
export function createTypeChecker(host) {
    var getPackagesMap = memoize(() => {
        var map2 = /* @__PURE__ */new Map();
        host.getSourceFiles().forEach(sf => {
            if (!sf.resolvedModules) return;
            sf.resolvedModules.forEach(({
                resolvedModule
            }) => {
                if (resolvedModule == null ? void 0 : resolvedModule.packageId) map2.set(resolvedModule.packageId.name, resolvedModule.extension === ".d.ts" || !!map2.get(resolvedModule.packageId.name));
            });
        });
        return map2;
    });
    var deferredDiagnosticsCallbacks = [];
    var addLazyDiagnostic = arg => {
        deferredDiagnosticsCallbacks.push(arg);
    };
    var cancellationToken;
    var requestedExternalEmitHelperNames = /* @__PURE__ */new Set();
    var requestedExternalEmitHelpers;
    var externalHelpersModule;
    var Symbol46 = objectAllocator.getSymbolConstructor();
    var Type27 = objectAllocator.getTypeConstructor();
    var Signature15 = objectAllocator.getSignatureConstructor();
    var typeCount = 0;
    var symbolCount = 0;
    var totalInstantiationCount = 0;
    var instantiationCount = 0;
    var instantiationDepth = 0;
    var inlineLevel = 0;
    var currentNode;
    var varianceTypeParameter;
    var isInferencePartiallyBlocked = false;
    var emptySymbols = createSymbolTable();
    var arrayVariances = [1];
    var compilerOptions = host.getCompilerOptions();
    var languageVersion = getEmitScriptTarget(compilerOptions);
    var moduleKind = getEmitModuleKind(compilerOptions);
    var legacyDecorators = !!compilerOptions.experimentalDecorators;
    var useDefineForClassFields = getUseDefineForClassFields(compilerOptions);
    var allowSyntheticDefaultImports = getAllowSyntheticDefaultImports(compilerOptions);
    var strictNullChecks = getStrictOptionValue(compilerOptions, "strictNullChecks");
    var strictFunctionTypes = getStrictOptionValue(compilerOptions, "strictFunctionTypes");
    var strictBindCallApply = getStrictOptionValue(compilerOptions, "strictBindCallApply");
    var strictPropertyInitialization = getStrictOptionValue(compilerOptions, "strictPropertyInitialization");
    var noImplicitAny = getStrictOptionValue(compilerOptions, "noImplicitAny");
    var noImplicitThis = getStrictOptionValue(compilerOptions, "noImplicitThis");
    var useUnknownInCatchVariables = getStrictOptionValue(compilerOptions, "useUnknownInCatchVariables");
    var keyofStringsOnly = !!compilerOptions.keyofStringsOnly;
    var freshObjectLiteralFlag = compilerOptions.suppressExcessPropertyErrors ? 0 : 8192;
    var exactOptionalPropertyTypes = compilerOptions.exactOptionalPropertyTypes;
    var checkBinaryExpression = createCheckBinaryExpression();
    var emitResolver = createResolver();
    var nodeBuilder = createNodeBuilder();
    var globals = createSymbolTable();
    var undefinedSymbol = createSymbol(4, "undefined");
    undefinedSymbol.declarations = [];
    var globalThisSymbol = createSymbol(1536, "globalThis", 8);
    globalThisSymbol.exports = globals;
    globalThisSymbol.declarations = [];
    globals.set(globalThisSymbol.escapedName, globalThisSymbol);
    var argumentsSymbol = createSymbol(4, "arguments");
    var requireSymbol = createSymbol(4, "require");
    var isolatedModulesLikeFlagName = compilerOptions.verbatimModuleSyntax ? "verbatimModuleSyntax" : "isolatedModules";
    var apparentArgumentCount;
    const checker = {
        getTypeCount: () => typeCount,
        getInstantiationCount: () => totalInstantiationCount,
        getRelationCacheSizes: () => ({
            assignable: assignableRelation.size,
            identity: identityRelation.size,
            subtype: subtypeRelation.size,
            strictSubtype: strictSubtypeRelation.size
        }),
        isUndefinedSymbol: symbol => symbol === undefinedSymbol,
        isArgumentsSymbol: symbol => symbol === argumentsSymbol,
        isUnknownSymbol: symbol => symbol === unknownSymbol,
        getMergedSymbol,
        getDiagnostics: getDiagnostics2,
        getGlobalDiagnostics,
        getRecursionIdentity,
        getUnmatchedProperties,
        getTypeOfSymbolAtLocation: (symbol, locationIn) => {
            const location = getParseTreeNode(locationIn);
            return location ? getTypeOfSymbolAtLocation(symbol, location) : errorType;
        },
        getTypeOfSymbol,
        getSymbolsOfParameterPropertyDeclaration: (parameterIn, parameterName) => {
            const parameter = getParseTreeNode(parameterIn, isParameter);
            if (parameter === void 0) return Debug.fail("Cannot get symbols of a synthetic parameter that cannot be resolved to a parse-tree node.");
            Debug.assert(isParameterPropertyDeclaration(parameter, parameter.parent));
            return getSymbolsOfParameterPropertyDeclaration(parameter, escapeLeadingUnderscores(parameterName));
        },
        getDeclaredTypeOfSymbol,
        getPropertiesOfType,
        getPropertyOfType: (type, name) => getPropertyOfType(type, escapeLeadingUnderscores(name)),
        getPrivateIdentifierPropertyOfType: (leftType, name, location) => {
            const node = getParseTreeNode(location);
            if (!node) {
                return void 0;
            }
            const propName = escapeLeadingUnderscores(name);
            const lexicallyScopedIdentifier = lookupSymbolForPrivateIdentifierDeclaration(propName, node);
            return lexicallyScopedIdentifier ? getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedIdentifier) : void 0;
        },
        getTypeOfPropertyOfType: (type, name) => getTypeOfPropertyOfType(type, escapeLeadingUnderscores(name)),
        getIndexInfoOfType: (type, kind) => getIndexInfoOfType(type, kind === 0 ? stringType : numberType),
        getIndexInfosOfType,
        getIndexInfosOfIndexSymbol,
        getSignaturesOfType,
        getIndexTypeOfType: (type, kind) => getIndexTypeOfType(type, kind === 0 ? stringType : numberType),
        getIndexType: type => getIndexType(type),
        getBaseTypes,
        getBaseTypeOfLiteralType,
        getWidenedType,
        getTypeFromTypeNode: nodeIn => {
            const node = getParseTreeNode(nodeIn, isTypeNode);
            return node ? getTypeFromTypeNode(node) : errorType;
        },
        getParameterType: getTypeAtPosition,
        getParameterIdentifierNameAtPosition,
        getPromisedTypeOfPromise,
        getAwaitedType: type => getAwaitedType(type),
        getReturnTypeOfSignature,
        isNullableType,
        getNullableType,
        getNonNullableType,
        getNonOptionalType: removeOptionalTypeMarker,
        getTypeArguments,
        typeToTypeNode: nodeBuilder.typeToTypeNode,
        indexInfoToIndexSignatureDeclaration: nodeBuilder.indexInfoToIndexSignatureDeclaration,
        signatureToSignatureDeclaration: nodeBuilder.signatureToSignatureDeclaration,
        symbolToEntityName: nodeBuilder.symbolToEntityName,
        symbolToExpression: nodeBuilder.symbolToExpression,
        symbolToNode: nodeBuilder.symbolToNode,
        symbolToTypeParameterDeclarations: nodeBuilder.symbolToTypeParameterDeclarations,
        symbolToParameterDeclaration: nodeBuilder.symbolToParameterDeclaration,
        typeParameterToDeclaration: nodeBuilder.typeParameterToDeclaration,
        getSymbolsInScope: (locationIn, meaning) => {
            const location = getParseTreeNode(locationIn);
            return location ? getSymbolsInScope(location, meaning) : [];
        },
        getSymbolAtLocation: nodeIn => {
            const node = getParseTreeNode(nodeIn);
            return node ? getSymbolAtLocation(node, true) : void 0;
        },
        getIndexInfosAtLocation: nodeIn => {
            const node = getParseTreeNode(nodeIn);
            return node ? getIndexInfosAtLocation(node) : void 0;
        },
        getShorthandAssignmentValueSymbol: nodeIn => {
            const node = getParseTreeNode(nodeIn);
            return node ? getShorthandAssignmentValueSymbol(node) : void 0;
        },
        getExportSpecifierLocalTargetSymbol: nodeIn => {
            const node = getParseTreeNode(nodeIn, isExportSpecifier);
            return node ? getExportSpecifierLocalTargetSymbol(node) : void 0;
        },
        getExportSymbolOfSymbol(symbol) {
            return getMergedSymbol(symbol.exportSymbol || symbol);
        },
        getTypeAtLocation: nodeIn => {
            const node = getParseTreeNode(nodeIn);
            return node ? getTypeOfNode(node) : errorType;
        },
        getTypeOfAssignmentPattern: nodeIn => {
            const node = getParseTreeNode(nodeIn, isAssignmentPattern);
            return node && getTypeOfAssignmentPattern(node) || errorType;
        },
        getPropertySymbolOfDestructuringAssignment: locationIn => {
            const location = getParseTreeNode(locationIn, isIdentifier);
            return location ? getPropertySymbolOfDestructuringAssignment(location) : void 0;
        },
        signatureToString: (signature, enclosingDeclaration, flags, kind) => {
            return signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind);
        },
        typeToString: (type, enclosingDeclaration, flags) => {
            return typeToString(type, getParseTreeNode(enclosingDeclaration), flags);
        },
        symbolToString: (symbol, enclosingDeclaration, meaning, flags) => {
            return symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags);
        },
        typePredicateToString: (predicate, enclosingDeclaration, flags) => {
            return typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags);
        },
        writeSignature: (signature, enclosingDeclaration, flags, kind, writer) => {
            return signatureToString(signature, getParseTreeNode(enclosingDeclaration), flags, kind, writer);
        },
        writeType: (type, enclosingDeclaration, flags, writer) => {
            return typeToString(type, getParseTreeNode(enclosingDeclaration), flags, writer);
        },
        writeSymbol: (symbol, enclosingDeclaration, meaning, flags, writer) => {
            return symbolToString(symbol, getParseTreeNode(enclosingDeclaration), meaning, flags, writer);
        },
        writeTypePredicate: (predicate, enclosingDeclaration, flags, writer) => {
            return typePredicateToString(predicate, getParseTreeNode(enclosingDeclaration), flags, writer);
        },
        getAugmentedPropertiesOfType,
        getRootSymbols,
        getSymbolOfExpando,
        getContextualType: (nodeIn, contextFlags) => {
            const node = getParseTreeNode(nodeIn, isExpression);
            if (!node) {
                return void 0;
            }
            if (contextFlags & 4) {
                return runWithInferenceBlockedFromSourceNode(node, () => getContextualType2(node, contextFlags));
            }
            return getContextualType2(node, contextFlags);
        },
        getContextualTypeForObjectLiteralElement: nodeIn => {
            const node = getParseTreeNode(nodeIn, isObjectLiteralElementLike);
            return node ? getContextualTypeForObjectLiteralElement(node, void 0) : void 0;
        },
        getContextualTypeForArgumentAtIndex: (nodeIn, argIndex) => {
            const node = getParseTreeNode(nodeIn, isCallLikeExpression);
            return node && getContextualTypeForArgumentAtIndex(node, argIndex);
        },
        getContextualTypeForJsxAttribute: nodeIn => {
            const node = getParseTreeNode(nodeIn, isJsxAttributeLike);
            return node && getContextualTypeForJsxAttribute(node, void 0);
        },
        isContextSensitive,
        getTypeOfPropertyOfContextualType,
        getFullyQualifiedName,
        getResolvedSignature: (node, candidatesOutArray, argumentCount) => getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, 0),
        getResolvedSignatureForStringLiteralCompletions: (call, editingArgument, candidatesOutArray) => runWithInferenceBlockedFromSourceNode(editingArgument, () => getResolvedSignatureWorker(call, candidatesOutArray, void 0, 32)),
        getResolvedSignatureForSignatureHelp: (node, candidatesOutArray, argumentCount) => runWithoutResolvedSignatureCaching(node, () => getResolvedSignatureWorker(node, candidatesOutArray, argumentCount, 16)),
        getExpandedParameters,
        hasEffectiveRestParameter,
        containsArgumentsReference,
        getConstantValue: nodeIn => {
            const node = getParseTreeNode(nodeIn, canHaveConstantValue);
            return node ? getConstantValue2(node) : void 0;
        },
        isValidPropertyAccess: (nodeIn, propertyName) => {
            const node = getParseTreeNode(nodeIn, isPropertyAccessOrQualifiedNameOrImportTypeNode);
            return !!node && isValidPropertyAccess(node, escapeLeadingUnderscores(propertyName));
        },
        isValidPropertyAccessForCompletions: (nodeIn, type, property) => {
            const node = getParseTreeNode(nodeIn, isPropertyAccessExpression);
            return !!node && isValidPropertyAccessForCompletions(node, type, property);
        },
        getSignatureFromDeclaration: declarationIn => {
            const declaration = getParseTreeNode(declarationIn, isFunctionLike);
            return declaration ? getSignatureFromDeclaration(declaration) : void 0;
        },
        isImplementationOfOverload: nodeIn => {
            const node = getParseTreeNode(nodeIn, isFunctionLike);
            return node ? isImplementationOfOverload(node) : void 0;
        },
        getImmediateAliasedSymbol,
        getAliasedSymbol: resolveAlias,
        getEmitResolver,
        getExportsOfModule: getExportsOfModuleAsArray,
        getExportsAndPropertiesOfModule,
        forEachExportAndPropertyOfModule,
        getSymbolWalker: createGetSymbolWalker(getRestTypeOfSignature, getTypePredicateOfSignature, getReturnTypeOfSignature, getBaseTypes, resolveStructuredTypeMembers, getTypeOfSymbol, getResolvedSymbol, getConstraintOfTypeParameter, getFirstIdentifier, getTypeArguments),
        getAmbientModules,
        getJsxIntrinsicTagNamesAt,
        isOptionalParameter: nodeIn => {
            const node = getParseTreeNode(nodeIn, isParameter);
            return node ? isOptionalParameter(node) : false;
        },
        tryGetMemberInModuleExports: (name, symbol) => tryGetMemberInModuleExports(escapeLeadingUnderscores(name), symbol),
        tryGetMemberInModuleExportsAndProperties: (name, symbol) => tryGetMemberInModuleExportsAndProperties(escapeLeadingUnderscores(name), symbol),
        tryFindAmbientModule: moduleName => tryFindAmbientModule(moduleName, true),
        tryFindAmbientModuleWithoutAugmentations: moduleName => {
            return tryFindAmbientModule(moduleName, false);
        },
        getApparentType,
        getUnionType,
        isTypeAssignableTo,
        createAnonymousType,
        createSignature,
        createSymbol,
        createIndexInfo,
        getAnyType: () => anyType,
        getStringType: () => stringType,
        getNumberType: () => numberType,
        createPromiseType,
        createArrayType,
        getElementTypeOfArrayType,
        getBooleanType: () => booleanType,
        getFalseType: fresh => fresh ? falseType : regularFalseType,
        getTrueType: fresh => fresh ? trueType : regularTrueType,
        getVoidType: () => voidType,
        getUndefinedType: () => undefinedType,
        getNullType: () => nullType,
        getESSymbolType: () => esSymbolType,
        getNeverType: () => neverType,
        getOptionalType: () => optionalType,
        getPromiseType: () => getGlobalPromiseType(false),
        getPromiseLikeType: () => getGlobalPromiseLikeType(false),
        getAsyncIterableType: () => {
            const type = getGlobalAsyncIterableType(false);
            if (type === emptyGenericType) return void 0;
            return type;
        },
        isSymbolAccessible,
        isArrayType,
        isTupleType,
        isArrayLikeType,
        isEmptyAnonymousObjectType,
        isTypeInvalidDueToUnionDiscriminant,
        getExactOptionalProperties,
        getAllPossiblePropertiesOfTypes,
        getSuggestedSymbolForNonexistentProperty,
        getSuggestionForNonexistentProperty,
        getSuggestedSymbolForNonexistentJSXAttribute,
        getSuggestedSymbolForNonexistentSymbol: (location, name, meaning) => getSuggestedSymbolForNonexistentSymbol(location, escapeLeadingUnderscores(name), meaning),
        getSuggestionForNonexistentSymbol: (location, name, meaning) => getSuggestionForNonexistentSymbol(location, escapeLeadingUnderscores(name), meaning),
        getSuggestedSymbolForNonexistentModule,
        getSuggestionForNonexistentExport,
        getSuggestedSymbolForNonexistentClassMember,
        getBaseConstraintOfType,
        getDefaultFromTypeParameter: type => type && type.flags & 262144 ? getDefaultFromTypeParameter(type) : void 0,
        resolveName(name, location, meaning, excludeGlobals) {
            return resolveName(location, escapeLeadingUnderscores(name), meaning, void 0, void 0, false, excludeGlobals);
        },
        getJsxNamespace: n => unescapeLeadingUnderscores(getJsxNamespace(n)),
        getJsxFragmentFactory: n => {
            const jsxFragmentFactory = getJsxFragmentFactoryEntity(n);
            return jsxFragmentFactory && unescapeLeadingUnderscores(getFirstIdentifier(jsxFragmentFactory).escapedText);
        },
        getAccessibleSymbolChain,
        getTypePredicateOfSignature,
        resolveExternalModuleName: moduleSpecifierIn => {
            const moduleSpecifier = getParseTreeNode(moduleSpecifierIn, isExpression);
            return moduleSpecifier && resolveExternalModuleName(moduleSpecifier, moduleSpecifier, true);
        },
        resolveExternalModuleSymbol,
        tryGetThisTypeAt: (nodeIn, includeGlobalThis, container) => {
            const node = getParseTreeNode(nodeIn);
            return node && tryGetThisTypeAt(node, includeGlobalThis, container);
        },
        getTypeArgumentConstraint: nodeIn => {
            const node = getParseTreeNode(nodeIn, isTypeNode);
            return node && getTypeArgumentConstraint(node);
        },
        getSuggestionDiagnostics: (fileIn, ct) => {
            const file = getParseTreeNode(fileIn, isSourceFile) || Debug.fail("Could not determine parsed source file.");
            if (skipTypeChecking(file, compilerOptions, host)) {
                return emptyArray;
            }
            let diagnostics2;
            try {
                cancellationToken = ct;
                checkSourceFileWithEagerDiagnostics(file);
                Debug.assert(!!(getNodeLinks(file).flags & 1));
                diagnostics2 = addRange(diagnostics2, suggestionDiagnostics.getDiagnostics(file.fileName));
                checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(file), (containingNode, kind, diag2) => {
                    if (!containsParseError(containingNode) && !unusedIsError(kind, !!(containingNode.flags & 16777216))) {
                        (diagnostics2 || (diagnostics2 = [])).push({
                            ...diag2,
                            category: 2
                        });
                    }
                });
                return diagnostics2 || emptyArray;
            } finally {
                cancellationToken = void 0;
            }
        },
        runWithCancellationToken: (token, callback) => {
            try {
                cancellationToken = token;
                return callback(checker);
            } finally {
                cancellationToken = void 0;
            }
        },
        getLocalTypeParametersOfClassOrInterfaceOrTypeAlias,
        isDeclarationVisible,
        isPropertyAccessible,
        getTypeOnlyAliasDeclaration,
        getMemberOverrideModifierStatus,
        isTypeParameterPossiblyReferenced,
        typeHasCallOrConstructSignatures
    };
    function runWithoutResolvedSignatureCaching(node, fn) {
        const containingCall = findAncestor(node, isCallLikeExpression);
        const containingCallResolvedSignature = containingCall && getNodeLinks(containingCall).resolvedSignature;
        if (containingCall) {
            getNodeLinks(containingCall).resolvedSignature = void 0;
        }
        const result = fn();
        if (containingCall) {
            getNodeLinks(containingCall).resolvedSignature = containingCallResolvedSignature;
        }
        return result;
    }
    function runWithInferenceBlockedFromSourceNode(node, fn) {
        const containingCall = findAncestor(node, isCallLikeExpression);
        if (containingCall) {
            let toMarkSkip = node;
            do {
                getNodeLinks(toMarkSkip).skipDirectInference = true;
                toMarkSkip = toMarkSkip.parent;
            } while (toMarkSkip && toMarkSkip !== containingCall);
        }
        isInferencePartiallyBlocked = true;
        const result = runWithoutResolvedSignatureCaching(node, fn);
        isInferencePartiallyBlocked = false;
        if (containingCall) {
            let toMarkSkip = node;
            do {
                getNodeLinks(toMarkSkip).skipDirectInference = void 0;
                toMarkSkip = toMarkSkip.parent;
            } while (toMarkSkip && toMarkSkip !== containingCall);
        }
        return result;
    }
    function getResolvedSignatureWorker(nodeIn, candidatesOutArray, argumentCount, checkMode) {
        const node = getParseTreeNode(nodeIn, isCallLikeExpression);
        apparentArgumentCount = argumentCount;
        const res = !node ? void 0 : getResolvedSignature(node, candidatesOutArray, checkMode);
        apparentArgumentCount = void 0;
        return res;
    }
    var tupleTypes = /* @__PURE__ */new Map();
    var unionTypes = /* @__PURE__ */new Map();
    var intersectionTypes = /* @__PURE__ */new Map();
    var stringLiteralTypes = /* @__PURE__ */new Map();
    var numberLiteralTypes = /* @__PURE__ */new Map();
    var bigIntLiteralTypes = /* @__PURE__ */new Map();
    var enumLiteralTypes = /* @__PURE__ */new Map();
    var indexedAccessTypes = /* @__PURE__ */new Map();
    var templateLiteralTypes = /* @__PURE__ */new Map();
    var stringMappingTypes = /* @__PURE__ */new Map();
    var substitutionTypes = /* @__PURE__ */new Map();
    var subtypeReductionCache = /* @__PURE__ */new Map();
    var decoratorContextOverrideTypeCache = /* @__PURE__ */new Map();
    var cachedTypes = /* @__PURE__ */new Map();
    var evolvingArrayTypes = [];
    var undefinedProperties = /* @__PURE__ */new Map();
    var markerTypes = /* @__PURE__ */new Set();
    var unknownSymbol = createSymbol(4, "unknown");
    var resolvingSymbol = createSymbol(0, "__resolving__");
    var unresolvedSymbols = /* @__PURE__ */new Map();
    var errorTypes = /* @__PURE__ */new Map();
    var anyType = createIntrinsicType(1, "any");
    var autoType = createIntrinsicType(1, "any", 262144);
    var wildcardType = createIntrinsicType(1, "any");
    var errorType = createIntrinsicType(1, "error");
    var unresolvedType = createIntrinsicType(1, "unresolved");
    var nonInferrableAnyType = createIntrinsicType(1, "any", 65536);
    var intrinsicMarkerType = createIntrinsicType(1, "intrinsic");
    var unknownType = createIntrinsicType(2, "unknown");
    var nonNullUnknownType = createIntrinsicType(2, "unknown");
    var undefinedType = createIntrinsicType(32768, "undefined");
    var undefinedWideningType = strictNullChecks ? undefinedType : createIntrinsicType(32768, "undefined", 65536);
    var missingType = createIntrinsicType(32768, "undefined");
    var undefinedOrMissingType = exactOptionalPropertyTypes ? missingType : undefinedType;
    var optionalType = createIntrinsicType(32768, "undefined");
    var nullType = createIntrinsicType(65536, "null");
    var nullWideningType = strictNullChecks ? nullType : createIntrinsicType(65536, "null", 65536);
    var stringType = createIntrinsicType(4, "string");
    var numberType = createIntrinsicType(8, "number");
    var bigintType = createIntrinsicType(64, "bigint");
    var falseType = createIntrinsicType(512, "false");
    var regularFalseType = createIntrinsicType(512, "false");
    var trueType = createIntrinsicType(512, "true");
    var regularTrueType = createIntrinsicType(512, "true");
    trueType.regularType = regularTrueType;
    trueType.freshType = trueType;
    regularTrueType.regularType = regularTrueType;
    regularTrueType.freshType = trueType;
    falseType.regularType = regularFalseType;
    falseType.freshType = falseType;
    regularFalseType.regularType = regularFalseType;
    regularFalseType.freshType = falseType;
    var booleanType = getUnionType([regularFalseType, regularTrueType]);
    var esSymbolType = createIntrinsicType(4096, "symbol");
    var voidType = createIntrinsicType(16384, "void");
    var neverType = createIntrinsicType(131072, "never");
    var silentNeverType = createIntrinsicType(131072, "never", 262144);
    var implicitNeverType = createIntrinsicType(131072, "never");
    var unreachableNeverType = createIntrinsicType(131072, "never");
    var nonPrimitiveType = createIntrinsicType(67108864, "object");
    var stringOrNumberType = getUnionType([stringType, numberType]);
    var stringNumberSymbolType = getUnionType([stringType, numberType, esSymbolType]);
    var keyofConstraintType = keyofStringsOnly ? stringType : stringNumberSymbolType;
    var numberOrBigIntType = getUnionType([numberType, bigintType]);
    var templateConstraintType = getUnionType([stringType, numberType, booleanType, bigintType, nullType, undefinedType]);
    var numericStringType = getTemplateLiteralType(["", ""], [numberType]);
    var restrictiveMapper = makeFunctionTypeMapper(t => t.flags & 262144 ? getRestrictiveTypeParameter(t) : t, () => "(restrictive mapper)");
    var permissiveMapper = makeFunctionTypeMapper(t => t.flags & 262144 ? wildcardType : t, () => "(permissive mapper)");
    var uniqueLiteralType = createIntrinsicType(131072, "never");
    var uniqueLiteralMapper = makeFunctionTypeMapper(t => t.flags & 262144 ? uniqueLiteralType : t, () => "(unique literal mapper)");
    var outofbandVarianceMarkerHandler;
    var reportUnmeasurableMapper = makeFunctionTypeMapper(t => {
        if (outofbandVarianceMarkerHandler && (t === markerSuperType || t === markerSubType || t === markerOtherType)) {
            outofbandVarianceMarkerHandler(false);
        }
        return t;
    }, () => "(unreliable reporter)");
    var emptyObjectType = createAnonymousType(void 0, emptySymbols, emptyArray, emptyArray, emptyArray);
    var emptyJsxObjectType = createAnonymousType(void 0, emptySymbols, emptyArray, emptyArray, emptyArray);
    emptyJsxObjectType.objectFlags |= 2048;
    var emptyTypeLiteralSymbol = createSymbol(2048, "__type");
    emptyTypeLiteralSymbol.members = createSymbolTable();
    var emptyTypeLiteralType = createAnonymousType(emptyTypeLiteralSymbol, emptySymbols, emptyArray, emptyArray, emptyArray);
    var unknownEmptyObjectType = createAnonymousType(void 0, emptySymbols, emptyArray, emptyArray, emptyArray);
    var unknownUnionType = strictNullChecks ? getUnionType([undefinedType, nullType, unknownEmptyObjectType]) : unknownType;
    var emptyGenericType = createAnonymousType(void 0, emptySymbols, emptyArray, emptyArray, emptyArray);
    emptyGenericType.instantiations = /* @__PURE__ */new Map();
    var anyFunctionType = createAnonymousType(void 0, emptySymbols, emptyArray, emptyArray, emptyArray);
    anyFunctionType.objectFlags |= 262144;
    var noConstraintType = createAnonymousType(void 0, emptySymbols, emptyArray, emptyArray, emptyArray);
    var circularConstraintType = createAnonymousType(void 0, emptySymbols, emptyArray, emptyArray, emptyArray);
    var resolvingDefaultType = createAnonymousType(void 0, emptySymbols, emptyArray, emptyArray, emptyArray);
    var markerSuperType = createTypeParameter();
    var markerSubType = createTypeParameter();
    markerSubType.constraint = markerSuperType;
    var markerOtherType = createTypeParameter();
    var markerSuperTypeForCheck = createTypeParameter();
    var markerSubTypeForCheck = createTypeParameter();
    markerSubTypeForCheck.constraint = markerSuperTypeForCheck;
    var noTypePredicate = createTypePredicate(1, "<<unresolved>>", 0, anyType);
    var anySignature = createSignature(void 0, void 0, void 0, emptyArray, anyType, void 0, 0, 0);
    var unknownSignature = createSignature(void 0, void 0, void 0, emptyArray, errorType, void 0, 0, 0);
    var resolvingSignature = createSignature(void 0, void 0, void 0, emptyArray, anyType, void 0, 0, 0);
    var silentNeverSignature = createSignature(void 0, void 0, void 0, emptyArray, silentNeverType, void 0, 0, 0);
    var enumNumberIndexInfo = createIndexInfo(numberType, stringType, true);
    var iterationTypesCache = /* @__PURE__ */new Map();
    var noIterationTypes = {
        get yieldType() {
            return Debug.fail("Not supported");
        },
        get returnType() {
            return Debug.fail("Not supported");
        },
        get nextType() {
            return Debug.fail("Not supported");
        }
    };
    var anyIterationTypes = createIterationTypes(anyType, anyType, anyType);
    var anyIterationTypesExceptNext = createIterationTypes(anyType, anyType, unknownType);
    var defaultIterationTypes = createIterationTypes(neverType, anyType, undefinedType);
    var asyncIterationTypesResolver = {
        iterableCacheKey: "iterationTypesOfAsyncIterable",
        iteratorCacheKey: "iterationTypesOfAsyncIterator",
        iteratorSymbolName: "asyncIterator",
        getGlobalIteratorType: getGlobalAsyncIteratorType,
        getGlobalIterableType: getGlobalAsyncIterableType,
        getGlobalIterableIteratorType: getGlobalAsyncIterableIteratorType,
        getGlobalGeneratorType: getGlobalAsyncGeneratorType,
        resolveIterationType: getAwaitedType,
        mustHaveANextMethodDiagnostic: Diagnostics.An_async_iterator_must_have_a_next_method,
        mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_async_iterator_must_be_a_method,
        mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property
    };
    var syncIterationTypesResolver = {
        iterableCacheKey: "iterationTypesOfIterable",
        iteratorCacheKey: "iterationTypesOfIterator",
        iteratorSymbolName: "iterator",
        getGlobalIteratorType,
        getGlobalIterableType,
        getGlobalIterableIteratorType,
        getGlobalGeneratorType,
        resolveIterationType: (type, _errorNode) => type,
        mustHaveANextMethodDiagnostic: Diagnostics.An_iterator_must_have_a_next_method,
        mustBeAMethodDiagnostic: Diagnostics.The_0_property_of_an_iterator_must_be_a_method,
        mustHaveAValueDiagnostic: Diagnostics.The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property
    };
    var amalgamatedDuplicates;
    var reverseMappedCache = /* @__PURE__ */new Map();
    var inInferTypeForHomomorphicMappedType = false;
    var patternAmbientModules;
    var patternAmbientModuleAugmentations;
    var globalObjectType;
    var globalFunctionType;
    var globalCallableFunctionType;
    var globalNewableFunctionType;
    var globalArrayType;
    var globalReadonlyArrayType;
    var globalStringType;
    var globalNumberType;
    var globalBooleanType;
    var globalRegExpType;
    var globalThisType;
    var anyArrayType;
    var autoArrayType;
    var anyReadonlyArrayType;
    var deferredGlobalNonNullableTypeAlias;
    var deferredGlobalESSymbolConstructorSymbol;
    var deferredGlobalESSymbolConstructorTypeSymbol;
    var deferredGlobalESSymbolType;
    var deferredGlobalTypedPropertyDescriptorType;
    var deferredGlobalPromiseType;
    var deferredGlobalPromiseLikeType;
    var deferredGlobalPromiseConstructorSymbol;
    var deferredGlobalPromiseConstructorLikeType;
    var deferredGlobalIterableType;
    var deferredGlobalIteratorType;
    var deferredGlobalIterableIteratorType;
    var deferredGlobalGeneratorType;
    var deferredGlobalIteratorYieldResultType;
    var deferredGlobalIteratorReturnResultType;
    var deferredGlobalAsyncIterableType;
    var deferredGlobalAsyncIteratorType;
    var deferredGlobalAsyncIterableIteratorType;
    var deferredGlobalAsyncGeneratorType;
    var deferredGlobalTemplateStringsArrayType;
    var deferredGlobalImportMetaType;
    var deferredGlobalImportMetaExpressionType;
    var deferredGlobalImportCallOptionsType;
    var deferredGlobalExtractSymbol;
    var deferredGlobalOmitSymbol;
    var deferredGlobalAwaitedSymbol;
    var deferredGlobalBigIntType;
    var deferredGlobalNaNSymbol;
    var deferredGlobalRecordSymbol;
    var deferredGlobalClassDecoratorContextType;
    var deferredGlobalClassMethodDecoratorContextType;
    var deferredGlobalClassGetterDecoratorContextType;
    var deferredGlobalClassSetterDecoratorContextType;
    var deferredGlobalClassAccessorDecoratorContextType;
    var deferredGlobalClassAccessorDecoratorTargetType;
    var deferredGlobalClassAccessorDecoratorResultType;
    var deferredGlobalClassFieldDecoratorContextType;
    var allPotentiallyUnusedIdentifiers = /* @__PURE__ */new Map();
    var flowLoopStart = 0;
    var flowLoopCount = 0;
    var sharedFlowCount = 0;
    var flowAnalysisDisabled = false;
    var flowInvocationCount = 0;
    var lastFlowNode;
    var lastFlowNodeReachable;
    var flowTypeCache;
    var contextualTypeNodes = [];
    var contextualTypes = [];
    var contextualIsCache = [];
    var contextualTypeCount = 0;
    var inferenceContextNodes = [];
    var inferenceContexts = [];
    var inferenceContextCount = 0;
    var emptyStringType = getStringLiteralType("");
    var zeroType = getNumberLiteralType(0);
    var zeroBigIntType = getBigIntLiteralType({
        negative: false,
        base10Value: "0"
    });
    var resolutionTargets = [];
    var resolutionResults = [];
    var resolutionPropertyNames = [];
    var suggestionCount = 0;
    var maximumSuggestionCount = 10;
    var mergedSymbols = [];
    var symbolLinks = [];
    var nodeLinks = [];
    var flowLoopCaches = [];
    var flowLoopNodes = [];
    var flowLoopKeys = [];
    var flowLoopTypes = [];
    var sharedFlowNodes = [];
    var sharedFlowTypes = [];
    var flowNodeReachable = [];
    var flowNodePostSuper = [];
    var potentialThisCollisions = [];
    var potentialNewTargetCollisions = [];
    var potentialWeakMapSetCollisions = [];
    var potentialReflectCollisions = [];
    var potentialUnusedRenamedBindingElementsInTypes = [];
    var awaitedTypeStack = [];
    var diagnostics = createDiagnosticCollection();
    var suggestionDiagnostics = createDiagnosticCollection();
    var typeofType = createTypeofType();
    var _jsxNamespace;
    var _jsxFactoryEntity;
    var subtypeRelation = /* @__PURE__ */new Map();
    var strictSubtypeRelation = /* @__PURE__ */new Map();
    var assignableRelation = /* @__PURE__ */new Map();
    var comparableRelation = /* @__PURE__ */new Map();
    var identityRelation = /* @__PURE__ */new Map();
    var enumRelation = /* @__PURE__ */new Map();
    var builtinGlobals = createSymbolTable();
    builtinGlobals.set(undefinedSymbol.escapedName, undefinedSymbol);
    var suggestedExtensions = [[".mts", ".mjs"], [".ts", ".js"], [".cts", ".cjs"], [".mjs", ".mjs"], [".js", ".js"], [".cjs", ".cjs"], [".tsx", compilerOptions.jsx === 1 ? ".jsx" : ".js"], [".jsx", ".jsx"], [".json", ".json"]];
    initializeTypeChecker();
    return checker;
    function getCachedType(key) {
        return key ? cachedTypes.get(key) : void 0;
    }
    function setCachedType(key, type) {
        if (key) cachedTypes.set(key, type);
        return type;
    }
    function getJsxNamespace(location) {
        if (location) {
            const file = getSourceFileOfNode(location);
            if (file) {
                if (isJsxOpeningFragment(location)) {
                    if (file.localJsxFragmentNamespace) {
                        return file.localJsxFragmentNamespace;
                    }
                    const jsxFragmentPragma = file.pragmas.get("jsxfrag");
                    if (jsxFragmentPragma) {
                        const chosenPragma = isArray(jsxFragmentPragma) ? jsxFragmentPragma[0] : jsxFragmentPragma;
                        file.localJsxFragmentFactory = parseIsolatedEntityName(chosenPragma.arguments.factory, languageVersion);
                        visitNode(file.localJsxFragmentFactory, markAsSynthetic, isEntityName);
                        if (file.localJsxFragmentFactory) {
                            return file.localJsxFragmentNamespace = getFirstIdentifier(file.localJsxFragmentFactory).escapedText;
                        }
                    }
                    const entity = getJsxFragmentFactoryEntity(location);
                    if (entity) {
                        file.localJsxFragmentFactory = entity;
                        return file.localJsxFragmentNamespace = getFirstIdentifier(entity).escapedText;
                    }
                } else {
                    const localJsxNamespace = getLocalJsxNamespace(file);
                    if (localJsxNamespace) {
                        return file.localJsxNamespace = localJsxNamespace;
                    }
                }
            }
        }
        if (!_jsxNamespace) {
            _jsxNamespace = "React";
            if (compilerOptions.jsxFactory) {
                _jsxFactoryEntity = parseIsolatedEntityName(compilerOptions.jsxFactory, languageVersion);
                visitNode(_jsxFactoryEntity, markAsSynthetic);
                if (_jsxFactoryEntity) {
                    _jsxNamespace = getFirstIdentifier(_jsxFactoryEntity).escapedText;
                }
            } else if (compilerOptions.reactNamespace) {
                _jsxNamespace = escapeLeadingUnderscores(compilerOptions.reactNamespace);
            }
        }
        if (!_jsxFactoryEntity) {
            _jsxFactoryEntity = factory.createQualifiedName(factory.createIdentifier(unescapeLeadingUnderscores(_jsxNamespace)), "createElement");
        }
        return _jsxNamespace;
    }
    function getLocalJsxNamespace(file) {
        if (file.localJsxNamespace) {
            return file.localJsxNamespace;
        }
        const jsxPragma = file.pragmas.get("jsx");
        if (jsxPragma) {
            const chosenPragma = isArray(jsxPragma) ? jsxPragma[0] : jsxPragma;
            file.localJsxFactory = parseIsolatedEntityName(chosenPragma.arguments.factory, languageVersion);
            visitNode(file.localJsxFactory, markAsSynthetic, isEntityName);
            if (file.localJsxFactory) {
                return file.localJsxNamespace = getFirstIdentifier(file.localJsxFactory).escapedText;
            }
        }
    }
    function markAsSynthetic(node) {
        setTextRangePosEnd(node, -1, -1);
        return visitEachChild(node, markAsSynthetic, nullTransformationContext);
    }
    function getEmitResolver(sourceFile, cancellationToken2) {
        getDiagnostics2(sourceFile, cancellationToken2);
        return emitResolver;
    }
    function lookupOrIssueError(location, message, arg0, arg1, arg2, arg3) {
        const diagnostic = location ? createDiagnosticForNode(location, message, arg0, arg1, arg2, arg3) : createCompilerDiagnostic(message, arg0, arg1, arg2, arg3);
        const existing = diagnostics.lookup(diagnostic);
        if (existing) {
            return existing;
        } else {
            diagnostics.add(diagnostic);
            return diagnostic;
        }
    }
    function errorSkippedOn(key, location, message, arg0, arg1, arg2, arg3) {
        const diagnostic = error(location, message, arg0, arg1, arg2, arg3);
        diagnostic.skippedOn = key;
        return diagnostic;
    }
    function createError(location, message, arg0, arg1, arg2, arg3) {
        return location ? createDiagnosticForNode(location, message, arg0, arg1, arg2, arg3) : createCompilerDiagnostic(message, arg0, arg1, arg2, arg3);
    }
    function error(location, message, arg0, arg1, arg2, arg3) {
        const diagnostic = createError(location, message, arg0, arg1, arg2, arg3);
        diagnostics.add(diagnostic);
        return diagnostic;
    }
    function addErrorOrSuggestion(isError, diagnostic) {
        if (isError) {
            diagnostics.add(diagnostic);
        } else {
            suggestionDiagnostics.add({
                ...diagnostic,
                category: 2
            });
        }
    }
    function errorOrSuggestion(isError, location, message, arg0, arg1, arg2, arg3) {
        if (location.pos < 0 || location.end < 0) {
            if (!isError) {
                return;
            }
            const file = getSourceFileOfNode(location);
            addErrorOrSuggestion(isError, "message" in message ? createFileDiagnostic(file, 0, 0, message, arg0, arg1, arg2, arg3) : createDiagnosticForFileFromMessageChain(file, message));
            return;
        }
        addErrorOrSuggestion(isError, "message" in message ? createDiagnosticForNode(location, message, arg0, arg1, arg2, arg3) : createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(location), location, message));
    }
    function errorAndMaybeSuggestAwait(location, maybeMissingAwait, message, arg0, arg1, arg2, arg3) {
        const diagnostic = error(location, message, arg0, arg1, arg2, arg3);
        if (maybeMissingAwait) {
            const related = createDiagnosticForNode(location, Diagnostics.Did_you_forget_to_use_await);
            addRelatedInfo(diagnostic, related);
        }
        return diagnostic;
    }
    function addDeprecatedSuggestionWorker(declarations, diagnostic) {
        const deprecatedTag = Array.isArray(declarations) ? forEach(declarations, getJSDocDeprecatedTag) : getJSDocDeprecatedTag(declarations);
        if (deprecatedTag) {
            addRelatedInfo(diagnostic, createDiagnosticForNode(deprecatedTag, Diagnostics.The_declaration_was_marked_as_deprecated_here));
        }
        suggestionDiagnostics.add(diagnostic);
        return diagnostic;
    }
    function isDeprecatedSymbol(symbol) {
        if (length(symbol.declarations) > 1) {
            const parentSymbol = getParentOfSymbol(symbol);
            if (parentSymbol && parentSymbol.flags & 64) {
                return some(symbol.declarations, d => !!(getCombinedNodeFlags(d) & 268435456));
            }
        }
        return !!(getDeclarationNodeFlagsFromSymbol(symbol) & 268435456);
    }
    function addDeprecatedSuggestion(location, declarations, deprecatedEntity) {
        const diagnostic = createDiagnosticForNode(location, Diagnostics._0_is_deprecated, deprecatedEntity);
        return addDeprecatedSuggestionWorker(declarations, diagnostic);
    }
    function addDeprecatedSuggestionWithSignature(location, declaration, deprecatedEntity, signatureString) {
        const diagnostic = deprecatedEntity ? createDiagnosticForNode(location, Diagnostics.The_signature_0_of_1_is_deprecated, signatureString, deprecatedEntity) : createDiagnosticForNode(location, Diagnostics._0_is_deprecated, signatureString);
        return addDeprecatedSuggestionWorker(declaration, diagnostic);
    }
    function createSymbol(flags, name, checkFlags) {
        symbolCount++;
        const symbol = new Symbol46(flags | 33554432, name);
        symbol.links = new SymbolLinks();
        symbol.links.checkFlags = checkFlags || 0;
        return symbol;
    }
    function createParameter(name, type) {
        const symbol = createSymbol(1, name);
        symbol.links.type = type;
        return symbol;
    }
    function createProperty(name, type) {
        const symbol = createSymbol(4, name);
        symbol.links.type = type;
        return symbol;
    }
    function getExcludedSymbolFlags(flags) {
        let result = 0;
        if (flags & 2) result |= 111551;
        if (flags & 1) result |= 111550;
        if (flags & 4) result |= 0;
        if (flags & 8) result |= 900095;
        if (flags & 16) result |= 110991;
        if (flags & 32) result |= 899503;
        if (flags & 64) result |= 788872;
        if (flags & 256) result |= 899327;
        if (flags & 128) result |= 899967;
        if (flags & 512) result |= 110735;
        if (flags & 8192) result |= 103359;
        if (flags & 32768) result |= 46015;
        if (flags & 65536) result |= 78783;
        if (flags & 262144) result |= 526824;
        if (flags & 524288) result |= 788968;
        if (flags & 2097152) result |= 2097152;
        return result;
    }
    function recordMergedSymbol(target, source) {
        if (!source.mergeId) {
            source.mergeId = nextMergeId;
            nextMergeId++;
        }
        mergedSymbols[source.mergeId] = target;
    }
    function cloneSymbol(symbol) {
        const result = createSymbol(symbol.flags, symbol.escapedName);
        result.declarations = symbol.declarations ? symbol.declarations.slice() : [];
        result.parent = symbol.parent;
        if (symbol.valueDeclaration) result.valueDeclaration = symbol.valueDeclaration;
        if (symbol.constEnumOnlyModule) result.constEnumOnlyModule = true;
        if (symbol.members) result.members = new Map(symbol.members);
        if (symbol.exports) result.exports = new Map(symbol.exports);
        recordMergedSymbol(result, symbol);
        return result;
    }
    function mergeSymbol(target, source, unidirectional = false) {
        if (!(target.flags & getExcludedSymbolFlags(source.flags)) || (source.flags | target.flags) & 67108864) {
            if (source === target) {
                return target;
            }
            if (!(target.flags & 33554432)) {
                const resolvedTarget = resolveSymbol(target);
                if (resolvedTarget === unknownSymbol) {
                    return source;
                }
                target = cloneSymbol(resolvedTarget);
            }
            if (source.flags & 512 && target.flags & 512 && target.constEnumOnlyModule && !source.constEnumOnlyModule) {
                target.constEnumOnlyModule = false;
            }
            target.flags |= source.flags;
            if (source.valueDeclaration) {
                setValueDeclaration(target, source.valueDeclaration);
            }
            addRange(target.declarations, source.declarations);
            if (source.members) {
                if (!target.members) target.members = createSymbolTable();
                mergeSymbolTable(target.members, source.members, unidirectional);
            }
            if (source.exports) {
                if (!target.exports) target.exports = createSymbolTable();
                mergeSymbolTable(target.exports, source.exports, unidirectional);
            }
            if (!unidirectional) {
                recordMergedSymbol(target, source);
            }
        } else if (target.flags & 1024) {
            if (target !== globalThisSymbol) {
                error(source.declarations && getNameOfDeclaration(source.declarations[0]), Diagnostics.Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity, symbolToString(target));
            }
        } else {
            const isEitherEnum = !!(target.flags & 384 || source.flags & 384);
            const isEitherBlockScoped = !!(target.flags & 2 || source.flags & 2);
            const message = isEitherEnum ? Diagnostics.Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations : isEitherBlockScoped ? Diagnostics.Cannot_redeclare_block_scoped_variable_0 : Diagnostics.Duplicate_identifier_0;
            const sourceSymbolFile = source.declarations && getSourceFileOfNode(source.declarations[0]);
            const targetSymbolFile = target.declarations && getSourceFileOfNode(target.declarations[0]);
            const isSourcePlainJs = isPlainJsFile(sourceSymbolFile, compilerOptions.checkJs);
            const isTargetPlainJs = isPlainJsFile(targetSymbolFile, compilerOptions.checkJs);
            const symbolName2 = symbolToString(source);
            if (sourceSymbolFile && targetSymbolFile && amalgamatedDuplicates && !isEitherEnum && sourceSymbolFile !== targetSymbolFile) {
                const firstFile = comparePaths(sourceSymbolFile.path, targetSymbolFile.path) === -1 ? sourceSymbolFile : targetSymbolFile;
                const secondFile = firstFile === sourceSymbolFile ? targetSymbolFile : sourceSymbolFile;
                const filesDuplicates = getOrUpdate(amalgamatedDuplicates, `${firstFile.path}|${secondFile.path}`, () => ({
                    firstFile,
                    secondFile,
                    conflictingSymbols: /* @__PURE__ */new Map()
                }));
                const conflictingSymbolInfo = getOrUpdate(filesDuplicates.conflictingSymbols, symbolName2, () => ({
                    isBlockScoped: isEitherBlockScoped,
                    firstFileLocations: [],
                    secondFileLocations: []
                }));
                if (!isSourcePlainJs) addDuplicateLocations(conflictingSymbolInfo.firstFileLocations, source);
                if (!isTargetPlainJs) addDuplicateLocations(conflictingSymbolInfo.secondFileLocations, target);
            } else {
                if (!isSourcePlainJs) addDuplicateDeclarationErrorsForSymbols(source, message, symbolName2, target);
                if (!isTargetPlainJs) addDuplicateDeclarationErrorsForSymbols(target, message, symbolName2, source);
            }
        }
        return target;
        function addDuplicateLocations(locs, symbol) {
            if (symbol.declarations) {
                for (const decl of symbol.declarations) {
                    pushIfUnique(locs, decl);
                }
            }
        }
    }
    function addDuplicateDeclarationErrorsForSymbols(target, message, symbolName2, source) {
        forEach(target.declarations, node => {
            addDuplicateDeclarationError(node, message, symbolName2, source.declarations);
        });
    }
    function addDuplicateDeclarationError(node, message, symbolName2, relatedNodes) {
        const errorNode = (getExpandoInitializer(node, false) ? getNameOfExpando(node) : getNameOfDeclaration(node)) || node;
        const err = lookupOrIssueError(errorNode, message, symbolName2);
        for (const relatedNode of relatedNodes || emptyArray) {
            const adjustedNode = (getExpandoInitializer(relatedNode, false) ? getNameOfExpando(relatedNode) : getNameOfDeclaration(relatedNode)) || relatedNode;
            if (adjustedNode === errorNode) continue;
            err.relatedInformation = err.relatedInformation || [];
            const leadingMessage = createDiagnosticForNode(adjustedNode, Diagnostics._0_was_also_declared_here, symbolName2);
            const followOnMessage = createDiagnosticForNode(adjustedNode, Diagnostics.and_here);
            if (length(err.relatedInformation) >= 5 || some(err.relatedInformation, r => compareDiagnostics(r, followOnMessage) === 0 || compareDiagnostics(r, leadingMessage) === 0)) continue;
            addRelatedInfo(err, !length(err.relatedInformation) ? leadingMessage : followOnMessage);
        }
    }
    function combineSymbolTables(first2, second) {
        if (!(first2 == null ? void 0 : first2.size)) return second;
        if (!(second == null ? void 0 : second.size)) return first2;
        const combined = createSymbolTable();
        mergeSymbolTable(combined, first2);
        mergeSymbolTable(combined, second);
        return combined;
    }
    function mergeSymbolTable(target, source, unidirectional = false) {
        source.forEach((sourceSymbol, id) => {
            const targetSymbol = target.get(id);
            target.set(id, targetSymbol ? mergeSymbol(targetSymbol, sourceSymbol, unidirectional) : getMergedSymbol(sourceSymbol));
        });
    }
    function mergeModuleAugmentation(moduleName) {
        var _a2, _b, _c;
        const moduleAugmentation = moduleName.parent;
        if (((_a2 = moduleAugmentation.symbol.declarations) == null ? void 0 : _a2[0]) !== moduleAugmentation) {
            Debug.assert(moduleAugmentation.symbol.declarations.length > 1);
            return;
        }
        if (isGlobalScopeAugmentation(moduleAugmentation)) {
            mergeSymbolTable(globals, moduleAugmentation.symbol.exports);
        } else {
            const moduleNotFoundError = !(moduleName.parent.parent.flags & 16777216) ? Diagnostics.Invalid_module_name_in_augmentation_module_0_cannot_be_found : void 0;
            let mainModule = resolveExternalModuleNameWorker(moduleName, moduleName, moduleNotFoundError, true);
            if (!mainModule) {
                return;
            }
            mainModule = resolveExternalModuleSymbol(mainModule);
            if (mainModule.flags & 1920) {
                if (some(patternAmbientModules, module2 => mainModule === module2.symbol)) {
                    const merged = mergeSymbol(moduleAugmentation.symbol, mainModule, true);
                    if (!patternAmbientModuleAugmentations) {
                        patternAmbientModuleAugmentations = /* @__PURE__ */new Map();
                    }
                    patternAmbientModuleAugmentations.set(moduleName.text, merged);
                } else {
                    if (((_b = mainModule.exports) == null ? void 0 : _b.get("__export")) && ((_c = moduleAugmentation.symbol.exports) == null ? void 0 : _c.size)) {
                        const resolvedExports = getResolvedMembersOrExportsOfSymbol(mainModule, "resolvedExports");
                        for (const [key, value] of arrayFrom(moduleAugmentation.symbol.exports.entries())) {
                            if (resolvedExports.has(key) && !mainModule.exports.has(key)) {
                                mergeSymbol(resolvedExports.get(key), value);
                            }
                        }
                    }
                    mergeSymbol(mainModule, moduleAugmentation.symbol);
                }
            } else {
                error(moduleName, Diagnostics.Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity, moduleName.text);
            }
        }
    }
    function addToSymbolTable(target, source, message) {
        source.forEach((sourceSymbol, id) => {
            const targetSymbol = target.get(id);
            if (targetSymbol) {
                forEach(targetSymbol.declarations, addDeclarationDiagnostic(unescapeLeadingUnderscores(id), message));
            } else {
                target.set(id, sourceSymbol);
            }
        });
        function addDeclarationDiagnostic(id, message2) {
            return declaration => diagnostics.add(createDiagnosticForNode(declaration, message2, id));
        }
    }
    function getSymbolLinks(symbol) {
        var _a2;
        if (symbol.flags & 33554432) return symbol.links;
        const id = getSymbolId(symbol);
        return (_a2 = symbolLinks[id]) != null ? _a2 : symbolLinks[id] = new SymbolLinks();
    }
    function getNodeLinks(node) {
        const nodeId = getNodeId(node);
        return nodeLinks[nodeId] || (nodeLinks[nodeId] = new NodeLinks());
    }
    function isGlobalSourceFile(node) {
        return node.kind === 308 && !isExternalOrCommonJsModule(node);
    }
    function getSymbol2(symbols, name, meaning) {
        if (meaning) {
            const symbol = getMergedSymbol(symbols.get(name));
            if (symbol) {
                Debug.assert((getCheckFlags(symbol) & 1) === 0, "Should never get an instantiated symbol here.");
                if (symbol.flags & meaning) {
                    return symbol;
                }
                if (symbol.flags & 2097152) {
                    const targetFlags = getAllSymbolFlags(symbol);
                    if (targetFlags & meaning) {
                        return symbol;
                    }
                }
            }
        }
    }
    function getSymbolsOfParameterPropertyDeclaration(parameter, parameterName) {
        const constructorDeclaration = parameter.parent;
        const classDeclaration = parameter.parent.parent;
        const parameterSymbol = getSymbol2(constructorDeclaration.locals, parameterName, 111551);
        const propertySymbol = getSymbol2(getMembersOfSymbol(classDeclaration.symbol), parameterName, 111551);
        if (parameterSymbol && propertySymbol) {
            return [parameterSymbol, propertySymbol];
        }
        return Debug.fail("There should exist two symbols, one as property declaration and one as parameter declaration");
    }
    function isBlockScopedNameDeclaredBeforeUse(declaration, usage) {
        const declarationFile = getSourceFileOfNode(declaration);
        const useFile = getSourceFileOfNode(usage);
        const declContainer = getEnclosingBlockScopeContainer(declaration);
        if (declarationFile !== useFile) {
            if (moduleKind && (declarationFile.externalModuleIndicator || useFile.externalModuleIndicator) || !outFile(compilerOptions) || isInTypeQuery(usage) || declaration.flags & 16777216) {
                return true;
            }
            if (isUsedInFunctionOrInstanceProperty(usage, declaration)) {
                return true;
            }
            const sourceFiles = host.getSourceFiles();
            return sourceFiles.indexOf(declarationFile) <= sourceFiles.indexOf(useFile);
        }
        if (declaration.pos <= usage.pos && !(isPropertyDeclaration(declaration) && isThisProperty(usage.parent) && !declaration.initializer && !declaration.exclamationToken)) {
            if (declaration.kind === 205) {
                const errorBindingElement = getAncestor(usage, 205);
                if (errorBindingElement) {
                    return findAncestor(errorBindingElement, isBindingElement) !== findAncestor(declaration, isBindingElement) || declaration.pos < errorBindingElement.pos;
                }
                return isBlockScopedNameDeclaredBeforeUse(getAncestor(declaration, 257), usage);
            } else if (declaration.kind === 257) {
                return !isImmediatelyUsedInInitializerOfBlockScopedVariable(declaration, usage);
            } else if (isClassDeclaration(declaration)) {
                return !findAncestor(usage, n => isComputedPropertyName(n) && n.parent.parent === declaration);
            } else if (isPropertyDeclaration(declaration)) {
                return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, false);
            } else if (isParameterPropertyDeclaration(declaration, declaration.parent)) {
                return !(getEmitScriptTarget(compilerOptions) === 99 && useDefineForClassFields && getContainingClass(declaration) === getContainingClass(usage) && isUsedInFunctionOrInstanceProperty(usage, declaration));
            }
            return true;
        }
        if (usage.parent.kind === 278 || usage.parent.kind === 274 && usage.parent.isExportEquals) {
            return true;
        }
        if (usage.kind === 274 && usage.isExportEquals) {
            return true;
        }
        if (!!(usage.flags & 8388608) || isInTypeQuery(usage) || isInAmbientOrTypeNode(usage)) {
            return true;
        }
        if (isUsedInFunctionOrInstanceProperty(usage, declaration)) {
            if (getEmitScriptTarget(compilerOptions) === 99 && useDefineForClassFields && getContainingClass(declaration) && (isPropertyDeclaration(declaration) || isParameterPropertyDeclaration(declaration, declaration.parent))) {
                return !isPropertyImmediatelyReferencedWithinDeclaration(declaration, usage, true);
            } else {
                return true;
            }
        }
        return false;
        function isImmediatelyUsedInInitializerOfBlockScopedVariable(declaration2, usage2) {
            switch (declaration2.parent.parent.kind) {
                case 240:
                case 245:
                case 247:
                    if (isSameScopeDescendentOf(usage2, declaration2, declContainer)) {
                        return true;
                    }
                    break;
            }
            const grandparent = declaration2.parent.parent;
            return isForInOrOfStatement(grandparent) && isSameScopeDescendentOf(usage2, grandparent.expression, declContainer);
        }
        function isUsedInFunctionOrInstanceProperty(usage2, declaration2) {
            return !!findAncestor(usage2, current => {
                if (current === declContainer) {
                    return "quit";
                }
                if (isFunctionLike(current)) {
                    return true;
                }
                if (isClassStaticBlockDeclaration(current)) {
                    return declaration2.pos < usage2.pos;
                }
                const propertyDeclaration = tryCast(current.parent, isPropertyDeclaration);
                if (propertyDeclaration) {
                    const initializerOfProperty = propertyDeclaration.initializer === current;
                    if (initializerOfProperty) {
                        if (isStatic(current.parent)) {
                            if (declaration2.kind === 171) {
                                return true;
                            }
                            if (isPropertyDeclaration(declaration2) && getContainingClass(usage2) === getContainingClass(declaration2)) {
                                const propName = declaration2.name;
                                if (isIdentifier(propName) || isPrivateIdentifier(propName)) {
                                    const type = getTypeOfSymbol(getSymbolOfDeclaration(declaration2));
                                    const staticBlocks = filter(declaration2.parent.members, isClassStaticBlockDeclaration);
                                    if (isPropertyInitializedInStaticBlocks(propName, type, staticBlocks, declaration2.parent.pos, current.pos)) {
                                        return true;
                                    }
                                }
                            }
                        } else {
                            const isDeclarationInstanceProperty = declaration2.kind === 169 && !isStatic(declaration2);
                            if (!isDeclarationInstanceProperty || getContainingClass(usage2) !== getContainingClass(declaration2)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            });
        }
        function isPropertyImmediatelyReferencedWithinDeclaration(declaration2, usage2, stopAtAnyPropertyDeclaration) {
            if (usage2.end > declaration2.end) {
                return false;
            }
            const ancestorChangingReferenceScope = findAncestor(usage2, node => {
                if (node === declaration2) {
                    return "quit";
                }
                switch (node.kind) {
                    case 216:
                        return true;
                    case 169:
                        return stopAtAnyPropertyDeclaration && (isPropertyDeclaration(declaration2) && node.parent === declaration2.parent || isParameterPropertyDeclaration(declaration2, declaration2.parent) && node.parent === declaration2.parent.parent) ? "quit" : true;
                    case 238:
                        switch (node.parent.kind) {
                            case 174:
                            case 171:
                            case 175:
                                return true;
                            default:
                                return false;
                        }
                    default:
                        return false;
                }
            });
            return ancestorChangingReferenceScope === void 0;
        }
    }
    function useOuterVariableScopeInParameter(result, location, lastLocation) {
        const target = getEmitScriptTarget(compilerOptions);
        const functionLocation = location;
        if (isParameter(lastLocation) && functionLocation.body && result.valueDeclaration && result.valueDeclaration.pos >= functionLocation.body.pos && result.valueDeclaration.end <= functionLocation.body.end) {
            if (target >= 2) {
                const links = getNodeLinks(functionLocation);
                if (links.declarationRequiresScopeChange === void 0) {
                    links.declarationRequiresScopeChange = forEach(functionLocation.parameters, requiresScopeChange) || false;
                }
                return !links.declarationRequiresScopeChange;
            }
        }
        return false;
        function requiresScopeChange(node) {
            return requiresScopeChangeWorker(node.name) || !!node.initializer && requiresScopeChangeWorker(node.initializer);
        }
        function requiresScopeChangeWorker(node) {
            switch (node.kind) {
                case 216:
                case 215:
                case 259:
                case 173:
                    return false;
                case 171:
                case 174:
                case 175:
                case 299:
                    return requiresScopeChangeWorker(node.name);
                case 169:
                    if (hasStaticModifier(node)) {
                        return target < 99 || !useDefineForClassFields;
                    }
                    return requiresScopeChangeWorker(node.name);
                default:
                    if (isNullishCoalesce(node) || isOptionalChain(node)) {
                        return target < 7;
                    }
                    if (isBindingElement(node) && node.dotDotDotToken && isObjectBindingPattern(node.parent)) {
                        return target < 4;
                    }
                    if (isTypeNode(node)) return false;
                    return forEachChild(node, requiresScopeChangeWorker) || false;
            }
        }
    }
    function isConstAssertion(location) {
        return isAssertionExpression(location) && isConstTypeReference(location.type) || isJSDocTypeTag(location) && isConstTypeReference(location.typeExpression);
    }
    function resolveName(location, name, meaning, nameNotFoundMessage, nameArg, isUse, excludeGlobals = false, getSpellingSuggestions = true) {
        return resolveNameHelper(location, name, meaning, nameNotFoundMessage, nameArg, isUse, excludeGlobals, getSpellingSuggestions, getSymbol2);
    }
    function resolveNameHelper(location, name, meaning, nameNotFoundMessage, nameArg, isUse, excludeGlobals, getSpellingSuggestions, lookup) {
        var _a2, _b, _c;
        const originalLocation = location;
        let result;
        let lastLocation;
        let lastSelfReferenceLocation;
        let propertyWithInvalidInitializer;
        let associatedDeclarationForContainingInitializerOrBindingName;
        let withinDeferredContext = false;
        const errorLocation = location;
        let grandparent;
        let isInExternalModule = false;
        loop: while (location) {
            if (name === "const" && isConstAssertion(location)) {
                return void 0;
            }
            if (canHaveLocals(location) && location.locals && !isGlobalSourceFile(location)) {
                if (result = lookup(location.locals, name, meaning)) {
                    let useResult = true;
                    if (isFunctionLike(location) && lastLocation && lastLocation !== location.body) {
                        if (meaning & result.flags & 788968 && lastLocation.kind !== 323) {
                            useResult = result.flags & 262144 ? lastLocation === location.type || lastLocation.kind === 166 || lastLocation.kind === 344 || lastLocation.kind === 345 || lastLocation.kind === 165 : false;
                        }
                        if (meaning & result.flags & 3) {
                            if (useOuterVariableScopeInParameter(result, location, lastLocation)) {
                                useResult = false;
                            } else if (result.flags & 1) {
                                useResult = lastLocation.kind === 166 || lastLocation === location.type && !!findAncestor(result.valueDeclaration, isParameter);
                            }
                        }
                    } else if (location.kind === 191) {
                        useResult = lastLocation === location.trueType;
                    }
                    if (useResult) {
                        break loop;
                    } else {
                        result = void 0;
                    }
                }
            }
            withinDeferredContext = withinDeferredContext || getIsDeferredContext(location, lastLocation);
            switch (location.kind) {
                case 308:
                    if (!isExternalOrCommonJsModule(location)) break;
                    isInExternalModule = true;
                case 264:
                    const moduleExports = ((_a2 = getSymbolOfDeclaration(location)) == null ? void 0 : _a2.exports) || emptySymbols;
                    if (location.kind === 308 || isModuleDeclaration(location) && location.flags & 16777216 && !isGlobalScopeAugmentation(location)) {
                        if (result = moduleExports.get("default")) {
                            const localSymbol = getLocalSymbolForExportDefault(result);
                            if (localSymbol && result.flags & meaning && localSymbol.escapedName === name) {
                                break loop;
                            }
                            result = void 0;
                        }
                        const moduleExport = moduleExports.get(name);
                        if (moduleExport && moduleExport.flags === 2097152 && (getDeclarationOfKind(moduleExport, 278) || getDeclarationOfKind(moduleExport, 277))) {
                            break;
                        }
                    }
                    if (name !== "default" && (result = lookup(moduleExports, name, meaning & 2623475))) {
                        if (isSourceFile(location) && location.commonJsModuleIndicator && !((_b = result.declarations) == null ? void 0 : _b.some(isJSDocTypeAlias))) {
                            result = void 0;
                        } else {
                            break loop;
                        }
                    }
                    break;
                case 263:
                    if (result = lookup(((_c = getSymbolOfDeclaration(location)) == null ? void 0 : _c.exports) || emptySymbols, name, meaning & 8)) {
                        if (nameNotFoundMessage && getIsolatedModules(compilerOptions) && !(location.flags & 16777216) && getSourceFileOfNode(location) !== getSourceFileOfNode(result.valueDeclaration)) {
                            error(errorLocation, Diagnostics.Cannot_access_0_from_another_file_without_qualification_when_1_is_enabled_Use_2_instead, unescapeLeadingUnderscores(name), isolatedModulesLikeFlagName, `${unescapeLeadingUnderscores(getSymbolOfNode(location).escapedName)}.${unescapeLeadingUnderscores(name)}`);
                        }
                        break loop;
                    }
                    break;
                case 169:
                    if (!isStatic(location)) {
                        const ctor = findConstructorDeclaration(location.parent);
                        if (ctor && ctor.locals) {
                            if (lookup(ctor.locals, name, meaning & 111551)) {
                                Debug.assertNode(location, isPropertyDeclaration);
                                propertyWithInvalidInitializer = location;
                            }
                        }
                    }
                    break;
                case 260:
                case 228:
                case 261:
                    if (result = lookup(getSymbolOfDeclaration(location).members || emptySymbols, name, meaning & 788968)) {
                        if (!isTypeParameterSymbolDeclaredInContainer(result, location)) {
                            result = void 0;
                            break;
                        }
                        if (lastLocation && isStatic(lastLocation)) {
                            if (nameNotFoundMessage) {
                                error(errorLocation, Diagnostics.Static_members_cannot_reference_class_type_parameters);
                            }
                            return void 0;
                        }
                        break loop;
                    }
                    if (isClassExpression(location) && meaning & 32) {
                        const className = location.name;
                        if (className && name === className.escapedText) {
                            result = location.symbol;
                            break loop;
                        }
                    }
                    break;
                case 230:
                    if (lastLocation === location.expression && location.parent.token === 94) {
                        const container = location.parent.parent;
                        if (isClassLike(container) && (result = lookup(getSymbolOfDeclaration(container).members, name, meaning & 788968))) {
                            if (nameNotFoundMessage) {
                                error(errorLocation, Diagnostics.Base_class_expressions_cannot_reference_class_type_parameters);
                            }
                            return void 0;
                        }
                    }
                    break;
                case 164:
                    grandparent = location.parent.parent;
                    if (isClassLike(grandparent) || grandparent.kind === 261) {
                        if (result = lookup(getSymbolOfDeclaration(grandparent).members, name, meaning & 788968)) {
                            if (nameNotFoundMessage) {
                                error(errorLocation, Diagnostics.A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type);
                            }
                            return void 0;
                        }
                    }
                    break;
                case 216:
                    if (getEmitScriptTarget(compilerOptions) >= 2) {
                        break;
                    }
                case 171:
                case 173:
                case 174:
                case 175:
                case 259:
                    if (meaning & 3 && name === "arguments") {
                        result = argumentsSymbol;
                        break loop;
                    }
                    break;
                case 215:
                    if (meaning & 3 && name === "arguments") {
                        result = argumentsSymbol;
                        break loop;
                    }
                    if (meaning & 16) {
                        const functionName = location.name;
                        if (functionName && name === functionName.escapedText) {
                            result = location.symbol;
                            break loop;
                        }
                    }
                    break;
                case 167:
                    if (location.parent && location.parent.kind === 166) {
                        location = location.parent;
                    }
                    if (location.parent && (isClassElement(location.parent) || location.parent.kind === 260)) {
                        location = location.parent;
                    }
                    break;
                case 349:
                case 341:
                case 343:
                    const root = getJSDocRoot(location);
                    if (root) {
                        location = root.parent;
                    }
                    break;
                case 166:
                    if (lastLocation && (lastLocation === location.initializer || lastLocation === location.name && isBindingPattern(lastLocation))) {
                        if (!associatedDeclarationForContainingInitializerOrBindingName) {
                            associatedDeclarationForContainingInitializerOrBindingName = location;
                        }
                    }
                    break;
                case 205:
                    if (lastLocation && (lastLocation === location.initializer || lastLocation === location.name && isBindingPattern(lastLocation))) {
                        if (isParameterDeclaration(location) && !associatedDeclarationForContainingInitializerOrBindingName) {
                            associatedDeclarationForContainingInitializerOrBindingName = location;
                        }
                    }
                    break;
                case 192:
                    if (meaning & 262144) {
                        const parameterName = location.typeParameter.name;
                        if (parameterName && name === parameterName.escapedText) {
                            result = location.typeParameter.symbol;
                            break loop;
                        }
                    }
                    break;
            }
            if (isSelfReferenceLocation(location)) {
                lastSelfReferenceLocation = location;
            }
            lastLocation = location;
            location = isJSDocTemplateTag(location) ? getEffectiveContainerForJSDocTemplateTag(location) || location.parent : isJSDocParameterTag(location) || isJSDocReturnTag(location) ? getHostSignatureFromJSDoc(location) || location.parent : location.parent;
        }
        if (isUse && result && (!lastSelfReferenceLocation || result !== lastSelfReferenceLocation.symbol)) {
            result.isReferenced |= meaning;
        }
        if (!result) {
            if (lastLocation) {
                Debug.assertNode(lastLocation, isSourceFile);
                if (lastLocation.commonJsModuleIndicator && name === "exports" && meaning & lastLocation.symbol.flags) {
                    return lastLocation.symbol;
                }
            }
            if (!excludeGlobals) {
                result = lookup(globals, name, meaning);
            }
        }
        if (!result) {
            if (originalLocation && isInJSFile(originalLocation) && originalLocation.parent) {
                if (isRequireCall(originalLocation.parent, false)) {
                    return requireSymbol;
                }
            }
        }
        function checkAndReportErrorForInvalidInitializer() {
            if (propertyWithInvalidInitializer && !(useDefineForClassFields && getEmitScriptTarget(compilerOptions) >= 9)) {
                error(errorLocation, errorLocation && propertyWithInvalidInitializer.type && textRangeContainsPositionInclusive(propertyWithInvalidInitializer.type, errorLocation.pos) ? Diagnostics.Type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor : Diagnostics.Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor, declarationNameToString(propertyWithInvalidInitializer.name), diagnosticName(nameArg));
                return true;
            }
            return false;
        }
        if (!result) {
            if (nameNotFoundMessage) {
                addLazyDiagnostic(() => {
                    if (!errorLocation || !checkAndReportErrorForMissingPrefix(errorLocation, name, nameArg) && !checkAndReportErrorForInvalidInitializer() && !checkAndReportErrorForExtendingInterface(errorLocation) && !checkAndReportErrorForUsingTypeAsNamespace(errorLocation, name, meaning) && !checkAndReportErrorForExportingPrimitiveType(errorLocation, name) && !checkAndReportErrorForUsingNamespaceAsTypeOrValue(errorLocation, name, meaning) && !checkAndReportErrorForUsingTypeAsValue(errorLocation, name, meaning) && !checkAndReportErrorForUsingValueAsType(errorLocation, name, meaning)) {
                        let suggestion;
                        let suggestedLib;
                        if (nameArg) {
                            suggestedLib = getSuggestedLibForNonExistentName(nameArg);
                            if (suggestedLib) {
                                error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg), suggestedLib);
                            }
                        }
                        if (!suggestedLib && getSpellingSuggestions && suggestionCount < maximumSuggestionCount) {
                            suggestion = getSuggestedSymbolForNonexistentSymbol(originalLocation, name, meaning);
                            const isGlobalScopeAugmentationDeclaration = (suggestion == null ? void 0 : suggestion.valueDeclaration) && isAmbientModule(suggestion.valueDeclaration) && isGlobalScopeAugmentation(suggestion.valueDeclaration);
                            if (isGlobalScopeAugmentationDeclaration) {
                                suggestion = void 0;
                            }
                            if (suggestion) {
                                const suggestionName = symbolToString(suggestion);
                                const isUncheckedJS = isUncheckedJSSuggestion(originalLocation, suggestion, false);
                                const message = meaning === 1920 || nameArg && typeof nameArg !== "string" && nodeIsSynthesized(nameArg) ? Diagnostics.Cannot_find_namespace_0_Did_you_mean_1 : isUncheckedJS ? Diagnostics.Could_not_find_name_0_Did_you_mean_1 : Diagnostics.Cannot_find_name_0_Did_you_mean_1;
                                const diagnostic = createError(errorLocation, message, diagnosticName(nameArg), suggestionName);
                                addErrorOrSuggestion(!isUncheckedJS, diagnostic);
                                if (suggestion.valueDeclaration) {
                                    addRelatedInfo(diagnostic, createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestionName));
                                }
                            }
                        }
                        if (!suggestion && !suggestedLib && nameArg) {
                            error(errorLocation, nameNotFoundMessage, diagnosticName(nameArg));
                        }
                        suggestionCount++;
                    }
                });
            }
            return void 0;
        } else if (nameNotFoundMessage && checkAndReportErrorForInvalidInitializer()) {
            return void 0;
        }
        if (nameNotFoundMessage) {
            addLazyDiagnostic(() => {
                if (errorLocation && (meaning & 2 || (meaning & 32 || meaning & 384) && (meaning & 111551) === 111551)) {
                    const exportOrLocalSymbol = getExportSymbolOfValueSymbolIfExported(result);
                    if (exportOrLocalSymbol.flags & 2 || exportOrLocalSymbol.flags & 32 || exportOrLocalSymbol.flags & 384) {
                        checkResolvedBlockScopedVariable(exportOrLocalSymbol, errorLocation);
                    }
                }
                if (result && isInExternalModule && (meaning & 111551) === 111551 && !(originalLocation.flags & 8388608)) {
                    const merged = getMergedSymbol(result);
                    if (length(merged.declarations) && every(merged.declarations, d => isNamespaceExportDeclaration(d) || isSourceFile(d) && !!d.symbol.globalExports)) {
                        errorOrSuggestion(!compilerOptions.allowUmdGlobalAccess, errorLocation, Diagnostics._0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead, unescapeLeadingUnderscores(name));
                    }
                }
                if (result && associatedDeclarationForContainingInitializerOrBindingName && !withinDeferredContext && (meaning & 111551) === 111551) {
                    const candidate = getMergedSymbol(getLateBoundSymbol(result));
                    const root = getRootDeclaration(associatedDeclarationForContainingInitializerOrBindingName);
                    if (candidate === getSymbolOfDeclaration(associatedDeclarationForContainingInitializerOrBindingName)) {
                        error(errorLocation, Diagnostics.Parameter_0_cannot_reference_itself, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name));
                    } else if (candidate.valueDeclaration && candidate.valueDeclaration.pos > associatedDeclarationForContainingInitializerOrBindingName.pos && root.parent.locals && lookup(root.parent.locals, candidate.escapedName, meaning) === candidate) {
                        error(errorLocation, Diagnostics.Parameter_0_cannot_reference_identifier_1_declared_after_it, declarationNameToString(associatedDeclarationForContainingInitializerOrBindingName.name), declarationNameToString(errorLocation));
                    }
                }
                if (result && errorLocation && meaning & 111551 && result.flags & 2097152 && !(result.flags & 111551) && !isValidTypeOnlyAliasUseSite(errorLocation)) {
                    const typeOnlyDeclaration = getTypeOnlyAliasDeclaration(result, 111551);
                    if (typeOnlyDeclaration) {
                        const message = typeOnlyDeclaration.kind === 278 || typeOnlyDeclaration.kind === 275 || typeOnlyDeclaration.kind === 277 ? Diagnostics._0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type : Diagnostics._0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type;
                        const unescapedName = unescapeLeadingUnderscores(name);
                        addTypeOnlyDeclarationRelatedInfo(error(errorLocation, message, unescapedName), typeOnlyDeclaration, unescapedName);
                    }
                }
            });
        }
        return result;
    }
    function addTypeOnlyDeclarationRelatedInfo(diagnostic, typeOnlyDeclaration, unescapedName) {
        if (!typeOnlyDeclaration) return diagnostic;
        return addRelatedInfo(diagnostic, createDiagnosticForNode(typeOnlyDeclaration, typeOnlyDeclaration.kind === 278 || typeOnlyDeclaration.kind === 275 || typeOnlyDeclaration.kind === 277 ? Diagnostics._0_was_exported_here : Diagnostics._0_was_imported_here, unescapedName));
    }
    function getIsDeferredContext(location, lastLocation) {
        if (location.kind !== 216 && location.kind !== 215) {
            return isTypeQueryNode(location) || (isFunctionLikeDeclaration(location) || location.kind === 169 && !isStatic(location)) && (!lastLocation || lastLocation !== location.name);
        }
        if (lastLocation && lastLocation === location.name) {
            return false;
        }
        if (location.asteriskToken || hasSyntacticModifier(location, 512)) {
            return true;
        }
        return !getImmediatelyInvokedFunctionExpression(location);
    }
    function isSelfReferenceLocation(node) {
        switch (node.kind) {
            case 259:
            case 260:
            case 261:
            case 263:
            case 262:
            case 264:
                return true;
            default:
                return false;
        }
    }
    function diagnosticName(nameArg) {
        return isString(nameArg) ? unescapeLeadingUnderscores(nameArg) : declarationNameToString(nameArg);
    }
    function isTypeParameterSymbolDeclaredInContainer(symbol, container) {
        if (symbol.declarations) {
            for (const decl of symbol.declarations) {
                if (decl.kind === 165) {
                    const parent2 = isJSDocTemplateTag(decl.parent) ? getJSDocHost(decl.parent) : decl.parent;
                    if (parent2 === container) {
                        return !(isJSDocTemplateTag(decl.parent) && find(decl.parent.parent.tags, isJSDocTypeAlias));
                    }
                }
            }
        }
        return false;
    }
    function checkAndReportErrorForMissingPrefix(errorLocation, name, nameArg) {
        if (!isIdentifier(errorLocation) || errorLocation.escapedText !== name || isTypeReferenceIdentifier(errorLocation) || isInTypeQuery(errorLocation)) {
            return false;
        }
        const container = getThisContainer(errorLocation, false, false);
        let location = container;
        while (location) {
            if (isClassLike(location.parent)) {
                const classSymbol = getSymbolOfDeclaration(location.parent);
                if (!classSymbol) {
                    break;
                }
                const constructorType = getTypeOfSymbol(classSymbol);
                if (getPropertyOfType(constructorType, name)) {
                    error(errorLocation, Diagnostics.Cannot_find_name_0_Did_you_mean_the_static_member_1_0, diagnosticName(nameArg), symbolToString(classSymbol));
                    return true;
                }
                if (location === container && !isStatic(location)) {
                    const instanceType = getDeclaredTypeOfSymbol(classSymbol).thisType;
                    if (getPropertyOfType(instanceType, name)) {
                        error(errorLocation, Diagnostics.Cannot_find_name_0_Did_you_mean_the_instance_member_this_0, diagnosticName(nameArg));
                        return true;
                    }
                }
            }
            location = location.parent;
        }
        return false;
    }
    function checkAndReportErrorForExtendingInterface(errorLocation) {
        const expression = getEntityNameForExtendingInterface(errorLocation);
        if (expression && resolveEntityName(expression, 64, true)) {
            error(errorLocation, Diagnostics.Cannot_extend_an_interface_0_Did_you_mean_implements, getTextOfNode(expression));
            return true;
        }
        return false;
    }
    function getEntityNameForExtendingInterface(node) {
        switch (node.kind) {
            case 79:
            case 208:
                return node.parent ? getEntityNameForExtendingInterface(node.parent) : void 0;
            case 230:
                if (isEntityNameExpression(node.expression)) {
                    return node.expression;
                }
            default:
                return void 0;
        }
    }
    function checkAndReportErrorForUsingTypeAsNamespace(errorLocation, name, meaning) {
        const namespaceMeaning = 1920 | (isInJSFile(errorLocation) ? 111551 : 0);
        if (meaning === namespaceMeaning) {
            const symbol = resolveSymbol(resolveName(errorLocation, name, 788968 & ~namespaceMeaning, void 0, void 0, false));
            const parent2 = errorLocation.parent;
            if (symbol) {
                if (isQualifiedName(parent2)) {
                    Debug.assert(parent2.left === errorLocation, "Should only be resolving left side of qualified name as a namespace");
                    const propName = parent2.right.escapedText;
                    const propType = getPropertyOfType(getDeclaredTypeOfSymbol(symbol), propName);
                    if (propType) {
                        error(parent2, Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1, unescapeLeadingUnderscores(name), unescapeLeadingUnderscores(propName));
                        return true;
                    }
                }
                error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here, unescapeLeadingUnderscores(name));
                return true;
            }
        }
        return false;
    }
    function checkAndReportErrorForUsingValueAsType(errorLocation, name, meaning) {
        if (meaning & (788968 & ~1920)) {
            const symbol = resolveSymbol(resolveName(errorLocation, name, ~788968 & 111551, void 0, void 0, false));
            if (symbol && !(symbol.flags & 1920)) {
                error(errorLocation, Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0, unescapeLeadingUnderscores(name));
                return true;
            }
        }
        return false;
    }
    function isPrimitiveTypeName(name) {
        return name === "any" || name === "string" || name === "number" || name === "boolean" || name === "never" || name === "unknown";
    }
    function checkAndReportErrorForExportingPrimitiveType(errorLocation, name) {
        if (isPrimitiveTypeName(name) && errorLocation.parent.kind === 278) {
            error(errorLocation, Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, name);
            return true;
        }
        return false;
    }
    function checkAndReportErrorForUsingTypeAsValue(errorLocation, name, meaning) {
        if (meaning & 111551) {
            if (isPrimitiveTypeName(name)) {
                if (isExtendedByInterface(errorLocation)) {
                    error(errorLocation, Diagnostics.An_interface_cannot_extend_a_primitive_type_like_0_an_interface_can_only_extend_named_types_and_classes, unescapeLeadingUnderscores(name));
                } else {
                    error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, unescapeLeadingUnderscores(name));
                }
                return true;
            }
            const symbol = resolveSymbol(resolveName(errorLocation, name, 788968 & ~111551, void 0, void 0, false));
            const allFlags = symbol && getAllSymbolFlags(symbol);
            if (symbol && allFlags !== void 0 && !(allFlags & 111551)) {
                const rawName = unescapeLeadingUnderscores(name);
                if (isES2015OrLaterConstructorName(name)) {
                    error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later, rawName);
                } else if (maybeMappedType(errorLocation, symbol)) {
                    error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0, rawName, rawName === "K" ? "P" : "K");
                } else {
                    error(errorLocation, Diagnostics._0_only_refers_to_a_type_but_is_being_used_as_a_value_here, rawName);
                }
                return true;
            }
        }
        return false;
    }
    function isExtendedByInterface(node) {
        const grandparent = node.parent.parent;
        const parentOfGrandparent = grandparent.parent;
        if (grandparent && parentOfGrandparent) {
            const isExtending = isHeritageClause(grandparent) && grandparent.token === 94;
            const isInterface = isInterfaceDeclaration(parentOfGrandparent);
            return isExtending && isInterface;
        }
        return false;
    }
    function maybeMappedType(node, symbol) {
        const container = findAncestor(node.parent, n => isComputedPropertyName(n) || isPropertySignature(n) ? false : isTypeLiteralNode(n) || "quit");
        if (container && container.members.length === 1) {
            const type = getDeclaredTypeOfSymbol(symbol);
            return !!(type.flags & 1048576) && allTypesAssignableToKind(type, 384, true);
        }
        return false;
    }
    function isES2015OrLaterConstructorName(n) {
        switch (n) {
            case "Promise":
            case "Symbol":
            case "Map":
            case "WeakMap":
            case "Set":
            case "WeakSet":
                return true;
        }
        return false;
    }
    function checkAndReportErrorForUsingNamespaceAsTypeOrValue(errorLocation, name, meaning) {
        if (meaning & (111551 & ~788968)) {
            const symbol = resolveSymbol(resolveName(errorLocation, name, 1024, void 0, void 0, false));
            if (symbol) {
                error(errorLocation, Diagnostics.Cannot_use_namespace_0_as_a_value, unescapeLeadingUnderscores(name));
                return true;
            }
        } else if (meaning & (788968 & ~111551)) {
            const symbol = resolveSymbol(resolveName(errorLocation, name, 1536, void 0, void 0, false));
            if (symbol) {
                error(errorLocation, Diagnostics.Cannot_use_namespace_0_as_a_type, unescapeLeadingUnderscores(name));
                return true;
            }
        }
        return false;
    }
    function checkResolvedBlockScopedVariable(result, errorLocation) {
        var _a2;
        Debug.assert(!!(result.flags & 2 || result.flags & 32 || result.flags & 384));
        if (result.flags & (16 | 1 | 67108864) && result.flags & 32) {
            return;
        }
        const declaration = (_a2 = result.declarations) == null ? void 0 : _a2.find(d => isBlockOrCatchScoped(d) || isClassLike(d) || d.kind === 263);
        if (declaration === void 0) return Debug.fail("checkResolvedBlockScopedVariable could not find block-scoped declaration");
        if (!(declaration.flags & 16777216) && !isBlockScopedNameDeclaredBeforeUse(declaration, errorLocation)) {
            let diagnosticMessage;
            const declarationName = declarationNameToString(getNameOfDeclaration(declaration));
            if (result.flags & 2) {
                diagnosticMessage = error(errorLocation, Diagnostics.Block_scoped_variable_0_used_before_its_declaration, declarationName);
            } else if (result.flags & 32) {
                diagnosticMessage = error(errorLocation, Diagnostics.Class_0_used_before_its_declaration, declarationName);
            } else if (result.flags & 256) {
                diagnosticMessage = error(errorLocation, Diagnostics.Enum_0_used_before_its_declaration, declarationName);
            } else {
                Debug.assert(!!(result.flags & 128));
                if (shouldPreserveConstEnums(compilerOptions)) {
                    diagnosticMessage = error(errorLocation, Diagnostics.Enum_0_used_before_its_declaration, declarationName);
                }
            }
            if (diagnosticMessage) {
                addRelatedInfo(diagnosticMessage, createDiagnosticForNode(declaration, Diagnostics._0_is_declared_here, declarationName));
            }
        }
    }
    function isSameScopeDescendentOf(initial, parent2, stopAt) {
        return !!parent2 && !!findAncestor(initial, n => n === parent2 || (n === stopAt || isFunctionLike(n) && (!getImmediatelyInvokedFunctionExpression(n) || isAsyncFunction(n)) ? "quit" : false));
    }
    function getAnyImportSyntax(node) {
        switch (node.kind) {
            case 268:
                return node;
            case 270:
                return node.parent;
            case 271:
                return node.parent.parent;
            case 273:
                return node.parent.parent.parent;
            default:
                return void 0;
        }
    }
    function getDeclarationOfAliasSymbol(symbol) {
        return symbol.declarations && findLast(symbol.declarations, isAliasSymbolDeclaration2);
    }
    function isAliasSymbolDeclaration2(node) {
        return node.kind === 268 || node.kind === 267 || node.kind === 270 && !!node.name || node.kind === 271 || node.kind === 277 || node.kind === 273 || node.kind === 278 || node.kind === 274 && exportAssignmentIsAlias(node) || isBinaryExpression(node) && getAssignmentDeclarationKind(node) === 2 && exportAssignmentIsAlias(node) || isAccessExpression(node) && isBinaryExpression(node.parent) && node.parent.left === node && node.parent.operatorToken.kind === 63 && isAliasableOrJsExpression(node.parent.right) || node.kind === 300 || node.kind === 299 && isAliasableOrJsExpression(node.initializer) || node.kind === 257 && isVariableDeclarationInitializedToBareOrAccessedRequire(node) || node.kind === 205 && isVariableDeclarationInitializedToBareOrAccessedRequire(node.parent.parent);
    }
    function isAliasableOrJsExpression(e) {
        return isAliasableExpression(e) || isFunctionExpression(e) && isJSConstructor(e);
    }
    function getTargetOfImportEqualsDeclaration(node, dontResolveAlias) {
        const commonJSPropertyAccess = getCommonJSPropertyAccess(node);
        if (commonJSPropertyAccess) {
            const name = getLeftmostAccessExpression(commonJSPropertyAccess.expression).arguments[0];
            return isIdentifier(commonJSPropertyAccess.name) ? resolveSymbol(getPropertyOfType(resolveExternalModuleTypeByLiteral(name), commonJSPropertyAccess.name.escapedText)) : void 0;
        }
        if (isVariableDeclaration(node) || node.moduleReference.kind === 280) {
            const immediate = resolveExternalModuleName(node, getExternalModuleRequireArgument(node) || getExternalModuleImportEqualsDeclarationExpression(node));
            const resolved2 = resolveExternalModuleSymbol(immediate);
            markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved2, false);
            return resolved2;
        }
        const resolved = getSymbolOfPartOfRightHandSideOfImportEquals(node.moduleReference, dontResolveAlias);
        checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol(node, resolved);
        return resolved;
    }
    function checkAndReportErrorForResolvingImportAliasToTypeOnlySymbol(node, resolved) {
        if (markSymbolOfAliasDeclarationIfTypeOnly(node, void 0, resolved, false) && !node.isTypeOnly) {
            const typeOnlyDeclaration = getTypeOnlyAliasDeclaration(getSymbolOfDeclaration(node));
            const isExport = typeOnlyDeclaration.kind === 278 || typeOnlyDeclaration.kind === 275;
            const message = isExport ? Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type : Diagnostics.An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type;
            const relatedMessage = isExport ? Diagnostics._0_was_exported_here : Diagnostics._0_was_imported_here;
            const name = typeOnlyDeclaration.kind === 275 ? "*" : unescapeLeadingUnderscores(typeOnlyDeclaration.name.escapedText);
            addRelatedInfo(error(node.moduleReference, message), createDiagnosticForNode(typeOnlyDeclaration, relatedMessage, name));
        }
    }
    function resolveExportByName(moduleSymbol, name, sourceNode, dontResolveAlias) {
        const exportValue = moduleSymbol.exports.get("export=");
        const exportSymbol = exportValue ? getPropertyOfType(getTypeOfSymbol(exportValue), name, true) : moduleSymbol.exports.get(name);
        const resolved = resolveSymbol(exportSymbol, dontResolveAlias);
        markSymbolOfAliasDeclarationIfTypeOnly(sourceNode, exportSymbol, resolved, false);
        return resolved;
    }
    function isSyntacticDefault(node) {
        return isExportAssignment(node) && !node.isExportEquals || hasSyntacticModifier(node, 1024) || isExportSpecifier(node);
    }
    function getUsageModeForExpression(usage) {
        return isStringLiteralLike(usage) ? getModeForUsageLocation(getSourceFileOfNode(usage), usage) : void 0;
    }
    function isESMFormatImportImportingCommonjsFormatFile(usageMode, targetMode) {
        return usageMode === 99 && targetMode === 1;
    }
    function isOnlyImportedAsDefault(usage) {
        const usageMode = getUsageModeForExpression(usage);
        return usageMode === 99 && endsWith(usage.text, ".json");
    }
    function canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, usage) {
        const usageMode = file && getUsageModeForExpression(usage);
        if (file && usageMode !== void 0) {
            const result = isESMFormatImportImportingCommonjsFormatFile(usageMode, file.impliedNodeFormat);
            if (usageMode === 99 || result) {
                return result;
            }
        }
        if (!allowSyntheticDefaultImports) {
            return false;
        }
        if (!file || file.isDeclarationFile) {
            const defaultExportSymbol = resolveExportByName(moduleSymbol, "default", void 0, true);
            if (defaultExportSymbol && some(defaultExportSymbol.declarations, isSyntacticDefault)) {
                return false;
            }
            if (resolveExportByName(moduleSymbol, escapeLeadingUnderscores("__esModule"), void 0, dontResolveAlias)) {
                return false;
            }
            return true;
        }
        if (!isSourceFileJS(file)) {
            return hasExportAssignmentSymbol(moduleSymbol);
        }
        return typeof file.externalModuleIndicator !== "object" && !resolveExportByName(moduleSymbol, escapeLeadingUnderscores("__esModule"), void 0, dontResolveAlias);
    }
    function getTargetOfImportClause(node, dontResolveAlias) {
        const moduleSymbol = resolveExternalModuleName(node, node.parent.moduleSpecifier);
        if (moduleSymbol) {
            return getTargetofModuleDefault(moduleSymbol, node, dontResolveAlias);
        }
    }
    function getTargetofModuleDefault(moduleSymbol, node, dontResolveAlias) {
        var _a2;
        let exportDefaultSymbol;
        if (isShorthandAmbientModuleSymbol(moduleSymbol)) {
            exportDefaultSymbol = moduleSymbol;
        } else {
            exportDefaultSymbol = resolveExportByName(moduleSymbol, "default", node, dontResolveAlias);
        }
        const file = (_a2 = moduleSymbol.declarations) == null ? void 0 : _a2.find(isSourceFile);
        const specifier = getModuleSpecifierForImportOrExport(node);
        if (!specifier) {
            return exportDefaultSymbol;
        }
        const hasDefaultOnly = isOnlyImportedAsDefault(specifier);
        const hasSyntheticDefault = canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, specifier);
        if (!exportDefaultSymbol && !hasSyntheticDefault && !hasDefaultOnly) {
            if (hasExportAssignmentSymbol(moduleSymbol) && !(getAllowSyntheticDefaultImports(compilerOptions) || getESModuleInterop(compilerOptions))) {
                const compilerOptionName = moduleKind >= 5 ? "allowSyntheticDefaultImports" : "esModuleInterop";
                const exportEqualsSymbol = moduleSymbol.exports.get("export=");
                const exportAssignment = exportEqualsSymbol.valueDeclaration;
                const err = error(node.name, Diagnostics.Module_0_can_only_be_default_imported_using_the_1_flag, symbolToString(moduleSymbol), compilerOptionName);
                if (exportAssignment) {
                    addRelatedInfo(err, createDiagnosticForNode(exportAssignment, Diagnostics.This_module_is_declared_with_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag, compilerOptionName));
                }
            } else if (isImportClause(node)) {
                reportNonDefaultExport(moduleSymbol, node);
            } else {
                errorNoModuleMemberSymbol(moduleSymbol, moduleSymbol, node, isImportOrExportSpecifier(node) && node.propertyName || node.name);
            }
        } else if (hasSyntheticDefault || hasDefaultOnly) {
            const resolved = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias);
            markSymbolOfAliasDeclarationIfTypeOnly(node, moduleSymbol, resolved, false);
            return resolved;
        }
        markSymbolOfAliasDeclarationIfTypeOnly(node, exportDefaultSymbol, void 0, false);
        return exportDefaultSymbol;
    }
    function getModuleSpecifierForImportOrExport(node) {
        switch (node.kind) {
            case 270:
                return node.parent.moduleSpecifier;
            case 268:
                return isExternalModuleReference(node.moduleReference) ? node.moduleReference.expression : void 0;
            case 271:
                return node.parent.parent.moduleSpecifier;
            case 273:
                return node.parent.parent.parent.moduleSpecifier;
            case 278:
                return node.parent.parent.moduleSpecifier;
            default:
                return Debug.assertNever(node);
        }
    }
    function reportNonDefaultExport(moduleSymbol, node) {
        var _a2, _b, _c;
        if ((_a2 = moduleSymbol.exports) == null ? void 0 : _a2.has(node.symbol.escapedName)) {
            error(node.name, Diagnostics.Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead, symbolToString(moduleSymbol), symbolToString(node.symbol));
        } else {
            const diagnostic = error(node.name, Diagnostics.Module_0_has_no_default_export, symbolToString(moduleSymbol));
            const exportStar = (_b = moduleSymbol.exports) == null ? void 0 : _b.get("__export");
            if (exportStar) {
                const defaultExport = (_c = exportStar.declarations) == null ? void 0 : _c.find(decl => {
                    var _a3, _b2;
                    return !!(isExportDeclaration(decl) && decl.moduleSpecifier && ((_b2 = (_a3 = resolveExternalModuleName(decl, decl.moduleSpecifier)) == null ? void 0 : _a3.exports) == null ? void 0 : _b2.has("default")));
                });
                if (defaultExport) {
                    addRelatedInfo(diagnostic, createDiagnosticForNode(defaultExport, Diagnostics.export_Asterisk_does_not_re_export_a_default));
                }
            }
        }
    }
    function getTargetOfNamespaceImport(node, dontResolveAlias) {
        const moduleSpecifier = node.parent.parent.moduleSpecifier;
        const immediate = resolveExternalModuleName(node, moduleSpecifier);
        const resolved = resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias, false);
        markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, false);
        return resolved;
    }
    function getTargetOfNamespaceExport(node, dontResolveAlias) {
        const moduleSpecifier = node.parent.moduleSpecifier;
        const immediate = moduleSpecifier && resolveExternalModuleName(node, moduleSpecifier);
        const resolved = moduleSpecifier && resolveESModuleSymbol(immediate, moduleSpecifier, dontResolveAlias, false);
        markSymbolOfAliasDeclarationIfTypeOnly(node, immediate, resolved, false);
        return resolved;
    }
    function combineValueAndTypeSymbols(valueSymbol, typeSymbol) {
        if (valueSymbol === unknownSymbol && typeSymbol === unknownSymbol) {
            return unknownSymbol;
        }
        if (valueSymbol.flags & (788968 | 1920)) {
            return valueSymbol;
        }
        const result = createSymbol(valueSymbol.flags | typeSymbol.flags, valueSymbol.escapedName);
        Debug.assert(valueSymbol.declarations || typeSymbol.declarations);
        result.declarations = deduplicate(concatenate(valueSymbol.declarations, typeSymbol.declarations), equateValues);
        result.parent = valueSymbol.parent || typeSymbol.parent;
        if (valueSymbol.valueDeclaration) result.valueDeclaration = valueSymbol.valueDeclaration;
        if (typeSymbol.members) result.members = new Map(typeSymbol.members);
        if (valueSymbol.exports) result.exports = new Map(valueSymbol.exports);
        return result;
    }
    function getExportOfModule(symbol, name, specifier, dontResolveAlias) {
        var _a2;
        if (symbol.flags & 1536) {
            const exportSymbol = getExportsOfSymbol(symbol).get(name.escapedText);
            const resolved = resolveSymbol(exportSymbol, dontResolveAlias);
            const exportStarDeclaration = (_a2 = getSymbolLinks(symbol).typeOnlyExportStarMap) == null ? void 0 : _a2.get(name.escapedText);
            markSymbolOfAliasDeclarationIfTypeOnly(specifier, exportSymbol, resolved, false, exportStarDeclaration, name.escapedText);
            return resolved;
        }
    }
    function getPropertyOfVariable(symbol, name) {
        if (symbol.flags & 3) {
            const typeAnnotation = symbol.valueDeclaration.type;
            if (typeAnnotation) {
                return resolveSymbol(getPropertyOfType(getTypeFromTypeNode(typeAnnotation), name));
            }
        }
    }
    function getExternalModuleMember(node, specifier, dontResolveAlias = false) {
        var _a2;
        const moduleSpecifier = getExternalModuleRequireArgument(node) || node.moduleSpecifier;
        const moduleSymbol = resolveExternalModuleName(node, moduleSpecifier);
        const name = !isPropertyAccessExpression(specifier) && specifier.propertyName || specifier.name;
        if (!isIdentifier(name)) {
            return void 0;
        }
        const suppressInteropError = name.escapedText === "default" && !!(compilerOptions.allowSyntheticDefaultImports || getESModuleInterop(compilerOptions));
        const targetSymbol = resolveESModuleSymbol(moduleSymbol, moduleSpecifier, false, suppressInteropError);
        if (targetSymbol) {
            if (name.escapedText) {
                if (isShorthandAmbientModuleSymbol(moduleSymbol)) {
                    return moduleSymbol;
                }
                let symbolFromVariable;
                if (moduleSymbol && moduleSymbol.exports && moduleSymbol.exports.get("export=")) {
                    symbolFromVariable = getPropertyOfType(getTypeOfSymbol(targetSymbol), name.escapedText, true);
                } else {
                    symbolFromVariable = getPropertyOfVariable(targetSymbol, name.escapedText);
                }
                symbolFromVariable = resolveSymbol(symbolFromVariable, dontResolveAlias);
                let symbolFromModule = getExportOfModule(targetSymbol, name, specifier, dontResolveAlias);
                if (symbolFromModule === void 0 && name.escapedText === "default") {
                    const file = (_a2 = moduleSymbol.declarations) == null ? void 0 : _a2.find(isSourceFile);
                    if (isOnlyImportedAsDefault(moduleSpecifier) || canHaveSyntheticDefault(file, moduleSymbol, dontResolveAlias, moduleSpecifier)) {
                        symbolFromModule = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) || resolveSymbol(moduleSymbol, dontResolveAlias);
                    }
                }
                const symbol = symbolFromModule && symbolFromVariable && symbolFromModule !== symbolFromVariable ? combineValueAndTypeSymbols(symbolFromVariable, symbolFromModule) : symbolFromModule || symbolFromVariable;
                if (!symbol) {
                    errorNoModuleMemberSymbol(moduleSymbol, targetSymbol, node, name);
                }
                return symbol;
            }
        }
    }
    function errorNoModuleMemberSymbol(moduleSymbol, targetSymbol, node, name) {
        var _a2;
        const moduleName = getFullyQualifiedName(moduleSymbol, node);
        const declarationName = declarationNameToString(name);
        const suggestion = getSuggestedSymbolForNonexistentModule(name, targetSymbol);
        if (suggestion !== void 0) {
            const suggestionName = symbolToString(suggestion);
            const diagnostic = error(name, Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2, moduleName, declarationName, suggestionName);
            if (suggestion.valueDeclaration) {
                addRelatedInfo(diagnostic, createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestionName));
            }
        } else {
            if ((_a2 = moduleSymbol.exports) == null ? void 0 : _a2.has("default")) {
                error(name, Diagnostics.Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead, moduleName, declarationName);
            } else {
                reportNonExportedMember(node, name, declarationName, moduleSymbol, moduleName);
            }
        }
    }
    function reportNonExportedMember(node, name, declarationName, moduleSymbol, moduleName) {
        var _a2, _b;
        const localSymbol = (_b = (_a2 = tryCast(moduleSymbol.valueDeclaration, canHaveLocals)) == null ? void 0 : _a2.locals) == null ? void 0 : _b.get(name.escapedText);
        const exports = moduleSymbol.exports;
        if (localSymbol) {
            const exportedEqualsSymbol = exports == null ? void 0 : exports.get("export=");
            if (exportedEqualsSymbol) {
                getSymbolIfSameReference(exportedEqualsSymbol, localSymbol) ? reportInvalidImportEqualsExportMember(node, name, declarationName, moduleName) : error(name, Diagnostics.Module_0_has_no_exported_member_1, moduleName, declarationName);
            } else {
                const exportedSymbol = exports ? find(symbolsToArray(exports), symbol => !!getSymbolIfSameReference(symbol, localSymbol)) : void 0;
                const diagnostic = exportedSymbol ? error(name, Diagnostics.Module_0_declares_1_locally_but_it_is_exported_as_2, moduleName, declarationName, symbolToString(exportedSymbol)) : error(name, Diagnostics.Module_0_declares_1_locally_but_it_is_not_exported, moduleName, declarationName);
                if (localSymbol.declarations) {
                    addRelatedInfo(diagnostic, ...map(localSymbol.declarations, (decl, index) => createDiagnosticForNode(decl, index === 0 ? Diagnostics._0_is_declared_here : Diagnostics.and_here, declarationName)));
                }
            }
        } else {
            error(name, Diagnostics.Module_0_has_no_exported_member_1, moduleName, declarationName);
        }
    }
    function reportInvalidImportEqualsExportMember(node, name, declarationName, moduleName) {
        if (moduleKind >= 5) {
            const message = getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_a_default_import : Diagnostics._0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import;
            error(name, message, declarationName);
        } else {
            if (isInJSFile(node)) {
                const message = getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import : Diagnostics._0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import;
                error(name, message, declarationName);
            } else {
                const message = getESModuleInterop(compilerOptions) ? Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import : Diagnostics._0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import;
                error(name, message, declarationName, declarationName, moduleName);
            }
        }
    }
    function getTargetOfImportSpecifier(node, dontResolveAlias) {
        if (isImportSpecifier(node) && idText(node.propertyName || node.name) === "default") {
            const specifier = getModuleSpecifierForImportOrExport(node);
            const moduleSymbol = specifier && resolveExternalModuleName(node, specifier);
            if (moduleSymbol) {
                return getTargetofModuleDefault(moduleSymbol, node, dontResolveAlias);
            }
        }
        const root = isBindingElement(node) ? getRootDeclaration(node) : node.parent.parent.parent;
        const commonJSPropertyAccess = getCommonJSPropertyAccess(root);
        const resolved = getExternalModuleMember(root, commonJSPropertyAccess || node, dontResolveAlias);
        const name = node.propertyName || node.name;
        if (commonJSPropertyAccess && resolved && isIdentifier(name)) {
            return resolveSymbol(getPropertyOfType(getTypeOfSymbol(resolved), name.escapedText), dontResolveAlias);
        }
        markSymbolOfAliasDeclarationIfTypeOnly(node, void 0, resolved, false);
        return resolved;
    }
    function getCommonJSPropertyAccess(node) {
        if (isVariableDeclaration(node) && node.initializer && isPropertyAccessExpression(node.initializer)) {
            return node.initializer;
        }
    }
    function getTargetOfNamespaceExportDeclaration(node, dontResolveAlias) {
        if (canHaveSymbol(node.parent)) {
            const resolved = resolveExternalModuleSymbol(node.parent.symbol, dontResolveAlias);
            markSymbolOfAliasDeclarationIfTypeOnly(node, void 0, resolved, false);
            return resolved;
        }
    }
    function getTargetOfExportSpecifier(node, meaning, dontResolveAlias) {
        if (idText(node.propertyName || node.name) === "default") {
            const specifier = getModuleSpecifierForImportOrExport(node);
            const moduleSymbol = specifier && resolveExternalModuleName(node, specifier);
            if (moduleSymbol) {
                return getTargetofModuleDefault(moduleSymbol, node, !!dontResolveAlias);
            }
        }
        const resolved = node.parent.parent.moduleSpecifier ? getExternalModuleMember(node.parent.parent, node, dontResolveAlias) : resolveEntityName(node.propertyName || node.name, meaning, false, dontResolveAlias);
        markSymbolOfAliasDeclarationIfTypeOnly(node, void 0, resolved, false);
        return resolved;
    }
    function getTargetOfExportAssignment(node, dontResolveAlias) {
        const expression = isExportAssignment(node) ? node.expression : node.right;
        const resolved = getTargetOfAliasLikeExpression(expression, dontResolveAlias);
        markSymbolOfAliasDeclarationIfTypeOnly(node, void 0, resolved, false);
        return resolved;
    }
    function getTargetOfAliasLikeExpression(expression, dontResolveAlias) {
        if (isClassExpression(expression)) {
            return checkExpressionCached(expression).symbol;
        }
        if (!isEntityName(expression) && !isEntityNameExpression(expression)) {
            return void 0;
        }
        const aliasLike = resolveEntityName(expression, 111551 | 788968 | 1920, true, dontResolveAlias);
        if (aliasLike) {
            return aliasLike;
        }
        checkExpressionCached(expression);
        return getNodeLinks(expression).resolvedSymbol;
    }
    function getTargetOfAccessExpression(node, dontRecursivelyResolve) {
        if (!(isBinaryExpression(node.parent) && node.parent.left === node && node.parent.operatorToken.kind === 63)) {
            return void 0;
        }
        return getTargetOfAliasLikeExpression(node.parent.right, dontRecursivelyResolve);
    }
    function getTargetOfAliasDeclaration(node, dontRecursivelyResolve = false) {
        switch (node.kind) {
            case 268:
            case 257:
                return getTargetOfImportEqualsDeclaration(node, dontRecursivelyResolve);
            case 270:
                return getTargetOfImportClause(node, dontRecursivelyResolve);
            case 271:
                return getTargetOfNamespaceImport(node, dontRecursivelyResolve);
            case 277:
                return getTargetOfNamespaceExport(node, dontRecursivelyResolve);
            case 273:
            case 205:
                return getTargetOfImportSpecifier(node, dontRecursivelyResolve);
            case 278:
                return getTargetOfExportSpecifier(node, 111551 | 788968 | 1920, dontRecursivelyResolve);
            case 274:
            case 223:
                return getTargetOfExportAssignment(node, dontRecursivelyResolve);
            case 267:
                return getTargetOfNamespaceExportDeclaration(node, dontRecursivelyResolve);
            case 300:
                return resolveEntityName(node.name, 111551 | 788968 | 1920, true, dontRecursivelyResolve);
            case 299:
                return getTargetOfAliasLikeExpression(node.initializer, dontRecursivelyResolve);
            case 209:
            case 208:
                return getTargetOfAccessExpression(node, dontRecursivelyResolve);
            default:
                return Debug.fail();
        }
    }
    function isNonLocalAlias(symbol, excludes = 111551 | 788968 | 1920) {
        if (!symbol) return false;
        return (symbol.flags & (2097152 | excludes)) === 2097152 || !!(symbol.flags & 2097152 && symbol.flags & 67108864);
    }
    function resolveSymbol(symbol, dontResolveAlias) {
        return !dontResolveAlias && isNonLocalAlias(symbol) ? resolveAlias(symbol) : symbol;
    }
    function resolveAlias(symbol) {
        Debug.assert((symbol.flags & 2097152) !== 0, "Should only get Alias here.");
        const links = getSymbolLinks(symbol);
        if (!links.aliasTarget) {
            links.aliasTarget = resolvingSymbol;
            const node = getDeclarationOfAliasSymbol(symbol);
            if (!node) return Debug.fail();
            const target = getTargetOfAliasDeclaration(node);
            if (links.aliasTarget === resolvingSymbol) {
                links.aliasTarget = target || unknownSymbol;
            } else {
                error(node, Diagnostics.Circular_definition_of_import_alias_0, symbolToString(symbol));
            }
        } else if (links.aliasTarget === resolvingSymbol) {
            links.aliasTarget = unknownSymbol;
        }
        return links.aliasTarget;
    }
    function tryResolveAlias(symbol) {
        const links = getSymbolLinks(symbol);
        if (links.aliasTarget !== resolvingSymbol) {
            return resolveAlias(symbol);
        }
        return void 0;
    }
    function getAllSymbolFlags(symbol) {
        let flags = symbol.flags;
        let seenSymbols;
        while (symbol.flags & 2097152) {
            const target = resolveAlias(symbol);
            if (target === unknownSymbol) {
                return 67108863;
            }
            if (target === symbol || (seenSymbols == null ? void 0 : seenSymbols.has(target))) {
                break;
            }
            if (target.flags & 2097152) {
                if (seenSymbols) {
                    seenSymbols.add(target);
                } else {
                    seenSymbols = /* @__PURE__ */new Set([symbol, target]);
                }
            }
            flags |= target.flags;
            symbol = target;
        }
        return flags;
    }
    function markSymbolOfAliasDeclarationIfTypeOnly(aliasDeclaration, immediateTarget, finalTarget, overwriteEmpty, exportStarDeclaration, exportStarName) {
        if (!aliasDeclaration || isPropertyAccessExpression(aliasDeclaration)) return false;
        const sourceSymbol = getSymbolOfDeclaration(aliasDeclaration);
        if (isTypeOnlyImportOrExportDeclaration(aliasDeclaration)) {
            const links2 = getSymbolLinks(sourceSymbol);
            links2.typeOnlyDeclaration = aliasDeclaration;
            return true;
        }
        if (exportStarDeclaration) {
            const links2 = getSymbolLinks(sourceSymbol);
            links2.typeOnlyDeclaration = exportStarDeclaration;
            if (sourceSymbol.escapedName !== exportStarName) {
                links2.typeOnlyExportStarName = exportStarName;
            }
            return true;
        }
        const links = getSymbolLinks(sourceSymbol);
        return markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, immediateTarget, overwriteEmpty) || markSymbolOfAliasDeclarationIfTypeOnlyWorker(links, finalTarget, overwriteEmpty);
    }
    function markSymbolOfAliasDeclarationIfTypeOnlyWorker(aliasDeclarationLinks, target, overwriteEmpty) {
        var _a2, _b, _c;
        if (target && (aliasDeclarationLinks.typeOnlyDeclaration === void 0 || overwriteEmpty && aliasDeclarationLinks.typeOnlyDeclaration === false)) {
            const exportSymbol = (_b = (_a2 = target.exports) == null ? void 0 : _a2.get("export=")) != null ? _b : target;
            const typeOnly = exportSymbol.declarations && find(exportSymbol.declarations, isTypeOnlyImportOrExportDeclaration);
            aliasDeclarationLinks.typeOnlyDeclaration = (_c = typeOnly != null ? typeOnly : getSymbolLinks(exportSymbol).typeOnlyDeclaration) != null ? _c : false;
        }
        return !!aliasDeclarationLinks.typeOnlyDeclaration;
    }
    function getTypeOnlyAliasDeclaration(symbol, include) {
        if (!(symbol.flags & 2097152)) {
            return void 0;
        }
        const links = getSymbolLinks(symbol);
        if (include === void 0) {
            return links.typeOnlyDeclaration || void 0;
        }
        if (links.typeOnlyDeclaration) {
            const resolved = links.typeOnlyDeclaration.kind === 275 ? resolveSymbol(getExportsOfModule(links.typeOnlyDeclaration.symbol.parent).get(links.typeOnlyExportStarName || symbol.escapedName)) : resolveAlias(links.typeOnlyDeclaration.symbol);
            return getAllSymbolFlags(resolved) & include ? links.typeOnlyDeclaration : void 0;
        }
        return void 0;
    }
    function markExportAsReferenced(node) {
        if (compilerOptions.verbatimModuleSyntax) {
            return;
        }
        const symbol = getSymbolOfDeclaration(node);
        const target = resolveAlias(symbol);
        if (target) {
            const markAlias = target === unknownSymbol || getAllSymbolFlags(target) & 111551 && !isConstEnumOrConstEnumOnlyModule(target) && !getTypeOnlyAliasDeclaration(symbol, 111551);
            if (markAlias) {
                markAliasSymbolAsReferenced(symbol);
            }
        }
    }
    function markAliasSymbolAsReferenced(symbol) {
        Debug.assert(!compilerOptions.verbatimModuleSyntax);
        const links = getSymbolLinks(symbol);
        if (!links.referenced) {
            links.referenced = true;
            const node = getDeclarationOfAliasSymbol(symbol);
            if (!node) return Debug.fail();
            if (isInternalModuleImportEqualsDeclaration(node)) {
                if (getAllSymbolFlags(resolveSymbol(symbol)) & 111551) {
                    checkExpressionCached(node.moduleReference);
                }
            }
        }
    }
    function markConstEnumAliasAsReferenced(symbol) {
        const links = getSymbolLinks(symbol);
        if (!links.constEnumReferenced) {
            links.constEnumReferenced = true;
        }
    }
    function getSymbolOfPartOfRightHandSideOfImportEquals(entityName, dontResolveAlias) {
        if (entityName.kind === 79 && isRightSideOfQualifiedNameOrPropertyAccess(entityName)) {
            entityName = entityName.parent;
        }
        if (entityName.kind === 79 || entityName.parent.kind === 163) {
            return resolveEntityName(entityName, 1920, false, dontResolveAlias);
        } else {
            Debug.assert(entityName.parent.kind === 268);
            return resolveEntityName(entityName, 111551 | 788968 | 1920, false, dontResolveAlias);
        }
    }
    function getFullyQualifiedName(symbol, containingLocation) {
        return symbol.parent ? getFullyQualifiedName(symbol.parent, containingLocation) + "." + symbolToString(symbol) : symbolToString(symbol, containingLocation, void 0, 32 | 4);
    }
    function getContainingQualifiedNameNode(node) {
        while (isQualifiedName(node.parent)) {
            node = node.parent;
        }
        return node;
    }
    function tryGetQualifiedNameAsValue(node) {
        let left = getFirstIdentifier(node);
        let symbol = resolveName(left, left.escapedText, 111551, void 0, left, true);
        if (!symbol) {
            return void 0;
        }
        while (isQualifiedName(left.parent)) {
            const type = getTypeOfSymbol(symbol);
            symbol = getPropertyOfType(type, left.parent.right.escapedText);
            if (!symbol) {
                return void 0;
            }
            left = left.parent;
        }
        return symbol;
    }
    function resolveEntityName(name, meaning, ignoreErrors, dontResolveAlias, location) {
        if (nodeIsMissing(name)) {
            return void 0;
        }
        const namespaceMeaning = 1920 | (isInJSFile(name) ? meaning & 111551 : 0);
        let symbol;
        if (name.kind === 79) {
            const message = meaning === namespaceMeaning || nodeIsSynthesized(name) ? Diagnostics.Cannot_find_namespace_0 : getCannotFindNameDiagnosticForName(getFirstIdentifier(name));
            const symbolFromJSPrototype = isInJSFile(name) && !nodeIsSynthesized(name) ? resolveEntityNameFromAssignmentDeclaration(name, meaning) : void 0;
            symbol = getMergedSymbol(resolveName(location || name, name.escapedText, meaning, ignoreErrors || symbolFromJSPrototype ? void 0 : message, name, true, false));
            if (!symbol) {
                return getMergedSymbol(symbolFromJSPrototype);
            }
        } else if (name.kind === 163 || name.kind === 208) {
            const left = name.kind === 163 ? name.left : name.expression;
            const right = name.kind === 163 ? name.right : name.name;
            let namespace = resolveEntityName(left, namespaceMeaning, ignoreErrors, false, location);
            if (!namespace || nodeIsMissing(right)) {
                return void 0;
            } else if (namespace === unknownSymbol) {
                return namespace;
            }
            if (namespace.valueDeclaration && isInJSFile(namespace.valueDeclaration) && getEmitModuleResolutionKind(compilerOptions) !== 100 && isVariableDeclaration(namespace.valueDeclaration) && namespace.valueDeclaration.initializer && isCommonJsRequire(namespace.valueDeclaration.initializer)) {
                const moduleName = namespace.valueDeclaration.initializer.arguments[0];
                const moduleSym = resolveExternalModuleName(moduleName, moduleName);
                if (moduleSym) {
                    const resolvedModuleSymbol = resolveExternalModuleSymbol(moduleSym);
                    if (resolvedModuleSymbol) {
                        namespace = resolvedModuleSymbol;
                    }
                }
            }
            symbol = getMergedSymbol(getSymbol2(getExportsOfSymbol(namespace), right.escapedText, meaning));
            if (!symbol) {
                if (!ignoreErrors) {
                    const namespaceName = getFullyQualifiedName(namespace);
                    const declarationName = declarationNameToString(right);
                    const suggestionForNonexistentModule = getSuggestedSymbolForNonexistentModule(right, namespace);
                    if (suggestionForNonexistentModule) {
                        error(right, Diagnostics._0_has_no_exported_member_named_1_Did_you_mean_2, namespaceName, declarationName, symbolToString(suggestionForNonexistentModule));
                        return void 0;
                    }
                    const containingQualifiedName = isQualifiedName(name) && getContainingQualifiedNameNode(name);
                    const canSuggestTypeof = globalObjectType && meaning & 788968 && containingQualifiedName && !isTypeOfExpression(containingQualifiedName.parent) && tryGetQualifiedNameAsValue(containingQualifiedName);
                    if (canSuggestTypeof) {
                        error(containingQualifiedName, Diagnostics._0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0, entityNameToString(containingQualifiedName));
                        return void 0;
                    }
                    if (meaning & 1920 && isQualifiedName(name.parent)) {
                        const exportedTypeSymbol = getMergedSymbol(getSymbol2(getExportsOfSymbol(namespace), right.escapedText, 788968));
                        if (exportedTypeSymbol) {
                            error(name.parent.right, Diagnostics.Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1, symbolToString(exportedTypeSymbol), unescapeLeadingUnderscores(name.parent.right.escapedText));
                            return void 0;
                        }
                    }
                    error(right, Diagnostics.Namespace_0_has_no_exported_member_1, namespaceName, declarationName);
                }
                return void 0;
            }
        } else {
            throw Debug.assertNever(name, "Unknown entity name kind.");
        }
        Debug.assert((getCheckFlags(symbol) & 1) === 0, "Should never get an instantiated symbol here.");
        if (!nodeIsSynthesized(name) && isEntityName(name) && (symbol.flags & 2097152 || name.parent.kind === 274)) {
            markSymbolOfAliasDeclarationIfTypeOnly(getAliasDeclarationFromName(name), symbol, void 0, true);
        }
        return symbol.flags & meaning || dontResolveAlias ? symbol : resolveAlias(symbol);
    }
    function resolveEntityNameFromAssignmentDeclaration(name, meaning) {
        if (isJSDocTypeReference(name.parent)) {
            const secondaryLocation = getAssignmentDeclarationLocation(name.parent);
            if (secondaryLocation) {
                return resolveName(secondaryLocation, name.escapedText, meaning, void 0, name, true);
            }
        }
    }
    function getAssignmentDeclarationLocation(node) {
        const typeAlias = findAncestor(node, node2 => !(isJSDocNode(node2) || node2.flags & 8388608) ? "quit" : isJSDocTypeAlias(node2));
        if (typeAlias) {
            return;
        }
        const host2 = getJSDocHost(node);
        if (host2 && isExpressionStatement(host2) && isPrototypePropertyAssignment(host2.expression)) {
            const symbol = getSymbolOfDeclaration(host2.expression.left);
            if (symbol) {
                return getDeclarationOfJSPrototypeContainer(symbol);
            }
        }
        if (host2 && isFunctionExpression(host2) && isPrototypePropertyAssignment(host2.parent) && isExpressionStatement(host2.parent.parent)) {
            const symbol = getSymbolOfDeclaration(host2.parent.left);
            if (symbol) {
                return getDeclarationOfJSPrototypeContainer(symbol);
            }
        }
        if (host2 && (isObjectLiteralMethod(host2) || isPropertyAssignment(host2)) && isBinaryExpression(host2.parent.parent) && getAssignmentDeclarationKind(host2.parent.parent) === 6) {
            const symbol = getSymbolOfDeclaration(host2.parent.parent.left);
            if (symbol) {
                return getDeclarationOfJSPrototypeContainer(symbol);
            }
        }
        const sig = getEffectiveJSDocHost(node);
        if (sig && isFunctionLike(sig)) {
            const symbol = getSymbolOfDeclaration(sig);
            return symbol && symbol.valueDeclaration;
        }
    }
    function getDeclarationOfJSPrototypeContainer(symbol) {
        const decl = symbol.parent.valueDeclaration;
        if (!decl) {
            return void 0;
        }
        const initializer = isAssignmentDeclaration(decl) ? getAssignedExpandoInitializer(decl) : hasOnlyExpressionInitializer(decl) ? getDeclaredExpandoInitializer(decl) : void 0;
        return initializer || decl;
    }
    function getExpandoSymbol(symbol) {
        const decl = symbol.valueDeclaration;
        if (!decl || !isInJSFile(decl) || symbol.flags & 524288 || getExpandoInitializer(decl, false)) {
            return void 0;
        }
        const init = isVariableDeclaration(decl) ? getDeclaredExpandoInitializer(decl) : getAssignedExpandoInitializer(decl);
        if (init) {
            const initSymbol = getSymbolOfNode(init);
            if (initSymbol) {
                return mergeJSSymbols(initSymbol, symbol);
            }
        }
    }
    function resolveExternalModuleName(location, moduleReferenceExpression, ignoreErrors) {
        const isClassic = getEmitModuleResolutionKind(compilerOptions) === 1;
        const errorMessage = isClassic ? Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option : Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations;
        return resolveExternalModuleNameWorker(location, moduleReferenceExpression, ignoreErrors ? void 0 : errorMessage);
    }
    function resolveExternalModuleNameWorker(location, moduleReferenceExpression, moduleNotFoundError, isForAugmentation = false) {
        return isStringLiteralLike(moduleReferenceExpression) ? resolveExternalModule(location, moduleReferenceExpression.text, moduleNotFoundError, moduleReferenceExpression, isForAugmentation) : void 0;
    }
    function resolveExternalModule(location, moduleReference, moduleNotFoundError, errorNode, isForAugmentation = false) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
        if (startsWith(moduleReference, "@types/")) {
            const diag2 = Diagnostics.Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1;
            const withoutAtTypePrefix = removePrefix(moduleReference, "@types/");
            error(errorNode, diag2, withoutAtTypePrefix, moduleReference);
        }
        const ambientModule = tryFindAmbientModule(moduleReference, true);
        if (ambientModule) {
            return ambientModule;
        }
        const currentSourceFile = getSourceFileOfNode(location);
        const contextSpecifier = isStringLiteralLike(location) ? location : ((_a2 = findAncestor(location, isImportCall)) == null ? void 0 : _a2.arguments[0]) || ((_b = findAncestor(location, isImportDeclaration)) == null ? void 0 : _b.moduleSpecifier) || ((_c = findAncestor(location, isExternalModuleImportEqualsDeclaration)) == null ? void 0 : _c.moduleReference.expression) || ((_d = findAncestor(location, isExportDeclaration)) == null ? void 0 : _d.moduleSpecifier) || ((_e = isModuleDeclaration(location) ? location : location.parent && isModuleDeclaration(location.parent) && location.parent.name === location ? location.parent : void 0) == null ? void 0 : _e.name) || ((_f = isLiteralImportTypeNode(location) ? location : void 0) == null ? void 0 : _f.argument.literal);
        const mode = contextSpecifier && isStringLiteralLike(contextSpecifier) ? getModeForUsageLocation(currentSourceFile, contextSpecifier) : currentSourceFile.impliedNodeFormat;
        const moduleResolutionKind = getEmitModuleResolutionKind(compilerOptions);
        const resolvedModule = getResolvedModule(currentSourceFile, moduleReference, mode);
        const resolutionDiagnostic = resolvedModule && getResolutionDiagnostic(compilerOptions, resolvedModule, currentSourceFile);
        const sourceFile = resolvedModule && (!resolutionDiagnostic || resolutionDiagnostic === Diagnostics.Module_0_was_resolved_to_1_but_jsx_is_not_set) && host.getSourceFile(resolvedModule.resolvedFileName);
        if (sourceFile) {
            if (resolutionDiagnostic) {
                error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName);
            }
            if (resolvedModule.resolvedUsingTsExtension && isDeclarationFileName(moduleReference)) {
                const importOrExport = ((_g = findAncestor(location, isImportDeclaration)) == null ? void 0 : _g.importClause) || findAncestor(location, or(isImportEqualsDeclaration, isExportDeclaration));
                if (importOrExport && !importOrExport.isTypeOnly || findAncestor(location, isImportCall)) {
                    error(errorNode, Diagnostics.A_declaration_file_cannot_be_imported_without_import_type_Did_you_mean_to_import_an_implementation_file_0_instead, getSuggestedImportSource(Debug.checkDefined(tryExtractTSExtension(moduleReference))));
                }
            } else if (resolvedModule.resolvedUsingTsExtension && !shouldAllowImportingTsExtension(compilerOptions, currentSourceFile.fileName)) {
                const tsExtension = Debug.checkDefined(tryExtractTSExtension(moduleReference));
                error(errorNode, Diagnostics.An_import_path_can_only_end_with_a_0_extension_when_allowImportingTsExtensions_is_enabled, tsExtension);
            }
            if (sourceFile.symbol) {
                if (resolvedModule.isExternalLibraryImport && !resolutionExtensionIsTSOrJson(resolvedModule.extension)) {
                    errorOnImplicitAnyModule(false, errorNode, currentSourceFile, mode, resolvedModule, moduleReference);
                }
                if (moduleResolutionKind === 3 || moduleResolutionKind === 99) {
                    const isSyncImport = currentSourceFile.impliedNodeFormat === 1 && !findAncestor(location, isImportCall) || !!findAncestor(location, isImportEqualsDeclaration);
                    const overrideClauseHost = findAncestor(location, l => isImportTypeNode(l) || isExportDeclaration(l) || isImportDeclaration(l));
                    const overrideClause = overrideClauseHost && isImportTypeNode(overrideClauseHost) ? (_h = overrideClauseHost.assertions) == null ? void 0 : _h.assertClause : overrideClauseHost == null ? void 0 : overrideClauseHost.assertClause;
                    if (isSyncImport && sourceFile.impliedNodeFormat === 99 && !getResolutionModeOverrideForClause(overrideClause)) {
                        if (findAncestor(location, isImportEqualsDeclaration)) {
                            error(errorNode, Diagnostics.Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_cannot_be_imported_with_require_Use_an_ECMAScript_import_instead, moduleReference);
                        } else {
                            let diagnosticDetails;
                            const ext = tryGetExtensionFromPath2(currentSourceFile.fileName);
                            if (ext === ".ts" || ext === ".js" || ext === ".tsx" || ext === ".jsx") {
                                const scope = currentSourceFile.packageJsonScope;
                                const targetExt = ext === ".ts" ? ".mts" : ext === ".js" ? ".mjs" : void 0;
                                if (scope && !scope.contents.packageJsonContent.type) {
                                    if (targetExt) {
                                        diagnosticDetails = chainDiagnosticMessages(void 0, Diagnostics.To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_add_the_field_type_Colon_module_to_1, targetExt, combinePaths(scope.packageDirectory, "package.json"));
                                    } else {
                                        diagnosticDetails = chainDiagnosticMessages(void 0, Diagnostics.To_convert_this_file_to_an_ECMAScript_module_add_the_field_type_Colon_module_to_0, combinePaths(scope.packageDirectory, "package.json"));
                                    }
                                } else {
                                    if (targetExt) {
                                        diagnosticDetails = chainDiagnosticMessages(void 0, Diagnostics.To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_create_a_local_package_json_file_with_type_Colon_module, targetExt);
                                    } else {
                                        diagnosticDetails = chainDiagnosticMessages(void 0, Diagnostics.To_convert_this_file_to_an_ECMAScript_module_create_a_local_package_json_file_with_type_Colon_module);
                                    }
                                }
                            }
                            diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode), errorNode, chainDiagnosticMessages(diagnosticDetails, Diagnostics.The_current_file_is_a_CommonJS_module_whose_imports_will_produce_require_calls_however_the_referenced_file_is_an_ECMAScript_module_and_cannot_be_imported_with_require_Consider_writing_a_dynamic_import_0_call_instead, moduleReference)));
                        }
                    }
                }
                return getMergedSymbol(sourceFile.symbol);
            }
            if (moduleNotFoundError) {
                error(errorNode, Diagnostics.File_0_is_not_a_module, sourceFile.fileName);
            }
            return void 0;
        }
        if (patternAmbientModules) {
            const pattern = findBestPatternMatch(patternAmbientModules, _ => _.pattern, moduleReference);
            if (pattern) {
                const augmentation = patternAmbientModuleAugmentations && patternAmbientModuleAugmentations.get(moduleReference);
                if (augmentation) {
                    return getMergedSymbol(augmentation);
                }
                return getMergedSymbol(pattern.symbol);
            }
        }
        if (resolvedModule && !resolutionExtensionIsTSOrJson(resolvedModule.extension) && resolutionDiagnostic === void 0 || resolutionDiagnostic === Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type) {
            if (isForAugmentation) {
                const diag2 = Diagnostics.Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented;
                error(errorNode, diag2, moduleReference, resolvedModule.resolvedFileName);
            } else {
                errorOnImplicitAnyModule(noImplicitAny && !!moduleNotFoundError, errorNode, currentSourceFile, mode, resolvedModule, moduleReference);
            }
            return void 0;
        }
        if (moduleNotFoundError) {
            if (resolvedModule) {
                const redirect = host.getProjectReferenceRedirect(resolvedModule.resolvedFileName);
                if (redirect) {
                    error(errorNode, Diagnostics.Output_file_0_has_not_been_built_from_source_file_1, redirect, resolvedModule.resolvedFileName);
                    return void 0;
                }
            }
            if (resolutionDiagnostic) {
                error(errorNode, resolutionDiagnostic, moduleReference, resolvedModule.resolvedFileName);
            } else {
                const isExtensionlessRelativePathImport = pathIsRelative(moduleReference) && !hasExtension(moduleReference);
                const resolutionIsNode16OrNext = moduleResolutionKind === 3 || moduleResolutionKind === 99;
                if (!getResolveJsonModule(compilerOptions) && fileExtensionIs(moduleReference, ".json") && moduleResolutionKind !== 1 && hasJsonModuleEmitEnabled(compilerOptions)) {
                    error(errorNode, Diagnostics.Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension, moduleReference);
                } else if (mode === 99 && resolutionIsNode16OrNext && isExtensionlessRelativePathImport) {
                    const absoluteRef = getNormalizedAbsolutePath(moduleReference, getDirectoryPath(currentSourceFile.path));
                    const suggestedExt = (_i = suggestedExtensions.find(([actualExt, _importExt]) => host.fileExists(absoluteRef + actualExt))) == null ? void 0 : _i[1];
                    if (suggestedExt) {
                        error(errorNode, Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_node16_or_nodenext_Did_you_mean_0, moduleReference + suggestedExt);
                    } else {
                        error(errorNode, Diagnostics.Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_node16_or_nodenext_Consider_adding_an_extension_to_the_import_path);
                    }
                } else {
                    error(errorNode, moduleNotFoundError, moduleReference);
                }
            }
        }
        return void 0;
        function getSuggestedImportSource(tsExtension) {
            const importSourceWithoutExtension = removeExtension(moduleReference, tsExtension);
            if (emitModuleKindIsNonNodeESM(moduleKind) || mode === 99) {
                const preferTs = isDeclarationFileName(moduleReference) && shouldAllowImportingTsExtension(compilerOptions);
                const ext = tsExtension === ".mts" || tsExtension === ".d.mts" ? preferTs ? ".mts" : ".mjs" : tsExtension === ".cts" || tsExtension === ".d.mts" ? preferTs ? ".cts" : ".cjs" : preferTs ? ".ts" : ".js";
                return importSourceWithoutExtension + ext;
            }
            return importSourceWithoutExtension;
        }
    }
    function errorOnImplicitAnyModule(isError, errorNode, sourceFile, mode, {
        packageId,
        resolvedFileName
    }, moduleReference) {
        var _a2, _b;
        let errorInfo;
        if (!isExternalModuleNameRelative(moduleReference) && packageId) {
            const node10Result = (_b = (_a2 = sourceFile.resolvedModules) == null ? void 0 : _a2.get(moduleReference, mode)) == null ? void 0 : _b.node10Result;
            errorInfo = node10Result ? chainDiagnosticMessages(void 0, Diagnostics.There_are_types_at_0_but_this_result_could_not_be_resolved_when_respecting_package_json_exports_The_1_library_may_need_to_update_its_package_json_or_typings, node10Result, node10Result.indexOf(nodeModulesPathPart + "@types/") > -1 ? `@types/${mangleScopedPackageName(packageId.name)}` : packageId.name) : typesPackageExists(packageId.name) ? chainDiagnosticMessages(void 0, Diagnostics.If_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_Colon_Slash_Slashgithub_com_SlashDefinitelyTyped_SlashDefinitelyTyped_Slashtree_Slashmaster_Slashtypes_Slash_1, packageId.name, mangleScopedPackageName(packageId.name)) : packageBundlesTypes(packageId.name) ? chainDiagnosticMessages(void 0, Diagnostics.If_the_0_package_actually_exposes_this_module_try_adding_a_new_declaration_d_ts_file_containing_declare_module_1, packageId.name, moduleReference) : chainDiagnosticMessages(void 0, Diagnostics.Try_npm_i_save_dev_types_Slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare_module_0, moduleReference, mangleScopedPackageName(packageId.name));
        }
        errorOrSuggestion(isError, errorNode, chainDiagnosticMessages(errorInfo, Diagnostics.Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type, moduleReference, resolvedFileName));
    }
    function typesPackageExists(packageName) {
        return getPackagesMap().has(getTypesPackageName(packageName));
    }
    function packageBundlesTypes(packageName) {
        return !!getPackagesMap().get(packageName);
    }
    function resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias) {
        if (moduleSymbol == null ? void 0 : moduleSymbol.exports) {
            const exportEquals = resolveSymbol(moduleSymbol.exports.get("export="), dontResolveAlias);
            const exported = getCommonJsExportEquals(getMergedSymbol(exportEquals), getMergedSymbol(moduleSymbol));
            return getMergedSymbol(exported) || moduleSymbol;
        }
        return void 0;
    }
    function getCommonJsExportEquals(exported, moduleSymbol) {
        if (!exported || exported === unknownSymbol || exported === moduleSymbol || moduleSymbol.exports.size === 1 || exported.flags & 2097152) {
            return exported;
        }
        const links = getSymbolLinks(exported);
        if (links.cjsExportMerged) {
            return links.cjsExportMerged;
        }
        const merged = exported.flags & 33554432 ? exported : cloneSymbol(exported);
        merged.flags = merged.flags | 512;
        if (merged.exports === void 0) {
            merged.exports = createSymbolTable();
        }
        moduleSymbol.exports.forEach((s, name) => {
            if (name === "export=") return;
            merged.exports.set(name, merged.exports.has(name) ? mergeSymbol(merged.exports.get(name), s) : s);
        });
        getSymbolLinks(merged).cjsExportMerged = merged;
        return links.cjsExportMerged = merged;
    }
    function resolveESModuleSymbol(moduleSymbol, referencingLocation, dontResolveAlias, suppressInteropError) {
        var _a2;
        const symbol = resolveExternalModuleSymbol(moduleSymbol, dontResolveAlias);
        if (!dontResolveAlias && symbol) {
            if (!suppressInteropError && !(symbol.flags & (1536 | 3)) && !getDeclarationOfKind(symbol, 308)) {
                const compilerOptionName = moduleKind >= 5 ? "allowSyntheticDefaultImports" : "esModuleInterop";
                error(referencingLocation, Diagnostics.This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export, compilerOptionName);
                return symbol;
            }
            const referenceParent = referencingLocation.parent;
            if (isImportDeclaration(referenceParent) && getNamespaceDeclarationNode(referenceParent) || isImportCall(referenceParent)) {
                const reference = isImportCall(referenceParent) ? referenceParent.arguments[0] : referenceParent.moduleSpecifier;
                const type = getTypeOfSymbol(symbol);
                const defaultOnlyType = getTypeWithSyntheticDefaultOnly(type, symbol, moduleSymbol, reference);
                if (defaultOnlyType) {
                    return cloneTypeAsModuleType(symbol, defaultOnlyType, referenceParent);
                }
                const targetFile = (_a2 = moduleSymbol == null ? void 0 : moduleSymbol.declarations) == null ? void 0 : _a2.find(isSourceFile);
                const isEsmCjsRef = targetFile && isESMFormatImportImportingCommonjsFormatFile(getUsageModeForExpression(reference), targetFile.impliedNodeFormat);
                if (getESModuleInterop(compilerOptions) || isEsmCjsRef) {
                    let sigs = getSignaturesOfStructuredType(type, 0);
                    if (!sigs || !sigs.length) {
                        sigs = getSignaturesOfStructuredType(type, 1);
                    }
                    if (sigs && sigs.length || getPropertyOfType(type, "default", true) || isEsmCjsRef) {
                        const moduleType = getTypeWithSyntheticDefaultImportType(type, symbol, moduleSymbol, reference);
                        return cloneTypeAsModuleType(symbol, moduleType, referenceParent);
                    }
                }
            }
        }
        return symbol;
    }
    function cloneTypeAsModuleType(symbol, moduleType, referenceParent) {
        const result = createSymbol(symbol.flags, symbol.escapedName);
        result.declarations = symbol.declarations ? symbol.declarations.slice() : [];
        result.parent = symbol.parent;
        result.links.target = symbol;
        result.links.originatingImport = referenceParent;
        if (symbol.valueDeclaration) result.valueDeclaration = symbol.valueDeclaration;
        if (symbol.constEnumOnlyModule) result.constEnumOnlyModule = true;
        if (symbol.members) result.members = new Map(symbol.members);
        if (symbol.exports) result.exports = new Map(symbol.exports);
        const resolvedModuleType = resolveStructuredTypeMembers(moduleType);
        result.links.type = createAnonymousType(result, resolvedModuleType.members, emptyArray, emptyArray, resolvedModuleType.indexInfos);
        return result;
    }
    function hasExportAssignmentSymbol(moduleSymbol) {
        return moduleSymbol.exports.get("export=") !== void 0;
    }
    function getExportsOfModuleAsArray(moduleSymbol) {
        return symbolsToArray(getExportsOfModule(moduleSymbol));
    }
    function getExportsAndPropertiesOfModule(moduleSymbol) {
        const exports = getExportsOfModuleAsArray(moduleSymbol);
        const exportEquals = resolveExternalModuleSymbol(moduleSymbol);
        if (exportEquals !== moduleSymbol) {
            const type = getTypeOfSymbol(exportEquals);
            if (shouldTreatPropertiesOfExternalModuleAsExports(type)) {
                addRange(exports, getPropertiesOfType(type));
            }
        }
        return exports;
    }
    function forEachExportAndPropertyOfModule(moduleSymbol, cb) {
        const exports = getExportsOfModule(moduleSymbol);
        exports.forEach((symbol, key) => {
            if (!isReservedMemberName(key)) {
                cb(symbol, key);
            }
        });
        const exportEquals = resolveExternalModuleSymbol(moduleSymbol);
        if (exportEquals !== moduleSymbol) {
            const type = getTypeOfSymbol(exportEquals);
            if (shouldTreatPropertiesOfExternalModuleAsExports(type)) {
                forEachPropertyOfType(type, (symbol, escapedName) => {
                    cb(symbol, escapedName);
                });
            }
        }
    }
    function tryGetMemberInModuleExports(memberName, moduleSymbol) {
        const symbolTable = getExportsOfModule(moduleSymbol);
        if (symbolTable) {
            return symbolTable.get(memberName);
        }
    }
    function tryGetMemberInModuleExportsAndProperties(memberName, moduleSymbol) {
        const symbol = tryGetMemberInModuleExports(memberName, moduleSymbol);
        if (symbol) {
            return symbol;
        }
        const exportEquals = resolveExternalModuleSymbol(moduleSymbol);
        if (exportEquals === moduleSymbol) {
            return void 0;
        }
        const type = getTypeOfSymbol(exportEquals);
        return shouldTreatPropertiesOfExternalModuleAsExports(type) ? getPropertyOfType(type, memberName) : void 0;
    }
    function shouldTreatPropertiesOfExternalModuleAsExports(resolvedExternalModuleType) {
        return !(resolvedExternalModuleType.flags & 134348796 || getObjectFlags(resolvedExternalModuleType) & 1 || isArrayType(resolvedExternalModuleType) || isTupleType(resolvedExternalModuleType));
    }
    function getExportsOfSymbol(symbol) {
        return symbol.flags & 6256 ? getResolvedMembersOrExportsOfSymbol(symbol, "resolvedExports") : symbol.flags & 1536 ? getExportsOfModule(symbol) : symbol.exports || emptySymbols;
    }
    function getExportsOfModule(moduleSymbol) {
        const links = getSymbolLinks(moduleSymbol);
        if (!links.resolvedExports) {
            const {
                exports,
                typeOnlyExportStarMap
            } = getExportsOfModuleWorker(moduleSymbol);
            links.resolvedExports = exports;
            links.typeOnlyExportStarMap = typeOnlyExportStarMap;
        }
        return links.resolvedExports;
    }
    function extendExportSymbols(target, source, lookupTable, exportNode) {
        if (!source) return;
        source.forEach((sourceSymbol, id) => {
            if (id === "default") return;
            const targetSymbol = target.get(id);
            if (!targetSymbol) {
                target.set(id, sourceSymbol);
                if (lookupTable && exportNode) {
                    lookupTable.set(id, {
                        specifierText: getTextOfNode(exportNode.moduleSpecifier)
                    });
                }
            } else if (lookupTable && exportNode && targetSymbol && resolveSymbol(targetSymbol) !== resolveSymbol(sourceSymbol)) {
                const collisionTracker = lookupTable.get(id);
                if (!collisionTracker.exportsWithDuplicate) {
                    collisionTracker.exportsWithDuplicate = [exportNode];
                } else {
                    collisionTracker.exportsWithDuplicate.push(exportNode);
                }
            }
        });
    }
    function getExportsOfModuleWorker(moduleSymbol) {
        const visitedSymbols = [];
        let typeOnlyExportStarMap;
        const nonTypeOnlyNames = /* @__PURE__ */new Set();
        moduleSymbol = resolveExternalModuleSymbol(moduleSymbol);
        const exports = visit(moduleSymbol) || emptySymbols;
        if (typeOnlyExportStarMap) {
            nonTypeOnlyNames.forEach(name => typeOnlyExportStarMap.delete(name));
        }
        return {
            exports,
            typeOnlyExportStarMap
        };
        function visit(symbol, exportStar, isTypeOnly) {
            if (!isTypeOnly && (symbol == null ? void 0 : symbol.exports)) {
                symbol.exports.forEach((_, name) => nonTypeOnlyNames.add(name));
            }
            if (!(symbol && symbol.exports && pushIfUnique(visitedSymbols, symbol))) {
                return;
            }
            const symbols = new Map(symbol.exports);
            const exportStars = symbol.exports.get("__export");
            if (exportStars) {
                const nestedSymbols = createSymbolTable();
                const lookupTable = /* @__PURE__ */new Map();
                if (exportStars.declarations) {
                    for (const node of exportStars.declarations) {
                        const resolvedModule = resolveExternalModuleName(node, node.moduleSpecifier);
                        const exportedSymbols = visit(resolvedModule, node, isTypeOnly || node.isTypeOnly);
                        extendExportSymbols(nestedSymbols, exportedSymbols, lookupTable, node);
                    }
                }
                lookupTable.forEach(({
                    exportsWithDuplicate
                }, id) => {
                    if (id === "export=" || !(exportsWithDuplicate && exportsWithDuplicate.length) || symbols.has(id)) {
                        return;
                    }
                    for (const node of exportsWithDuplicate) {
                        diagnostics.add(createDiagnosticForNode(node, Diagnostics.Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity, lookupTable.get(id).specifierText, unescapeLeadingUnderscores(id)));
                    }
                });
                extendExportSymbols(symbols, nestedSymbols);
            }
            if (exportStar == null ? void 0 : exportStar.isTypeOnly) {
                typeOnlyExportStarMap != null ? typeOnlyExportStarMap : typeOnlyExportStarMap = /* @__PURE__ */new Map();
                symbols.forEach((_, escapedName) => typeOnlyExportStarMap.set(escapedName, exportStar));
            }
            return symbols;
        }
    }
    function getMergedSymbol(symbol) {
        let merged;
        return symbol && symbol.mergeId && (merged = mergedSymbols[symbol.mergeId]) ? merged : symbol;
    }
    function getSymbolOfDeclaration(node) {
        return getMergedSymbol(node.symbol && getLateBoundSymbol(node.symbol));
    }
    function getSymbolOfNode(node) {
        return canHaveSymbol(node) ? getSymbolOfDeclaration(node) : void 0;
    }
    function getParentOfSymbol(symbol) {
        return getMergedSymbol(symbol.parent && getLateBoundSymbol(symbol.parent));
    }
    function getAlternativeContainingModules(symbol, enclosingDeclaration) {
        const containingFile = getSourceFileOfNode(enclosingDeclaration);
        const id = getNodeId(containingFile);
        const links = getSymbolLinks(symbol);
        let results;
        if (links.extendedContainersByFile && (results = links.extendedContainersByFile.get(id))) {
            return results;
        }
        if (containingFile && containingFile.imports) {
            for (const importRef of containingFile.imports) {
                if (nodeIsSynthesized(importRef)) continue;
                const resolvedModule = resolveExternalModuleName(enclosingDeclaration, importRef, true);
                if (!resolvedModule) continue;
                const ref = getAliasForSymbolInContainer(resolvedModule, symbol);
                if (!ref) continue;
                results = append(results, resolvedModule);
            }
            if (length(results)) {
                (links.extendedContainersByFile || (links.extendedContainersByFile = /* @__PURE__ */new Map())).set(id, results);
                return results;
            }
        }
        if (links.extendedContainers) {
            return links.extendedContainers;
        }
        const otherFiles = host.getSourceFiles();
        for (const file of otherFiles) {
            if (!isExternalModule(file)) continue;
            const sym = getSymbolOfDeclaration(file);
            const ref = getAliasForSymbolInContainer(sym, symbol);
            if (!ref) continue;
            results = append(results, sym);
        }
        return links.extendedContainers = results || emptyArray;
    }
    function getContainersOfSymbol(symbol, enclosingDeclaration, meaning) {
        const container = getParentOfSymbol(symbol);
        if (container && !(symbol.flags & 262144)) {
            const additionalContainers = mapDefined(container.declarations, fileSymbolIfFileSymbolExportEqualsContainer);
            const reexportContainers = enclosingDeclaration && getAlternativeContainingModules(symbol, enclosingDeclaration);
            const objectLiteralContainer = getVariableDeclarationOfObjectLiteral(container, meaning);
            if (enclosingDeclaration && container.flags & getQualifiedLeftMeaning(meaning) && getAccessibleSymbolChain(container, enclosingDeclaration, 1920, false)) {
                return append(concatenate(concatenate([container], additionalContainers), reexportContainers), objectLiteralContainer);
            }
            const firstVariableMatch = !(container.flags & getQualifiedLeftMeaning(meaning)) && container.flags & 788968 && getDeclaredTypeOfSymbol(container).flags & 524288 && meaning === 111551 ? forEachSymbolTableInScope(enclosingDeclaration, t => {
                return forEachEntry(t, s => {
                    if (s.flags & getQualifiedLeftMeaning(meaning) && getTypeOfSymbol(s) === getDeclaredTypeOfSymbol(container)) {
                        return s;
                    }
                });
            }) : void 0;
            let res = firstVariableMatch ? [firstVariableMatch, ...additionalContainers, container] : [...additionalContainers, container];
            res = append(res, objectLiteralContainer);
            res = addRange(res, reexportContainers);
            return res;
        }
        const candidates = mapDefined(symbol.declarations, d => {
            if (!isAmbientModule(d) && d.parent) {
                if (hasNonGlobalAugmentationExternalModuleSymbol(d.parent)) {
                    return getSymbolOfDeclaration(d.parent);
                }
                if (isModuleBlock(d.parent) && d.parent.parent && resolveExternalModuleSymbol(getSymbolOfDeclaration(d.parent.parent)) === symbol) {
                    return getSymbolOfDeclaration(d.parent.parent);
                }
            }
            if (isClassExpression(d) && isBinaryExpression(d.parent) && d.parent.operatorToken.kind === 63 && isAccessExpression(d.parent.left) && isEntityNameExpression(d.parent.left.expression)) {
                if (isModuleExportsAccessExpression(d.parent.left) || isExportsIdentifier(d.parent.left.expression)) {
                    return getSymbolOfDeclaration(getSourceFileOfNode(d));
                }
                checkExpressionCached(d.parent.left.expression);
                return getNodeLinks(d.parent.left.expression).resolvedSymbol;
            }
        });
        if (!length(candidates)) {
            return void 0;
        }
        return mapDefined(candidates, candidate => getAliasForSymbolInContainer(candidate, symbol) ? candidate : void 0);
        function fileSymbolIfFileSymbolExportEqualsContainer(d) {
            return container && getFileSymbolIfFileSymbolExportEqualsContainer(d, container);
        }
    }
    function getVariableDeclarationOfObjectLiteral(symbol, meaning) {
        const firstDecl = !!length(symbol.declarations) && first(symbol.declarations);
        if (meaning & 111551 && firstDecl && firstDecl.parent && isVariableDeclaration(firstDecl.parent)) {
            if (isObjectLiteralExpression(firstDecl) && firstDecl === firstDecl.parent.initializer || isTypeLiteralNode(firstDecl) && firstDecl === firstDecl.parent.type) {
                return getSymbolOfDeclaration(firstDecl.parent);
            }
        }
    }
    function getFileSymbolIfFileSymbolExportEqualsContainer(d, container) {
        const fileSymbol = getExternalModuleContainer(d);
        const exported = fileSymbol && fileSymbol.exports && fileSymbol.exports.get("export=");
        return exported && getSymbolIfSameReference(exported, container) ? fileSymbol : void 0;
    }
    function getAliasForSymbolInContainer(container, symbol) {
        if (container === getParentOfSymbol(symbol)) {
            return symbol;
        }
        const exportEquals = container.exports && container.exports.get("export=");
        if (exportEquals && getSymbolIfSameReference(exportEquals, symbol)) {
            return container;
        }
        const exports = getExportsOfSymbol(container);
        const quick = exports.get(symbol.escapedName);
        if (quick && getSymbolIfSameReference(quick, symbol)) {
            return quick;
        }
        return forEachEntry(exports, exported => {
            if (getSymbolIfSameReference(exported, symbol)) {
                return exported;
            }
        });
    }
    function getSymbolIfSameReference(s1, s2) {
        if (getMergedSymbol(resolveSymbol(getMergedSymbol(s1))) === getMergedSymbol(resolveSymbol(getMergedSymbol(s2)))) {
            return s1;
        }
    }
    function getExportSymbolOfValueSymbolIfExported(symbol) {
        return getMergedSymbol(symbol && (symbol.flags & 1048576) !== 0 && symbol.exportSymbol || symbol);
    }
    function symbolIsValue(symbol, includeTypeOnlyMembers) {
        return !!(symbol.flags & 111551 || symbol.flags & 2097152 && getAllSymbolFlags(symbol) & 111551 && (includeTypeOnlyMembers || !getTypeOnlyAliasDeclaration(symbol)));
    }
    function findConstructorDeclaration(node) {
        const members = node.members;
        for (const member of members) {
            if (member.kind === 173 && nodeIsPresent(member.body)) {
                return member;
            }
        }
    }
    function createType(flags) {
        var _a2;
        const result = new Type27(checker, flags);
        typeCount++;
        result.id = typeCount;
        (_a2 = tracing) == null ? void 0 : _a2.recordType(result);
        return result;
    }
    function createTypeWithSymbol(flags, symbol) {
        const result = createType(flags);
        result.symbol = symbol;
        return result;
    }
    function createOriginType(flags) {
        return new Type27(checker, flags);
    }
    function createIntrinsicType(kind, intrinsicName, objectFlags = 0) {
        const type = createType(kind);
        type.intrinsicName = intrinsicName;
        type.objectFlags = objectFlags;
        return type;
    }
    function createObjectType(objectFlags, symbol) {
        const type = createTypeWithSymbol(524288, symbol);
        type.objectFlags = objectFlags;
        type.members = void 0;
        type.properties = void 0;
        type.callSignatures = void 0;
        type.constructSignatures = void 0;
        type.indexInfos = void 0;
        return type;
    }
    function createTypeofType() {
        return getUnionType(arrayFrom(typeofNEFacts.keys(), getStringLiteralType));
    }
    function createTypeParameter(symbol) {
        return createTypeWithSymbol(262144, symbol);
    }
    function isReservedMemberName(name) {
        return name.charCodeAt(0) === 95 && name.charCodeAt(1) === 95 && name.charCodeAt(2) !== 95 && name.charCodeAt(2) !== 64 && name.charCodeAt(2) !== 35;
    }
    function getNamedMembers(members) {
        let result;
        members.forEach((symbol, id) => {
            if (isNamedMember(symbol, id)) {
                (result || (result = [])).push(symbol);
            }
        });
        return result || emptyArray;
    }
    function isNamedMember(member, escapedName) {
        return !isReservedMemberName(escapedName) && symbolIsValue(member);
    }
    function getNamedOrIndexSignatureMembers(members) {
        const result = getNamedMembers(members);
        const index = getIndexSymbolFromSymbolTable(members);
        return index ? concatenate(result, [index]) : result;
    }
    function setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos) {
        const resolved = type;
        resolved.members = members;
        resolved.properties = emptyArray;
        resolved.callSignatures = callSignatures;
        resolved.constructSignatures = constructSignatures;
        resolved.indexInfos = indexInfos;
        if (members !== emptySymbols) resolved.properties = getNamedMembers(members);
        return resolved;
    }
    function createAnonymousType(symbol, members, callSignatures, constructSignatures, indexInfos) {
        return setStructuredTypeMembers(createObjectType(16, symbol), members, callSignatures, constructSignatures, indexInfos);
    }
    function getResolvedTypeWithoutAbstractConstructSignatures(type) {
        if (type.constructSignatures.length === 0) return type;
        if (type.objectTypeWithoutAbstractConstructSignatures) return type.objectTypeWithoutAbstractConstructSignatures;
        const constructSignatures = filter(type.constructSignatures, signature => !(signature.flags & 4));
        if (type.constructSignatures === constructSignatures) return type;
        const typeCopy = createAnonymousType(type.symbol, type.members, type.callSignatures, some(constructSignatures) ? constructSignatures : emptyArray, type.indexInfos);
        type.objectTypeWithoutAbstractConstructSignatures = typeCopy;
        typeCopy.objectTypeWithoutAbstractConstructSignatures = typeCopy;
        return typeCopy;
    }
    function forEachSymbolTableInScope(enclosingDeclaration, callback) {
        let result;
        for (let location = enclosingDeclaration; location; location = location.parent) {
            if (canHaveLocals(location) && location.locals && !isGlobalSourceFile(location)) {
                if (result = callback(location.locals, void 0, true, location)) {
                    return result;
                }
            }
            switch (location.kind) {
                case 308:
                    if (!isExternalOrCommonJsModule(location)) {
                        break;
                    }
                case 264:
                    const sym = getSymbolOfDeclaration(location);
                    if (result = callback((sym == null ? void 0 : sym.exports) || emptySymbols, void 0, true, location)) {
                        return result;
                    }
                    break;
                case 260:
                case 228:
                case 261:
                    let table;
                    (getSymbolOfDeclaration(location).members || emptySymbols).forEach((memberSymbol, key) => {
                        if (memberSymbol.flags & (788968 & ~67108864)) {
                            (table || (table = createSymbolTable())).set(key, memberSymbol);
                        }
                    });
                    if (table && (result = callback(table, void 0, false, location))) {
                        return result;
                    }
                    break;
            }
        }
        return callback(globals, void 0, true);
    }
    function getQualifiedLeftMeaning(rightMeaning) {
        return rightMeaning === 111551 ? 111551 : 1920;
    }
    function getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning, useOnlyExternalAliasing, visitedSymbolTablesMap = /* @__PURE__ */new Map()) {
        if (!(symbol && !isPropertyOrMethodDeclarationSymbol(symbol))) {
            return void 0;
        }
        const links = getSymbolLinks(symbol);
        const cache = links.accessibleChainCache || (links.accessibleChainCache = /* @__PURE__ */new Map());
        const firstRelevantLocation = forEachSymbolTableInScope(enclosingDeclaration, (_, __, ___, node) => node);
        const key = `${useOnlyExternalAliasing ? 0 : 1}|${firstRelevantLocation && getNodeId(firstRelevantLocation)}|${meaning}`;
        if (cache.has(key)) {
            return cache.get(key);
        }
        const id = getSymbolId(symbol);
        let visitedSymbolTables = visitedSymbolTablesMap.get(id);
        if (!visitedSymbolTables) {
            visitedSymbolTablesMap.set(id, visitedSymbolTables = []);
        }
        const result = forEachSymbolTableInScope(enclosingDeclaration, getAccessibleSymbolChainFromSymbolTable);
        cache.set(key, result);
        return result;
        function getAccessibleSymbolChainFromSymbolTable(symbols, ignoreQualification, isLocalNameLookup) {
            if (!pushIfUnique(visitedSymbolTables, symbols)) {
                return void 0;
            }
            const result2 = trySymbolTable(symbols, ignoreQualification, isLocalNameLookup);
            visitedSymbolTables.pop();
            return result2;
        }
        function canQualifySymbol(symbolFromSymbolTable, meaning2) {
            return !needsQualification(symbolFromSymbolTable, enclosingDeclaration, meaning2) || !!getAccessibleSymbolChain(symbolFromSymbolTable.parent, enclosingDeclaration, getQualifiedLeftMeaning(meaning2), useOnlyExternalAliasing, visitedSymbolTablesMap);
        }
        function isAccessible(symbolFromSymbolTable, resolvedAliasSymbol, ignoreQualification) {
            return (symbol === (resolvedAliasSymbol || symbolFromSymbolTable) || getMergedSymbol(symbol) === getMergedSymbol(resolvedAliasSymbol || symbolFromSymbolTable)) && !some(symbolFromSymbolTable.declarations, hasNonGlobalAugmentationExternalModuleSymbol) && (ignoreQualification || canQualifySymbol(getMergedSymbol(symbolFromSymbolTable), meaning));
        }
        function trySymbolTable(symbols, ignoreQualification, isLocalNameLookup) {
            if (isAccessible(symbols.get(symbol.escapedName), void 0, ignoreQualification)) {
                return [symbol];
            }
            const result2 = forEachEntry(symbols, symbolFromSymbolTable => {
                if (symbolFromSymbolTable.flags & 2097152 && symbolFromSymbolTable.escapedName !== "export=" && symbolFromSymbolTable.escapedName !== "default" && !(isUMDExportSymbol(symbolFromSymbolTable) && enclosingDeclaration && isExternalModule(getSourceFileOfNode(enclosingDeclaration))) && (!useOnlyExternalAliasing || some(symbolFromSymbolTable.declarations, isExternalModuleImportEqualsDeclaration)) && (isLocalNameLookup ? !some(symbolFromSymbolTable.declarations, isNamespaceReexportDeclaration) : true) && (ignoreQualification || !getDeclarationOfKind(symbolFromSymbolTable, 278))) {
                    const resolvedImportedSymbol = resolveAlias(symbolFromSymbolTable);
                    const candidate = getCandidateListForSymbol(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification);
                    if (candidate) {
                        return candidate;
                    }
                }
                if (symbolFromSymbolTable.escapedName === symbol.escapedName && symbolFromSymbolTable.exportSymbol) {
                    if (isAccessible(getMergedSymbol(symbolFromSymbolTable.exportSymbol), void 0, ignoreQualification)) {
                        return [symbol];
                    }
                }
            });
            return result2 || (symbols === globals ? getCandidateListForSymbol(globalThisSymbol, globalThisSymbol, ignoreQualification) : void 0);
        }
        function getCandidateListForSymbol(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification) {
            if (isAccessible(symbolFromSymbolTable, resolvedImportedSymbol, ignoreQualification)) {
                return [symbolFromSymbolTable];
            }
            const candidateTable = getExportsOfSymbol(resolvedImportedSymbol);
            const accessibleSymbolsFromExports = candidateTable && getAccessibleSymbolChainFromSymbolTable(candidateTable, true);
            if (accessibleSymbolsFromExports && canQualifySymbol(symbolFromSymbolTable, getQualifiedLeftMeaning(meaning))) {
                return [symbolFromSymbolTable].concat(accessibleSymbolsFromExports);
            }
        }
    }
    function needsQualification(symbol, enclosingDeclaration, meaning) {
        let qualify = false;
        forEachSymbolTableInScope(enclosingDeclaration, symbolTable => {
            let symbolFromSymbolTable = getMergedSymbol(symbolTable.get(symbol.escapedName));
            if (!symbolFromSymbolTable) {
                return false;
            }
            if (symbolFromSymbolTable === symbol) {
                return true;
            }
            const shouldResolveAlias = symbolFromSymbolTable.flags & 2097152 && !getDeclarationOfKind(symbolFromSymbolTable, 278);
            symbolFromSymbolTable = shouldResolveAlias ? resolveAlias(symbolFromSymbolTable) : symbolFromSymbolTable;
            const flags = shouldResolveAlias ? getAllSymbolFlags(symbolFromSymbolTable) : symbolFromSymbolTable.flags;
            if (flags & meaning) {
                qualify = true;
                return true;
            }
            return false;
        });
        return qualify;
    }
    function isPropertyOrMethodDeclarationSymbol(symbol) {
        if (symbol.declarations && symbol.declarations.length) {
            for (const declaration of symbol.declarations) {
                switch (declaration.kind) {
                    case 169:
                    case 171:
                    case 174:
                    case 175:
                        continue;
                    default:
                        return false;
                }
            }
            return true;
        }
        return false;
    }
    function isTypeSymbolAccessible(typeSymbol, enclosingDeclaration) {
        const access = isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, 788968, false, true);
        return access.accessibility === 0;
    }
    function isValueSymbolAccessible(typeSymbol, enclosingDeclaration) {
        const access = isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, 111551, false, true);
        return access.accessibility === 0;
    }
    function isSymbolAccessibleByFlags(typeSymbol, enclosingDeclaration, flags) {
        const access = isSymbolAccessibleWorker(typeSymbol, enclosingDeclaration, flags, false, false);
        return access.accessibility === 0;
    }
    function isAnySymbolAccessible(symbols, enclosingDeclaration, initialSymbol, meaning, shouldComputeAliasesToMakeVisible, allowModules) {
        if (!length(symbols)) return;
        let hadAccessibleChain;
        let earlyModuleBail = false;
        for (const symbol of symbols) {
            const accessibleSymbolChain = getAccessibleSymbolChain(symbol, enclosingDeclaration, meaning, false);
            if (accessibleSymbolChain) {
                hadAccessibleChain = symbol;
                const hasAccessibleDeclarations = hasVisibleDeclarations(accessibleSymbolChain[0], shouldComputeAliasesToMakeVisible);
                if (hasAccessibleDeclarations) {
                    return hasAccessibleDeclarations;
                }
            }
            if (allowModules) {
                if (some(symbol.declarations, hasNonGlobalAugmentationExternalModuleSymbol)) {
                    if (shouldComputeAliasesToMakeVisible) {
                        earlyModuleBail = true;
                        continue;
                    }
                    return {
                        accessibility: 0
                    };
                }
            }
            const containers = getContainersOfSymbol(symbol, enclosingDeclaration, meaning);
            const parentResult = isAnySymbolAccessible(containers, enclosingDeclaration, initialSymbol, initialSymbol === symbol ? getQualifiedLeftMeaning(meaning) : meaning, shouldComputeAliasesToMakeVisible, allowModules);
            if (parentResult) {
                return parentResult;
            }
        }
        if (earlyModuleBail) {
            return {
                accessibility: 0
            };
        }
        if (hadAccessibleChain) {
            return {
                accessibility: 1,
                errorSymbolName: symbolToString(initialSymbol, enclosingDeclaration, meaning),
                errorModuleName: hadAccessibleChain !== initialSymbol ? symbolToString(hadAccessibleChain, enclosingDeclaration, 1920) : void 0
            };
        }
    }
    function isSymbolAccessible(symbol, enclosingDeclaration, meaning, shouldComputeAliasesToMakeVisible) {
        return isSymbolAccessibleWorker(symbol, enclosingDeclaration, meaning, shouldComputeAliasesToMakeVisible, true);
    }
    function isSymbolAccessibleWorker(symbol, enclosingDeclaration, meaning, shouldComputeAliasesToMakeVisible, allowModules) {
        if (symbol && enclosingDeclaration) {
            const result = isAnySymbolAccessible([symbol], enclosingDeclaration, symbol, meaning, shouldComputeAliasesToMakeVisible, allowModules);
            if (result) {
                return result;
            }
            const symbolExternalModule = forEach(symbol.declarations, getExternalModuleContainer);
            if (symbolExternalModule) {
                const enclosingExternalModule = getExternalModuleContainer(enclosingDeclaration);
                if (symbolExternalModule !== enclosingExternalModule) {
                    return {
                        accessibility: 2,
                        errorSymbolName: symbolToString(symbol, enclosingDeclaration, meaning),
                        errorModuleName: symbolToString(symbolExternalModule),
                        errorNode: isInJSFile(enclosingDeclaration) ? enclosingDeclaration : void 0
                    };
                }
            }
            return {
                accessibility: 1,
                errorSymbolName: symbolToString(symbol, enclosingDeclaration, meaning)
            };
        }
        return {
            accessibility: 0
        };
    }
    function getExternalModuleContainer(declaration) {
        const node = findAncestor(declaration, hasExternalModuleSymbol);
        return node && getSymbolOfDeclaration(node);
    }
    function hasExternalModuleSymbol(declaration) {
        return isAmbientModule(declaration) || declaration.kind === 308 && isExternalOrCommonJsModule(declaration);
    }
    function hasNonGlobalAugmentationExternalModuleSymbol(declaration) {
        return isModuleWithStringLiteralName(declaration) || declaration.kind === 308 && isExternalOrCommonJsModule(declaration);
    }
    function hasVisibleDeclarations(symbol, shouldComputeAliasToMakeVisible) {
        let aliasesToMakeVisible;
        if (!every(filter(symbol.declarations, d => d.kind !== 79), getIsDeclarationVisible)) {
            return void 0;
        }
        return {
            accessibility: 0,
            aliasesToMakeVisible
        };
        function getIsDeclarationVisible(declaration) {
            var _a2, _b;
            if (!isDeclarationVisible(declaration)) {
                const anyImportSyntax = getAnyImportSyntax(declaration);
                if (anyImportSyntax && !hasSyntacticModifier(anyImportSyntax, 1) && isDeclarationVisible(anyImportSyntax.parent)) {
                    return addVisibleAlias(declaration, anyImportSyntax);
                } else if (isVariableDeclaration(declaration) && isVariableStatement(declaration.parent.parent) && !hasSyntacticModifier(declaration.parent.parent, 1) && isDeclarationVisible(declaration.parent.parent.parent)) {
                    return addVisibleAlias(declaration, declaration.parent.parent);
                } else if (isLateVisibilityPaintedStatement(declaration) && !hasSyntacticModifier(declaration, 1) && isDeclarationVisible(declaration.parent)) {
                    return addVisibleAlias(declaration, declaration);
                } else if (isBindingElement(declaration)) {
                    if (symbol.flags & 2097152 && isInJSFile(declaration) && ((_a2 = declaration.parent) == null ? void 0 : _a2.parent) && isVariableDeclaration(declaration.parent.parent) && ((_b = declaration.parent.parent.parent) == null ? void 0 : _b.parent) && isVariableStatement(declaration.parent.parent.parent.parent) && !hasSyntacticModifier(declaration.parent.parent.parent.parent, 1) && declaration.parent.parent.parent.parent.parent && isDeclarationVisible(declaration.parent.parent.parent.parent.parent)) {
                        return addVisibleAlias(declaration, declaration.parent.parent.parent.parent);
                    } else if (symbol.flags & 2) {
                        const variableStatement = findAncestor(declaration, isVariableStatement);
                        if (hasSyntacticModifier(variableStatement, 1)) {
                            return true;
                        }
                        if (!isDeclarationVisible(variableStatement.parent)) {
                            return false;
                        }
                        return addVisibleAlias(declaration, variableStatement);
                    }
                }
                return false;
            }
            return true;
        }
        function addVisibleAlias(declaration, aliasingStatement) {
            if (shouldComputeAliasToMakeVisible) {
                getNodeLinks(declaration).isVisible = true;
                aliasesToMakeVisible = appendIfUnique(aliasesToMakeVisible, aliasingStatement);
            }
            return true;
        }
    }
    function isEntityNameVisible(entityName, enclosingDeclaration) {
        let meaning;
        if (entityName.parent.kind === 183 || entityName.parent.kind === 230 && !isPartOfTypeNode(entityName.parent) || entityName.parent.kind === 164) {
            meaning = 111551 | 1048576;
        } else if (entityName.kind === 163 || entityName.kind === 208 || entityName.parent.kind === 268) {
            meaning = 1920;
        } else {
            meaning = 788968;
        }
        const firstIdentifier = getFirstIdentifier(entityName);
        const symbol = resolveName(enclosingDeclaration, firstIdentifier.escapedText, meaning, void 0, void 0, false);
        if (symbol && symbol.flags & 262144 && meaning & 788968) {
            return {
                accessibility: 0
            };
        }
        if (!symbol && isThisIdentifier(firstIdentifier) && isSymbolAccessible(getSymbolOfDeclaration(getThisContainer(firstIdentifier, false, false)), firstIdentifier, meaning, false).accessibility === 0) {
            return {
                accessibility: 0
            };
        }
        return symbol && hasVisibleDeclarations(symbol, true) || {
            accessibility: 1,
            errorSymbolName: getTextOfNode(firstIdentifier),
            errorNode: firstIdentifier
        };
    }
    function symbolToString(symbol, enclosingDeclaration, meaning, flags = 4, writer) {
        let nodeFlags = 70221824;
        if (flags & 2) {
            nodeFlags |= 128;
        }
        if (flags & 1) {
            nodeFlags |= 512;
        }
        if (flags & 8) {
            nodeFlags |= 16384;
        }
        if (flags & 32) {
            nodeFlags |= 134217728;
        }
        if (flags & 16) {
            nodeFlags |= 1073741824;
        }
        const builder = flags & 4 ? nodeBuilder.symbolToNode : nodeBuilder.symbolToEntityName;
        return writer ? symbolToStringWorker(writer).getText() : usingSingleLineStringWriter(symbolToStringWorker);
        function symbolToStringWorker(writer2) {
            const entity = builder(symbol, meaning, enclosingDeclaration, nodeFlags);
            const printer = (enclosingDeclaration == null ? void 0 : enclosingDeclaration.kind) === 308 ? createPrinterWithRemoveCommentsNeverAsciiEscape() : createPrinterWithRemoveComments();
            const sourceFile = enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration);
            printer.writeNode(4, entity, sourceFile, writer2);
            return writer2;
        }
    }
    function signatureToString(signature, enclosingDeclaration, flags = 0, kind, writer) {
        return writer ? signatureToStringWorker(writer).getText() : usingSingleLineStringWriter(signatureToStringWorker);
        function signatureToStringWorker(writer2) {
            let sigOutput;
            if (flags & 262144) {
                sigOutput = kind === 1 ? 182 : 181;
            } else {
                sigOutput = kind === 1 ? 177 : 176;
            }
            const sig = nodeBuilder.signatureToSignatureDeclaration(signature, sigOutput, enclosingDeclaration, toNodeBuilderFlags(flags) | 70221824 | 512);
            const printer = createPrinterWithRemoveCommentsOmitTrailingSemicolon();
            const sourceFile = enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration);
            printer.writeNode(4, sig, sourceFile, getTrailingSemicolonDeferringWriter(writer2));
            return writer2;
        }
    }
    function typeToString(type, enclosingDeclaration, flags = 1048576 | 16384, writer = createTextWriter("")) {
        const noTruncation = compilerOptions.noErrorTruncation || flags & 1;
        const typeNode = nodeBuilder.typeToTypeNode(type, enclosingDeclaration, toNodeBuilderFlags(flags) | 70221824 | (noTruncation ? 1 : 0));
        if (typeNode === void 0) return Debug.fail("should always get typenode");
        const printer = type !== unresolvedType ? createPrinterWithRemoveComments() : createPrinterWithDefaults();
        const sourceFile = enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration);
        printer.writeNode(4, typeNode, sourceFile, writer);
        const result = writer.getText();
        const maxLength2 = noTruncation ? noTruncationMaximumTruncationLength * 2 : defaultMaximumTruncationLength * 2;
        if (maxLength2 && result && result.length >= maxLength2) {
            return result.substr(0, maxLength2 - "...".length) + "...";
        }
        return result;
    }
    function getTypeNamesForErrorDisplay(left, right) {
        let leftStr = symbolValueDeclarationIsContextSensitive(left.symbol) ? typeToString(left, left.symbol.valueDeclaration) : typeToString(left);
        let rightStr = symbolValueDeclarationIsContextSensitive(right.symbol) ? typeToString(right, right.symbol.valueDeclaration) : typeToString(right);
        if (leftStr === rightStr) {
            leftStr = getTypeNameForErrorDisplay(left);
            rightStr = getTypeNameForErrorDisplay(right);
        }
        return [leftStr, rightStr];
    }
    function getTypeNameForErrorDisplay(type) {
        return typeToString(type, void 0, 64);
    }
    function symbolValueDeclarationIsContextSensitive(symbol) {
        return symbol && !!symbol.valueDeclaration && isExpression(symbol.valueDeclaration) && !isContextSensitive(symbol.valueDeclaration);
    }
    function toNodeBuilderFlags(flags = 0) {
        return flags & 848330091;
    }
    function isClassInstanceSide(type) {
        return !!type.symbol && !!(type.symbol.flags & 32) && (type === getDeclaredTypeOfClassOrInterface(type.symbol) || !!(type.flags & 524288) && !!(getObjectFlags(type) & 16777216));
    }
    function createNodeBuilder() {
        return {
            typeToTypeNode: (type, enclosingDeclaration, flags, tracker) => withContext(enclosingDeclaration, flags, tracker, context => typeToTypeNodeHelper(type, context)),
            indexInfoToIndexSignatureDeclaration: (indexInfo, enclosingDeclaration, flags, tracker) => withContext(enclosingDeclaration, flags, tracker, context => indexInfoToIndexSignatureDeclarationHelper(indexInfo, context, void 0)),
            signatureToSignatureDeclaration: (signature, kind, enclosingDeclaration, flags, tracker) => withContext(enclosingDeclaration, flags, tracker, context => signatureToSignatureDeclarationHelper(signature, kind, context)),
            symbolToEntityName: (symbol, meaning, enclosingDeclaration, flags, tracker) => withContext(enclosingDeclaration, flags, tracker, context => symbolToName(symbol, context, meaning, false)),
            symbolToExpression: (symbol, meaning, enclosingDeclaration, flags, tracker) => withContext(enclosingDeclaration, flags, tracker, context => symbolToExpression(symbol, context, meaning)),
            symbolToTypeParameterDeclarations: (symbol, enclosingDeclaration, flags, tracker) => withContext(enclosingDeclaration, flags, tracker, context => typeParametersToTypeParameterDeclarations(symbol, context)),
            symbolToParameterDeclaration: (symbol, enclosingDeclaration, flags, tracker) => withContext(enclosingDeclaration, flags, tracker, context => symbolToParameterDeclaration(symbol, context)),
            typeParameterToDeclaration: (parameter, enclosingDeclaration, flags, tracker) => withContext(enclosingDeclaration, flags, tracker, context => typeParameterToDeclaration(parameter, context)),
            symbolTableToDeclarationStatements: (symbolTable, enclosingDeclaration, flags, tracker, bundled) => withContext(enclosingDeclaration, flags, tracker, context => symbolTableToDeclarationStatements(symbolTable, context, bundled)),
            symbolToNode: (symbol, meaning, enclosingDeclaration, flags, tracker) => withContext(enclosingDeclaration, flags, tracker, context => symbolToNode(symbol, context, meaning))
        };
        function symbolToNode(symbol, context, meaning) {
            if (context.flags & 1073741824) {
                if (symbol.valueDeclaration) {
                    const name = getNameOfDeclaration(symbol.valueDeclaration);
                    if (name && isComputedPropertyName(name)) return name;
                }
                const nameType = getSymbolLinks(symbol).nameType;
                if (nameType && nameType.flags & (1024 | 8192)) {
                    context.enclosingDeclaration = nameType.symbol.valueDeclaration;
                    return factory.createComputedPropertyName(symbolToExpression(nameType.symbol, context, meaning));
                }
            }
            return symbolToExpression(symbol, context, meaning);
        }
        function withContext(enclosingDeclaration, flags, tracker, cb) {
            Debug.assert(enclosingDeclaration === void 0 || (enclosingDeclaration.flags & 8) === 0);
            const moduleResolverHost = (tracker == null ? void 0 : tracker.trackSymbol) ? tracker.moduleResolverHost : flags & 134217728 ? createBasicNodeBuilderModuleSpecifierResolutionHost(host) : void 0;
            const context = {
                enclosingDeclaration,
                flags: flags || 0,
                tracker: void 0,
                encounteredError: false,
                reportedDiagnostic: false,
                visitedTypes: void 0,
                symbolDepth: void 0,
                inferTypeParameters: void 0,
                approximateLength: 0
            };
            context.tracker = new SymbolTrackerImpl(context, tracker, moduleResolverHost);
            const resultingNode = cb(context);
            if (context.truncating && context.flags & 1) {
                context.tracker.reportTruncationError();
            }
            return context.encounteredError ? void 0 : resultingNode;
        }
        function checkTruncationLength(context) {
            if (context.truncating) return context.truncating;
            return context.truncating = context.approximateLength > (context.flags & 1 ? noTruncationMaximumTruncationLength : defaultMaximumTruncationLength);
        }
        function typeToTypeNodeHelper(type, context) {
            const savedFlags = context.flags;
            const typeNode = typeToTypeNodeWorker(type, context);
            context.flags = savedFlags;
            return typeNode;
        }
        function typeToTypeNodeWorker(type, context) {
            var _a2, _b;
            if (cancellationToken && cancellationToken.throwIfCancellationRequested) {
                cancellationToken.throwIfCancellationRequested();
            }
            const inTypeAlias = context.flags & 8388608;
            context.flags &= ~8388608;
            if (!type) {
                if (!(context.flags & 262144)) {
                    context.encounteredError = true;
                    return void 0;
                }
                context.approximateLength += 3;
                return factory.createKeywordTypeNode(131);
            }
            if (!(context.flags & 536870912)) {
                type = getReducedType(type);
            }
            if (type.flags & 1) {
                if (type.aliasSymbol) {
                    return factory.createTypeReferenceNode(symbolToEntityNameNode(type.aliasSymbol), mapToTypeNodes(type.aliasTypeArguments, context));
                }
                if (type === unresolvedType) {
                    return addSyntheticLeadingComment(factory.createKeywordTypeNode(131), 3, "unresolved");
                }
                context.approximateLength += 3;
                return factory.createKeywordTypeNode(type === intrinsicMarkerType ? 139 : 131);
            }
            if (type.flags & 2) {
                return factory.createKeywordTypeNode(157);
            }
            if (type.flags & 4) {
                context.approximateLength += 6;
                return factory.createKeywordTypeNode(152);
            }
            if (type.flags & 8) {
                context.approximateLength += 6;
                return factory.createKeywordTypeNode(148);
            }
            if (type.flags & 64) {
                context.approximateLength += 6;
                return factory.createKeywordTypeNode(160);
            }
            if (type.flags & 16 && !type.aliasSymbol) {
                context.approximateLength += 7;
                return factory.createKeywordTypeNode(134);
            }
            if (type.flags & 1056) {
                if (type.symbol.flags & 8) {
                    const parentSymbol = getParentOfSymbol(type.symbol);
                    const parentName = symbolToTypeNode(parentSymbol, context, 788968);
                    if (getDeclaredTypeOfSymbol(parentSymbol) === type) {
                        return parentName;
                    }
                    const memberName = symbolName(type.symbol);
                    if (isIdentifierText(memberName, 0)) {
                        return appendReferenceToType(parentName, factory.createTypeReferenceNode(memberName, void 0));
                    }
                    if (isImportTypeNode(parentName)) {
                        parentName.isTypeOf = true;
                        return factory.createIndexedAccessTypeNode(parentName, factory.createLiteralTypeNode(factory.createStringLiteral(memberName)));
                    } else if (isTypeReferenceNode(parentName)) {
                        return factory.createIndexedAccessTypeNode(factory.createTypeQueryNode(parentName.typeName), factory.createLiteralTypeNode(factory.createStringLiteral(memberName)));
                    } else {
                        return Debug.fail("Unhandled type node kind returned from `symbolToTypeNode`.");
                    }
                }
                return symbolToTypeNode(type.symbol, context, 788968);
            }
            if (type.flags & 128) {
                context.approximateLength += type.value.length + 2;
                return factory.createLiteralTypeNode(setEmitFlags(factory.createStringLiteral(type.value, !!(context.flags & 268435456)), 33554432));
            }
            if (type.flags & 256) {
                const value = type.value;
                context.approximateLength += ("" + value).length;
                return factory.createLiteralTypeNode(value < 0 ? factory.createPrefixUnaryExpression(40, factory.createNumericLiteral(-value)) : factory.createNumericLiteral(value));
            }
            if (type.flags & 2048) {
                context.approximateLength += pseudoBigIntToString(type.value).length + 1;
                return factory.createLiteralTypeNode(factory.createBigIntLiteral(type.value));
            }
            if (type.flags & 512) {
                context.approximateLength += type.intrinsicName.length;
                return factory.createLiteralTypeNode(type.intrinsicName === "true" ? factory.createTrue() : factory.createFalse());
            }
            if (type.flags & 8192) {
                if (!(context.flags & 1048576)) {
                    if (isValueSymbolAccessible(type.symbol, context.enclosingDeclaration)) {
                        context.approximateLength += 6;
                        return symbolToTypeNode(type.symbol, context, 111551);
                    }
                    if (context.tracker.reportInaccessibleUniqueSymbolError) {
                        context.tracker.reportInaccessibleUniqueSymbolError();
                    }
                }
                context.approximateLength += 13;
                return factory.createTypeOperatorNode(156, factory.createKeywordTypeNode(153));
            }
            if (type.flags & 16384) {
                context.approximateLength += 4;
                return factory.createKeywordTypeNode(114);
            }
            if (type.flags & 32768) {
                context.approximateLength += 9;
                return factory.createKeywordTypeNode(155);
            }
            if (type.flags & 65536) {
                context.approximateLength += 4;
                return factory.createLiteralTypeNode(factory.createNull());
            }
            if (type.flags & 131072) {
                context.approximateLength += 5;
                return factory.createKeywordTypeNode(144);
            }
            if (type.flags & 4096) {
                context.approximateLength += 6;
                return factory.createKeywordTypeNode(153);
            }
            if (type.flags & 67108864) {
                context.approximateLength += 6;
                return factory.createKeywordTypeNode(149);
            }
            if (isThisTypeParameter(type)) {
                if (context.flags & 4194304) {
                    if (!context.encounteredError && !(context.flags & 32768)) {
                        context.encounteredError = true;
                    }
                    (_b = (_a2 = context.tracker).reportInaccessibleThisError) == null ? void 0 : _b.call(_a2);
                }
                context.approximateLength += 4;
                return factory.createThisTypeNode();
            }
            if (!inTypeAlias && type.aliasSymbol && (context.flags & 16384 || isTypeSymbolAccessible(type.aliasSymbol, context.enclosingDeclaration))) {
                const typeArgumentNodes = mapToTypeNodes(type.aliasTypeArguments, context);
                if (isReservedMemberName(type.aliasSymbol.escapedName) && !(type.aliasSymbol.flags & 32)) return factory.createTypeReferenceNode(factory.createIdentifier(""), typeArgumentNodes);
                if (length(typeArgumentNodes) === 1 && type.aliasSymbol === globalArrayType.symbol) {
                    return factory.createArrayTypeNode(typeArgumentNodes[0]);
                }
                return symbolToTypeNode(type.aliasSymbol, context, 788968, typeArgumentNodes);
            }
            const objectFlags = getObjectFlags(type);
            if (objectFlags & 4) {
                Debug.assert(!!(type.flags & 524288));
                return type.node ? visitAndTransformType(type, typeReferenceToTypeNode) : typeReferenceToTypeNode(type);
            }
            if (type.flags & 262144 || objectFlags & 3) {
                if (type.flags & 262144 && contains(context.inferTypeParameters, type)) {
                    context.approximateLength += symbolName(type.symbol).length + 6;
                    let constraintNode;
                    const constraint = getConstraintOfTypeParameter(type);
                    if (constraint) {
                        const inferredConstraint = getInferredTypeParameterConstraint(type, true);
                        if (!(inferredConstraint && isTypeIdenticalTo(constraint, inferredConstraint))) {
                            context.approximateLength += 9;
                            constraintNode = constraint && typeToTypeNodeHelper(constraint, context);
                        }
                    }
                    return factory.createInferTypeNode(typeParameterToDeclarationWithConstraint(type, context, constraintNode));
                }
                if (context.flags & 4 && type.flags & 262144 && !isTypeSymbolAccessible(type.symbol, context.enclosingDeclaration)) {
                    const name2 = typeParameterToName(type, context);
                    context.approximateLength += idText(name2).length;
                    return factory.createTypeReferenceNode(factory.createIdentifier(idText(name2)), void 0);
                }
                if (type.symbol) {
                    return symbolToTypeNode(type.symbol, context, 788968);
                }
                const name = (type === markerSuperTypeForCheck || type === markerSubTypeForCheck) && varianceTypeParameter && varianceTypeParameter.symbol ? (type === markerSubTypeForCheck ? "sub-" : "super-") + symbolName(varianceTypeParameter.symbol) : "?";
                return factory.createTypeReferenceNode(factory.createIdentifier(name), void 0);
            }
            if (type.flags & 1048576 && type.origin) {
                type = type.origin;
            }
            if (type.flags & (1048576 | 2097152)) {
                const types = type.flags & 1048576 ? formatUnionTypes(type.types) : type.types;
                if (length(types) === 1) {
                    return typeToTypeNodeHelper(types[0], context);
                }
                const typeNodes = mapToTypeNodes(types, context, true);
                if (typeNodes && typeNodes.length > 0) {
                    return type.flags & 1048576 ? factory.createUnionTypeNode(typeNodes) : factory.createIntersectionTypeNode(typeNodes);
                } else {
                    if (!context.encounteredError && !(context.flags & 262144)) {
                        context.encounteredError = true;
                    }
                    return void 0;
                }
            }
            if (objectFlags & (16 | 32)) {
                Debug.assert(!!(type.flags & 524288));
                return createAnonymousTypeNode(type);
            }
            if (type.flags & 4194304) {
                const indexedType = type.type;
                context.approximateLength += 6;
                const indexTypeNode = typeToTypeNodeHelper(indexedType, context);
                return factory.createTypeOperatorNode(141, indexTypeNode);
            }
            if (type.flags & 134217728) {
                const texts = type.texts;
                const types = type.types;
                const templateHead = factory.createTemplateHead(texts[0]);
                const templateSpans = factory.createNodeArray(map(types, (t, i) => factory.createTemplateLiteralTypeSpan(typeToTypeNodeHelper(t, context), (i < types.length - 1 ? factory.createTemplateMiddle : factory.createTemplateTail)(texts[i + 1]))));
                context.approximateLength += 2;
                return factory.createTemplateLiteralType(templateHead, templateSpans);
            }
            if (type.flags & 268435456) {
                const typeNode = typeToTypeNodeHelper(type.type, context);
                return symbolToTypeNode(type.symbol, context, 788968, [typeNode]);
            }
            if (type.flags & 8388608) {
                const objectTypeNode = typeToTypeNodeHelper(type.objectType, context);
                const indexTypeNode = typeToTypeNodeHelper(type.indexType, context);
                context.approximateLength += 2;
                return factory.createIndexedAccessTypeNode(objectTypeNode, indexTypeNode);
            }
            if (type.flags & 16777216) {
                return visitAndTransformType(type, type2 => conditionalTypeToTypeNode(type2));
            }
            if (type.flags & 33554432) {
                return typeToTypeNodeHelper(type.baseType, context);
            }
            return Debug.fail("Should be unreachable.");
            function conditionalTypeToTypeNode(type2) {
                const checkTypeNode = typeToTypeNodeHelper(type2.checkType, context);
                context.approximateLength += 15;
                if (context.flags & 4 && type2.root.isDistributive && !(type2.checkType.flags & 262144)) {
                    const newParam = createTypeParameter(createSymbol(262144, "T"));
                    const name = typeParameterToName(newParam, context);
                    const newTypeVariable = factory.createTypeReferenceNode(name);
                    context.approximateLength += 37;
                    const newMapper = prependTypeMapping(type2.root.checkType, newParam, type2.mapper);
                    const saveInferTypeParameters2 = context.inferTypeParameters;
                    context.inferTypeParameters = type2.root.inferTypeParameters;
                    const extendsTypeNode2 = typeToTypeNodeHelper(instantiateType(type2.root.extendsType, newMapper), context);
                    context.inferTypeParameters = saveInferTypeParameters2;
                    const trueTypeNode2 = typeToTypeNodeOrCircularityElision(instantiateType(getTypeFromTypeNode(type2.root.node.trueType), newMapper));
                    const falseTypeNode2 = typeToTypeNodeOrCircularityElision(instantiateType(getTypeFromTypeNode(type2.root.node.falseType), newMapper));
                    return factory.createConditionalTypeNode(checkTypeNode, factory.createInferTypeNode(factory.createTypeParameterDeclaration(void 0, factory.cloneNode(newTypeVariable.typeName))), factory.createConditionalTypeNode(factory.createTypeReferenceNode(factory.cloneNode(name)), typeToTypeNodeHelper(type2.checkType, context), factory.createConditionalTypeNode(newTypeVariable, extendsTypeNode2, trueTypeNode2, falseTypeNode2), factory.createKeywordTypeNode(144)), factory.createKeywordTypeNode(144));
                }
                const saveInferTypeParameters = context.inferTypeParameters;
                context.inferTypeParameters = type2.root.inferTypeParameters;
                const extendsTypeNode = typeToTypeNodeHelper(type2.extendsType, context);
                context.inferTypeParameters = saveInferTypeParameters;
                const trueTypeNode = typeToTypeNodeOrCircularityElision(getTrueTypeFromConditionalType(type2));
                const falseTypeNode = typeToTypeNodeOrCircularityElision(getFalseTypeFromConditionalType(type2));
                return factory.createConditionalTypeNode(checkTypeNode, extendsTypeNode, trueTypeNode, falseTypeNode);
            }
            function typeToTypeNodeOrCircularityElision(type2) {
                var _a3, _b2, _c;
                if (type2.flags & 1048576) {
                    if ((_a3 = context.visitedTypes) == null ? void 0 : _a3.has(getTypeId(type2))) {
                        if (!(context.flags & 131072)) {
                            context.encounteredError = true;
                            (_c = (_b2 = context.tracker) == null ? void 0 : _b2.reportCyclicStructureError) == null ? void 0 : _c.call(_b2);
                        }
                        return createElidedInformationPlaceholder(context);
                    }
                    return visitAndTransformType(type2, type3 => typeToTypeNodeHelper(type3, context));
                }
                return typeToTypeNodeHelper(type2, context);
            }
            function isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type2) {
                return isMappedTypeWithKeyofConstraintDeclaration(type2) && !(getModifiersTypeFromMappedType(type2).flags & 262144);
            }
            function createMappedTypeNodeFromType(type2) {
                Debug.assert(!!(type2.flags & 524288));
                const readonlyToken = type2.declaration.readonlyToken ? factory.createToken(type2.declaration.readonlyToken.kind) : void 0;
                const questionToken = type2.declaration.questionToken ? factory.createToken(type2.declaration.questionToken.kind) : void 0;
                let appropriateConstraintTypeNode;
                let newTypeVariable;
                if (isMappedTypeWithKeyofConstraintDeclaration(type2)) {
                    if (isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type2) && context.flags & 4) {
                        const newParam = createTypeParameter(createSymbol(262144, "T"));
                        const name = typeParameterToName(newParam, context);
                        newTypeVariable = factory.createTypeReferenceNode(name);
                    }
                    appropriateConstraintTypeNode = factory.createTypeOperatorNode(141, newTypeVariable || typeToTypeNodeHelper(getModifiersTypeFromMappedType(type2), context));
                } else {
                    appropriateConstraintTypeNode = typeToTypeNodeHelper(getConstraintTypeFromMappedType(type2), context);
                }
                const typeParameterNode = typeParameterToDeclarationWithConstraint(getTypeParameterFromMappedType(type2), context, appropriateConstraintTypeNode);
                const nameTypeNode = type2.declaration.nameType ? typeToTypeNodeHelper(getNameTypeFromMappedType(type2), context) : void 0;
                const templateTypeNode = typeToTypeNodeHelper(removeMissingType(getTemplateTypeFromMappedType(type2), !!(getMappedTypeModifiers(type2) & 4)), context);
                const mappedTypeNode = factory.createMappedTypeNode(readonlyToken, typeParameterNode, nameTypeNode, questionToken, templateTypeNode, void 0);
                context.approximateLength += 10;
                const result = setEmitFlags(mappedTypeNode, 1);
                if (isHomomorphicMappedTypeWithNonHomomorphicInstantiation(type2) && context.flags & 4) {
                    const originalConstraint = instantiateType(getConstraintOfTypeParameter(getTypeFromTypeNode(type2.declaration.typeParameter.constraint.type)) || unknownType, type2.mapper);
                    return factory.createConditionalTypeNode(typeToTypeNodeHelper(getModifiersTypeFromMappedType(type2), context), factory.createInferTypeNode(factory.createTypeParameterDeclaration(void 0, factory.cloneNode(newTypeVariable.typeName), originalConstraint.flags & 2 ? void 0 : typeToTypeNodeHelper(originalConstraint, context))), result, factory.createKeywordTypeNode(144));
                }
                return result;
            }
            function createAnonymousTypeNode(type2) {
                var _a3, _b2;
                const typeId = type2.id;
                const symbol = type2.symbol;
                if (symbol) {
                    const isInstanceType = isClassInstanceSide(type2) ? 788968 : 111551;
                    if (isJSConstructor(symbol.valueDeclaration)) {
                        return symbolToTypeNode(symbol, context, isInstanceType);
                    } else if (symbol.flags & 32 && !getBaseTypeVariableOfClass(symbol) && !(symbol.valueDeclaration && isClassLike(symbol.valueDeclaration) && context.flags & 2048 && (!isClassDeclaration(symbol.valueDeclaration) || isSymbolAccessible(symbol, context.enclosingDeclaration, isInstanceType, false).accessibility !== 0)) || symbol.flags & (384 | 512) || shouldWriteTypeOfFunctionSymbol()) {
                        return symbolToTypeNode(symbol, context, isInstanceType);
                    } else if ((_a3 = context.visitedTypes) == null ? void 0 : _a3.has(typeId)) {
                        const typeAlias = getTypeAliasForTypeLiteral(type2);
                        if (typeAlias) {
                            return symbolToTypeNode(typeAlias, context, 788968);
                        } else {
                            return createElidedInformationPlaceholder(context);
                        }
                    } else {
                        return visitAndTransformType(type2, createTypeNodeFromObjectType);
                    }
                } else {
                    const isInstantiationExpressionType = !!(getObjectFlags(type2) & 8388608);
                    if (isInstantiationExpressionType) {
                        const instantiationExpressionType = type2;
                        if (isTypeQueryNode(instantiationExpressionType.node)) {
                            const typeNode = serializeExistingTypeNode(context, instantiationExpressionType.node);
                            if (typeNode) {
                                return typeNode;
                            }
                        }
                        if ((_b2 = context.visitedTypes) == null ? void 0 : _b2.has(typeId)) {
                            return createElidedInformationPlaceholder(context);
                        }
                        return visitAndTransformType(type2, createTypeNodeFromObjectType);
                    }
                    return createTypeNodeFromObjectType(type2);
                }
                function shouldWriteTypeOfFunctionSymbol() {
                    var _a4;
                    const isStaticMethodSymbol = !!(symbol.flags & 8192) && some(symbol.declarations, declaration => isStatic(declaration));
                    const isNonLocalFunctionSymbol = !!(symbol.flags & 16) && (symbol.parent || forEach(symbol.declarations, declaration => declaration.parent.kind === 308 || declaration.parent.kind === 265));
                    if (isStaticMethodSymbol || isNonLocalFunctionSymbol) {
                        return (!!(context.flags & 4096) || ((_a4 = context.visitedTypes) == null ? void 0 : _a4.has(typeId))) && (!(context.flags & 8) || isValueSymbolAccessible(symbol, context.enclosingDeclaration));
                    }
                }
            }
            function visitAndTransformType(type2, transform2) {
                var _a3, _b2;
                const typeId = type2.id;
                const isConstructorObject = getObjectFlags(type2) & 16 && type2.symbol && type2.symbol.flags & 32;
                const id = getObjectFlags(type2) & 4 && type2.node ? "N" + getNodeId(type2.node) : type2.flags & 16777216 ? "N" + getNodeId(type2.root.node) : type2.symbol ? (isConstructorObject ? "+" : "") + getSymbolId(type2.symbol) : void 0;
                if (!context.visitedTypes) {
                    context.visitedTypes = /* @__PURE__ */new Set();
                }
                if (id && !context.symbolDepth) {
                    context.symbolDepth = /* @__PURE__ */new Map();
                }
                const links = context.enclosingDeclaration && getNodeLinks(context.enclosingDeclaration);
                const key = `${getTypeId(type2)}|${context.flags}`;
                if (links) {
                    links.serializedTypes || (links.serializedTypes = /* @__PURE__ */new Map());
                }
                const cachedResult = (_a3 = links == null ? void 0 : links.serializedTypes) == null ? void 0 : _a3.get(key);
                if (cachedResult) {
                    if (cachedResult.truncating) {
                        context.truncating = true;
                    }
                    context.approximateLength += cachedResult.addedLength;
                    return deepCloneOrReuseNode(cachedResult.node);
                }
                let depth;
                if (id) {
                    depth = context.symbolDepth.get(id) || 0;
                    if (depth > 10) {
                        return createElidedInformationPlaceholder(context);
                    }
                    context.symbolDepth.set(id, depth + 1);
                }
                context.visitedTypes.add(typeId);
                const startLength = context.approximateLength;
                const result = transform2(type2);
                const addedLength = context.approximateLength - startLength;
                if (!context.reportedDiagnostic && !context.encounteredError) {
                    (_b2 = links == null ? void 0 : links.serializedTypes) == null ? void 0 : _b2.set(key, {
                        node: result,
                        truncating: context.truncating,
                        addedLength
                    });
                }
                context.visitedTypes.delete(typeId);
                if (id) {
                    context.symbolDepth.set(id, depth);
                }
                return result;
                function deepCloneOrReuseNode(node) {
                    if (!nodeIsSynthesized(node) && getParseTreeNode(node) === node) {
                        return node;
                    }
                    return setTextRange(factory.cloneNode(visitEachChild(node, deepCloneOrReuseNode, nullTransformationContext, deepCloneOrReuseNodes)), node);
                }
                function deepCloneOrReuseNodes(nodes, visitor, test, start, count) {
                    if (nodes && nodes.length === 0) {
                        return setTextRange(factory.createNodeArray(void 0, nodes.hasTrailingComma), nodes);
                    }
                    return visitNodes2(nodes, visitor, test, start, count);
                }
            }
            function createTypeNodeFromObjectType(type2) {
                if (isGenericMappedType(type2) || type2.containsError) {
                    return createMappedTypeNodeFromType(type2);
                }
                const resolved = resolveStructuredTypeMembers(type2);
                if (!resolved.properties.length && !resolved.indexInfos.length) {
                    if (!resolved.callSignatures.length && !resolved.constructSignatures.length) {
                        context.approximateLength += 2;
                        return setEmitFlags(factory.createTypeLiteralNode(void 0), 1);
                    }
                    if (resolved.callSignatures.length === 1 && !resolved.constructSignatures.length) {
                        const signature = resolved.callSignatures[0];
                        const signatureNode = signatureToSignatureDeclarationHelper(signature, 181, context);
                        return signatureNode;
                    }
                    if (resolved.constructSignatures.length === 1 && !resolved.callSignatures.length) {
                        const signature = resolved.constructSignatures[0];
                        const signatureNode = signatureToSignatureDeclarationHelper(signature, 182, context);
                        return signatureNode;
                    }
                }
                const abstractSignatures = filter(resolved.constructSignatures, signature => !!(signature.flags & 4));
                if (some(abstractSignatures)) {
                    const types = map(abstractSignatures, getOrCreateTypeFromSignature);
                    const typeElementCount = resolved.callSignatures.length + (resolved.constructSignatures.length - abstractSignatures.length) + resolved.indexInfos.length + (context.flags & 2048 ? countWhere(resolved.properties, p => !(p.flags & 4194304)) : length(resolved.properties));
                    if (typeElementCount) {
                        types.push(getResolvedTypeWithoutAbstractConstructSignatures(resolved));
                    }
                    return typeToTypeNodeHelper(getIntersectionType(types), context);
                }
                const savedFlags = context.flags;
                context.flags |= 4194304;
                const members = createTypeNodesFromResolvedType(resolved);
                context.flags = savedFlags;
                const typeLiteralNode = factory.createTypeLiteralNode(members);
                context.approximateLength += 2;
                setEmitFlags(typeLiteralNode, context.flags & 1024 ? 0 : 1);
                return typeLiteralNode;
            }
            function typeReferenceToTypeNode(type2) {
                let typeArguments = getTypeArguments(type2);
                if (type2.target === globalArrayType || type2.target === globalReadonlyArrayType) {
                    if (context.flags & 2) {
                        const typeArgumentNode = typeToTypeNodeHelper(typeArguments[0], context);
                        return factory.createTypeReferenceNode(type2.target === globalArrayType ? "Array" : "ReadonlyArray", [typeArgumentNode]);
                    }
                    const elementType = typeToTypeNodeHelper(typeArguments[0], context);
                    const arrayType = factory.createArrayTypeNode(elementType);
                    return type2.target === globalArrayType ? arrayType : factory.createTypeOperatorNode(146, arrayType);
                } else if (type2.target.objectFlags & 8) {
                    typeArguments = sameMap(typeArguments, (t, i) => removeMissingType(t, !!(type2.target.elementFlags[i] & 2)));
                    if (typeArguments.length > 0) {
                        const arity = getTypeReferenceArity(type2);
                        const tupleConstituentNodes = mapToTypeNodes(typeArguments.slice(0, arity), context);
                        if (tupleConstituentNodes) {
                            if (type2.target.labeledElementDeclarations) {
                                for (let i = 0; i < tupleConstituentNodes.length; i++) {
                                    const flags = type2.target.elementFlags[i];
                                    tupleConstituentNodes[i] = factory.createNamedTupleMember(flags & 12 ? factory.createToken(25) : void 0, factory.createIdentifier(unescapeLeadingUnderscores(getTupleElementLabel(type2.target.labeledElementDeclarations[i]))), flags & 2 ? factory.createToken(57) : void 0, flags & 4 ? factory.createArrayTypeNode(tupleConstituentNodes[i]) : tupleConstituentNodes[i]);
                                }
                            } else {
                                for (let i = 0; i < Math.min(arity, tupleConstituentNodes.length); i++) {
                                    const flags = type2.target.elementFlags[i];
                                    tupleConstituentNodes[i] = flags & 12 ? factory.createRestTypeNode(flags & 4 ? factory.createArrayTypeNode(tupleConstituentNodes[i]) : tupleConstituentNodes[i]) : flags & 2 ? factory.createOptionalTypeNode(tupleConstituentNodes[i]) : tupleConstituentNodes[i];
                                }
                            }
                            const tupleTypeNode = setEmitFlags(factory.createTupleTypeNode(tupleConstituentNodes), 1);
                            return type2.target.readonly ? factory.createTypeOperatorNode(146, tupleTypeNode) : tupleTypeNode;
                        }
                    }
                    if (context.encounteredError || context.flags & 524288) {
                        const tupleTypeNode = setEmitFlags(factory.createTupleTypeNode([]), 1);
                        return type2.target.readonly ? factory.createTypeOperatorNode(146, tupleTypeNode) : tupleTypeNode;
                    }
                    context.encounteredError = true;
                    return void 0;
                } else if (context.flags & 2048 && type2.symbol.valueDeclaration && isClassLike(type2.symbol.valueDeclaration) && !isValueSymbolAccessible(type2.symbol, context.enclosingDeclaration)) {
                    return createAnonymousTypeNode(type2);
                } else {
                    const outerTypeParameters = type2.target.outerTypeParameters;
                    let i = 0;
                    let resultType;
                    if (outerTypeParameters) {
                        const length2 = outerTypeParameters.length;
                        while (i < length2) {
                            const start = i;
                            const parent2 = getParentSymbolOfTypeParameter(outerTypeParameters[i]);
                            do {
                                i++;
                            } while (i < length2 && getParentSymbolOfTypeParameter(outerTypeParameters[i]) === parent2);
                            if (!rangeEquals(outerTypeParameters, typeArguments, start, i)) {
                                const typeArgumentSlice = mapToTypeNodes(typeArguments.slice(start, i), context);
                                const flags2 = context.flags;
                                context.flags |= 16;
                                const ref = symbolToTypeNode(parent2, context, 788968, typeArgumentSlice);
                                context.flags = flags2;
                                resultType = !resultType ? ref : appendReferenceToType(resultType, ref);
                            }
                        }
                    }
                    let typeArgumentNodes;
                    if (typeArguments.length > 0) {
                        const typeParameterCount = (type2.target.typeParameters || emptyArray).length;
                        typeArgumentNodes = mapToTypeNodes(typeArguments.slice(i, typeParameterCount), context);
                    }
                    const flags = context.flags;
                    context.flags |= 16;
                    const finalRef = symbolToTypeNode(type2.symbol, context, 788968, typeArgumentNodes);
                    context.flags = flags;
                    return !resultType ? finalRef : appendReferenceToType(resultType, finalRef);
                }
            }
            function appendReferenceToType(root, ref) {
                if (isImportTypeNode(root)) {
                    let typeArguments = root.typeArguments;
                    let qualifier = root.qualifier;
                    if (qualifier) {
                        if (isIdentifier(qualifier)) {
                            if (typeArguments !== getIdentifierTypeArguments(qualifier)) {
                                qualifier = setIdentifierTypeArguments(factory.cloneNode(qualifier), typeArguments);
                            }
                        } else {
                            if (typeArguments !== getIdentifierTypeArguments(qualifier.right)) {
                                qualifier = factory.updateQualifiedName(qualifier, qualifier.left, setIdentifierTypeArguments(factory.cloneNode(qualifier.right), typeArguments));
                            }
                        }
                    }
                    typeArguments = ref.typeArguments;
                    const ids = getAccessStack(ref);
                    for (const id of ids) {
                        qualifier = qualifier ? factory.createQualifiedName(qualifier, id) : id;
                    }
                    return factory.updateImportTypeNode(root, root.argument, root.assertions, qualifier, typeArguments, root.isTypeOf);
                } else {
                    let typeArguments = root.typeArguments;
                    let typeName = root.typeName;
                    if (isIdentifier(typeName)) {
                        if (typeArguments !== getIdentifierTypeArguments(typeName)) {
                            typeName = setIdentifierTypeArguments(factory.cloneNode(typeName), typeArguments);
                        }
                    } else {
                        if (typeArguments !== getIdentifierTypeArguments(typeName.right)) {
                            typeName = factory.updateQualifiedName(typeName, typeName.left, setIdentifierTypeArguments(factory.cloneNode(typeName.right), typeArguments));
                        }
                    }
                    typeArguments = ref.typeArguments;
                    const ids = getAccessStack(ref);
                    for (const id of ids) {
                        typeName = factory.createQualifiedName(typeName, id);
                    }
                    return factory.updateTypeReferenceNode(root, typeName, typeArguments);
                }
            }
            function getAccessStack(ref) {
                let state = ref.typeName;
                const ids = [];
                while (!isIdentifier(state)) {
                    ids.unshift(state.right);
                    state = state.left;
                }
                ids.unshift(state);
                return ids;
            }
            function createTypeNodesFromResolvedType(resolvedType) {
                if (checkTruncationLength(context)) {
                    return [factory.createPropertySignature(void 0, "...", void 0, void 0)];
                }
                const typeElements = [];
                for (const signature of resolvedType.callSignatures) {
                    typeElements.push(signatureToSignatureDeclarationHelper(signature, 176, context));
                }
                for (const signature of resolvedType.constructSignatures) {
                    if (signature.flags & 4) continue;
                    typeElements.push(signatureToSignatureDeclarationHelper(signature, 177, context));
                }
                for (const info of resolvedType.indexInfos) {
                    typeElements.push(indexInfoToIndexSignatureDeclarationHelper(info, context, resolvedType.objectFlags & 1024 ? createElidedInformationPlaceholder(context) : void 0));
                }
                const properties = resolvedType.properties;
                if (!properties) {
                    return typeElements;
                }
                let i = 0;
                for (const propertySymbol of properties) {
                    i++;
                    if (context.flags & 2048) {
                        if (propertySymbol.flags & 4194304) {
                            continue;
                        }
                        if (getDeclarationModifierFlagsFromSymbol(propertySymbol) & (8 | 16) && context.tracker.reportPrivateInBaseOfClassExpression) {
                            context.tracker.reportPrivateInBaseOfClassExpression(unescapeLeadingUnderscores(propertySymbol.escapedName));
                        }
                    }
                    if (checkTruncationLength(context) && i + 2 < properties.length - 1) {
                        typeElements.push(factory.createPropertySignature(void 0, `... ${properties.length - i} more ...`, void 0, void 0));
                        addPropertyToElementList(properties[properties.length - 1], context, typeElements);
                        break;
                    }
                    addPropertyToElementList(propertySymbol, context, typeElements);
                }
                return typeElements.length ? typeElements : void 0;
            }
        }
        function createElidedInformationPlaceholder(context) {
            context.approximateLength += 3;
            if (!(context.flags & 1)) {
                return factory.createTypeReferenceNode(factory.createIdentifier("..."), void 0);
            }
            return factory.createKeywordTypeNode(131);
        }
        function shouldUsePlaceholderForProperty(propertySymbol, context) {
            var _a2;
            return !!(getCheckFlags(propertySymbol) & 8192) && (contains(context.reverseMappedStack, propertySymbol) || ((_a2 = context.reverseMappedStack) == null ? void 0 : _a2[0]) && !(getObjectFlags(last(context.reverseMappedStack).links.propertyType) & 16));
        }
        function addPropertyToElementList(propertySymbol, context, typeElements) {
            var _a2;
            const propertyIsReverseMapped = !!(getCheckFlags(propertySymbol) & 8192);
            const propertyType = shouldUsePlaceholderForProperty(propertySymbol, context) ? anyType : getNonMissingTypeOfSymbol(propertySymbol);
            const saveEnclosingDeclaration = context.enclosingDeclaration;
            context.enclosingDeclaration = void 0;
            if (context.tracker.canTrackSymbol && isLateBoundName(propertySymbol.escapedName)) {
                if (propertySymbol.declarations) {
                    const decl = first(propertySymbol.declarations);
                    if (hasLateBindableName(decl)) {
                        if (isBinaryExpression(decl)) {
                            const name = getNameOfDeclaration(decl);
                            if (name && isElementAccessExpression(name) && isPropertyAccessEntityNameExpression(name.argumentExpression)) {
                                trackComputedName(name.argumentExpression, saveEnclosingDeclaration, context);
                            }
                        } else {
                            trackComputedName(decl.name.expression, saveEnclosingDeclaration, context);
                        }
                    }
                } else {
                    context.tracker.reportNonSerializableProperty(symbolToString(propertySymbol));
                }
            }
            context.enclosingDeclaration = propertySymbol.valueDeclaration || ((_a2 = propertySymbol.declarations) == null ? void 0 : _a2[0]) || saveEnclosingDeclaration;
            const propertyName = getPropertyNameNodeForSymbol(propertySymbol, context);
            context.enclosingDeclaration = saveEnclosingDeclaration;
            context.approximateLength += symbolName(propertySymbol).length + 1;
            const optionalToken = propertySymbol.flags & 16777216 ? factory.createToken(57) : void 0;
            if (propertySymbol.flags & (16 | 8192) && !getPropertiesOfObjectType(propertyType).length && !isReadonlySymbol(propertySymbol)) {
                const signatures = getSignaturesOfType(filterType(propertyType, t => !(t.flags & 32768)), 0);
                for (const signature of signatures) {
                    const methodDeclaration = signatureToSignatureDeclarationHelper(signature, 170, context, {
                        name: propertyName,
                        questionToken: optionalToken
                    });
                    typeElements.push(preserveCommentsOn(methodDeclaration));
                }
            } else {
                let propertyTypeNode;
                if (shouldUsePlaceholderForProperty(propertySymbol, context)) {
                    propertyTypeNode = createElidedInformationPlaceholder(context);
                } else {
                    if (propertyIsReverseMapped) {
                        context.reverseMappedStack || (context.reverseMappedStack = []);
                        context.reverseMappedStack.push(propertySymbol);
                    }
                    propertyTypeNode = propertyType ? serializeTypeForDeclaration(context, propertyType, propertySymbol, saveEnclosingDeclaration) : factory.createKeywordTypeNode(131);
                    if (propertyIsReverseMapped) {
                        context.reverseMappedStack.pop();
                    }
                }
                const modifiers = isReadonlySymbol(propertySymbol) ? [factory.createToken(146)] : void 0;
                if (modifiers) {
                    context.approximateLength += 9;
                }
                const propertySignature = factory.createPropertySignature(modifiers, propertyName, optionalToken, propertyTypeNode);
                typeElements.push(preserveCommentsOn(propertySignature));
            }
            function preserveCommentsOn(node) {
                var _a3;
                if (some(propertySymbol.declarations, d => d.kind === 351)) {
                    const d = (_a3 = propertySymbol.declarations) == null ? void 0 : _a3.find(d2 => d2.kind === 351);
                    const commentText = getTextOfJSDocComment(d.comment);
                    if (commentText) {
                        setSyntheticLeadingComments(node, [{
                            kind: 3,
                            text: "*\n * " + commentText.replace(/\n/g, "\n * ") + "\n ",
                            pos: -1,
                            end: -1,
                            hasTrailingNewLine: true
                        }]);
                    }
                } else if (propertySymbol.valueDeclaration) {
                    setCommentRange(node, propertySymbol.valueDeclaration);
                }
                return node;
            }
        }
        function mapToTypeNodes(types, context, isBareList) {
            if (some(types)) {
                if (checkTruncationLength(context)) {
                    if (!isBareList) {
                        return [factory.createTypeReferenceNode("...", void 0)];
                    } else if (types.length > 2) {
                        return [typeToTypeNodeHelper(types[0], context), factory.createTypeReferenceNode(`... ${types.length - 2} more ...`, void 0), typeToTypeNodeHelper(types[types.length - 1], context)];
                    }
                }
                const mayHaveNameCollisions = !(context.flags & 64);
                const seenNames = mayHaveNameCollisions ? createUnderscoreEscapedMultiMap() : void 0;
                const result = [];
                let i = 0;
                for (const type of types) {
                    i++;
                    if (checkTruncationLength(context) && i + 2 < types.length - 1) {
                        result.push(factory.createTypeReferenceNode(`... ${types.length - i} more ...`, void 0));
                        const typeNode2 = typeToTypeNodeHelper(types[types.length - 1], context);
                        if (typeNode2) {
                            result.push(typeNode2);
                        }
                        break;
                    }
                    context.approximateLength += 2;
                    const typeNode = typeToTypeNodeHelper(type, context);
                    if (typeNode) {
                        result.push(typeNode);
                        if (seenNames && isIdentifierTypeReference(typeNode)) {
                            seenNames.add(typeNode.typeName.escapedText, [type, result.length - 1]);
                        }
                    }
                }
                if (seenNames) {
                    const saveContextFlags = context.flags;
                    context.flags |= 64;
                    seenNames.forEach(types2 => {
                        if (!arrayIsHomogeneous(types2, ([a], [b]) => typesAreSameReference(a, b))) {
                            for (const [type, resultIndex] of types2) {
                                result[resultIndex] = typeToTypeNodeHelper(type, context);
                            }
                        }
                    });
                    context.flags = saveContextFlags;
                }
                return result;
            }
        }
        function typesAreSameReference(a, b) {
            return a === b || !!a.symbol && a.symbol === b.symbol || !!a.aliasSymbol && a.aliasSymbol === b.aliasSymbol;
        }
        function indexInfoToIndexSignatureDeclarationHelper(indexInfo, context, typeNode) {
            const name = getNameFromIndexInfo(indexInfo) || "x";
            const indexerTypeNode = typeToTypeNodeHelper(indexInfo.keyType, context);
            const indexingParameter = factory.createParameterDeclaration(void 0, void 0, name, void 0, indexerTypeNode, void 0);
            if (!typeNode) {
                typeNode = typeToTypeNodeHelper(indexInfo.type || anyType, context);
            }
            if (!indexInfo.type && !(context.flags & 2097152)) {
                context.encounteredError = true;
            }
            context.approximateLength += name.length + 4;
            return factory.createIndexSignature(indexInfo.isReadonly ? [factory.createToken(146)] : void 0, [indexingParameter], typeNode);
        }
        function signatureToSignatureDeclarationHelper(signature, kind, context, options) {
            var _a2, _b, _c, _d, _e;
            const suppressAny = context.flags & 256;
            if (suppressAny) context.flags &= ~256;
            context.approximateLength += 3;
            let typeParameters;
            let typeArguments;
            if (context.flags & 32 && signature.target && signature.mapper && signature.target.typeParameters) {
                typeArguments = signature.target.typeParameters.map(parameter => typeToTypeNodeHelper(instantiateType(parameter, signature.mapper), context));
            } else {
                typeParameters = signature.typeParameters && signature.typeParameters.map(parameter => typeParameterToDeclaration(parameter, context));
            }
            const expandedParams = getExpandedParameters(signature, true)[0];
            let cleanup;
            if (context.enclosingDeclaration && signature.declaration && signature.declaration !== context.enclosingDeclaration && !isInJSFile(signature.declaration) && some(expandedParams)) {
                const existingFakeScope = getNodeLinks(context.enclosingDeclaration).fakeScopeForSignatureDeclaration ? context.enclosingDeclaration : void 0;
                Debug.assertOptionalNode(existingFakeScope, isBlock);
                const locals = (_a2 = existingFakeScope == null ? void 0 : existingFakeScope.locals) != null ? _a2 : createSymbolTable();
                let newLocals;
                for (const param of expandedParams) {
                    if (!locals.has(param.escapedName)) {
                        newLocals = append(newLocals, param.escapedName);
                        locals.set(param.escapedName, param);
                    }
                }
                if (newLocals) {
                    let removeNewLocals2 = function () {
                        forEach(newLocals, s => locals.delete(s));
                    };
                    if (existingFakeScope) {
                        cleanup = removeNewLocals2;
                    } else {
                        const fakeScope = parseNodeFactory.createBlock(emptyArray);
                        getNodeLinks(fakeScope).fakeScopeForSignatureDeclaration = true;
                        fakeScope.locals = locals;
                        const saveEnclosingDeclaration = context.enclosingDeclaration;
                        setParent(fakeScope, saveEnclosingDeclaration);
                        context.enclosingDeclaration = fakeScope;
                        cleanup = () => {
                            context.enclosingDeclaration = saveEnclosingDeclaration;
                            removeNewLocals2();
                        };
                    }
                }
            }
            const parameters = (some(expandedParams, p => p !== expandedParams[expandedParams.length - 1] && !!(getCheckFlags(p) & 32768)) ? signature.parameters : expandedParams).map(parameter => symbolToParameterDeclaration(parameter, context, kind === 173, options == null ? void 0 : options.privateSymbolVisitor, options == null ? void 0 : options.bundledImports));
            const thisParameter = context.flags & 33554432 ? void 0 : tryGetThisParameterDeclaration(signature, context);
            if (thisParameter) {
                parameters.unshift(thisParameter);
            }
            let returnTypeNode;
            const typePredicate = getTypePredicateOfSignature(signature);
            if (typePredicate) {
                const assertsModifier = typePredicate.kind === 2 || typePredicate.kind === 3 ? factory.createToken(129) : void 0;
                const parameterName = typePredicate.kind === 1 || typePredicate.kind === 3 ? setEmitFlags(factory.createIdentifier(typePredicate.parameterName), 33554432) : factory.createThisTypeNode();
                const typeNode = typePredicate.type && typeToTypeNodeHelper(typePredicate.type, context);
                returnTypeNode = factory.createTypePredicateNode(assertsModifier, parameterName, typeNode);
            } else {
                const returnType = getReturnTypeOfSignature(signature);
                if (returnType && !(suppressAny && isTypeAny(returnType))) {
                    returnTypeNode = serializeReturnTypeForSignature(context, returnType, signature, options == null ? void 0 : options.privateSymbolVisitor, options == null ? void 0 : options.bundledImports);
                } else if (!suppressAny) {
                    returnTypeNode = factory.createKeywordTypeNode(131);
                }
            }
            let modifiers = options == null ? void 0 : options.modifiers;
            if (kind === 182 && signature.flags & 4) {
                const flags = modifiersToFlags(modifiers);
                modifiers = factory.createModifiersFromModifierFlags(flags | 256);
            }
            const node = kind === 176 ? factory.createCallSignature(typeParameters, parameters, returnTypeNode) : kind === 177 ? factory.createConstructSignature(typeParameters, parameters, returnTypeNode) : kind === 170 ? factory.createMethodSignature(modifiers, (_b = options == null ? void 0 : options.name) != null ? _b : factory.createIdentifier(""), options == null ? void 0 : options.questionToken, typeParameters, parameters, returnTypeNode) : kind === 171 ? factory.createMethodDeclaration(modifiers, void 0, (_c = options == null ? void 0 : options.name) != null ? _c : factory.createIdentifier(""), void 0, typeParameters, parameters, returnTypeNode, void 0) : kind === 173 ? factory.createConstructorDeclaration(modifiers, parameters, void 0) : kind === 174 ? factory.createGetAccessorDeclaration(modifiers, (_d = options == null ? void 0 : options.name) != null ? _d : factory.createIdentifier(""), parameters, returnTypeNode, void 0) : kind === 175 ? factory.createSetAccessorDeclaration(modifiers, (_e = options == null ? void 0 : options.name) != null ? _e : factory.createIdentifier(""), parameters, void 0) : kind === 178 ? factory.createIndexSignature(modifiers, parameters, returnTypeNode) : kind === 320 ? factory.createJSDocFunctionType(parameters, returnTypeNode) : kind === 181 ? factory.createFunctionTypeNode(typeParameters, parameters, returnTypeNode != null ? returnTypeNode : factory.createTypeReferenceNode(factory.createIdentifier(""))) : kind === 182 ? factory.createConstructorTypeNode(modifiers, typeParameters, parameters, returnTypeNode != null ? returnTypeNode : factory.createTypeReferenceNode(factory.createIdentifier(""))) : kind === 259 ? factory.createFunctionDeclaration(modifiers, void 0, (options == null ? void 0 : options.name) ? cast(options.name, isIdentifier) : factory.createIdentifier(""), typeParameters, parameters, returnTypeNode, void 0) : kind === 215 ? factory.createFunctionExpression(modifiers, void 0, (options == null ? void 0 : options.name) ? cast(options.name, isIdentifier) : factory.createIdentifier(""), typeParameters, parameters, returnTypeNode, factory.createBlock([])) : kind === 216 ? factory.createArrowFunction(modifiers, typeParameters, parameters, returnTypeNode, void 0, factory.createBlock([])) : Debug.assertNever(kind);
            if (typeArguments) {
                node.typeArguments = factory.createNodeArray(typeArguments);
            }
            cleanup == null ? void 0 : cleanup();
            return node;
        }
        function tryGetThisParameterDeclaration(signature, context) {
            if (signature.thisParameter) {
                return symbolToParameterDeclaration(signature.thisParameter, context);
            }
            if (signature.declaration && isInJSFile(signature.declaration)) {
                const thisTag = getJSDocThisTag(signature.declaration);
                if (thisTag && thisTag.typeExpression) {
                    return factory.createParameterDeclaration(void 0, void 0, "this", void 0, typeToTypeNodeHelper(getTypeFromTypeNode(thisTag.typeExpression), context));
                }
            }
        }
        function typeParameterToDeclarationWithConstraint(type, context, constraintNode) {
            const savedContextFlags = context.flags;
            context.flags &= ~512;
            const modifiers = factory.createModifiersFromModifierFlags(getTypeParameterModifiers(type));
            const name = typeParameterToName(type, context);
            const defaultParameter = getDefaultFromTypeParameter(type);
            const defaultParameterNode = defaultParameter && typeToTypeNodeHelper(defaultParameter, context);
            context.flags = savedContextFlags;
            return factory.createTypeParameterDeclaration(modifiers, name, constraintNode, defaultParameterNode);
        }
        function typeParameterToDeclaration(type, context, constraint = getConstraintOfTypeParameter(type)) {
            const constraintNode = constraint && typeToTypeNodeHelper(constraint, context);
            return typeParameterToDeclarationWithConstraint(type, context, constraintNode);
        }
        function symbolToParameterDeclaration(parameterSymbol, context, preserveModifierFlags, privateSymbolVisitor, bundledImports) {
            let parameterDeclaration = getDeclarationOfKind(parameterSymbol, 166);
            if (!parameterDeclaration && !isTransientSymbol(parameterSymbol)) {
                parameterDeclaration = getDeclarationOfKind(parameterSymbol, 344);
            }
            let parameterType = getTypeOfSymbol(parameterSymbol);
            if (parameterDeclaration && isRequiredInitializedParameter(parameterDeclaration)) {
                parameterType = getOptionalType(parameterType);
            }
            const parameterTypeNode = serializeTypeForDeclaration(context, parameterType, parameterSymbol, context.enclosingDeclaration, privateSymbolVisitor, bundledImports);
            const modifiers = !(context.flags & 8192) && preserveModifierFlags && parameterDeclaration && canHaveModifiers(parameterDeclaration) ? map(getModifiers(parameterDeclaration), factory.cloneNode) : void 0;
            const isRest = parameterDeclaration && isRestParameter(parameterDeclaration) || getCheckFlags(parameterSymbol) & 32768;
            const dotDotDotToken = isRest ? factory.createToken(25) : void 0;
            const name = parameterDeclaration ? parameterDeclaration.name ? parameterDeclaration.name.kind === 79 ? setEmitFlags(factory.cloneNode(parameterDeclaration.name), 33554432) : parameterDeclaration.name.kind === 163 ? setEmitFlags(factory.cloneNode(parameterDeclaration.name.right), 33554432) : cloneBindingName(parameterDeclaration.name) : symbolName(parameterSymbol) : symbolName(parameterSymbol);
            const isOptional = parameterDeclaration && isOptionalParameter(parameterDeclaration) || getCheckFlags(parameterSymbol) & 16384;
            const questionToken = isOptional ? factory.createToken(57) : void 0;
            const parameterNode = factory.createParameterDeclaration(modifiers, dotDotDotToken, name, questionToken, parameterTypeNode, void 0);
            context.approximateLength += symbolName(parameterSymbol).length + 3;
            return parameterNode;
            function cloneBindingName(node) {
                return elideInitializerAndSetEmitFlags(node);
                function elideInitializerAndSetEmitFlags(node2) {
                    if (context.tracker.canTrackSymbol && isComputedPropertyName(node2) && isLateBindableName(node2)) {
                        trackComputedName(node2.expression, context.enclosingDeclaration, context);
                    }
                    let visited = visitEachChild(node2, elideInitializerAndSetEmitFlags, nullTransformationContext, void 0, elideInitializerAndSetEmitFlags);
                    if (isBindingElement(visited)) {
                        visited = factory.updateBindingElement(visited, visited.dotDotDotToken, visited.propertyName, visited.name, void 0);
                    }
                    if (!nodeIsSynthesized(visited)) {
                        visited = factory.cloneNode(visited);
                    }
                    return setEmitFlags(visited, 1 | 33554432);
                }
            }
        }
        function trackComputedName(accessExpression, enclosingDeclaration, context) {
            if (!context.tracker.canTrackSymbol) return;
            const firstIdentifier = getFirstIdentifier(accessExpression);
            const name = resolveName(firstIdentifier, firstIdentifier.escapedText, 111551 | 1048576, void 0, void 0, true);
            if (name) {
                context.tracker.trackSymbol(name, enclosingDeclaration, 111551);
            }
        }
        function lookupSymbolChain(symbol, context, meaning, yieldModuleSymbol) {
            context.tracker.trackSymbol(symbol, context.enclosingDeclaration, meaning);
            return lookupSymbolChainWorker(symbol, context, meaning, yieldModuleSymbol);
        }
        function lookupSymbolChainWorker(symbol, context, meaning, yieldModuleSymbol) {
            let chain;
            const isTypeParameter = symbol.flags & 262144;
            if (!isTypeParameter && (context.enclosingDeclaration || context.flags & 64) && !(context.flags & 134217728)) {
                chain = Debug.checkDefined(getSymbolChain(symbol, meaning, true));
                Debug.assert(chain && chain.length > 0);
            } else {
                chain = [symbol];
            }
            return chain;
            function getSymbolChain(symbol2, meaning2, endOfChain) {
                let accessibleSymbolChain = getAccessibleSymbolChain(symbol2, context.enclosingDeclaration, meaning2, !!(context.flags & 128));
                let parentSpecifiers;
                if (!accessibleSymbolChain || needsQualification(accessibleSymbolChain[0], context.enclosingDeclaration, accessibleSymbolChain.length === 1 ? meaning2 : getQualifiedLeftMeaning(meaning2))) {
                    const parents = getContainersOfSymbol(accessibleSymbolChain ? accessibleSymbolChain[0] : symbol2, context.enclosingDeclaration, meaning2);
                    if (length(parents)) {
                        parentSpecifiers = parents.map(symbol3 => some(symbol3.declarations, hasNonGlobalAugmentationExternalModuleSymbol) ? getSpecifierForModuleSymbol(symbol3, context) : void 0);
                        const indices = parents.map((_, i) => i);
                        indices.sort(sortByBestName);
                        const sortedParents = indices.map(i => parents[i]);
                        for (const parent2 of sortedParents) {
                            const parentChain = getSymbolChain(parent2, getQualifiedLeftMeaning(meaning2), false);
                            if (parentChain) {
                                if (parent2.exports && parent2.exports.get("export=") && getSymbolIfSameReference(parent2.exports.get("export="), symbol2)) {
                                    accessibleSymbolChain = parentChain;
                                    break;
                                }
                                accessibleSymbolChain = parentChain.concat(accessibleSymbolChain || [getAliasForSymbolInContainer(parent2, symbol2) || symbol2]);
                                break;
                            }
                        }
                    }
                }
                if (accessibleSymbolChain) {
                    return accessibleSymbolChain;
                }
                if (endOfChain || !(symbol2.flags & (2048 | 4096))) {
                    if (!endOfChain && !yieldModuleSymbol && !!forEach(symbol2.declarations, hasNonGlobalAugmentationExternalModuleSymbol)) {
                        return;
                    }
                    return [symbol2];
                }
                function sortByBestName(a, b) {
                    const specifierA = parentSpecifiers[a];
                    const specifierB = parentSpecifiers[b];
                    if (specifierA && specifierB) {
                        const isBRelative = pathIsRelative(specifierB);
                        if (pathIsRelative(specifierA) === isBRelative) {
                            return countPathComponents(specifierA) - countPathComponents(specifierB);
                        }
                        if (isBRelative) {
                            return -1;
                        }
                        return 1;
                    }
                    return 0;
                }
            }
        }
        function typeParametersToTypeParameterDeclarations(symbol, context) {
            let typeParameterNodes;
            const targetSymbol = getTargetSymbol(symbol);
            if (targetSymbol.flags & (32 | 64 | 524288)) {
                typeParameterNodes = factory.createNodeArray(map(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol), tp => typeParameterToDeclaration(tp, context)));
            }
            return typeParameterNodes;
        }
        function lookupTypeParameterNodes(chain, index, context) {
            var _a2;
            Debug.assert(chain && 0 <= index && index < chain.length);
            const symbol = chain[index];
            const symbolId = getSymbolId(symbol);
            if ((_a2 = context.typeParameterSymbolList) == null ? void 0 : _a2.has(symbolId)) {
                return void 0;
            }
            (context.typeParameterSymbolList || (context.typeParameterSymbolList = /* @__PURE__ */new Set())).add(symbolId);
            let typeParameterNodes;
            if (context.flags & 512 && index < chain.length - 1) {
                const parentSymbol = symbol;
                const nextSymbol = chain[index + 1];
                if (getCheckFlags(nextSymbol) & 1) {
                    const params = getTypeParametersOfClassOrInterface(parentSymbol.flags & 2097152 ? resolveAlias(parentSymbol) : parentSymbol);
                    typeParameterNodes = mapToTypeNodes(map(params, t => getMappedType(t, nextSymbol.links.mapper)), context);
                } else {
                    typeParameterNodes = typeParametersToTypeParameterDeclarations(symbol, context);
                }
            }
            return typeParameterNodes;
        }
        function getTopmostIndexedAccessType(top) {
            if (isIndexedAccessTypeNode(top.objectType)) {
                return getTopmostIndexedAccessType(top.objectType);
            }
            return top;
        }
        function getSpecifierForModuleSymbol(symbol, context, overrideImportMode) {
            var _a2;
            let file = getDeclarationOfKind(symbol, 308);
            if (!file) {
                const equivalentFileSymbol = firstDefined(symbol.declarations, d => getFileSymbolIfFileSymbolExportEqualsContainer(d, symbol));
                if (equivalentFileSymbol) {
                    file = getDeclarationOfKind(equivalentFileSymbol, 308);
                }
            }
            if (file && file.moduleName !== void 0) {
                return file.moduleName;
            }
            if (!file) {
                if (context.tracker.trackReferencedAmbientModule) {
                    const ambientDecls = filter(symbol.declarations, isAmbientModule);
                    if (length(ambientDecls)) {
                        for (const decl of ambientDecls) {
                            context.tracker.trackReferencedAmbientModule(decl, symbol);
                        }
                    }
                }
                if (ambientModuleSymbolRegex.test(symbol.escapedName)) {
                    return symbol.escapedName.substring(1, symbol.escapedName.length - 1);
                }
            }
            if (!context.enclosingDeclaration || !context.tracker.moduleResolverHost) {
                if (ambientModuleSymbolRegex.test(symbol.escapedName)) {
                    return symbol.escapedName.substring(1, symbol.escapedName.length - 1);
                }
                return getSourceFileOfNode(getNonAugmentationDeclaration(symbol)).fileName;
            }
            const contextFile = getSourceFileOfNode(getOriginalNode(context.enclosingDeclaration));
            const resolutionMode = overrideImportMode || (contextFile == null ? void 0 : contextFile.impliedNodeFormat);
            const cacheKey = createModeAwareCacheKey(contextFile.path, resolutionMode);
            const links = getSymbolLinks(symbol);
            let specifier = links.specifierCache && links.specifierCache.get(cacheKey);
            if (!specifier) {
                const isBundle2 = !!outFile(compilerOptions);
                const {
                    moduleResolverHost
                } = context.tracker;
                const specifierCompilerOptions = isBundle2 ? {
                    ...compilerOptions,
                    baseUrl: moduleResolverHost.getCommonSourceDirectory()
                } : compilerOptions;
                specifier = first(getModuleSpecifiers(symbol, checker, specifierCompilerOptions, contextFile, moduleResolverHost, {
                    importModuleSpecifierPreference: isBundle2 ? "non-relative" : "project-relative",
                    importModuleSpecifierEnding: isBundle2 ? "minimal" : resolutionMode === 99 ? "js" : void 0
                }, {
                    overrideImportMode
                }));
                (_a2 = links.specifierCache) != null ? _a2 : links.specifierCache = /* @__PURE__ */new Map();
                links.specifierCache.set(cacheKey, specifier);
            }
            return specifier;
        }
        function symbolToEntityNameNode(symbol) {
            const identifier = factory.createIdentifier(unescapeLeadingUnderscores(symbol.escapedName));
            return symbol.parent ? factory.createQualifiedName(symbolToEntityNameNode(symbol.parent), identifier) : identifier;
        }
        function symbolToTypeNode(symbol, context, meaning, overrideTypeArguments) {
            var _a2, _b, _c, _d;
            const chain = lookupSymbolChain(symbol, context, meaning, !(context.flags & 16384));
            const isTypeOf = meaning === 111551;
            if (some(chain[0].declarations, hasNonGlobalAugmentationExternalModuleSymbol)) {
                const nonRootParts = chain.length > 1 ? createAccessFromSymbolChain(chain, chain.length - 1, 1) : void 0;
                const typeParameterNodes = overrideTypeArguments || lookupTypeParameterNodes(chain, 0, context);
                const contextFile = getSourceFileOfNode(getOriginalNode(context.enclosingDeclaration));
                const targetFile = getSourceFileOfModule(chain[0]);
                let specifier;
                let assertion;
                if (getEmitModuleResolutionKind(compilerOptions) === 3 || getEmitModuleResolutionKind(compilerOptions) === 99) {
                    if ((targetFile == null ? void 0 : targetFile.impliedNodeFormat) === 99 && targetFile.impliedNodeFormat !== (contextFile == null ? void 0 : contextFile.impliedNodeFormat)) {
                        specifier = getSpecifierForModuleSymbol(chain[0], context, 99);
                        assertion = factory.createImportTypeAssertionContainer(factory.createAssertClause(factory.createNodeArray([factory.createAssertEntry(factory.createStringLiteral("resolution-mode"), factory.createStringLiteral("import"))])));
                        (_b = (_a2 = context.tracker).reportImportTypeNodeResolutionModeOverride) == null ? void 0 : _b.call(_a2);
                    }
                }
                if (!specifier) {
                    specifier = getSpecifierForModuleSymbol(chain[0], context);
                }
                if (!(context.flags & 67108864) && getEmitModuleResolutionKind(compilerOptions) !== 1 && specifier.indexOf("/node_modules/") >= 0) {
                    const oldSpecifier = specifier;
                    if (getEmitModuleResolutionKind(compilerOptions) === 3 || getEmitModuleResolutionKind(compilerOptions) === 99) {
                        const swappedMode = (contextFile == null ? void 0 : contextFile.impliedNodeFormat) === 99 ? 1 : 99;
                        specifier = getSpecifierForModuleSymbol(chain[0], context, swappedMode);
                        if (specifier.indexOf("/node_modules/") >= 0) {
                            specifier = oldSpecifier;
                        } else {
                            assertion = factory.createImportTypeAssertionContainer(factory.createAssertClause(factory.createNodeArray([factory.createAssertEntry(factory.createStringLiteral("resolution-mode"), factory.createStringLiteral(swappedMode === 99 ? "import" : "require"))])));
                            (_d = (_c = context.tracker).reportImportTypeNodeResolutionModeOverride) == null ? void 0 : _d.call(_c);
                        }
                    }
                    if (!assertion) {
                        context.encounteredError = true;
                        if (context.tracker.reportLikelyUnsafeImportRequiredError) {
                            context.tracker.reportLikelyUnsafeImportRequiredError(oldSpecifier);
                        }
                    }
                }
                const lit = factory.createLiteralTypeNode(factory.createStringLiteral(specifier));
                if (context.tracker.trackExternalModuleSymbolOfImportTypeNode) context.tracker.trackExternalModuleSymbolOfImportTypeNode(chain[0]);
                context.approximateLength += specifier.length + 10;
                if (!nonRootParts || isEntityName(nonRootParts)) {
                    if (nonRootParts) {
                        const lastId = isIdentifier(nonRootParts) ? nonRootParts : nonRootParts.right;
                        setIdentifierTypeArguments(lastId, void 0);
                    }
                    return factory.createImportTypeNode(lit, assertion, nonRootParts, typeParameterNodes, isTypeOf);
                } else {
                    const splitNode = getTopmostIndexedAccessType(nonRootParts);
                    const qualifier = splitNode.objectType.typeName;
                    return factory.createIndexedAccessTypeNode(factory.createImportTypeNode(lit, assertion, qualifier, typeParameterNodes, isTypeOf), splitNode.indexType);
                }
            }
            const entityName = createAccessFromSymbolChain(chain, chain.length - 1, 0);
            if (isIndexedAccessTypeNode(entityName)) {
                return entityName;
            }
            if (isTypeOf) {
                return factory.createTypeQueryNode(entityName);
            } else {
                const lastId = isIdentifier(entityName) ? entityName : entityName.right;
                const lastTypeArgs = getIdentifierTypeArguments(lastId);
                setIdentifierTypeArguments(lastId, void 0);
                return factory.createTypeReferenceNode(entityName, lastTypeArgs);
            }
            function createAccessFromSymbolChain(chain2, index, stopper) {
                const typeParameterNodes = index === chain2.length - 1 ? overrideTypeArguments : lookupTypeParameterNodes(chain2, index, context);
                const symbol2 = chain2[index];
                const parent2 = chain2[index - 1];
                let symbolName2;
                if (index === 0) {
                    context.flags |= 16777216;
                    symbolName2 = getNameOfSymbolAsWritten(symbol2, context);
                    context.approximateLength += (symbolName2 ? symbolName2.length : 0) + 1;
                    context.flags ^= 16777216;
                } else {
                    if (parent2 && getExportsOfSymbol(parent2)) {
                        const exports = getExportsOfSymbol(parent2);
                        forEachEntry(exports, (ex, name) => {
                            if (getSymbolIfSameReference(ex, symbol2) && !isLateBoundName(name) && name !== "export=") {
                                symbolName2 = unescapeLeadingUnderscores(name);
                                return true;
                            }
                        });
                    }
                }
                if (symbolName2 === void 0) {
                    const name = firstDefined(symbol2.declarations, getNameOfDeclaration);
                    if (name && isComputedPropertyName(name) && isEntityName(name.expression)) {
                        const LHS = createAccessFromSymbolChain(chain2, index - 1, stopper);
                        if (isEntityName(LHS)) {
                            return factory.createIndexedAccessTypeNode(factory.createParenthesizedType(factory.createTypeQueryNode(LHS)), factory.createTypeQueryNode(name.expression));
                        }
                        return LHS;
                    }
                    symbolName2 = getNameOfSymbolAsWritten(symbol2, context);
                }
                context.approximateLength += symbolName2.length + 1;
                if (!(context.flags & 16) && parent2 && getMembersOfSymbol(parent2) && getMembersOfSymbol(parent2).get(symbol2.escapedName) && getSymbolIfSameReference(getMembersOfSymbol(parent2).get(symbol2.escapedName), symbol2)) {
                    const LHS = createAccessFromSymbolChain(chain2, index - 1, stopper);
                    if (isIndexedAccessTypeNode(LHS)) {
                        return factory.createIndexedAccessTypeNode(LHS, factory.createLiteralTypeNode(factory.createStringLiteral(symbolName2)));
                    } else {
                        return factory.createIndexedAccessTypeNode(factory.createTypeReferenceNode(LHS, typeParameterNodes), factory.createLiteralTypeNode(factory.createStringLiteral(symbolName2)));
                    }
                }
                const identifier = setEmitFlags(factory.createIdentifier(symbolName2), 33554432);
                if (typeParameterNodes) setIdentifierTypeArguments(identifier, factory.createNodeArray(typeParameterNodes));
                identifier.symbol = symbol2;
                if (index > stopper) {
                    const LHS = createAccessFromSymbolChain(chain2, index - 1, stopper);
                    if (!isEntityName(LHS)) {
                        return Debug.fail("Impossible construct - an export of an indexed access cannot be reachable");
                    }
                    return factory.createQualifiedName(LHS, identifier);
                }
                return identifier;
            }
        }
        function typeParameterShadowsNameInScope(escapedName, context, type) {
            const result = resolveName(context.enclosingDeclaration, escapedName, 788968, void 0, escapedName, false);
            if (result) {
                if (result.flags & 262144 && result === type.symbol) {
                    return false;
                }
                return true;
            }
            return false;
        }
        function typeParameterToName(type, context) {
            var _a2, _b;
            if (context.flags & 4 && context.typeParameterNames) {
                const cached = context.typeParameterNames.get(getTypeId(type));
                if (cached) {
                    return cached;
                }
            }
            let result = symbolToName(type.symbol, context, 788968, true);
            if (!(result.kind & 79)) {
                return factory.createIdentifier("(Missing type parameter)");
            }
            if (context.flags & 4) {
                const rawtext = result.escapedText;
                let i = ((_a2 = context.typeParameterNamesByTextNextNameCount) == null ? void 0 : _a2.get(rawtext)) || 0;
                let text = rawtext;
                while (((_b = context.typeParameterNamesByText) == null ? void 0 : _b.has(text)) || typeParameterShadowsNameInScope(text, context, type)) {
                    i++;
                    text = `${rawtext}_${i}`;
                }
                if (text !== rawtext) {
                    const typeArguments = getIdentifierTypeArguments(result);
                    result = factory.createIdentifier(text);
                    setIdentifierTypeArguments(result, typeArguments);
                }
                (context.typeParameterNamesByTextNextNameCount || (context.typeParameterNamesByTextNextNameCount = /* @__PURE__ */new Map())).set(rawtext, i);
                (context.typeParameterNames || (context.typeParameterNames = /* @__PURE__ */new Map())).set(getTypeId(type), result);
                (context.typeParameterNamesByText || (context.typeParameterNamesByText = /* @__PURE__ */new Set())).add(rawtext);
            }
            return result;
        }
        function symbolToName(symbol, context, meaning, expectsIdentifier) {
            const chain = lookupSymbolChain(symbol, context, meaning);
            if (expectsIdentifier && chain.length !== 1 && !context.encounteredError && !(context.flags & 65536)) {
                context.encounteredError = true;
            }
            return createEntityNameFromSymbolChain(chain, chain.length - 1);
            function createEntityNameFromSymbolChain(chain2, index) {
                const typeParameterNodes = lookupTypeParameterNodes(chain2, index, context);
                const symbol2 = chain2[index];
                if (index === 0) {
                    context.flags |= 16777216;
                }
                const symbolName2 = getNameOfSymbolAsWritten(symbol2, context);
                if (index === 0) {
                    context.flags ^= 16777216;
                }
                const identifier = setEmitFlags(factory.createIdentifier(symbolName2), 33554432);
                if (typeParameterNodes) setIdentifierTypeArguments(identifier, factory.createNodeArray(typeParameterNodes));
                identifier.symbol = symbol2;
                return index > 0 ? factory.createQualifiedName(createEntityNameFromSymbolChain(chain2, index - 1), identifier) : identifier;
            }
        }
        function symbolToExpression(symbol, context, meaning) {
            const chain = lookupSymbolChain(symbol, context, meaning);
            return createExpressionFromSymbolChain(chain, chain.length - 1);
            function createExpressionFromSymbolChain(chain2, index) {
                const typeParameterNodes = lookupTypeParameterNodes(chain2, index, context);
                const symbol2 = chain2[index];
                if (index === 0) {
                    context.flags |= 16777216;
                }
                let symbolName2 = getNameOfSymbolAsWritten(symbol2, context);
                if (index === 0) {
                    context.flags ^= 16777216;
                }
                let firstChar = symbolName2.charCodeAt(0);
                if (isSingleOrDoubleQuote(firstChar) && some(symbol2.declarations, hasNonGlobalAugmentationExternalModuleSymbol)) {
                    return factory.createStringLiteral(getSpecifierForModuleSymbol(symbol2, context));
                }
                if (index === 0 || canUsePropertyAccess(symbolName2, languageVersion)) {
                    const identifier = setEmitFlags(factory.createIdentifier(symbolName2), 33554432);
                    if (typeParameterNodes) setIdentifierTypeArguments(identifier, factory.createNodeArray(typeParameterNodes));
                    identifier.symbol = symbol2;
                    return index > 0 ? factory.createPropertyAccessExpression(createExpressionFromSymbolChain(chain2, index - 1), identifier) : identifier;
                } else {
                    if (firstChar === 91) {
                        symbolName2 = symbolName2.substring(1, symbolName2.length - 1);
                        firstChar = symbolName2.charCodeAt(0);
                    }
                    let expression;
                    if (isSingleOrDoubleQuote(firstChar) && !(symbol2.flags & 8)) {
                        expression = factory.createStringLiteral(stripQuotes(symbolName2).replace(/\\./g, s => s.substring(1)), firstChar === 39);
                    } else if ("" + +symbolName2 === symbolName2) {
                        expression = factory.createNumericLiteral(+symbolName2);
                    }
                    if (!expression) {
                        const identifier = setEmitFlags(factory.createIdentifier(symbolName2), 33554432);
                        if (typeParameterNodes) setIdentifierTypeArguments(identifier, factory.createNodeArray(typeParameterNodes));
                        identifier.symbol = symbol2;
                        expression = identifier;
                    }
                    return factory.createElementAccessExpression(createExpressionFromSymbolChain(chain2, index - 1), expression);
                }
            }
        }
        function isStringNamed(d) {
            const name = getNameOfDeclaration(d);
            return !!name && isStringLiteral(name);
        }
        function isSingleQuotedStringNamed(d) {
            const name = getNameOfDeclaration(d);
            return !!(name && isStringLiteral(name) && (name.singleQuote || !nodeIsSynthesized(name) && startsWith(getTextOfNode(name, false), "'")));
        }
        function getPropertyNameNodeForSymbol(symbol, context) {
            const stringNamed = !!length(symbol.declarations) && every(symbol.declarations, isStringNamed);
            const singleQuote = !!length(symbol.declarations) && every(symbol.declarations, isSingleQuotedStringNamed);
            const fromNameType = getPropertyNameNodeForSymbolFromNameType(symbol, context, singleQuote, stringNamed);
            if (fromNameType) {
                return fromNameType;
            }
            const rawName = unescapeLeadingUnderscores(symbol.escapedName);
            return createPropertyNameNodeForIdentifierOrLiteral(rawName, getEmitScriptTarget(compilerOptions), singleQuote, stringNamed);
        }
        function getPropertyNameNodeForSymbolFromNameType(symbol, context, singleQuote, stringNamed) {
            const nameType = getSymbolLinks(symbol).nameType;
            if (nameType) {
                if (nameType.flags & 384) {
                    const name = "" + nameType.value;
                    if (!isIdentifierText(name, getEmitScriptTarget(compilerOptions)) && (stringNamed || !isNumericLiteralName(name))) {
                        return factory.createStringLiteral(name, !!singleQuote);
                    }
                    if (isNumericLiteralName(name) && startsWith(name, "-")) {
                        return factory.createComputedPropertyName(factory.createNumericLiteral(+name));
                    }
                    return createPropertyNameNodeForIdentifierOrLiteral(name, getEmitScriptTarget(compilerOptions));
                }
                if (nameType.flags & 8192) {
                    return factory.createComputedPropertyName(symbolToExpression(nameType.symbol, context, 111551));
                }
            }
        }
        function cloneNodeBuilderContext(context) {
            const initial = {
                ...context
            };
            if (initial.typeParameterNames) {
                initial.typeParameterNames = new Map(initial.typeParameterNames);
            }
            if (initial.typeParameterNamesByText) {
                initial.typeParameterNamesByText = new Set(initial.typeParameterNamesByText);
            }
            if (initial.typeParameterSymbolList) {
                initial.typeParameterSymbolList = new Set(initial.typeParameterSymbolList);
            }
            initial.tracker = new SymbolTrackerImpl(initial, initial.tracker.inner, initial.tracker.moduleResolverHost);
            return initial;
        }
        function getDeclarationWithTypeAnnotation(symbol, enclosingDeclaration) {
            return symbol.declarations && find(symbol.declarations, s => !!getEffectiveTypeAnnotationNode(s) && (!enclosingDeclaration || !!findAncestor(s, n => n === enclosingDeclaration)));
        }
        function existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type) {
            return !(getObjectFlags(type) & 4) || !isTypeReferenceNode(existing) || length(existing.typeArguments) >= getMinTypeArgumentCount(type.target.typeParameters);
        }
        function getEnclosingDeclarationIgnoringFakeScope(enclosingDeclaration) {
            return getNodeLinks(enclosingDeclaration).fakeScopeForSignatureDeclaration ? enclosingDeclaration.parent : enclosingDeclaration;
        }
        function serializeTypeForDeclaration(context, type, symbol, enclosingDeclaration, includePrivateSymbol, bundled) {
            if (!isErrorType(type) && enclosingDeclaration) {
                const declWithExistingAnnotation = getDeclarationWithTypeAnnotation(symbol, getEnclosingDeclarationIgnoringFakeScope(enclosingDeclaration));
                if (declWithExistingAnnotation && !isFunctionLikeDeclaration(declWithExistingAnnotation) && !isGetAccessorDeclaration(declWithExistingAnnotation)) {
                    const existing = getEffectiveTypeAnnotationNode(declWithExistingAnnotation);
                    if (typeNodeIsEquivalentToType(existing, declWithExistingAnnotation, type) && existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(existing, type)) {
                        const result2 = serializeExistingTypeNode(context, existing, includePrivateSymbol, bundled);
                        if (result2) {
                            return result2;
                        }
                    }
                }
            }
            const oldFlags = context.flags;
            if (type.flags & 8192 && type.symbol === symbol && (!context.enclosingDeclaration || some(symbol.declarations, d => getSourceFileOfNode(d) === getSourceFileOfNode(context.enclosingDeclaration)))) {
                context.flags |= 1048576;
            }
            const result = typeToTypeNodeHelper(type, context);
            context.flags = oldFlags;
            return result;
        }
        function typeNodeIsEquivalentToType(typeNode, annotatedDeclaration, type) {
            const typeFromTypeNode = getTypeFromTypeNode(typeNode);
            if (typeFromTypeNode === type) {
                return true;
            }
            if (isParameter(annotatedDeclaration) && annotatedDeclaration.questionToken) {
                return getTypeWithFacts(type, 524288) === typeFromTypeNode;
            }
            return false;
        }
        function serializeReturnTypeForSignature(context, type, signature, includePrivateSymbol, bundled) {
            if (!isErrorType(type) && context.enclosingDeclaration) {
                const annotation = signature.declaration && getEffectiveReturnTypeNode(signature.declaration);
                const enclosingDeclarationIgnoringFakeScope = getEnclosingDeclarationIgnoringFakeScope(context.enclosingDeclaration);
                if (!!findAncestor(annotation, n => n === enclosingDeclarationIgnoringFakeScope) && annotation) {
                    const annotated = getTypeFromTypeNode(annotation);
                    const thisInstantiated = annotated.flags & 262144 && annotated.isThisType ? instantiateType(annotated, signature.mapper) : annotated;
                    if (thisInstantiated === type && existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(annotation, type)) {
                        const result = serializeExistingTypeNode(context, annotation, includePrivateSymbol, bundled);
                        if (result) {
                            return result;
                        }
                    }
                }
            }
            return typeToTypeNodeHelper(type, context);
        }
        function trackExistingEntityName(node, context, includePrivateSymbol) {
            let introducesError = false;
            const leftmost = getFirstIdentifier(node);
            if (isInJSFile(node) && (isExportsIdentifier(leftmost) || isModuleExportsAccessExpression(leftmost.parent) || isQualifiedName(leftmost.parent) && isModuleIdentifier(leftmost.parent.left) && isExportsIdentifier(leftmost.parent.right))) {
                introducesError = true;
                return {
                    introducesError,
                    node
                };
            }
            const sym = resolveEntityName(leftmost, 67108863, true, true);
            if (sym) {
                if (isSymbolAccessible(sym, context.enclosingDeclaration, 67108863, false).accessibility !== 0) {
                    introducesError = true;
                } else {
                    context.tracker.trackSymbol(sym, context.enclosingDeclaration, 67108863);
                    includePrivateSymbol == null ? void 0 : includePrivateSymbol(sym);
                }
                if (isIdentifier(node)) {
                    const type = getDeclaredTypeOfSymbol(sym);
                    const name = sym.flags & 262144 && !isTypeSymbolAccessible(type.symbol, context.enclosingDeclaration) ? typeParameterToName(type, context) : factory.cloneNode(node);
                    name.symbol = sym;
                    return {
                        introducesError,
                        node: setEmitFlags(setOriginalNode(name, node), 33554432)
                    };
                }
            }
            return {
                introducesError,
                node
            };
        }
        function serializeExistingTypeNode(context, existing, includePrivateSymbol, bundled) {
            if (cancellationToken && cancellationToken.throwIfCancellationRequested) {
                cancellationToken.throwIfCancellationRequested();
            }
            let hadError = false;
            const file = getSourceFileOfNode(existing);
            const transformed = visitNode(existing, visitExistingNodeTreeSymbols, isTypeNode);
            if (hadError) {
                return void 0;
            }
            return transformed === existing ? setTextRange(factory.cloneNode(existing), existing) : transformed;
            function visitExistingNodeTreeSymbols(node) {
                if (isJSDocAllType(node) || node.kind === 322) {
                    return factory.createKeywordTypeNode(131);
                }
                if (isJSDocUnknownType(node)) {
                    return factory.createKeywordTypeNode(157);
                }
                if (isJSDocNullableType(node)) {
                    return factory.createUnionTypeNode([visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode), factory.createLiteralTypeNode(factory.createNull())]);
                }
                if (isJSDocOptionalType(node)) {
                    return factory.createUnionTypeNode([visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode), factory.createKeywordTypeNode(155)]);
                }
                if (isJSDocNonNullableType(node)) {
                    return visitNode(node.type, visitExistingNodeTreeSymbols);
                }
                if (isJSDocVariadicType(node)) {
                    return factory.createArrayTypeNode(visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode));
                }
                if (isJSDocTypeLiteral(node)) {
                    return factory.createTypeLiteralNode(map(node.jsDocPropertyTags, t => {
                        const name = isIdentifier(t.name) ? t.name : t.name.right;
                        const typeViaParent = getTypeOfPropertyOfType(getTypeFromTypeNode(node), name.escapedText);
                        const overrideTypeNode = typeViaParent && t.typeExpression && getTypeFromTypeNode(t.typeExpression.type) !== typeViaParent ? typeToTypeNodeHelper(typeViaParent, context) : void 0;
                        return factory.createPropertySignature(void 0, name, t.isBracketed || t.typeExpression && isJSDocOptionalType(t.typeExpression.type) ? factory.createToken(57) : void 0, overrideTypeNode || t.typeExpression && visitNode(t.typeExpression.type, visitExistingNodeTreeSymbols, isTypeNode) || factory.createKeywordTypeNode(131));
                    }));
                }
                if (isTypeReferenceNode(node) && isIdentifier(node.typeName) && node.typeName.escapedText === "") {
                    return setOriginalNode(factory.createKeywordTypeNode(131), node);
                }
                if ((isExpressionWithTypeArguments(node) || isTypeReferenceNode(node)) && isJSDocIndexSignature(node)) {
                    return factory.createTypeLiteralNode([factory.createIndexSignature(void 0, [factory.createParameterDeclaration(void 0, void 0, "x", void 0, visitNode(node.typeArguments[0], visitExistingNodeTreeSymbols, isTypeNode))], visitNode(node.typeArguments[1], visitExistingNodeTreeSymbols, isTypeNode))]);
                }
                if (isJSDocFunctionType(node)) {
                    if (isJSDocConstructSignature(node)) {
                        let newTypeNode;
                        return factory.createConstructorTypeNode(void 0, visitNodes2(node.typeParameters, visitExistingNodeTreeSymbols, isTypeParameterDeclaration), mapDefined(node.parameters, (p, i) => p.name && isIdentifier(p.name) && p.name.escapedText === "new" ? (newTypeNode = p.type, void 0) : factory.createParameterDeclaration(void 0, getEffectiveDotDotDotForParameter(p), getNameForJSDocFunctionParameter(p, i), p.questionToken, visitNode(p.type, visitExistingNodeTreeSymbols, isTypeNode), void 0)), visitNode(newTypeNode || node.type, visitExistingNodeTreeSymbols, isTypeNode) || factory.createKeywordTypeNode(131));
                    } else {
                        return factory.createFunctionTypeNode(visitNodes2(node.typeParameters, visitExistingNodeTreeSymbols, isTypeParameterDeclaration), map(node.parameters, (p, i) => factory.createParameterDeclaration(void 0, getEffectiveDotDotDotForParameter(p), getNameForJSDocFunctionParameter(p, i), p.questionToken, visitNode(p.type, visitExistingNodeTreeSymbols, isTypeNode), void 0)), visitNode(node.type, visitExistingNodeTreeSymbols, isTypeNode) || factory.createKeywordTypeNode(131));
                    }
                }
                if (isTypeReferenceNode(node) && isInJSDoc(node) && (!existingTypeNodeIsNotReferenceOrIsReferenceWithCompatibleTypeArgumentCount(node, getTypeFromTypeNode(node)) || getIntendedTypeFromJSDocTypeReference(node) || unknownSymbol === resolveTypeReferenceName(node, 788968, true))) {
                    return setOriginalNode(typeToTypeNodeHelper(getTypeFromTypeNode(node), context), node);
                }
                if (isLiteralImportTypeNode(node)) {
                    const nodeSymbol = getNodeLinks(node).resolvedSymbol;
                    if (isInJSDoc(node) && nodeSymbol && (!node.isTypeOf && !(nodeSymbol.flags & 788968) || !(length(node.typeArguments) >= getMinTypeArgumentCount(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(nodeSymbol))))) {
                        return setOriginalNode(typeToTypeNodeHelper(getTypeFromTypeNode(node), context), node);
                    }
                    return factory.updateImportTypeNode(node, factory.updateLiteralTypeNode(node.argument, rewriteModuleSpecifier(node, node.argument.literal)), node.assertions, node.qualifier, visitNodes2(node.typeArguments, visitExistingNodeTreeSymbols, isTypeNode), node.isTypeOf);
                }
                if (isEntityName(node) || isEntityNameExpression(node)) {
                    const {
                        introducesError,
                        node: result
                    } = trackExistingEntityName(node, context, includePrivateSymbol);
                    hadError = hadError || introducesError;
                    if (result !== node) {
                        return result;
                    }
                }
                if (file && isTupleTypeNode(node) && getLineAndCharacterOfPosition(file, node.pos).line === getLineAndCharacterOfPosition(file, node.end).line) {
                    setEmitFlags(node, 1);
                }
                return visitEachChild(node, visitExistingNodeTreeSymbols, nullTransformationContext);
                function getEffectiveDotDotDotForParameter(p) {
                    return p.dotDotDotToken || (p.type && isJSDocVariadicType(p.type) ? factory.createToken(25) : void 0);
                }
                function getNameForJSDocFunctionParameter(p, index) {
                    return p.name && isIdentifier(p.name) && p.name.escapedText === "this" ? "this" : getEffectiveDotDotDotForParameter(p) ? `args` : `arg${index}`;
                }
                function rewriteModuleSpecifier(parent2, lit) {
                    if (bundled) {
                        if (context.tracker && context.tracker.moduleResolverHost) {
                            const targetFile = getExternalModuleFileFromDeclaration(parent2);
                            if (targetFile) {
                                const getCanonicalFileName = createGetCanonicalFileName(!!host.useCaseSensitiveFileNames);
                                const resolverHost = {
                                    getCanonicalFileName,
                                    getCurrentDirectory: () => context.tracker.moduleResolverHost.getCurrentDirectory(),
                                    getCommonSourceDirectory: () => context.tracker.moduleResolverHost.getCommonSourceDirectory()
                                };
                                const newName = getResolvedExternalModuleName(resolverHost, targetFile);
                                return factory.createStringLiteral(newName);
                            }
                        }
                    } else {
                        if (context.tracker && context.tracker.trackExternalModuleSymbolOfImportTypeNode) {
                            const moduleSym = resolveExternalModuleNameWorker(lit, lit, void 0);
                            if (moduleSym) {
                                context.tracker.trackExternalModuleSymbolOfImportTypeNode(moduleSym);
                            }
                        }
                    }
                    return lit;
                }
            }
        }
        function symbolTableToDeclarationStatements(symbolTable, context, bundled) {
            const serializePropertySymbolForClass = makeSerializePropertySymbol(factory.createPropertyDeclaration, 171, true);
            const serializePropertySymbolForInterfaceWorker = makeSerializePropertySymbol((mods, name, question, type) => factory.createPropertySignature(mods, name, question, type), 170, false);
            const enclosingDeclaration = context.enclosingDeclaration;
            let results = [];
            const visitedSymbols = /* @__PURE__ */new Set();
            const deferredPrivatesStack = [];
            const oldcontext = context;
            context = {
                ...oldcontext,
                usedSymbolNames: new Set(oldcontext.usedSymbolNames),
                remappedSymbolNames: /* @__PURE__ */new Map(),
                tracker: void 0
            };
            const tracker = {
                ...oldcontext.tracker.inner,
                trackSymbol: (sym, decl, meaning) => {
                    var _a2;
                    const accessibleResult = isSymbolAccessible(sym, decl, meaning, false);
                    if (accessibleResult.accessibility === 0) {
                        const chain = lookupSymbolChainWorker(sym, context, meaning);
                        if (!(sym.flags & 4)) {
                            includePrivateSymbol(chain[0]);
                        }
                    } else if ((_a2 = oldcontext.tracker.inner) == null ? void 0 : _a2.trackSymbol) {
                        return oldcontext.tracker.inner.trackSymbol(sym, decl, meaning);
                    }
                    return false;
                }
            };
            context.tracker = new SymbolTrackerImpl(context, tracker, oldcontext.tracker.moduleResolverHost);
            forEachEntry(symbolTable, (symbol, name) => {
                const baseName = unescapeLeadingUnderscores(name);
                void getInternalSymbolName(symbol, baseName);
            });
            let addingDeclare = !bundled;
            const exportEquals = symbolTable.get("export=");
            if (exportEquals && symbolTable.size > 1 && exportEquals.flags & 2097152) {
                symbolTable = createSymbolTable();
                symbolTable.set("export=", exportEquals);
            }
            visitSymbolTable(symbolTable);
            return mergeRedundantStatements(results);
            function isIdentifierAndNotUndefined(node) {
                return !!node && node.kind === 79;
            }
            function getNamesOfDeclaration(statement) {
                if (isVariableStatement(statement)) {
                    return filter(map(statement.declarationList.declarations, getNameOfDeclaration), isIdentifierAndNotUndefined);
                }
                return filter([getNameOfDeclaration(statement)], isIdentifierAndNotUndefined);
            }
            function flattenExportAssignedNamespace(statements) {
                const exportAssignment = find(statements, isExportAssignment);
                const nsIndex = findIndex(statements, isModuleDeclaration);
                let ns = nsIndex !== -1 ? statements[nsIndex] : void 0;
                if (ns && exportAssignment && exportAssignment.isExportEquals && isIdentifier(exportAssignment.expression) && isIdentifier(ns.name) && idText(ns.name) === idText(exportAssignment.expression) && ns.body && isModuleBlock(ns.body)) {
                    const excessExports = filter(statements, s => !!(getEffectiveModifierFlags(s) & 1));
                    const name = ns.name;
                    let body = ns.body;
                    if (length(excessExports)) {
                        ns = factory.updateModuleDeclaration(ns, ns.modifiers, ns.name, body = factory.updateModuleBlock(body, factory.createNodeArray([...ns.body.statements, factory.createExportDeclaration(void 0, false, factory.createNamedExports(map(flatMap(excessExports, e => getNamesOfDeclaration(e)), id => factory.createExportSpecifier(false, void 0, id))), void 0)])));
                        statements = [...statements.slice(0, nsIndex), ns, ...statements.slice(nsIndex + 1)];
                    }
                    if (!find(statements, s => s !== ns && nodeHasName(s, name))) {
                        results = [];
                        const mixinExportFlag = !some(body.statements, s => hasSyntacticModifier(s, 1) || isExportAssignment(s) || isExportDeclaration(s));
                        forEach(body.statements, s => {
                            addResult(s, mixinExportFlag ? 1 : 0);
                        });
                        statements = [...filter(statements, s => s !== ns && s !== exportAssignment), ...results];
                    }
                }
                return statements;
            }
            function mergeExportDeclarations(statements) {
                const exports = filter(statements, d => isExportDeclaration(d) && !d.moduleSpecifier && !!d.exportClause && isNamedExports(d.exportClause));
                if (length(exports) > 1) {
                    const nonExports = filter(statements, d => !isExportDeclaration(d) || !!d.moduleSpecifier || !d.exportClause);
                    statements = [...nonExports, factory.createExportDeclaration(void 0, false, factory.createNamedExports(flatMap(exports, e => cast(e.exportClause, isNamedExports).elements)), void 0)];
                }
                const reexports = filter(statements, d => isExportDeclaration(d) && !!d.moduleSpecifier && !!d.exportClause && isNamedExports(d.exportClause));
                if (length(reexports) > 1) {
                    const groups = group(reexports, decl => isStringLiteral(decl.moduleSpecifier) ? ">" + decl.moduleSpecifier.text : ">");
                    if (groups.length !== reexports.length) {
                        for (const group2 of groups) {
                            if (group2.length > 1) {
                                statements = [...filter(statements, s => group2.indexOf(s) === -1), factory.createExportDeclaration(void 0, false, factory.createNamedExports(flatMap(group2, e => cast(e.exportClause, isNamedExports).elements)), group2[0].moduleSpecifier)];
                            }
                        }
                    }
                }
                return statements;
            }
            function inlineExportModifiers(statements) {
                const index = findIndex(statements, d => isExportDeclaration(d) && !d.moduleSpecifier && !d.assertClause && !!d.exportClause && isNamedExports(d.exportClause));
                if (index >= 0) {
                    const exportDecl = statements[index];
                    const replacements = mapDefined(exportDecl.exportClause.elements, e => {
                        if (!e.propertyName) {
                            const indices = indicesOf(statements);
                            const associatedIndices = filter(indices, i => nodeHasName(statements[i], e.name));
                            if (length(associatedIndices) && every(associatedIndices, i => canHaveExportModifier(statements[i]))) {
                                for (const index2 of associatedIndices) {
                                    statements[index2] = addExportModifier(statements[index2]);
                                }
                                return void 0;
                            }
                        }
                        return e;
                    });
                    if (!length(replacements)) {
                        orderedRemoveItemAt(statements, index);
                    } else {
                        statements[index] = factory.updateExportDeclaration(exportDecl, exportDecl.modifiers, exportDecl.isTypeOnly, factory.updateNamedExports(exportDecl.exportClause, replacements), exportDecl.moduleSpecifier, exportDecl.assertClause);
                    }
                }
                return statements;
            }
            function mergeRedundantStatements(statements) {
                statements = flattenExportAssignedNamespace(statements);
                statements = mergeExportDeclarations(statements);
                statements = inlineExportModifiers(statements);
                if (enclosingDeclaration && (isSourceFile(enclosingDeclaration) && isExternalOrCommonJsModule(enclosingDeclaration) || isModuleDeclaration(enclosingDeclaration)) && (!some(statements, isExternalModuleIndicator) || !hasScopeMarker(statements) && some(statements, needsScopeMarker))) {
                    statements.push(createEmptyExports(factory));
                }
                return statements;
            }
            function addExportModifier(node) {
                const flags = (getEffectiveModifierFlags(node) | 1) & ~2;
                return factory.updateModifiers(node, flags);
            }
            function removeExportModifier(node) {
                const flags = getEffectiveModifierFlags(node) & ~1;
                return factory.updateModifiers(node, flags);
            }
            function visitSymbolTable(symbolTable2, suppressNewPrivateContext, propertyAsAlias) {
                if (!suppressNewPrivateContext) {
                    deferredPrivatesStack.push( /* @__PURE__ */new Map());
                }
                symbolTable2.forEach(symbol => {
                    serializeSymbol(symbol, false, !!propertyAsAlias);
                });
                if (!suppressNewPrivateContext) {
                    deferredPrivatesStack[deferredPrivatesStack.length - 1].forEach(symbol => {
                        serializeSymbol(symbol, true, !!propertyAsAlias);
                    });
                    deferredPrivatesStack.pop();
                }
            }
            function serializeSymbol(symbol, isPrivate, propertyAsAlias) {
                const visitedSym = getMergedSymbol(symbol);
                if (visitedSymbols.has(getSymbolId(visitedSym))) {
                    return;
                }
                visitedSymbols.add(getSymbolId(visitedSym));
                const skipMembershipCheck = !isPrivate;
                if (skipMembershipCheck || !!length(symbol.declarations) && some(symbol.declarations, d => !!findAncestor(d, n => n === enclosingDeclaration))) {
                    const oldContext = context;
                    context = cloneNodeBuilderContext(context);
                    serializeSymbolWorker(symbol, isPrivate, propertyAsAlias);
                    if (context.reportedDiagnostic) {
                        oldcontext.reportedDiagnostic = context.reportedDiagnostic;
                    }
                    context = oldContext;
                }
            }
            function serializeSymbolWorker(symbol, isPrivate, propertyAsAlias) {
                var _a2, _b, _c, _d;
                const symbolName2 = unescapeLeadingUnderscores(symbol.escapedName);
                const isDefault = symbol.escapedName === "default";
                if (isPrivate && !(context.flags & 131072) && isStringANonContextualKeyword(symbolName2) && !isDefault) {
                    context.encounteredError = true;
                    return;
                }
                let needsPostExportDefault = isDefault && !!(symbol.flags & -113 || symbol.flags & 16 && length(getPropertiesOfType(getTypeOfSymbol(symbol)))) && !(symbol.flags & 2097152);
                let needsExportDeclaration = !needsPostExportDefault && !isPrivate && isStringANonContextualKeyword(symbolName2) && !isDefault;
                if (needsPostExportDefault || needsExportDeclaration) {
                    isPrivate = true;
                }
                const modifierFlags = (!isPrivate ? 1 : 0) | (isDefault && !needsPostExportDefault ? 1024 : 0);
                const isConstMergedWithNS = symbol.flags & 1536 && symbol.flags & (2 | 1 | 4) && symbol.escapedName !== "export=";
                const isConstMergedWithNSPrintableAsSignatureMerge = isConstMergedWithNS && isTypeRepresentableAsFunctionNamespaceMerge(getTypeOfSymbol(symbol), symbol);
                if (symbol.flags & (16 | 8192) || isConstMergedWithNSPrintableAsSignatureMerge) {
                    serializeAsFunctionNamespaceMerge(getTypeOfSymbol(symbol), symbol, getInternalSymbolName(symbol, symbolName2), modifierFlags);
                }
                if (symbol.flags & 524288) {
                    serializeTypeAlias(symbol, symbolName2, modifierFlags);
                }
                if (symbol.flags & (2 | 1 | 4) && symbol.escapedName !== "export=" && !(symbol.flags & 4194304) && !(symbol.flags & 32) && !(symbol.flags & 8192) && !isConstMergedWithNSPrintableAsSignatureMerge) {
                    if (propertyAsAlias) {
                        const createdExport = serializeMaybeAliasAssignment(symbol);
                        if (createdExport) {
                            needsExportDeclaration = false;
                            needsPostExportDefault = false;
                        }
                    } else {
                        const type = getTypeOfSymbol(symbol);
                        const localName = getInternalSymbolName(symbol, symbolName2);
                        if (!(symbol.flags & 16) && isTypeRepresentableAsFunctionNamespaceMerge(type, symbol)) {
                            serializeAsFunctionNamespaceMerge(type, symbol, localName, modifierFlags);
                        } else {
                            const flags = !(symbol.flags & 2) ? ((_a2 = symbol.parent) == null ? void 0 : _a2.valueDeclaration) && isSourceFile((_b = symbol.parent) == null ? void 0 : _b.valueDeclaration) ? 2 : void 0 : isConstVariable(symbol) ? 2 : 1;
                            const name = needsPostExportDefault || !(symbol.flags & 4) ? localName : getUnusedName(localName, symbol);
                            let textRange = symbol.declarations && find(symbol.declarations, d => isVariableDeclaration(d));
                            if (textRange && isVariableDeclarationList(textRange.parent) && textRange.parent.declarations.length === 1) {
                                textRange = textRange.parent.parent;
                            }
                            const propertyAccessRequire = (_c = symbol.declarations) == null ? void 0 : _c.find(isPropertyAccessExpression);
                            if (propertyAccessRequire && isBinaryExpression(propertyAccessRequire.parent) && isIdentifier(propertyAccessRequire.parent.right) && ((_d = type.symbol) == null ? void 0 : _d.valueDeclaration) && isSourceFile(type.symbol.valueDeclaration)) {
                                const alias = localName === propertyAccessRequire.parent.right.escapedText ? void 0 : propertyAccessRequire.parent.right;
                                addResult(factory.createExportDeclaration(void 0, false, factory.createNamedExports([factory.createExportSpecifier(false, alias, localName)])), 0);
                                context.tracker.trackSymbol(type.symbol, context.enclosingDeclaration, 111551);
                            } else {
                                const statement = setTextRange(factory.createVariableStatement(void 0, factory.createVariableDeclarationList([factory.createVariableDeclaration(name, void 0, serializeTypeForDeclaration(context, type, symbol, enclosingDeclaration, includePrivateSymbol, bundled))], flags)), textRange);
                                addResult(statement, name !== localName ? modifierFlags & ~1 : modifierFlags);
                                if (name !== localName && !isPrivate) {
                                    addResult(factory.createExportDeclaration(void 0, false, factory.createNamedExports([factory.createExportSpecifier(false, name, localName)])), 0);
                                    needsExportDeclaration = false;
                                    needsPostExportDefault = false;
                                }
                            }
                        }
                    }
                }
                if (symbol.flags & 384) {
                    serializeEnum(symbol, symbolName2, modifierFlags);
                }
                if (symbol.flags & 32) {
                    if (symbol.flags & 4 && symbol.valueDeclaration && isBinaryExpression(symbol.valueDeclaration.parent) && isClassExpression(symbol.valueDeclaration.parent.right)) {
                        serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName2), modifierFlags);
                    } else {
                        serializeAsClass(symbol, getInternalSymbolName(symbol, symbolName2), modifierFlags);
                    }
                }
                if (symbol.flags & (512 | 1024) && (!isConstMergedWithNS || isTypeOnlyNamespace(symbol)) || isConstMergedWithNSPrintableAsSignatureMerge) {
                    serializeModule(symbol, symbolName2, modifierFlags);
                }
                if (symbol.flags & 64 && !(symbol.flags & 32)) {
                    serializeInterface(symbol, symbolName2, modifierFlags);
                }
                if (symbol.flags & 2097152) {
                    serializeAsAlias(symbol, getInternalSymbolName(symbol, symbolName2), modifierFlags);
                }
                if (symbol.flags & 4 && symbol.escapedName === "export=") {
                    serializeMaybeAliasAssignment(symbol);
                }
                if (symbol.flags & 8388608) {
                    if (symbol.declarations) {
                        for (const node of symbol.declarations) {
                            const resolvedModule = resolveExternalModuleName(node, node.moduleSpecifier);
                            if (!resolvedModule) continue;
                            addResult(factory.createExportDeclaration(void 0, node.isTypeOnly, void 0, factory.createStringLiteral(getSpecifierForModuleSymbol(resolvedModule, context))), 0);
                        }
                    }
                }
                if (needsPostExportDefault) {
                    addResult(factory.createExportAssignment(void 0, false, factory.createIdentifier(getInternalSymbolName(symbol, symbolName2))), 0);
                } else if (needsExportDeclaration) {
                    addResult(factory.createExportDeclaration(void 0, false, factory.createNamedExports([factory.createExportSpecifier(false, getInternalSymbolName(symbol, symbolName2), symbolName2)])), 0);
                }
            }
            function includePrivateSymbol(symbol) {
                if (some(symbol.declarations, isParameterDeclaration)) return;
                Debug.assertIsDefined(deferredPrivatesStack[deferredPrivatesStack.length - 1]);
                getUnusedName(unescapeLeadingUnderscores(symbol.escapedName), symbol);
                const isExternalImportAlias = !!(symbol.flags & 2097152) && !some(symbol.declarations, d => !!findAncestor(d, isExportDeclaration) || isNamespaceExport(d) || isImportEqualsDeclaration(d) && !isExternalModuleReference(d.moduleReference));
                deferredPrivatesStack[isExternalImportAlias ? 0 : deferredPrivatesStack.length - 1].set(getSymbolId(symbol), symbol);
            }
            function isExportingScope(enclosingDeclaration2) {
                return isSourceFile(enclosingDeclaration2) && (isExternalOrCommonJsModule(enclosingDeclaration2) || isJsonSourceFile(enclosingDeclaration2)) || isAmbientModule(enclosingDeclaration2) && !isGlobalScopeAugmentation(enclosingDeclaration2);
            }
            function addResult(node, additionalModifierFlags) {
                if (canHaveModifiers(node)) {
                    let newModifierFlags = 0;
                    const enclosingDeclaration2 = context.enclosingDeclaration && (isJSDocTypeAlias(context.enclosingDeclaration) ? getSourceFileOfNode(context.enclosingDeclaration) : context.enclosingDeclaration);
                    if (additionalModifierFlags & 1 && enclosingDeclaration2 && (isExportingScope(enclosingDeclaration2) || isModuleDeclaration(enclosingDeclaration2)) && canHaveExportModifier(node)) {
                        newModifierFlags |= 1;
                    }
                    if (addingDeclare && !(newModifierFlags & 1) && (!enclosingDeclaration2 || !(enclosingDeclaration2.flags & 16777216)) && (isEnumDeclaration(node) || isVariableStatement(node) || isFunctionDeclaration(node) || isClassDeclaration(node) || isModuleDeclaration(node))) {
                        newModifierFlags |= 2;
                    }
                    if (additionalModifierFlags & 1024 && (isClassDeclaration(node) || isInterfaceDeclaration(node) || isFunctionDeclaration(node))) {
                        newModifierFlags |= 1024;
                    }
                    if (newModifierFlags) {
                        node = factory.updateModifiers(node, newModifierFlags | getEffectiveModifierFlags(node));
                    }
                }
                results.push(node);
            }
            function serializeTypeAlias(symbol, symbolName2, modifierFlags) {
                var _a2;
                const aliasType = getDeclaredTypeOfTypeAlias(symbol);
                const typeParams = getSymbolLinks(symbol).typeParameters;
                const typeParamDecls = map(typeParams, p => typeParameterToDeclaration(p, context));
                const jsdocAliasDecl = (_a2 = symbol.declarations) == null ? void 0 : _a2.find(isJSDocTypeAlias);
                const commentText = getTextOfJSDocComment(jsdocAliasDecl ? jsdocAliasDecl.comment || jsdocAliasDecl.parent.comment : void 0);
                const oldFlags = context.flags;
                context.flags |= 8388608;
                const oldEnclosingDecl = context.enclosingDeclaration;
                context.enclosingDeclaration = jsdocAliasDecl;
                const typeNode = jsdocAliasDecl && jsdocAliasDecl.typeExpression && isJSDocTypeExpression(jsdocAliasDecl.typeExpression) && serializeExistingTypeNode(context, jsdocAliasDecl.typeExpression.type, includePrivateSymbol, bundled) || typeToTypeNodeHelper(aliasType, context);
                addResult(setSyntheticLeadingComments(factory.createTypeAliasDeclaration(void 0, getInternalSymbolName(symbol, symbolName2), typeParamDecls, typeNode), !commentText ? [] : [{
                    kind: 3,
                    text: "*\n * " + commentText.replace(/\n/g, "\n * ") + "\n ",
                    pos: -1,
                    end: -1,
                    hasTrailingNewLine: true
                }]), modifierFlags);
                context.flags = oldFlags;
                context.enclosingDeclaration = oldEnclosingDecl;
            }
            function serializeInterface(symbol, symbolName2, modifierFlags) {
                const interfaceType = getDeclaredTypeOfClassOrInterface(symbol);
                const localParams = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
                const typeParamDecls = map(localParams, p => typeParameterToDeclaration(p, context));
                const baseTypes = getBaseTypes(interfaceType);
                const baseType = length(baseTypes) ? getIntersectionType(baseTypes) : void 0;
                const members = flatMap(getPropertiesOfType(interfaceType), p => serializePropertySymbolForInterface(p, baseType));
                const callSignatures = serializeSignatures(0, interfaceType, baseType, 176);
                const constructSignatures = serializeSignatures(1, interfaceType, baseType, 177);
                const indexSignatures = serializeIndexSignatures(interfaceType, baseType);
                const heritageClauses = !length(baseTypes) ? void 0 : [factory.createHeritageClause(94, mapDefined(baseTypes, b => trySerializeAsTypeReference(b, 111551)))];
                addResult(factory.createInterfaceDeclaration(void 0, getInternalSymbolName(symbol, symbolName2), typeParamDecls, heritageClauses, [...indexSignatures, ...constructSignatures, ...callSignatures, ...members]), modifierFlags);
            }
            function getNamespaceMembersForSerialization(symbol) {
                return !symbol.exports ? [] : filter(arrayFrom(symbol.exports.values()), isNamespaceMember);
            }
            function isTypeOnlyNamespace(symbol) {
                return every(getNamespaceMembersForSerialization(symbol), m => !(getAllSymbolFlags(resolveSymbol(m)) & 111551));
            }
            function serializeModule(symbol, symbolName2, modifierFlags) {
                const members = getNamespaceMembersForSerialization(symbol);
                const locationMap = arrayToMultiMap(members, m => m.parent && m.parent === symbol ? "real" : "merged");
                const realMembers = locationMap.get("real") || emptyArray;
                const mergedMembers = locationMap.get("merged") || emptyArray;
                if (length(realMembers)) {
                    const localName = getInternalSymbolName(symbol, symbolName2);
                    serializeAsNamespaceDeclaration(realMembers, localName, modifierFlags, !!(symbol.flags & (16 | 67108864)));
                }
                if (length(mergedMembers)) {
                    const containingFile = getSourceFileOfNode(context.enclosingDeclaration);
                    const localName = getInternalSymbolName(symbol, symbolName2);
                    const nsBody = factory.createModuleBlock([factory.createExportDeclaration(void 0, false, factory.createNamedExports(mapDefined(filter(mergedMembers, n => n.escapedName !== "export="), s => {
                        var _a2, _b;
                        const name = unescapeLeadingUnderscores(s.escapedName);
                        const localName2 = getInternalSymbolName(s, name);
                        const aliasDecl = s.declarations && getDeclarationOfAliasSymbol(s);
                        if (containingFile && (aliasDecl ? containingFile !== getSourceFileOfNode(aliasDecl) : !some(s.declarations, d => getSourceFileOfNode(d) === containingFile))) {
                            (_b = (_a2 = context.tracker) == null ? void 0 : _a2.reportNonlocalAugmentation) == null ? void 0 : _b.call(_a2, containingFile, symbol, s);
                            return void 0;
                        }
                        const target = aliasDecl && getTargetOfAliasDeclaration(aliasDecl, true);
                        includePrivateSymbol(target || s);
                        const targetName = target ? getInternalSymbolName(target, unescapeLeadingUnderscores(target.escapedName)) : localName2;
                        return factory.createExportSpecifier(false, name === targetName ? void 0 : targetName, name);
                    })))]);
                    addResult(factory.createModuleDeclaration(void 0, factory.createIdentifier(localName), nsBody, 16), 0);
                }
            }
            function serializeEnum(symbol, symbolName2, modifierFlags) {
                addResult(factory.createEnumDeclaration(factory.createModifiersFromModifierFlags(isConstEnumSymbol(symbol) ? 2048 : 0), getInternalSymbolName(symbol, symbolName2), map(filter(getPropertiesOfType(getTypeOfSymbol(symbol)), p => !!(p.flags & 8)), p => {
                    const initializedValue = p.declarations && p.declarations[0] && isEnumMember(p.declarations[0]) ? getConstantValue2(p.declarations[0]) : void 0;
                    return factory.createEnumMember(unescapeLeadingUnderscores(p.escapedName), initializedValue === void 0 ? void 0 : typeof initializedValue === "string" ? factory.createStringLiteral(initializedValue) : factory.createNumericLiteral(initializedValue));
                })), modifierFlags);
            }
            function serializeAsFunctionNamespaceMerge(type, symbol, localName, modifierFlags) {
                const signatures = getSignaturesOfType(type, 0);
                for (const sig of signatures) {
                    const decl = signatureToSignatureDeclarationHelper(sig, 259, context, {
                        name: factory.createIdentifier(localName),
                        privateSymbolVisitor: includePrivateSymbol,
                        bundledImports: bundled
                    });
                    addResult(setTextRange(decl, getSignatureTextRangeLocation(sig)), modifierFlags);
                }
                if (!(symbol.flags & (512 | 1024) && !!symbol.exports && !!symbol.exports.size)) {
                    const props = filter(getPropertiesOfType(type), isNamespaceMember);
                    serializeAsNamespaceDeclaration(props, localName, modifierFlags, true);
                }
            }
            function getSignatureTextRangeLocation(signature) {
                if (signature.declaration && signature.declaration.parent) {
                    if (isBinaryExpression(signature.declaration.parent) && getAssignmentDeclarationKind(signature.declaration.parent) === 5) {
                        return signature.declaration.parent;
                    }
                    if (isVariableDeclaration(signature.declaration.parent) && signature.declaration.parent.parent) {
                        return signature.declaration.parent.parent;
                    }
                }
                return signature.declaration;
            }
            function serializeAsNamespaceDeclaration(props, localName, modifierFlags, suppressNewPrivateContext) {
                if (length(props)) {
                    const localVsRemoteMap = arrayToMultiMap(props, p => !length(p.declarations) || some(p.declarations, d => getSourceFileOfNode(d) === getSourceFileOfNode(context.enclosingDeclaration)) ? "local" : "remote");
                    const localProps = localVsRemoteMap.get("local") || emptyArray;
                    let fakespace = parseNodeFactory.createModuleDeclaration(void 0, factory.createIdentifier(localName), factory.createModuleBlock([]), 16);
                    setParent(fakespace, enclosingDeclaration);
                    fakespace.locals = createSymbolTable(props);
                    fakespace.symbol = props[0].parent;
                    const oldResults = results;
                    results = [];
                    const oldAddingDeclare = addingDeclare;
                    addingDeclare = false;
                    const subcontext = {
                        ...context,
                        enclosingDeclaration: fakespace
                    };
                    const oldContext = context;
                    context = subcontext;
                    visitSymbolTable(createSymbolTable(localProps), suppressNewPrivateContext, true);
                    context = oldContext;
                    addingDeclare = oldAddingDeclare;
                    const declarations = results;
                    results = oldResults;
                    const defaultReplaced = map(declarations, d => isExportAssignment(d) && !d.isExportEquals && isIdentifier(d.expression) ? factory.createExportDeclaration(void 0, false, factory.createNamedExports([factory.createExportSpecifier(false, d.expression, factory.createIdentifier("default"))])) : d);
                    const exportModifierStripped = every(defaultReplaced, d => hasSyntacticModifier(d, 1)) ? map(defaultReplaced, removeExportModifier) : defaultReplaced;
                    fakespace = factory.updateModuleDeclaration(fakespace, fakespace.modifiers, fakespace.name, factory.createModuleBlock(exportModifierStripped));
                    addResult(fakespace, modifierFlags);
                }
            }
            function isNamespaceMember(p) {
                return !!(p.flags & (788968 | 1920 | 2097152)) || !(p.flags & 4194304 || p.escapedName === "prototype" || p.valueDeclaration && isStatic(p.valueDeclaration) && isClassLike(p.valueDeclaration.parent));
            }
            function sanitizeJSDocImplements(clauses) {
                const result = mapDefined(clauses, e => {
                    const oldEnclosing = context.enclosingDeclaration;
                    context.enclosingDeclaration = e;
                    let expr = e.expression;
                    if (isEntityNameExpression(expr)) {
                        if (isIdentifier(expr) && idText(expr) === "") {
                            return cleanup(void 0);
                        }
                        let introducesError;
                        ({
                            introducesError,
                            node: expr
                        } = trackExistingEntityName(expr, context, includePrivateSymbol));
                        if (introducesError) {
                            return cleanup(void 0);
                        }
                    }
                    return cleanup(factory.createExpressionWithTypeArguments(expr, map(e.typeArguments, a => serializeExistingTypeNode(context, a, includePrivateSymbol, bundled) || typeToTypeNodeHelper(getTypeFromTypeNode(a), context))));
                    function cleanup(result2) {
                        context.enclosingDeclaration = oldEnclosing;
                        return result2;
                    }
                });
                if (result.length === clauses.length) {
                    return result;
                }
                return void 0;
            }
            function serializeAsClass(symbol, localName, modifierFlags) {
                var _a2, _b;
                const originalDecl = (_a2 = symbol.declarations) == null ? void 0 : _a2.find(isClassLike);
                const oldEnclosing = context.enclosingDeclaration;
                context.enclosingDeclaration = originalDecl || oldEnclosing;
                const localParams = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
                const typeParamDecls = map(localParams, p => typeParameterToDeclaration(p, context));
                const classType = getDeclaredTypeOfClassOrInterface(symbol);
                const baseTypes = getBaseTypes(classType);
                const originalImplements = originalDecl && getEffectiveImplementsTypeNodes(originalDecl);
                const implementsExpressions = originalImplements && sanitizeJSDocImplements(originalImplements) || mapDefined(getImplementsTypes(classType), serializeImplementedType);
                const staticType = getTypeOfSymbol(symbol);
                const isClass = !!((_b = staticType.symbol) == null ? void 0 : _b.valueDeclaration) && isClassLike(staticType.symbol.valueDeclaration);
                const staticBaseType = isClass ? getBaseConstructorTypeOfClass(staticType) : anyType;
                const heritageClauses = [...(!length(baseTypes) ? [] : [factory.createHeritageClause(94, map(baseTypes, b => serializeBaseType(b, staticBaseType, localName)))]), ...(!length(implementsExpressions) ? [] : [factory.createHeritageClause(117, implementsExpressions)])];
                const symbolProps = getNonInheritedProperties(classType, baseTypes, getPropertiesOfType(classType));
                const publicSymbolProps = filter(symbolProps, s => {
                    const valueDecl = s.valueDeclaration;
                    return !!valueDecl && !(isNamedDeclaration(valueDecl) && isPrivateIdentifier(valueDecl.name));
                });
                const hasPrivateIdentifier = some(symbolProps, s => {
                    const valueDecl = s.valueDeclaration;
                    return !!valueDecl && isNamedDeclaration(valueDecl) && isPrivateIdentifier(valueDecl.name);
                });
                const privateProperties = hasPrivateIdentifier ? [factory.createPropertyDeclaration(void 0, factory.createPrivateIdentifier("#private"), void 0, void 0, void 0)] : emptyArray;
                const publicProperties = flatMap(publicSymbolProps, p => serializePropertySymbolForClass(p, false, baseTypes[0]));
                const staticMembers = flatMap(filter(getPropertiesOfType(staticType), p => !(p.flags & 4194304) && p.escapedName !== "prototype" && !isNamespaceMember(p)), p => serializePropertySymbolForClass(p, true, staticBaseType));
                const isNonConstructableClassLikeInJsFile = !isClass && !!symbol.valueDeclaration && isInJSFile(symbol.valueDeclaration) && !some(getSignaturesOfType(staticType, 1));
                const constructors = isNonConstructableClassLikeInJsFile ? [factory.createConstructorDeclaration(factory.createModifiersFromModifierFlags(8), [], void 0)] : serializeSignatures(1, staticType, staticBaseType, 173);
                const indexSignatures = serializeIndexSignatures(classType, baseTypes[0]);
                context.enclosingDeclaration = oldEnclosing;
                addResult(setTextRange(factory.createClassDeclaration(void 0, localName, typeParamDecls, heritageClauses, [...indexSignatures, ...staticMembers, ...constructors, ...publicProperties, ...privateProperties]), symbol.declarations && filter(symbol.declarations, d => isClassDeclaration(d) || isClassExpression(d))[0]), modifierFlags);
            }
            function getSomeTargetNameFromDeclarations(declarations) {
                return firstDefined(declarations, d => {
                    if (isImportSpecifier(d) || isExportSpecifier(d)) {
                        return idText(d.propertyName || d.name);
                    }
                    if (isBinaryExpression(d) || isExportAssignment(d)) {
                        const expression = isExportAssignment(d) ? d.expression : d.right;
                        if (isPropertyAccessExpression(expression)) {
                            return idText(expression.name);
                        }
                    }
                    if (isAliasSymbolDeclaration2(d)) {
                        const name = getNameOfDeclaration(d);
                        if (name && isIdentifier(name)) {
                            return idText(name);
                        }
                    }
                    return void 0;
                });
            }
            function serializeAsAlias(symbol, localName, modifierFlags) {
                var _a2, _b, _c, _d, _e;
                const node = getDeclarationOfAliasSymbol(symbol);
                if (!node) return Debug.fail();
                const target = getMergedSymbol(getTargetOfAliasDeclaration(node, true));
                if (!target) {
                    return;
                }
                let verbatimTargetName = isShorthandAmbientModuleSymbol(target) && getSomeTargetNameFromDeclarations(symbol.declarations) || unescapeLeadingUnderscores(target.escapedName);
                if (verbatimTargetName === "export=" && (getESModuleInterop(compilerOptions) || compilerOptions.allowSyntheticDefaultImports)) {
                    verbatimTargetName = "default";
                }
                const targetName = getInternalSymbolName(target, verbatimTargetName);
                includePrivateSymbol(target);
                switch (node.kind) {
                    case 205:
                        if (((_b = (_a2 = node.parent) == null ? void 0 : _a2.parent) == null ? void 0 : _b.kind) === 257) {
                            const specifier2 = getSpecifierForModuleSymbol(target.parent || target, context);
                            const {
                                propertyName
                            } = node;
                            addResult(factory.createImportDeclaration(void 0, factory.createImportClause(false, void 0, factory.createNamedImports([factory.createImportSpecifier(false, propertyName && isIdentifier(propertyName) ? factory.createIdentifier(idText(propertyName)) : void 0, factory.createIdentifier(localName))])), factory.createStringLiteral(specifier2), void 0), 0);
                            break;
                        }
                        Debug.failBadSyntaxKind(((_c = node.parent) == null ? void 0 : _c.parent) || node, "Unhandled binding element grandparent kind in declaration serialization");
                        break;
                    case 300:
                        if (((_e = (_d = node.parent) == null ? void 0 : _d.parent) == null ? void 0 : _e.kind) === 223) {
                            serializeExportSpecifier(unescapeLeadingUnderscores(symbol.escapedName), targetName);
                        }
                        break;
                    case 257:
                        if (isPropertyAccessExpression(node.initializer)) {
                            const initializer = node.initializer;
                            const uniqueName = factory.createUniqueName(localName);
                            const specifier2 = getSpecifierForModuleSymbol(target.parent || target, context);
                            addResult(factory.createImportEqualsDeclaration(void 0, false, uniqueName, factory.createExternalModuleReference(factory.createStringLiteral(specifier2))), 0);
                            addResult(factory.createImportEqualsDeclaration(void 0, false, factory.createIdentifier(localName), factory.createQualifiedName(uniqueName, initializer.name)), modifierFlags);
                            break;
                        }
                    case 268:
                        if (target.escapedName === "export=" && some(target.declarations, d => isSourceFile(d) && isJsonSourceFile(d))) {
                            serializeMaybeAliasAssignment(symbol);
                            break;
                        }
                        const isLocalImport = !(target.flags & 512) && !isVariableDeclaration(node);
                        addResult(factory.createImportEqualsDeclaration(void 0, false, factory.createIdentifier(localName), isLocalImport ? symbolToName(target, context, 67108863, false) : factory.createExternalModuleReference(factory.createStringLiteral(getSpecifierForModuleSymbol(target, context)))), isLocalImport ? modifierFlags : 0);
                        break;
                    case 267:
                        addResult(factory.createNamespaceExportDeclaration(idText(node.name)), 0);
                        break;
                    case 270:
                        {
                            const generatedSpecifier = getSpecifierForModuleSymbol(target.parent || target, context);
                            const specifier2 = bundled ? factory.createStringLiteral(generatedSpecifier) : node.parent.moduleSpecifier;
                            addResult(factory.createImportDeclaration(void 0, factory.createImportClause(false, factory.createIdentifier(localName), void 0), specifier2, node.parent.assertClause), 0);
                            break;
                        }
                    case 271:
                        {
                            const generatedSpecifier = getSpecifierForModuleSymbol(target.parent || target, context);
                            const specifier2 = bundled ? factory.createStringLiteral(generatedSpecifier) : node.parent.parent.moduleSpecifier;
                            addResult(factory.createImportDeclaration(void 0, factory.createImportClause(false, void 0, factory.createNamespaceImport(factory.createIdentifier(localName))), specifier2, node.parent.parent.assertClause), 0);
                            break;
                        }
                    case 277:
                        addResult(factory.createExportDeclaration(void 0, false, factory.createNamespaceExport(factory.createIdentifier(localName)), factory.createStringLiteral(getSpecifierForModuleSymbol(target, context))), 0);
                        break;
                    case 273:
                        {
                            const generatedSpecifier = getSpecifierForModuleSymbol(target.parent || target, context);
                            const specifier2 = bundled ? factory.createStringLiteral(generatedSpecifier) : node.parent.parent.parent.moduleSpecifier;
                            addResult(factory.createImportDeclaration(void 0, factory.createImportClause(false, void 0, factory.createNamedImports([factory.createImportSpecifier(false, localName !== verbatimTargetName ? factory.createIdentifier(verbatimTargetName) : void 0, factory.createIdentifier(localName))])), specifier2, node.parent.parent.parent.assertClause), 0);
                            break;
                        }
                    case 278:
                        const specifier = node.parent.parent.moduleSpecifier;
                        serializeExportSpecifier(unescapeLeadingUnderscores(symbol.escapedName), specifier ? verbatimTargetName : targetName, specifier && isStringLiteralLike(specifier) ? factory.createStringLiteral(specifier.text) : void 0);
                        break;
                    case 274:
                        serializeMaybeAliasAssignment(symbol);
                        break;
                    case 223:
                    case 208:
                    case 209:
                        if (symbol.escapedName === "default" || symbol.escapedName === "export=") {
                            serializeMaybeAliasAssignment(symbol);
                        } else {
                            serializeExportSpecifier(localName, targetName);
                        }
                        break;
                    default:
                        return Debug.failBadSyntaxKind(node, "Unhandled alias declaration kind in symbol serializer!");
                }
            }
            function serializeExportSpecifier(localName, targetName, specifier) {
                addResult(factory.createExportDeclaration(void 0, false, factory.createNamedExports([factory.createExportSpecifier(false, localName !== targetName ? targetName : void 0, localName)]), specifier), 0);
            }
            function serializeMaybeAliasAssignment(symbol) {
                if (symbol.flags & 4194304) {
                    return false;
                }
                const name = unescapeLeadingUnderscores(symbol.escapedName);
                const isExportEquals = name === "export=";
                const isDefault = name === "default";
                const isExportAssignmentCompatibleSymbolName = isExportEquals || isDefault;
                const aliasDecl = symbol.declarations && getDeclarationOfAliasSymbol(symbol);
                const target = aliasDecl && getTargetOfAliasDeclaration(aliasDecl, true);
                if (target && length(target.declarations) && some(target.declarations, d => getSourceFileOfNode(d) === getSourceFileOfNode(enclosingDeclaration))) {
                    const expr = aliasDecl && (isExportAssignment(aliasDecl) || isBinaryExpression(aliasDecl) ? getExportAssignmentExpression(aliasDecl) : getPropertyAssignmentAliasLikeExpression(aliasDecl));
                    const first2 = expr && isEntityNameExpression(expr) ? getFirstNonModuleExportsIdentifier(expr) : void 0;
                    const referenced = first2 && resolveEntityName(first2, 67108863, true, true, enclosingDeclaration);
                    if (referenced || target) {
                        includePrivateSymbol(referenced || target);
                    }
                    const prevDisableTrackSymbol = context.tracker.disableTrackSymbol;
                    context.tracker.disableTrackSymbol = true;
                    if (isExportAssignmentCompatibleSymbolName) {
                        results.push(factory.createExportAssignment(void 0, isExportEquals, symbolToExpression(target, context, 67108863)));
                    } else {
                        if (first2 === expr && first2) {
                            serializeExportSpecifier(name, idText(first2));
                        } else if (expr && isClassExpression(expr)) {
                            serializeExportSpecifier(name, getInternalSymbolName(target, symbolName(target)));
                        } else {
                            const varName = getUnusedName(name, symbol);
                            addResult(factory.createImportEqualsDeclaration(void 0, false, factory.createIdentifier(varName), symbolToName(target, context, 67108863, false)), 0);
                            serializeExportSpecifier(name, varName);
                        }
                    }
                    context.tracker.disableTrackSymbol = prevDisableTrackSymbol;
                    return true;
                } else {
                    const varName = getUnusedName(name, symbol);
                    const typeToSerialize = getWidenedType(getTypeOfSymbol(getMergedSymbol(symbol)));
                    if (isTypeRepresentableAsFunctionNamespaceMerge(typeToSerialize, symbol)) {
                        serializeAsFunctionNamespaceMerge(typeToSerialize, symbol, varName, isExportAssignmentCompatibleSymbolName ? 0 : 1);
                    } else {
                        const statement = factory.createVariableStatement(void 0, factory.createVariableDeclarationList([factory.createVariableDeclaration(varName, void 0, serializeTypeForDeclaration(context, typeToSerialize, symbol, enclosingDeclaration, includePrivateSymbol, bundled))], 2));
                        addResult(statement, target && target.flags & 4 && target.escapedName === "export=" ? 2 : name === varName ? 1 : 0);
                    }
                    if (isExportAssignmentCompatibleSymbolName) {
                        results.push(factory.createExportAssignment(void 0, isExportEquals, factory.createIdentifier(varName)));
                        return true;
                    } else if (name !== varName) {
                        serializeExportSpecifier(name, varName);
                        return true;
                    }
                    return false;
                }
            }
            function isTypeRepresentableAsFunctionNamespaceMerge(typeToSerialize, hostSymbol) {
                const ctxSrc = getSourceFileOfNode(context.enclosingDeclaration);
                return getObjectFlags(typeToSerialize) & (16 | 32) && !length(getIndexInfosOfType(typeToSerialize)) && !isClassInstanceSide(typeToSerialize) && !!(length(filter(getPropertiesOfType(typeToSerialize), isNamespaceMember)) || length(getSignaturesOfType(typeToSerialize, 0))) && !length(getSignaturesOfType(typeToSerialize, 1)) && !getDeclarationWithTypeAnnotation(hostSymbol, enclosingDeclaration) && !(typeToSerialize.symbol && some(typeToSerialize.symbol.declarations, d => getSourceFileOfNode(d) !== ctxSrc)) && !some(getPropertiesOfType(typeToSerialize), p => isLateBoundName(p.escapedName)) && !some(getPropertiesOfType(typeToSerialize), p => some(p.declarations, d => getSourceFileOfNode(d) !== ctxSrc)) && every(getPropertiesOfType(typeToSerialize), p => isIdentifierText(symbolName(p), languageVersion));
            }
            function makeSerializePropertySymbol(createProperty2, methodKind, useAccessors) {
                return function serializePropertySymbol(p, isStatic2, baseType) {
                    var _a2, _b, _c, _d, _e;
                    const modifierFlags = getDeclarationModifierFlagsFromSymbol(p);
                    const isPrivate = !!(modifierFlags & 8);
                    if (isStatic2 && p.flags & (788968 | 1920 | 2097152)) {
                        return [];
                    }
                    if (p.flags & 4194304 || baseType && getPropertyOfType(baseType, p.escapedName) && isReadonlySymbol(getPropertyOfType(baseType, p.escapedName)) === isReadonlySymbol(p) && (p.flags & 16777216) === (getPropertyOfType(baseType, p.escapedName).flags & 16777216) && isTypeIdenticalTo(getTypeOfSymbol(p), getTypeOfPropertyOfType(baseType, p.escapedName))) {
                        return [];
                    }
                    const flag = modifierFlags & ~512 | (isStatic2 ? 32 : 0);
                    const name = getPropertyNameNodeForSymbol(p, context);
                    const firstPropertyLikeDecl = (_a2 = p.declarations) == null ? void 0 : _a2.find(or(isPropertyDeclaration, isAccessor, isVariableDeclaration, isPropertySignature, isBinaryExpression, isPropertyAccessExpression));
                    if (p.flags & 98304 && useAccessors) {
                        const result = [];
                        if (p.flags & 65536) {
                            result.push(setTextRange(factory.createSetAccessorDeclaration(factory.createModifiersFromModifierFlags(flag), name, [factory.createParameterDeclaration(void 0, void 0, "arg", void 0, isPrivate ? void 0 : serializeTypeForDeclaration(context, getTypeOfSymbol(p), p, enclosingDeclaration, includePrivateSymbol, bundled))], void 0), ((_b = p.declarations) == null ? void 0 : _b.find(isSetAccessor)) || firstPropertyLikeDecl));
                        }
                        if (p.flags & 32768) {
                            const isPrivate2 = modifierFlags & 8;
                            result.push(setTextRange(factory.createGetAccessorDeclaration(factory.createModifiersFromModifierFlags(flag), name, [], isPrivate2 ? void 0 : serializeTypeForDeclaration(context, getTypeOfSymbol(p), p, enclosingDeclaration, includePrivateSymbol, bundled), void 0), ((_c = p.declarations) == null ? void 0 : _c.find(isGetAccessor)) || firstPropertyLikeDecl));
                        }
                        return result;
                    } else if (p.flags & (4 | 3 | 98304)) {
                        return setTextRange(createProperty2(factory.createModifiersFromModifierFlags((isReadonlySymbol(p) ? 64 : 0) | flag), name, p.flags & 16777216 ? factory.createToken(57) : void 0, isPrivate ? void 0 : serializeTypeForDeclaration(context, getWriteTypeOfSymbol(p), p, enclosingDeclaration, includePrivateSymbol, bundled), void 0), ((_d = p.declarations) == null ? void 0 : _d.find(or(isPropertyDeclaration, isVariableDeclaration))) || firstPropertyLikeDecl);
                    }
                    if (p.flags & (8192 | 16)) {
                        const type = getTypeOfSymbol(p);
                        const signatures = getSignaturesOfType(type, 0);
                        if (flag & 8) {
                            return setTextRange(createProperty2(factory.createModifiersFromModifierFlags((isReadonlySymbol(p) ? 64 : 0) | flag), name, p.flags & 16777216 ? factory.createToken(57) : void 0, void 0, void 0), ((_e = p.declarations) == null ? void 0 : _e.find(isFunctionLikeDeclaration)) || signatures[0] && signatures[0].declaration || p.declarations && p.declarations[0]);
                        }
                        const results2 = [];
                        for (const sig of signatures) {
                            const decl = signatureToSignatureDeclarationHelper(sig, methodKind, context, {
                                name,
                                questionToken: p.flags & 16777216 ? factory.createToken(57) : void 0,
                                modifiers: flag ? factory.createModifiersFromModifierFlags(flag) : void 0
                            });
                            const location = sig.declaration && isPrototypePropertyAssignment(sig.declaration.parent) ? sig.declaration.parent : sig.declaration;
                            results2.push(setTextRange(decl, location));
                        }
                        return results2;
                    }
                    return Debug.fail(`Unhandled class member kind! ${p.__debugFlags || p.flags}`);
                };
            }
            function serializePropertySymbolForInterface(p, baseType) {
                return serializePropertySymbolForInterfaceWorker(p, false, baseType);
            }
            function serializeSignatures(kind, input, baseType, outputKind) {
                const signatures = getSignaturesOfType(input, kind);
                if (kind === 1) {
                    if (!baseType && every(signatures, s => length(s.parameters) === 0)) {
                        return [];
                    }
                    if (baseType) {
                        const baseSigs = getSignaturesOfType(baseType, 1);
                        if (!length(baseSigs) && every(signatures, s => length(s.parameters) === 0)) {
                            return [];
                        }
                        if (baseSigs.length === signatures.length) {
                            let failed = false;
                            for (let i = 0; i < baseSigs.length; i++) {
                                if (!compareSignaturesIdentical(signatures[i], baseSigs[i], false, false, true, compareTypesIdentical)) {
                                    failed = true;
                                    break;
                                }
                            }
                            if (!failed) {
                                return [];
                            }
                        }
                    }
                    let privateProtected = 0;
                    for (const s of signatures) {
                        if (s.declaration) {
                            privateProtected |= getSelectedEffectiveModifierFlags(s.declaration, 8 | 16);
                        }
                    }
                    if (privateProtected) {
                        return [setTextRange(factory.createConstructorDeclaration(factory.createModifiersFromModifierFlags(privateProtected), [], void 0), signatures[0].declaration)];
                    }
                }
                const results2 = [];
                for (const sig of signatures) {
                    const decl = signatureToSignatureDeclarationHelper(sig, outputKind, context);
                    results2.push(setTextRange(decl, sig.declaration));
                }
                return results2;
            }
            function serializeIndexSignatures(input, baseType) {
                const results2 = [];
                for (const info of getIndexInfosOfType(input)) {
                    if (baseType) {
                        const baseInfo = getIndexInfoOfType(baseType, info.keyType);
                        if (baseInfo) {
                            if (isTypeIdenticalTo(info.type, baseInfo.type)) {
                                continue;
                            }
                        }
                    }
                    results2.push(indexInfoToIndexSignatureDeclarationHelper(info, context, void 0));
                }
                return results2;
            }
            function serializeBaseType(t, staticType, rootName) {
                const ref = trySerializeAsTypeReference(t, 111551);
                if (ref) {
                    return ref;
                }
                const tempName = getUnusedName(`${rootName}_base`);
                const statement = factory.createVariableStatement(void 0, factory.createVariableDeclarationList([factory.createVariableDeclaration(tempName, void 0, typeToTypeNodeHelper(staticType, context))], 2));
                addResult(statement, 0);
                return factory.createExpressionWithTypeArguments(factory.createIdentifier(tempName), void 0);
            }
            function trySerializeAsTypeReference(t, flags) {
                let typeArgs;
                let reference;
                if (t.target && isSymbolAccessibleByFlags(t.target.symbol, enclosingDeclaration, flags)) {
                    typeArgs = map(getTypeArguments(t), t2 => typeToTypeNodeHelper(t2, context));
                    reference = symbolToExpression(t.target.symbol, context, 788968);
                } else if (t.symbol && isSymbolAccessibleByFlags(t.symbol, enclosingDeclaration, flags)) {
                    reference = symbolToExpression(t.symbol, context, 788968);
                }
                if (reference) {
                    return factory.createExpressionWithTypeArguments(reference, typeArgs);
                }
            }
            function serializeImplementedType(t) {
                const ref = trySerializeAsTypeReference(t, 788968);
                if (ref) {
                    return ref;
                }
                if (t.symbol) {
                    return factory.createExpressionWithTypeArguments(symbolToExpression(t.symbol, context, 788968), void 0);
                }
            }
            function getUnusedName(input, symbol) {
                var _a2, _b;
                const id = symbol ? getSymbolId(symbol) : void 0;
                if (id) {
                    if (context.remappedSymbolNames.has(id)) {
                        return context.remappedSymbolNames.get(id);
                    }
                }
                if (symbol) {
                    input = getNameCandidateWorker(symbol, input);
                }
                let i = 0;
                const original = input;
                while ((_a2 = context.usedSymbolNames) == null ? void 0 : _a2.has(input)) {
                    i++;
                    input = `${original}_${i}`;
                }
                (_b = context.usedSymbolNames) == null ? void 0 : _b.add(input);
                if (id) {
                    context.remappedSymbolNames.set(id, input);
                }
                return input;
            }
            function getNameCandidateWorker(symbol, localName) {
                if (localName === "default" || localName === "__class" || localName === "__function") {
                    const flags = context.flags;
                    context.flags |= 16777216;
                    const nameCandidate = getNameOfSymbolAsWritten(symbol, context);
                    context.flags = flags;
                    localName = nameCandidate.length > 0 && isSingleOrDoubleQuote(nameCandidate.charCodeAt(0)) ? stripQuotes(nameCandidate) : nameCandidate;
                }
                if (localName === "default") {
                    localName = "_default";
                } else if (localName === "export=") {
                    localName = "_exports";
                }
                localName = isIdentifierText(localName, languageVersion) && !isStringANonContextualKeyword(localName) ? localName : "_" + localName.replace(/[^a-zA-Z0-9]/g, "_");
                return localName;
            }
            function getInternalSymbolName(symbol, localName) {
                const id = getSymbolId(symbol);
                if (context.remappedSymbolNames.has(id)) {
                    return context.remappedSymbolNames.get(id);
                }
                localName = getNameCandidateWorker(symbol, localName);
                context.remappedSymbolNames.set(id, localName);
                return localName;
            }
        }
    }
    function typePredicateToString(typePredicate, enclosingDeclaration, flags = 16384, writer) {
        return writer ? typePredicateToStringWorker(writer).getText() : usingSingleLineStringWriter(typePredicateToStringWorker);
        function typePredicateToStringWorker(writer2) {
            const predicate = factory.createTypePredicateNode(typePredicate.kind === 2 || typePredicate.kind === 3 ? factory.createToken(129) : void 0, typePredicate.kind === 1 || typePredicate.kind === 3 ? factory.createIdentifier(typePredicate.parameterName) : factory.createThisTypeNode(), typePredicate.type && nodeBuilder.typeToTypeNode(typePredicate.type, enclosingDeclaration, toNodeBuilderFlags(flags) | 70221824 | 512));
            const printer = createPrinterWithRemoveComments();
            const sourceFile = enclosingDeclaration && getSourceFileOfNode(enclosingDeclaration);
            printer.writeNode(4, predicate, sourceFile, writer2);
            return writer2;
        }
    }
    function formatUnionTypes(types) {
        const result = [];
        let flags = 0;
        for (let i = 0; i < types.length; i++) {
            const t = types[i];
            flags |= t.flags;
            if (!(t.flags & 98304)) {
                if (t.flags & (512 | 1056)) {
                    const baseType = t.flags & 512 ? booleanType : getBaseTypeOfEnumLikeType(t);
                    if (baseType.flags & 1048576) {
                        const count = baseType.types.length;
                        if (i + count <= types.length && getRegularTypeOfLiteralType(types[i + count - 1]) === getRegularTypeOfLiteralType(baseType.types[count - 1])) {
                            result.push(baseType);
                            i += count - 1;
                            continue;
                        }
                    }
                }
                result.push(t);
            }
        }
        if (flags & 65536) result.push(nullType);
        if (flags & 32768) result.push(undefinedType);
        return result || types;
    }
    function visibilityToString(flags) {
        if (flags === 8) {
            return "private";
        }
        if (flags === 16) {
            return "protected";
        }
        return "public";
    }
    function getTypeAliasForTypeLiteral(type) {
        if (type.symbol && type.symbol.flags & 2048 && type.symbol.declarations) {
            const node = walkUpParenthesizedTypes(type.symbol.declarations[0].parent);
            if (isTypeAliasDeclaration(node)) {
                return getSymbolOfDeclaration(node);
            }
        }
        return void 0;
    }
    function isTopLevelInExternalModuleAugmentation(node) {
        return node && node.parent && node.parent.kind === 265 && isExternalModuleAugmentation(node.parent.parent);
    }
    function isDefaultBindingContext(location) {
        return location.kind === 308 || isAmbientModule(location);
    }
    function getNameOfSymbolFromNameType(symbol, context) {
        const nameType = getSymbolLinks(symbol).nameType;
        if (nameType) {
            if (nameType.flags & 384) {
                const name = "" + nameType.value;
                if (!isIdentifierText(name, getEmitScriptTarget(compilerOptions)) && !isNumericLiteralName(name)) {
                    return `"${escapeString(name, 34)}"`;
                }
                if (isNumericLiteralName(name) && startsWith(name, "-")) {
                    return `[${name}]`;
                }
                return name;
            }
            if (nameType.flags & 8192) {
                return `[${getNameOfSymbolAsWritten(nameType.symbol, context)}]`;
            }
        }
    }
    function getNameOfSymbolAsWritten(symbol, context) {
        if (context && symbol.escapedName === "default" && !(context.flags & 16384) && (!(context.flags & 16777216) || !symbol.declarations || context.enclosingDeclaration && findAncestor(symbol.declarations[0], isDefaultBindingContext) !== findAncestor(context.enclosingDeclaration, isDefaultBindingContext))) {
            return "default";
        }
        if (symbol.declarations && symbol.declarations.length) {
            let declaration = firstDefined(symbol.declarations, d => getNameOfDeclaration(d) ? d : void 0);
            const name2 = declaration && getNameOfDeclaration(declaration);
            if (declaration && name2) {
                if (isCallExpression(declaration) && isBindableObjectDefinePropertyCall(declaration)) {
                    return symbolName(symbol);
                }
                if (isComputedPropertyName(name2) && !(getCheckFlags(symbol) & 4096)) {
                    const nameType = getSymbolLinks(symbol).nameType;
                    if (nameType && nameType.flags & 384) {
                        const result = getNameOfSymbolFromNameType(symbol, context);
                        if (result !== void 0) {
                            return result;
                        }
                    }
                }
                return declarationNameToString(name2);
            }
            if (!declaration) {
                declaration = symbol.declarations[0];
            }
            if (declaration.parent && declaration.parent.kind === 257) {
                return declarationNameToString(declaration.parent.name);
            }
            switch (declaration.kind) {
                case 228:
                case 215:
                case 216:
                    if (context && !context.encounteredError && !(context.flags & 131072)) {
                        context.encounteredError = true;
                    }
                    return declaration.kind === 228 ? "(Anonymous class)" : "(Anonymous function)";
            }
        }
        const name = getNameOfSymbolFromNameType(symbol, context);
        return name !== void 0 ? name : symbolName(symbol);
    }
    function isDeclarationVisible(node) {
        if (node) {
            const links = getNodeLinks(node);
            if (links.isVisible === void 0) {
                links.isVisible = !!determineIfDeclarationIsVisible();
            }
            return links.isVisible;
        }
        return false;
        function determineIfDeclarationIsVisible() {
            switch (node.kind) {
                case 341:
                case 349:
                case 343:
                    return !!(node.parent && node.parent.parent && node.parent.parent.parent && isSourceFile(node.parent.parent.parent));
                case 205:
                    return isDeclarationVisible(node.parent.parent);
                case 257:
                    if (isBindingPattern(node.name) && !node.name.elements.length) {
                        return false;
                    }
                case 264:
                case 260:
                case 261:
                case 262:
                case 259:
                case 263:
                case 268:
                    if (isExternalModuleAugmentation(node)) {
                        return true;
                    }
                    const parent2 = getDeclarationContainer(node);
                    if (!(getCombinedModifierFlags(node) & 1) && !(node.kind !== 268 && parent2.kind !== 308 && parent2.flags & 16777216)) {
                        return isGlobalSourceFile(parent2);
                    }
                    return isDeclarationVisible(parent2);
                case 169:
                case 168:
                case 174:
                case 175:
                case 171:
                case 170:
                    if (hasEffectiveModifier(node, 8 | 16)) {
                        return false;
                    }
                case 173:
                case 177:
                case 176:
                case 178:
                case 166:
                case 265:
                case 181:
                case 182:
                case 184:
                case 180:
                case 185:
                case 186:
                case 189:
                case 190:
                case 193:
                case 199:
                    return isDeclarationVisible(node.parent);
                case 270:
                case 271:
                case 273:
                    return false;
                case 165:
                case 308:
                case 267:
                    return true;
                case 274:
                    return false;
                default:
                    return false;
            }
        }
    }
    function collectLinkedAliases(node, setVisibility) {
        let exportSymbol;
        if (node.parent && node.parent.kind === 274) {
            exportSymbol = resolveName(node, node.escapedText, 111551 | 788968 | 1920 | 2097152, void 0, node, false);
        } else if (node.parent.kind === 278) {
            exportSymbol = getTargetOfExportSpecifier(node.parent, 111551 | 788968 | 1920 | 2097152);
        }
        let result;
        let visited;
        if (exportSymbol) {
            visited = /* @__PURE__ */new Set();
            visited.add(getSymbolId(exportSymbol));
            buildVisibleNodeList(exportSymbol.declarations);
        }
        return result;
        function buildVisibleNodeList(declarations) {
            forEach(declarations, declaration => {
                const resultNode = getAnyImportSyntax(declaration) || declaration;
                if (setVisibility) {
                    getNodeLinks(declaration).isVisible = true;
                } else {
                    result = result || [];
                    pushIfUnique(result, resultNode);
                }
                if (isInternalModuleImportEqualsDeclaration(declaration)) {
                    const internalModuleReference = declaration.moduleReference;
                    const firstIdentifier = getFirstIdentifier(internalModuleReference);
                    const importSymbol = resolveName(declaration, firstIdentifier.escapedText, 111551 | 788968 | 1920, void 0, void 0, false);
                    if (importSymbol && visited) {
                        if (tryAddToSet(visited, getSymbolId(importSymbol))) {
                            buildVisibleNodeList(importSymbol.declarations);
                        }
                    }
                }
            });
        }
    }
    function pushTypeResolution(target, propertyName) {
        const resolutionCycleStartIndex = findResolutionCycleStartIndex(target, propertyName);
        if (resolutionCycleStartIndex >= 0) {
            const {
                length: length2
            } = resolutionTargets;
            for (let i = resolutionCycleStartIndex; i < length2; i++) {
                resolutionResults[i] = false;
            }
            return false;
        }
        resolutionTargets.push(target);
        resolutionResults.push(true);
        resolutionPropertyNames.push(propertyName);
        return true;
    }
    function findResolutionCycleStartIndex(target, propertyName) {
        for (let i = resolutionTargets.length - 1; i >= 0; i--) {
            if (resolutionTargetHasProperty(resolutionTargets[i], resolutionPropertyNames[i])) {
                return -1;
            }
            if (resolutionTargets[i] === target && resolutionPropertyNames[i] === propertyName) {
                return i;
            }
        }
        return -1;
    }
    function resolutionTargetHasProperty(target, propertyName) {
        switch (propertyName) {
            case 0:
                return !!getSymbolLinks(target).type;
            case 5:
                return !!getNodeLinks(target).resolvedEnumType;
            case 2:
                return !!getSymbolLinks(target).declaredType;
            case 1:
                return !!target.resolvedBaseConstructorType;
            case 3:
                return !!target.resolvedReturnType;
            case 4:
                return !!target.immediateBaseConstraint;
            case 6:
                return !!target.resolvedTypeArguments;
            case 7:
                return !!target.baseTypesResolved;
            case 8:
                return !!getSymbolLinks(target).writeType;
            case 9:
                return getNodeLinks(target).parameterInitializerContainsUndefined !== void 0;
        }
        return Debug.assertNever(propertyName);
    }
    function popTypeResolution() {
        resolutionTargets.pop();
        resolutionPropertyNames.pop();
        return resolutionResults.pop();
    }
    function getDeclarationContainer(node) {
        return findAncestor(getRootDeclaration(node), node2 => {
            switch (node2.kind) {
                case 257:
                case 258:
                case 273:
                case 272:
                case 271:
                case 270:
                    return false;
                default:
                    return true;
            }
        }).parent;
    }
    function getTypeOfPrototypeProperty(prototype) {
        const classType = getDeclaredTypeOfSymbol(getParentOfSymbol(prototype));
        return classType.typeParameters ? createTypeReference(classType, map(classType.typeParameters, _ => anyType)) : classType;
    }
    function getTypeOfPropertyOfType(type, name) {
        const prop = getPropertyOfType(type, name);
        return prop ? getTypeOfSymbol(prop) : void 0;
    }
    function getTypeOfPropertyOrIndexSignature(type, name) {
        var _a2;
        return getTypeOfPropertyOfType(type, name) || ((_a2 = getApplicableIndexInfoForName(type, name)) == null ? void 0 : _a2.type) || unknownType;
    }
    function isTypeAny(type) {
        return type && (type.flags & 1) !== 0;
    }
    function isErrorType(type) {
        return type === errorType || !!(type.flags & 1 && type.aliasSymbol);
    }
    function getTypeForBindingElementParent(node, checkMode) {
        if (checkMode !== 0) {
            return getTypeForVariableLikeDeclaration(node, false, checkMode);
        }
        const symbol = getSymbolOfDeclaration(node);
        return symbol && getSymbolLinks(symbol).type || getTypeForVariableLikeDeclaration(node, false, checkMode);
    }
    function getRestType(source, properties, symbol) {
        source = filterType(source, t => !(t.flags & 98304));
        if (source.flags & 131072) {
            return emptyObjectType;
        }
        if (source.flags & 1048576) {
            return mapType(source, t => getRestType(t, properties, symbol));
        }
        let omitKeyType = getUnionType(map(properties, getLiteralTypeFromPropertyName));
        const spreadableProperties = [];
        const unspreadableToRestKeys = [];
        for (const prop of getPropertiesOfType(source)) {
            const literalTypeFromProperty = getLiteralTypeFromProperty(prop, 8576);
            if (!isTypeAssignableTo(literalTypeFromProperty, omitKeyType) && !(getDeclarationModifierFlagsFromSymbol(prop) & (8 | 16)) && isSpreadableProperty(prop)) {
                spreadableProperties.push(prop);
            } else {
                unspreadableToRestKeys.push(literalTypeFromProperty);
            }
        }
        if (isGenericObjectType(source) || isGenericIndexType(omitKeyType)) {
            if (unspreadableToRestKeys.length) {
                omitKeyType = getUnionType([omitKeyType, ...unspreadableToRestKeys]);
            }
            if (omitKeyType.flags & 131072) {
                return source;
            }
            const omitTypeAlias = getGlobalOmitSymbol();
            if (!omitTypeAlias) {
                return errorType;
            }
            return getTypeAliasInstantiation(omitTypeAlias, [source, omitKeyType]);
        }
        const members = createSymbolTable();
        for (const prop of spreadableProperties) {
            members.set(prop.escapedName, getSpreadSymbol(prop, false));
        }
        const result = createAnonymousType(symbol, members, emptyArray, emptyArray, getIndexInfosOfType(source));
        result.objectFlags |= 4194304;
        return result;
    }
    function isGenericTypeWithUndefinedConstraint(type) {
        return !!(type.flags & 465829888) && maybeTypeOfKind(getBaseConstraintOfType(type) || unknownType, 32768);
    }
    function getNonUndefinedType(type) {
        const typeOrConstraint = someType(type, isGenericTypeWithUndefinedConstraint) ? mapType(type, t => t.flags & 465829888 ? getBaseConstraintOrType(t) : t) : type;
        return getTypeWithFacts(typeOrConstraint, 524288);
    }
    function getFlowTypeOfDestructuring(node, declaredType) {
        const reference = getSyntheticElementAccess(node);
        return reference ? getFlowTypeOfReference(reference, declaredType) : declaredType;
    }
    function getSyntheticElementAccess(node) {
        const parentAccess = getParentElementAccess(node);
        if (parentAccess && canHaveFlowNode(parentAccess) && parentAccess.flowNode) {
            const propName = getDestructuringPropertyName(node);
            if (propName) {
                const literal = setTextRange(parseNodeFactory.createStringLiteral(propName), node);
                const lhsExpr = isLeftHandSideExpression(parentAccess) ? parentAccess : parseNodeFactory.createParenthesizedExpression(parentAccess);
                const result = setTextRange(parseNodeFactory.createElementAccessExpression(lhsExpr, literal), node);
                setParent(literal, result);
                setParent(result, node);
                if (lhsExpr !== parentAccess) {
                    setParent(lhsExpr, result);
                }
                result.flowNode = parentAccess.flowNode;
                return result;
            }
        }
    }
    function getParentElementAccess(node) {
        const ancestor = node.parent.parent;
        switch (ancestor.kind) {
            case 205:
            case 299:
                return getSyntheticElementAccess(ancestor);
            case 206:
                return getSyntheticElementAccess(node.parent);
            case 257:
                return ancestor.initializer;
            case 223:
                return ancestor.right;
        }
    }
    function getDestructuringPropertyName(node) {
        const parent2 = node.parent;
        if (node.kind === 205 && parent2.kind === 203) {
            return getLiteralPropertyNameText(node.propertyName || node.name);
        }
        if (node.kind === 299 || node.kind === 300) {
            return getLiteralPropertyNameText(node.name);
        }
        return "" + parent2.elements.indexOf(node);
    }
    function getLiteralPropertyNameText(name) {
        const type = getLiteralTypeFromPropertyName(name);
        return type.flags & (128 | 256) ? "" + type.value : void 0;
    }
    function getTypeForBindingElement(declaration) {
        const checkMode = declaration.dotDotDotToken ? 64 : 0;
        const parentType = getTypeForBindingElementParent(declaration.parent.parent, checkMode);
        return parentType && getBindingElementTypeFromParentType(declaration, parentType);
    }
    function getBindingElementTypeFromParentType(declaration, parentType) {
        if (isTypeAny(parentType)) {
            return parentType;
        }
        const pattern = declaration.parent;
        if (strictNullChecks && declaration.flags & 16777216 && isParameterDeclaration(declaration)) {
            parentType = getNonNullableType(parentType);
        } else if (strictNullChecks && pattern.parent.initializer && !(getTypeFacts(getTypeOfInitializer(pattern.parent.initializer)) & 65536)) {
            parentType = getTypeWithFacts(parentType, 524288);
        }
        let type;
        if (pattern.kind === 203) {
            if (declaration.dotDotDotToken) {
                parentType = getReducedType(parentType);
                if (parentType.flags & 2 || !isValidSpreadType(parentType)) {
                    error(declaration, Diagnostics.Rest_types_may_only_be_created_from_object_types);
                    return errorType;
                }
                const literalMembers = [];
                for (const element of pattern.elements) {
                    if (!element.dotDotDotToken) {
                        literalMembers.push(element.propertyName || element.name);
                    }
                }
                type = getRestType(parentType, literalMembers, declaration.symbol);
            } else {
                const name = declaration.propertyName || declaration.name;
                const indexType = getLiteralTypeFromPropertyName(name);
                const declaredType = getIndexedAccessType(parentType, indexType, 32, name);
                type = getFlowTypeOfDestructuring(declaration, declaredType);
            }
        } else {
            const elementType = checkIteratedTypeOrElementType(65 | (declaration.dotDotDotToken ? 0 : 128), parentType, undefinedType, pattern);
            const index = pattern.elements.indexOf(declaration);
            if (declaration.dotDotDotToken) {
                const baseConstraint = getBaseConstraintOrType(parentType);
                type = everyType(baseConstraint, isTupleType) ? mapType(baseConstraint, t => sliceTupleType(t, index)) : createArrayType(elementType);
            } else if (isArrayLikeType(parentType)) {
                const indexType = getNumberLiteralType(index);
                const accessFlags = 32 | (hasDefaultValue(declaration) ? 16 : 0);
                const declaredType = getIndexedAccessTypeOrUndefined(parentType, indexType, accessFlags, declaration.name) || errorType;
                type = getFlowTypeOfDestructuring(declaration, declaredType);
            } else {
                type = elementType;
            }
        }
        if (!declaration.initializer) {
            return type;
        }
        if (getEffectiveTypeAnnotationNode(walkUpBindingElementsAndPatterns(declaration))) {
            return strictNullChecks && !(getTypeFacts(checkDeclarationInitializer(declaration, 0)) & 16777216) ? getNonUndefinedType(type) : type;
        }
        return widenTypeInferredFromInitializer(declaration, getUnionType([getNonUndefinedType(type), checkDeclarationInitializer(declaration, 0)], 2));
    }
    function getTypeForDeclarationFromJSDocComment(declaration) {
        const jsdocType = getJSDocType(declaration);
        if (jsdocType) {
            return getTypeFromTypeNode(jsdocType);
        }
        return void 0;
    }
    function isNullOrUndefined3(node) {
        const expr = skipParentheses(node, true);
        return expr.kind === 104 || expr.kind === 79 && getResolvedSymbol(expr) === undefinedSymbol;
    }
    function isEmptyArrayLiteral2(node) {
        const expr = skipParentheses(node, true);
        return expr.kind === 206 && expr.elements.length === 0;
    }
    function addOptionality(type, isProperty = false, isOptional = true) {
        return strictNullChecks && isOptional ? getOptionalType(type, isProperty) : type;
    }
    function getTypeForVariableLikeDeclaration(declaration, includeOptionality, checkMode) {
        if (isVariableDeclaration(declaration) && declaration.parent.parent.kind === 246) {
            const indexType = getIndexType(getNonNullableTypeIfNeeded(checkExpression(declaration.parent.parent.expression, checkMode)));
            return indexType.flags & (262144 | 4194304) ? getExtractStringType(indexType) : stringType;
        }
        if (isVariableDeclaration(declaration) && declaration.parent.parent.kind === 247) {
            const forOfStatement = declaration.parent.parent;
            return checkRightHandSideOfForOf(forOfStatement) || anyType;
        }
        if (isBindingPattern(declaration.parent)) {
            return getTypeForBindingElement(declaration);
        }
        const isProperty = isPropertyDeclaration(declaration) && !hasAccessorModifier(declaration) || isPropertySignature(declaration) || isJSDocPropertyTag(declaration);
        const isOptional = includeOptionality && isOptionalDeclaration(declaration);
        const declaredType = tryGetTypeFromEffectiveTypeNode(declaration);
        if (isCatchClauseVariableDeclarationOrBindingElement(declaration)) {
            if (declaredType) {
                return isTypeAny(declaredType) || declaredType === unknownType ? declaredType : errorType;
            }
            return useUnknownInCatchVariables ? unknownType : anyType;
        }
        if (declaredType) {
            return addOptionality(declaredType, isProperty, isOptional);
        }
        if ((noImplicitAny || isInJSFile(declaration)) && isVariableDeclaration(declaration) && !isBindingPattern(declaration.name) && !(getCombinedModifierFlags(declaration) & 1) && !(declaration.flags & 16777216)) {
            if (!(getCombinedNodeFlags(declaration) & 2) && (!declaration.initializer || isNullOrUndefined3(declaration.initializer))) {
                return autoType;
            }
            if (declaration.initializer && isEmptyArrayLiteral2(declaration.initializer)) {
                return autoArrayType;
            }
        }
        if (isParameter(declaration)) {
            const func = declaration.parent;
            if (func.kind === 175 && hasBindableName(func)) {
                const getter = getDeclarationOfKind(getSymbolOfDeclaration(declaration.parent), 174);
                if (getter) {
                    const getterSignature = getSignatureFromDeclaration(getter);
                    const thisParameter = getAccessorThisParameter(func);
                    if (thisParameter && declaration === thisParameter) {
                        Debug.assert(!thisParameter.type);
                        return getTypeOfSymbol(getterSignature.thisParameter);
                    }
                    return getReturnTypeOfSignature(getterSignature);
                }
            }
            const parameterTypeOfTypeTag = getParameterTypeOfTypeTag(func, declaration);
            if (parameterTypeOfTypeTag) return parameterTypeOfTypeTag;
            const type = declaration.symbol.escapedName === "this" ? getContextualThisParameterType(func) : getContextuallyTypedParameterType(declaration);
            if (type) {
                return addOptionality(type, false, isOptional);
            }
        }
        if (hasOnlyExpressionInitializer(declaration) && !!declaration.initializer) {
            if (isInJSFile(declaration) && !isParameter(declaration)) {
                const containerObjectType = getJSContainerObjectType(declaration, getSymbolOfDeclaration(declaration), getDeclaredExpandoInitializer(declaration));
                if (containerObjectType) {
                    return containerObjectType;
                }
            }
            const type = widenTypeInferredFromInitializer(declaration, checkDeclarationInitializer(declaration, checkMode));
            return addOptionality(type, isProperty, isOptional);
        }
        if (isPropertyDeclaration(declaration) && (noImplicitAny || isInJSFile(declaration))) {
            if (!hasStaticModifier(declaration)) {
                const constructor = findConstructorDeclaration(declaration.parent);
                const type = constructor ? getFlowTypeInConstructor(declaration.symbol, constructor) : getEffectiveModifierFlags(declaration) & 2 ? getTypeOfPropertyInBaseClass(declaration.symbol) : void 0;
                return type && addOptionality(type, true, isOptional);
            } else {
                const staticBlocks = filter(declaration.parent.members, isClassStaticBlockDeclaration);
                const type = staticBlocks.length ? getFlowTypeInStaticBlocks(declaration.symbol, staticBlocks) : getEffectiveModifierFlags(declaration) & 2 ? getTypeOfPropertyInBaseClass(declaration.symbol) : void 0;
                return type && addOptionality(type, true, isOptional);
            }
        }
        if (isJsxAttribute(declaration)) {
            return trueType;
        }
        if (isBindingPattern(declaration.name)) {
            return getTypeFromBindingPattern(declaration.name, false, true);
        }
        return void 0;
    }
    function isConstructorDeclaredProperty(symbol) {
        if (symbol.valueDeclaration && isBinaryExpression(symbol.valueDeclaration)) {
            const links = getSymbolLinks(symbol);
            if (links.isConstructorDeclaredProperty === void 0) {
                links.isConstructorDeclaredProperty = false;
                links.isConstructorDeclaredProperty = !!getDeclaringConstructor(symbol) && every(symbol.declarations, declaration => isBinaryExpression(declaration) && isPossiblyAliasedThisProperty(declaration) && (declaration.left.kind !== 209 || isStringOrNumericLiteralLike(declaration.left.argumentExpression)) && !getAnnotatedTypeForAssignmentDeclaration(void 0, declaration, symbol, declaration));
            }
            return links.isConstructorDeclaredProperty;
        }
        return false;
    }
    function isAutoTypedProperty(symbol) {
        const declaration = symbol.valueDeclaration;
        return declaration && isPropertyDeclaration(declaration) && !getEffectiveTypeAnnotationNode(declaration) && !declaration.initializer && (noImplicitAny || isInJSFile(declaration));
    }
    function getDeclaringConstructor(symbol) {
        if (!symbol.declarations) {
            return;
        }
        for (const declaration of symbol.declarations) {
            const container = getThisContainer(declaration, false, false);
            if (container && (container.kind === 173 || isJSConstructor(container))) {
                return container;
            }
        }
    }
    function getFlowTypeFromCommonJSExport(symbol) {
        const file = getSourceFileOfNode(symbol.declarations[0]);
        const accessName = unescapeLeadingUnderscores(symbol.escapedName);
        const areAllModuleExports = symbol.declarations.every(d => isInJSFile(d) && isAccessExpression(d) && isModuleExportsAccessExpression(d.expression));
        const reference = areAllModuleExports ? factory.createPropertyAccessExpression(factory.createPropertyAccessExpression(factory.createIdentifier("module"), factory.createIdentifier("exports")), accessName) : factory.createPropertyAccessExpression(factory.createIdentifier("exports"), accessName);
        if (areAllModuleExports) {
            setParent(reference.expression.expression, reference.expression);
        }
        setParent(reference.expression, reference);
        setParent(reference, file);
        reference.flowNode = file.endFlowNode;
        return getFlowTypeOfReference(reference, autoType, undefinedType);
    }
    function getFlowTypeInStaticBlocks(symbol, staticBlocks) {
        const accessName = startsWith(symbol.escapedName, "__#") ? factory.createPrivateIdentifier(symbol.escapedName.split("@")[1]) : unescapeLeadingUnderscores(symbol.escapedName);
        for (const staticBlock of staticBlocks) {
            const reference = factory.createPropertyAccessExpression(factory.createThis(), accessName);
            setParent(reference.expression, reference);
            setParent(reference, staticBlock);
            reference.flowNode = staticBlock.returnFlowNode;
            const flowType = getFlowTypeOfProperty(reference, symbol);
            if (noImplicitAny && (flowType === autoType || flowType === autoArrayType)) {
                error(symbol.valueDeclaration, Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType));
            }
            if (everyType(flowType, isNullableType)) {
                continue;
            }
            return convertAutoToAny(flowType);
        }
    }
    function getFlowTypeInConstructor(symbol, constructor) {
        const accessName = startsWith(symbol.escapedName, "__#") ? factory.createPrivateIdentifier(symbol.escapedName.split("@")[1]) : unescapeLeadingUnderscores(symbol.escapedName);
        const reference = factory.createPropertyAccessExpression(factory.createThis(), accessName);
        setParent(reference.expression, reference);
        setParent(reference, constructor);
        reference.flowNode = constructor.returnFlowNode;
        const flowType = getFlowTypeOfProperty(reference, symbol);
        if (noImplicitAny && (flowType === autoType || flowType === autoArrayType)) {
            error(symbol.valueDeclaration, Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType));
        }
        return everyType(flowType, isNullableType) ? void 0 : convertAutoToAny(flowType);
    }
    function getFlowTypeOfProperty(reference, prop) {
        const initialType = (prop == null ? void 0 : prop.valueDeclaration) && (!isAutoTypedProperty(prop) || getEffectiveModifierFlags(prop.valueDeclaration) & 2) && getTypeOfPropertyInBaseClass(prop) || undefinedType;
        return getFlowTypeOfReference(reference, autoType, initialType);
    }
    function getWidenedTypeForAssignmentDeclaration(symbol, resolvedSymbol) {
        const container = getAssignedExpandoInitializer(symbol.valueDeclaration);
        if (container) {
            const tag = isInJSFile(container) ? getJSDocTypeTag(container) : void 0;
            if (tag && tag.typeExpression) {
                return getTypeFromTypeNode(tag.typeExpression);
            }
            const containerObjectType = symbol.valueDeclaration && getJSContainerObjectType(symbol.valueDeclaration, symbol, container);
            return containerObjectType || getWidenedLiteralType(checkExpressionCached(container));
        }
        let type;
        let definedInConstructor = false;
        let definedInMethod = false;
        if (isConstructorDeclaredProperty(symbol)) {
            type = getFlowTypeInConstructor(symbol, getDeclaringConstructor(symbol));
        }
        if (!type) {
            let types;
            if (symbol.declarations) {
                let jsdocType;
                for (const declaration of symbol.declarations) {
                    const expression = isBinaryExpression(declaration) || isCallExpression(declaration) ? declaration : isAccessExpression(declaration) ? isBinaryExpression(declaration.parent) ? declaration.parent : declaration : void 0;
                    if (!expression) {
                        continue;
                    }
                    const kind = isAccessExpression(expression) ? getAssignmentDeclarationPropertyAccessKind(expression) : getAssignmentDeclarationKind(expression);
                    if (kind === 4 || isBinaryExpression(expression) && isPossiblyAliasedThisProperty(expression, kind)) {
                        if (isDeclarationInConstructor(expression)) {
                            definedInConstructor = true;
                        } else {
                            definedInMethod = true;
                        }
                    }
                    if (!isCallExpression(expression)) {
                        jsdocType = getAnnotatedTypeForAssignmentDeclaration(jsdocType, expression, symbol, declaration);
                    }
                    if (!jsdocType) {
                        (types || (types = [])).push(isBinaryExpression(expression) || isCallExpression(expression) ? getInitializerTypeFromAssignmentDeclaration(symbol, resolvedSymbol, expression, kind) : neverType);
                    }
                }
                type = jsdocType;
            }
            if (!type) {
                if (!length(types)) {
                    return errorType;
                }
                let constructorTypes = definedInConstructor && symbol.declarations ? getConstructorDefinedThisAssignmentTypes(types, symbol.declarations) : void 0;
                if (definedInMethod) {
                    const propType = getTypeOfPropertyInBaseClass(symbol);
                    if (propType) {
                        (constructorTypes || (constructorTypes = [])).push(propType);
                        definedInConstructor = true;
                    }
                }
                const sourceTypes = some(constructorTypes, t => !!(t.flags & ~98304)) ? constructorTypes : types;
                type = getUnionType(sourceTypes);
            }
        }
        const widened = getWidenedType(addOptionality(type, false, definedInMethod && !definedInConstructor));
        if (symbol.valueDeclaration && filterType(widened, t => !!(t.flags & ~98304)) === neverType) {
            reportImplicitAny(symbol.valueDeclaration, anyType);
            return anyType;
        }
        return widened;
    }
    function getJSContainerObjectType(decl, symbol, init) {
        var _a2, _b;
        if (!isInJSFile(decl) || !init || !isObjectLiteralExpression(init) || init.properties.length) {
            return void 0;
        }
        const exports = createSymbolTable();
        while (isBinaryExpression(decl) || isPropertyAccessExpression(decl)) {
            const s2 = getSymbolOfNode(decl);
            if ((_a2 = s2 == null ? void 0 : s2.exports) == null ? void 0 : _a2.size) {
                mergeSymbolTable(exports, s2.exports);
            }
            decl = isBinaryExpression(decl) ? decl.parent : decl.parent.parent;
        }
        const s = getSymbolOfNode(decl);
        if ((_b = s == null ? void 0 : s.exports) == null ? void 0 : _b.size) {
            mergeSymbolTable(exports, s.exports);
        }
        const type = createAnonymousType(symbol, exports, emptyArray, emptyArray, emptyArray);
        type.objectFlags |= 4096;
        return type;
    }
    function getAnnotatedTypeForAssignmentDeclaration(declaredType, expression, symbol, declaration) {
        var _a2;
        const typeNode = getEffectiveTypeAnnotationNode(expression.parent);
        if (typeNode) {
            const type = getWidenedType(getTypeFromTypeNode(typeNode));
            if (!declaredType) {
                return type;
            } else if (!isErrorType(declaredType) && !isErrorType(type) && !isTypeIdenticalTo(declaredType, type)) {
                errorNextVariableOrPropertyDeclarationMustHaveSameType(void 0, declaredType, declaration, type);
            }
        }
        if ((_a2 = symbol.parent) == null ? void 0 : _a2.valueDeclaration) {
            const typeNode2 = getEffectiveTypeAnnotationNode(symbol.parent.valueDeclaration);
            if (typeNode2) {
                const annotationSymbol = getPropertyOfType(getTypeFromTypeNode(typeNode2), symbol.escapedName);
                if (annotationSymbol) {
                    return getNonMissingTypeOfSymbol(annotationSymbol);
                }
            }
        }
        return declaredType;
    }
    function getInitializerTypeFromAssignmentDeclaration(symbol, resolvedSymbol, expression, kind) {
        if (isCallExpression(expression)) {
            if (resolvedSymbol) {
                return getTypeOfSymbol(resolvedSymbol);
            }
            const objectLitType = checkExpressionCached(expression.arguments[2]);
            const valueType = getTypeOfPropertyOfType(objectLitType, "value");
            if (valueType) {
                return valueType;
            }
            const getFunc = getTypeOfPropertyOfType(objectLitType, "get");
            if (getFunc) {
                const getSig = getSingleCallSignature(getFunc);
                if (getSig) {
                    return getReturnTypeOfSignature(getSig);
                }
            }
            const setFunc = getTypeOfPropertyOfType(objectLitType, "set");
            if (setFunc) {
                const setSig = getSingleCallSignature(setFunc);
                if (setSig) {
                    return getTypeOfFirstParameterOfSignature(setSig);
                }
            }
            return anyType;
        }
        if (containsSameNamedThisProperty(expression.left, expression.right)) {
            return anyType;
        }
        const isDirectExport = kind === 1 && (isPropertyAccessExpression(expression.left) || isElementAccessExpression(expression.left)) && (isModuleExportsAccessExpression(expression.left.expression) || isIdentifier(expression.left.expression) && isExportsIdentifier(expression.left.expression));
        const type = resolvedSymbol ? getTypeOfSymbol(resolvedSymbol) : isDirectExport ? getRegularTypeOfLiteralType(checkExpressionCached(expression.right)) : getWidenedLiteralType(checkExpressionCached(expression.right));
        if (type.flags & 524288 && kind === 2 && symbol.escapedName === "export=") {
            const exportedType = resolveStructuredTypeMembers(type);
            const members = createSymbolTable();
            copyEntries(exportedType.members, members);
            const initialSize = members.size;
            if (resolvedSymbol && !resolvedSymbol.exports) {
                resolvedSymbol.exports = createSymbolTable();
            }
            (resolvedSymbol || symbol).exports.forEach((s, name) => {
                var _a2;
                const exportedMember = members.get(name);
                if (exportedMember && exportedMember !== s && !(s.flags & 2097152)) {
                    if (s.flags & 111551 && exportedMember.flags & 111551) {
                        if (s.valueDeclaration && exportedMember.valueDeclaration && getSourceFileOfNode(s.valueDeclaration) !== getSourceFileOfNode(exportedMember.valueDeclaration)) {
                            const unescapedName = unescapeLeadingUnderscores(s.escapedName);
                            const exportedMemberName = ((_a2 = tryCast(exportedMember.valueDeclaration, isNamedDeclaration)) == null ? void 0 : _a2.name) || exportedMember.valueDeclaration;
                            addRelatedInfo(error(s.valueDeclaration, Diagnostics.Duplicate_identifier_0, unescapedName), createDiagnosticForNode(exportedMemberName, Diagnostics._0_was_also_declared_here, unescapedName));
                            addRelatedInfo(error(exportedMemberName, Diagnostics.Duplicate_identifier_0, unescapedName), createDiagnosticForNode(s.valueDeclaration, Diagnostics._0_was_also_declared_here, unescapedName));
                        }
                        const union = createSymbol(s.flags | exportedMember.flags, name);
                        union.links.type = getUnionType([getTypeOfSymbol(s), getTypeOfSymbol(exportedMember)]);
                        union.valueDeclaration = exportedMember.valueDeclaration;
                        union.declarations = concatenate(exportedMember.declarations, s.declarations);
                        members.set(name, union);
                    } else {
                        members.set(name, mergeSymbol(s, exportedMember));
                    }
                } else {
                    members.set(name, s);
                }
            });
            const result = createAnonymousType(initialSize !== members.size ? void 0 : exportedType.symbol, members, exportedType.callSignatures, exportedType.constructSignatures, exportedType.indexInfos);
            if (initialSize === members.size) {
                if (type.aliasSymbol) {
                    result.aliasSymbol = type.aliasSymbol;
                    result.aliasTypeArguments = type.aliasTypeArguments;
                }
                if (getObjectFlags(type) & 4) {
                    result.aliasSymbol = type.symbol;
                    const args = getTypeArguments(type);
                    result.aliasTypeArguments = length(args) ? args : void 0;
                }
            }
            result.objectFlags |= getObjectFlags(type) & 4096;
            if (result.symbol && result.symbol.flags & 32 && type === getDeclaredTypeOfClassOrInterface(result.symbol)) {
                result.objectFlags |= 16777216;
            }
            return result;
        }
        if (isEmptyArrayLiteralType(type)) {
            reportImplicitAny(expression, anyArrayType);
            return anyArrayType;
        }
        return type;
    }
    function containsSameNamedThisProperty(thisProperty, expression) {
        return isPropertyAccessExpression(thisProperty) && thisProperty.expression.kind === 108 && forEachChildRecursively(expression, n => isMatchingReference(thisProperty, n));
    }
    function isDeclarationInConstructor(expression) {
        const thisContainer = getThisContainer(expression, false, false);
        return thisContainer.kind === 173 || thisContainer.kind === 259 || thisContainer.kind === 215 && !isPrototypePropertyAssignment(thisContainer.parent);
    }
    function getConstructorDefinedThisAssignmentTypes(types, declarations) {
        Debug.assert(types.length === declarations.length);
        return types.filter((_, i) => {
            const declaration = declarations[i];
            const expression = isBinaryExpression(declaration) ? declaration : isBinaryExpression(declaration.parent) ? declaration.parent : void 0;
            return expression && isDeclarationInConstructor(expression);
        });
    }
    function getTypeFromBindingElement(element, includePatternInType, reportErrors2) {
        if (element.initializer) {
            const contextualType = isBindingPattern(element.name) ? getTypeFromBindingPattern(element.name, true, false) : unknownType;
            return addOptionality(widenTypeInferredFromInitializer(element, checkDeclarationInitializer(element, 0, contextualType)));
        }
        if (isBindingPattern(element.name)) {
            return getTypeFromBindingPattern(element.name, includePatternInType, reportErrors2);
        }
        if (reportErrors2 && !declarationBelongsToPrivateAmbientMember(element)) {
            reportImplicitAny(element, anyType);
        }
        return includePatternInType ? nonInferrableAnyType : anyType;
    }
    function getTypeFromObjectBindingPattern(pattern, includePatternInType, reportErrors2) {
        const members = createSymbolTable();
        let stringIndexInfo;
        let objectFlags = 128 | 131072;
        forEach(pattern.elements, e => {
            const name = e.propertyName || e.name;
            if (e.dotDotDotToken) {
                stringIndexInfo = createIndexInfo(stringType, anyType, false);
                return;
            }
            const exprType = getLiteralTypeFromPropertyName(name);
            if (!isTypeUsableAsPropertyName(exprType)) {
                objectFlags |= 512;
                return;
            }
            const text = getPropertyNameFromType(exprType);
            const flags = 4 | (e.initializer ? 16777216 : 0);
            const symbol = createSymbol(flags, text);
            symbol.links.type = getTypeFromBindingElement(e, includePatternInType, reportErrors2);
            symbol.links.bindingElement = e;
            members.set(symbol.escapedName, symbol);
        });
        const result = createAnonymousType(void 0, members, emptyArray, emptyArray, stringIndexInfo ? [stringIndexInfo] : emptyArray);
        result.objectFlags |= objectFlags;
        if (includePatternInType) {
            result.pattern = pattern;
            result.objectFlags |= 131072;
        }
        return result;
    }
    function getTypeFromArrayBindingPattern(pattern, includePatternInType, reportErrors2) {
        const elements = pattern.elements;
        const lastElement = lastOrUndefined(elements);
        const restElement = lastElement && lastElement.kind === 205 && lastElement.dotDotDotToken ? lastElement : void 0;
        if (elements.length === 0 || elements.length === 1 && restElement) {
            return languageVersion >= 2 ? createIterableType(anyType) : anyArrayType;
        }
        const elementTypes = map(elements, e => isOmittedExpression(e) ? anyType : getTypeFromBindingElement(e, includePatternInType, reportErrors2));
        const minLength = findLastIndex(elements, e => !(e === restElement || isOmittedExpression(e) || hasDefaultValue(e)), elements.length - 1) + 1;
        const elementFlags = map(elements, (e, i) => e === restElement ? 4 : i >= minLength ? 2 : 1);
        let result = createTupleType(elementTypes, elementFlags);
        if (includePatternInType) {
            result = cloneTypeReference(result);
            result.pattern = pattern;
            result.objectFlags |= 131072;
        }
        return result;
    }
    function getTypeFromBindingPattern(pattern, includePatternInType = false, reportErrors2 = false) {
        return pattern.kind === 203 ? getTypeFromObjectBindingPattern(pattern, includePatternInType, reportErrors2) : getTypeFromArrayBindingPattern(pattern, includePatternInType, reportErrors2);
    }
    function getWidenedTypeForVariableLikeDeclaration(declaration, reportErrors2) {
        return widenTypeForVariableLikeDeclaration(getTypeForVariableLikeDeclaration(declaration, true, 0), declaration, reportErrors2);
    }
    function isGlobalSymbolConstructor(node) {
        const symbol = getSymbolOfNode(node);
        const globalSymbol = getGlobalESSymbolConstructorTypeSymbol(false);
        return globalSymbol && symbol && symbol === globalSymbol;
    }
    function widenTypeForVariableLikeDeclaration(type, declaration, reportErrors2) {
        if (type) {
            if (type.flags & 4096 && isGlobalSymbolConstructor(declaration.parent)) {
                type = getESSymbolLikeTypeForNode(declaration);
            }
            if (reportErrors2) {
                reportErrorsFromWidening(declaration, type);
            }
            if (type.flags & 8192 && (isBindingElement(declaration) || !declaration.type) && type.symbol !== getSymbolOfDeclaration(declaration)) {
                type = esSymbolType;
            }
            return getWidenedType(type);
        }
        type = isParameter(declaration) && declaration.dotDotDotToken ? anyArrayType : anyType;
        if (reportErrors2) {
            if (!declarationBelongsToPrivateAmbientMember(declaration)) {
                reportImplicitAny(declaration, type);
            }
        }
        return type;
    }
    function declarationBelongsToPrivateAmbientMember(declaration) {
        const root = getRootDeclaration(declaration);
        const memberDeclaration = root.kind === 166 ? root.parent : root;
        return isPrivateWithinAmbient(memberDeclaration);
    }
    function tryGetTypeFromEffectiveTypeNode(node) {
        const typeNode = getEffectiveTypeAnnotationNode(node);
        if (typeNode) {
            return getTypeFromTypeNode(typeNode);
        }
    }
    function isParameterOfContextSensitiveSignature(symbol) {
        let decl = symbol.valueDeclaration;
        if (!decl) {
            return false;
        }
        if (isBindingElement(decl)) {
            decl = walkUpBindingElementsAndPatterns(decl);
        }
        if (isParameter(decl)) {
            return isContextSensitiveFunctionOrObjectLiteralMethod(decl.parent);
        }
        return false;
    }
    function getTypeOfVariableOrParameterOrProperty(symbol) {
        const links = getSymbolLinks(symbol);
        if (!links.type) {
            const type = getTypeOfVariableOrParameterOrPropertyWorker(symbol);
            if (!links.type && !isParameterOfContextSensitiveSignature(symbol)) {
                links.type = type;
            }
            return type;
        }
        return links.type;
    }
    function getTypeOfVariableOrParameterOrPropertyWorker(symbol) {
        if (symbol.flags & 4194304) {
            return getTypeOfPrototypeProperty(symbol);
        }
        if (symbol === requireSymbol) {
            return anyType;
        }
        if (symbol.flags & 134217728 && symbol.valueDeclaration) {
            const fileSymbol = getSymbolOfDeclaration(getSourceFileOfNode(symbol.valueDeclaration));
            const result = createSymbol(fileSymbol.flags, "exports");
            result.declarations = fileSymbol.declarations ? fileSymbol.declarations.slice() : [];
            result.parent = symbol;
            result.links.target = fileSymbol;
            if (fileSymbol.valueDeclaration) result.valueDeclaration = fileSymbol.valueDeclaration;
            if (fileSymbol.members) result.members = new Map(fileSymbol.members);
            if (fileSymbol.exports) result.exports = new Map(fileSymbol.exports);
            const members = createSymbolTable();
            members.set("exports", result);
            return createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray);
        }
        Debug.assertIsDefined(symbol.valueDeclaration);
        const declaration = symbol.valueDeclaration;
        if (isSourceFile(declaration) && isJsonSourceFile(declaration)) {
            if (!declaration.statements.length) {
                return emptyObjectType;
            }
            return getWidenedType(getWidenedLiteralType(checkExpression(declaration.statements[0].expression)));
        }
        if (isAccessor(declaration)) {
            return getTypeOfAccessors(symbol);
        }
        if (!pushTypeResolution(symbol, 0)) {
            if (symbol.flags & 512 && !(symbol.flags & 67108864)) {
                return getTypeOfFuncClassEnumModule(symbol);
            }
            return reportCircularityError(symbol);
        }
        let type;
        if (declaration.kind === 274) {
            type = widenTypeForVariableLikeDeclaration(tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionCached(declaration.expression), declaration);
        } else if (isBinaryExpression(declaration) || isInJSFile(declaration) && (isCallExpression(declaration) || (isPropertyAccessExpression(declaration) || isBindableStaticElementAccessExpression(declaration)) && isBinaryExpression(declaration.parent))) {
            type = getWidenedTypeForAssignmentDeclaration(symbol);
        } else if (isPropertyAccessExpression(declaration) || isElementAccessExpression(declaration) || isIdentifier(declaration) || isStringLiteralLike(declaration) || isNumericLiteral(declaration) || isClassDeclaration(declaration) || isFunctionDeclaration(declaration) || isMethodDeclaration(declaration) && !isObjectLiteralMethod(declaration) || isMethodSignature(declaration) || isSourceFile(declaration)) {
            if (symbol.flags & (16 | 8192 | 32 | 384 | 512)) {
                return getTypeOfFuncClassEnumModule(symbol);
            }
            type = isBinaryExpression(declaration.parent) ? getWidenedTypeForAssignmentDeclaration(symbol) : tryGetTypeFromEffectiveTypeNode(declaration) || anyType;
        } else if (isPropertyAssignment(declaration)) {
            type = tryGetTypeFromEffectiveTypeNode(declaration) || checkPropertyAssignment(declaration);
        } else if (isJsxAttribute(declaration)) {
            type = tryGetTypeFromEffectiveTypeNode(declaration) || checkJsxAttribute(declaration);
        } else if (isShorthandPropertyAssignment(declaration)) {
            type = tryGetTypeFromEffectiveTypeNode(declaration) || checkExpressionForMutableLocation(declaration.name, 0);
        } else if (isObjectLiteralMethod(declaration)) {
            type = tryGetTypeFromEffectiveTypeNode(declaration) || checkObjectLiteralMethod(declaration, 0);
        } else if (isParameter(declaration) || isPropertyDeclaration(declaration) || isPropertySignature(declaration) || isVariableDeclaration(declaration) || isBindingElement(declaration) || isJSDocPropertyLikeTag(declaration)) {
            type = getWidenedTypeForVariableLikeDeclaration(declaration, true);
        } else if (isEnumDeclaration(declaration)) {
            type = getTypeOfFuncClassEnumModule(symbol);
        } else if (isEnumMember(declaration)) {
            type = getTypeOfEnumMember(symbol);
        } else {
            return Debug.fail("Unhandled declaration kind! " + Debug.formatSyntaxKind(declaration.kind) + " for " + Debug.formatSymbol(symbol));
        }
        if (!popTypeResolution()) {
            if (symbol.flags & 512 && !(symbol.flags & 67108864)) {
                return getTypeOfFuncClassEnumModule(symbol);
            }
            return reportCircularityError(symbol);
        }
        return type;
    }
    function getAnnotatedAccessorTypeNode(accessor) {
        if (accessor) {
            switch (accessor.kind) {
                case 174:
                    const getterTypeAnnotation = getEffectiveReturnTypeNode(accessor);
                    return getterTypeAnnotation;
                case 175:
                    const setterTypeAnnotation = getEffectiveSetAccessorTypeAnnotationNode(accessor);
                    return setterTypeAnnotation;
                case 169:
                    Debug.assert(hasAccessorModifier(accessor));
                    const accessorTypeAnnotation = getEffectiveTypeAnnotationNode(accessor);
                    return accessorTypeAnnotation;
            }
        }
        return void 0;
    }
    function getAnnotatedAccessorType(accessor) {
        const node = getAnnotatedAccessorTypeNode(accessor);
        return node && getTypeFromTypeNode(node);
    }
    function getAnnotatedAccessorThisParameter(accessor) {
        const parameter = getAccessorThisParameter(accessor);
        return parameter && parameter.symbol;
    }
    function getThisTypeOfDeclaration(declaration) {
        return getThisTypeOfSignature(getSignatureFromDeclaration(declaration));
    }
    function getTypeOfAccessors(symbol) {
        const links = getSymbolLinks(symbol);
        if (!links.type) {
            if (!pushTypeResolution(symbol, 0)) {
                return errorType;
            }
            const getter = getDeclarationOfKind(symbol, 174);
            const setter = getDeclarationOfKind(symbol, 175);
            const accessor = tryCast(getDeclarationOfKind(symbol, 169), isAutoAccessorPropertyDeclaration);
            let type = getter && isInJSFile(getter) && getTypeForDeclarationFromJSDocComment(getter) || getAnnotatedAccessorType(getter) || getAnnotatedAccessorType(setter) || getAnnotatedAccessorType(accessor) || getter && getter.body && getReturnTypeFromBody(getter) || accessor && accessor.initializer && getWidenedTypeForVariableLikeDeclaration(accessor, true);
            if (!type) {
                if (setter && !isPrivateWithinAmbient(setter)) {
                    errorOrSuggestion(noImplicitAny, setter, Diagnostics.Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation, symbolToString(symbol));
                } else if (getter && !isPrivateWithinAmbient(getter)) {
                    errorOrSuggestion(noImplicitAny, getter, Diagnostics.Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation, symbolToString(symbol));
                } else if (accessor && !isPrivateWithinAmbient(accessor)) {
                    errorOrSuggestion(noImplicitAny, accessor, Diagnostics.Member_0_implicitly_has_an_1_type, symbolToString(symbol), "any");
                }
                type = anyType;
            }
            if (!popTypeResolution()) {
                if (getAnnotatedAccessorTypeNode(getter)) {
                    error(getter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol));
                } else if (getAnnotatedAccessorTypeNode(setter)) {
                    error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol));
                } else if (getAnnotatedAccessorTypeNode(accessor)) {
                    error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol));
                } else if (getter && noImplicitAny) {
                    error(getter, Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, symbolToString(symbol));
                }
                type = anyType;
            }
            links.type = type;
        }
        return links.type;
    }
    function getWriteTypeOfAccessors(symbol) {
        var _a2;
        const links = getSymbolLinks(symbol);
        if (!links.writeType) {
            if (!pushTypeResolution(symbol, 8)) {
                return errorType;
            }
            const setter = (_a2 = getDeclarationOfKind(symbol, 175)) != null ? _a2 : tryCast(getDeclarationOfKind(symbol, 169), isAutoAccessorPropertyDeclaration);
            let writeType = getAnnotatedAccessorType(setter);
            if (!popTypeResolution()) {
                if (getAnnotatedAccessorTypeNode(setter)) {
                    error(setter, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol));
                }
                writeType = anyType;
            }
            links.writeType = writeType || getTypeOfAccessors(symbol);
        }
        return links.writeType;
    }
    function getBaseTypeVariableOfClass(symbol) {
        const baseConstructorType = getBaseConstructorTypeOfClass(getDeclaredTypeOfClassOrInterface(symbol));
        return baseConstructorType.flags & 8650752 ? baseConstructorType : baseConstructorType.flags & 2097152 ? find(baseConstructorType.types, t => !!(t.flags & 8650752)) : void 0;
    }
    function getTypeOfFuncClassEnumModule(symbol) {
        let links = getSymbolLinks(symbol);
        const originalLinks = links;
        if (!links.type) {
            const expando = symbol.valueDeclaration && getSymbolOfExpando(symbol.valueDeclaration, false);
            if (expando) {
                const merged = mergeJSSymbols(symbol, expando);
                if (merged) {
                    symbol = merged;
                    links = merged.links;
                }
            }
            originalLinks.type = links.type = getTypeOfFuncClassEnumModuleWorker(symbol);
        }
        return links.type;
    }
    function getTypeOfFuncClassEnumModuleWorker(symbol) {
        const declaration = symbol.valueDeclaration;
        if (symbol.flags & 1536 && isShorthandAmbientModuleSymbol(symbol)) {
            return anyType;
        } else if (declaration && (declaration.kind === 223 || isAccessExpression(declaration) && declaration.parent.kind === 223)) {
            return getWidenedTypeForAssignmentDeclaration(symbol);
        } else if (symbol.flags & 512 && declaration && isSourceFile(declaration) && declaration.commonJsModuleIndicator) {
            const resolvedModule = resolveExternalModuleSymbol(symbol);
            if (resolvedModule !== symbol) {
                if (!pushTypeResolution(symbol, 0)) {
                    return errorType;
                }
                const exportEquals = getMergedSymbol(symbol.exports.get("export="));
                const type2 = getWidenedTypeForAssignmentDeclaration(exportEquals, exportEquals === resolvedModule ? void 0 : resolvedModule);
                if (!popTypeResolution()) {
                    return reportCircularityError(symbol);
                }
                return type2;
            }
        }
        const type = createObjectType(16, symbol);
        if (symbol.flags & 32) {
            const baseTypeVariable = getBaseTypeVariableOfClass(symbol);
            return baseTypeVariable ? getIntersectionType([type, baseTypeVariable]) : type;
        } else {
            return strictNullChecks && symbol.flags & 16777216 ? getOptionalType(type) : type;
        }
    }
    function getTypeOfEnumMember(symbol) {
        const links = getSymbolLinks(symbol);
        return links.type || (links.type = getDeclaredTypeOfEnumMember(symbol));
    }
    function getTypeOfAlias(symbol) {
        const links = getSymbolLinks(symbol);
        if (!links.type) {
            const targetSymbol = resolveAlias(symbol);
            const exportSymbol = symbol.declarations && getTargetOfAliasDeclaration(getDeclarationOfAliasSymbol(symbol), true);
            const declaredType = firstDefined(exportSymbol == null ? void 0 : exportSymbol.declarations, d => isExportAssignment(d) ? tryGetTypeFromEffectiveTypeNode(d) : void 0);
            links.type = (exportSymbol == null ? void 0 : exportSymbol.declarations) && isDuplicatedCommonJSExport(exportSymbol.declarations) && symbol.declarations.length ? getFlowTypeFromCommonJSExport(exportSymbol) : isDuplicatedCommonJSExport(symbol.declarations) ? autoType : declaredType ? declaredType : getAllSymbolFlags(targetSymbol) & 111551 ? getTypeOfSymbol(targetSymbol) : errorType;
        }
        return links.type;
    }
    function getTypeOfInstantiatedSymbol(symbol) {
        const links = getSymbolLinks(symbol);
        return links.type || (links.type = instantiateType(getTypeOfSymbol(links.target), links.mapper));
    }
    function getWriteTypeOfInstantiatedSymbol(symbol) {
        const links = getSymbolLinks(symbol);
        return links.writeType || (links.writeType = instantiateType(getWriteTypeOfSymbol(links.target), links.mapper));
    }
    function reportCircularityError(symbol) {
        const declaration = symbol.valueDeclaration;
        if (getEffectiveTypeAnnotationNode(declaration)) {
            error(symbol.valueDeclaration, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_type_annotation, symbolToString(symbol));
            return errorType;
        }
        if (noImplicitAny && (declaration.kind !== 166 || declaration.initializer)) {
            error(symbol.valueDeclaration, Diagnostics._0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer, symbolToString(symbol));
        }
        return anyType;
    }
    function getTypeOfSymbolWithDeferredType(symbol) {
        const links = getSymbolLinks(symbol);
        if (!links.type) {
            Debug.assertIsDefined(links.deferralParent);
            Debug.assertIsDefined(links.deferralConstituents);
            links.type = links.deferralParent.flags & 1048576 ? getUnionType(links.deferralConstituents) : getIntersectionType(links.deferralConstituents);
        }
        return links.type;
    }
    function getWriteTypeOfSymbolWithDeferredType(symbol) {
        const links = getSymbolLinks(symbol);
        if (!links.writeType && links.deferralWriteConstituents) {
            Debug.assertIsDefined(links.deferralParent);
            Debug.assertIsDefined(links.deferralConstituents);
            links.writeType = links.deferralParent.flags & 1048576 ? getUnionType(links.deferralWriteConstituents) : getIntersectionType(links.deferralWriteConstituents);
        }
        return links.writeType;
    }
    function getWriteTypeOfSymbol(symbol) {
        const checkFlags = getCheckFlags(symbol);
        if (symbol.flags & 4) {
            return checkFlags & 2 ? checkFlags & 65536 ? getWriteTypeOfSymbolWithDeferredType(symbol) || getTypeOfSymbolWithDeferredType(symbol) : symbol.links.writeType || symbol.links.type : getTypeOfSymbol(symbol);
        }
        if (symbol.flags & 98304) {
            return checkFlags & 1 ? getWriteTypeOfInstantiatedSymbol(symbol) : getWriteTypeOfAccessors(symbol);
        }
        return getTypeOfSymbol(symbol);
    }
    function getTypeOfSymbol(symbol) {
        const checkFlags = getCheckFlags(symbol);
        if (checkFlags & 65536) {
            return getTypeOfSymbolWithDeferredType(symbol);
        }
        if (checkFlags & 1) {
            return getTypeOfInstantiatedSymbol(symbol);
        }
        if (checkFlags & 262144) {
            return getTypeOfMappedSymbol(symbol);
        }
        if (checkFlags & 8192) {
            return getTypeOfReverseMappedSymbol(symbol);
        }
        if (symbol.flags & (3 | 4)) {
            return getTypeOfVariableOrParameterOrProperty(symbol);
        }
        if (symbol.flags & (16 | 8192 | 32 | 384 | 512)) {
            return getTypeOfFuncClassEnumModule(symbol);
        }
        if (symbol.flags & 8) {
            return getTypeOfEnumMember(symbol);
        }
        if (symbol.flags & 98304) {
            return getTypeOfAccessors(symbol);
        }
        if (symbol.flags & 2097152) {
            return getTypeOfAlias(symbol);
        }
        return errorType;
    }
    function getNonMissingTypeOfSymbol(symbol) {
        return removeMissingType(getTypeOfSymbol(symbol), !!(symbol.flags & 16777216));
    }
    function isReferenceToType2(type, target) {
        return type !== void 0 && target !== void 0 && (getObjectFlags(type) & 4) !== 0 && type.target === target;
    }
    function getTargetType(type) {
        return getObjectFlags(type) & 4 ? type.target : type;
    }
    function hasBaseType(type, checkBase) {
        return check(type);
        function check(type2) {
            if (getObjectFlags(type2) & (3 | 4)) {
                const target = getTargetType(type2);
                return target === checkBase || some(getBaseTypes(target), check);
            } else if (type2.flags & 2097152) {
                return some(type2.types, check);
            }
            return false;
        }
    }
    function appendTypeParameters(typeParameters, declarations) {
        for (const declaration of declarations) {
            typeParameters = appendIfUnique(typeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(declaration)));
        }
        return typeParameters;
    }
    function getOuterTypeParameters(node, includeThisTypes) {
        while (true) {
            node = node.parent;
            if (node && isBinaryExpression(node)) {
                const assignmentKind = getAssignmentDeclarationKind(node);
                if (assignmentKind === 6 || assignmentKind === 3) {
                    const symbol = getSymbolOfDeclaration(node.left);
                    if (symbol && symbol.parent && !findAncestor(symbol.parent.valueDeclaration, d => node === d)) {
                        node = symbol.parent.valueDeclaration;
                    }
                }
            }
            if (!node) {
                return void 0;
            }
            switch (node.kind) {
                case 260:
                case 228:
                case 261:
                case 176:
                case 177:
                case 170:
                case 181:
                case 182:
                case 320:
                case 259:
                case 171:
                case 215:
                case 216:
                case 262:
                case 348:
                case 349:
                case 343:
                case 341:
                case 197:
                case 191:
                    {
                        const outerTypeParameters = getOuterTypeParameters(node, includeThisTypes);
                        if (node.kind === 197) {
                            return append(outerTypeParameters, getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node.typeParameter)));
                        } else if (node.kind === 191) {
                            return concatenate(outerTypeParameters, getInferTypeParameters(node));
                        }
                        const outerAndOwnTypeParameters = appendTypeParameters(outerTypeParameters, getEffectiveTypeParameterDeclarations(node));
                        const thisType = includeThisTypes && (node.kind === 260 || node.kind === 228 || node.kind === 261 || isJSConstructor(node)) && getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node)).thisType;
                        return thisType ? append(outerAndOwnTypeParameters, thisType) : outerAndOwnTypeParameters;
                    }
                case 344:
                    const paramSymbol = getParameterSymbolFromJSDoc(node);
                    if (paramSymbol) {
                        node = paramSymbol.valueDeclaration;
                    }
                    break;
                case 323:
                    {
                        const outerTypeParameters = getOuterTypeParameters(node, includeThisTypes);
                        return node.tags ? appendTypeParameters(outerTypeParameters, flatMap(node.tags, t => isJSDocTemplateTag(t) ? t.typeParameters : void 0)) : outerTypeParameters;
                    }
            }
        }
    }
    function getOuterTypeParametersOfClassOrInterface(symbol) {
        var _a2;
        const declaration = symbol.flags & 32 || symbol.flags & 16 ? symbol.valueDeclaration : (_a2 = symbol.declarations) == null ? void 0 : _a2.find(decl => {
            if (decl.kind === 261) {
                return true;
            }
            if (decl.kind !== 257) {
                return false;
            }
            const initializer = decl.initializer;
            return !!initializer && (initializer.kind === 215 || initializer.kind === 216);
        });
        Debug.assert(!!declaration, "Class was missing valueDeclaration -OR- non-class had no interface declarations");
        return getOuterTypeParameters(declaration);
    }
    function getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol) {
        if (!symbol.declarations) {
            return;
        }
        let result;
        for (const node of symbol.declarations) {
            if (node.kind === 261 || node.kind === 260 || node.kind === 228 || isJSConstructor(node) || isTypeAlias(node)) {
                const declaration = node;
                result = appendTypeParameters(result, getEffectiveTypeParameterDeclarations(declaration));
            }
        }
        return result;
    }
    function getTypeParametersOfClassOrInterface(symbol) {
        return concatenate(getOuterTypeParametersOfClassOrInterface(symbol), getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol));
    }
    function isMixinConstructorType(type) {
        const signatures = getSignaturesOfType(type, 1);
        if (signatures.length === 1) {
            const s = signatures[0];
            if (!s.typeParameters && s.parameters.length === 1 && signatureHasRestParameter(s)) {
                const paramType = getTypeOfParameter(s.parameters[0]);
                return isTypeAny(paramType) || getElementTypeOfArrayType(paramType) === anyType;
            }
        }
        return false;
    }
    function isConstructorType(type) {
        if (getSignaturesOfType(type, 1).length > 0) {
            return true;
        }
        if (type.flags & 8650752) {
            const constraint = getBaseConstraintOfType(type);
            return !!constraint && isMixinConstructorType(constraint);
        }
        return false;
    }
    function getBaseTypeNodeOfClass(type) {
        const decl = getClassLikeDeclarationOfSymbol(type.symbol);
        return decl && getEffectiveBaseTypeNode(decl);
    }
    function getConstructorsForTypeArguments(type, typeArgumentNodes, location) {
        const typeArgCount = length(typeArgumentNodes);
        const isJavascript = isInJSFile(location);
        return filter(getSignaturesOfType(type, 1), sig => (isJavascript || typeArgCount >= getMinTypeArgumentCount(sig.typeParameters)) && typeArgCount <= length(sig.typeParameters));
    }
    function getInstantiatedConstructorsForTypeArguments(type, typeArgumentNodes, location) {
        const signatures = getConstructorsForTypeArguments(type, typeArgumentNodes, location);
        const typeArguments = map(typeArgumentNodes, getTypeFromTypeNode);
        return sameMap(signatures, sig => some(sig.typeParameters) ? getSignatureInstantiation(sig, typeArguments, isInJSFile(location)) : sig);
    }
    function getBaseConstructorTypeOfClass(type) {
        if (!type.resolvedBaseConstructorType) {
            const decl = getClassLikeDeclarationOfSymbol(type.symbol);
            const extended = decl && getEffectiveBaseTypeNode(decl);
            const baseTypeNode = getBaseTypeNodeOfClass(type);
            if (!baseTypeNode) {
                return type.resolvedBaseConstructorType = undefinedType;
            }
            if (!pushTypeResolution(type, 1)) {
                return errorType;
            }
            const baseConstructorType = checkExpression(baseTypeNode.expression);
            if (extended && baseTypeNode !== extended) {
                Debug.assert(!extended.typeArguments);
                checkExpression(extended.expression);
            }
            if (baseConstructorType.flags & (524288 | 2097152)) {
                resolveStructuredTypeMembers(baseConstructorType);
            }
            if (!popTypeResolution()) {
                error(type.symbol.valueDeclaration, Diagnostics._0_is_referenced_directly_or_indirectly_in_its_own_base_expression, symbolToString(type.symbol));
                return type.resolvedBaseConstructorType = errorType;
            }
            if (!(baseConstructorType.flags & 1) && baseConstructorType !== nullWideningType && !isConstructorType(baseConstructorType)) {
                const err = error(baseTypeNode.expression, Diagnostics.Type_0_is_not_a_constructor_function_type, typeToString(baseConstructorType));
                if (baseConstructorType.flags & 262144) {
                    const constraint = getConstraintFromTypeParameter(baseConstructorType);
                    let ctorReturn = unknownType;
                    if (constraint) {
                        const ctorSig = getSignaturesOfType(constraint, 1);
                        if (ctorSig[0]) {
                            ctorReturn = getReturnTypeOfSignature(ctorSig[0]);
                        }
                    }
                    if (baseConstructorType.symbol.declarations) {
                        addRelatedInfo(err, createDiagnosticForNode(baseConstructorType.symbol.declarations[0], Diagnostics.Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1, symbolToString(baseConstructorType.symbol), typeToString(ctorReturn)));
                    }
                }
                return type.resolvedBaseConstructorType = errorType;
            }
            type.resolvedBaseConstructorType = baseConstructorType;
        }
        return type.resolvedBaseConstructorType;
    }
    function getImplementsTypes(type) {
        let resolvedImplementsTypes = emptyArray;
        if (type.symbol.declarations) {
            for (const declaration of type.symbol.declarations) {
                const implementsTypeNodes = getEffectiveImplementsTypeNodes(declaration);
                if (!implementsTypeNodes) continue;
                for (const node of implementsTypeNodes) {
                    const implementsType = getTypeFromTypeNode(node);
                    if (!isErrorType(implementsType)) {
                        if (resolvedImplementsTypes === emptyArray) {
                            resolvedImplementsTypes = [implementsType];
                        } else {
                            resolvedImplementsTypes.push(implementsType);
                        }
                    }
                }
            }
        }
        return resolvedImplementsTypes;
    }
    function reportCircularBaseType(node, type) {
        error(node, Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, void 0, 2));
    }
    function getBaseTypes(type) {
        if (!type.baseTypesResolved) {
            if (pushTypeResolution(type, 7)) {
                if (type.objectFlags & 8) {
                    type.resolvedBaseTypes = [getTupleBaseType(type)];
                } else if (type.symbol.flags & (32 | 64)) {
                    if (type.symbol.flags & 32) {
                        resolveBaseTypesOfClass(type);
                    }
                    if (type.symbol.flags & 64) {
                        resolveBaseTypesOfInterface(type);
                    }
                } else {
                    Debug.fail("type must be class or interface");
                }
                if (!popTypeResolution() && type.symbol.declarations) {
                    for (const declaration of type.symbol.declarations) {
                        if (declaration.kind === 260 || declaration.kind === 261) {
                            reportCircularBaseType(declaration, type);
                        }
                    }
                }
            }
            type.baseTypesResolved = true;
        }
        return type.resolvedBaseTypes;
    }
    function getTupleBaseType(type) {
        const elementTypes = sameMap(type.typeParameters, (t, i) => type.elementFlags[i] & 8 ? getIndexedAccessType(t, numberType) : t);
        return createArrayType(getUnionType(elementTypes || emptyArray), type.readonly);
    }
    function resolveBaseTypesOfClass(type) {
        type.resolvedBaseTypes = resolvingEmptyArray;
        const baseConstructorType = getApparentType(getBaseConstructorTypeOfClass(type));
        if (!(baseConstructorType.flags & (524288 | 2097152 | 1))) {
            return type.resolvedBaseTypes = emptyArray;
        }
        const baseTypeNode = getBaseTypeNodeOfClass(type);
        let baseType;
        const originalBaseType = baseConstructorType.symbol ? getDeclaredTypeOfSymbol(baseConstructorType.symbol) : void 0;
        if (baseConstructorType.symbol && baseConstructorType.symbol.flags & 32 && areAllOuterTypeParametersApplied(originalBaseType)) {
            baseType = getTypeFromClassOrInterfaceReference(baseTypeNode, baseConstructorType.symbol);
        } else if (baseConstructorType.flags & 1) {
            baseType = baseConstructorType;
        } else {
            const constructors = getInstantiatedConstructorsForTypeArguments(baseConstructorType, baseTypeNode.typeArguments, baseTypeNode);
            if (!constructors.length) {
                error(baseTypeNode.expression, Diagnostics.No_base_constructor_has_the_specified_number_of_type_arguments);
                return type.resolvedBaseTypes = emptyArray;
            }
            baseType = getReturnTypeOfSignature(constructors[0]);
        }
        if (isErrorType(baseType)) {
            return type.resolvedBaseTypes = emptyArray;
        }
        const reducedBaseType = getReducedType(baseType);
        if (!isValidBaseType(reducedBaseType)) {
            const elaboration = elaborateNeverIntersection(void 0, baseType);
            const diagnostic = chainDiagnosticMessages(elaboration, Diagnostics.Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members, typeToString(reducedBaseType));
            diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(baseTypeNode.expression), baseTypeNode.expression, diagnostic));
            return type.resolvedBaseTypes = emptyArray;
        }
        if (type === reducedBaseType || hasBaseType(reducedBaseType, type)) {
            error(type.symbol.valueDeclaration, Diagnostics.Type_0_recursively_references_itself_as_a_base_type, typeToString(type, void 0, 2));
            return type.resolvedBaseTypes = emptyArray;
        }
        if (type.resolvedBaseTypes === resolvingEmptyArray) {
            type.members = void 0;
        }
        return type.resolvedBaseTypes = [reducedBaseType];
    }
    function areAllOuterTypeParametersApplied(type) {
        const outerTypeParameters = type.outerTypeParameters;
        if (outerTypeParameters) {
            const last2 = outerTypeParameters.length - 1;
            const typeArguments = getTypeArguments(type);
            return outerTypeParameters[last2].symbol !== typeArguments[last2].symbol;
        }
        return true;
    }
    function isValidBaseType(type) {
        if (type.flags & 262144) {
            const constraint = getBaseConstraintOfType(type);
            if (constraint) {
                return isValidBaseType(constraint);
            }
        }
        return !!(type.flags & (524288 | 67108864 | 1) && !isGenericMappedType(type) || type.flags & 2097152 && every(type.types, isValidBaseType));
    }
    function resolveBaseTypesOfInterface(type) {
        type.resolvedBaseTypes = type.resolvedBaseTypes || emptyArray;
        if (type.symbol.declarations) {
            for (const declaration of type.symbol.declarations) {
                if (declaration.kind === 261 && getInterfaceBaseTypeNodes(declaration)) {
                    for (const node of getInterfaceBaseTypeNodes(declaration)) {
                        const baseType = getReducedType(getTypeFromTypeNode(node));
                        if (!isErrorType(baseType)) {
                            if (isValidBaseType(baseType)) {
                                if (type !== baseType && !hasBaseType(baseType, type)) {
                                    if (type.resolvedBaseTypes === emptyArray) {
                                        type.resolvedBaseTypes = [baseType];
                                    } else {
                                        type.resolvedBaseTypes.push(baseType);
                                    }
                                } else {
                                    reportCircularBaseType(declaration, type);
                                }
                            } else {
                                error(node, Diagnostics.An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members);
                            }
                        }
                    }
                }
            }
        }
    }
    function isThislessInterface(symbol) {
        if (!symbol.declarations) {
            return true;
        }
        for (const declaration of symbol.declarations) {
            if (declaration.kind === 261) {
                if (declaration.flags & 128) {
                    return false;
                }
                const baseTypeNodes = getInterfaceBaseTypeNodes(declaration);
                if (baseTypeNodes) {
                    for (const node of baseTypeNodes) {
                        if (isEntityNameExpression(node.expression)) {
                            const baseSymbol = resolveEntityName(node.expression, 788968, true);
                            if (!baseSymbol || !(baseSymbol.flags & 64) || getDeclaredTypeOfClassOrInterface(baseSymbol).thisType) {
                                return false;
                            }
                        }
                    }
                }
            }
        }
        return true;
    }
    function getDeclaredTypeOfClassOrInterface(symbol) {
        let links = getSymbolLinks(symbol);
        const originalLinks = links;
        if (!links.declaredType) {
            const kind = symbol.flags & 32 ? 1 : 2;
            const merged = mergeJSSymbols(symbol, symbol.valueDeclaration && getAssignedClassSymbol(symbol.valueDeclaration));
            if (merged) {
                symbol = merged;
                links = merged.links;
            }
            const type = originalLinks.declaredType = links.declaredType = createObjectType(kind, symbol);
            const outerTypeParameters = getOuterTypeParametersOfClassOrInterface(symbol);
            const localTypeParameters = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
            if (outerTypeParameters || localTypeParameters || kind === 1 || !isThislessInterface(symbol)) {
                type.objectFlags |= 4;
                type.typeParameters = concatenate(outerTypeParameters, localTypeParameters);
                type.outerTypeParameters = outerTypeParameters;
                type.localTypeParameters = localTypeParameters;
                type.instantiations = /* @__PURE__ */new Map();
                type.instantiations.set(getTypeListId(type.typeParameters), type);
                type.target = type;
                type.resolvedTypeArguments = type.typeParameters;
                type.thisType = createTypeParameter(symbol);
                type.thisType.isThisType = true;
                type.thisType.constraint = type;
            }
        }
        return links.declaredType;
    }
    function getDeclaredTypeOfTypeAlias(symbol) {
        var _a2;
        const links = getSymbolLinks(symbol);
        if (!links.declaredType) {
            if (!pushTypeResolution(symbol, 2)) {
                return errorType;
            }
            const declaration = Debug.checkDefined((_a2 = symbol.declarations) == null ? void 0 : _a2.find(isTypeAlias), "Type alias symbol with no valid declaration found");
            const typeNode = isJSDocTypeAlias(declaration) ? declaration.typeExpression : declaration.type;
            let type = typeNode ? getTypeFromTypeNode(typeNode) : errorType;
            if (popTypeResolution()) {
                const typeParameters = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol);
                if (typeParameters) {
                    links.typeParameters = typeParameters;
                    links.instantiations = /* @__PURE__ */new Map();
                    links.instantiations.set(getTypeListId(typeParameters), type);
                }
            } else {
                type = errorType;
                if (declaration.kind === 343) {
                    error(declaration.typeExpression.type, Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol));
                } else {
                    error(isNamedDeclaration(declaration) ? declaration.name || declaration : declaration, Diagnostics.Type_alias_0_circularly_references_itself, symbolToString(symbol));
                }
            }
            links.declaredType = type;
        }
        return links.declaredType;
    }
    function getBaseTypeOfEnumLikeType(type) {
        return type.flags & 1056 && type.symbol.flags & 8 ? getDeclaredTypeOfSymbol(getParentOfSymbol(type.symbol)) : type;
    }
    function getDeclaredTypeOfEnum(symbol) {
        const links = getSymbolLinks(symbol);
        if (!links.declaredType) {
            const memberTypeList = [];
            if (symbol.declarations) {
                for (const declaration of symbol.declarations) {
                    if (declaration.kind === 263) {
                        for (const member of declaration.members) {
                            if (hasBindableName(member)) {
                                const memberSymbol = getSymbolOfDeclaration(member);
                                const value = getEnumMemberValue(member);
                                const memberType = getFreshTypeOfLiteralType(value !== void 0 ? getEnumLiteralType(value, getSymbolId(symbol), memberSymbol) : createComputedEnumType(memberSymbol));
                                getSymbolLinks(memberSymbol).declaredType = memberType;
                                memberTypeList.push(getRegularTypeOfLiteralType(memberType));
                            }
                        }
                    }
                }
            }
            const enumType = memberTypeList.length ? getUnionType(memberTypeList, 1, symbol, void 0) : createComputedEnumType(symbol);
            if (enumType.flags & 1048576) {
                enumType.flags |= 1024;
                enumType.symbol = symbol;
            }
            links.declaredType = enumType;
        }
        return links.declaredType;
    }
    function createComputedEnumType(symbol) {
        const regularType = createTypeWithSymbol(32, symbol);
        const freshType = createTypeWithSymbol(32, symbol);
        regularType.regularType = regularType;
        regularType.freshType = freshType;
        freshType.regularType = regularType;
        freshType.freshType = freshType;
        return regularType;
    }
    function getDeclaredTypeOfEnumMember(symbol) {
        const links = getSymbolLinks(symbol);
        if (!links.declaredType) {
            const enumType = getDeclaredTypeOfEnum(getParentOfSymbol(symbol));
            if (!links.declaredType) {
                links.declaredType = enumType;
            }
        }
        return links.declaredType;
    }
    function getDeclaredTypeOfTypeParameter(symbol) {
        const links = getSymbolLinks(symbol);
        return links.declaredType || (links.declaredType = createTypeParameter(symbol));
    }
    function getDeclaredTypeOfAlias(symbol) {
        const links = getSymbolLinks(symbol);
        return links.declaredType || (links.declaredType = getDeclaredTypeOfSymbol(resolveAlias(symbol)));
    }
    function getDeclaredTypeOfSymbol(symbol) {
        return tryGetDeclaredTypeOfSymbol(symbol) || errorType;
    }
    function tryGetDeclaredTypeOfSymbol(symbol) {
        if (symbol.flags & (32 | 64)) {
            return getDeclaredTypeOfClassOrInterface(symbol);
        }
        if (symbol.flags & 524288) {
            return getDeclaredTypeOfTypeAlias(symbol);
        }
        if (symbol.flags & 262144) {
            return getDeclaredTypeOfTypeParameter(symbol);
        }
        if (symbol.flags & 384) {
            return getDeclaredTypeOfEnum(symbol);
        }
        if (symbol.flags & 8) {
            return getDeclaredTypeOfEnumMember(symbol);
        }
        if (symbol.flags & 2097152) {
            return getDeclaredTypeOfAlias(symbol);
        }
        return void 0;
    }
    function isThislessType(node) {
        switch (node.kind) {
            case 131:
            case 157:
            case 152:
            case 148:
            case 160:
            case 134:
            case 153:
            case 149:
            case 114:
            case 155:
            case 144:
            case 198:
                return true;
            case 185:
                return isThislessType(node.elementType);
            case 180:
                return !node.typeArguments || node.typeArguments.every(isThislessType);
        }
        return false;
    }
    function isThislessTypeParameter(node) {
        const constraint = getEffectiveConstraintOfTypeParameter(node);
        return !constraint || isThislessType(constraint);
    }
    function isThislessVariableLikeDeclaration(node) {
        const typeNode = getEffectiveTypeAnnotationNode(node);
        return typeNode ? isThislessType(typeNode) : !hasInitializer(node);
    }
    function isThislessFunctionLikeDeclaration(node) {
        const returnType = getEffectiveReturnTypeNode(node);
        const typeParameters = getEffectiveTypeParameterDeclarations(node);
        return (node.kind === 173 || !!returnType && isThislessType(returnType)) && node.parameters.every(isThislessVariableLikeDeclaration) && typeParameters.every(isThislessTypeParameter);
    }
    function isThisless(symbol) {
        if (symbol.declarations && symbol.declarations.length === 1) {
            const declaration = symbol.declarations[0];
            if (declaration) {
                switch (declaration.kind) {
                    case 169:
                    case 168:
                        return isThislessVariableLikeDeclaration(declaration);
                    case 171:
                    case 170:
                    case 173:
                    case 174:
                    case 175:
                        return isThislessFunctionLikeDeclaration(declaration);
                }
            }
        }
        return false;
    }
    function createInstantiatedSymbolTable(symbols, mapper, mappingThisOnly) {
        const result = createSymbolTable();
        for (const symbol of symbols) {
            result.set(symbol.escapedName, mappingThisOnly && isThisless(symbol) ? symbol : instantiateSymbol(symbol, mapper));
        }
        return result;
    }
    function addInheritedMembers(symbols, baseSymbols) {
        for (const s of baseSymbols) {
            if (!symbols.has(s.escapedName) && !isStaticPrivateIdentifierProperty(s)) {
                symbols.set(s.escapedName, s);
            }
        }
    }
    function isStaticPrivateIdentifierProperty(s) {
        return !!s.valueDeclaration && isPrivateIdentifierClassElementDeclaration(s.valueDeclaration) && isStatic(s.valueDeclaration);
    }
    function resolveDeclaredMembers(type) {
        if (!type.declaredProperties) {
            const symbol = type.symbol;
            const members = getMembersOfSymbol(symbol);
            type.declaredProperties = getNamedMembers(members);
            type.declaredCallSignatures = emptyArray;
            type.declaredConstructSignatures = emptyArray;
            type.declaredIndexInfos = emptyArray;
            type.declaredCallSignatures = getSignaturesOfSymbol(members.get("__call"));
            type.declaredConstructSignatures = getSignaturesOfSymbol(members.get("__new"));
            type.declaredIndexInfos = getIndexInfosOfSymbol(symbol);
        }
        return type;
    }
    function isTypeUsableAsPropertyName(type) {
        return !!(type.flags & 8576);
    }
    function isLateBindableName(node) {
        if (!isComputedPropertyName(node) && !isElementAccessExpression(node)) {
            return false;
        }
        const expr = isComputedPropertyName(node) ? node.expression : node.argumentExpression;
        return isEntityNameExpression(expr) && isTypeUsableAsPropertyName(isComputedPropertyName(node) ? checkComputedPropertyName(node) : checkExpressionCached(expr));
    }
    function isLateBoundName(name) {
        return name.charCodeAt(0) === 95 && name.charCodeAt(1) === 95 && name.charCodeAt(2) === 64;
    }
    function hasLateBindableName(node) {
        const name = getNameOfDeclaration(node);
        return !!name && isLateBindableName(name);
    }
    function hasBindableName(node) {
        return !hasDynamicName(node) || hasLateBindableName(node);
    }
    function isNonBindableDynamicName(node) {
        return isDynamicName(node) && !isLateBindableName(node);
    }
    function getPropertyNameFromType(type) {
        if (type.flags & 8192) {
            return type.escapedName;
        }
        if (type.flags & (128 | 256)) {
            return escapeLeadingUnderscores("" + type.value);
        }
        return Debug.fail();
    }
    function addDeclarationToLateBoundSymbol(symbol, member, symbolFlags) {
        Debug.assert(!!(getCheckFlags(symbol) & 4096), "Expected a late-bound symbol.");
        symbol.flags |= symbolFlags;
        getSymbolLinks(member.symbol).lateSymbol = symbol;
        if (!symbol.declarations) {
            symbol.declarations = [member];
        } else if (!member.symbol.isReplaceableByMethod) {
            symbol.declarations.push(member);
        }
        if (symbolFlags & 111551) {
            if (!symbol.valueDeclaration || symbol.valueDeclaration.kind !== member.kind) {
                symbol.valueDeclaration = member;
            }
        }
    }
    function lateBindMember(parent2, earlySymbols, lateSymbols, decl) {
        Debug.assert(!!decl.symbol, "The member is expected to have a symbol.");
        const links = getNodeLinks(decl);
        if (!links.resolvedSymbol) {
            links.resolvedSymbol = decl.symbol;
            const declName = isBinaryExpression(decl) ? decl.left : decl.name;
            const type = isElementAccessExpression(declName) ? checkExpressionCached(declName.argumentExpression) : checkComputedPropertyName(declName);
            if (isTypeUsableAsPropertyName(type)) {
                const memberName = getPropertyNameFromType(type);
                const symbolFlags = decl.symbol.flags;
                let lateSymbol = lateSymbols.get(memberName);
                if (!lateSymbol) lateSymbols.set(memberName, lateSymbol = createSymbol(0, memberName, 4096));
                const earlySymbol = earlySymbols && earlySymbols.get(memberName);
                if (lateSymbol.flags & getExcludedSymbolFlags(symbolFlags) || earlySymbol) {
                    const declarations = earlySymbol ? concatenate(earlySymbol.declarations, lateSymbol.declarations) : lateSymbol.declarations;
                    const name = !(type.flags & 8192) && unescapeLeadingUnderscores(memberName) || declarationNameToString(declName);
                    forEach(declarations, declaration => error(getNameOfDeclaration(declaration) || declaration, Diagnostics.Property_0_was_also_declared_here, name));
                    error(declName || decl, Diagnostics.Duplicate_property_0, name);
                    lateSymbol = createSymbol(0, memberName, 4096);
                }
                lateSymbol.links.nameType = type;
                addDeclarationToLateBoundSymbol(lateSymbol, decl, symbolFlags);
                if (lateSymbol.parent) {
                    Debug.assert(lateSymbol.parent === parent2, "Existing symbol parent should match new one");
                } else {
                    lateSymbol.parent = parent2;
                }
                return links.resolvedSymbol = lateSymbol;
            }
        }
        return links.resolvedSymbol;
    }
    function getResolvedMembersOrExportsOfSymbol(symbol, resolutionKind) {
        const links = getSymbolLinks(symbol);
        if (!links[resolutionKind]) {
            const isStatic2 = resolutionKind === "resolvedExports";
            const earlySymbols = !isStatic2 ? symbol.members : symbol.flags & 1536 ? getExportsOfModuleWorker(symbol).exports : symbol.exports;
            links[resolutionKind] = earlySymbols || emptySymbols;
            const lateSymbols = createSymbolTable();
            for (const decl of symbol.declarations || emptyArray) {
                const members = getMembersOfDeclaration(decl);
                if (members) {
                    for (const member of members) {
                        if (isStatic2 === hasStaticModifier(member)) {
                            if (hasLateBindableName(member)) {
                                lateBindMember(symbol, earlySymbols, lateSymbols, member);
                            }
                        }
                    }
                }
            }
            const assignments = symbol.assignmentDeclarationMembers;
            if (assignments) {
                const decls = arrayFrom(assignments.values());
                for (const member of decls) {
                    const assignmentKind = getAssignmentDeclarationKind(member);
                    const isInstanceMember = assignmentKind === 3 || isBinaryExpression(member) && isPossiblyAliasedThisProperty(member, assignmentKind) || assignmentKind === 9 || assignmentKind === 6;
                    if (isStatic2 === !isInstanceMember) {
                        if (hasLateBindableName(member)) {
                            lateBindMember(symbol, earlySymbols, lateSymbols, member);
                        }
                    }
                }
            }
            links[resolutionKind] = combineSymbolTables(earlySymbols, lateSymbols) || emptySymbols;
        }
        return links[resolutionKind];
    }
    function getMembersOfSymbol(symbol) {
        return symbol.flags & 6256 ? getResolvedMembersOrExportsOfSymbol(symbol, "resolvedMembers") : symbol.members || emptySymbols;
    }
    function getLateBoundSymbol(symbol) {
        if (symbol.flags & 106500 && symbol.escapedName === "__computed") {
            const links = getSymbolLinks(symbol);
            if (!links.lateSymbol && some(symbol.declarations, hasLateBindableName)) {
                const parent2 = getMergedSymbol(symbol.parent);
                if (some(symbol.declarations, hasStaticModifier)) {
                    getExportsOfSymbol(parent2);
                } else {
                    getMembersOfSymbol(parent2);
                }
            }
            return links.lateSymbol || (links.lateSymbol = symbol);
        }
        return symbol;
    }
    function getTypeWithThisArgument(type, thisArgument, needApparentType) {
        if (getObjectFlags(type) & 4) {
            const target = type.target;
            const typeArguments = getTypeArguments(type);
            if (length(target.typeParameters) === length(typeArguments)) {
                const ref = createTypeReference(target, concatenate(typeArguments, [thisArgument || target.thisType]));
                return needApparentType ? getApparentType(ref) : ref;
            }
        } else if (type.flags & 2097152) {
            const types = sameMap(type.types, t => getTypeWithThisArgument(t, thisArgument, needApparentType));
            return types !== type.types ? getIntersectionType(types) : type;
        }
        return needApparentType ? getApparentType(type) : type;
    }
    function resolveObjectTypeMembers(type, source, typeParameters, typeArguments) {
        let mapper;
        let members;
        let callSignatures;
        let constructSignatures;
        let indexInfos;
        if (rangeEquals(typeParameters, typeArguments, 0, typeParameters.length)) {
            members = source.symbol ? getMembersOfSymbol(source.symbol) : createSymbolTable(source.declaredProperties);
            callSignatures = source.declaredCallSignatures;
            constructSignatures = source.declaredConstructSignatures;
            indexInfos = source.declaredIndexInfos;
        } else {
            mapper = createTypeMapper(typeParameters, typeArguments);
            members = createInstantiatedSymbolTable(source.declaredProperties, mapper, typeParameters.length === 1);
            callSignatures = instantiateSignatures(source.declaredCallSignatures, mapper);
            constructSignatures = instantiateSignatures(source.declaredConstructSignatures, mapper);
            indexInfos = instantiateIndexInfos(source.declaredIndexInfos, mapper);
        }
        const baseTypes = getBaseTypes(source);
        if (baseTypes.length) {
            if (source.symbol && members === getMembersOfSymbol(source.symbol)) {
                members = createSymbolTable(source.declaredProperties);
            }
            setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos);
            const thisArgument = lastOrUndefined(typeArguments);
            for (const baseType of baseTypes) {
                const instantiatedBaseType = thisArgument ? getTypeWithThisArgument(instantiateType(baseType, mapper), thisArgument) : baseType;
                addInheritedMembers(members, getPropertiesOfType(instantiatedBaseType));
                callSignatures = concatenate(callSignatures, getSignaturesOfType(instantiatedBaseType, 0));
                constructSignatures = concatenate(constructSignatures, getSignaturesOfType(instantiatedBaseType, 1));
                const inheritedIndexInfos = instantiatedBaseType !== anyType ? getIndexInfosOfType(instantiatedBaseType) : [createIndexInfo(stringType, anyType, false)];
                indexInfos = concatenate(indexInfos, filter(inheritedIndexInfos, info => !findIndexInfo(indexInfos, info.keyType)));
            }
        }
        setStructuredTypeMembers(type, members, callSignatures, constructSignatures, indexInfos);
    }
    function resolveClassOrInterfaceMembers(type) {
        resolveObjectTypeMembers(type, resolveDeclaredMembers(type), emptyArray, emptyArray);
    }
    function resolveTypeReferenceMembers(type) {
        const source = resolveDeclaredMembers(type.target);
        const typeParameters = concatenate(source.typeParameters, [source.thisType]);
        const typeArguments = getTypeArguments(type);
        const paddedTypeArguments = typeArguments.length === typeParameters.length ? typeArguments : concatenate(typeArguments, [type]);
        resolveObjectTypeMembers(type, source, typeParameters, paddedTypeArguments);
    }
    function createSignature(declaration, typeParameters, thisParameter, parameters, resolvedReturnType, resolvedTypePredicate, minArgumentCount, flags) {
        const sig = new Signature15(checker, flags);
        sig.declaration = declaration;
        sig.typeParameters = typeParameters;
        sig.parameters = parameters;
        sig.thisParameter = thisParameter;
        sig.resolvedReturnType = resolvedReturnType;
        sig.resolvedTypePredicate = resolvedTypePredicate;
        sig.minArgumentCount = minArgumentCount;
        sig.resolvedMinArgumentCount = void 0;
        sig.target = void 0;
        sig.mapper = void 0;
        sig.compositeSignatures = void 0;
        sig.compositeKind = void 0;
        return sig;
    }
    function cloneSignature(sig) {
        const result = createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, void 0, void 0, sig.minArgumentCount, sig.flags & 39);
        result.target = sig.target;
        result.mapper = sig.mapper;
        result.compositeSignatures = sig.compositeSignatures;
        result.compositeKind = sig.compositeKind;
        return result;
    }
    function createUnionSignature(signature, unionSignatures) {
        const result = cloneSignature(signature);
        result.compositeSignatures = unionSignatures;
        result.compositeKind = 1048576;
        result.target = void 0;
        result.mapper = void 0;
        return result;
    }
    function getOptionalCallSignature(signature, callChainFlags) {
        if ((signature.flags & 24) === callChainFlags) {
            return signature;
        }
        if (!signature.optionalCallSignatureCache) {
            signature.optionalCallSignatureCache = {};
        }
        const key = callChainFlags === 8 ? "inner" : "outer";
        return signature.optionalCallSignatureCache[key] || (signature.optionalCallSignatureCache[key] = createOptionalCallSignature(signature, callChainFlags));
    }
    function createOptionalCallSignature(signature, callChainFlags) {
        Debug.assert(callChainFlags === 8 || callChainFlags === 16, "An optional call signature can either be for an inner call chain or an outer call chain, but not both.");
        const result = cloneSignature(signature);
        result.flags |= callChainFlags;
        return result;
    }
    function getExpandedParameters(sig, skipUnionExpanding) {
        if (signatureHasRestParameter(sig)) {
            const restIndex = sig.parameters.length - 1;
            const restType = getTypeOfSymbol(sig.parameters[restIndex]);
            if (isTupleType(restType)) {
                return [expandSignatureParametersWithTupleMembers(restType, restIndex)];
            } else if (!skipUnionExpanding && restType.flags & 1048576 && every(restType.types, isTupleType)) {
                return map(restType.types, t => expandSignatureParametersWithTupleMembers(t, restIndex));
            }
        }
        return [sig.parameters];
        function expandSignatureParametersWithTupleMembers(restType, restIndex) {
            const elementTypes = getTypeArguments(restType);
            const associatedNames = restType.target.labeledElementDeclarations;
            const restParams = map(elementTypes, (t, i) => {
                const tupleLabelName = !!associatedNames && getTupleElementLabel(associatedNames[i]);
                const name = tupleLabelName || getParameterNameAtPosition(sig, restIndex + i, restType);
                const flags = restType.target.elementFlags[i];
                const checkFlags = flags & 12 ? 32768 : flags & 2 ? 16384 : 0;
                const symbol = createSymbol(1, name, checkFlags);
                symbol.links.type = flags & 4 ? createArrayType(t) : t;
                return symbol;
            });
            return concatenate(sig.parameters.slice(0, restIndex), restParams);
        }
    }
    function getDefaultConstructSignatures(classType) {
        const baseConstructorType = getBaseConstructorTypeOfClass(classType);
        const baseSignatures = getSignaturesOfType(baseConstructorType, 1);
        const declaration = getClassLikeDeclarationOfSymbol(classType.symbol);
        const isAbstract = !!declaration && hasSyntacticModifier(declaration, 256);
        if (baseSignatures.length === 0) {
            return [createSignature(void 0, classType.localTypeParameters, void 0, emptyArray, classType, void 0, 0, isAbstract ? 4 : 0)];
        }
        const baseTypeNode = getBaseTypeNodeOfClass(classType);
        const isJavaScript = isInJSFile(baseTypeNode);
        const typeArguments = typeArgumentsFromTypeReferenceNode(baseTypeNode);
        const typeArgCount = length(typeArguments);
        const result = [];
        for (const baseSig of baseSignatures) {
            const minTypeArgumentCount = getMinTypeArgumentCount(baseSig.typeParameters);
            const typeParamCount = length(baseSig.typeParameters);
            if (isJavaScript || typeArgCount >= minTypeArgumentCount && typeArgCount <= typeParamCount) {
                const sig = typeParamCount ? createSignatureInstantiation(baseSig, fillMissingTypeArguments(typeArguments, baseSig.typeParameters, minTypeArgumentCount, isJavaScript)) : cloneSignature(baseSig);
                sig.typeParameters = classType.localTypeParameters;
                sig.resolvedReturnType = classType;
                sig.flags = isAbstract ? sig.flags | 4 : sig.flags & ~4;
                result.push(sig);
            }
        }
        return result;
    }
    function findMatchingSignature(signatureList, signature, partialMatch, ignoreThisTypes, ignoreReturnTypes) {
        for (const s of signatureList) {
            if (compareSignaturesIdentical(s, signature, partialMatch, ignoreThisTypes, ignoreReturnTypes, partialMatch ? compareTypesSubtypeOf : compareTypesIdentical)) {
                return s;
            }
        }
    }
    function findMatchingSignatures(signatureLists, signature, listIndex) {
        if (signature.typeParameters) {
            if (listIndex > 0) {
                return void 0;
            }
            for (let i = 1; i < signatureLists.length; i++) {
                if (!findMatchingSignature(signatureLists[i], signature, false, false, false)) {
                    return void 0;
                }
            }
            return [signature];
        }
        let result;
        for (let i = 0; i < signatureLists.length; i++) {
            const match = i === listIndex ? signature : findMatchingSignature(signatureLists[i], signature, true, false, true);
            if (!match) {
                return void 0;
            }
            result = appendIfUnique(result, match);
        }
        return result;
    }
    function getUnionSignatures(signatureLists) {
        let result;
        let indexWithLengthOverOne;
        for (let i = 0; i < signatureLists.length; i++) {
            if (signatureLists[i].length === 0) return emptyArray;
            if (signatureLists[i].length > 1) {
                indexWithLengthOverOne = indexWithLengthOverOne === void 0 ? i : -1;
            }
            for (const signature of signatureLists[i]) {
                if (!result || !findMatchingSignature(result, signature, false, false, true)) {
                    const unionSignatures = findMatchingSignatures(signatureLists, signature, i);
                    if (unionSignatures) {
                        let s = signature;
                        if (unionSignatures.length > 1) {
                            let thisParameter = signature.thisParameter;
                            const firstThisParameterOfUnionSignatures = forEach(unionSignatures, sig => sig.thisParameter);
                            if (firstThisParameterOfUnionSignatures) {
                                const thisType = getIntersectionType(mapDefined(unionSignatures, sig => sig.thisParameter && getTypeOfSymbol(sig.thisParameter)));
                                thisParameter = createSymbolWithType(firstThisParameterOfUnionSignatures, thisType);
                            }
                            s = createUnionSignature(signature, unionSignatures);
                            s.thisParameter = thisParameter;
                        }
                        (result || (result = [])).push(s);
                    }
                }
            }
        }
        if (!length(result) && indexWithLengthOverOne !== -1) {
            const masterList = signatureLists[indexWithLengthOverOne !== void 0 ? indexWithLengthOverOne : 0];
            let results = masterList.slice();
            for (const signatures of signatureLists) {
                if (signatures !== masterList) {
                    const signature = signatures[0];
                    Debug.assert(!!signature, "getUnionSignatures bails early on empty signature lists and should not have empty lists on second pass");
                    results = !!signature.typeParameters && some(results, s => !!s.typeParameters && !compareTypeParametersIdentical(signature.typeParameters, s.typeParameters)) ? void 0 : map(results, sig => combineSignaturesOfUnionMembers(sig, signature));
                    if (!results) {
                        break;
                    }
                }
            }
            result = results;
        }
        return result || emptyArray;
    }
    function compareTypeParametersIdentical(sourceParams, targetParams) {
        if (length(sourceParams) !== length(targetParams)) {
            return false;
        }
        if (!sourceParams || !targetParams) {
            return true;
        }
        const mapper = createTypeMapper(targetParams, sourceParams);
        for (let i = 0; i < sourceParams.length; i++) {
            const source = sourceParams[i];
            const target = targetParams[i];
            if (source === target) continue;
            if (!isTypeIdenticalTo(getConstraintFromTypeParameter(source) || unknownType, instantiateType(getConstraintFromTypeParameter(target) || unknownType, mapper))) return false;
        }
        return true;
    }
    function combineUnionThisParam(left, right, mapper) {
        if (!left || !right) {
            return left || right;
        }
        const thisType = getIntersectionType([getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)]);
        return createSymbolWithType(left, thisType);
    }
    function combineUnionParameters(left, right, mapper) {
        const leftCount = getParameterCount(left);
        const rightCount = getParameterCount(right);
        const longest = leftCount >= rightCount ? left : right;
        const shorter = longest === left ? right : left;
        const longestCount = longest === left ? leftCount : rightCount;
        const eitherHasEffectiveRest = hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right);
        const needsExtraRestElement = eitherHasEffectiveRest && !hasEffectiveRestParameter(longest);
        const params = new Array(longestCount + (needsExtraRestElement ? 1 : 0));
        for (let i = 0; i < longestCount; i++) {
            let longestParamType = tryGetTypeAtPosition(longest, i);
            if (longest === right) {
                longestParamType = instantiateType(longestParamType, mapper);
            }
            let shorterParamType = tryGetTypeAtPosition(shorter, i) || unknownType;
            if (shorter === right) {
                shorterParamType = instantiateType(shorterParamType, mapper);
            }
            const unionParamType = getIntersectionType([longestParamType, shorterParamType]);
            const isRestParam = eitherHasEffectiveRest && !needsExtraRestElement && i === longestCount - 1;
            const isOptional = i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter);
            const leftName = i >= leftCount ? void 0 : getParameterNameAtPosition(left, i);
            const rightName = i >= rightCount ? void 0 : getParameterNameAtPosition(right, i);
            const paramName = leftName === rightName ? leftName : !leftName ? rightName : !rightName ? leftName : void 0;
            const paramSymbol = createSymbol(1 | (isOptional && !isRestParam ? 16777216 : 0), paramName || `arg${i}`);
            paramSymbol.links.type = isRestParam ? createArrayType(unionParamType) : unionParamType;
            params[i] = paramSymbol;
        }
        if (needsExtraRestElement) {
            const restParamSymbol = createSymbol(1, "args");
            restParamSymbol.links.type = createArrayType(getTypeAtPosition(shorter, longestCount));
            if (shorter === right) {
                restParamSymbol.links.type = instantiateType(restParamSymbol.links.type, mapper);
            }
            params[longestCount] = restParamSymbol;
        }
        return params;
    }
    function combineSignaturesOfUnionMembers(left, right) {
        const typeParams = left.typeParameters || right.typeParameters;
        let paramMapper;
        if (left.typeParameters && right.typeParameters) {
            paramMapper = createTypeMapper(right.typeParameters, left.typeParameters);
        }
        const declaration = left.declaration;
        const params = combineUnionParameters(left, right, paramMapper);
        const thisParam = combineUnionThisParam(left.thisParameter, right.thisParameter, paramMapper);
        const minArgCount = Math.max(left.minArgumentCount, right.minArgumentCount);
        const result = createSignature(declaration, typeParams, thisParam, params, void 0, void 0, minArgCount, (left.flags | right.flags) & 39);
        result.compositeKind = 1048576;
        result.compositeSignatures = concatenate(left.compositeKind !== 2097152 && left.compositeSignatures || [left], [right]);
        if (paramMapper) {
            result.mapper = left.compositeKind !== 2097152 && left.mapper && left.compositeSignatures ? combineTypeMappers(left.mapper, paramMapper) : paramMapper;
        }
        return result;
    }
    function getUnionIndexInfos(types) {
        const sourceInfos = getIndexInfosOfType(types[0]);
        if (sourceInfos) {
            const result = [];
            for (const info of sourceInfos) {
                const indexType = info.keyType;
                if (every(types, t => !!getIndexInfoOfType(t, indexType))) {
                    result.push(createIndexInfo(indexType, getUnionType(map(types, t => getIndexTypeOfType(t, indexType))), some(types, t => getIndexInfoOfType(t, indexType).isReadonly)));
                }
            }
            return result;
        }
        return emptyArray;
    }
    function resolveUnionTypeMembers(type) {
        const callSignatures = getUnionSignatures(map(type.types, t => t === globalFunctionType ? [unknownSignature] : getSignaturesOfType(t, 0)));
        const constructSignatures = getUnionSignatures(map(type.types, t => getSignaturesOfType(t, 1)));
        const indexInfos = getUnionIndexInfos(type.types);
        setStructuredTypeMembers(type, emptySymbols, callSignatures, constructSignatures, indexInfos);
    }
    function intersectTypes(type1, type2) {
        return !type1 ? type2 : !type2 ? type1 : getIntersectionType([type1, type2]);
    }
    function findMixins(types) {
        const constructorTypeCount = countWhere(types, t => getSignaturesOfType(t, 1).length > 0);
        const mixinFlags = map(types, isMixinConstructorType);
        if (constructorTypeCount > 0 && constructorTypeCount === countWhere(mixinFlags, b => b)) {
            const firstMixinIndex = mixinFlags.indexOf(true);
            mixinFlags[firstMixinIndex] = false;
        }
        return mixinFlags;
    }
    function includeMixinType(type, types, mixinFlags, index) {
        const mixedTypes = [];
        for (let i = 0; i < types.length; i++) {
            if (i === index) {
                mixedTypes.push(type);
            } else if (mixinFlags[i]) {
                mixedTypes.push(getReturnTypeOfSignature(getSignaturesOfType(types[i], 1)[0]));
            }
        }
        return getIntersectionType(mixedTypes);
    }
    function resolveIntersectionTypeMembers(type) {
        let callSignatures;
        let constructSignatures;
        let indexInfos;
        const types = type.types;
        const mixinFlags = findMixins(types);
        const mixinCount = countWhere(mixinFlags, b => b);
        for (let i = 0; i < types.length; i++) {
            const t = type.types[i];
            if (!mixinFlags[i]) {
                let signatures = getSignaturesOfType(t, 1);
                if (signatures.length && mixinCount > 0) {
                    signatures = map(signatures, s => {
                        const clone2 = cloneSignature(s);
                        clone2.resolvedReturnType = includeMixinType(getReturnTypeOfSignature(s), types, mixinFlags, i);
                        return clone2;
                    });
                }
                constructSignatures = appendSignatures(constructSignatures, signatures);
            }
            callSignatures = appendSignatures(callSignatures, getSignaturesOfType(t, 0));
            indexInfos = reduceLeft(getIndexInfosOfType(t), (infos, newInfo) => appendIndexInfo(infos, newInfo, false), indexInfos);
        }
        setStructuredTypeMembers(type, emptySymbols, callSignatures || emptyArray, constructSignatures || emptyArray, indexInfos || emptyArray);
    }
    function appendSignatures(signatures, newSignatures) {
        for (const sig of newSignatures) {
            if (!signatures || every(signatures, s => !compareSignaturesIdentical(s, sig, false, false, false, compareTypesIdentical))) {
                signatures = append(signatures, sig);
            }
        }
        return signatures;
    }
    function appendIndexInfo(indexInfos, newInfo, union) {
        if (indexInfos) {
            for (let i = 0; i < indexInfos.length; i++) {
                const info = indexInfos[i];
                if (info.keyType === newInfo.keyType) {
                    indexInfos[i] = createIndexInfo(info.keyType, union ? getUnionType([info.type, newInfo.type]) : getIntersectionType([info.type, newInfo.type]), union ? info.isReadonly || newInfo.isReadonly : info.isReadonly && newInfo.isReadonly);
                    return indexInfos;
                }
            }
        }
        return append(indexInfos, newInfo);
    }
    function resolveAnonymousTypeMembers(type) {
        if (type.target) {
            setStructuredTypeMembers(type, emptySymbols, emptyArray, emptyArray, emptyArray);
            const members2 = createInstantiatedSymbolTable(getPropertiesOfObjectType(type.target), type.mapper, false);
            const callSignatures = instantiateSignatures(getSignaturesOfType(type.target, 0), type.mapper);
            const constructSignatures = instantiateSignatures(getSignaturesOfType(type.target, 1), type.mapper);
            const indexInfos2 = instantiateIndexInfos(getIndexInfosOfType(type.target), type.mapper);
            setStructuredTypeMembers(type, members2, callSignatures, constructSignatures, indexInfos2);
            return;
        }
        const symbol = getMergedSymbol(type.symbol);
        if (symbol.flags & 2048) {
            setStructuredTypeMembers(type, emptySymbols, emptyArray, emptyArray, emptyArray);
            const members2 = getMembersOfSymbol(symbol);
            const callSignatures = getSignaturesOfSymbol(members2.get("__call"));
            const constructSignatures = getSignaturesOfSymbol(members2.get("__new"));
            const indexInfos2 = getIndexInfosOfSymbol(symbol);
            setStructuredTypeMembers(type, members2, callSignatures, constructSignatures, indexInfos2);
            return;
        }
        let members = emptySymbols;
        let indexInfos;
        if (symbol.exports) {
            members = getExportsOfSymbol(symbol);
            if (symbol === globalThisSymbol) {
                const varsOnly = /* @__PURE__ */new Map();
                members.forEach(p => {
                    var _a2;
                    if (!(p.flags & 418) && !(p.flags & 512 && ((_a2 = p.declarations) == null ? void 0 : _a2.length) && every(p.declarations, isAmbientModule))) {
                        varsOnly.set(p.escapedName, p);
                    }
                });
                members = varsOnly;
            }
        }
        let baseConstructorIndexInfo;
        setStructuredTypeMembers(type, members, emptyArray, emptyArray, emptyArray);
        if (symbol.flags & 32) {
            const classType = getDeclaredTypeOfClassOrInterface(symbol);
            const baseConstructorType = getBaseConstructorTypeOfClass(classType);
            if (baseConstructorType.flags & (524288 | 2097152 | 8650752)) {
                members = createSymbolTable(getNamedOrIndexSignatureMembers(members));
                addInheritedMembers(members, getPropertiesOfType(baseConstructorType));
            } else if (baseConstructorType === anyType) {
                baseConstructorIndexInfo = createIndexInfo(stringType, anyType, false);
            }
        }
        const indexSymbol = getIndexSymbolFromSymbolTable(members);
        if (indexSymbol) {
            indexInfos = getIndexInfosOfIndexSymbol(indexSymbol);
        } else {
            if (baseConstructorIndexInfo) {
                indexInfos = append(indexInfos, baseConstructorIndexInfo);
            }
            if (symbol.flags & 384 && (getDeclaredTypeOfSymbol(symbol).flags & 32 || some(type.properties, prop => !!(getTypeOfSymbol(prop).flags & 296)))) {
                indexInfos = append(indexInfos, enumNumberIndexInfo);
            }
        }
        setStructuredTypeMembers(type, members, emptyArray, emptyArray, indexInfos || emptyArray);
        if (symbol.flags & (16 | 8192)) {
            type.callSignatures = getSignaturesOfSymbol(symbol);
        }
        if (symbol.flags & 32) {
            const classType = getDeclaredTypeOfClassOrInterface(symbol);
            let constructSignatures = symbol.members ? getSignaturesOfSymbol(symbol.members.get("__constructor")) : emptyArray;
            if (symbol.flags & 16) {
                constructSignatures = addRange(constructSignatures.slice(), mapDefined(type.callSignatures, sig => isJSConstructor(sig.declaration) ? createSignature(sig.declaration, sig.typeParameters, sig.thisParameter, sig.parameters, classType, void 0, sig.minArgumentCount, sig.flags & 39) : void 0));
            }
            if (!constructSignatures.length) {
                constructSignatures = getDefaultConstructSignatures(classType);
            }
            type.constructSignatures = constructSignatures;
        }
    }
    function replaceIndexedAccess(instantiable, type, replacement) {
        return instantiateType(instantiable, createTypeMapper([type.indexType, type.objectType], [getNumberLiteralType(0), createTupleType([replacement])]));
    }
    function resolveReverseMappedTypeMembers(type) {
        const indexInfo = getIndexInfoOfType(type.source, stringType);
        const modifiers = getMappedTypeModifiers(type.mappedType);
        const readonlyMask = modifiers & 1 ? false : true;
        const optionalMask = modifiers & 4 ? 0 : 16777216;
        const indexInfos = indexInfo ? [createIndexInfo(stringType, inferReverseMappedType(indexInfo.type, type.mappedType, type.constraintType), readonlyMask && indexInfo.isReadonly)] : emptyArray;
        const members = createSymbolTable();
        for (const prop of getPropertiesOfType(type.source)) {
            const checkFlags = 8192 | (readonlyMask && isReadonlySymbol(prop) ? 8 : 0);
            const inferredProp = createSymbol(4 | prop.flags & optionalMask, prop.escapedName, checkFlags);
            inferredProp.declarations = prop.declarations;
            inferredProp.links.nameType = getSymbolLinks(prop).nameType;
            inferredProp.links.propertyType = getTypeOfSymbol(prop);
            if (type.constraintType.type.flags & 8388608 && type.constraintType.type.objectType.flags & 262144 && type.constraintType.type.indexType.flags & 262144) {
                const newTypeParam = type.constraintType.type.objectType;
                const newMappedType = replaceIndexedAccess(type.mappedType, type.constraintType.type, newTypeParam);
                inferredProp.links.mappedType = newMappedType;
                inferredProp.links.constraintType = getIndexType(newTypeParam);
            } else {
                inferredProp.links.mappedType = type.mappedType;
                inferredProp.links.constraintType = type.constraintType;
            }
            members.set(prop.escapedName, inferredProp);
        }
        setStructuredTypeMembers(type, members, emptyArray, emptyArray, indexInfos);
    }
    function getLowerBoundOfKeyType(type) {
        if (type.flags & 4194304) {
            const t = getApparentType(type.type);
            return isGenericTupleType(t) ? getKnownKeysOfTupleType(t) : getIndexType(t);
        }
        if (type.flags & 16777216) {
            if (type.root.isDistributive) {
                const checkType = type.checkType;
                const constraint = getLowerBoundOfKeyType(checkType);
                if (constraint !== checkType) {
                    return getConditionalTypeInstantiation(type, prependTypeMapping(type.root.checkType, constraint, type.mapper));
                }
            }
            return type;
        }
        if (type.flags & 1048576) {
            return mapType(type, getLowerBoundOfKeyType, true);
        }
        if (type.flags & 2097152) {
            const types = type.types;
            if (types.length === 2 && !!(types[0].flags & (4 | 8 | 64)) && types[1] === emptyTypeLiteralType) {
                return type;
            }
            return getIntersectionType(sameMap(type.types, getLowerBoundOfKeyType));
        }
        return type;
    }
    function getIsLateCheckFlag(s) {
        return getCheckFlags(s) & 4096;
    }
    function forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(type, include, stringsOnly, cb) {
        for (const prop of getPropertiesOfType(type)) {
            cb(getLiteralTypeFromProperty(prop, include));
        }
        if (type.flags & 1) {
            cb(stringType);
        } else {
            for (const info of getIndexInfosOfType(type)) {
                if (!stringsOnly || info.keyType.flags & (4 | 134217728)) {
                    cb(info.keyType);
                }
            }
        }
    }
    function resolveMappedTypeMembers(type) {
        const members = createSymbolTable();
        let indexInfos;
        setStructuredTypeMembers(type, emptySymbols, emptyArray, emptyArray, emptyArray);
        const typeParameter = getTypeParameterFromMappedType(type);
        const constraintType = getConstraintTypeFromMappedType(type);
        const nameType = getNameTypeFromMappedType(type.target || type);
        const isFilteringMappedType = nameType && isTypeAssignableTo(nameType, typeParameter);
        const templateType = getTemplateTypeFromMappedType(type.target || type);
        const modifiersType = getApparentType(getModifiersTypeFromMappedType(type));
        const templateModifiers = getMappedTypeModifiers(type);
        const include = keyofStringsOnly ? 128 : 8576;
        if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
            forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, include, keyofStringsOnly, addMemberForKeyType);
        } else {
            forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType);
        }
        setStructuredTypeMembers(type, members, emptyArray, emptyArray, indexInfos || emptyArray);
        function addMemberForKeyType(keyType) {
            const propNameType = nameType ? instantiateType(nameType, appendTypeMapping(type.mapper, typeParameter, keyType)) : keyType;
            forEachType(propNameType, t => addMemberForKeyTypeWorker(keyType, t));
        }
        function addMemberForKeyTypeWorker(keyType, propNameType) {
            if (isTypeUsableAsPropertyName(propNameType)) {
                const propName = getPropertyNameFromType(propNameType);
                const existingProp = members.get(propName);
                if (existingProp) {
                    existingProp.links.nameType = getUnionType([existingProp.links.nameType, propNameType]);
                    existingProp.links.keyType = getUnionType([existingProp.links.keyType, keyType]);
                } else {
                    const modifiersProp = isTypeUsableAsPropertyName(keyType) ? getPropertyOfType(modifiersType, getPropertyNameFromType(keyType)) : void 0;
                    const isOptional = !!(templateModifiers & 4 || !(templateModifiers & 8) && modifiersProp && modifiersProp.flags & 16777216);
                    const isReadonly = !!(templateModifiers & 1 || !(templateModifiers & 2) && modifiersProp && isReadonlySymbol(modifiersProp));
                    const stripOptional = strictNullChecks && !isOptional && modifiersProp && modifiersProp.flags & 16777216;
                    const lateFlag = modifiersProp ? getIsLateCheckFlag(modifiersProp) : 0;
                    const prop = createSymbol(4 | (isOptional ? 16777216 : 0), propName, lateFlag | 262144 | (isReadonly ? 8 : 0) | (stripOptional ? 524288 : 0));
                    prop.links.mappedType = type;
                    prop.links.nameType = propNameType;
                    prop.links.keyType = keyType;
                    if (modifiersProp) {
                        prop.links.syntheticOrigin = modifiersProp;
                        prop.declarations = !nameType || isFilteringMappedType ? modifiersProp.declarations : void 0;
                    }
                    members.set(propName, prop);
                }
            } else if (isValidIndexKeyType(propNameType) || propNameType.flags & (1 | 32)) {
                const indexKeyType = propNameType.flags & (1 | 4) ? stringType : propNameType.flags & (8 | 32) ? numberType : propNameType;
                const propType = instantiateType(templateType, appendTypeMapping(type.mapper, typeParameter, keyType));
                const indexInfo = createIndexInfo(indexKeyType, propType, !!(templateModifiers & 1));
                indexInfos = appendIndexInfo(indexInfos, indexInfo, true);
            }
        }
    }
    function getTypeOfMappedSymbol(symbol) {
        if (!symbol.links.type) {
            const mappedType = symbol.links.mappedType;
            if (!pushTypeResolution(symbol, 0)) {
                mappedType.containsError = true;
                return errorType;
            }
            const templateType = getTemplateTypeFromMappedType(mappedType.target || mappedType);
            const mapper = appendTypeMapping(mappedType.mapper, getTypeParameterFromMappedType(mappedType), symbol.links.keyType);
            const propType = instantiateType(templateType, mapper);
            let type = strictNullChecks && symbol.flags & 16777216 && !maybeTypeOfKind(propType, 32768 | 16384) ? getOptionalType(propType, true) : symbol.links.checkFlags & 524288 ? removeMissingOrUndefinedType(propType) : propType;
            if (!popTypeResolution()) {
                error(currentNode, Diagnostics.Type_of_property_0_circularly_references_itself_in_mapped_type_1, symbolToString(symbol), typeToString(mappedType));
                type = errorType;
            }
            symbol.links.type = type;
        }
        return symbol.links.type;
    }
    function getTypeParameterFromMappedType(type) {
        return type.typeParameter || (type.typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(type.declaration.typeParameter)));
    }
    function getConstraintTypeFromMappedType(type) {
        return type.constraintType || (type.constraintType = getConstraintOfTypeParameter(getTypeParameterFromMappedType(type)) || errorType);
    }
    function getNameTypeFromMappedType(type) {
        return type.declaration.nameType ? type.nameType || (type.nameType = instantiateType(getTypeFromTypeNode(type.declaration.nameType), type.mapper)) : void 0;
    }
    function getTemplateTypeFromMappedType(type) {
        return type.templateType || (type.templateType = type.declaration.type ? instantiateType(addOptionality(getTypeFromTypeNode(type.declaration.type), true, !!(getMappedTypeModifiers(type) & 4)), type.mapper) : errorType);
    }
    function getConstraintDeclarationForMappedType(type) {
        return getEffectiveConstraintOfTypeParameter(type.declaration.typeParameter);
    }
    function isMappedTypeWithKeyofConstraintDeclaration(type) {
        const constraintDeclaration = getConstraintDeclarationForMappedType(type);
        return constraintDeclaration.kind === 195 && constraintDeclaration.operator === 141;
    }
    function getModifiersTypeFromMappedType(type) {
        if (!type.modifiersType) {
            if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
                type.modifiersType = instantiateType(getTypeFromTypeNode(getConstraintDeclarationForMappedType(type).type), type.mapper);
            } else {
                const declaredType = getTypeFromMappedTypeNode(type.declaration);
                const constraint = getConstraintTypeFromMappedType(declaredType);
                const extendedConstraint = constraint && constraint.flags & 262144 ? getConstraintOfTypeParameter(constraint) : constraint;
                type.modifiersType = extendedConstraint && extendedConstraint.flags & 4194304 ? instantiateType(extendedConstraint.type, type.mapper) : unknownType;
            }
        }
        return type.modifiersType;
    }
    function getMappedTypeModifiers(type) {
        const declaration = type.declaration;
        return (declaration.readonlyToken ? declaration.readonlyToken.kind === 40 ? 2 : 1 : 0) | (declaration.questionToken ? declaration.questionToken.kind === 40 ? 8 : 4 : 0);
    }
    function isGenericMappedType(type) {
        if (getObjectFlags(type) & 32) {
            const constraint = getConstraintTypeFromMappedType(type);
            if (isGenericIndexType(constraint)) {
                return true;
            }
            const nameType = getNameTypeFromMappedType(type);
            if (nameType && isGenericIndexType(instantiateType(nameType, makeUnaryTypeMapper(getTypeParameterFromMappedType(type), constraint)))) {
                return true;
            }
        }
        return false;
    }
    function resolveStructuredTypeMembers(type) {
        if (!type.members) {
            if (type.flags & 524288) {
                if (type.objectFlags & 4) {
                    resolveTypeReferenceMembers(type);
                } else if (type.objectFlags & 3) {
                    resolveClassOrInterfaceMembers(type);
                } else if (type.objectFlags & 1024) {
                    resolveReverseMappedTypeMembers(type);
                } else if (type.objectFlags & 16) {
                    resolveAnonymousTypeMembers(type);
                } else if (type.objectFlags & 32) {
                    resolveMappedTypeMembers(type);
                } else {
                    Debug.fail("Unhandled object type " + Debug.formatObjectFlags(type.objectFlags));
                }
            } else if (type.flags & 1048576) {
                resolveUnionTypeMembers(type);
            } else if (type.flags & 2097152) {
                resolveIntersectionTypeMembers(type);
            } else {
                Debug.fail("Unhandled type " + Debug.formatTypeFlags(type.flags));
            }
        }
        return type;
    }
    function getPropertiesOfObjectType(type) {
        if (type.flags & 524288) {
            return resolveStructuredTypeMembers(type).properties;
        }
        return emptyArray;
    }
    function getPropertyOfObjectType(type, name) {
        if (type.flags & 524288) {
            const resolved = resolveStructuredTypeMembers(type);
            const symbol = resolved.members.get(name);
            if (symbol && symbolIsValue(symbol)) {
                return symbol;
            }
        }
    }
    function getPropertiesOfUnionOrIntersectionType(type) {
        if (!type.resolvedProperties) {
            const members = createSymbolTable();
            for (const current of type.types) {
                for (const prop of getPropertiesOfType(current)) {
                    if (!members.has(prop.escapedName)) {
                        const combinedProp = getPropertyOfUnionOrIntersectionType(type, prop.escapedName);
                        if (combinedProp) {
                            members.set(prop.escapedName, combinedProp);
                        }
                    }
                }
                if (type.flags & 1048576 && getIndexInfosOfType(current).length === 0) {
                    break;
                }
            }
            type.resolvedProperties = getNamedMembers(members);
        }
        return type.resolvedProperties;
    }
    function getPropertiesOfType(type) {
        type = getReducedApparentType(type);
        return type.flags & 3145728 ? getPropertiesOfUnionOrIntersectionType(type) : getPropertiesOfObjectType(type);
    }
    function forEachPropertyOfType(type, action) {
        type = getReducedApparentType(type);
        if (type.flags & 3670016) {
            resolveStructuredTypeMembers(type).members.forEach((symbol, escapedName) => {
                if (isNamedMember(symbol, escapedName)) {
                    action(symbol, escapedName);
                }
            });
        }
    }
    function isTypeInvalidDueToUnionDiscriminant(contextualType, obj) {
        const list = obj.properties;
        return list.some(property => {
            const nameType = property.name && getLiteralTypeFromPropertyName(property.name);
            const name = nameType && isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : void 0;
            const expected = name === void 0 ? void 0 : getTypeOfPropertyOfType(contextualType, name);
            return !!expected && isLiteralType(expected) && !isTypeAssignableTo(getTypeOfNode(property), expected);
        });
    }
    function getAllPossiblePropertiesOfTypes(types) {
        const unionType = getUnionType(types);
        if (!(unionType.flags & 1048576)) {
            return getAugmentedPropertiesOfType(unionType);
        }
        const props = createSymbolTable();
        for (const memberType of types) {
            for (const {
                escapedName
            } of getAugmentedPropertiesOfType(memberType)) {
                if (!props.has(escapedName)) {
                    const prop = createUnionOrIntersectionProperty(unionType, escapedName);
                    if (prop) props.set(escapedName, prop);
                }
            }
        }
        return arrayFrom(props.values());
    }
    function getConstraintOfType(type) {
        return type.flags & 262144 ? getConstraintOfTypeParameter(type) : type.flags & 8388608 ? getConstraintOfIndexedAccess(type) : type.flags & 16777216 ? getConstraintOfConditionalType(type) : getBaseConstraintOfType(type);
    }
    function getConstraintOfTypeParameter(typeParameter) {
        return hasNonCircularBaseConstraint(typeParameter) ? getConstraintFromTypeParameter(typeParameter) : void 0;
    }
    function isConstTypeVariable(type) {
        var _a2;
        return !!(type.flags & 262144 && some((_a2 = type.symbol) == null ? void 0 : _a2.declarations, d => hasSyntacticModifier(d, 2048)) || isGenericTupleType(type) && findIndex(getTypeArguments(type), (t, i) => !!(type.target.elementFlags[i] & 8) && isConstTypeVariable(t)) >= 0 || type.flags & 8388608 && isConstTypeVariable(type.objectType));
    }
    function getConstraintOfIndexedAccess(type) {
        return hasNonCircularBaseConstraint(type) ? getConstraintFromIndexedAccess(type) : void 0;
    }
    function getSimplifiedTypeOrConstraint(type) {
        const simplified = getSimplifiedType(type, false);
        return simplified !== type ? simplified : getConstraintOfType(type);
    }
    function getConstraintFromIndexedAccess(type) {
        if (isMappedTypeGenericIndexedAccess(type)) {
            return substituteIndexedMappedType(type.objectType, type.indexType);
        }
        const indexConstraint = getSimplifiedTypeOrConstraint(type.indexType);
        if (indexConstraint && indexConstraint !== type.indexType) {
            const indexedAccess = getIndexedAccessTypeOrUndefined(type.objectType, indexConstraint, type.accessFlags);
            if (indexedAccess) {
                return indexedAccess;
            }
        }
        const objectConstraint = getSimplifiedTypeOrConstraint(type.objectType);
        if (objectConstraint && objectConstraint !== type.objectType) {
            return getIndexedAccessTypeOrUndefined(objectConstraint, type.indexType, type.accessFlags);
        }
        return void 0;
    }
    function getDefaultConstraintOfConditionalType(type) {
        if (!type.resolvedDefaultConstraint) {
            const trueConstraint = getInferredTrueTypeFromConditionalType(type);
            const falseConstraint = getFalseTypeFromConditionalType(type);
            type.resolvedDefaultConstraint = isTypeAny(trueConstraint) ? falseConstraint : isTypeAny(falseConstraint) ? trueConstraint : getUnionType([trueConstraint, falseConstraint]);
        }
        return type.resolvedDefaultConstraint;
    }
    function getConstraintOfDistributiveConditionalType(type) {
        if (type.root.isDistributive && type.restrictiveInstantiation !== type) {
            const simplified = getSimplifiedType(type.checkType, false);
            const constraint = simplified === type.checkType ? getConstraintOfType(simplified) : simplified;
            if (constraint && constraint !== type.checkType) {
                const instantiated = getConditionalTypeInstantiation(type, prependTypeMapping(type.root.checkType, constraint, type.mapper));
                if (!(instantiated.flags & 131072)) {
                    return instantiated;
                }
            }
        }
        return void 0;
    }
    function getConstraintFromConditionalType(type) {
        return getConstraintOfDistributiveConditionalType(type) || getDefaultConstraintOfConditionalType(type);
    }
    function getConstraintOfConditionalType(type) {
        return hasNonCircularBaseConstraint(type) ? getConstraintFromConditionalType(type) : void 0;
    }
    function getBaseConstraintOfType(type) {
        if (type.flags & (58982400 | 3145728 | 134217728 | 268435456)) {
            const constraint = getResolvedBaseConstraint(type);
            return constraint !== noConstraintType && constraint !== circularConstraintType ? constraint : void 0;
        }
        return type.flags & 4194304 ? keyofConstraintType : void 0;
    }
    function getBaseConstraintOrType(type) {
        return getBaseConstraintOfType(type) || type;
    }
    function hasNonCircularBaseConstraint(type) {
        return getResolvedBaseConstraint(type) !== circularConstraintType;
    }
    function getResolvedBaseConstraint(type) {
        if (type.resolvedBaseConstraint) {
            return type.resolvedBaseConstraint;
        }
        const stack = [];
        return type.resolvedBaseConstraint = getTypeWithThisArgument(getImmediateBaseConstraint(type), type);
        function getImmediateBaseConstraint(t) {
            if (!t.immediateBaseConstraint) {
                if (!pushTypeResolution(t, 4)) {
                    return circularConstraintType;
                }
                let result;
                const identity2 = getRecursionIdentity(t);
                if (stack.length < 10 || stack.length < 50 && !contains(stack, identity2)) {
                    stack.push(identity2);
                    result = computeBaseConstraint(getSimplifiedType(t, false));
                    stack.pop();
                }
                if (!popTypeResolution()) {
                    if (t.flags & 262144) {
                        const errorNode = getConstraintDeclaration(t);
                        if (errorNode) {
                            const diagnostic = error(errorNode, Diagnostics.Type_parameter_0_has_a_circular_constraint, typeToString(t));
                            if (currentNode && !isNodeDescendantOf(errorNode, currentNode) && !isNodeDescendantOf(currentNode, errorNode)) {
                                addRelatedInfo(diagnostic, createDiagnosticForNode(currentNode, Diagnostics.Circularity_originates_in_type_at_this_location));
                            }
                        }
                    }
                    result = circularConstraintType;
                }
                t.immediateBaseConstraint = result || noConstraintType;
            }
            return t.immediateBaseConstraint;
        }
        function getBaseConstraint(t) {
            const c = getImmediateBaseConstraint(t);
            return c !== noConstraintType && c !== circularConstraintType ? c : void 0;
        }
        function computeBaseConstraint(t) {
            if (t.flags & 262144) {
                const constraint = getConstraintFromTypeParameter(t);
                return t.isThisType || !constraint ? constraint : getBaseConstraint(constraint);
            }
            if (t.flags & 3145728) {
                const types = t.types;
                const baseTypes = [];
                let different = false;
                for (const type2 of types) {
                    const baseType = getBaseConstraint(type2);
                    if (baseType) {
                        if (baseType !== type2) {
                            different = true;
                        }
                        baseTypes.push(baseType);
                    } else {
                        different = true;
                    }
                }
                if (!different) {
                    return t;
                }
                return t.flags & 1048576 && baseTypes.length === types.length ? getUnionType(baseTypes) : t.flags & 2097152 && baseTypes.length ? getIntersectionType(baseTypes) : void 0;
            }
            if (t.flags & 4194304) {
                return keyofConstraintType;
            }
            if (t.flags & 134217728) {
                const types = t.types;
                const constraints = mapDefined(types, getBaseConstraint);
                return constraints.length === types.length ? getTemplateLiteralType(t.texts, constraints) : stringType;
            }
            if (t.flags & 268435456) {
                const constraint = getBaseConstraint(t.type);
                return constraint && constraint !== t.type ? getStringMappingType(t.symbol, constraint) : stringType;
            }
            if (t.flags & 8388608) {
                if (isMappedTypeGenericIndexedAccess(t)) {
                    return getBaseConstraint(substituteIndexedMappedType(t.objectType, t.indexType));
                }
                const baseObjectType = getBaseConstraint(t.objectType);
                const baseIndexType = getBaseConstraint(t.indexType);
                const baseIndexedAccess = baseObjectType && baseIndexType && getIndexedAccessTypeOrUndefined(baseObjectType, baseIndexType, t.accessFlags);
                return baseIndexedAccess && getBaseConstraint(baseIndexedAccess);
            }
            if (t.flags & 16777216) {
                const constraint = getConstraintFromConditionalType(t);
                return constraint && getBaseConstraint(constraint);
            }
            if (t.flags & 33554432) {
                return getBaseConstraint(getSubstitutionIntersection(t));
            }
            return t;
        }
    }
    function getApparentTypeOfIntersectionType(type) {
        return type.resolvedApparentType || (type.resolvedApparentType = getTypeWithThisArgument(type, type, true));
    }
    function getResolvedTypeParameterDefault(typeParameter) {
        if (!typeParameter.default) {
            if (typeParameter.target) {
                const targetDefault = getResolvedTypeParameterDefault(typeParameter.target);
                typeParameter.default = targetDefault ? instantiateType(targetDefault, typeParameter.mapper) : noConstraintType;
            } else {
                typeParameter.default = resolvingDefaultType;
                const defaultDeclaration = typeParameter.symbol && forEach(typeParameter.symbol.declarations, decl => isTypeParameterDeclaration(decl) && decl.default);
                const defaultType = defaultDeclaration ? getTypeFromTypeNode(defaultDeclaration) : noConstraintType;
                if (typeParameter.default === resolvingDefaultType) {
                    typeParameter.default = defaultType;
                }
            }
        } else if (typeParameter.default === resolvingDefaultType) {
            typeParameter.default = circularConstraintType;
        }
        return typeParameter.default;
    }
    function getDefaultFromTypeParameter(typeParameter) {
        const defaultType = getResolvedTypeParameterDefault(typeParameter);
        return defaultType !== noConstraintType && defaultType !== circularConstraintType ? defaultType : void 0;
    }
    function hasNonCircularTypeParameterDefault(typeParameter) {
        return getResolvedTypeParameterDefault(typeParameter) !== circularConstraintType;
    }
    function hasTypeParameterDefault(typeParameter) {
        return !!(typeParameter.symbol && forEach(typeParameter.symbol.declarations, decl => isTypeParameterDeclaration(decl) && decl.default));
    }
    function getApparentTypeOfMappedType(type) {
        return type.resolvedApparentType || (type.resolvedApparentType = getResolvedApparentTypeOfMappedType(type));
    }
    function getResolvedApparentTypeOfMappedType(type) {
        const typeVariable = getHomomorphicTypeVariable(type);
        if (typeVariable && !type.declaration.nameType) {
            const constraint = getConstraintOfTypeParameter(typeVariable);
            if (constraint && isArrayOrTupleType(constraint)) {
                return instantiateType(type, prependTypeMapping(typeVariable, constraint, type.mapper));
            }
        }
        return type;
    }
    function isMappedTypeGenericIndexedAccess(type) {
        let objectType;
        return !!(type.flags & 8388608 && getObjectFlags(objectType = type.objectType) & 32 && !isGenericMappedType(objectType) && isGenericIndexType(type.indexType) && !(getMappedTypeModifiers(objectType) & 8) && !objectType.declaration.nameType);
    }
    function getApparentType(type) {
        const t = !(type.flags & 465829888) ? type : getBaseConstraintOfType(type) || unknownType;
        return getObjectFlags(t) & 32 ? getApparentTypeOfMappedType(t) : t.flags & 2097152 ? getApparentTypeOfIntersectionType(t) : t.flags & 402653316 ? globalStringType : t.flags & 296 ? globalNumberType : t.flags & 2112 ? getGlobalBigIntType() : t.flags & 528 ? globalBooleanType : t.flags & 12288 ? getGlobalESSymbolType() : t.flags & 67108864 ? emptyObjectType : t.flags & 4194304 ? keyofConstraintType : t.flags & 2 && !strictNullChecks ? emptyObjectType : t;
    }
    function getReducedApparentType(type) {
        return getReducedType(getApparentType(getReducedType(type)));
    }
    function createUnionOrIntersectionProperty(containingType, name, skipObjectFunctionPropertyAugment) {
        var _a2, _b, _c;
        let singleProp;
        let propSet;
        let indexTypes;
        const isUnion = containingType.flags & 1048576;
        let optionalFlag;
        let syntheticFlag = 4;
        let checkFlags = isUnion ? 0 : 8;
        let mergedInstantiations = false;
        for (const current of containingType.types) {
            const type = getApparentType(current);
            if (!(isErrorType(type) || type.flags & 131072)) {
                const prop = getPropertyOfType(type, name, skipObjectFunctionPropertyAugment);
                const modifiers = prop ? getDeclarationModifierFlagsFromSymbol(prop) : 0;
                if (prop) {
                    if (prop.flags & 106500) {
                        optionalFlag != null ? optionalFlag : optionalFlag = isUnion ? 0 : 16777216;
                        if (isUnion) {
                            optionalFlag |= prop.flags & 16777216;
                        } else {
                            optionalFlag &= prop.flags;
                        }
                    }
                    if (!singleProp) {
                        singleProp = prop;
                    } else if (prop !== singleProp) {
                        const isInstantiation = (getTargetSymbol(prop) || prop) === (getTargetSymbol(singleProp) || singleProp);
                        if (isInstantiation && compareProperties2(singleProp, prop, (a, b) => a === b ? -1 : 0) === -1) {
                            mergedInstantiations = !!singleProp.parent && !!length(getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(singleProp.parent));
                        } else {
                            if (!propSet) {
                                propSet = /* @__PURE__ */new Map();
                                propSet.set(getSymbolId(singleProp), singleProp);
                            }
                            const id = getSymbolId(prop);
                            if (!propSet.has(id)) {
                                propSet.set(id, prop);
                            }
                        }
                    }
                    if (isUnion && isReadonlySymbol(prop)) {
                        checkFlags |= 8;
                    } else if (!isUnion && !isReadonlySymbol(prop)) {
                        checkFlags &= ~8;
                    }
                    checkFlags |= (!(modifiers & 24) ? 256 : 0) | (modifiers & 16 ? 512 : 0) | (modifiers & 8 ? 1024 : 0) | (modifiers & 32 ? 2048 : 0);
                    if (!isPrototypeProperty(prop)) {
                        syntheticFlag = 2;
                    }
                } else if (isUnion) {
                    const indexInfo = !isLateBoundName(name) && getApplicableIndexInfoForName(type, name);
                    if (indexInfo) {
                        checkFlags |= 32 | (indexInfo.isReadonly ? 8 : 0);
                        indexTypes = append(indexTypes, isTupleType(type) ? getRestTypeOfTupleType(type) || undefinedType : indexInfo.type);
                    } else if (isObjectLiteralType2(type) && !(getObjectFlags(type) & 2097152)) {
                        checkFlags |= 32;
                        indexTypes = append(indexTypes, undefinedType);
                    } else {
                        checkFlags |= 16;
                    }
                }
            }
        }
        if (!singleProp || isUnion && (propSet || checkFlags & 48) && checkFlags & (1024 | 512) && !(propSet && getCommonDeclarationsOfSymbols(propSet.values()))) {
            return void 0;
        }
        if (!propSet && !(checkFlags & 16) && !indexTypes) {
            if (mergedInstantiations) {
                const links = (_a2 = tryCast(singleProp, isTransientSymbol)) == null ? void 0 : _a2.links;
                const clone2 = createSymbolWithType(singleProp, links == null ? void 0 : links.type);
                clone2.parent = (_c = (_b = singleProp.valueDeclaration) == null ? void 0 : _b.symbol) == null ? void 0 : _c.parent;
                clone2.links.containingType = containingType;
                clone2.links.mapper = links == null ? void 0 : links.mapper;
                return clone2;
            } else {
                return singleProp;
            }
        }
        const props = propSet ? arrayFrom(propSet.values()) : [singleProp];
        let declarations;
        let firstType;
        let nameType;
        const propTypes = [];
        let writeTypes;
        let firstValueDeclaration;
        let hasNonUniformValueDeclaration = false;
        for (const prop of props) {
            if (!firstValueDeclaration) {
                firstValueDeclaration = prop.valueDeclaration;
            } else if (prop.valueDeclaration && prop.valueDeclaration !== firstValueDeclaration) {
                hasNonUniformValueDeclaration = true;
            }
            declarations = addRange(declarations, prop.declarations);
            const type = getTypeOfSymbol(prop);
            if (!firstType) {
                firstType = type;
                nameType = getSymbolLinks(prop).nameType;
            }
            const writeType = getWriteTypeOfSymbol(prop);
            if (writeTypes || writeType !== type) {
                writeTypes = append(!writeTypes ? propTypes.slice() : writeTypes, writeType);
            } else if (type !== firstType) {
                checkFlags |= 64;
            }
            if (isLiteralType(type) || isPatternLiteralType(type) || type === uniqueLiteralType) {
                checkFlags |= 128;
            }
            if (type.flags & 131072 && type !== uniqueLiteralType) {
                checkFlags |= 131072;
            }
            propTypes.push(type);
        }
        addRange(propTypes, indexTypes);
        const result = createSymbol(4 | (optionalFlag != null ? optionalFlag : 0), name, syntheticFlag | checkFlags);
        result.links.containingType = containingType;
        if (!hasNonUniformValueDeclaration && firstValueDeclaration) {
            result.valueDeclaration = firstValueDeclaration;
            if (firstValueDeclaration.symbol.parent) {
                result.parent = firstValueDeclaration.symbol.parent;
            }
        }
        result.declarations = declarations;
        result.links.nameType = nameType;
        if (propTypes.length > 2) {
            result.links.checkFlags |= 65536;
            result.links.deferralParent = containingType;
            result.links.deferralConstituents = propTypes;
            result.links.deferralWriteConstituents = writeTypes;
        } else {
            result.links.type = isUnion ? getUnionType(propTypes) : getIntersectionType(propTypes);
            if (writeTypes) {
                result.links.writeType = isUnion ? getUnionType(writeTypes) : getIntersectionType(writeTypes);
            }
        }
        return result;
    }
    function getUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment) {
        var _a2, _b;
        let property = ((_a2 = type.propertyCacheWithoutObjectFunctionPropertyAugment) == null ? void 0 : _a2.get(name)) || !skipObjectFunctionPropertyAugment ? (_b = type.propertyCache) == null ? void 0 : _b.get(name) : void 0;
        if (!property) {
            property = createUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment);
            if (property) {
                const properties = skipObjectFunctionPropertyAugment ? type.propertyCacheWithoutObjectFunctionPropertyAugment || (type.propertyCacheWithoutObjectFunctionPropertyAugment = createSymbolTable()) : type.propertyCache || (type.propertyCache = createSymbolTable());
                properties.set(name, property);
            }
        }
        return property;
    }
    function getCommonDeclarationsOfSymbols(symbols) {
        let commonDeclarations;
        for (const symbol of symbols) {
            if (!symbol.declarations) {
                return void 0;
            }
            if (!commonDeclarations) {
                commonDeclarations = new Set(symbol.declarations);
                continue;
            }
            commonDeclarations.forEach(declaration => {
                if (!contains(symbol.declarations, declaration)) {
                    commonDeclarations.delete(declaration);
                }
            });
            if (commonDeclarations.size === 0) {
                return void 0;
            }
        }
        return commonDeclarations;
    }
    function getPropertyOfUnionOrIntersectionType(type, name, skipObjectFunctionPropertyAugment) {
        const property = getUnionOrIntersectionProperty(type, name, skipObjectFunctionPropertyAugment);
        return property && !(getCheckFlags(property) & 16) ? property : void 0;
    }
    function getReducedType(type) {
        if (type.flags & 1048576 && type.objectFlags & 16777216) {
            return type.resolvedReducedType || (type.resolvedReducedType = getReducedUnionType(type));
        } else if (type.flags & 2097152) {
            if (!(type.objectFlags & 16777216)) {
                type.objectFlags |= 16777216 | (some(getPropertiesOfUnionOrIntersectionType(type), isNeverReducedProperty) ? 33554432 : 0);
            }
            return type.objectFlags & 33554432 ? neverType : type;
        }
        return type;
    }
    function getReducedUnionType(unionType) {
        const reducedTypes = sameMap(unionType.types, getReducedType);
        if (reducedTypes === unionType.types) {
            return unionType;
        }
        const reduced = getUnionType(reducedTypes);
        if (reduced.flags & 1048576) {
            reduced.resolvedReducedType = reduced;
        }
        return reduced;
    }
    function isNeverReducedProperty(prop) {
        return isDiscriminantWithNeverType(prop) || isConflictingPrivateProperty(prop);
    }
    function isDiscriminantWithNeverType(prop) {
        return !(prop.flags & 16777216) && (getCheckFlags(prop) & (192 | 131072)) === 192 && !!(getTypeOfSymbol(prop).flags & 131072);
    }
    function isConflictingPrivateProperty(prop) {
        return !prop.valueDeclaration && !!(getCheckFlags(prop) & 1024);
    }
    function elaborateNeverIntersection(errorInfo, type) {
        if (type.flags & 2097152 && getObjectFlags(type) & 33554432) {
            const neverProp = find(getPropertiesOfUnionOrIntersectionType(type), isDiscriminantWithNeverType);
            if (neverProp) {
                return chainDiagnosticMessages(errorInfo, Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents, typeToString(type, void 0, 536870912), symbolToString(neverProp));
            }
            const privateProp = find(getPropertiesOfUnionOrIntersectionType(type), isConflictingPrivateProperty);
            if (privateProp) {
                return chainDiagnosticMessages(errorInfo, Diagnostics.The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some, typeToString(type, void 0, 536870912), symbolToString(privateProp));
            }
        }
        return errorInfo;
    }
    function getPropertyOfType(type, name, skipObjectFunctionPropertyAugment, includeTypeOnlyMembers) {
        type = getReducedApparentType(type);
        if (type.flags & 524288) {
            const resolved = resolveStructuredTypeMembers(type);
            const symbol = resolved.members.get(name);
            if (symbol && symbolIsValue(symbol, includeTypeOnlyMembers)) {
                return symbol;
            }
            if (skipObjectFunctionPropertyAugment) return void 0;
            const functionType = resolved === anyFunctionType ? globalFunctionType : resolved.callSignatures.length ? globalCallableFunctionType : resolved.constructSignatures.length ? globalNewableFunctionType : void 0;
            if (functionType) {
                const symbol2 = getPropertyOfObjectType(functionType, name);
                if (symbol2) {
                    return symbol2;
                }
            }
            return getPropertyOfObjectType(globalObjectType, name);
        }
        if (type.flags & 3145728) {
            return getPropertyOfUnionOrIntersectionType(type, name, skipObjectFunctionPropertyAugment);
        }
        return void 0;
    }
    function getSignaturesOfStructuredType(type, kind) {
        if (type.flags & 3670016) {
            const resolved = resolveStructuredTypeMembers(type);
            return kind === 0 ? resolved.callSignatures : resolved.constructSignatures;
        }
        return emptyArray;
    }
    function getSignaturesOfType(type, kind) {
        return getSignaturesOfStructuredType(getReducedApparentType(type), kind);
    }
    function findIndexInfo(indexInfos, keyType) {
        return find(indexInfos, info => info.keyType === keyType);
    }
    function findApplicableIndexInfo(indexInfos, keyType) {
        let stringIndexInfo;
        let applicableInfo;
        let applicableInfos;
        for (const info of indexInfos) {
            if (info.keyType === stringType) {
                stringIndexInfo = info;
            } else if (isApplicableIndexType(keyType, info.keyType)) {
                if (!applicableInfo) {
                    applicableInfo = info;
                } else {
                    (applicableInfos || (applicableInfos = [applicableInfo])).push(info);
                }
            }
        }
        return applicableInfos ? createIndexInfo(unknownType, getIntersectionType(map(applicableInfos, info => info.type)), reduceLeft(applicableInfos, (isReadonly, info) => isReadonly && info.isReadonly, true)) : applicableInfo ? applicableInfo : stringIndexInfo && isApplicableIndexType(keyType, stringType) ? stringIndexInfo : void 0;
    }
    function isApplicableIndexType(source, target) {
        return isTypeAssignableTo(source, target) || target === stringType && isTypeAssignableTo(source, numberType) || target === numberType && (source === numericStringType || !!(source.flags & 128) && isNumericLiteralName(source.value));
    }
    function getIndexInfosOfStructuredType(type) {
        if (type.flags & 3670016) {
            const resolved = resolveStructuredTypeMembers(type);
            return resolved.indexInfos;
        }
        return emptyArray;
    }
    function getIndexInfosOfType(type) {
        return getIndexInfosOfStructuredType(getReducedApparentType(type));
    }
    function getIndexInfoOfType(type, keyType) {
        return findIndexInfo(getIndexInfosOfType(type), keyType);
    }
    function getIndexTypeOfType(type, keyType) {
        var _a2;
        return (_a2 = getIndexInfoOfType(type, keyType)) == null ? void 0 : _a2.type;
    }
    function getApplicableIndexInfos(type, keyType) {
        return getIndexInfosOfType(type).filter(info => isApplicableIndexType(keyType, info.keyType));
    }
    function getApplicableIndexInfo(type, keyType) {
        return findApplicableIndexInfo(getIndexInfosOfType(type), keyType);
    }
    function getApplicableIndexInfoForName(type, name) {
        return getApplicableIndexInfo(type, isLateBoundName(name) ? esSymbolType : getStringLiteralType(unescapeLeadingUnderscores(name)));
    }
    function getTypeParametersFromDeclaration(declaration) {
        var _a2;
        let result;
        for (const node of getEffectiveTypeParameterDeclarations(declaration)) {
            result = appendIfUnique(result, getDeclaredTypeOfTypeParameter(node.symbol));
        }
        return (result == null ? void 0 : result.length) ? result : isFunctionDeclaration(declaration) ? (_a2 = getSignatureOfTypeTag(declaration)) == null ? void 0 : _a2.typeParameters : void 0;
    }
    function symbolsToArray(symbols) {
        const result = [];
        symbols.forEach((symbol, id) => {
            if (!isReservedMemberName(id)) {
                result.push(symbol);
            }
        });
        return result;
    }
    function tryFindAmbientModule(moduleName, withAugmentations) {
        if (isExternalModuleNameRelative(moduleName)) {
            return void 0;
        }
        const symbol = getSymbol2(globals, '"' + moduleName + '"', 512);
        return symbol && withAugmentations ? getMergedSymbol(symbol) : symbol;
    }
    function isOptionalParameter(node) {
        if (hasQuestionToken(node) || isOptionalJSDocPropertyLikeTag(node) || isJSDocOptionalParameter(node)) {
            return true;
        }
        if (node.initializer) {
            const signature = getSignatureFromDeclaration(node.parent);
            const parameterIndex = node.parent.parameters.indexOf(node);
            Debug.assert(parameterIndex >= 0);
            return parameterIndex >= getMinArgumentCount(signature, 1 | 2);
        }
        const iife = getImmediatelyInvokedFunctionExpression(node.parent);
        if (iife) {
            return !node.type && !node.dotDotDotToken && node.parent.parameters.indexOf(node) >= iife.arguments.length;
        }
        return false;
    }
    function isOptionalPropertyDeclaration(node) {
        return isPropertyDeclaration(node) && !hasAccessorModifier(node) && node.questionToken;
    }
    function createTypePredicate(kind, parameterName, parameterIndex, type) {
        return {
            kind,
            parameterName,
            parameterIndex,
            type
        };
    }
    function getMinTypeArgumentCount(typeParameters) {
        let minTypeArgumentCount = 0;
        if (typeParameters) {
            for (let i = 0; i < typeParameters.length; i++) {
                if (!hasTypeParameterDefault(typeParameters[i])) {
                    minTypeArgumentCount = i + 1;
                }
            }
        }
        return minTypeArgumentCount;
    }
    function fillMissingTypeArguments(typeArguments, typeParameters, minTypeArgumentCount, isJavaScriptImplicitAny) {
        const numTypeParameters = length(typeParameters);
        if (!numTypeParameters) {
            return [];
        }
        const numTypeArguments = length(typeArguments);
        if (isJavaScriptImplicitAny || numTypeArguments >= minTypeArgumentCount && numTypeArguments <= numTypeParameters) {
            const result = typeArguments ? typeArguments.slice() : [];
            for (let i = numTypeArguments; i < numTypeParameters; i++) {
                result[i] = errorType;
            }
            const baseDefaultType = getDefaultTypeArgumentType(isJavaScriptImplicitAny);
            for (let i = numTypeArguments; i < numTypeParameters; i++) {
                let defaultType = getDefaultFromTypeParameter(typeParameters[i]);
                if (isJavaScriptImplicitAny && defaultType && (isTypeIdenticalTo(defaultType, unknownType) || isTypeIdenticalTo(defaultType, emptyObjectType))) {
                    defaultType = anyType;
                }
                result[i] = defaultType ? instantiateType(defaultType, createTypeMapper(typeParameters, result)) : baseDefaultType;
            }
            result.length = typeParameters.length;
            return result;
        }
        return typeArguments && typeArguments.slice();
    }
    function getSignatureFromDeclaration(declaration) {
        const links = getNodeLinks(declaration);
        if (!links.resolvedSignature) {
            const parameters = [];
            let flags = 0;
            let minArgumentCount = 0;
            let thisParameter;
            let hasThisParameter2 = false;
            const iife = getImmediatelyInvokedFunctionExpression(declaration);
            const isJSConstructSignature = isJSDocConstructSignature(declaration);
            const isUntypedSignatureInJSFile = !iife && isInJSFile(declaration) && isValueSignatureDeclaration(declaration) && !hasJSDocParameterTags(declaration) && !getJSDocType(declaration);
            if (isUntypedSignatureInJSFile) {
                flags |= 32;
            }
            for (let i = isJSConstructSignature ? 1 : 0; i < declaration.parameters.length; i++) {
                const param = declaration.parameters[i];
                let paramSymbol = param.symbol;
                const type = isJSDocParameterTag(param) ? param.typeExpression && param.typeExpression.type : param.type;
                if (paramSymbol && !!(paramSymbol.flags & 4) && !isBindingPattern(param.name)) {
                    const resolvedSymbol = resolveName(param, paramSymbol.escapedName, 111551, void 0, void 0, false);
                    paramSymbol = resolvedSymbol;
                }
                if (i === 0 && paramSymbol.escapedName === "this") {
                    hasThisParameter2 = true;
                    thisParameter = param.symbol;
                } else {
                    parameters.push(paramSymbol);
                }
                if (type && type.kind === 198) {
                    flags |= 2;
                }
                const isOptionalParameter2 = isOptionalJSDocPropertyLikeTag(param) || param.initializer || param.questionToken || isRestParameter(param) || iife && parameters.length > iife.arguments.length && !type || isJSDocOptionalParameter(param);
                if (!isOptionalParameter2) {
                    minArgumentCount = parameters.length;
                }
            }
            if ((declaration.kind === 174 || declaration.kind === 175) && hasBindableName(declaration) && (!hasThisParameter2 || !thisParameter)) {
                const otherKind = declaration.kind === 174 ? 175 : 174;
                const other = getDeclarationOfKind(getSymbolOfDeclaration(declaration), otherKind);
                if (other) {
                    thisParameter = getAnnotatedAccessorThisParameter(other);
                }
            }
            if (isInJSFile(declaration)) {
                const thisTag = getJSDocThisTag(declaration);
                if (thisTag && thisTag.typeExpression) {
                    thisParameter = createSymbolWithType(createSymbol(1, "this"), getTypeFromTypeNode(thisTag.typeExpression));
                }
            }
            const classType = declaration.kind === 173 ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(declaration.parent.symbol)) : void 0;
            const typeParameters = classType ? classType.localTypeParameters : getTypeParametersFromDeclaration(declaration);
            if (hasRestParameter(declaration) || isInJSFile(declaration) && maybeAddJsSyntheticRestParameter(declaration, parameters)) {
                flags |= 1;
            }
            if (isConstructorTypeNode(declaration) && hasSyntacticModifier(declaration, 256) || isConstructorDeclaration(declaration) && hasSyntacticModifier(declaration.parent, 256)) {
                flags |= 4;
            }
            links.resolvedSignature = createSignature(declaration, typeParameters, thisParameter, parameters, void 0, void 0, minArgumentCount, flags);
        }
        return links.resolvedSignature;
    }
    function maybeAddJsSyntheticRestParameter(declaration, parameters) {
        if (isJSDocSignature(declaration) || !containsArgumentsReference(declaration)) {
            return false;
        }
        const lastParam = lastOrUndefined(declaration.parameters);
        const lastParamTags = lastParam ? getJSDocParameterTags(lastParam) : getJSDocTags(declaration).filter(isJSDocParameterTag);
        const lastParamVariadicType = firstDefined(lastParamTags, p => p.typeExpression && isJSDocVariadicType(p.typeExpression.type) ? p.typeExpression.type : void 0);
        const syntheticArgsSymbol = createSymbol(3, "args", 32768);
        if (lastParamVariadicType) {
            syntheticArgsSymbol.links.type = createArrayType(getTypeFromTypeNode(lastParamVariadicType.type));
        } else {
            syntheticArgsSymbol.links.checkFlags |= 65536;
            syntheticArgsSymbol.links.deferralParent = neverType;
            syntheticArgsSymbol.links.deferralConstituents = [anyArrayType];
            syntheticArgsSymbol.links.deferralWriteConstituents = [anyArrayType];
        }
        if (lastParamVariadicType) {
            parameters.pop();
        }
        parameters.push(syntheticArgsSymbol);
        return true;
    }
    function getSignatureOfTypeTag(node) {
        if (!(isInJSFile(node) && isFunctionLikeDeclaration(node))) return void 0;
        const typeTag = getJSDocTypeTag(node);
        return (typeTag == null ? void 0 : typeTag.typeExpression) && getSingleCallSignature(getTypeFromTypeNode(typeTag.typeExpression));
    }
    function getParameterTypeOfTypeTag(func, parameter) {
        const signature = getSignatureOfTypeTag(func);
        if (!signature) return void 0;
        const pos = func.parameters.indexOf(parameter);
        return parameter.dotDotDotToken ? getRestTypeAtPosition(signature, pos) : getTypeAtPosition(signature, pos);
    }
    function getReturnTypeOfTypeTag(node) {
        const signature = getSignatureOfTypeTag(node);
        return signature && getReturnTypeOfSignature(signature);
    }
    function containsArgumentsReference(declaration) {
        const links = getNodeLinks(declaration);
        if (links.containsArgumentsReference === void 0) {
            if (links.flags & 512) {
                links.containsArgumentsReference = true;
            } else {
                links.containsArgumentsReference = traverse(declaration.body);
            }
        }
        return links.containsArgumentsReference;
        function traverse(node) {
            if (!node) return false;
            switch (node.kind) {
                case 79:
                    return node.escapedText === argumentsSymbol.escapedName && getReferencedValueSymbol(node) === argumentsSymbol;
                case 169:
                case 171:
                case 174:
                case 175:
                    return node.name.kind === 164 && traverse(node.name);
                case 208:
                case 209:
                    return traverse(node.expression);
                case 299:
                    return traverse(node.initializer);
                default:
                    return !nodeStartsNewLexicalEnvironment(node) && !isPartOfTypeNode(node) && !!forEachChild(node, traverse);
            }
        }
    }
    function getSignaturesOfSymbol(symbol) {
        if (!symbol || !symbol.declarations) return emptyArray;
        const result = [];
        for (let i = 0; i < symbol.declarations.length; i++) {
            const decl = symbol.declarations[i];
            if (!isFunctionLike(decl)) continue;
            if (i > 0 && decl.body) {
                const previous = symbol.declarations[i - 1];
                if (decl.parent === previous.parent && decl.kind === previous.kind && decl.pos === previous.end) {
                    continue;
                }
            }
            if (isInJSFile(decl) && decl.jsDoc) {
                let hasJSDocOverloads = false;
                for (const node of decl.jsDoc) {
                    if (node.tags) {
                        for (const tag of node.tags) {
                            if (isJSDocOverloadTag(tag)) {
                                const jsDocSignature = tag.typeExpression;
                                if (jsDocSignature.type === void 0 && !isConstructorDeclaration(decl)) {
                                    reportImplicitAny(jsDocSignature, anyType);
                                }
                                result.push(getSignatureFromDeclaration(jsDocSignature));
                                hasJSDocOverloads = true;
                            }
                        }
                    }
                }
                if (hasJSDocOverloads) {
                    continue;
                }
            }
            result.push(!isFunctionExpressionOrArrowFunction(decl) && !isObjectLiteralMethod(decl) && getSignatureOfTypeTag(decl) || getSignatureFromDeclaration(decl));
        }
        return result;
    }
    function resolveExternalModuleTypeByLiteral(name) {
        const moduleSym = resolveExternalModuleName(name, name);
        if (moduleSym) {
            const resolvedModuleSymbol = resolveExternalModuleSymbol(moduleSym);
            if (resolvedModuleSymbol) {
                return getTypeOfSymbol(resolvedModuleSymbol);
            }
        }
        return anyType;
    }
    function getThisTypeOfSignature(signature) {
        if (signature.thisParameter) {
            return getTypeOfSymbol(signature.thisParameter);
        }
    }
    function getTypePredicateOfSignature(signature) {
        if (!signature.resolvedTypePredicate) {
            if (signature.target) {
                const targetTypePredicate = getTypePredicateOfSignature(signature.target);
                signature.resolvedTypePredicate = targetTypePredicate ? instantiateTypePredicate(targetTypePredicate, signature.mapper) : noTypePredicate;
            } else if (signature.compositeSignatures) {
                signature.resolvedTypePredicate = getUnionOrIntersectionTypePredicate(signature.compositeSignatures, signature.compositeKind) || noTypePredicate;
            } else {
                const type = signature.declaration && getEffectiveReturnTypeNode(signature.declaration);
                let jsdocPredicate;
                if (!type) {
                    const jsdocSignature = getSignatureOfTypeTag(signature.declaration);
                    if (jsdocSignature && signature !== jsdocSignature) {
                        jsdocPredicate = getTypePredicateOfSignature(jsdocSignature);
                    }
                }
                signature.resolvedTypePredicate = type && isTypePredicateNode(type) ? createTypePredicateFromTypePredicateNode(type, signature) : jsdocPredicate || noTypePredicate;
            }
            Debug.assert(!!signature.resolvedTypePredicate);
        }
        return signature.resolvedTypePredicate === noTypePredicate ? void 0 : signature.resolvedTypePredicate;
    }
    function createTypePredicateFromTypePredicateNode(node, signature) {
        const parameterName = node.parameterName;
        const type = node.type && getTypeFromTypeNode(node.type);
        return parameterName.kind === 194 ? createTypePredicate(node.assertsModifier ? 2 : 0, void 0, void 0, type) : createTypePredicate(node.assertsModifier ? 3 : 1, parameterName.escapedText, findIndex(signature.parameters, p => p.escapedName === parameterName.escapedText), type);
    }
    function getUnionOrIntersectionType(types, kind, unionReduction) {
        return kind !== 2097152 ? getUnionType(types, unionReduction) : getIntersectionType(types);
    }
    function getReturnTypeOfSignature(signature) {
        if (!signature.resolvedReturnType) {
            if (!pushTypeResolution(signature, 3)) {
                return errorType;
            }
            let type = signature.target ? instantiateType(getReturnTypeOfSignature(signature.target), signature.mapper) : signature.compositeSignatures ? instantiateType(getUnionOrIntersectionType(map(signature.compositeSignatures, getReturnTypeOfSignature), signature.compositeKind, 2), signature.mapper) : getReturnTypeFromAnnotation(signature.declaration) || (nodeIsMissing(signature.declaration.body) ? anyType : getReturnTypeFromBody(signature.declaration));
            if (signature.flags & 8) {
                type = addOptionalTypeMarker(type);
            } else if (signature.flags & 16) {
                type = getOptionalType(type);
            }
            if (!popTypeResolution()) {
                if (signature.declaration) {
                    const typeNode = getEffectiveReturnTypeNode(signature.declaration);
                    if (typeNode) {
                        error(typeNode, Diagnostics.Return_type_annotation_circularly_references_itself);
                    } else if (noImplicitAny) {
                        const declaration = signature.declaration;
                        const name = getNameOfDeclaration(declaration);
                        if (name) {
                            error(name, Diagnostics._0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions, declarationNameToString(name));
                        } else {
                            error(declaration, Diagnostics.Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions);
                        }
                    }
                }
                type = anyType;
            }
            signature.resolvedReturnType = type;
        }
        return signature.resolvedReturnType;
    }
    function getReturnTypeFromAnnotation(declaration) {
        if (declaration.kind === 173) {
            return getDeclaredTypeOfClassOrInterface(getMergedSymbol(declaration.parent.symbol));
        }
        if (isJSDocSignature(declaration)) {
            const root = getJSDocRoot(declaration);
            if (root && isConstructorDeclaration(root.parent)) {
                return getDeclaredTypeOfClassOrInterface(getMergedSymbol(root.parent.parent.symbol));
            }
        }
        if (isJSDocConstructSignature(declaration)) {
            return getTypeFromTypeNode(declaration.parameters[0].type);
        }
        const typeNode = getEffectiveReturnTypeNode(declaration);
        if (typeNode) {
            return getTypeFromTypeNode(typeNode);
        }
        if (declaration.kind === 174 && hasBindableName(declaration)) {
            const jsDocType = isInJSFile(declaration) && getTypeForDeclarationFromJSDocComment(declaration);
            if (jsDocType) {
                return jsDocType;
            }
            const setter = getDeclarationOfKind(getSymbolOfDeclaration(declaration), 175);
            const setterType = getAnnotatedAccessorType(setter);
            if (setterType) {
                return setterType;
            }
        }
        return getReturnTypeOfTypeTag(declaration);
    }
    function isResolvingReturnTypeOfSignature(signature) {
        return !signature.resolvedReturnType && findResolutionCycleStartIndex(signature, 3) >= 0;
    }
    function getRestTypeOfSignature(signature) {
        return tryGetRestTypeOfSignature(signature) || anyType;
    }
    function tryGetRestTypeOfSignature(signature) {
        if (signatureHasRestParameter(signature)) {
            const sigRestType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
            const restType = isTupleType(sigRestType) ? getRestTypeOfTupleType(sigRestType) : sigRestType;
            return restType && getIndexTypeOfType(restType, numberType);
        }
        return void 0;
    }
    function getSignatureInstantiation(signature, typeArguments, isJavascript, inferredTypeParameters) {
        const instantiatedSignature = getSignatureInstantiationWithoutFillingInTypeArguments(signature, fillMissingTypeArguments(typeArguments, signature.typeParameters, getMinTypeArgumentCount(signature.typeParameters), isJavascript));
        if (inferredTypeParameters) {
            const returnSignature = getSingleCallOrConstructSignature(getReturnTypeOfSignature(instantiatedSignature));
            if (returnSignature) {
                const newReturnSignature = cloneSignature(returnSignature);
                newReturnSignature.typeParameters = inferredTypeParameters;
                const newInstantiatedSignature = cloneSignature(instantiatedSignature);
                newInstantiatedSignature.resolvedReturnType = getOrCreateTypeFromSignature(newReturnSignature);
                return newInstantiatedSignature;
            }
        }
        return instantiatedSignature;
    }
    function getSignatureInstantiationWithoutFillingInTypeArguments(signature, typeArguments) {
        const instantiations = signature.instantiations || (signature.instantiations = /* @__PURE__ */new Map());
        const id = getTypeListId(typeArguments);
        let instantiation = instantiations.get(id);
        if (!instantiation) {
            instantiations.set(id, instantiation = createSignatureInstantiation(signature, typeArguments));
        }
        return instantiation;
    }
    function createSignatureInstantiation(signature, typeArguments) {
        return instantiateSignature(signature, createSignatureTypeMapper(signature, typeArguments), true);
    }
    function createSignatureTypeMapper(signature, typeArguments) {
        return createTypeMapper(signature.typeParameters, typeArguments);
    }
    function getErasedSignature(signature) {
        return signature.typeParameters ? signature.erasedSignatureCache || (signature.erasedSignatureCache = createErasedSignature(signature)) : signature;
    }
    function createErasedSignature(signature) {
        return instantiateSignature(signature, createTypeEraser(signature.typeParameters), true);
    }
    function getCanonicalSignature(signature) {
        return signature.typeParameters ? signature.canonicalSignatureCache || (signature.canonicalSignatureCache = createCanonicalSignature(signature)) : signature;
    }
    function createCanonicalSignature(signature) {
        return getSignatureInstantiation(signature, map(signature.typeParameters, tp => tp.target && !getConstraintOfTypeParameter(tp.target) ? tp.target : tp), isInJSFile(signature.declaration));
    }
    function getBaseSignature(signature) {
        const typeParameters = signature.typeParameters;
        if (typeParameters) {
            if (signature.baseSignatureCache) {
                return signature.baseSignatureCache;
            }
            const typeEraser = createTypeEraser(typeParameters);
            const baseConstraintMapper = createTypeMapper(typeParameters, map(typeParameters, tp => getConstraintOfTypeParameter(tp) || unknownType));
            let baseConstraints = map(typeParameters, tp => instantiateType(tp, baseConstraintMapper) || unknownType);
            for (let i = 0; i < typeParameters.length - 1; i++) {
                baseConstraints = instantiateTypes(baseConstraints, baseConstraintMapper);
            }
            baseConstraints = instantiateTypes(baseConstraints, typeEraser);
            return signature.baseSignatureCache = instantiateSignature(signature, createTypeMapper(typeParameters, baseConstraints), true);
        }
        return signature;
    }
    function getOrCreateTypeFromSignature(signature) {
        var _a2;
        if (!signature.isolatedSignatureType) {
            const kind = (_a2 = signature.declaration) == null ? void 0 : _a2.kind;
            const isConstructor = kind === void 0 || kind === 173 || kind === 177 || kind === 182;
            const type = createObjectType(16);
            type.members = emptySymbols;
            type.properties = emptyArray;
            type.callSignatures = !isConstructor ? [signature] : emptyArray;
            type.constructSignatures = isConstructor ? [signature] : emptyArray;
            type.indexInfos = emptyArray;
            signature.isolatedSignatureType = type;
        }
        return signature.isolatedSignatureType;
    }
    function getIndexSymbol(symbol) {
        return symbol.members ? getIndexSymbolFromSymbolTable(symbol.members) : void 0;
    }
    function getIndexSymbolFromSymbolTable(symbolTable) {
        return symbolTable.get("__index");
    }
    function createIndexInfo(keyType, type, isReadonly, declaration) {
        return {
            keyType,
            type,
            isReadonly,
            declaration
        };
    }
    function getIndexInfosOfSymbol(symbol) {
        const indexSymbol = getIndexSymbol(symbol);
        return indexSymbol ? getIndexInfosOfIndexSymbol(indexSymbol) : emptyArray;
    }
    function getIndexInfosOfIndexSymbol(indexSymbol) {
        if (indexSymbol.declarations) {
            const indexInfos = [];
            for (const declaration of indexSymbol.declarations) {
                if (declaration.parameters.length === 1) {
                    const parameter = declaration.parameters[0];
                    if (parameter.type) {
                        forEachType(getTypeFromTypeNode(parameter.type), keyType => {
                            if (isValidIndexKeyType(keyType) && !findIndexInfo(indexInfos, keyType)) {
                                indexInfos.push(createIndexInfo(keyType, declaration.type ? getTypeFromTypeNode(declaration.type) : anyType, hasEffectiveModifier(declaration, 64), declaration));
                            }
                        });
                    }
                }
            }
            return indexInfos;
        }
        return emptyArray;
    }
    function isValidIndexKeyType(type) {
        return !!(type.flags & (4 | 8 | 4096)) || isPatternLiteralType(type) || !!(type.flags & 2097152) && !isGenericType(type) && some(type.types, isValidIndexKeyType);
    }
    function getConstraintDeclaration(type) {
        return mapDefined(filter(type.symbol && type.symbol.declarations, isTypeParameterDeclaration), getEffectiveConstraintOfTypeParameter)[0];
    }
    function getInferredTypeParameterConstraint(typeParameter, omitTypeReferences) {
        var _a2;
        let inferences;
        if ((_a2 = typeParameter.symbol) == null ? void 0 : _a2.declarations) {
            for (const declaration of typeParameter.symbol.declarations) {
                if (declaration.parent.kind === 192) {
                    const [childTypeParameter = declaration.parent, grandParent] = walkUpParenthesizedTypesAndGetParentAndChild(declaration.parent.parent);
                    if (grandParent.kind === 180 && !omitTypeReferences) {
                        const typeReference = grandParent;
                        const typeParameters = getTypeParametersForTypeReferenceOrImport(typeReference);
                        if (typeParameters) {
                            const index = typeReference.typeArguments.indexOf(childTypeParameter);
                            if (index < typeParameters.length) {
                                const declaredConstraint = getConstraintOfTypeParameter(typeParameters[index]);
                                if (declaredConstraint) {
                                    const mapper = makeDeferredTypeMapper(typeParameters, typeParameters.map((_, index2) => () => {
                                        return getEffectiveTypeArgumentAtIndex(typeReference, typeParameters, index2);
                                    }));
                                    const constraint = instantiateType(declaredConstraint, mapper);
                                    if (constraint !== typeParameter) {
                                        inferences = append(inferences, constraint);
                                    }
                                }
                            }
                        }
                    } else if (grandParent.kind === 166 && grandParent.dotDotDotToken || grandParent.kind === 188 || grandParent.kind === 199 && grandParent.dotDotDotToken) {
                        inferences = append(inferences, createArrayType(unknownType));
                    } else if (grandParent.kind === 201) {
                        inferences = append(inferences, stringType);
                    } else if (grandParent.kind === 165 && grandParent.parent.kind === 197) {
                        inferences = append(inferences, keyofConstraintType);
                    } else if (grandParent.kind === 197 && grandParent.type && skipParentheses(grandParent.type) === declaration.parent && grandParent.parent.kind === 191 && grandParent.parent.extendsType === grandParent && grandParent.parent.checkType.kind === 197 && grandParent.parent.checkType.type) {
                        const checkMappedType2 = grandParent.parent.checkType;
                        const nodeType = getTypeFromTypeNode(checkMappedType2.type);
                        inferences = append(inferences, instantiateType(nodeType, makeUnaryTypeMapper(getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(checkMappedType2.typeParameter)), checkMappedType2.typeParameter.constraint ? getTypeFromTypeNode(checkMappedType2.typeParameter.constraint) : keyofConstraintType)));
                    }
                }
            }
        }
        return inferences && getIntersectionType(inferences);
    }
    function getConstraintFromTypeParameter(typeParameter) {
        if (!typeParameter.constraint) {
            if (typeParameter.target) {
                const targetConstraint = getConstraintOfTypeParameter(typeParameter.target);
                typeParameter.constraint = targetConstraint ? instantiateType(targetConstraint, typeParameter.mapper) : noConstraintType;
            } else {
                const constraintDeclaration = getConstraintDeclaration(typeParameter);
                if (!constraintDeclaration) {
                    typeParameter.constraint = getInferredTypeParameterConstraint(typeParameter) || noConstraintType;
                } else {
                    let type = getTypeFromTypeNode(constraintDeclaration);
                    if (type.flags & 1 && !isErrorType(type)) {
                        type = constraintDeclaration.parent.parent.kind === 197 ? keyofConstraintType : unknownType;
                    }
                    typeParameter.constraint = type;
                }
            }
        }
        return typeParameter.constraint === noConstraintType ? void 0 : typeParameter.constraint;
    }
    function getParentSymbolOfTypeParameter(typeParameter) {
        const tp = getDeclarationOfKind(typeParameter.symbol, 165);
        const host2 = isJSDocTemplateTag(tp.parent) ? getEffectiveContainerForJSDocTemplateTag(tp.parent) : tp.parent;
        return host2 && getSymbolOfNode(host2);
    }
    function getTypeListId(types) {
        let result = "";
        if (types) {
            const length2 = types.length;
            let i = 0;
            while (i < length2) {
                const startId = types[i].id;
                let count = 1;
                while (i + count < length2 && types[i + count].id === startId + count) {
                    count++;
                }
                if (result.length) {
                    result += ",";
                }
                result += startId;
                if (count > 1) {
                    result += ":" + count;
                }
                i += count;
            }
        }
        return result;
    }
    function getAliasId(aliasSymbol, aliasTypeArguments) {
        return aliasSymbol ? `@${getSymbolId(aliasSymbol)}` + (aliasTypeArguments ? `:${getTypeListId(aliasTypeArguments)}` : "") : "";
    }
    function getPropagatingFlagsOfTypes(types, excludeKinds) {
        let result = 0;
        for (const type of types) {
            if (excludeKinds === void 0 || !(type.flags & excludeKinds)) {
                result |= getObjectFlags(type);
            }
        }
        return result & 458752;
    }
    function tryCreateTypeReference(target, typeArguments) {
        if (some(typeArguments) && target === emptyGenericType) {
            return unknownType;
        }
        return createTypeReference(target, typeArguments);
    }
    function createTypeReference(target, typeArguments) {
        const id = getTypeListId(typeArguments);
        let type = target.instantiations.get(id);
        if (!type) {
            type = createObjectType(4, target.symbol);
            target.instantiations.set(id, type);
            type.objectFlags |= typeArguments ? getPropagatingFlagsOfTypes(typeArguments) : 0;
            type.target = target;
            type.resolvedTypeArguments = typeArguments;
        }
        return type;
    }
    function cloneTypeReference(source) {
        const type = createTypeWithSymbol(source.flags, source.symbol);
        type.objectFlags = source.objectFlags;
        type.target = source.target;
        type.resolvedTypeArguments = source.resolvedTypeArguments;
        return type;
    }
    function createDeferredTypeReference(target, node, mapper, aliasSymbol, aliasTypeArguments) {
        if (!aliasSymbol) {
            aliasSymbol = getAliasSymbolForTypeNode(node);
            const localAliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
            aliasTypeArguments = mapper ? instantiateTypes(localAliasTypeArguments, mapper) : localAliasTypeArguments;
        }
        const type = createObjectType(4, target.symbol);
        type.target = target;
        type.node = node;
        type.mapper = mapper;
        type.aliasSymbol = aliasSymbol;
        type.aliasTypeArguments = aliasTypeArguments;
        return type;
    }
    function getTypeArguments(type) {
        var _a2, _b;
        if (!type.resolvedTypeArguments) {
            if (!pushTypeResolution(type, 6)) {
                return ((_a2 = type.target.localTypeParameters) == null ? void 0 : _a2.map(() => errorType)) || emptyArray;
            }
            const node = type.node;
            const typeArguments = !node ? emptyArray : node.kind === 180 ? concatenate(type.target.outerTypeParameters, getEffectiveTypeArguments2(node, type.target.localTypeParameters)) : node.kind === 185 ? [getTypeFromTypeNode(node.elementType)] : map(node.elements, getTypeFromTypeNode);
            if (popTypeResolution()) {
                type.resolvedTypeArguments = type.mapper ? instantiateTypes(typeArguments, type.mapper) : typeArguments;
            } else {
                type.resolvedTypeArguments = ((_b = type.target.localTypeParameters) == null ? void 0 : _b.map(() => errorType)) || emptyArray;
                error(type.node || currentNode, type.target.symbol ? Diagnostics.Type_arguments_for_0_circularly_reference_themselves : Diagnostics.Tuple_type_arguments_circularly_reference_themselves, type.target.symbol && symbolToString(type.target.symbol));
            }
        }
        return type.resolvedTypeArguments;
    }
    function getTypeReferenceArity(type) {
        return length(type.target.typeParameters);
    }
    function getTypeFromClassOrInterfaceReference(node, symbol) {
        const type = getDeclaredTypeOfSymbol(getMergedSymbol(symbol));
        const typeParameters = type.localTypeParameters;
        if (typeParameters) {
            const numTypeArguments = length(node.typeArguments);
            const minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
            const isJs = isInJSFile(node);
            const isJsImplicitAny = !noImplicitAny && isJs;
            if (!isJsImplicitAny && (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length)) {
                const missingAugmentsTag = isJs && isExpressionWithTypeArguments(node) && !isJSDocAugmentsTag(node.parent);
                const diag2 = minTypeArgumentCount === typeParameters.length ? missingAugmentsTag ? Diagnostics.Expected_0_type_arguments_provide_these_with_an_extends_tag : Diagnostics.Generic_type_0_requires_1_type_argument_s : missingAugmentsTag ? Diagnostics.Expected_0_1_type_arguments_provide_these_with_an_extends_tag : Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments;
                const typeStr = typeToString(type, void 0, 2);
                error(node, diag2, typeStr, minTypeArgumentCount, typeParameters.length);
                if (!isJs) {
                    return errorType;
                }
            }
            if (node.kind === 180 && isDeferredTypeReferenceNode(node, length(node.typeArguments) !== typeParameters.length)) {
                return createDeferredTypeReference(type, node, void 0);
            }
            const typeArguments = concatenate(type.outerTypeParameters, fillMissingTypeArguments(typeArgumentsFromTypeReferenceNode(node), typeParameters, minTypeArgumentCount, isJs));
            return createTypeReference(type, typeArguments);
        }
        return checkNoTypeArguments(node, symbol) ? type : errorType;
    }
    function getTypeAliasInstantiation(symbol, typeArguments, aliasSymbol, aliasTypeArguments) {
        const type = getDeclaredTypeOfSymbol(symbol);
        if (type === intrinsicMarkerType && intrinsicTypeKinds.has(symbol.escapedName) && typeArguments && typeArguments.length === 1) {
            return getStringMappingType(symbol, typeArguments[0]);
        }
        const links = getSymbolLinks(symbol);
        const typeParameters = links.typeParameters;
        const id = getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments);
        let instantiation = links.instantiations.get(id);
        if (!instantiation) {
            links.instantiations.set(id, instantiation = instantiateTypeWithAlias(type, createTypeMapper(typeParameters, fillMissingTypeArguments(typeArguments, typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(symbol.valueDeclaration))), aliasSymbol, aliasTypeArguments));
        }
        return instantiation;
    }
    function getTypeFromTypeAliasReference(node, symbol) {
        if (getCheckFlags(symbol) & 1048576) {
            const typeArguments = typeArgumentsFromTypeReferenceNode(node);
            const id = getAliasId(symbol, typeArguments);
            let errorType2 = errorTypes.get(id);
            if (!errorType2) {
                errorType2 = createIntrinsicType(1, "error");
                errorType2.aliasSymbol = symbol;
                errorType2.aliasTypeArguments = typeArguments;
                errorTypes.set(id, errorType2);
            }
            return errorType2;
        }
        const type = getDeclaredTypeOfSymbol(symbol);
        const typeParameters = getSymbolLinks(symbol).typeParameters;
        if (typeParameters) {
            const numTypeArguments = length(node.typeArguments);
            const minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
            if (numTypeArguments < minTypeArgumentCount || numTypeArguments > typeParameters.length) {
                error(node, minTypeArgumentCount === typeParameters.length ? Diagnostics.Generic_type_0_requires_1_type_argument_s : Diagnostics.Generic_type_0_requires_between_1_and_2_type_arguments, symbolToString(symbol), minTypeArgumentCount, typeParameters.length);
                return errorType;
            }
            const aliasSymbol = getAliasSymbolForTypeNode(node);
            let newAliasSymbol = aliasSymbol && (isLocalTypeAlias(symbol) || !isLocalTypeAlias(aliasSymbol)) ? aliasSymbol : void 0;
            let aliasTypeArguments;
            if (newAliasSymbol) {
                aliasTypeArguments = getTypeArgumentsForAliasSymbol(newAliasSymbol);
            } else if (isTypeReferenceType(node)) {
                const aliasSymbol2 = resolveTypeReferenceName(node, 2097152, true);
                if (aliasSymbol2 && aliasSymbol2 !== unknownSymbol) {
                    const resolved = resolveAlias(aliasSymbol2);
                    if (resolved && resolved.flags & 524288) {
                        newAliasSymbol = resolved;
                        aliasTypeArguments = typeArgumentsFromTypeReferenceNode(node) || (typeParameters ? [] : void 0);
                    }
                }
            }
            return getTypeAliasInstantiation(symbol, typeArgumentsFromTypeReferenceNode(node), newAliasSymbol, aliasTypeArguments);
        }
        return checkNoTypeArguments(node, symbol) ? type : errorType;
    }
    function isLocalTypeAlias(symbol) {
        var _a2;
        const declaration = (_a2 = symbol.declarations) == null ? void 0 : _a2.find(isTypeAlias);
        return !!(declaration && getContainingFunction(declaration));
    }
    function getTypeReferenceName(node) {
        switch (node.kind) {
            case 180:
                return node.typeName;
            case 230:
                const expr = node.expression;
                if (isEntityNameExpression(expr)) {
                    return expr;
                }
        }
        return void 0;
    }
    function getSymbolPath(symbol) {
        return symbol.parent ? `${getSymbolPath(symbol.parent)}.${symbol.escapedName}` : symbol.escapedName;
    }
    function getUnresolvedSymbolForEntityName(name) {
        const identifier = name.kind === 163 ? name.right : name.kind === 208 ? name.name : name;
        const text = identifier.escapedText;
        if (text) {
            const parentSymbol = name.kind === 163 ? getUnresolvedSymbolForEntityName(name.left) : name.kind === 208 ? getUnresolvedSymbolForEntityName(name.expression) : void 0;
            const path = parentSymbol ? `${getSymbolPath(parentSymbol)}.${text}` : text;
            let result = unresolvedSymbols.get(path);
            if (!result) {
                unresolvedSymbols.set(path, result = createSymbol(524288, text, 1048576));
                result.parent = parentSymbol;
                result.links.declaredType = unresolvedType;
            }
            return result;
        }
        return unknownSymbol;
    }
    function resolveTypeReferenceName(typeReference, meaning, ignoreErrors) {
        const name = getTypeReferenceName(typeReference);
        if (!name) {
            return unknownSymbol;
        }
        const symbol = resolveEntityName(name, meaning, ignoreErrors);
        return symbol && symbol !== unknownSymbol ? symbol : ignoreErrors ? unknownSymbol : getUnresolvedSymbolForEntityName(name);
    }
    function getTypeReferenceType(node, symbol) {
        if (symbol === unknownSymbol) {
            return errorType;
        }
        symbol = getExpandoSymbol(symbol) || symbol;
        if (symbol.flags & (32 | 64)) {
            return getTypeFromClassOrInterfaceReference(node, symbol);
        }
        if (symbol.flags & 524288) {
            return getTypeFromTypeAliasReference(node, symbol);
        }
        const res = tryGetDeclaredTypeOfSymbol(symbol);
        if (res) {
            return checkNoTypeArguments(node, symbol) ? getRegularTypeOfLiteralType(res) : errorType;
        }
        if (symbol.flags & 111551 && isJSDocTypeReference(node)) {
            const jsdocType = getTypeFromJSDocValueReference(node, symbol);
            if (jsdocType) {
                return jsdocType;
            } else {
                resolveTypeReferenceName(node, 788968);
                return getTypeOfSymbol(symbol);
            }
        }
        return errorType;
    }
    function getTypeFromJSDocValueReference(node, symbol) {
        const links = getNodeLinks(node);
        if (!links.resolvedJSDocType) {
            const valueType = getTypeOfSymbol(symbol);
            let typeType = valueType;
            if (symbol.valueDeclaration) {
                const isImportTypeWithQualifier = node.kind === 202 && node.qualifier;
                if (valueType.symbol && valueType.symbol !== symbol && isImportTypeWithQualifier) {
                    typeType = getTypeReferenceType(node, valueType.symbol);
                }
            }
            links.resolvedJSDocType = typeType;
        }
        return links.resolvedJSDocType;
    }
    function getSubstitutionType(baseType, constraint) {
        if (constraint.flags & 3 || constraint === baseType || baseType.flags & 1) {
            return baseType;
        }
        const id = `${getTypeId(baseType)}>${getTypeId(constraint)}`;
        const cached = substitutionTypes.get(id);
        if (cached) {
            return cached;
        }
        const result = createType(33554432);
        result.baseType = baseType;
        result.constraint = constraint;
        substitutionTypes.set(id, result);
        return result;
    }
    function getSubstitutionIntersection(substitutionType) {
        return getIntersectionType([substitutionType.constraint, substitutionType.baseType]);
    }
    function isUnaryTupleTypeNode(node) {
        return node.kind === 186 && node.elements.length === 1;
    }
    function getImpliedConstraint(type, checkNode, extendsNode) {
        return isUnaryTupleTypeNode(checkNode) && isUnaryTupleTypeNode(extendsNode) ? getImpliedConstraint(type, checkNode.elements[0], extendsNode.elements[0]) : getActualTypeVariable(getTypeFromTypeNode(checkNode)) === getActualTypeVariable(type) ? getTypeFromTypeNode(extendsNode) : void 0;
    }
    function getConditionalFlowTypeOfType(type, node) {
        let constraints;
        let covariant = true;
        while (node && !isStatement(node) && node.kind !== 323) {
            const parent2 = node.parent;
            if (parent2.kind === 166) {
                covariant = !covariant;
            }
            if ((covariant || type.flags & 8650752) && parent2.kind === 191 && node === parent2.trueType) {
                const constraint = getImpliedConstraint(type, parent2.checkType, parent2.extendsType);
                if (constraint) {
                    constraints = append(constraints, constraint);
                }
            } else if (type.flags & 262144 && parent2.kind === 197 && node === parent2.type) {
                const mappedType = getTypeFromTypeNode(parent2);
                if (getTypeParameterFromMappedType(mappedType) === getActualTypeVariable(type)) {
                    const typeParameter = getHomomorphicTypeVariable(mappedType);
                    if (typeParameter) {
                        const constraint = getConstraintOfTypeParameter(typeParameter);
                        if (constraint && everyType(constraint, isArrayOrTupleType)) {
                            constraints = append(constraints, getUnionType([numberType, numericStringType]));
                        }
                    }
                }
            }
            node = parent2;
        }
        return constraints ? getSubstitutionType(type, getIntersectionType(constraints)) : type;
    }
    function isJSDocTypeReference(node) {
        return !!(node.flags & 8388608) && (node.kind === 180 || node.kind === 202);
    }
    function checkNoTypeArguments(node, symbol) {
        if (node.typeArguments) {
            error(node, Diagnostics.Type_0_is_not_generic, symbol ? symbolToString(symbol) : node.typeName ? declarationNameToString(node.typeName) : anon);
            return false;
        }
        return true;
    }
    function getIntendedTypeFromJSDocTypeReference(node) {
        if (isIdentifier(node.typeName)) {
            const typeArgs = node.typeArguments;
            switch (node.typeName.escapedText) {
                case "String":
                    checkNoTypeArguments(node);
                    return stringType;
                case "Number":
                    checkNoTypeArguments(node);
                    return numberType;
                case "Boolean":
                    checkNoTypeArguments(node);
                    return booleanType;
                case "Void":
                    checkNoTypeArguments(node);
                    return voidType;
                case "Undefined":
                    checkNoTypeArguments(node);
                    return undefinedType;
                case "Null":
                    checkNoTypeArguments(node);
                    return nullType;
                case "Function":
                case "function":
                    checkNoTypeArguments(node);
                    return globalFunctionType;
                case "array":
                    return (!typeArgs || !typeArgs.length) && !noImplicitAny ? anyArrayType : void 0;
                case "promise":
                    return (!typeArgs || !typeArgs.length) && !noImplicitAny ? createPromiseType(anyType) : void 0;
                case "Object":
                    if (typeArgs && typeArgs.length === 2) {
                        if (isJSDocIndexSignature(node)) {
                            const indexed = getTypeFromTypeNode(typeArgs[0]);
                            const target = getTypeFromTypeNode(typeArgs[1]);
                            const indexInfo = indexed === stringType || indexed === numberType ? [createIndexInfo(indexed, target, false)] : emptyArray;
                            return createAnonymousType(void 0, emptySymbols, emptyArray, emptyArray, indexInfo);
                        }
                        return anyType;
                    }
                    checkNoTypeArguments(node);
                    return !noImplicitAny ? anyType : void 0;
            }
        }
    }
    function getTypeFromJSDocNullableTypeNode(node) {
        const type = getTypeFromTypeNode(node.type);
        return strictNullChecks ? getNullableType(type, 65536) : type;
    }
    function getTypeFromTypeReference(node) {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            if (isConstTypeReference(node) && isAssertionExpression(node.parent)) {
                links.resolvedSymbol = unknownSymbol;
                return links.resolvedType = checkExpressionCached(node.parent.expression);
            }
            let symbol;
            let type;
            const meaning = 788968;
            if (isJSDocTypeReference(node)) {
                type = getIntendedTypeFromJSDocTypeReference(node);
                if (!type) {
                    symbol = resolveTypeReferenceName(node, meaning, true);
                    if (symbol === unknownSymbol) {
                        symbol = resolveTypeReferenceName(node, meaning | 111551);
                    } else {
                        resolveTypeReferenceName(node, meaning);
                    }
                    type = getTypeReferenceType(node, symbol);
                }
            }
            if (!type) {
                symbol = resolveTypeReferenceName(node, meaning);
                type = getTypeReferenceType(node, symbol);
            }
            links.resolvedSymbol = symbol;
            links.resolvedType = type;
        }
        return links.resolvedType;
    }
    function typeArgumentsFromTypeReferenceNode(node) {
        return map(node.typeArguments, getTypeFromTypeNode);
    }
    function getTypeFromTypeQueryNode(node) {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const type = checkExpressionWithTypeArguments(node);
            links.resolvedType = getRegularTypeOfLiteralType(getWidenedType(type));
        }
        return links.resolvedType;
    }
    function getTypeOfGlobalSymbol(symbol, arity) {
        function getTypeDeclaration(symbol2) {
            const declarations = symbol2.declarations;
            if (declarations) {
                for (const declaration of declarations) {
                    switch (declaration.kind) {
                        case 260:
                        case 261:
                        case 263:
                            return declaration;
                    }
                }
            }
        }
        if (!symbol) {
            return arity ? emptyGenericType : emptyObjectType;
        }
        const type = getDeclaredTypeOfSymbol(symbol);
        if (!(type.flags & 524288)) {
            error(getTypeDeclaration(symbol), Diagnostics.Global_type_0_must_be_a_class_or_interface_type, symbolName(symbol));
            return arity ? emptyGenericType : emptyObjectType;
        }
        if (length(type.typeParameters) !== arity) {
            error(getTypeDeclaration(symbol), Diagnostics.Global_type_0_must_have_1_type_parameter_s, symbolName(symbol), arity);
            return arity ? emptyGenericType : emptyObjectType;
        }
        return type;
    }
    function getGlobalValueSymbol(name, reportErrors2) {
        return getGlobalSymbol(name, 111551, reportErrors2 ? Diagnostics.Cannot_find_global_value_0 : void 0);
    }
    function getGlobalTypeSymbol(name, reportErrors2) {
        return getGlobalSymbol(name, 788968, reportErrors2 ? Diagnostics.Cannot_find_global_type_0 : void 0);
    }
    function getGlobalTypeAliasSymbol(name, arity, reportErrors2) {
        const symbol = getGlobalSymbol(name, 788968, reportErrors2 ? Diagnostics.Cannot_find_global_type_0 : void 0);
        if (symbol) {
            getDeclaredTypeOfSymbol(symbol);
            if (length(getSymbolLinks(symbol).typeParameters) !== arity) {
                const decl = symbol.declarations && find(symbol.declarations, isTypeAliasDeclaration);
                error(decl, Diagnostics.Global_type_0_must_have_1_type_parameter_s, symbolName(symbol), arity);
                return void 0;
            }
        }
        return symbol;
    }
    function getGlobalSymbol(name, meaning, diagnostic) {
        return resolveName(void 0, name, meaning, diagnostic, name, false, false, false);
    }
    function getGlobalType(name, arity, reportErrors2) {
        const symbol = getGlobalTypeSymbol(name, reportErrors2);
        return symbol || reportErrors2 ? getTypeOfGlobalSymbol(symbol, arity) : void 0;
    }
    function getGlobalTypedPropertyDescriptorType() {
        return deferredGlobalTypedPropertyDescriptorType || (deferredGlobalTypedPropertyDescriptorType = getGlobalType("TypedPropertyDescriptor", 1, true) || emptyGenericType);
    }
    function getGlobalTemplateStringsArrayType() {
        return deferredGlobalTemplateStringsArrayType || (deferredGlobalTemplateStringsArrayType = getGlobalType("TemplateStringsArray", 0, true) || emptyObjectType);
    }
    function getGlobalImportMetaType() {
        return deferredGlobalImportMetaType || (deferredGlobalImportMetaType = getGlobalType("ImportMeta", 0, true) || emptyObjectType);
    }
    function getGlobalImportMetaExpressionType() {
        if (!deferredGlobalImportMetaExpressionType) {
            const symbol = createSymbol(0, "ImportMetaExpression");
            const importMetaType = getGlobalImportMetaType();
            const metaPropertySymbol = createSymbol(4, "meta", 8);
            metaPropertySymbol.parent = symbol;
            metaPropertySymbol.links.type = importMetaType;
            const members = createSymbolTable([metaPropertySymbol]);
            symbol.members = members;
            deferredGlobalImportMetaExpressionType = createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray);
        }
        return deferredGlobalImportMetaExpressionType;
    }
    function getGlobalImportCallOptionsType(reportErrors2) {
        return deferredGlobalImportCallOptionsType || (deferredGlobalImportCallOptionsType = getGlobalType("ImportCallOptions", 0, reportErrors2)) || emptyObjectType;
    }
    function getGlobalESSymbolConstructorSymbol(reportErrors2) {
        return deferredGlobalESSymbolConstructorSymbol || (deferredGlobalESSymbolConstructorSymbol = getGlobalValueSymbol("Symbol", reportErrors2));
    }
    function getGlobalESSymbolConstructorTypeSymbol(reportErrors2) {
        return deferredGlobalESSymbolConstructorTypeSymbol || (deferredGlobalESSymbolConstructorTypeSymbol = getGlobalTypeSymbol("SymbolConstructor", reportErrors2));
    }
    function getGlobalESSymbolType() {
        return deferredGlobalESSymbolType || (deferredGlobalESSymbolType = getGlobalType("Symbol", 0, false)) || emptyObjectType;
    }
    function getGlobalPromiseType(reportErrors2) {
        return deferredGlobalPromiseType || (deferredGlobalPromiseType = getGlobalType("Promise", 1, reportErrors2)) || emptyGenericType;
    }
    function getGlobalPromiseLikeType(reportErrors2) {
        return deferredGlobalPromiseLikeType || (deferredGlobalPromiseLikeType = getGlobalType("PromiseLike", 1, reportErrors2)) || emptyGenericType;
    }
    function getGlobalPromiseConstructorSymbol(reportErrors2) {
        return deferredGlobalPromiseConstructorSymbol || (deferredGlobalPromiseConstructorSymbol = getGlobalValueSymbol("Promise", reportErrors2));
    }
    function getGlobalPromiseConstructorLikeType(reportErrors2) {
        return deferredGlobalPromiseConstructorLikeType || (deferredGlobalPromiseConstructorLikeType = getGlobalType("PromiseConstructorLike", 0, reportErrors2)) || emptyObjectType;
    }
    function getGlobalAsyncIterableType(reportErrors2) {
        return deferredGlobalAsyncIterableType || (deferredGlobalAsyncIterableType = getGlobalType("AsyncIterable", 1, reportErrors2)) || emptyGenericType;
    }
    function getGlobalAsyncIteratorType(reportErrors2) {
        return deferredGlobalAsyncIteratorType || (deferredGlobalAsyncIteratorType = getGlobalType("AsyncIterator", 3, reportErrors2)) || emptyGenericType;
    }
    function getGlobalAsyncIterableIteratorType(reportErrors2) {
        return deferredGlobalAsyncIterableIteratorType || (deferredGlobalAsyncIterableIteratorType = getGlobalType("AsyncIterableIterator", 1, reportErrors2)) || emptyGenericType;
    }
    function getGlobalAsyncGeneratorType(reportErrors2) {
        return deferredGlobalAsyncGeneratorType || (deferredGlobalAsyncGeneratorType = getGlobalType("AsyncGenerator", 3, reportErrors2)) || emptyGenericType;
    }
    function getGlobalIterableType(reportErrors2) {
        return deferredGlobalIterableType || (deferredGlobalIterableType = getGlobalType("Iterable", 1, reportErrors2)) || emptyGenericType;
    }
    function getGlobalIteratorType(reportErrors2) {
        return deferredGlobalIteratorType || (deferredGlobalIteratorType = getGlobalType("Iterator", 3, reportErrors2)) || emptyGenericType;
    }
    function getGlobalIterableIteratorType(reportErrors2) {
        return deferredGlobalIterableIteratorType || (deferredGlobalIterableIteratorType = getGlobalType("IterableIterator", 1, reportErrors2)) || emptyGenericType;
    }
    function getGlobalGeneratorType(reportErrors2) {
        return deferredGlobalGeneratorType || (deferredGlobalGeneratorType = getGlobalType("Generator", 3, reportErrors2)) || emptyGenericType;
    }
    function getGlobalIteratorYieldResultType(reportErrors2) {
        return deferredGlobalIteratorYieldResultType || (deferredGlobalIteratorYieldResultType = getGlobalType("IteratorYieldResult", 1, reportErrors2)) || emptyGenericType;
    }
    function getGlobalIteratorReturnResultType(reportErrors2) {
        return deferredGlobalIteratorReturnResultType || (deferredGlobalIteratorReturnResultType = getGlobalType("IteratorReturnResult", 1, reportErrors2)) || emptyGenericType;
    }
    function getGlobalTypeOrUndefined(name, arity = 0) {
        const symbol = getGlobalSymbol(name, 788968, void 0);
        return symbol && getTypeOfGlobalSymbol(symbol, arity);
    }
    function getGlobalExtractSymbol() {
        deferredGlobalExtractSymbol || (deferredGlobalExtractSymbol = getGlobalTypeAliasSymbol("Extract", 2, true) || unknownSymbol);
        return deferredGlobalExtractSymbol === unknownSymbol ? void 0 : deferredGlobalExtractSymbol;
    }
    function getGlobalOmitSymbol() {
        deferredGlobalOmitSymbol || (deferredGlobalOmitSymbol = getGlobalTypeAliasSymbol("Omit", 2, true) || unknownSymbol);
        return deferredGlobalOmitSymbol === unknownSymbol ? void 0 : deferredGlobalOmitSymbol;
    }
    function getGlobalAwaitedSymbol(reportErrors2) {
        deferredGlobalAwaitedSymbol || (deferredGlobalAwaitedSymbol = getGlobalTypeAliasSymbol("Awaited", 1, reportErrors2) || (reportErrors2 ? unknownSymbol : void 0));
        return deferredGlobalAwaitedSymbol === unknownSymbol ? void 0 : deferredGlobalAwaitedSymbol;
    }
    function getGlobalBigIntType() {
        return deferredGlobalBigIntType || (deferredGlobalBigIntType = getGlobalType("BigInt", 0, false)) || emptyObjectType;
    }
    function getGlobalClassDecoratorContextType(reportErrors2) {
        var _a2;
        return (_a2 = deferredGlobalClassDecoratorContextType != null ? deferredGlobalClassDecoratorContextType : deferredGlobalClassDecoratorContextType = getGlobalType("ClassDecoratorContext", 1, reportErrors2)) != null ? _a2 : emptyGenericType;
    }
    function getGlobalClassMethodDecoratorContextType(reportErrors2) {
        var _a2;
        return (_a2 = deferredGlobalClassMethodDecoratorContextType != null ? deferredGlobalClassMethodDecoratorContextType : deferredGlobalClassMethodDecoratorContextType = getGlobalType("ClassMethodDecoratorContext", 2, reportErrors2)) != null ? _a2 : emptyGenericType;
    }
    function getGlobalClassGetterDecoratorContextType(reportErrors2) {
        var _a2;
        return (_a2 = deferredGlobalClassGetterDecoratorContextType != null ? deferredGlobalClassGetterDecoratorContextType : deferredGlobalClassGetterDecoratorContextType = getGlobalType("ClassGetterDecoratorContext", 2, reportErrors2)) != null ? _a2 : emptyGenericType;
    }
    function getGlobalClassSetterDecoratorContextType(reportErrors2) {
        var _a2;
        return (_a2 = deferredGlobalClassSetterDecoratorContextType != null ? deferredGlobalClassSetterDecoratorContextType : deferredGlobalClassSetterDecoratorContextType = getGlobalType("ClassSetterDecoratorContext", 2, reportErrors2)) != null ? _a2 : emptyGenericType;
    }
    function getGlobalClassAccessorDecoratorContextType(reportErrors2) {
        var _a2;
        return (_a2 = deferredGlobalClassAccessorDecoratorContextType != null ? deferredGlobalClassAccessorDecoratorContextType : deferredGlobalClassAccessorDecoratorContextType = getGlobalType("ClassAccessorDecoratorContext", 2, reportErrors2)) != null ? _a2 : emptyGenericType;
    }
    function getGlobalClassAccessorDecoratorTargetType(reportErrors2) {
        var _a2;
        return (_a2 = deferredGlobalClassAccessorDecoratorTargetType != null ? deferredGlobalClassAccessorDecoratorTargetType : deferredGlobalClassAccessorDecoratorTargetType = getGlobalType("ClassAccessorDecoratorTarget", 2, reportErrors2)) != null ? _a2 : emptyGenericType;
    }
    function getGlobalClassAccessorDecoratorResultType(reportErrors2) {
        var _a2;
        return (_a2 = deferredGlobalClassAccessorDecoratorResultType != null ? deferredGlobalClassAccessorDecoratorResultType : deferredGlobalClassAccessorDecoratorResultType = getGlobalType("ClassAccessorDecoratorResult", 2, reportErrors2)) != null ? _a2 : emptyGenericType;
    }
    function getGlobalClassFieldDecoratorContextType(reportErrors2) {
        var _a2;
        return (_a2 = deferredGlobalClassFieldDecoratorContextType != null ? deferredGlobalClassFieldDecoratorContextType : deferredGlobalClassFieldDecoratorContextType = getGlobalType("ClassFieldDecoratorContext", 2, reportErrors2)) != null ? _a2 : emptyGenericType;
    }
    function getGlobalNaNSymbol() {
        return deferredGlobalNaNSymbol || (deferredGlobalNaNSymbol = getGlobalValueSymbol("NaN", false));
    }
    function getGlobalRecordSymbol() {
        deferredGlobalRecordSymbol || (deferredGlobalRecordSymbol = getGlobalTypeAliasSymbol("Record", 2, true) || unknownSymbol);
        return deferredGlobalRecordSymbol === unknownSymbol ? void 0 : deferredGlobalRecordSymbol;
    }
    function createTypeFromGenericGlobalType(genericGlobalType, typeArguments) {
        return genericGlobalType !== emptyGenericType ? createTypeReference(genericGlobalType, typeArguments) : emptyObjectType;
    }
    function createTypedPropertyDescriptorType(propertyType) {
        return createTypeFromGenericGlobalType(getGlobalTypedPropertyDescriptorType(), [propertyType]);
    }
    function createIterableType(iteratedType) {
        return createTypeFromGenericGlobalType(getGlobalIterableType(true), [iteratedType]);
    }
    function createArrayType(elementType, readonly) {
        return createTypeFromGenericGlobalType(readonly ? globalReadonlyArrayType : globalArrayType, [elementType]);
    }
    function getTupleElementFlags(node) {
        switch (node.kind) {
            case 187:
                return 2;
            case 188:
                return getRestTypeElementFlags(node);
            case 199:
                return node.questionToken ? 2 : node.dotDotDotToken ? getRestTypeElementFlags(node) : 1;
            default:
                return 1;
        }
    }
    function getRestTypeElementFlags(node) {
        return getArrayElementTypeNode(node.type) ? 4 : 8;
    }
    function getArrayOrTupleTargetType(node) {
        const readonly = isReadonlyTypeOperator(node.parent);
        const elementType = getArrayElementTypeNode(node);
        if (elementType) {
            return readonly ? globalReadonlyArrayType : globalArrayType;
        }
        const elementFlags = map(node.elements, getTupleElementFlags);
        const missingName = some(node.elements, e => e.kind !== 199);
        return getTupleTargetType(elementFlags, readonly, missingName ? void 0 : node.elements);
    }
    function isDeferredTypeReferenceNode(node, hasDefaultTypeArguments) {
        return !!getAliasSymbolForTypeNode(node) || isResolvedByTypeAlias(node) && (node.kind === 185 ? mayResolveTypeAlias(node.elementType) : node.kind === 186 ? some(node.elements, mayResolveTypeAlias) : hasDefaultTypeArguments || some(node.typeArguments, mayResolveTypeAlias));
    }
    function isResolvedByTypeAlias(node) {
        const parent2 = node.parent;
        switch (parent2.kind) {
            case 193:
            case 199:
            case 180:
            case 189:
            case 190:
            case 196:
            case 191:
            case 195:
            case 185:
            case 186:
                return isResolvedByTypeAlias(parent2);
            case 262:
                return true;
        }
        return false;
    }
    function mayResolveTypeAlias(node) {
        switch (node.kind) {
            case 180:
                return isJSDocTypeReference(node) || !!(resolveTypeReferenceName(node, 788968).flags & 524288);
            case 183:
                return true;
            case 195:
                return node.operator !== 156 && mayResolveTypeAlias(node.type);
            case 193:
            case 187:
            case 199:
            case 319:
            case 317:
            case 318:
            case 312:
                return mayResolveTypeAlias(node.type);
            case 188:
                return node.type.kind !== 185 || mayResolveTypeAlias(node.type.elementType);
            case 189:
            case 190:
                return some(node.types, mayResolveTypeAlias);
            case 196:
                return mayResolveTypeAlias(node.objectType) || mayResolveTypeAlias(node.indexType);
            case 191:
                return mayResolveTypeAlias(node.checkType) || mayResolveTypeAlias(node.extendsType) || mayResolveTypeAlias(node.trueType) || mayResolveTypeAlias(node.falseType);
        }
        return false;
    }
    function getTypeFromArrayOrTupleTypeNode(node) {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const target = getArrayOrTupleTargetType(node);
            if (target === emptyGenericType) {
                links.resolvedType = emptyObjectType;
            } else if (!(node.kind === 186 && some(node.elements, e => !!(getTupleElementFlags(e) & 8))) && isDeferredTypeReferenceNode(node)) {
                links.resolvedType = node.kind === 186 && node.elements.length === 0 ? target : createDeferredTypeReference(target, node, void 0);
            } else {
                const elementTypes = node.kind === 185 ? [getTypeFromTypeNode(node.elementType)] : map(node.elements, getTypeFromTypeNode);
                links.resolvedType = createNormalizedTypeReference(target, elementTypes);
            }
        }
        return links.resolvedType;
    }
    function isReadonlyTypeOperator(node) {
        return isTypeOperatorNode(node) && node.operator === 146;
    }
    function createTupleType(elementTypes, elementFlags, readonly = false, namedMemberDeclarations) {
        const tupleTarget = getTupleTargetType(elementFlags || map(elementTypes, _ => 1), readonly, namedMemberDeclarations);
        return tupleTarget === emptyGenericType ? emptyObjectType : elementTypes.length ? createNormalizedTypeReference(tupleTarget, elementTypes) : tupleTarget;
    }
    function getTupleTargetType(elementFlags, readonly, namedMemberDeclarations) {
        if (elementFlags.length === 1 && elementFlags[0] & 4) {
            return readonly ? globalReadonlyArrayType : globalArrayType;
        }
        const key = map(elementFlags, f => f & 1 ? "#" : f & 2 ? "?" : f & 4 ? "." : "*").join() + (readonly ? "R" : "") + (namedMemberDeclarations && namedMemberDeclarations.length ? "," + map(namedMemberDeclarations, getNodeId).join(",") : "");
        let type = tupleTypes.get(key);
        if (!type) {
            tupleTypes.set(key, type = createTupleTargetType(elementFlags, readonly, namedMemberDeclarations));
        }
        return type;
    }
    function createTupleTargetType(elementFlags, readonly, namedMemberDeclarations) {
        const arity = elementFlags.length;
        const minLength = countWhere(elementFlags, f => !!(f & (1 | 8)));
        let typeParameters;
        const properties = [];
        let combinedFlags = 0;
        if (arity) {
            typeParameters = new Array(arity);
            for (let i = 0; i < arity; i++) {
                const typeParameter = typeParameters[i] = createTypeParameter();
                const flags = elementFlags[i];
                combinedFlags |= flags;
                if (!(combinedFlags & 12)) {
                    const property = createSymbol(4 | (flags & 2 ? 16777216 : 0), "" + i, readonly ? 8 : 0);
                    property.links.tupleLabelDeclaration = namedMemberDeclarations == null ? void 0 : namedMemberDeclarations[i];
                    property.links.type = typeParameter;
                    properties.push(property);
                }
            }
        }
        const fixedLength = properties.length;
        const lengthSymbol = createSymbol(4, "length", readonly ? 8 : 0);
        if (combinedFlags & 12) {
            lengthSymbol.links.type = numberType;
        } else {
            const literalTypes = [];
            for (let i = minLength; i <= arity; i++) literalTypes.push(getNumberLiteralType(i));
            lengthSymbol.links.type = getUnionType(literalTypes);
        }
        properties.push(lengthSymbol);
        const type = createObjectType(8 | 4);
        type.typeParameters = typeParameters;
        type.outerTypeParameters = void 0;
        type.localTypeParameters = typeParameters;
        type.instantiations = /* @__PURE__ */new Map();
        type.instantiations.set(getTypeListId(type.typeParameters), type);
        type.target = type;
        type.resolvedTypeArguments = type.typeParameters;
        type.thisType = createTypeParameter();
        type.thisType.isThisType = true;
        type.thisType.constraint = type;
        type.declaredProperties = properties;
        type.declaredCallSignatures = emptyArray;
        type.declaredConstructSignatures = emptyArray;
        type.declaredIndexInfos = emptyArray;
        type.elementFlags = elementFlags;
        type.minLength = minLength;
        type.fixedLength = fixedLength;
        type.hasRestElement = !!(combinedFlags & 12);
        type.combinedFlags = combinedFlags;
        type.readonly = readonly;
        type.labeledElementDeclarations = namedMemberDeclarations;
        return type;
    }
    function createNormalizedTypeReference(target, typeArguments) {
        return target.objectFlags & 8 ? createNormalizedTupleType(target, typeArguments) : createTypeReference(target, typeArguments);
    }
    function createNormalizedTupleType(target, elementTypes) {
        var _a2, _b, _c;
        if (!(target.combinedFlags & 14)) {
            return createTypeReference(target, elementTypes);
        }
        if (target.combinedFlags & 8) {
            const unionIndex = findIndex(elementTypes, (t, i) => !!(target.elementFlags[i] & 8 && t.flags & (131072 | 1048576)));
            if (unionIndex >= 0) {
                return checkCrossProductUnion(map(elementTypes, (t, i) => target.elementFlags[i] & 8 ? t : unknownType)) ? mapType(elementTypes[unionIndex], t => createNormalizedTupleType(target, replaceElement(elementTypes, unionIndex, t))) : errorType;
            }
        }
        const expandedTypes = [];
        const expandedFlags = [];
        let expandedDeclarations = [];
        let lastRequiredIndex = -1;
        let firstRestIndex = -1;
        let lastOptionalOrRestIndex = -1;
        for (let i = 0; i < elementTypes.length; i++) {
            const type = elementTypes[i];
            const flags = target.elementFlags[i];
            if (flags & 8) {
                if (type.flags & 58982400 || isGenericMappedType(type)) {
                    addElement(type, 8, (_a2 = target.labeledElementDeclarations) == null ? void 0 : _a2[i]);
                } else if (isTupleType(type)) {
                    const elements = getTypeArguments(type);
                    if (elements.length + expandedTypes.length >= 1e4) {
                        error(currentNode, isPartOfTypeNode(currentNode) ? Diagnostics.Type_produces_a_tuple_type_that_is_too_large_to_represent : Diagnostics.Expression_produces_a_tuple_type_that_is_too_large_to_represent);
                        return errorType;
                    }
                    forEach(elements, (t, n) => {
                        var _a3;
                        return addElement(t, type.target.elementFlags[n], (_a3 = type.target.labeledElementDeclarations) == null ? void 0 : _a3[n]);
                    });
                } else {
                    addElement(isArrayLikeType(type) && getIndexTypeOfType(type, numberType) || errorType, 4, (_b = target.labeledElementDeclarations) == null ? void 0 : _b[i]);
                }
            } else {
                addElement(type, flags, (_c = target.labeledElementDeclarations) == null ? void 0 : _c[i]);
            }
        }
        for (let i = 0; i < lastRequiredIndex; i++) {
            if (expandedFlags[i] & 2) expandedFlags[i] = 1;
        }
        if (firstRestIndex >= 0 && firstRestIndex < lastOptionalOrRestIndex) {
            expandedTypes[firstRestIndex] = getUnionType(sameMap(expandedTypes.slice(firstRestIndex, lastOptionalOrRestIndex + 1), (t, i) => expandedFlags[firstRestIndex + i] & 8 ? getIndexedAccessType(t, numberType) : t));
            expandedTypes.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex);
            expandedFlags.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex);
            expandedDeclarations == null ? void 0 : expandedDeclarations.splice(firstRestIndex + 1, lastOptionalOrRestIndex - firstRestIndex);
        }
        const tupleTarget = getTupleTargetType(expandedFlags, target.readonly, expandedDeclarations);
        return tupleTarget === emptyGenericType ? emptyObjectType : expandedFlags.length ? createTypeReference(tupleTarget, expandedTypes) : tupleTarget;
        function addElement(type, flags, declaration) {
            if (flags & 1) {
                lastRequiredIndex = expandedFlags.length;
            }
            if (flags & 4 && firstRestIndex < 0) {
                firstRestIndex = expandedFlags.length;
            }
            if (flags & (2 | 4)) {
                lastOptionalOrRestIndex = expandedFlags.length;
            }
            expandedTypes.push(flags & 2 ? addOptionality(type, true) : type);
            expandedFlags.push(flags);
            if (expandedDeclarations && declaration) {
                expandedDeclarations.push(declaration);
            } else {
                expandedDeclarations = void 0;
            }
        }
    }
    function sliceTupleType(type, index, endSkipCount = 0) {
        const target = type.target;
        const endIndex = getTypeReferenceArity(type) - endSkipCount;
        return index > target.fixedLength ? getRestArrayTypeOfTupleType(type) || createTupleType(emptyArray) : createTupleType(getTypeArguments(type).slice(index, endIndex), target.elementFlags.slice(index, endIndex), false, target.labeledElementDeclarations && target.labeledElementDeclarations.slice(index, endIndex));
    }
    function getKnownKeysOfTupleType(type) {
        return getUnionType(append(arrayOf(type.target.fixedLength, i => getStringLiteralType("" + i)), getIndexType(type.target.readonly ? globalReadonlyArrayType : globalArrayType)));
    }
    function getEndElementCount(type, flags) {
        return type.elementFlags.length - findLastIndex(type.elementFlags, f => !(f & flags)) - 1;
    }
    function getTypeFromOptionalTypeNode(node) {
        return addOptionality(getTypeFromTypeNode(node.type), true);
    }
    function getTypeId(type) {
        return type.id;
    }
    function containsType(types, type) {
        return binarySearch(types, type, getTypeId, compareValues) >= 0;
    }
    function insertType(types, type) {
        const index = binarySearch(types, type, getTypeId, compareValues);
        if (index < 0) {
            types.splice(~index, 0, type);
            return true;
        }
        return false;
    }
    function addTypeToUnion(typeSet, includes, type) {
        const flags = type.flags;
        if (flags & 1048576) {
            return addTypesToUnion(typeSet, includes | (isNamedUnionType(type) ? 1048576 : 0), type.types);
        }
        if (!(flags & 131072)) {
            includes |= flags & 205258751;
            if (flags & 465829888) includes |= 33554432;
            if (type === wildcardType) includes |= 8388608;
            if (!strictNullChecks && flags & 98304) {
                if (!(getObjectFlags(type) & 65536)) includes |= 4194304;
            } else {
                const len = typeSet.length;
                const index = len && type.id > typeSet[len - 1].id ? ~len : binarySearch(typeSet, type, getTypeId, compareValues);
                if (index < 0) {
                    typeSet.splice(~index, 0, type);
                }
            }
        }
        return includes;
    }
    function addTypesToUnion(typeSet, includes, types) {
        for (const type of types) {
            includes = addTypeToUnion(typeSet, includes, type);
        }
        return includes;
    }
    function removeSubtypes(types, hasObjectTypes) {
        var _a2;
        if (types.length < 2) {
            return types;
        }
        const id = getTypeListId(types);
        const match = subtypeReductionCache.get(id);
        if (match) {
            return match;
        }
        const hasEmptyObject = hasObjectTypes && some(types, t => !!(t.flags & 524288) && !isGenericMappedType(t) && isEmptyResolvedType(resolveStructuredTypeMembers(t)));
        const len = types.length;
        let i = len;
        let count = 0;
        while (i > 0) {
            i--;
            const source = types[i];
            if (hasEmptyObject || source.flags & 469499904) {
                const keyProperty = source.flags & (524288 | 2097152 | 58982400) ? find(getPropertiesOfType(source), p => isUnitType(getTypeOfSymbol(p))) : void 0;
                const keyPropertyType = keyProperty && getRegularTypeOfLiteralType(getTypeOfSymbol(keyProperty));
                for (const target of types) {
                    if (source !== target) {
                        if (count === 1e5) {
                            const estimatedCount = count / (len - i) * len;
                            if (estimatedCount > 1e6) {
                                (_a2 = tracing) == null ? void 0 : _a2.instant(tracing.Phase.CheckTypes, "removeSubtypes_DepthLimit", {
                                    typeIds: types.map(t => t.id)
                                });
                                error(currentNode, Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent);
                                return void 0;
                            }
                        }
                        count++;
                        if (keyProperty && target.flags & (524288 | 2097152 | 58982400)) {
                            const t = getTypeOfPropertyOfType(target, keyProperty.escapedName);
                            if (t && isUnitType(t) && getRegularTypeOfLiteralType(t) !== keyPropertyType) {
                                continue;
                            }
                        }
                        if (isTypeRelatedTo(source, target, strictSubtypeRelation) && (!(getObjectFlags(getTargetType(source)) & 1) || !(getObjectFlags(getTargetType(target)) & 1) || isTypeDerivedFrom(source, target))) {
                            orderedRemoveItemAt(types, i);
                            break;
                        }
                    }
                }
            }
        }
        subtypeReductionCache.set(id, types);
        return types;
    }
    function removeRedundantLiteralTypes(types, includes, reduceVoidUndefined) {
        let i = types.length;
        while (i > 0) {
            i--;
            const t = types[i];
            const flags = t.flags;
            const remove = flags & (128 | 134217728 | 268435456) && includes & 4 || flags & 256 && includes & 8 || flags & 2048 && includes & 64 || flags & 8192 && includes & 4096 || reduceVoidUndefined && flags & 32768 && includes & 16384 || isFreshLiteralType(t) && containsType(types, t.regularType);
            if (remove) {
                orderedRemoveItemAt(types, i);
            }
        }
    }
    function removeStringLiteralsMatchedByTemplateLiterals(types) {
        const templates = filter(types, t => !!(t.flags & 134217728) && isPatternLiteralType(t));
        if (templates.length) {
            let i = types.length;
            while (i > 0) {
                i--;
                const t = types[i];
                if (t.flags & 128 && some(templates, template => isTypeMatchedByTemplateLiteralType(t, template))) {
                    orderedRemoveItemAt(types, i);
                }
            }
        }
    }
    function isNamedUnionType(type) {
        return !!(type.flags & 1048576 && (type.aliasSymbol || type.origin));
    }
    function addNamedUnions(namedUnions, types) {
        for (const t of types) {
            if (t.flags & 1048576) {
                const origin = t.origin;
                if (t.aliasSymbol || origin && !(origin.flags & 1048576)) {
                    pushIfUnique(namedUnions, t);
                } else if (origin && origin.flags & 1048576) {
                    addNamedUnions(namedUnions, origin.types);
                }
            }
        }
    }
    function createOriginUnionOrIntersectionType(flags, types) {
        const result = createOriginType(flags);
        result.types = types;
        return result;
    }
    function getUnionType(types, unionReduction = 1, aliasSymbol, aliasTypeArguments, origin) {
        if (types.length === 0) {
            return neverType;
        }
        if (types.length === 1) {
            return types[0];
        }
        let typeSet = [];
        const includes = addTypesToUnion(typeSet, 0, types);
        if (unionReduction !== 0) {
            if (includes & 3) {
                return includes & 1 ? includes & 8388608 ? wildcardType : anyType : includes & 65536 || containsType(typeSet, unknownType) ? unknownType : nonNullUnknownType;
            }
            if (includes & 32768) {
                if (typeSet.length >= 2 && typeSet[0] === undefinedType && typeSet[1] === missingType) {
                    orderedRemoveItemAt(typeSet, 1);
                }
            }
            if (includes & (32 | 2944 | 8192 | 134217728 | 268435456) || includes & 16384 && includes & 32768) {
                removeRedundantLiteralTypes(typeSet, includes, !!(unionReduction & 2));
            }
            if (includes & 128 && includes & 134217728) {
                removeStringLiteralsMatchedByTemplateLiterals(typeSet);
            }
            if (unionReduction === 2) {
                typeSet = removeSubtypes(typeSet, !!(includes & 524288));
                if (!typeSet) {
                    return errorType;
                }
            }
            if (typeSet.length === 0) {
                return includes & 65536 ? includes & 4194304 ? nullType : nullWideningType : includes & 32768 ? includes & 4194304 ? undefinedType : undefinedWideningType : neverType;
            }
        }
        if (!origin && includes & 1048576) {
            const namedUnions = [];
            addNamedUnions(namedUnions, types);
            const reducedTypes = [];
            for (const t of typeSet) {
                if (!some(namedUnions, union => containsType(union.types, t))) {
                    reducedTypes.push(t);
                }
            }
            if (!aliasSymbol && namedUnions.length === 1 && reducedTypes.length === 0) {
                return namedUnions[0];
            }
            const namedTypesCount = reduceLeft(namedUnions, (sum, union) => sum + union.types.length, 0);
            if (namedTypesCount + reducedTypes.length === typeSet.length) {
                for (const t of namedUnions) {
                    insertType(reducedTypes, t);
                }
                origin = createOriginUnionOrIntersectionType(1048576, reducedTypes);
            }
        }
        const objectFlags = (includes & 36323363 ? 0 : 32768) | (includes & 2097152 ? 16777216 : 0);
        return getUnionTypeFromSortedList(typeSet, objectFlags, aliasSymbol, aliasTypeArguments, origin);
    }
    function getUnionOrIntersectionTypePredicate(signatures, kind) {
        let first2;
        const types = [];
        for (const sig of signatures) {
            const pred = getTypePredicateOfSignature(sig);
            if (!pred || pred.kind === 2 || pred.kind === 3) {
                if (kind !== 2097152) {
                    continue;
                } else {
                    return;
                }
            }
            if (first2) {
                if (!typePredicateKindsMatch(first2, pred)) {
                    return void 0;
                }
            } else {
                first2 = pred;
            }
            types.push(pred.type);
        }
        if (!first2) {
            return void 0;
        }
        const compositeType = getUnionOrIntersectionType(types, kind);
        return createTypePredicate(first2.kind, first2.parameterName, first2.parameterIndex, compositeType);
    }
    function typePredicateKindsMatch(a, b) {
        return a.kind === b.kind && a.parameterIndex === b.parameterIndex;
    }
    function getUnionTypeFromSortedList(types, precomputedObjectFlags, aliasSymbol, aliasTypeArguments, origin) {
        if (types.length === 0) {
            return neverType;
        }
        if (types.length === 1) {
            return types[0];
        }
        const typeKey = !origin ? getTypeListId(types) : origin.flags & 1048576 ? `|${getTypeListId(origin.types)}` : origin.flags & 2097152 ? `&${getTypeListId(origin.types)}` : `#${origin.type.id}|${getTypeListId(types)}`;
        const id = typeKey + getAliasId(aliasSymbol, aliasTypeArguments);
        let type = unionTypes.get(id);
        if (!type) {
            type = createType(1048576);
            type.objectFlags = precomputedObjectFlags | getPropagatingFlagsOfTypes(types, 98304);
            type.types = types;
            type.origin = origin;
            type.aliasSymbol = aliasSymbol;
            type.aliasTypeArguments = aliasTypeArguments;
            if (types.length === 2 && types[0].flags & 512 && types[1].flags & 512) {
                type.flags |= 16;
                type.intrinsicName = "boolean";
            }
            unionTypes.set(id, type);
        }
        return type;
    }
    function getTypeFromUnionTypeNode(node) {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const aliasSymbol = getAliasSymbolForTypeNode(node);
            links.resolvedType = getUnionType(map(node.types, getTypeFromTypeNode), 1, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol));
        }
        return links.resolvedType;
    }
    function addTypeToIntersection(typeSet, includes, type) {
        const flags = type.flags;
        if (flags & 2097152) {
            return addTypesToIntersection(typeSet, includes, type.types);
        }
        if (isEmptyAnonymousObjectType(type)) {
            if (!(includes & 16777216)) {
                includes |= 16777216;
                typeSet.set(type.id.toString(), type);
            }
        } else {
            if (flags & 3) {
                if (type === wildcardType) includes |= 8388608;
            } else if (strictNullChecks || !(flags & 98304)) {
                if (type === missingType) {
                    includes |= 262144;
                    type = undefinedType;
                }
                if (!typeSet.has(type.id.toString())) {
                    if (type.flags & 109472 && includes & 109472) {
                        includes |= 67108864;
                    }
                    typeSet.set(type.id.toString(), type);
                }
            }
            includes |= flags & 205258751;
        }
        return includes;
    }
    function addTypesToIntersection(typeSet, includes, types) {
        for (const type of types) {
            includes = addTypeToIntersection(typeSet, includes, getRegularTypeOfLiteralType(type));
        }
        return includes;
    }
    function removeRedundantSupertypes(types, includes) {
        let i = types.length;
        while (i > 0) {
            i--;
            const t = types[i];
            const remove = t.flags & 4 && includes & (128 | 134217728 | 268435456) || t.flags & 8 && includes & 256 || t.flags & 64 && includes & 2048 || t.flags & 4096 && includes & 8192 || t.flags & 16384 && includes & 32768 || isEmptyAnonymousObjectType(t) && includes & 470302716;
            if (remove) {
                orderedRemoveItemAt(types, i);
            }
        }
    }
    function eachUnionContains(unionTypes2, type) {
        for (const u of unionTypes2) {
            if (!containsType(u.types, type)) {
                const primitive = type.flags & 128 ? stringType : type.flags & 256 ? numberType : type.flags & 2048 ? bigintType : type.flags & 8192 ? esSymbolType : void 0;
                if (!primitive || !containsType(u.types, primitive)) {
                    return false;
                }
            }
        }
        return true;
    }
    function extractRedundantTemplateLiterals(types) {
        let i = types.length;
        const literals = filter(types, t => !!(t.flags & 128));
        while (i > 0) {
            i--;
            const t = types[i];
            if (!(t.flags & 134217728)) continue;
            for (const t2 of literals) {
                if (isTypeSubtypeOf(t2, t)) {
                    orderedRemoveItemAt(types, i);
                    break;
                } else if (isPatternLiteralType(t)) {
                    return true;
                }
            }
        }
        return false;
    }
    function eachIsUnionContaining(types, flag) {
        return every(types, t => !!(t.flags & 1048576) && some(t.types, tt => !!(tt.flags & flag)));
    }
    function removeFromEach(types, flag) {
        for (let i = 0; i < types.length; i++) {
            types[i] = filterType(types[i], t => !(t.flags & flag));
        }
    }
    function intersectUnionsOfPrimitiveTypes(types) {
        let unionTypes2;
        const index = findIndex(types, t => !!(getObjectFlags(t) & 32768));
        if (index < 0) {
            return false;
        }
        let i = index + 1;
        while (i < types.length) {
            const t = types[i];
            if (getObjectFlags(t) & 32768) {
                (unionTypes2 || (unionTypes2 = [types[index]])).push(t);
                orderedRemoveItemAt(types, i);
            } else {
                i++;
            }
        }
        if (!unionTypes2) {
            return false;
        }
        const checked = [];
        const result = [];
        for (const u of unionTypes2) {
            for (const t of u.types) {
                if (insertType(checked, t)) {
                    if (eachUnionContains(unionTypes2, t)) {
                        insertType(result, t);
                    }
                }
            }
        }
        types[index] = getUnionTypeFromSortedList(result, 32768);
        return true;
    }
    function createIntersectionType(types, aliasSymbol, aliasTypeArguments) {
        const result = createType(2097152);
        result.objectFlags = getPropagatingFlagsOfTypes(types, 98304);
        result.types = types;
        result.aliasSymbol = aliasSymbol;
        result.aliasTypeArguments = aliasTypeArguments;
        return result;
    }
    function getIntersectionType(types, aliasSymbol, aliasTypeArguments, noSupertypeReduction) {
        const typeMembershipMap = /* @__PURE__ */new Map();
        const includes = addTypesToIntersection(typeMembershipMap, 0, types);
        const typeSet = arrayFrom(typeMembershipMap.values());
        if (includes & 131072) {
            return contains(typeSet, silentNeverType) ? silentNeverType : neverType;
        }
        if (strictNullChecks && includes & 98304 && includes & (524288 | 67108864 | 16777216) || includes & 67108864 && includes & (469892092 & ~67108864) || includes & 402653316 && includes & (469892092 & ~402653316) || includes & 296 && includes & (469892092 & ~296) || includes & 2112 && includes & (469892092 & ~2112) || includes & 12288 && includes & (469892092 & ~12288) || includes & 49152 && includes & (469892092 & ~49152)) {
            return neverType;
        }
        if (includes & 134217728 && includes & 128 && extractRedundantTemplateLiterals(typeSet)) {
            return neverType;
        }
        if (includes & 1) {
            return includes & 8388608 ? wildcardType : anyType;
        }
        if (!strictNullChecks && includes & 98304) {
            return includes & 16777216 ? neverType : includes & 32768 ? undefinedType : nullType;
        }
        if (includes & 4 && includes & (128 | 134217728 | 268435456) || includes & 8 && includes & 256 || includes & 64 && includes & 2048 || includes & 4096 && includes & 8192 || includes & 16384 && includes & 32768 || includes & 16777216 && includes & 470302716) {
            if (!noSupertypeReduction) removeRedundantSupertypes(typeSet, includes);
        }
        if (includes & 262144) {
            typeSet[typeSet.indexOf(undefinedType)] = missingType;
        }
        if (typeSet.length === 0) {
            return unknownType;
        }
        if (typeSet.length === 1) {
            return typeSet[0];
        }
        const id = getTypeListId(typeSet) + getAliasId(aliasSymbol, aliasTypeArguments);
        let result = intersectionTypes.get(id);
        if (!result) {
            if (includes & 1048576) {
                if (intersectUnionsOfPrimitiveTypes(typeSet)) {
                    result = getIntersectionType(typeSet, aliasSymbol, aliasTypeArguments);
                } else if (eachIsUnionContaining(typeSet, 32768)) {
                    const containedUndefinedType = some(typeSet, containsMissingType) ? missingType : undefinedType;
                    removeFromEach(typeSet, 32768);
                    result = getUnionType([getIntersectionType(typeSet), containedUndefinedType], 1, aliasSymbol, aliasTypeArguments);
                } else if (eachIsUnionContaining(typeSet, 65536)) {
                    removeFromEach(typeSet, 65536);
                    result = getUnionType([getIntersectionType(typeSet), nullType], 1, aliasSymbol, aliasTypeArguments);
                } else {
                    if (!checkCrossProductUnion(typeSet)) {
                        return errorType;
                    }
                    const constituents = getCrossProductIntersections(typeSet);
                    const origin = some(constituents, t => !!(t.flags & 2097152)) && getConstituentCountOfTypes(constituents) > getConstituentCountOfTypes(typeSet) ? createOriginUnionOrIntersectionType(2097152, typeSet) : void 0;
                    result = getUnionType(constituents, 1, aliasSymbol, aliasTypeArguments, origin);
                }
            } else {
                result = createIntersectionType(typeSet, aliasSymbol, aliasTypeArguments);
            }
            intersectionTypes.set(id, result);
        }
        return result;
    }
    function getCrossProductUnionSize(types) {
        return reduceLeft(types, (n, t) => t.flags & 1048576 ? n * t.types.length : t.flags & 131072 ? 0 : n, 1);
    }
    function checkCrossProductUnion(types) {
        var _a2;
        const size = getCrossProductUnionSize(types);
        if (size >= 1e5) {
            (_a2 = tracing) == null ? void 0 : _a2.instant(tracing.Phase.CheckTypes, "checkCrossProductUnion_DepthLimit", {
                typeIds: types.map(t => t.id),
                size
            });
            error(currentNode, Diagnostics.Expression_produces_a_union_type_that_is_too_complex_to_represent);
            return false;
        }
        return true;
    }
    function getCrossProductIntersections(types) {
        const count = getCrossProductUnionSize(types);
        const intersections = [];
        for (let i = 0; i < count; i++) {
            const constituents = types.slice();
            let n = i;
            for (let j = types.length - 1; j >= 0; j--) {
                if (types[j].flags & 1048576) {
                    const sourceTypes = types[j].types;
                    const length2 = sourceTypes.length;
                    constituents[j] = sourceTypes[n % length2];
                    n = Math.floor(n / length2);
                }
            }
            const t = getIntersectionType(constituents);
            if (!(t.flags & 131072)) intersections.push(t);
        }
        return intersections;
    }
    function getConstituentCount(type) {
        return !(type.flags & 3145728) || type.aliasSymbol ? 1 : type.flags & 1048576 && type.origin ? getConstituentCount(type.origin) : getConstituentCountOfTypes(type.types);
    }
    function getConstituentCountOfTypes(types) {
        return reduceLeft(types, (n, t) => n + getConstituentCount(t), 0);
    }
    function getTypeFromIntersectionTypeNode(node) {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const aliasSymbol = getAliasSymbolForTypeNode(node);
            const types = map(node.types, getTypeFromTypeNode);
            const noSupertypeReduction = types.length === 2 && !!(types[0].flags & (4 | 8 | 64)) && types[1] === emptyTypeLiteralType;
            links.resolvedType = getIntersectionType(types, aliasSymbol, getTypeArgumentsForAliasSymbol(aliasSymbol), noSupertypeReduction);
        }
        return links.resolvedType;
    }
    function createIndexType(type, stringsOnly) {
        const result = createType(4194304);
        result.type = type;
        result.stringsOnly = stringsOnly;
        return result;
    }
    function createOriginIndexType(type) {
        const result = createOriginType(4194304);
        result.type = type;
        return result;
    }
    function getIndexTypeForGenericType(type, stringsOnly) {
        return stringsOnly ? type.resolvedStringIndexType || (type.resolvedStringIndexType = createIndexType(type, true)) : type.resolvedIndexType || (type.resolvedIndexType = createIndexType(type, false));
    }
    function getIndexTypeForMappedType(type, stringsOnly, noIndexSignatures) {
        const typeParameter = getTypeParameterFromMappedType(type);
        const constraintType = getConstraintTypeFromMappedType(type);
        const nameType = getNameTypeFromMappedType(type.target || type);
        if (!nameType && !noIndexSignatures) {
            return constraintType;
        }
        const keyTypes = [];
        if (isMappedTypeWithKeyofConstraintDeclaration(type)) {
            if (!isGenericIndexType(constraintType)) {
                const modifiersType = getApparentType(getModifiersTypeFromMappedType(type));
                forEachMappedTypePropertyKeyTypeAndIndexSignatureKeyType(modifiersType, 8576, stringsOnly, addMemberForKeyType);
            } else {
                return getIndexTypeForGenericType(type, stringsOnly);
            }
        } else {
            forEachType(getLowerBoundOfKeyType(constraintType), addMemberForKeyType);
        }
        if (isGenericIndexType(constraintType)) {
            forEachType(constraintType, addMemberForKeyType);
        }
        const result = noIndexSignatures ? filterType(getUnionType(keyTypes), t => !(t.flags & (1 | 4))) : getUnionType(keyTypes);
        if (result.flags & 1048576 && constraintType.flags & 1048576 && getTypeListId(result.types) === getTypeListId(constraintType.types)) {
            return constraintType;
        }
        return result;
        function addMemberForKeyType(keyType) {
            const propNameType = nameType ? instantiateType(nameType, appendTypeMapping(type.mapper, typeParameter, keyType)) : keyType;
            keyTypes.push(propNameType === stringType ? stringOrNumberType : propNameType);
        }
    }
    function hasDistributiveNameType(mappedType) {
        const typeVariable = getTypeParameterFromMappedType(mappedType);
        return isDistributive(getNameTypeFromMappedType(mappedType) || typeVariable);
        function isDistributive(type) {
            return type.flags & (3 | 134348796 | 131072 | 262144 | 524288 | 67108864) ? true : type.flags & 16777216 ? type.root.isDistributive && type.checkType === typeVariable : type.flags & (3145728 | 134217728) ? every(type.types, isDistributive) : type.flags & 8388608 ? isDistributive(type.objectType) && isDistributive(type.indexType) : type.flags & 33554432 ? isDistributive(type.baseType) && isDistributive(type.constraint) : type.flags & 268435456 ? isDistributive(type.type) : false;
        }
    }
    function getLiteralTypeFromPropertyName(name) {
        if (isPrivateIdentifier(name)) {
            return neverType;
        }
        return isIdentifier(name) ? getStringLiteralType(unescapeLeadingUnderscores(name.escapedText)) : getRegularTypeOfLiteralType(isComputedPropertyName(name) ? checkComputedPropertyName(name) : checkExpression(name));
    }
    function getLiteralTypeFromProperty(prop, include, includeNonPublic) {
        if (includeNonPublic || !(getDeclarationModifierFlagsFromSymbol(prop) & 24)) {
            let type = getSymbolLinks(getLateBoundSymbol(prop)).nameType;
            if (!type) {
                const name = getNameOfDeclaration(prop.valueDeclaration);
                type = prop.escapedName === "default" ? getStringLiteralType("default") : name && getLiteralTypeFromPropertyName(name) || (!isKnownSymbol(prop) ? getStringLiteralType(symbolName(prop)) : void 0);
            }
            if (type && type.flags & include) {
                return type;
            }
        }
        return neverType;
    }
    function isKeyTypeIncluded(keyType, include) {
        return !!(keyType.flags & include || keyType.flags & 2097152 && some(keyType.types, t => isKeyTypeIncluded(t, include)));
    }
    function getLiteralTypeFromProperties(type, include, includeOrigin) {
        const origin = includeOrigin && (getObjectFlags(type) & (3 | 4) || type.aliasSymbol) ? createOriginIndexType(type) : void 0;
        const propertyTypes = map(getPropertiesOfType(type), prop => getLiteralTypeFromProperty(prop, include));
        const indexKeyTypes = map(getIndexInfosOfType(type), info => info !== enumNumberIndexInfo && isKeyTypeIncluded(info.keyType, include) ? info.keyType === stringType && include & 8 ? stringOrNumberType : info.keyType : neverType);
        return getUnionType(concatenate(propertyTypes, indexKeyTypes), 1, void 0, void 0, origin);
    }
    function isPossiblyReducibleByInstantiation(type) {
        const uniqueFilled = getUniqueLiteralFilledInstantiation(type);
        return getReducedType(uniqueFilled) !== uniqueFilled;
    }
    function shouldDeferIndexType(type) {
        return !!(type.flags & 58982400 || isGenericTupleType(type) || isGenericMappedType(type) && !hasDistributiveNameType(type) || type.flags & 1048576 && some(type.types, isPossiblyReducibleByInstantiation) || type.flags & 2097152 && maybeTypeOfKind(type, 465829888) && some(type.types, isEmptyAnonymousObjectType));
    }
    function getIndexType(type, stringsOnly = keyofStringsOnly, noIndexSignatures) {
        type = getReducedType(type);
        return shouldDeferIndexType(type) ? getIndexTypeForGenericType(type, stringsOnly) : type.flags & 1048576 ? getIntersectionType(map(type.types, t => getIndexType(t, stringsOnly, noIndexSignatures))) : type.flags & 2097152 ? getUnionType(map(type.types, t => getIndexType(t, stringsOnly, noIndexSignatures))) : getObjectFlags(type) & 32 ? getIndexTypeForMappedType(type, stringsOnly, noIndexSignatures) : type === wildcardType ? wildcardType : type.flags & 2 ? neverType : type.flags & (1 | 131072) ? keyofConstraintType : getLiteralTypeFromProperties(type, (noIndexSignatures ? 128 : 402653316) | (stringsOnly ? 0 : 296 | 12288), stringsOnly === keyofStringsOnly && !noIndexSignatures);
    }
    function getExtractStringType(type) {
        if (keyofStringsOnly) {
            return type;
        }
        const extractTypeAlias = getGlobalExtractSymbol();
        return extractTypeAlias ? getTypeAliasInstantiation(extractTypeAlias, [type, stringType]) : stringType;
    }
    function getIndexTypeOrString(type) {
        const indexType = getExtractStringType(getIndexType(type));
        return indexType.flags & 131072 ? stringType : indexType;
    }
    function getTypeFromTypeOperatorNode(node) {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            switch (node.operator) {
                case 141:
                    links.resolvedType = getIndexType(getTypeFromTypeNode(node.type));
                    break;
                case 156:
                    links.resolvedType = node.type.kind === 153 ? getESSymbolLikeTypeForNode(walkUpParenthesizedTypes(node.parent)) : errorType;
                    break;
                case 146:
                    links.resolvedType = getTypeFromTypeNode(node.type);
                    break;
                default:
                    throw Debug.assertNever(node.operator);
            }
        }
        return links.resolvedType;
    }
    function getTypeFromTemplateTypeNode(node) {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            links.resolvedType = getTemplateLiteralType([node.head.text, ...map(node.templateSpans, span => span.literal.text)], map(node.templateSpans, span => getTypeFromTypeNode(span.type)));
        }
        return links.resolvedType;
    }
    function getTemplateLiteralType(texts, types) {
        const unionIndex = findIndex(types, t => !!(t.flags & (131072 | 1048576)));
        if (unionIndex >= 0) {
            return checkCrossProductUnion(types) ? mapType(types[unionIndex], t => getTemplateLiteralType(texts, replaceElement(types, unionIndex, t))) : errorType;
        }
        if (contains(types, wildcardType)) {
            return wildcardType;
        }
        const newTypes = [];
        const newTexts = [];
        let text = texts[0];
        if (!addSpans(texts, types)) {
            return stringType;
        }
        if (newTypes.length === 0) {
            return getStringLiteralType(text);
        }
        newTexts.push(text);
        if (every(newTexts, t => t === "")) {
            if (every(newTypes, t => !!(t.flags & 4))) {
                return stringType;
            }
            if (newTypes.length === 1 && isPatternLiteralType(newTypes[0])) {
                return newTypes[0];
            }
        }
        const id = `${getTypeListId(newTypes)}|${map(newTexts, t => t.length).join(",")}|${newTexts.join("")}`;
        let type = templateLiteralTypes.get(id);
        if (!type) {
            templateLiteralTypes.set(id, type = createTemplateLiteralType(newTexts, newTypes));
        }
        return type;
        function addSpans(texts2, types2) {
            const isTextsArray = isArray(texts2);
            for (let i = 0; i < types2.length; i++) {
                const t = types2[i];
                const addText = isTextsArray ? texts2[i + 1] : texts2;
                if (t.flags & (2944 | 65536 | 32768)) {
                    text += getTemplateStringForType(t) || "";
                    text += addText;
                    if (!isTextsArray) return true;
                } else if (t.flags & 134217728) {
                    text += t.texts[0];
                    if (!addSpans(t.texts, t.types)) return false;
                    text += addText;
                    if (!isTextsArray) return true;
                } else if (isGenericIndexType(t) || isPatternLiteralPlaceholderType(t)) {
                    newTypes.push(t);
                    newTexts.push(text);
                    text = addText;
                } else if (t.flags & 2097152) {
                    const added = addSpans(texts2[i + 1], t.types);
                    if (!added) return false;
                } else if (isTextsArray) {
                    return false;
                }
            }
            return true;
        }
    }
    function getTemplateStringForType(type) {
        return type.flags & 128 ? type.value : type.flags & 256 ? "" + type.value : type.flags & 2048 ? pseudoBigIntToString(type.value) : type.flags & (512 | 98304) ? type.intrinsicName : void 0;
    }
    function createTemplateLiteralType(texts, types) {
        const type = createType(134217728);
        type.texts = texts;
        type.types = types;
        return type;
    }
    function getStringMappingType(symbol, type) {
        return type.flags & (1048576 | 131072) ? mapType(type, t => getStringMappingType(symbol, t)) : type.flags & 128 ? getStringLiteralType(applyStringMapping(symbol, type.value)) : type.flags & 134217728 ? getTemplateLiteralType(...applyTemplateStringMapping(symbol, type.texts, type.types)) : type.flags & 268435456 && symbol === type.symbol ? type : type.flags & (1 | 4 | 268435456) || isGenericIndexType(type) ? getStringMappingTypeForGenericType(symbol, type) : isPatternLiteralPlaceholderType(type) ? getStringMappingTypeForGenericType(symbol, getTemplateLiteralType(["", ""], [type])) : type;
    }
    function applyStringMapping(symbol, str) {
        switch (intrinsicTypeKinds.get(symbol.escapedName)) {
            case 0:
                return str.toUpperCase();
            case 1:
                return str.toLowerCase();
            case 2:
                return str.charAt(0).toUpperCase() + str.slice(1);
            case 3:
                return str.charAt(0).toLowerCase() + str.slice(1);
        }
        return str;
    }
    function applyTemplateStringMapping(symbol, texts, types) {
        switch (intrinsicTypeKinds.get(symbol.escapedName)) {
            case 0:
                return [texts.map(t => t.toUpperCase()), types.map(t => getStringMappingType(symbol, t))];
            case 1:
                return [texts.map(t => t.toLowerCase()), types.map(t => getStringMappingType(symbol, t))];
            case 2:
                return [texts[0] === "" ? texts : [texts[0].charAt(0).toUpperCase() + texts[0].slice(1), ...texts.slice(1)], texts[0] === "" ? [getStringMappingType(symbol, types[0]), ...types.slice(1)] : types];
            case 3:
                return [texts[0] === "" ? texts : [texts[0].charAt(0).toLowerCase() + texts[0].slice(1), ...texts.slice(1)], texts[0] === "" ? [getStringMappingType(symbol, types[0]), ...types.slice(1)] : types];
        }
        return [texts, types];
    }
    function getStringMappingTypeForGenericType(symbol, type) {
        const id = `${getSymbolId(symbol)},${getTypeId(type)}`;
        let result = stringMappingTypes.get(id);
        if (!result) {
            stringMappingTypes.set(id, result = createStringMappingType(symbol, type));
        }
        return result;
    }
    function createStringMappingType(symbol, type) {
        const result = createTypeWithSymbol(268435456, symbol);
        result.type = type;
        return result;
    }
    function createIndexedAccessType(objectType, indexType, accessFlags, aliasSymbol, aliasTypeArguments) {
        const type = createType(8388608);
        type.objectType = objectType;
        type.indexType = indexType;
        type.accessFlags = accessFlags;
        type.aliasSymbol = aliasSymbol;
        type.aliasTypeArguments = aliasTypeArguments;
        return type;
    }
    function isJSLiteralType(type) {
        if (noImplicitAny) {
            return false;
        }
        if (getObjectFlags(type) & 4096) {
            return true;
        }
        if (type.flags & 1048576) {
            return every(type.types, isJSLiteralType);
        }
        if (type.flags & 2097152) {
            return some(type.types, isJSLiteralType);
        }
        if (type.flags & 465829888) {
            const constraint = getResolvedBaseConstraint(type);
            return constraint !== type && isJSLiteralType(constraint);
        }
        return false;
    }
    function getPropertyNameFromIndex(indexType, accessNode) {
        return isTypeUsableAsPropertyName(indexType) ? getPropertyNameFromType(indexType) : accessNode && isPropertyName(accessNode) ? getPropertyNameForPropertyNameNode(accessNode) : void 0;
    }
    function isUncalledFunctionReference(node, symbol) {
        if (symbol.flags & (16 | 8192)) {
            const parent2 = findAncestor(node.parent, n => !isAccessExpression(n)) || node.parent;
            if (isCallLikeExpression(parent2)) {
                return isCallOrNewExpression(parent2) && isIdentifier(node) && hasMatchingArgument(parent2, node);
            }
            return every(symbol.declarations, d => !isFunctionLike(d) || !!(getCombinedNodeFlags(d) & 268435456));
        }
        return true;
    }
    function getPropertyTypeForIndexType(originalObjectType, objectType, indexType, fullIndexType, accessNode, accessFlags) {
        var _a2;
        const accessExpression = accessNode && accessNode.kind === 209 ? accessNode : void 0;
        const propName = accessNode && isPrivateIdentifier(accessNode) ? void 0 : getPropertyNameFromIndex(indexType, accessNode);
        if (propName !== void 0) {
            if (accessFlags & 256) {
                return getTypeOfPropertyOfContextualType(objectType, propName) || anyType;
            }
            const prop = getPropertyOfType(objectType, propName);
            if (prop) {
                if (accessFlags & 64 && accessNode && prop.declarations && isDeprecatedSymbol(prop) && isUncalledFunctionReference(accessNode, prop)) {
                    const deprecatedNode = (_a2 = accessExpression == null ? void 0 : accessExpression.argumentExpression) != null ? _a2 : isIndexedAccessTypeNode(accessNode) ? accessNode.indexType : accessNode;
                    addDeprecatedSuggestion(deprecatedNode, prop.declarations, propName);
                }
                if (accessExpression) {
                    markPropertyAsReferenced(prop, accessExpression, isSelfTypeAccess(accessExpression.expression, objectType.symbol));
                    if (isAssignmentToReadonlyEntity(accessExpression, prop, getAssignmentTargetKind(accessExpression))) {
                        error(accessExpression.argumentExpression, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(prop));
                        return void 0;
                    }
                    if (accessFlags & 8) {
                        getNodeLinks(accessNode).resolvedSymbol = prop;
                    }
                    if (isThisPropertyAccessInConstructor(accessExpression, prop)) {
                        return autoType;
                    }
                }
                const propType = getTypeOfSymbol(prop);
                return accessExpression && getAssignmentTargetKind(accessExpression) !== 1 ? getFlowTypeOfReference(accessExpression, propType) : accessNode && isIndexedAccessTypeNode(accessNode) && containsMissingType(propType) ? getUnionType([propType, undefinedType]) : propType;
            }
            if (everyType(objectType, isTupleType) && isNumericLiteralName(propName)) {
                const index = +propName;
                if (accessNode && everyType(objectType, t => !t.target.hasRestElement) && !(accessFlags & 16)) {
                    const indexNode = getIndexNodeForAccessExpression(accessNode);
                    if (isTupleType(objectType)) {
                        if (index < 0) {
                            error(indexNode, Diagnostics.A_tuple_type_cannot_be_indexed_with_a_negative_value);
                            return undefinedType;
                        }
                        error(indexNode, Diagnostics.Tuple_type_0_of_length_1_has_no_element_at_index_2, typeToString(objectType), getTypeReferenceArity(objectType), unescapeLeadingUnderscores(propName));
                    } else {
                        error(indexNode, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(propName), typeToString(objectType));
                    }
                }
                if (index >= 0) {
                    errorIfWritingToReadonlyIndex(getIndexInfoOfType(objectType, numberType));
                    return mapType(objectType, t => {
                        const restType = getRestTypeOfTupleType(t) || undefinedType;
                        return accessFlags & 1 ? getUnionType([restType, missingType]) : restType;
                    });
                }
            }
        }
        if (!(indexType.flags & 98304) && isTypeAssignableToKind(indexType, 402653316 | 296 | 12288)) {
            if (objectType.flags & (1 | 131072)) {
                return objectType;
            }
            const indexInfo = getApplicableIndexInfo(objectType, indexType) || getIndexInfoOfType(objectType, stringType);
            if (indexInfo) {
                if (accessFlags & 2 && indexInfo.keyType !== numberType) {
                    if (accessExpression) {
                        error(accessExpression, Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(originalObjectType));
                    }
                    return void 0;
                }
                if (accessNode && indexInfo.keyType === stringType && !isTypeAssignableToKind(indexType, 4 | 8)) {
                    const indexNode = getIndexNodeForAccessExpression(accessNode);
                    error(indexNode, Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType));
                    return accessFlags & 1 ? getUnionType([indexInfo.type, missingType]) : indexInfo.type;
                }
                errorIfWritingToReadonlyIndex(indexInfo);
                if (accessFlags & 1 && !(objectType.symbol && objectType.symbol.flags & (256 | 128) && indexType.symbol && indexType.flags & 1024 && getParentOfSymbol(indexType.symbol) === objectType.symbol)) {
                    return getUnionType([indexInfo.type, missingType]);
                }
                return indexInfo.type;
            }
            if (indexType.flags & 131072) {
                return neverType;
            }
            if (isJSLiteralType(objectType)) {
                return anyType;
            }
            if (accessExpression && !isConstEnumObjectType(objectType)) {
                if (isObjectLiteralType2(objectType)) {
                    if (noImplicitAny && indexType.flags & (128 | 256)) {
                        diagnostics.add(createDiagnosticForNode(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1, indexType.value, typeToString(objectType)));
                        return undefinedType;
                    } else if (indexType.flags & (8 | 4)) {
                        const types = map(objectType.properties, property => {
                            return getTypeOfSymbol(property);
                        });
                        return getUnionType(append(types, undefinedType));
                    }
                }
                if (objectType.symbol === globalThisSymbol && propName !== void 0 && globalThisSymbol.exports.has(propName) && globalThisSymbol.exports.get(propName).flags & 418) {
                    error(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(propName), typeToString(objectType));
                } else if (noImplicitAny && !compilerOptions.suppressImplicitAnyIndexErrors && !(accessFlags & 128)) {
                    if (propName !== void 0 && typeHasStaticProperty(propName, objectType)) {
                        const typeName = typeToString(objectType);
                        error(accessExpression, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName, typeName, typeName + "[" + getTextOfNode(accessExpression.argumentExpression) + "]");
                    } else if (getIndexTypeOfType(objectType, numberType)) {
                        error(accessExpression.argumentExpression, Diagnostics.Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number);
                    } else {
                        let suggestion;
                        if (propName !== void 0 && (suggestion = getSuggestionForNonexistentProperty(propName, objectType))) {
                            if (suggestion !== void 0) {
                                error(accessExpression.argumentExpression, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2, propName, typeToString(objectType), suggestion);
                            }
                        } else {
                            const suggestion2 = getSuggestionForNonexistentIndexSignature(objectType, accessExpression, indexType);
                            if (suggestion2 !== void 0) {
                                error(accessExpression, Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1, typeToString(objectType), suggestion2);
                            } else {
                                let errorInfo;
                                if (indexType.flags & 1024) {
                                    errorInfo = chainDiagnosticMessages(void 0, Diagnostics.Property_0_does_not_exist_on_type_1, "[" + typeToString(indexType) + "]", typeToString(objectType));
                                } else if (indexType.flags & 8192) {
                                    const symbolName2 = getFullyQualifiedName(indexType.symbol, accessExpression);
                                    errorInfo = chainDiagnosticMessages(void 0, Diagnostics.Property_0_does_not_exist_on_type_1, "[" + symbolName2 + "]", typeToString(objectType));
                                } else if (indexType.flags & 128) {
                                    errorInfo = chainDiagnosticMessages(void 0, Diagnostics.Property_0_does_not_exist_on_type_1, indexType.value, typeToString(objectType));
                                } else if (indexType.flags & 256) {
                                    errorInfo = chainDiagnosticMessages(void 0, Diagnostics.Property_0_does_not_exist_on_type_1, indexType.value, typeToString(objectType));
                                } else if (indexType.flags & (8 | 4)) {
                                    errorInfo = chainDiagnosticMessages(void 0, Diagnostics.No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1, typeToString(indexType), typeToString(objectType));
                                }
                                errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1, typeToString(fullIndexType), typeToString(objectType));
                                diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(accessExpression), accessExpression, errorInfo));
                            }
                        }
                    }
                }
                return void 0;
            }
        }
        if (isJSLiteralType(objectType)) {
            return anyType;
        }
        if (accessNode) {
            const indexNode = getIndexNodeForAccessExpression(accessNode);
            if (indexType.flags & (128 | 256)) {
                error(indexNode, Diagnostics.Property_0_does_not_exist_on_type_1, "" + indexType.value, typeToString(objectType));
            } else if (indexType.flags & (4 | 8)) {
                error(indexNode, Diagnostics.Type_0_has_no_matching_index_signature_for_type_1, typeToString(objectType), typeToString(indexType));
            } else {
                error(indexNode, Diagnostics.Type_0_cannot_be_used_as_an_index_type, typeToString(indexType));
            }
        }
        if (isTypeAny(indexType)) {
            return indexType;
        }
        return void 0;
        function errorIfWritingToReadonlyIndex(indexInfo) {
            if (indexInfo && indexInfo.isReadonly && accessExpression && (isAssignmentTarget(accessExpression) || isDeleteTarget(accessExpression))) {
                error(accessExpression, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType));
            }
        }
    }
    function getIndexNodeForAccessExpression(accessNode) {
        return accessNode.kind === 209 ? accessNode.argumentExpression : accessNode.kind === 196 ? accessNode.indexType : accessNode.kind === 164 ? accessNode.expression : accessNode;
    }
    function isPatternLiteralPlaceholderType(type) {
        return !!(type.flags & (1 | 4 | 8 | 64)) || isPatternLiteralType(type);
    }
    function isPatternLiteralType(type) {
        return !!(type.flags & 134217728) && every(type.types, isPatternLiteralPlaceholderType) || !!(type.flags & 268435456) && isPatternLiteralPlaceholderType(type.type);
    }
    function isGenericType(type) {
        return !!getGenericObjectFlags(type);
    }
    function isGenericObjectType(type) {
        return !!(getGenericObjectFlags(type) & 4194304);
    }
    function isGenericIndexType(type) {
        return !!(getGenericObjectFlags(type) & 8388608);
    }
    function getGenericObjectFlags(type) {
        if (type.flags & 3145728) {
            if (!(type.objectFlags & 2097152)) {
                type.objectFlags |= 2097152 | reduceLeft(type.types, (flags, t) => flags | getGenericObjectFlags(t), 0);
            }
            return type.objectFlags & 12582912;
        }
        if (type.flags & 33554432) {
            if (!(type.objectFlags & 2097152)) {
                type.objectFlags |= 2097152 | getGenericObjectFlags(type.baseType) | getGenericObjectFlags(type.constraint);
            }
            return type.objectFlags & 12582912;
        }
        return (type.flags & 58982400 || isGenericMappedType(type) || isGenericTupleType(type) ? 4194304 : 0) | (type.flags & (58982400 | 4194304 | 134217728 | 268435456) && !isPatternLiteralType(type) ? 8388608 : 0);
    }
    function getSimplifiedType(type, writing) {
        return type.flags & 8388608 ? getSimplifiedIndexedAccessType(type, writing) : type.flags & 16777216 ? getSimplifiedConditionalType(type, writing) : type;
    }
    function distributeIndexOverObjectType(objectType, indexType, writing) {
        if (objectType.flags & 1048576 || objectType.flags & 2097152 && !shouldDeferIndexType(objectType)) {
            const types = map(objectType.types, t => getSimplifiedType(getIndexedAccessType(t, indexType), writing));
            return objectType.flags & 2097152 || writing ? getIntersectionType(types) : getUnionType(types);
        }
    }
    function distributeObjectOverIndexType(objectType, indexType, writing) {
        if (indexType.flags & 1048576) {
            const types = map(indexType.types, t => getSimplifiedType(getIndexedAccessType(objectType, t), writing));
            return writing ? getIntersectionType(types) : getUnionType(types);
        }
    }
    function getSimplifiedIndexedAccessType(type, writing) {
        const cache = writing ? "simplifiedForWriting" : "simplifiedForReading";
        if (type[cache]) {
            return type[cache] === circularConstraintType ? type : type[cache];
        }
        type[cache] = circularConstraintType;
        const objectType = getSimplifiedType(type.objectType, writing);
        const indexType = getSimplifiedType(type.indexType, writing);
        const distributedOverIndex = distributeObjectOverIndexType(objectType, indexType, writing);
        if (distributedOverIndex) {
            return type[cache] = distributedOverIndex;
        }
        if (!(indexType.flags & 465829888)) {
            const distributedOverObject = distributeIndexOverObjectType(objectType, indexType, writing);
            if (distributedOverObject) {
                return type[cache] = distributedOverObject;
            }
        }
        if (isGenericTupleType(objectType) && indexType.flags & 296) {
            const elementType = getElementTypeOfSliceOfTupleType(objectType, indexType.flags & 8 ? 0 : objectType.target.fixedLength, 0, writing);
            if (elementType) {
                return type[cache] = elementType;
            }
        }
        if (isGenericMappedType(objectType)) {
            const nameType = getNameTypeFromMappedType(objectType);
            if (!nameType || isTypeAssignableTo(nameType, getTypeParameterFromMappedType(objectType))) {
                return type[cache] = mapType(substituteIndexedMappedType(objectType, type.indexType), t => getSimplifiedType(t, writing));
            }
        }
        return type[cache] = type;
    }
    function getSimplifiedConditionalType(type, writing) {
        const checkType = type.checkType;
        const extendsType = type.extendsType;
        const trueType2 = getTrueTypeFromConditionalType(type);
        const falseType2 = getFalseTypeFromConditionalType(type);
        if (falseType2.flags & 131072 && getActualTypeVariable(trueType2) === getActualTypeVariable(checkType)) {
            if (checkType.flags & 1 || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType))) {
                return getSimplifiedType(trueType2, writing);
            } else if (isIntersectionEmpty(checkType, extendsType)) {
                return neverType;
            }
        } else if (trueType2.flags & 131072 && getActualTypeVariable(falseType2) === getActualTypeVariable(checkType)) {
            if (!(checkType.flags & 1) && isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(extendsType))) {
                return neverType;
            } else if (checkType.flags & 1 || isIntersectionEmpty(checkType, extendsType)) {
                return getSimplifiedType(falseType2, writing);
            }
        }
        return type;
    }
    function isIntersectionEmpty(type1, type2) {
        return !!(getUnionType([intersectTypes(type1, type2), neverType]).flags & 131072);
    }
    function substituteIndexedMappedType(objectType, index) {
        const mapper = createTypeMapper([getTypeParameterFromMappedType(objectType)], [index]);
        const templateMapper = combineTypeMappers(objectType.mapper, mapper);
        return instantiateType(getTemplateTypeFromMappedType(objectType.target || objectType), templateMapper);
    }
    function getIndexedAccessType(objectType, indexType, accessFlags = 0, accessNode, aliasSymbol, aliasTypeArguments) {
        return getIndexedAccessTypeOrUndefined(objectType, indexType, accessFlags, accessNode, aliasSymbol, aliasTypeArguments) || (accessNode ? errorType : unknownType);
    }
    function indexTypeLessThan(indexType, limit) {
        return everyType(indexType, t => {
            if (t.flags & 384) {
                const propName = getPropertyNameFromType(t);
                if (isNumericLiteralName(propName)) {
                    const index = +propName;
                    return index >= 0 && index < limit;
                }
            }
            return false;
        });
    }
    function getIndexedAccessTypeOrUndefined(objectType, indexType, accessFlags = 0, accessNode, aliasSymbol, aliasTypeArguments) {
        if (objectType === wildcardType || indexType === wildcardType) {
            return wildcardType;
        }
        if (isStringIndexSignatureOnlyType(objectType) && !(indexType.flags & 98304) && isTypeAssignableToKind(indexType, 4 | 8)) {
            indexType = stringType;
        }
        if (compilerOptions.noUncheckedIndexedAccess && accessFlags & 32) accessFlags |= 1;
        if (isGenericIndexType(indexType) || (accessNode && accessNode.kind !== 196 ? isGenericTupleType(objectType) && !indexTypeLessThan(indexType, objectType.target.fixedLength) : isGenericObjectType(objectType) && !(isTupleType(objectType) && indexTypeLessThan(indexType, objectType.target.fixedLength)))) {
            if (objectType.flags & 3) {
                return objectType;
            }
            const persistentAccessFlags = accessFlags & 1;
            const id = objectType.id + "," + indexType.id + "," + persistentAccessFlags + getAliasId(aliasSymbol, aliasTypeArguments);
            let type = indexedAccessTypes.get(id);
            if (!type) {
                indexedAccessTypes.set(id, type = createIndexedAccessType(objectType, indexType, persistentAccessFlags, aliasSymbol, aliasTypeArguments));
            }
            return type;
        }
        const apparentObjectType = getReducedApparentType(objectType);
        if (indexType.flags & 1048576 && !(indexType.flags & 16)) {
            const propTypes = [];
            let wasMissingProp = false;
            for (const t of indexType.types) {
                const propType = getPropertyTypeForIndexType(objectType, apparentObjectType, t, indexType, accessNode, accessFlags | (wasMissingProp ? 128 : 0));
                if (propType) {
                    propTypes.push(propType);
                } else if (!accessNode) {
                    return void 0;
                } else {
                    wasMissingProp = true;
                }
            }
            if (wasMissingProp) {
                return void 0;
            }
            return accessFlags & 4 ? getIntersectionType(propTypes, aliasSymbol, aliasTypeArguments) : getUnionType(propTypes, 1, aliasSymbol, aliasTypeArguments);
        }
        return getPropertyTypeForIndexType(objectType, apparentObjectType, indexType, indexType, accessNode, accessFlags | 8 | 64);
    }
    function getTypeFromIndexedAccessTypeNode(node) {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const objectType = getTypeFromTypeNode(node.objectType);
            const indexType = getTypeFromTypeNode(node.indexType);
            const potentialAlias = getAliasSymbolForTypeNode(node);
            links.resolvedType = getIndexedAccessType(objectType, indexType, 0, node, potentialAlias, getTypeArgumentsForAliasSymbol(potentialAlias));
        }
        return links.resolvedType;
    }
    function getTypeFromMappedTypeNode(node) {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const type = createObjectType(32, node.symbol);
            type.declaration = node;
            type.aliasSymbol = getAliasSymbolForTypeNode(node);
            type.aliasTypeArguments = getTypeArgumentsForAliasSymbol(type.aliasSymbol);
            links.resolvedType = type;
            getConstraintTypeFromMappedType(type);
        }
        return links.resolvedType;
    }
    function getActualTypeVariable(type) {
        if (type.flags & 33554432) {
            return getActualTypeVariable(type.baseType);
        }
        if (type.flags & 8388608 && (type.objectType.flags & 33554432 || type.indexType.flags & 33554432)) {
            return getIndexedAccessType(getActualTypeVariable(type.objectType), getActualTypeVariable(type.indexType));
        }
        return type;
    }
    function maybeCloneTypeParameter(p) {
        const constraint = getConstraintOfTypeParameter(p);
        return constraint && (isGenericObjectType(constraint) || isGenericIndexType(constraint)) ? cloneTypeParameter(p) : p;
    }
    function isSimpleTupleType(node) {
        return isTupleTypeNode(node) && length(node.elements) > 0 && !some(node.elements, e => isOptionalTypeNode(e) || isRestTypeNode(e) || isNamedTupleMember(e) && !!(e.questionToken || e.dotDotDotToken));
    }
    function isDeferredType(type, checkTuples) {
        return isGenericType(type) || checkTuples && isTupleType(type) && some(getTypeArguments(type), isGenericType);
    }
    function getConditionalType(root, mapper, aliasSymbol, aliasTypeArguments) {
        let result;
        let extraTypes;
        let tailCount = 0;
        while (true) {
            if (tailCount === 1e3) {
                error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite);
                result = errorType;
                break;
            }
            const checkTuples = isSimpleTupleType(root.node.checkType) && isSimpleTupleType(root.node.extendsType) && length(root.node.checkType.elements) === length(root.node.extendsType.elements);
            const checkType = instantiateType(getActualTypeVariable(root.checkType), mapper);
            const checkTypeDeferred = isDeferredType(checkType, checkTuples);
            const extendsType = instantiateType(root.extendsType, mapper);
            if (checkType === wildcardType || extendsType === wildcardType) {
                return wildcardType;
            }
            let combinedMapper;
            if (root.inferTypeParameters) {
                const freshParams = sameMap(root.inferTypeParameters, maybeCloneTypeParameter);
                const freshMapper = freshParams !== root.inferTypeParameters ? createTypeMapper(root.inferTypeParameters, freshParams) : void 0;
                const context = createInferenceContext(freshParams, void 0, 0);
                if (freshMapper) {
                    const freshCombinedMapper = combineTypeMappers(mapper, freshMapper);
                    for (const p of freshParams) {
                        if (root.inferTypeParameters.indexOf(p) === -1) {
                            p.mapper = freshCombinedMapper;
                        }
                    }
                }
                if (!checkTypeDeferred) {
                    inferTypes(context.inferences, checkType, instantiateType(extendsType, freshMapper), 512 | 1024);
                }
                const innerMapper = combineTypeMappers(freshMapper, context.mapper);
                combinedMapper = mapper ? combineTypeMappers(innerMapper, mapper) : innerMapper;
            }
            const inferredExtendsType = combinedMapper ? instantiateType(root.extendsType, combinedMapper) : extendsType;
            if (!checkTypeDeferred && !isDeferredType(inferredExtendsType, checkTuples)) {
                if (!(inferredExtendsType.flags & 3) && (checkType.flags & 1 || !isTypeAssignableTo(getPermissiveInstantiation(checkType), getPermissiveInstantiation(inferredExtendsType)))) {
                    if (checkType.flags & 1) {
                        (extraTypes || (extraTypes = [])).push(instantiateType(getTypeFromTypeNode(root.node.trueType), combinedMapper || mapper));
                    }
                    const falseType2 = getTypeFromTypeNode(root.node.falseType);
                    if (falseType2.flags & 16777216) {
                        const newRoot = falseType2.root;
                        if (newRoot.node.parent === root.node && (!newRoot.isDistributive || newRoot.checkType === root.checkType)) {
                            root = newRoot;
                            continue;
                        }
                        if (canTailRecurse(falseType2, mapper)) {
                            continue;
                        }
                    }
                    result = instantiateType(falseType2, mapper);
                    break;
                }
                if (inferredExtendsType.flags & 3 || isTypeAssignableTo(getRestrictiveInstantiation(checkType), getRestrictiveInstantiation(inferredExtendsType))) {
                    const trueType2 = getTypeFromTypeNode(root.node.trueType);
                    const trueMapper = combinedMapper || mapper;
                    if (canTailRecurse(trueType2, trueMapper)) {
                        continue;
                    }
                    result = instantiateType(trueType2, trueMapper);
                    break;
                }
            }
            result = createType(16777216);
            result.root = root;
            result.checkType = instantiateType(root.checkType, mapper);
            result.extendsType = instantiateType(root.extendsType, mapper);
            result.mapper = mapper;
            result.combinedMapper = combinedMapper;
            result.aliasSymbol = aliasSymbol || root.aliasSymbol;
            result.aliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(root.aliasTypeArguments, mapper);
            break;
        }
        return extraTypes ? getUnionType(append(extraTypes, result)) : result;
        function canTailRecurse(newType, newMapper) {
            if (newType.flags & 16777216 && newMapper) {
                const newRoot = newType.root;
                if (newRoot.outerTypeParameters) {
                    const typeParamMapper = combineTypeMappers(newType.mapper, newMapper);
                    const typeArguments = map(newRoot.outerTypeParameters, t => getMappedType(t, typeParamMapper));
                    const newRootMapper = createTypeMapper(newRoot.outerTypeParameters, typeArguments);
                    const newCheckType = newRoot.isDistributive ? getMappedType(newRoot.checkType, newRootMapper) : void 0;
                    if (!newCheckType || newCheckType === newRoot.checkType || !(newCheckType.flags & (1048576 | 131072))) {
                        root = newRoot;
                        mapper = newRootMapper;
                        aliasSymbol = void 0;
                        aliasTypeArguments = void 0;
                        if (newRoot.aliasSymbol) {
                            tailCount++;
                        }
                        return true;
                    }
                }
            }
            return false;
        }
    }
    function getTrueTypeFromConditionalType(type) {
        return type.resolvedTrueType || (type.resolvedTrueType = instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.mapper));
    }
    function getFalseTypeFromConditionalType(type) {
        return type.resolvedFalseType || (type.resolvedFalseType = instantiateType(getTypeFromTypeNode(type.root.node.falseType), type.mapper));
    }
    function getInferredTrueTypeFromConditionalType(type) {
        return type.resolvedInferredTrueType || (type.resolvedInferredTrueType = type.combinedMapper ? instantiateType(getTypeFromTypeNode(type.root.node.trueType), type.combinedMapper) : getTrueTypeFromConditionalType(type));
    }
    function getInferTypeParameters(node) {
        let result;
        if (node.locals) {
            node.locals.forEach(symbol => {
                if (symbol.flags & 262144) {
                    result = append(result, getDeclaredTypeOfSymbol(symbol));
                }
            });
        }
        return result;
    }
    function getTypeFromConditionalTypeNode(node) {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const checkType = getTypeFromTypeNode(node.checkType);
            const aliasSymbol = getAliasSymbolForTypeNode(node);
            const aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
            const allOuterTypeParameters = getOuterTypeParameters(node, true);
            const outerTypeParameters = aliasTypeArguments ? allOuterTypeParameters : filter(allOuterTypeParameters, tp => isTypeParameterPossiblyReferenced(tp, node));
            const root = {
                node,
                checkType,
                extendsType: getTypeFromTypeNode(node.extendsType),
                isDistributive: !!(checkType.flags & 262144),
                inferTypeParameters: getInferTypeParameters(node),
                outerTypeParameters,
                instantiations: void 0,
                aliasSymbol,
                aliasTypeArguments
            };
            links.resolvedType = getConditionalType(root, void 0);
            if (outerTypeParameters) {
                root.instantiations = /* @__PURE__ */new Map();
                root.instantiations.set(getTypeListId(outerTypeParameters), links.resolvedType);
            }
        }
        return links.resolvedType;
    }
    function getTypeFromInferTypeNode(node) {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            links.resolvedType = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node.typeParameter));
        }
        return links.resolvedType;
    }
    function getIdentifierChain(node) {
        if (isIdentifier(node)) {
            return [node];
        } else {
            return append(getIdentifierChain(node.left), node.right);
        }
    }
    function getTypeFromImportTypeNode(node) {
        var _a2;
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            if (!isLiteralImportTypeNode(node)) {
                error(node.argument, Diagnostics.String_literal_expected);
                links.resolvedSymbol = unknownSymbol;
                return links.resolvedType = errorType;
            }
            const targetMeaning = node.isTypeOf ? 111551 : node.flags & 8388608 ? 111551 | 788968 : 788968;
            const innerModuleSymbol = resolveExternalModuleName(node, node.argument.literal);
            if (!innerModuleSymbol) {
                links.resolvedSymbol = unknownSymbol;
                return links.resolvedType = errorType;
            }
            const isExportEquals = !!((_a2 = innerModuleSymbol.exports) == null ? void 0 : _a2.get("export="));
            const moduleSymbol = resolveExternalModuleSymbol(innerModuleSymbol, false);
            if (!nodeIsMissing(node.qualifier)) {
                const nameStack = getIdentifierChain(node.qualifier);
                let currentNamespace = moduleSymbol;
                let current;
                while (current = nameStack.shift()) {
                    const meaning = nameStack.length ? 1920 : targetMeaning;
                    const mergedResolvedSymbol = getMergedSymbol(resolveSymbol(currentNamespace));
                    const symbolFromVariable = node.isTypeOf || isInJSFile(node) && isExportEquals ? getPropertyOfType(getTypeOfSymbol(mergedResolvedSymbol), current.escapedText, false, true) : void 0;
                    const symbolFromModule = node.isTypeOf ? void 0 : getSymbol2(getExportsOfSymbol(mergedResolvedSymbol), current.escapedText, meaning);
                    const next = symbolFromModule != null ? symbolFromModule : symbolFromVariable;
                    if (!next) {
                        error(current, Diagnostics.Namespace_0_has_no_exported_member_1, getFullyQualifiedName(currentNamespace), declarationNameToString(current));
                        return links.resolvedType = errorType;
                    }
                    getNodeLinks(current).resolvedSymbol = next;
                    getNodeLinks(current.parent).resolvedSymbol = next;
                    currentNamespace = next;
                }
                links.resolvedType = resolveImportSymbolType(node, links, currentNamespace, targetMeaning);
            } else {
                if (moduleSymbol.flags & targetMeaning) {
                    links.resolvedType = resolveImportSymbolType(node, links, moduleSymbol, targetMeaning);
                } else {
                    const errorMessage = targetMeaning === 111551 ? Diagnostics.Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here : Diagnostics.Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0;
                    error(node, errorMessage, node.argument.literal.text);
                    links.resolvedSymbol = unknownSymbol;
                    links.resolvedType = errorType;
                }
            }
        }
        return links.resolvedType;
    }
    function resolveImportSymbolType(node, links, symbol, meaning) {
        const resolvedSymbol = resolveSymbol(symbol);
        links.resolvedSymbol = resolvedSymbol;
        if (meaning === 111551) {
            return getInstantiationExpressionType(getTypeOfSymbol(symbol), node);
        } else {
            return getTypeReferenceType(node, resolvedSymbol);
        }
    }
    function getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node) {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const aliasSymbol = getAliasSymbolForTypeNode(node);
            if (getMembersOfSymbol(node.symbol).size === 0 && !aliasSymbol) {
                links.resolvedType = emptyTypeLiteralType;
            } else {
                let type = createObjectType(16, node.symbol);
                type.aliasSymbol = aliasSymbol;
                type.aliasTypeArguments = getTypeArgumentsForAliasSymbol(aliasSymbol);
                if (isJSDocTypeLiteral(node) && node.isArrayType) {
                    type = createArrayType(type);
                }
                links.resolvedType = type;
            }
        }
        return links.resolvedType;
    }
    function getAliasSymbolForTypeNode(node) {
        let host2 = node.parent;
        while (isParenthesizedTypeNode(host2) || isJSDocTypeExpression(host2) || isTypeOperatorNode(host2) && host2.operator === 146) {
            host2 = host2.parent;
        }
        return isTypeAlias(host2) ? getSymbolOfDeclaration(host2) : void 0;
    }
    function getTypeArgumentsForAliasSymbol(symbol) {
        return symbol ? getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(symbol) : void 0;
    }
    function isNonGenericObjectType(type) {
        return !!(type.flags & 524288) && !isGenericMappedType(type);
    }
    function isEmptyObjectTypeOrSpreadsIntoEmptyObject(type) {
        return isEmptyObjectType(type) || !!(type.flags & (65536 | 32768 | 528 | 296 | 2112 | 402653316 | 1056 | 67108864 | 4194304));
    }
    function tryMergeUnionOfObjectTypeAndEmptyObject(type, readonly) {
        if (!(type.flags & 1048576)) {
            return type;
        }
        if (every(type.types, isEmptyObjectTypeOrSpreadsIntoEmptyObject)) {
            return find(type.types, isEmptyObjectType) || emptyObjectType;
        }
        const firstType = find(type.types, t => !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t));
        if (!firstType) {
            return type;
        }
        const secondType = find(type.types, t => t !== firstType && !isEmptyObjectTypeOrSpreadsIntoEmptyObject(t));
        if (secondType) {
            return type;
        }
        return getAnonymousPartialType(firstType);
        function getAnonymousPartialType(type2) {
            const members = createSymbolTable();
            for (const prop of getPropertiesOfType(type2)) {
                if (getDeclarationModifierFlagsFromSymbol(prop) & (8 | 16)) { } else if (isSpreadableProperty(prop)) {
                    const isSetonlyAccessor = prop.flags & 65536 && !(prop.flags & 32768);
                    const flags = 4 | 16777216;
                    const result = createSymbol(flags, prop.escapedName, getIsLateCheckFlag(prop) | (readonly ? 8 : 0));
                    result.links.type = isSetonlyAccessor ? undefinedType : addOptionality(getTypeOfSymbol(prop), true);
                    result.declarations = prop.declarations;
                    result.links.nameType = getSymbolLinks(prop).nameType;
                    result.links.syntheticOrigin = prop;
                    members.set(prop.escapedName, result);
                }
            }
            const spread = createAnonymousType(type2.symbol, members, emptyArray, emptyArray, getIndexInfosOfType(type2));
            spread.objectFlags |= 128 | 131072;
            return spread;
        }
    }
    function getSpreadType(left, right, symbol, objectFlags, readonly) {
        if (left.flags & 1 || right.flags & 1) {
            return anyType;
        }
        if (left.flags & 2 || right.flags & 2) {
            return unknownType;
        }
        if (left.flags & 131072) {
            return right;
        }
        if (right.flags & 131072) {
            return left;
        }
        left = tryMergeUnionOfObjectTypeAndEmptyObject(left, readonly);
        if (left.flags & 1048576) {
            return checkCrossProductUnion([left, right]) ? mapType(left, t => getSpreadType(t, right, symbol, objectFlags, readonly)) : errorType;
        }
        right = tryMergeUnionOfObjectTypeAndEmptyObject(right, readonly);
        if (right.flags & 1048576) {
            return checkCrossProductUnion([left, right]) ? mapType(right, t => getSpreadType(left, t, symbol, objectFlags, readonly)) : errorType;
        }
        if (right.flags & (528 | 296 | 2112 | 402653316 | 1056 | 67108864 | 4194304)) {
            return left;
        }
        if (isGenericObjectType(left) || isGenericObjectType(right)) {
            if (isEmptyObjectType(left)) {
                return right;
            }
            if (left.flags & 2097152) {
                const types = left.types;
                const lastLeft = types[types.length - 1];
                if (isNonGenericObjectType(lastLeft) && isNonGenericObjectType(right)) {
                    return getIntersectionType(concatenate(types.slice(0, types.length - 1), [getSpreadType(lastLeft, right, symbol, objectFlags, readonly)]));
                }
            }
            return getIntersectionType([left, right]);
        }
        const members = createSymbolTable();
        const skippedPrivateMembers = /* @__PURE__ */new Set();
        const indexInfos = left === emptyObjectType ? getIndexInfosOfType(right) : getUnionIndexInfos([left, right]);
        for (const rightProp of getPropertiesOfType(right)) {
            if (getDeclarationModifierFlagsFromSymbol(rightProp) & (8 | 16)) {
                skippedPrivateMembers.add(rightProp.escapedName);
            } else if (isSpreadableProperty(rightProp)) {
                members.set(rightProp.escapedName, getSpreadSymbol(rightProp, readonly));
            }
        }
        for (const leftProp of getPropertiesOfType(left)) {
            if (skippedPrivateMembers.has(leftProp.escapedName) || !isSpreadableProperty(leftProp)) {
                continue;
            }
            if (members.has(leftProp.escapedName)) {
                const rightProp = members.get(leftProp.escapedName);
                const rightType = getTypeOfSymbol(rightProp);
                if (rightProp.flags & 16777216) {
                    const declarations = concatenate(leftProp.declarations, rightProp.declarations);
                    const flags = 4 | leftProp.flags & 16777216;
                    const result = createSymbol(flags, leftProp.escapedName);
                    result.links.type = getUnionType([getTypeOfSymbol(leftProp), removeMissingOrUndefinedType(rightType)], 2);
                    result.links.leftSpread = leftProp;
                    result.links.rightSpread = rightProp;
                    result.declarations = declarations;
                    result.links.nameType = getSymbolLinks(leftProp).nameType;
                    members.set(leftProp.escapedName, result);
                }
            } else {
                members.set(leftProp.escapedName, getSpreadSymbol(leftProp, readonly));
            }
        }
        const spread = createAnonymousType(symbol, members, emptyArray, emptyArray, sameMap(indexInfos, info => getIndexInfoWithReadonly(info, readonly)));
        spread.objectFlags |= 128 | 131072 | 2097152 | objectFlags;
        return spread;
    }
    function isSpreadableProperty(prop) {
        var _a2;
        return !some(prop.declarations, isPrivateIdentifierClassElementDeclaration) && (!(prop.flags & (8192 | 32768 | 65536)) || !((_a2 = prop.declarations) == null ? void 0 : _a2.some(decl => isClassLike(decl.parent))));
    }
    function getSpreadSymbol(prop, readonly) {
        const isSetonlyAccessor = prop.flags & 65536 && !(prop.flags & 32768);
        if (!isSetonlyAccessor && readonly === isReadonlySymbol(prop)) {
            return prop;
        }
        const flags = 4 | prop.flags & 16777216;
        const result = createSymbol(flags, prop.escapedName, getIsLateCheckFlag(prop) | (readonly ? 8 : 0));
        result.links.type = isSetonlyAccessor ? undefinedType : getTypeOfSymbol(prop);
        result.declarations = prop.declarations;
        result.links.nameType = getSymbolLinks(prop).nameType;
        result.links.syntheticOrigin = prop;
        return result;
    }
    function getIndexInfoWithReadonly(info, readonly) {
        return info.isReadonly !== readonly ? createIndexInfo(info.keyType, info.type, readonly, info.declaration) : info;
    }
    function createLiteralType(flags, value, symbol, regularType) {
        const type = createTypeWithSymbol(flags, symbol);
        type.value = value;
        type.regularType = regularType || type;
        return type;
    }
    function getFreshTypeOfLiteralType(type) {
        if (type.flags & 2976) {
            if (!type.freshType) {
                const freshType = createLiteralType(type.flags, type.value, type.symbol, type);
                freshType.freshType = freshType;
                type.freshType = freshType;
            }
            return type.freshType;
        }
        return type;
    }
    function getRegularTypeOfLiteralType(type) {
        return type.flags & 2976 ? type.regularType : type.flags & 1048576 ? type.regularType || (type.regularType = mapType(type, getRegularTypeOfLiteralType)) : type;
    }
    function isFreshLiteralType(type) {
        return !!(type.flags & 2976) && type.freshType === type;
    }
    function getStringLiteralType(value) {
        let type;
        return stringLiteralTypes.get(value) || (stringLiteralTypes.set(value, type = createLiteralType(128, value)), type);
    }
    function getNumberLiteralType(value) {
        let type;
        return numberLiteralTypes.get(value) || (numberLiteralTypes.set(value, type = createLiteralType(256, value)), type);
    }
    function getBigIntLiteralType(value) {
        let type;
        const key = pseudoBigIntToString(value);
        return bigIntLiteralTypes.get(key) || (bigIntLiteralTypes.set(key, type = createLiteralType(2048, value)), type);
    }
    function getEnumLiteralType(value, enumId, symbol) {
        let type;
        const key = `${enumId}${typeof value === "string" ? "@" : "#"}${value}`;
        const flags = 1024 | (typeof value === "string" ? 128 : 256);
        return enumLiteralTypes.get(key) || (enumLiteralTypes.set(key, type = createLiteralType(flags, value, symbol)), type);
    }
    function getTypeFromLiteralTypeNode(node) {
        if (node.literal.kind === 104) {
            return nullType;
        }
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            links.resolvedType = getRegularTypeOfLiteralType(checkExpression(node.literal));
        }
        return links.resolvedType;
    }
    function createUniqueESSymbolType(symbol) {
        const type = createTypeWithSymbol(8192, symbol);
        type.escapedName = `__@${type.symbol.escapedName}@${getSymbolId(type.symbol)}`;
        return type;
    }
    function getESSymbolLikeTypeForNode(node) {
        if (isValidESSymbolDeclaration(node)) {
            const symbol = isCommonJsExportPropertyAssignment(node) ? getSymbolOfNode(node.left) : getSymbolOfNode(node);
            if (symbol) {
                const links = getSymbolLinks(symbol);
                return links.uniqueESSymbolType || (links.uniqueESSymbolType = createUniqueESSymbolType(symbol));
            }
        }
        return esSymbolType;
    }
    function getThisType(node) {
        const container = getThisContainer(node, false, false);
        const parent2 = container && container.parent;
        if (parent2 && (isClassLike(parent2) || parent2.kind === 261)) {
            if (!isStatic(container) && (!isConstructorDeclaration(container) || isNodeDescendantOf(node, container.body))) {
                return getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(parent2)).thisType;
            }
        }
        if (parent2 && isObjectLiteralExpression(parent2) && isBinaryExpression(parent2.parent) && getAssignmentDeclarationKind(parent2.parent) === 6) {
            return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(parent2.parent.left).parent).thisType;
        }
        const host2 = node.flags & 8388608 ? getHostSignatureFromJSDoc(node) : void 0;
        if (host2 && isFunctionExpression(host2) && isBinaryExpression(host2.parent) && getAssignmentDeclarationKind(host2.parent) === 3) {
            return getDeclaredTypeOfClassOrInterface(getSymbolOfNode(host2.parent.left).parent).thisType;
        }
        if (isJSConstructor(container) && isNodeDescendantOf(node, container.body)) {
            return getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(container)).thisType;
        }
        error(node, Diagnostics.A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface);
        return errorType;
    }
    function getTypeFromThisTypeNode(node) {
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            links.resolvedType = getThisType(node);
        }
        return links.resolvedType;
    }
    function getTypeFromRestTypeNode(node) {
        return getTypeFromTypeNode(getArrayElementTypeNode(node.type) || node.type);
    }
    function getArrayElementTypeNode(node) {
        switch (node.kind) {
            case 193:
                return getArrayElementTypeNode(node.type);
            case 186:
                if (node.elements.length === 1) {
                    node = node.elements[0];
                    if (node.kind === 188 || node.kind === 199 && node.dotDotDotToken) {
                        return getArrayElementTypeNode(node.type);
                    }
                }
                break;
            case 185:
                return node.elementType;
        }
        return void 0;
    }
    function getTypeFromNamedTupleTypeNode(node) {
        const links = getNodeLinks(node);
        return links.resolvedType || (links.resolvedType = node.dotDotDotToken ? getTypeFromRestTypeNode(node) : addOptionality(getTypeFromTypeNode(node.type), true, !!node.questionToken));
    }
    function getTypeFromTypeNode(node) {
        return getConditionalFlowTypeOfType(getTypeFromTypeNodeWorker(node), node);
    }
    function getTypeFromTypeNodeWorker(node) {
        switch (node.kind) {
            case 131:
            case 315:
            case 316:
                return anyType;
            case 157:
                return unknownType;
            case 152:
                return stringType;
            case 148:
                return numberType;
            case 160:
                return bigintType;
            case 134:
                return booleanType;
            case 153:
                return esSymbolType;
            case 114:
                return voidType;
            case 155:
                return undefinedType;
            case 104:
                return nullType;
            case 144:
                return neverType;
            case 149:
                return node.flags & 262144 && !noImplicitAny ? anyType : nonPrimitiveType;
            case 139:
                return intrinsicMarkerType;
            case 194:
            case 108:
                return getTypeFromThisTypeNode(node);
            case 198:
                return getTypeFromLiteralTypeNode(node);
            case 180:
                return getTypeFromTypeReference(node);
            case 179:
                return node.assertsModifier ? voidType : booleanType;
            case 230:
                return getTypeFromTypeReference(node);
            case 183:
                return getTypeFromTypeQueryNode(node);
            case 185:
            case 186:
                return getTypeFromArrayOrTupleTypeNode(node);
            case 187:
                return getTypeFromOptionalTypeNode(node);
            case 189:
                return getTypeFromUnionTypeNode(node);
            case 190:
                return getTypeFromIntersectionTypeNode(node);
            case 317:
                return getTypeFromJSDocNullableTypeNode(node);
            case 319:
                return addOptionality(getTypeFromTypeNode(node.type));
            case 199:
                return getTypeFromNamedTupleTypeNode(node);
            case 193:
            case 318:
            case 312:
                return getTypeFromTypeNode(node.type);
            case 188:
                return getTypeFromRestTypeNode(node);
            case 321:
                return getTypeFromJSDocVariadicType(node);
            case 181:
            case 182:
            case 184:
            case 325:
            case 320:
            case 326:
                return getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node);
            case 195:
                return getTypeFromTypeOperatorNode(node);
            case 196:
                return getTypeFromIndexedAccessTypeNode(node);
            case 197:
                return getTypeFromMappedTypeNode(node);
            case 191:
                return getTypeFromConditionalTypeNode(node);
            case 192:
                return getTypeFromInferTypeNode(node);
            case 200:
                return getTypeFromTemplateTypeNode(node);
            case 202:
                return getTypeFromImportTypeNode(node);
            case 79:
            case 163:
            case 208:
                const symbol = getSymbolAtLocation(node);
                return symbol ? getDeclaredTypeOfSymbol(symbol) : errorType;
            default:
                return errorType;
        }
    }
    function instantiateList(items, mapper, instantiator) {
        if (items && items.length) {
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const mapped = instantiator(item, mapper);
                if (item !== mapped) {
                    const result = i === 0 ? [] : items.slice(0, i);
                    result.push(mapped);
                    for (i++; i < items.length; i++) {
                        result.push(instantiator(items[i], mapper));
                    }
                    return result;
                }
            }
        }
        return items;
    }
    function instantiateTypes(types, mapper) {
        return instantiateList(types, mapper, instantiateType);
    }
    function instantiateSignatures(signatures, mapper) {
        return instantiateList(signatures, mapper, instantiateSignature);
    }
    function instantiateIndexInfos(indexInfos, mapper) {
        return instantiateList(indexInfos, mapper, instantiateIndexInfo);
    }
    function createTypeMapper(sources, targets) {
        return sources.length === 1 ? makeUnaryTypeMapper(sources[0], targets ? targets[0] : anyType) : makeArrayTypeMapper(sources, targets);
    }
    function getMappedType(type, mapper) {
        switch (mapper.kind) {
            case 0:
                return type === mapper.source ? mapper.target : type;
            case 1:
                {
                    const sources = mapper.sources;
                    const targets = mapper.targets;
                    for (let i = 0; i < sources.length; i++) {
                        if (type === sources[i]) {
                            return targets ? targets[i] : anyType;
                        }
                    }
                    return type;
                }
            case 2:
                {
                    const sources = mapper.sources;
                    const targets = mapper.targets;
                    for (let i = 0; i < sources.length; i++) {
                        if (type === sources[i]) {
                            return targets[i]();
                        }
                    }
                    return type;
                }
            case 3:
                return mapper.func(type);
            case 4:
            case 5:
                const t1 = getMappedType(type, mapper.mapper1);
                return t1 !== type && mapper.kind === 4 ? instantiateType(t1, mapper.mapper2) : getMappedType(t1, mapper.mapper2);
        }
    }
    function makeUnaryTypeMapper(source, target) {
        return Debug.attachDebugPrototypeIfDebug({
            kind: 0,
            source,
            target
        });
    }
    function makeArrayTypeMapper(sources, targets) {
        return Debug.attachDebugPrototypeIfDebug({
            kind: 1,
            sources,
            targets
        });
    }
    function makeFunctionTypeMapper(func, debugInfo) {
        return Debug.attachDebugPrototypeIfDebug({
            kind: 3,
            func,
            debugInfo: Debug.isDebugging ? debugInfo : void 0
        });
    }
    function makeDeferredTypeMapper(sources, targets) {
        return Debug.attachDebugPrototypeIfDebug({
            kind: 2,
            sources,
            targets
        });
    }
    function makeCompositeTypeMapper(kind, mapper1, mapper2) {
        return Debug.attachDebugPrototypeIfDebug({
            kind,
            mapper1,
            mapper2
        });
    }
    function createTypeEraser(sources) {
        return createTypeMapper(sources, void 0);
    }
    function createBackreferenceMapper(context, index) {
        const forwardInferences = context.inferences.slice(index);
        return createTypeMapper(map(forwardInferences, i => i.typeParameter), map(forwardInferences, () => unknownType));
    }
    function combineTypeMappers(mapper1, mapper2) {
        return mapper1 ? makeCompositeTypeMapper(4, mapper1, mapper2) : mapper2;
    }
    function mergeTypeMappers(mapper1, mapper2) {
        return mapper1 ? makeCompositeTypeMapper(5, mapper1, mapper2) : mapper2;
    }
    function prependTypeMapping(source, target, mapper) {
        return !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(5, makeUnaryTypeMapper(source, target), mapper);
    }
    function appendTypeMapping(mapper, source, target) {
        return !mapper ? makeUnaryTypeMapper(source, target) : makeCompositeTypeMapper(5, mapper, makeUnaryTypeMapper(source, target));
    }
    function getRestrictiveTypeParameter(tp) {
        return !tp.constraint && !getConstraintDeclaration(tp) || tp.constraint === noConstraintType ? tp : tp.restrictiveInstantiation || (tp.restrictiveInstantiation = createTypeParameter(tp.symbol), tp.restrictiveInstantiation.constraint = noConstraintType, tp.restrictiveInstantiation);
    }
    function cloneTypeParameter(typeParameter) {
        const result = createTypeParameter(typeParameter.symbol);
        result.target = typeParameter;
        return result;
    }
    function instantiateTypePredicate(predicate, mapper) {
        return createTypePredicate(predicate.kind, predicate.parameterName, predicate.parameterIndex, instantiateType(predicate.type, mapper));
    }
    function instantiateSignature(signature, mapper, eraseTypeParameters) {
        let freshTypeParameters;
        if (signature.typeParameters && !eraseTypeParameters) {
            freshTypeParameters = map(signature.typeParameters, cloneTypeParameter);
            mapper = combineTypeMappers(createTypeMapper(signature.typeParameters, freshTypeParameters), mapper);
            for (const tp of freshTypeParameters) {
                tp.mapper = mapper;
            }
        }
        const result = createSignature(signature.declaration, freshTypeParameters, signature.thisParameter && instantiateSymbol(signature.thisParameter, mapper), instantiateList(signature.parameters, mapper, instantiateSymbol), void 0, void 0, signature.minArgumentCount, signature.flags & 39);
        result.target = signature;
        result.mapper = mapper;
        return result;
    }
    function instantiateSymbol(symbol, mapper) {
        const links = getSymbolLinks(symbol);
        if (links.type && !couldContainTypeVariables(links.type)) {
            return symbol;
        }
        if (getCheckFlags(symbol) & 1) {
            symbol = links.target;
            mapper = combineTypeMappers(links.mapper, mapper);
        }
        const result = createSymbol(symbol.flags, symbol.escapedName, 1 | getCheckFlags(symbol) & (8 | 4096 | 16384 | 32768));
        result.declarations = symbol.declarations;
        result.parent = symbol.parent;
        result.links.target = symbol;
        result.links.mapper = mapper;
        if (symbol.valueDeclaration) {
            result.valueDeclaration = symbol.valueDeclaration;
        }
        if (links.nameType) {
            result.links.nameType = links.nameType;
        }
        return result;
    }
    function getObjectTypeInstantiation(type, mapper, aliasSymbol, aliasTypeArguments) {
        const declaration = type.objectFlags & 4 ? type.node : type.objectFlags & 8388608 ? type.node : type.symbol.declarations[0];
        const links = getNodeLinks(declaration);
        const target = type.objectFlags & 4 ? links.resolvedType : type.objectFlags & 64 ? type.target : type;
        let typeParameters = links.outerTypeParameters;
        if (!typeParameters) {
            let outerTypeParameters = getOuterTypeParameters(declaration, true);
            if (isJSConstructor(declaration)) {
                const templateTagParameters = getTypeParametersFromDeclaration(declaration);
                outerTypeParameters = addRange(outerTypeParameters, templateTagParameters);
            }
            typeParameters = outerTypeParameters || emptyArray;
            const allDeclarations = type.objectFlags & (4 | 8388608) ? [declaration] : type.symbol.declarations;
            typeParameters = (target.objectFlags & (4 | 8388608) || target.symbol.flags & 8192 || target.symbol.flags & 2048) && !target.aliasTypeArguments ? filter(typeParameters, tp => some(allDeclarations, d => isTypeParameterPossiblyReferenced(tp, d))) : typeParameters;
            links.outerTypeParameters = typeParameters;
        }
        if (typeParameters.length) {
            const combinedMapper = combineTypeMappers(type.mapper, mapper);
            const typeArguments = map(typeParameters, t => getMappedType(t, combinedMapper));
            const newAliasSymbol = aliasSymbol || type.aliasSymbol;
            const newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
            const id = getTypeListId(typeArguments) + getAliasId(newAliasSymbol, newAliasTypeArguments);
            if (!target.instantiations) {
                target.instantiations = /* @__PURE__ */new Map();
                target.instantiations.set(getTypeListId(typeParameters) + getAliasId(target.aliasSymbol, target.aliasTypeArguments), target);
            }
            let result = target.instantiations.get(id);
            if (!result) {
                const newMapper = createTypeMapper(typeParameters, typeArguments);
                result = target.objectFlags & 4 ? createDeferredTypeReference(type.target, type.node, newMapper, newAliasSymbol, newAliasTypeArguments) : target.objectFlags & 32 ? instantiateMappedType(target, newMapper, newAliasSymbol, newAliasTypeArguments) : instantiateAnonymousType(target, newMapper, newAliasSymbol, newAliasTypeArguments);
                target.instantiations.set(id, result);
            }
            return result;
        }
        return type;
    }
    function maybeTypeParameterReference(node) {
        return !(node.parent.kind === 180 && node.parent.typeArguments && node === node.parent.typeName || node.parent.kind === 202 && node.parent.typeArguments && node === node.parent.qualifier);
    }
    function isTypeParameterPossiblyReferenced(tp, node) {
        if (tp.symbol && tp.symbol.declarations && tp.symbol.declarations.length === 1) {
            const container = tp.symbol.declarations[0].parent;
            for (let n = node; n !== container; n = n.parent) {
                if (!n || n.kind === 238 || n.kind === 191 && forEachChild(n.extendsType, containsReference)) {
                    return true;
                }
            }
            return containsReference(node);
        }
        return true;
        function containsReference(node2) {
            switch (node2.kind) {
                case 194:
                    return !!tp.isThisType;
                case 79:
                    return !tp.isThisType && isPartOfTypeNode(node2) && maybeTypeParameterReference(node2) && getTypeFromTypeNodeWorker(node2) === tp;
                case 183:
                    const entityName = node2.exprName;
                    const firstIdentifier = getFirstIdentifier(entityName);
                    const firstIdentifierSymbol = getResolvedSymbol(firstIdentifier);
                    const tpDeclaration = tp.symbol.declarations[0];
                    let tpScope;
                    if (tpDeclaration.kind === 165) {
                        tpScope = tpDeclaration.parent;
                    } else if (tp.isThisType) {
                        tpScope = tpDeclaration;
                    } else {
                        return true;
                    }
                    if (firstIdentifierSymbol.declarations) {
                        return some(firstIdentifierSymbol.declarations, idDecl => isNodeDescendantOf(idDecl, tpScope)) || some(node2.typeArguments, containsReference);
                    }
                    return true;
                case 171:
                case 170:
                    return !node2.type && !!node2.body || some(node2.typeParameters, containsReference) || some(node2.parameters, containsReference) || !!node2.type && containsReference(node2.type);
            }
            return !!forEachChild(node2, containsReference);
        }
    }
    function getHomomorphicTypeVariable(type) {
        const constraintType = getConstraintTypeFromMappedType(type);
        if (constraintType.flags & 4194304) {
            const typeVariable = getActualTypeVariable(constraintType.type);
            if (typeVariable.flags & 262144) {
                return typeVariable;
            }
        }
        return void 0;
    }
    function instantiateMappedType(type, mapper, aliasSymbol, aliasTypeArguments) {
        const typeVariable = getHomomorphicTypeVariable(type);
        if (typeVariable) {
            const mappedTypeVariable = instantiateType(typeVariable, mapper);
            if (typeVariable !== mappedTypeVariable) {
                return mapTypeWithAlias(getReducedType(mappedTypeVariable), t => {
                    if (t.flags & (3 | 58982400 | 524288 | 2097152) && t !== wildcardType && !isErrorType(t)) {
                        if (!type.declaration.nameType) {
                            let constraint;
                            if (isArrayType(t) || t.flags & 1 && findResolutionCycleStartIndex(typeVariable, 4) < 0 && (constraint = getConstraintOfTypeParameter(typeVariable)) && everyType(constraint, isArrayOrTupleType)) {
                                return instantiateMappedArrayType(t, type, prependTypeMapping(typeVariable, t, mapper));
                            }
                            if (isGenericTupleType(t)) {
                                return instantiateMappedGenericTupleType(t, type, typeVariable, mapper);
                            }
                            if (isTupleType(t)) {
                                return instantiateMappedTupleType(t, type, prependTypeMapping(typeVariable, t, mapper));
                            }
                        }
                        return instantiateAnonymousType(type, prependTypeMapping(typeVariable, t, mapper));
                    }
                    return t;
                }, aliasSymbol, aliasTypeArguments);
            }
        }
        return instantiateType(getConstraintTypeFromMappedType(type), mapper) === wildcardType ? wildcardType : instantiateAnonymousType(type, mapper, aliasSymbol, aliasTypeArguments);
    }
    function getModifiedReadonlyState(state, modifiers) {
        return modifiers & 1 ? true : modifiers & 2 ? false : state;
    }
    function instantiateMappedGenericTupleType(tupleType, mappedType, typeVariable, mapper) {
        const elementFlags = tupleType.target.elementFlags;
        const elementTypes = map(getTypeArguments(tupleType), (t, i) => {
            const singleton = elementFlags[i] & 8 ? t : elementFlags[i] & 4 ? createArrayType(t) : createTupleType([t], [elementFlags[i]]);
            return instantiateMappedType(mappedType, prependTypeMapping(typeVariable, singleton, mapper));
        });
        const newReadonly = getModifiedReadonlyState(tupleType.target.readonly, getMappedTypeModifiers(mappedType));
        return createTupleType(elementTypes, map(elementTypes, _ => 8), newReadonly);
    }
    function instantiateMappedArrayType(arrayType, mappedType, mapper) {
        const elementType = instantiateMappedTypeTemplate(mappedType, numberType, true, mapper);
        return isErrorType(elementType) ? errorType : createArrayType(elementType, getModifiedReadonlyState(isReadonlyArrayType(arrayType), getMappedTypeModifiers(mappedType)));
    }
    function instantiateMappedTupleType(tupleType, mappedType, mapper) {
        const elementFlags = tupleType.target.elementFlags;
        const elementTypes = map(getTypeArguments(tupleType), (_, i) => instantiateMappedTypeTemplate(mappedType, getStringLiteralType("" + i), !!(elementFlags[i] & 2), mapper));
        const modifiers = getMappedTypeModifiers(mappedType);
        const newTupleModifiers = modifiers & 4 ? map(elementFlags, f => f & 1 ? 2 : f) : modifiers & 8 ? map(elementFlags, f => f & 2 ? 1 : f) : elementFlags;
        const newReadonly = getModifiedReadonlyState(tupleType.target.readonly, modifiers);
        return contains(elementTypes, errorType) ? errorType : createTupleType(elementTypes, newTupleModifiers, newReadonly, tupleType.target.labeledElementDeclarations);
    }
    function instantiateMappedTypeTemplate(type, key, isOptional, mapper) {
        const templateMapper = appendTypeMapping(mapper, getTypeParameterFromMappedType(type), key);
        const propType = instantiateType(getTemplateTypeFromMappedType(type.target || type), templateMapper);
        const modifiers = getMappedTypeModifiers(type);
        return strictNullChecks && modifiers & 4 && !maybeTypeOfKind(propType, 32768 | 16384) ? getOptionalType(propType, true) : strictNullChecks && modifiers & 8 && isOptional ? getTypeWithFacts(propType, 524288) : propType;
    }
    function instantiateAnonymousType(type, mapper, aliasSymbol, aliasTypeArguments) {
        const result = createObjectType(type.objectFlags | 64, type.symbol);
        if (type.objectFlags & 32) {
            result.declaration = type.declaration;
            const origTypeParameter = getTypeParameterFromMappedType(type);
            const freshTypeParameter = cloneTypeParameter(origTypeParameter);
            result.typeParameter = freshTypeParameter;
            mapper = combineTypeMappers(makeUnaryTypeMapper(origTypeParameter, freshTypeParameter), mapper);
            freshTypeParameter.mapper = mapper;
        }
        if (type.objectFlags & 8388608) {
            result.node = type.node;
        }
        result.target = type;
        result.mapper = mapper;
        result.aliasSymbol = aliasSymbol || type.aliasSymbol;
        result.aliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
        result.objectFlags |= result.aliasTypeArguments ? getPropagatingFlagsOfTypes(result.aliasTypeArguments) : 0;
        return result;
    }
    function getConditionalTypeInstantiation(type, mapper, aliasSymbol, aliasTypeArguments) {
        const root = type.root;
        if (root.outerTypeParameters) {
            const typeArguments = map(root.outerTypeParameters, t => getMappedType(t, mapper));
            const id = getTypeListId(typeArguments) + getAliasId(aliasSymbol, aliasTypeArguments);
            let result = root.instantiations.get(id);
            if (!result) {
                const newMapper = createTypeMapper(root.outerTypeParameters, typeArguments);
                const checkType = root.checkType;
                const distributionType = root.isDistributive ? getMappedType(checkType, newMapper) : void 0;
                result = distributionType && checkType !== distributionType && distributionType.flags & (1048576 | 131072) ? mapTypeWithAlias(getReducedType(distributionType), t => getConditionalType(root, prependTypeMapping(checkType, t, newMapper)), aliasSymbol, aliasTypeArguments) : getConditionalType(root, newMapper, aliasSymbol, aliasTypeArguments);
                root.instantiations.set(id, result);
            }
            return result;
        }
        return type;
    }
    function instantiateType(type, mapper) {
        return type && mapper ? instantiateTypeWithAlias(type, mapper, void 0, void 0) : type;
    }
    function instantiateTypeWithAlias(type, mapper, aliasSymbol, aliasTypeArguments) {
        var _a2;
        if (!couldContainTypeVariables(type)) {
            return type;
        }
        if (instantiationDepth === 100 || instantiationCount >= 5e6) {
            (_a2 = tracing) == null ? void 0 : _a2.instant(tracing.Phase.CheckTypes, "instantiateType_DepthLimit", {
                typeId: type.id,
                instantiationDepth,
                instantiationCount
            });
            error(currentNode, Diagnostics.Type_instantiation_is_excessively_deep_and_possibly_infinite);
            return errorType;
        }
        totalInstantiationCount++;
        instantiationCount++;
        instantiationDepth++;
        const result = instantiateTypeWorker(type, mapper, aliasSymbol, aliasTypeArguments);
        instantiationDepth--;
        return result;
    }
    function instantiateTypeWorker(type, mapper, aliasSymbol, aliasTypeArguments) {
        const flags = type.flags;
        if (flags & 262144) {
            return getMappedType(type, mapper);
        }
        if (flags & 524288) {
            const objectFlags = type.objectFlags;
            if (objectFlags & (4 | 16 | 32)) {
                if (objectFlags & 4 && !type.node) {
                    const resolvedTypeArguments = type.resolvedTypeArguments;
                    const newTypeArguments = instantiateTypes(resolvedTypeArguments, mapper);
                    return newTypeArguments !== resolvedTypeArguments ? createNormalizedTypeReference(type.target, newTypeArguments) : type;
                }
                if (objectFlags & 1024) {
                    return instantiateReverseMappedType(type, mapper);
                }
                return getObjectTypeInstantiation(type, mapper, aliasSymbol, aliasTypeArguments);
            }
            return type;
        }
        if (flags & 3145728) {
            const origin = type.flags & 1048576 ? type.origin : void 0;
            const types = origin && origin.flags & 3145728 ? origin.types : type.types;
            const newTypes = instantiateTypes(types, mapper);
            if (newTypes === types && aliasSymbol === type.aliasSymbol) {
                return type;
            }
            const newAliasSymbol = aliasSymbol || type.aliasSymbol;
            const newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
            return flags & 2097152 || origin && origin.flags & 2097152 ? getIntersectionType(newTypes, newAliasSymbol, newAliasTypeArguments) : getUnionType(newTypes, 1, newAliasSymbol, newAliasTypeArguments);
        }
        if (flags & 4194304) {
            return getIndexType(instantiateType(type.type, mapper));
        }
        if (flags & 134217728) {
            return getTemplateLiteralType(type.texts, instantiateTypes(type.types, mapper));
        }
        if (flags & 268435456) {
            return getStringMappingType(type.symbol, instantiateType(type.type, mapper));
        }
        if (flags & 8388608) {
            const newAliasSymbol = aliasSymbol || type.aliasSymbol;
            const newAliasTypeArguments = aliasSymbol ? aliasTypeArguments : instantiateTypes(type.aliasTypeArguments, mapper);
            return getIndexedAccessType(instantiateType(type.objectType, mapper), instantiateType(type.indexType, mapper), type.accessFlags, void 0, newAliasSymbol, newAliasTypeArguments);
        }
        if (flags & 16777216) {
            return getConditionalTypeInstantiation(type, combineTypeMappers(type.mapper, mapper), aliasSymbol, aliasTypeArguments);
        }
        if (flags & 33554432) {
            const newBaseType = instantiateType(type.baseType, mapper);
            const newConstraint = instantiateType(type.constraint, mapper);
            if (newBaseType.flags & 8650752 && isGenericType(newConstraint)) {
                return getSubstitutionType(newBaseType, newConstraint);
            }
            if (newConstraint.flags & 3 || isTypeAssignableTo(getRestrictiveInstantiation(newBaseType), getRestrictiveInstantiation(newConstraint))) {
                return newBaseType;
            }
            return newBaseType.flags & 8650752 ? getSubstitutionType(newBaseType, newConstraint) : getIntersectionType([newConstraint, newBaseType]);
        }
        return type;
    }
    function instantiateReverseMappedType(type, mapper) {
        const innerMappedType = instantiateType(type.mappedType, mapper);
        if (!(getObjectFlags(innerMappedType) & 32)) {
            return type;
        }
        const innerIndexType = instantiateType(type.constraintType, mapper);
        if (!(innerIndexType.flags & 4194304)) {
            return type;
        }
        const instantiated = inferTypeForHomomorphicMappedType(instantiateType(type.source, mapper), innerMappedType, innerIndexType);
        if (instantiated) {
            return instantiated;
        }
        return type;
    }
    function getUniqueLiteralFilledInstantiation(type) {
        return type.flags & (134348796 | 3 | 131072) ? type : type.uniqueLiteralFilledInstantiation || (type.uniqueLiteralFilledInstantiation = instantiateType(type, uniqueLiteralMapper));
    }
    function getPermissiveInstantiation(type) {
        return type.flags & (134348796 | 3 | 131072) ? type : type.permissiveInstantiation || (type.permissiveInstantiation = instantiateType(type, permissiveMapper));
    }
    function getRestrictiveInstantiation(type) {
        if (type.flags & (134348796 | 3 | 131072)) {
            return type;
        }
        if (type.restrictiveInstantiation) {
            return type.restrictiveInstantiation;
        }
        type.restrictiveInstantiation = instantiateType(type, restrictiveMapper);
        type.restrictiveInstantiation.restrictiveInstantiation = type.restrictiveInstantiation;
        return type.restrictiveInstantiation;
    }
    function instantiateIndexInfo(info, mapper) {
        return createIndexInfo(info.keyType, instantiateType(info.type, mapper), info.isReadonly, info.declaration);
    }
    function isContextSensitive(node) {
        Debug.assert(node.kind !== 171 || isObjectLiteralMethod(node));
        switch (node.kind) {
            case 215:
            case 216:
            case 171:
            case 259:
                return isContextSensitiveFunctionLikeDeclaration(node);
            case 207:
                return some(node.properties, isContextSensitive);
            case 206:
                return some(node.elements, isContextSensitive);
            case 224:
                return isContextSensitive(node.whenTrue) || isContextSensitive(node.whenFalse);
            case 223:
                return (node.operatorToken.kind === 56 || node.operatorToken.kind === 60) && (isContextSensitive(node.left) || isContextSensitive(node.right));
            case 299:
                return isContextSensitive(node.initializer);
            case 214:
                return isContextSensitive(node.expression);
            case 289:
                return some(node.properties, isContextSensitive) || isJsxOpeningElement(node.parent) && some(node.parent.parent.children, isContextSensitive);
            case 288:
                {
                    const {
                        initializer
                    } = node;
                    return !!initializer && isContextSensitive(initializer);
                }
            case 291:
                {
                    const {
                        expression
                    } = node;
                    return !!expression && isContextSensitive(expression);
                }
        }
        return false;
    }
    function isContextSensitiveFunctionLikeDeclaration(node) {
        return hasContextSensitiveParameters(node) || hasContextSensitiveReturnExpression(node);
    }
    function hasContextSensitiveReturnExpression(node) {
        return !node.typeParameters && !getEffectiveReturnTypeNode(node) && !!node.body && node.body.kind !== 238 && isContextSensitive(node.body);
    }
    function isContextSensitiveFunctionOrObjectLiteralMethod(func) {
        return (isFunctionExpressionOrArrowFunction(func) || isObjectLiteralMethod(func)) && isContextSensitiveFunctionLikeDeclaration(func);
    }
    function getTypeWithoutSignatures(type) {
        if (type.flags & 524288) {
            const resolved = resolveStructuredTypeMembers(type);
            if (resolved.constructSignatures.length || resolved.callSignatures.length) {
                const result = createObjectType(16, type.symbol);
                result.members = resolved.members;
                result.properties = resolved.properties;
                result.callSignatures = emptyArray;
                result.constructSignatures = emptyArray;
                result.indexInfos = emptyArray;
                return result;
            }
        } else if (type.flags & 2097152) {
            return getIntersectionType(map(type.types, getTypeWithoutSignatures));
        }
        return type;
    }
    function isTypeIdenticalTo(source, target) {
        return isTypeRelatedTo(source, target, identityRelation);
    }
    function compareTypesIdentical(source, target) {
        return isTypeRelatedTo(source, target, identityRelation) ? -1 : 0;
    }
    function compareTypesAssignable(source, target) {
        return isTypeRelatedTo(source, target, assignableRelation) ? -1 : 0;
    }
    function compareTypesSubtypeOf(source, target) {
        return isTypeRelatedTo(source, target, subtypeRelation) ? -1 : 0;
    }
    function isTypeSubtypeOf(source, target) {
        return isTypeRelatedTo(source, target, subtypeRelation);
    }
    function isTypeStrictSubtypeOf(source, target) {
        return isTypeRelatedTo(source, target, strictSubtypeRelation);
    }
    function isTypeAssignableTo(source, target) {
        return isTypeRelatedTo(source, target, assignableRelation);
    }
    function isTypeDerivedFrom(source, target) {
        return source.flags & 1048576 ? every(source.types, t => isTypeDerivedFrom(t, target)) : target.flags & 1048576 ? some(target.types, t => isTypeDerivedFrom(source, t)) : source.flags & 2097152 ? some(source.types, t => isTypeDerivedFrom(t, target)) : source.flags & 58982400 ? isTypeDerivedFrom(getBaseConstraintOfType(source) || unknownType, target) : isEmptyAnonymousObjectType(target) ? !!(source.flags & (524288 | 67108864)) : target === globalObjectType ? !!(source.flags & (524288 | 67108864)) && !isEmptyAnonymousObjectType(source) : target === globalFunctionType ? !!(source.flags & 524288) && isFunctionObjectType(source) : hasBaseType(source, getTargetType(target)) || isArrayType(target) && !isReadonlyArrayType(target) && isTypeDerivedFrom(source, globalReadonlyArrayType);
    }
    function isTypeComparableTo(source, target) {
        return isTypeRelatedTo(source, target, comparableRelation);
    }
    function areTypesComparable(type1, type2) {
        return isTypeComparableTo(type1, type2) || isTypeComparableTo(type2, type1);
    }
    function checkTypeAssignableTo(source, target, errorNode, headMessage, containingMessageChain, errorOutputObject) {
        return checkTypeRelatedTo(source, target, assignableRelation, errorNode, headMessage, containingMessageChain, errorOutputObject);
    }
    function checkTypeAssignableToAndOptionallyElaborate(source, target, errorNode, expr, headMessage, containingMessageChain) {
        return checkTypeRelatedToAndOptionallyElaborate(source, target, assignableRelation, errorNode, expr, headMessage, containingMessageChain, void 0);
    }
    function checkTypeRelatedToAndOptionallyElaborate(source, target, relation, errorNode, expr, headMessage, containingMessageChain, errorOutputContainer) {
        if (isTypeRelatedTo(source, target, relation)) return true;
        if (!errorNode || !elaborateError(expr, source, target, relation, headMessage, containingMessageChain, errorOutputContainer)) {
            return checkTypeRelatedTo(source, target, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer);
        }
        return false;
    }
    function isOrHasGenericConditional(type) {
        return !!(type.flags & 16777216 || type.flags & 2097152 && some(type.types, isOrHasGenericConditional));
    }
    function elaborateError(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) {
        if (!node || isOrHasGenericConditional(target)) return false;
        if (!checkTypeRelatedTo(source, target, relation, void 0) && elaborateDidYouMeanToCallOrConstruct(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer)) {
            return true;
        }
        switch (node.kind) {
            case 291:
            case 214:
                return elaborateError(node.expression, source, target, relation, headMessage, containingMessageChain, errorOutputContainer);
            case 223:
                switch (node.operatorToken.kind) {
                    case 63:
                    case 27:
                        return elaborateError(node.right, source, target, relation, headMessage, containingMessageChain, errorOutputContainer);
                }
                break;
            case 207:
                return elaborateObjectLiteral(node, source, target, relation, containingMessageChain, errorOutputContainer);
            case 206:
                return elaborateArrayLiteral(node, source, target, relation, containingMessageChain, errorOutputContainer);
            case 289:
                return elaborateJsxComponents(node, source, target, relation, containingMessageChain, errorOutputContainer);
            case 216:
                return elaborateArrowFunction(node, source, target, relation, containingMessageChain, errorOutputContainer);
        }
        return false;
    }
    function elaborateDidYouMeanToCallOrConstruct(node, source, target, relation, headMessage, containingMessageChain, errorOutputContainer) {
        const callSignatures = getSignaturesOfType(source, 0);
        const constructSignatures = getSignaturesOfType(source, 1);
        for (const signatures of [constructSignatures, callSignatures]) {
            if (some(signatures, s => {
                const returnType = getReturnTypeOfSignature(s);
                return !(returnType.flags & (1 | 131072)) && checkTypeRelatedTo(returnType, target, relation, void 0);
            })) {
                const resultObj = errorOutputContainer || {};
                checkTypeAssignableTo(source, target, node, headMessage, containingMessageChain, resultObj);
                const diagnostic = resultObj.errors[resultObj.errors.length - 1];
                addRelatedInfo(diagnostic, createDiagnosticForNode(node, signatures === constructSignatures ? Diagnostics.Did_you_mean_to_use_new_with_this_expression : Diagnostics.Did_you_mean_to_call_this_expression));
                return true;
            }
        }
        return false;
    }
    function elaborateArrowFunction(node, source, target, relation, containingMessageChain, errorOutputContainer) {
        if (isBlock(node.body)) {
            return false;
        }
        if (some(node.parameters, hasType)) {
            return false;
        }
        const sourceSig = getSingleCallSignature(source);
        if (!sourceSig) {
            return false;
        }
        const targetSignatures = getSignaturesOfType(target, 0);
        if (!length(targetSignatures)) {
            return false;
        }
        const returnExpression = node.body;
        const sourceReturn = getReturnTypeOfSignature(sourceSig);
        const targetReturn = getUnionType(map(targetSignatures, getReturnTypeOfSignature));
        if (!checkTypeRelatedTo(sourceReturn, targetReturn, relation, void 0)) {
            const elaborated = returnExpression && elaborateError(returnExpression, sourceReturn, targetReturn, relation, void 0, containingMessageChain, errorOutputContainer);
            if (elaborated) {
                return elaborated;
            }
            const resultObj = errorOutputContainer || {};
            checkTypeRelatedTo(sourceReturn, targetReturn, relation, returnExpression, void 0, containingMessageChain, resultObj);
            if (resultObj.errors) {
                if (target.symbol && length(target.symbol.declarations)) {
                    addRelatedInfo(resultObj.errors[resultObj.errors.length - 1], createDiagnosticForNode(target.symbol.declarations[0], Diagnostics.The_expected_type_comes_from_the_return_type_of_this_signature));
                }
                if ((getFunctionFlags(node) & 2) === 0 && !getTypeOfPropertyOfType(sourceReturn, "then") && checkTypeRelatedTo(createPromiseType(sourceReturn), targetReturn, relation, void 0)) {
                    addRelatedInfo(resultObj.errors[resultObj.errors.length - 1], createDiagnosticForNode(node, Diagnostics.Did_you_mean_to_mark_this_function_as_async));
                }
                return true;
            }
        }
        return false;
    }
    function getBestMatchIndexedAccessTypeOrUndefined(source, target, nameType) {
        const idx = getIndexedAccessTypeOrUndefined(target, nameType);
        if (idx) {
            return idx;
        }
        if (target.flags & 1048576) {
            const best = getBestMatchingType(source, target);
            if (best) {
                return getIndexedAccessTypeOrUndefined(best, nameType);
            }
        }
    }
    function checkExpressionForMutableLocationWithContextualType(next, sourcePropType) {
        pushContextualType(next, sourcePropType, false);
        const result = checkExpressionForMutableLocation(next, 1);
        popContextualType();
        return result;
    }
    function elaborateElementwise(iterator, source, target, relation, containingMessageChain, errorOutputContainer) {
        let reportedError = false;
        for (const value of iterator) {
            const {
                errorNode: prop,
                innerExpression: next,
                nameType,
                errorMessage
            } = value;
            let targetPropType = getBestMatchIndexedAccessTypeOrUndefined(source, target, nameType);
            if (!targetPropType || targetPropType.flags & 8388608) continue;
            let sourcePropType = getIndexedAccessTypeOrUndefined(source, nameType);
            if (!sourcePropType) continue;
            const propName = getPropertyNameFromIndex(nameType, void 0);
            if (!checkTypeRelatedTo(sourcePropType, targetPropType, relation, void 0)) {
                const elaborated = next && elaborateError(next, sourcePropType, targetPropType, relation, void 0, containingMessageChain, errorOutputContainer);
                reportedError = true;
                if (!elaborated) {
                    const resultObj = errorOutputContainer || {};
                    const specificSource = next ? checkExpressionForMutableLocationWithContextualType(next, sourcePropType) : sourcePropType;
                    if (exactOptionalPropertyTypes && isExactOptionalPropertyMismatch(specificSource, targetPropType)) {
                        const diag2 = createDiagnosticForNode(prop, Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target, typeToString(specificSource), typeToString(targetPropType));
                        diagnostics.add(diag2);
                        resultObj.errors = [diag2];
                    } else {
                        const targetIsOptional = !!(propName && (getPropertyOfType(target, propName) || unknownSymbol).flags & 16777216);
                        const sourceIsOptional = !!(propName && (getPropertyOfType(source, propName) || unknownSymbol).flags & 16777216);
                        targetPropType = removeMissingType(targetPropType, targetIsOptional);
                        sourcePropType = removeMissingType(sourcePropType, targetIsOptional && sourceIsOptional);
                        const result = checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);
                        if (result && specificSource !== sourcePropType) {
                            checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);
                        }
                    }
                    if (resultObj.errors) {
                        const reportedDiag = resultObj.errors[resultObj.errors.length - 1];
                        const propertyName = isTypeUsableAsPropertyName(nameType) ? getPropertyNameFromType(nameType) : void 0;
                        const targetProp = propertyName !== void 0 ? getPropertyOfType(target, propertyName) : void 0;
                        let issuedElaboration = false;
                        if (!targetProp) {
                            const indexInfo = getApplicableIndexInfo(target, nameType);
                            if (indexInfo && indexInfo.declaration && !getSourceFileOfNode(indexInfo.declaration).hasNoDefaultLib) {
                                issuedElaboration = true;
                                addRelatedInfo(reportedDiag, createDiagnosticForNode(indexInfo.declaration, Diagnostics.The_expected_type_comes_from_this_index_signature));
                            }
                        }
                        if (!issuedElaboration && (targetProp && length(targetProp.declarations) || target.symbol && length(target.symbol.declarations))) {
                            const targetNode = targetProp && length(targetProp.declarations) ? targetProp.declarations[0] : target.symbol.declarations[0];
                            if (!getSourceFileOfNode(targetNode).hasNoDefaultLib) {
                                addRelatedInfo(reportedDiag, createDiagnosticForNode(targetNode, Diagnostics.The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1, propertyName && !(nameType.flags & 8192) ? unescapeLeadingUnderscores(propertyName) : typeToString(nameType), typeToString(target)));
                            }
                        }
                    }
                }
            }
        }
        return reportedError;
    }
    function elaborateIterableOrArrayLikeTargetElementwise(iterator, source, target, relation, containingMessageChain, errorOutputContainer) {
        const tupleOrArrayLikeTargetParts = filterType(target, isArrayOrTupleLikeType);
        const nonTupleOrArrayLikeTargetParts = filterType(target, t => !isArrayOrTupleLikeType(t));
        const iterationType = nonTupleOrArrayLikeTargetParts !== neverType ? getIterationTypeOfIterable(13, 0, nonTupleOrArrayLikeTargetParts, void 0) : void 0;
        let reportedError = false;
        for (let status = iterator.next(); !status.done; status = iterator.next()) {
            const {
                errorNode: prop,
                innerExpression: next,
                nameType,
                errorMessage
            } = status.value;
            let targetPropType = iterationType;
            const targetIndexedPropType = tupleOrArrayLikeTargetParts !== neverType ? getBestMatchIndexedAccessTypeOrUndefined(source, tupleOrArrayLikeTargetParts, nameType) : void 0;
            if (targetIndexedPropType && !(targetIndexedPropType.flags & 8388608)) {
                targetPropType = iterationType ? getUnionType([iterationType, targetIndexedPropType]) : targetIndexedPropType;
            }
            if (!targetPropType) continue;
            let sourcePropType = getIndexedAccessTypeOrUndefined(source, nameType);
            if (!sourcePropType) continue;
            const propName = getPropertyNameFromIndex(nameType, void 0);
            if (!checkTypeRelatedTo(sourcePropType, targetPropType, relation, void 0)) {
                const elaborated = next && elaborateError(next, sourcePropType, targetPropType, relation, void 0, containingMessageChain, errorOutputContainer);
                reportedError = true;
                if (!elaborated) {
                    const resultObj = errorOutputContainer || {};
                    const specificSource = next ? checkExpressionForMutableLocationWithContextualType(next, sourcePropType) : sourcePropType;
                    if (exactOptionalPropertyTypes && isExactOptionalPropertyMismatch(specificSource, targetPropType)) {
                        const diag2 = createDiagnosticForNode(prop, Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target, typeToString(specificSource), typeToString(targetPropType));
                        diagnostics.add(diag2);
                        resultObj.errors = [diag2];
                    } else {
                        const targetIsOptional = !!(propName && (getPropertyOfType(tupleOrArrayLikeTargetParts, propName) || unknownSymbol).flags & 16777216);
                        const sourceIsOptional = !!(propName && (getPropertyOfType(source, propName) || unknownSymbol).flags & 16777216);
                        targetPropType = removeMissingType(targetPropType, targetIsOptional);
                        sourcePropType = removeMissingType(sourcePropType, targetIsOptional && sourceIsOptional);
                        const result = checkTypeRelatedTo(specificSource, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);
                        if (result && specificSource !== sourcePropType) {
                            checkTypeRelatedTo(sourcePropType, targetPropType, relation, prop, errorMessage, containingMessageChain, resultObj);
                        }
                    }
                }
            }
        }
        return reportedError;
    }
    function* generateJsxAttributes(node) {
        if (!length(node.properties)) return;
        for (const prop of node.properties) {
            if (isJsxSpreadAttribute(prop) || isHyphenatedJsxName(idText(prop.name))) continue;
            yield {
                errorNode: prop.name,
                innerExpression: prop.initializer,
                nameType: getStringLiteralType(idText(prop.name))
            };
        }
    }
    function* generateJsxChildren(node, getInvalidTextDiagnostic) {
        if (!length(node.children)) return;
        let memberOffset = 0;
        for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            const nameType = getNumberLiteralType(i - memberOffset);
            const elem = getElaborationElementForJsxChild(child, nameType, getInvalidTextDiagnostic);
            if (elem) {
                yield elem;
            } else {
                memberOffset++;
            }
        }
    }
    function getElaborationElementForJsxChild(child, nameType, getInvalidTextDiagnostic) {
        switch (child.kind) {
            case 291:
                return {
                    errorNode: child,
                    innerExpression: child.expression,
                    nameType
                };
            case 11:
                if (child.containsOnlyTriviaWhiteSpaces) {
                    break;
                }
                return {
                    errorNode: child,
                    innerExpression: void 0,
                    nameType,
                    errorMessage: getInvalidTextDiagnostic()
                };
            case 281:
            case 282:
            case 285:
                return {
                    errorNode: child,
                    innerExpression: child,
                    nameType
                };
            default:
                return Debug.assertNever(child, "Found invalid jsx child");
        }
    }
    function elaborateJsxComponents(node, source, target, relation, containingMessageChain, errorOutputContainer) {
        let result = elaborateElementwise(generateJsxAttributes(node), source, target, relation, containingMessageChain, errorOutputContainer);
        let invalidTextDiagnostic;
        if (isJsxOpeningElement(node.parent) && isJsxElement(node.parent.parent)) {
            const containingElement = node.parent.parent;
            const childPropName = getJsxElementChildrenPropertyName(getJsxNamespaceAt(node));
            const childrenPropName = childPropName === void 0 ? "children" : unescapeLeadingUnderscores(childPropName);
            const childrenNameType = getStringLiteralType(childrenPropName);
            const childrenTargetType = getIndexedAccessType(target, childrenNameType);
            const validChildren = getSemanticJsxChildren(containingElement.children);
            if (!length(validChildren)) {
                return result;
            }
            const moreThanOneRealChildren = length(validChildren) > 1;
            let arrayLikeTargetParts;
            let nonArrayLikeTargetParts;
            const iterableType = getGlobalIterableType(false);
            if (iterableType !== emptyGenericType) {
                const anyIterable = createIterableType(anyType);
                arrayLikeTargetParts = filterType(childrenTargetType, t => isTypeAssignableTo(t, anyIterable));
                nonArrayLikeTargetParts = filterType(childrenTargetType, t => !isTypeAssignableTo(t, anyIterable));
            } else {
                arrayLikeTargetParts = filterType(childrenTargetType, isArrayOrTupleLikeType);
                nonArrayLikeTargetParts = filterType(childrenTargetType, t => !isArrayOrTupleLikeType(t));
            }
            if (moreThanOneRealChildren) {
                if (arrayLikeTargetParts !== neverType) {
                    const realSource = createTupleType(checkJsxChildren(containingElement, 0));
                    const children = generateJsxChildren(containingElement, getInvalidTextualChildDiagnostic);
                    result = elaborateIterableOrArrayLikeTargetElementwise(children, realSource, arrayLikeTargetParts, relation, containingMessageChain, errorOutputContainer) || result;
                } else if (!isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation)) {
                    result = true;
                    const diag2 = error(containingElement.openingElement.tagName, Diagnostics.This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided, childrenPropName, typeToString(childrenTargetType));
                    if (errorOutputContainer && errorOutputContainer.skipLogging) {
                        (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag2);
                    }
                }
            } else {
                if (nonArrayLikeTargetParts !== neverType) {
                    const child = validChildren[0];
                    const elem = getElaborationElementForJsxChild(child, childrenNameType, getInvalidTextualChildDiagnostic);
                    if (elem) {
                        result = elaborateElementwise(function* () {
                            yield elem;
                        }(), source, target, relation, containingMessageChain, errorOutputContainer) || result;
                    }
                } else if (!isTypeRelatedTo(getIndexedAccessType(source, childrenNameType), childrenTargetType, relation)) {
                    result = true;
                    const diag2 = error(containingElement.openingElement.tagName, Diagnostics.This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided, childrenPropName, typeToString(childrenTargetType));
                    if (errorOutputContainer && errorOutputContainer.skipLogging) {
                        (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag2);
                    }
                }
            }
        }
        return result;
        function getInvalidTextualChildDiagnostic() {
            if (!invalidTextDiagnostic) {
                const tagNameText = getTextOfNode(node.parent.tagName);
                const childPropName = getJsxElementChildrenPropertyName(getJsxNamespaceAt(node));
                const childrenPropName = childPropName === void 0 ? "children" : unescapeLeadingUnderscores(childPropName);
                const childrenTargetType = getIndexedAccessType(target, getStringLiteralType(childrenPropName));
                const diagnostic = Diagnostics._0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2;
                invalidTextDiagnostic = {
                    ...diagnostic,
                    key: "!!ALREADY FORMATTED!!",
                    message: formatMessage(void 0, diagnostic, tagNameText, childrenPropName, typeToString(childrenTargetType))
                };
            }
            return invalidTextDiagnostic;
        }
    }
    function* generateLimitedTupleElements(node, target) {
        const len = length(node.elements);
        if (!len) return;
        for (let i = 0; i < len; i++) {
            if (isTupleLikeType(target) && !getPropertyOfType(target, "" + i)) continue;
            const elem = node.elements[i];
            if (isOmittedExpression(elem)) continue;
            const nameType = getNumberLiteralType(i);
            yield {
                errorNode: elem,
                innerExpression: elem,
                nameType
            };
        }
    }
    function elaborateArrayLiteral(node, source, target, relation, containingMessageChain, errorOutputContainer) {
        if (target.flags & (134348796 | 131072)) return false;
        if (isTupleLikeType(source)) {
            return elaborateElementwise(generateLimitedTupleElements(node, target), source, target, relation, containingMessageChain, errorOutputContainer);
        }
        pushContextualType(node, target, false);
        const tupleizedType = checkArrayLiteral(node, 1, true);
        popContextualType();
        if (isTupleLikeType(tupleizedType)) {
            return elaborateElementwise(generateLimitedTupleElements(node, target), tupleizedType, target, relation, containingMessageChain, errorOutputContainer);
        }
        return false;
    }
    function* generateObjectLiteralElements(node) {
        if (!length(node.properties)) return;
        for (const prop of node.properties) {
            if (isSpreadAssignment(prop)) continue;
            const type = getLiteralTypeFromProperty(getSymbolOfDeclaration(prop), 8576);
            if (!type || type.flags & 131072) {
                continue;
            }
            switch (prop.kind) {
                case 175:
                case 174:
                case 171:
                case 300:
                    yield {
                        errorNode: prop.name,
                        innerExpression: void 0,
                        nameType: type
                    };
                    break;
                case 299:
                    yield {
                        errorNode: prop.name,
                        innerExpression: prop.initializer,
                        nameType: type,
                        errorMessage: isComputedNonLiteralName(prop.name) ? Diagnostics.Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1 : void 0
                    };
                    break;
                default:
                    Debug.assertNever(prop);
            }
        }
    }
    function elaborateObjectLiteral(node, source, target, relation, containingMessageChain, errorOutputContainer) {
        if (target.flags & (134348796 | 131072)) return false;
        return elaborateElementwise(generateObjectLiteralElements(node), source, target, relation, containingMessageChain, errorOutputContainer);
    }
    function checkTypeComparableTo(source, target, errorNode, headMessage, containingMessageChain) {
        return checkTypeRelatedTo(source, target, comparableRelation, errorNode, headMessage, containingMessageChain);
    }
    function isSignatureAssignableTo(source, target, ignoreReturnTypes) {
        return compareSignaturesRelated(source, target, ignoreReturnTypes ? 4 : 0, false, void 0, void 0, compareTypesAssignable, void 0) !== 0;
    }
    function isTopSignature(s) {
        if (!s.typeParameters && (!s.thisParameter || isTypeAny(getTypeOfParameter(s.thisParameter))) && s.parameters.length === 1 && signatureHasRestParameter(s)) {
            const paramType = getTypeOfParameter(s.parameters[0]);
            const restType = isArrayType(paramType) ? getTypeArguments(paramType)[0] : paramType;
            return !!(restType.flags & (1 | 131072) && getReturnTypeOfSignature(s).flags & 3);
        }
        return false;
    }
    function compareSignaturesRelated(source, target, checkMode, reportErrors2, errorReporter, incompatibleErrorReporter, compareTypes, reportUnreliableMarkers) {
        if (source === target) {
            return -1;
        }
        if (!(checkMode & 16 && isTopSignature(source)) && isTopSignature(target)) {
            return -1;
        }
        if (checkMode & 16 && isTopSignature(source) && !isTopSignature(target)) {
            return 0;
        }
        const targetCount = getParameterCount(target);
        const sourceHasMoreParameters = !hasEffectiveRestParameter(target) && (checkMode & 8 ? hasEffectiveRestParameter(source) || getParameterCount(source) > targetCount : getMinArgumentCount(source) > targetCount);
        if (sourceHasMoreParameters) {
            return 0;
        }
        if (source.typeParameters && source.typeParameters !== target.typeParameters) {
            target = getCanonicalSignature(target);
            source = instantiateSignatureInContextOf(source, target, void 0, compareTypes);
        }
        const sourceCount = getParameterCount(source);
        const sourceRestType = getNonArrayRestType(source);
        const targetRestType = getNonArrayRestType(target);
        if (sourceRestType || targetRestType) {
            void instantiateType(sourceRestType || targetRestType, reportUnreliableMarkers);
        }
        const kind = target.declaration ? target.declaration.kind : 0;
        const strictVariance = !(checkMode & 3) && strictFunctionTypes && kind !== 171 && kind !== 170 && kind !== 173;
        let result = -1;
        const sourceThisType = getThisTypeOfSignature(source);
        if (sourceThisType && sourceThisType !== voidType) {
            const targetThisType = getThisTypeOfSignature(target);
            if (targetThisType) {
                const related = !strictVariance && compareTypes(sourceThisType, targetThisType, false) || compareTypes(targetThisType, sourceThisType, reportErrors2);
                if (!related) {
                    if (reportErrors2) {
                        errorReporter(Diagnostics.The_this_types_of_each_signature_are_incompatible);
                    }
                    return 0;
                }
                result &= related;
            }
        }
        const paramCount = sourceRestType || targetRestType ? Math.min(sourceCount, targetCount) : Math.max(sourceCount, targetCount);
        const restIndex = sourceRestType || targetRestType ? paramCount - 1 : -1;
        for (let i = 0; i < paramCount; i++) {
            const sourceType = i === restIndex ? getRestTypeAtPosition(source, i) : tryGetTypeAtPosition(source, i);
            const targetType = i === restIndex ? getRestTypeAtPosition(target, i) : tryGetTypeAtPosition(target, i);
            if (sourceType && targetType) {
                const sourceSig = checkMode & 3 ? void 0 : getSingleCallSignature(getNonNullableType(sourceType));
                const targetSig = checkMode & 3 ? void 0 : getSingleCallSignature(getNonNullableType(targetType));
                const callbacks = sourceSig && targetSig && !getTypePredicateOfSignature(sourceSig) && !getTypePredicateOfSignature(targetSig) && (getTypeFacts(sourceType) & 50331648) === (getTypeFacts(targetType) & 50331648);
                let related = callbacks ? compareSignaturesRelated(targetSig, sourceSig, checkMode & 8 | (strictVariance ? 2 : 1), reportErrors2, errorReporter, incompatibleErrorReporter, compareTypes, reportUnreliableMarkers) : !(checkMode & 3) && !strictVariance && compareTypes(sourceType, targetType, false) || compareTypes(targetType, sourceType, reportErrors2);
                if (related && checkMode & 8 && i >= getMinArgumentCount(source) && i < getMinArgumentCount(target) && compareTypes(sourceType, targetType, false)) {
                    related = 0;
                }
                if (!related) {
                    if (reportErrors2) {
                        errorReporter(Diagnostics.Types_of_parameters_0_and_1_are_incompatible, unescapeLeadingUnderscores(getParameterNameAtPosition(source, i)), unescapeLeadingUnderscores(getParameterNameAtPosition(target, i)));
                    }
                    return 0;
                }
                result &= related;
            }
        }
        if (!(checkMode & 4)) {
            const targetReturnType = isResolvingReturnTypeOfSignature(target) ? anyType : target.declaration && isJSConstructor(target.declaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(target.declaration.symbol)) : getReturnTypeOfSignature(target);
            if (targetReturnType === voidType || targetReturnType === anyType) {
                return result;
            }
            const sourceReturnType = isResolvingReturnTypeOfSignature(source) ? anyType : source.declaration && isJSConstructor(source.declaration) ? getDeclaredTypeOfClassOrInterface(getMergedSymbol(source.declaration.symbol)) : getReturnTypeOfSignature(source);
            const targetTypePredicate = getTypePredicateOfSignature(target);
            if (targetTypePredicate) {
                const sourceTypePredicate = getTypePredicateOfSignature(source);
                if (sourceTypePredicate) {
                    result &= compareTypePredicateRelatedTo(sourceTypePredicate, targetTypePredicate, reportErrors2, errorReporter, compareTypes);
                } else if (isIdentifierTypePredicate(targetTypePredicate)) {
                    if (reportErrors2) {
                        errorReporter(Diagnostics.Signature_0_must_be_a_type_predicate, signatureToString(source));
                    }
                    return 0;
                }
            } else {
                result &= checkMode & 1 && compareTypes(targetReturnType, sourceReturnType, false) || compareTypes(sourceReturnType, targetReturnType, reportErrors2);
                if (!result && reportErrors2 && incompatibleErrorReporter) {
                    incompatibleErrorReporter(sourceReturnType, targetReturnType);
                }
            }
        }
        return result;
    }
    function compareTypePredicateRelatedTo(source, target, reportErrors2, errorReporter, compareTypes) {
        if (source.kind !== target.kind) {
            if (reportErrors2) {
                errorReporter(Diagnostics.A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard);
                errorReporter(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
            }
            return 0;
        }
        if (source.kind === 1 || source.kind === 3) {
            if (source.parameterIndex !== target.parameterIndex) {
                if (reportErrors2) {
                    errorReporter(Diagnostics.Parameter_0_is_not_in_the_same_position_as_parameter_1, source.parameterName, target.parameterName);
                    errorReporter(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
                }
                return 0;
            }
        }
        const related = source.type === target.type ? -1 : source.type && target.type ? compareTypes(source.type, target.type, reportErrors2) : 0;
        if (related === 0 && reportErrors2) {
            errorReporter(Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
        }
        return related;
    }
    function isImplementationCompatibleWithOverload(implementation, overload) {
        const erasedSource = getErasedSignature(implementation);
        const erasedTarget = getErasedSignature(overload);
        const sourceReturnType = getReturnTypeOfSignature(erasedSource);
        const targetReturnType = getReturnTypeOfSignature(erasedTarget);
        if (targetReturnType === voidType || isTypeRelatedTo(targetReturnType, sourceReturnType, assignableRelation) || isTypeRelatedTo(sourceReturnType, targetReturnType, assignableRelation)) {
            return isSignatureAssignableTo(erasedSource, erasedTarget, true);
        }
        return false;
    }
    function isEmptyResolvedType(t) {
        return t !== anyFunctionType && t.properties.length === 0 && t.callSignatures.length === 0 && t.constructSignatures.length === 0 && t.indexInfos.length === 0;
    }
    function isEmptyObjectType(type) {
        return type.flags & 524288 ? !isGenericMappedType(type) && isEmptyResolvedType(resolveStructuredTypeMembers(type)) : type.flags & 67108864 ? true : type.flags & 1048576 ? some(type.types, isEmptyObjectType) : type.flags & 2097152 ? every(type.types, isEmptyObjectType) : false;
    }
    function isEmptyAnonymousObjectType(type) {
        return !!(getObjectFlags(type) & 16 && (type.members && isEmptyResolvedType(type) || type.symbol && type.symbol.flags & 2048 && getMembersOfSymbol(type.symbol).size === 0));
    }
    function isUnknownLikeUnionType(type) {
        if (strictNullChecks && type.flags & 1048576) {
            if (!(type.objectFlags & 33554432)) {
                const types = type.types;
                type.objectFlags |= 33554432 | (types.length >= 3 && types[0].flags & 32768 && types[1].flags & 65536 && some(types, isEmptyAnonymousObjectType) ? 67108864 : 0);
            }
            return !!(type.objectFlags & 67108864);
        }
        return false;
    }
    function containsUndefinedType(type) {
        return !!((type.flags & 1048576 ? type.types[0] : type).flags & 32768);
    }
    function isStringIndexSignatureOnlyType(type) {
        return type.flags & 524288 && !isGenericMappedType(type) && getPropertiesOfType(type).length === 0 && getIndexInfosOfType(type).length === 1 && !!getIndexInfoOfType(type, stringType) || type.flags & 3145728 && every(type.types, isStringIndexSignatureOnlyType) || false;
    }
    function isEnumTypeRelatedTo(source, target, errorReporter) {
        const sourceSymbol = source.flags & 8 ? getParentOfSymbol(source) : source;
        const targetSymbol = target.flags & 8 ? getParentOfSymbol(target) : target;
        if (sourceSymbol === targetSymbol) {
            return true;
        }
        if (sourceSymbol.escapedName !== targetSymbol.escapedName || !(sourceSymbol.flags & 256) || !(targetSymbol.flags & 256)) {
            return false;
        }
        const id = getSymbolId(sourceSymbol) + "," + getSymbolId(targetSymbol);
        const entry = enumRelation.get(id);
        if (entry !== void 0 && !(!(entry & 4) && entry & 2 && errorReporter)) {
            return !!(entry & 1);
        }
        const targetEnumType = getTypeOfSymbol(targetSymbol);
        for (const property of getPropertiesOfType(getTypeOfSymbol(sourceSymbol))) {
            if (property.flags & 8) {
                const targetProperty = getPropertyOfType(targetEnumType, property.escapedName);
                if (!targetProperty || !(targetProperty.flags & 8)) {
                    if (errorReporter) {
                        errorReporter(Diagnostics.Property_0_is_missing_in_type_1, symbolName(property), typeToString(getDeclaredTypeOfSymbol(targetSymbol), void 0, 64));
                        enumRelation.set(id, 2 | 4);
                    } else {
                        enumRelation.set(id, 2);
                    }
                    return false;
                }
            }
        }
        enumRelation.set(id, 1);
        return true;
    }
    function isSimpleTypeRelatedTo(source, target, relation, errorReporter) {
        const s = source.flags;
        const t = target.flags;
        if (t & 1 || s & 131072 || source === wildcardType) return true;
        if (t & 2 && !(relation === strictSubtypeRelation && s & 1)) return true;
        if (t & 131072) return false;
        if (s & 402653316 && t & 4) return true;
        if (s & 128 && s & 1024 && t & 128 && !(t & 1024) && source.value === target.value) return true;
        if (s & 296 && t & 8) return true;
        if (s & 256 && s & 1024 && t & 256 && !(t & 1024) && source.value === target.value) return true;
        if (s & 2112 && t & 64) return true;
        if (s & 528 && t & 16) return true;
        if (s & 12288 && t & 4096) return true;
        if (s & 32 && t & 32 && source.symbol.escapedName === target.symbol.escapedName && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter)) return true;
        if (s & 1024 && t & 1024) {
            if (s & 1048576 && t & 1048576 && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter)) return true;
            if (s & 2944 && t & 2944 && source.value === target.value && isEnumTypeRelatedTo(source.symbol, target.symbol, errorReporter)) return true;
        }
        if (s & 32768 && (!strictNullChecks && !(t & 3145728) || t & (32768 | 16384))) return true;
        if (s & 65536 && (!strictNullChecks && !(t & 3145728) || t & 65536)) return true;
        if (s & 524288 && t & 67108864 && !(relation === strictSubtypeRelation && isEmptyAnonymousObjectType(source) && !(getObjectFlags(source) & 8192))) return true;
        if (relation === assignableRelation || relation === comparableRelation) {
            if (s & 1) return true;
            if (s & 8 && (t & 32 || t & 256 && t & 1024)) return true;
            if (s & 256 && !(s & 1024) && (t & 32 || t & 256 && t & 1024 && source.value === target.value)) return true;
            if (isUnknownLikeUnionType(target)) return true;
        }
        return false;
    }
    function isTypeRelatedTo(source, target, relation) {
        if (isFreshLiteralType(source)) {
            source = source.regularType;
        }
        if (isFreshLiteralType(target)) {
            target = target.regularType;
        }
        if (source === target) {
            return true;
        }
        if (relation !== identityRelation) {
            if (relation === comparableRelation && !(target.flags & 131072) && isSimpleTypeRelatedTo(target, source, relation) || isSimpleTypeRelatedTo(source, target, relation)) {
                return true;
            }
        } else if (!((source.flags | target.flags) & (3145728 | 8388608 | 16777216 | 33554432))) {
            if (source.flags !== target.flags) return false;
            if (source.flags & 67358815) return true;
        }
        if (source.flags & 524288 && target.flags & 524288) {
            const related = relation.get(getRelationKey(source, target, 0, relation, false));
            if (related !== void 0) {
                return !!(related & 1);
            }
        }
        if (source.flags & 469499904 || target.flags & 469499904) {
            return checkTypeRelatedTo(source, target, relation, void 0);
        }
        return false;
    }
    function getNormalizedType(type, writing) {
        while (true) {
            const t = isFreshLiteralType(type) ? type.regularType : getObjectFlags(type) & 4 ? type.node ? createTypeReference(type.target, getTypeArguments(type)) : getSingleBaseForNonAugmentingSubtype(type) || type : type.flags & 3145728 ? getNormalizedUnionOrIntersectionType(type, writing) : type.flags & 33554432 ? writing ? type.baseType : getSubstitutionIntersection(type) : type.flags & 25165824 ? getSimplifiedType(type, writing) : type;
            if (t === type) return t;
            type = t;
        }
    }
    function getNormalizedUnionOrIntersectionType(type, writing) {
        const reduced = getReducedType(type);
        if (reduced !== type) {
            return reduced;
        }
        if (type.flags & 2097152 && some(type.types, isEmptyAnonymousObjectType)) {
            const normalizedTypes = sameMap(type.types, t => getNormalizedType(t, writing));
            if (normalizedTypes !== type.types) {
                return getIntersectionType(normalizedTypes);
            }
        }
        return type;
    }
    function checkTypeRelatedTo(source, target, relation, errorNode, headMessage, containingMessageChain, errorOutputContainer) { }
    function typeCouldHaveTopLevelSingletonTypes(type) {
        if (type.flags & 16) {
            return false;
        }
        if (type.flags & 3145728) {
            return !!forEach(type.types, typeCouldHaveTopLevelSingletonTypes);
        }
        if (type.flags & 465829888) {
            const constraint = getConstraintOfType(type);
            if (constraint && constraint !== type) {
                return typeCouldHaveTopLevelSingletonTypes(constraint);
            }
        }
        return isUnitType(type) || !!(type.flags & 134217728) || !!(type.flags & 268435456);
    }
    function isExactOptionalPropertyMismatch(source, target) {
        return !!source && !!target && maybeTypeOfKind(source, 32768) && !!containsMissingType(target);
    }
    function getExactOptionalProperties(type) {
        return getPropertiesOfType(type).filter(targetProp => containsMissingType(getTypeOfSymbol(targetProp)));
    }
    function getBestMatchingType(source, target, isRelatedTo = compareTypesAssignable) {
        return findMatchingDiscriminantType(source, target, isRelatedTo, true) || findMatchingTypeReferenceOrTypeAliasReference(source, target) || findBestTypeForObjectLiteral(source, target) || findBestTypeForInvokable(source, target) || findMostOverlappyType(source, target);
    }
    function discriminateTypeByDiscriminableItems(target, discriminators, related, defaultValue, skipPartial) {
        const discriminable = target.types.map(_ => void 0);
        for (const [getDiscriminatingType, propertyName] of discriminators) {
            const targetProp = getUnionOrIntersectionProperty(target, propertyName);
            if (skipPartial && targetProp && getCheckFlags(targetProp) & 16) {
                continue;
            }
            let i = 0;
            for (const type of target.types) {
                const targetType = getTypeOfPropertyOfType(type, propertyName);
                if (targetType && related(getDiscriminatingType(), targetType)) {
                    discriminable[i] = discriminable[i] === void 0 ? true : discriminable[i];
                } else {
                    discriminable[i] = false;
                }
                i++;
            }
        }
        const match = discriminable.indexOf(true);
        if (match === -1) {
            return defaultValue;
        }
        let nextMatch = discriminable.indexOf(true, match + 1);
        while (nextMatch !== -1) {
            if (!isTypeIdenticalTo(target.types[match], target.types[nextMatch])) {
                return defaultValue;
            }
            nextMatch = discriminable.indexOf(true, nextMatch + 1);
        }
        return target.types[match];
    }
    function isWeakType(type) {
        if (type.flags & 524288) {
            const resolved = resolveStructuredTypeMembers(type);
            return resolved.callSignatures.length === 0 && resolved.constructSignatures.length === 0 && resolved.indexInfos.length === 0 && resolved.properties.length > 0 && every(resolved.properties, p => !!(p.flags & 16777216));
        }
        if (type.flags & 2097152) {
            return every(type.types, isWeakType);
        }
        return false;
    }
    function getVariances(type) {
        return type === globalArrayType || type === globalReadonlyArrayType || type.objectFlags & 8 ? arrayVariances : getVariancesWorker(type.symbol, type.typeParameters);
    }
    function getAliasVariances(symbol) {
        return getVariancesWorker(symbol, getSymbolLinks(symbol).typeParameters);
    }
    function getVariancesWorker(symbol, typeParameters = emptyArray) {
        var _a2, _b;
        const links = getSymbolLinks(symbol);
        if (!links.variances) {
            (_a2 = tracing) == null ? void 0 : _a2.push(tracing.Phase.CheckTypes, "getVariancesWorker", {
                arity: typeParameters.length,
                id: getTypeId(getDeclaredTypeOfSymbol(symbol))
            });
            links.variances = emptyArray;
            const variances = [];
            for (const tp of typeParameters) {
                const modifiers = getTypeParameterModifiers(tp);
                let variance = modifiers & 65536 ? modifiers & 32768 ? 0 : 1 : modifiers & 32768 ? 2 : void 0;
                if (variance === void 0) {
                    let unmeasurable = false;
                    let unreliable = false;
                    const oldHandler = outofbandVarianceMarkerHandler;
                    outofbandVarianceMarkerHandler = onlyUnreliable => onlyUnreliable ? unreliable = true : unmeasurable = true;
                    const typeWithSuper = createMarkerType(symbol, tp, markerSuperType);
                    const typeWithSub = createMarkerType(symbol, tp, markerSubType);
                    variance = (isTypeAssignableTo(typeWithSub, typeWithSuper) ? 1 : 0) | (isTypeAssignableTo(typeWithSuper, typeWithSub) ? 2 : 0);
                    if (variance === 3 && isTypeAssignableTo(createMarkerType(symbol, tp, markerOtherType), typeWithSuper)) {
                        variance = 4;
                    }
                    outofbandVarianceMarkerHandler = oldHandler;
                    if (unmeasurable || unreliable) {
                        if (unmeasurable) {
                            variance |= 8;
                        }
                        if (unreliable) {
                            variance |= 16;
                        }
                    }
                }
                variances.push(variance);
            }
            links.variances = variances;
            (_b = tracing) == null ? void 0 : _b.pop({
                variances: variances.map(Debug.formatVariance)
            });
        }
        return links.variances;
    }
    function createMarkerType(symbol, source, target) {
        const mapper = makeUnaryTypeMapper(source, target);
        const type = getDeclaredTypeOfSymbol(symbol);
        if (isErrorType(type)) {
            return type;
        }
        const result = symbol.flags & 524288 ? getTypeAliasInstantiation(symbol, instantiateTypes(getSymbolLinks(symbol).typeParameters, mapper)) : createTypeReference(type, instantiateTypes(type.typeParameters, mapper));
        markerTypes.add(getTypeId(result));
        return result;
    }
    function getTypeParameterModifiers(tp) {
        var _a2;
        return reduceLeft((_a2 = tp.symbol) == null ? void 0 : _a2.declarations, (modifiers, d) => modifiers | getEffectiveModifierFlags(d), 0) & (32768 | 65536 | 2048);
    }
    function isUnconstrainedTypeParameter(type) {
        return type.flags & 262144 && !getConstraintOfTypeParameter(type);
    }
    function isNonDeferredTypeReference(type) {
        return !!(getObjectFlags(type) & 4) && !type.node;
    }
    function isTypeReferenceWithGenericArguments(type) {
        return isNonDeferredTypeReference(type) && some(getTypeArguments(type), t => !!(t.flags & 262144) || isTypeReferenceWithGenericArguments(t));
    }
    function getGenericTypeReferenceRelationKey(source, target, postFix, ignoreConstraints) {
        const typeParameters = [];
        let constraintMarker = "";
        const sourceId = getTypeReferenceId(source, 0);
        const targetId = getTypeReferenceId(target, 0);
        return `${constraintMarker}${sourceId},${targetId}${postFix}`;
        function getTypeReferenceId(type, depth = 0) {
            let result = "" + type.target.id;
            for (const t of getTypeArguments(type)) {
                if (t.flags & 262144) {
                    if (ignoreConstraints || isUnconstrainedTypeParameter(t)) {
                        let index = typeParameters.indexOf(t);
                        if (index < 0) {
                            index = typeParameters.length;
                            typeParameters.push(t);
                        }
                        result += "=" + index;
                        continue;
                    }
                    constraintMarker = "*";
                } else if (depth < 4 && isTypeReferenceWithGenericArguments(t)) {
                    result += "<" + getTypeReferenceId(t, depth + 1) + ">";
                    continue;
                }
                result += "-" + t.id;
            }
            return result;
        }
    }
    function getRelationKey(source, target, intersectionState, relation, ignoreConstraints) {
        if (relation === identityRelation && source.id > target.id) {
            const temp = source;
            source = target;
            target = temp;
        }
        const postFix = intersectionState ? ":" + intersectionState : "";
        return isTypeReferenceWithGenericArguments(source) && isTypeReferenceWithGenericArguments(target) ? getGenericTypeReferenceRelationKey(source, target, postFix, ignoreConstraints) : `${source.id},${target.id}${postFix}`;
    }
    function forEachProperty2(prop, callback) {
        if (getCheckFlags(prop) & 6) {
            for (const t of prop.links.containingType.types) {
                const p = getPropertyOfType(t, prop.escapedName);
                const result = p && forEachProperty2(p, callback);
                if (result) {
                    return result;
                }
            }
            return void 0;
        }
        return callback(prop);
    }
    function getDeclaringClass(prop) {
        return prop.parent && prop.parent.flags & 32 ? getDeclaredTypeOfSymbol(getParentOfSymbol(prop)) : void 0;
    }
    function getTypeOfPropertyInBaseClass(property) {
        const classType = getDeclaringClass(property);
        const baseClassType = classType && getBaseTypes(classType)[0];
        return baseClassType && getTypeOfPropertyOfType(baseClassType, property.escapedName);
    }
    function isClassDerivedFromDeclaringClasses(checkClass, prop, writing) {
        return forEachProperty2(prop, p => getDeclarationModifierFlagsFromSymbol(p, writing) & 16 ? !hasBaseType(checkClass, getDeclaringClass(p)) : false) ? void 0 : checkClass;
    }
    function isDeeplyNestedType(type, stack, depth, maxDepth = 3) {
        if (depth >= maxDepth) {
            if (type.flags & 2097152) {
                return some(type.types, t => isDeeplyNestedType(t, stack, depth, maxDepth));
            }
            const identity2 = getRecursionIdentity(type);
            let count = 0;
            let lastTypeId = 0;
            for (let i = 0; i < depth; i++) {
                const t = stack[i];
                if (t.flags & 2097152 ? some(t.types, u => getRecursionIdentity(u) === identity2) : getRecursionIdentity(t) === identity2) {
                    if (t.id >= lastTypeId) {
                        count++;
                        if (count >= maxDepth) {
                            return true;
                        }
                    }
                    lastTypeId = t.id;
                }
            }
        }
        return false;
    }
    function getRecursionIdentity(type) {
        if (type.flags & 524288 && !isObjectOrArrayLiteralType(type)) {
            if (getObjectFlags(type) && 4 && type.node) {
                return type.node;
            }
            if (type.symbol && !(getObjectFlags(type) & 16 && type.symbol.flags & 32)) {
                return type.symbol;
            }
            if (isTupleType(type)) {
                return type.target;
            }
        }
        if (type.flags & 262144) {
            return type.symbol;
        }
        if (type.flags & 8388608) {
            do {
                type = type.objectType;
            } while (type.flags & 8388608);
            return type;
        }
        if (type.flags & 16777216) {
            return type.root;
        }
        return type;
    }
    function isPropertyIdenticalTo(sourceProp, targetProp) {
        return compareProperties2(sourceProp, targetProp, compareTypesIdentical) !== 0;
    }
    function compareProperties2(sourceProp, targetProp, compareTypes) {
        if (sourceProp === targetProp) {
            return -1;
        }
        const sourcePropAccessibility = getDeclarationModifierFlagsFromSymbol(sourceProp) & 24;
        const targetPropAccessibility = getDeclarationModifierFlagsFromSymbol(targetProp) & 24;
        if (sourcePropAccessibility !== targetPropAccessibility) {
            return 0;
        }
        if (sourcePropAccessibility) {
            if (getTargetSymbol(sourceProp) !== getTargetSymbol(targetProp)) {
                return 0;
            }
        } else {
            if ((sourceProp.flags & 16777216) !== (targetProp.flags & 16777216)) {
                return 0;
            }
        }
        if (isReadonlySymbol(sourceProp) !== isReadonlySymbol(targetProp)) {
            return 0;
        }
        return compareTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp));
    }
    function isMatchingSignature(source, target, partialMatch) {
        const sourceParameterCount = getParameterCount(source);
        const targetParameterCount = getParameterCount(target);
        const sourceMinArgumentCount = getMinArgumentCount(source);
        const targetMinArgumentCount = getMinArgumentCount(target);
        const sourceHasRestParameter = hasEffectiveRestParameter(source);
        const targetHasRestParameter = hasEffectiveRestParameter(target);
        if (sourceParameterCount === targetParameterCount && sourceMinArgumentCount === targetMinArgumentCount && sourceHasRestParameter === targetHasRestParameter) {
            return true;
        }
        if (partialMatch && sourceMinArgumentCount <= targetMinArgumentCount) {
            return true;
        }
        return false;
    }
    function compareSignaturesIdentical(source, target, partialMatch, ignoreThisTypes, ignoreReturnTypes, compareTypes) {
        if (source === target) {
            return -1;
        }
        if (!isMatchingSignature(source, target, partialMatch)) {
            return 0;
        }
        if (length(source.typeParameters) !== length(target.typeParameters)) {
            return 0;
        }
        if (target.typeParameters) {
            const mapper = createTypeMapper(source.typeParameters, target.typeParameters);
            for (let i = 0; i < target.typeParameters.length; i++) {
                const s = source.typeParameters[i];
                const t = target.typeParameters[i];
                if (!(s === t || compareTypes(instantiateType(getConstraintFromTypeParameter(s), mapper) || unknownType, getConstraintFromTypeParameter(t) || unknownType) && compareTypes(instantiateType(getDefaultFromTypeParameter(s), mapper) || unknownType, getDefaultFromTypeParameter(t) || unknownType))) {
                    return 0;
                }
            }
            source = instantiateSignature(source, mapper, true);
        }
        let result = -1;
        if (!ignoreThisTypes) {
            const sourceThisType = getThisTypeOfSignature(source);
            if (sourceThisType) {
                const targetThisType = getThisTypeOfSignature(target);
                if (targetThisType) {
                    const related = compareTypes(sourceThisType, targetThisType);
                    if (!related) {
                        return 0;
                    }
                    result &= related;
                }
            }
        }
        const targetLen = getParameterCount(target);
        for (let i = 0; i < targetLen; i++) {
            const s = getTypeAtPosition(source, i);
            const t = getTypeAtPosition(target, i);
            const related = compareTypes(t, s);
            if (!related) {
                return 0;
            }
            result &= related;
        }
        if (!ignoreReturnTypes) {
            const sourceTypePredicate = getTypePredicateOfSignature(source);
            const targetTypePredicate = getTypePredicateOfSignature(target);
            result &= sourceTypePredicate || targetTypePredicate ? compareTypePredicatesIdentical(sourceTypePredicate, targetTypePredicate, compareTypes) : compareTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target));
        }
        return result;
    }
    function compareTypePredicatesIdentical(source, target, compareTypes) {
        return !(source && target && typePredicateKindsMatch(source, target)) ? 0 : source.type === target.type ? -1 : source.type && target.type ? compareTypes(source.type, target.type) : 0;
    }
    function literalTypesWithSameBaseType(types) {
        let commonBaseType;
        for (const t of types) {
            if (!(t.flags & 131072)) {
                const baseType = getBaseTypeOfLiteralType(t);
                commonBaseType != null ? commonBaseType : commonBaseType = baseType;
                if (baseType === t || baseType !== commonBaseType) {
                    return false;
                }
            }
        }
        return true;
    }
    function getCombinedTypeFlags(types) {
        return reduceLeft(types, (flags, t) => flags | (t.flags & 1048576 ? getCombinedTypeFlags(t.types) : t.flags), 0);
    }
    function getCommonSupertype(types) {
        if (types.length === 1) {
            return types[0];
        }
        const primaryTypes = strictNullChecks ? sameMap(types, t => filterType(t, u => !(u.flags & 98304))) : types;
        const superTypeOrUnion = literalTypesWithSameBaseType(primaryTypes) ? getUnionType(primaryTypes) : reduceLeft(primaryTypes, (s, t) => isTypeSubtypeOf(s, t) ? t : s);
        return primaryTypes === types ? superTypeOrUnion : getNullableType(superTypeOrUnion, getCombinedTypeFlags(types) & 98304);
    }
    function getCommonSubtype(types) {
        return reduceLeft(types, (s, t) => isTypeSubtypeOf(t, s) ? t : s);
    }
    function isArrayType(type) {
        return !!(getObjectFlags(type) & 4) && (type.target === globalArrayType || type.target === globalReadonlyArrayType);
    }
    function isReadonlyArrayType(type) {
        return !!(getObjectFlags(type) & 4) && type.target === globalReadonlyArrayType;
    }
    function isArrayOrTupleType(type) {
        return isArrayType(type) || isTupleType(type);
    }
    function isMutableArrayOrTuple(type) {
        return isArrayType(type) && !isReadonlyArrayType(type) || isTupleType(type) && !type.target.readonly;
    }
    function getElementTypeOfArrayType(type) {
        return isArrayType(type) ? getTypeArguments(type)[0] : void 0;
    }
    function isArrayLikeType(type) {
        return isArrayType(type) || !(type.flags & 98304) && isTypeAssignableTo(type, anyReadonlyArrayType);
    }
    function getSingleBaseForNonAugmentingSubtype(type) {
        if (!(getObjectFlags(type) & 4) || !(getObjectFlags(type.target) & 3)) {
            return void 0;
        }
        if (getObjectFlags(type) & 33554432) {
            return getObjectFlags(type) & 67108864 ? type.cachedEquivalentBaseType : void 0;
        }
        type.objectFlags |= 33554432;
        const target = type.target;
        if (getObjectFlags(target) & 1) {
            const baseTypeNode = getBaseTypeNodeOfClass(target);
            if (baseTypeNode && baseTypeNode.expression.kind !== 79 && baseTypeNode.expression.kind !== 208) {
                return void 0;
            }
        }
        const bases = getBaseTypes(target);
        if (bases.length !== 1) {
            return void 0;
        }
        if (getMembersOfSymbol(type.symbol).size) {
            return void 0;
        }
        let instantiatedBase = !length(target.typeParameters) ? bases[0] : instantiateType(bases[0], createTypeMapper(target.typeParameters, getTypeArguments(type).slice(0, target.typeParameters.length)));
        if (length(getTypeArguments(type)) > length(target.typeParameters)) {
            instantiatedBase = getTypeWithThisArgument(instantiatedBase, last(getTypeArguments(type)));
        }
        type.objectFlags |= 67108864;
        return type.cachedEquivalentBaseType = instantiatedBase;
    }
    function isEmptyLiteralType(type) {
        return strictNullChecks ? type === implicitNeverType : type === undefinedWideningType;
    }
    function isEmptyArrayLiteralType(type) {
        const elementType = getElementTypeOfArrayType(type);
        return !!elementType && isEmptyLiteralType(elementType);
    }
    function isTupleLikeType(type) {
        return isTupleType(type) || !!getPropertyOfType(type, "0");
    }
    function isArrayOrTupleLikeType(type) {
        return isArrayLikeType(type) || isTupleLikeType(type);
    }
    function getTupleElementType(type, index) {
        const propType = getTypeOfPropertyOfType(type, "" + index);
        if (propType) {
            return propType;
        }
        if (everyType(type, isTupleType)) {
            return mapType(type, t => {
                const tupleType = t;
                const restType = getRestTypeOfTupleType(tupleType);
                if (!restType) {
                    return undefinedType;
                }
                if (compilerOptions.noUncheckedIndexedAccess && index >= tupleType.target.fixedLength + getEndElementCount(tupleType.target, 3)) {
                    return getUnionType([restType, undefinedType]);
                }
                return restType;
            });
        }
        return void 0;
    }
    function isNeitherUnitTypeNorNever(type) {
        return !(type.flags & (109472 | 131072));
    }
    function isUnitType(type) {
        return !!(type.flags & 109472);
    }
    function isUnitLikeType(type) {
        const t = getBaseConstraintOrType(type);
        return t.flags & 2097152 ? some(t.types, isUnitType) : isUnitType(t);
    }
    function extractUnitType(type) {
        return type.flags & 2097152 ? find(type.types, isUnitType) || type : type;
    }
    function isLiteralType(type) {
        return type.flags & 16 ? true : type.flags & 1048576 ? type.flags & 1024 ? true : every(type.types, isUnitType) : isUnitType(type);
    }
    function getBaseTypeOfLiteralType(type) {
        return type.flags & 1056 ? getBaseTypeOfEnumLikeType(type) : type.flags & (128 | 134217728 | 268435456) ? stringType : type.flags & 256 ? numberType : type.flags & 2048 ? bigintType : type.flags & 512 ? booleanType : type.flags & 1048576 ? getBaseTypeOfLiteralTypeUnion(type) : type;
    }
    function getBaseTypeOfLiteralTypeUnion(type) {
        var _a2;
        const key = `B${getTypeId(type)}`;
        return (_a2 = getCachedType(key)) != null ? _a2 : setCachedType(key, mapType(type, getBaseTypeOfLiteralType));
    }
    function getBaseTypeOfLiteralTypeForComparison(type) {
        return type.flags & (128 | 134217728 | 268435456) ? stringType : type.flags & (256 | 32) ? numberType : type.flags & 2048 ? bigintType : type.flags & 512 ? booleanType : type.flags & 1048576 ? mapType(type, getBaseTypeOfLiteralTypeForComparison) : type;
    }
    function getWidenedLiteralType(type) {
        return type.flags & 1056 && isFreshLiteralType(type) ? getBaseTypeOfEnumLikeType(type) : type.flags & 128 && isFreshLiteralType(type) ? stringType : type.flags & 256 && isFreshLiteralType(type) ? numberType : type.flags & 2048 && isFreshLiteralType(type) ? bigintType : type.flags & 512 && isFreshLiteralType(type) ? booleanType : type.flags & 1048576 ? mapType(type, getWidenedLiteralType) : type;
    }
    function getWidenedUniqueESSymbolType(type) {
        return type.flags & 8192 ? esSymbolType : type.flags & 1048576 ? mapType(type, getWidenedUniqueESSymbolType) : type;
    }
    function getWidenedLiteralLikeTypeForContextualType(type, contextualType) {
        if (!isLiteralOfContextualType(type, contextualType)) {
            type = getWidenedUniqueESSymbolType(getWidenedLiteralType(type));
        }
        return getRegularTypeOfLiteralType(type);
    }
    function getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(type, contextualSignatureReturnType, isAsync) {
        if (type && isUnitType(type)) {
            const contextualType = !contextualSignatureReturnType ? void 0 : isAsync ? getPromisedTypeOfPromise(contextualSignatureReturnType) : contextualSignatureReturnType;
            type = getWidenedLiteralLikeTypeForContextualType(type, contextualType);
        }
        return type;
    }
    function getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(type, contextualSignatureReturnType, kind, isAsyncGenerator) {
        if (type && isUnitType(type)) {
            const contextualType = !contextualSignatureReturnType ? void 0 : getIterationTypeOfGeneratorFunctionReturnType(kind, contextualSignatureReturnType, isAsyncGenerator);
            type = getWidenedLiteralLikeTypeForContextualType(type, contextualType);
        }
        return type;
    }
    function isTupleType(type) {
        return !!(getObjectFlags(type) & 4 && type.target.objectFlags & 8);
    }
    function isGenericTupleType(type) {
        return isTupleType(type) && !!(type.target.combinedFlags & 8);
    }
    function getRestTypeOfTupleType(type) {
        return getElementTypeOfSliceOfTupleType(type, type.target.fixedLength);
    }
    function getRestArrayTypeOfTupleType(type) {
        const restType = getRestTypeOfTupleType(type);
        return restType && createArrayType(restType);
    }
    function getElementTypeOfSliceOfTupleType(type, index, endSkipCount = 0, writing = false, noReductions = false) {
        const length2 = getTypeReferenceArity(type) - endSkipCount;
        if (index < length2) {
            const typeArguments = getTypeArguments(type);
            const elementTypes = [];
            for (let i = index; i < length2; i++) {
                const t = typeArguments[i];
                elementTypes.push(type.target.elementFlags[i] & 8 ? getIndexedAccessType(t, numberType) : t);
            }
            return writing ? getIntersectionType(elementTypes) : getUnionType(elementTypes, noReductions ? 0 : 1);
        }
        return void 0;
    }
    function isTupleTypeStructureMatching(t1, t2) {
        return getTypeReferenceArity(t1) === getTypeReferenceArity(t2) && every(t1.target.elementFlags, (f, i) => (f & 12) === (t2.target.elementFlags[i] & 12));
    }
    function isZeroBigInt({
        value
    }) {
        return value.base10Value === "0";
    }
    function removeDefinitelyFalsyTypes(type) {
        return filterType(type, t => !!(getTypeFacts(t) & 4194304));
    }
    function extractDefinitelyFalsyTypes(type) {
        return mapType(type, getDefinitelyFalsyPartOfType);
    }
    function getDefinitelyFalsyPartOfType(type) {
        return type.flags & 4 ? emptyStringType : type.flags & 8 ? zeroType : type.flags & 64 ? zeroBigIntType : type === regularFalseType || type === falseType || type.flags & (16384 | 32768 | 65536 | 3) || type.flags & 128 && type.value === "" || type.flags & 256 && type.value === 0 || type.flags & 2048 && isZeroBigInt(type) ? type : neverType;
    }
    function getNullableType(type, flags) {
        const missing = flags & ~type.flags & (32768 | 65536);
        return missing === 0 ? type : missing === 32768 ? getUnionType([type, undefinedType]) : missing === 65536 ? getUnionType([type, nullType]) : getUnionType([type, undefinedType, nullType]);
    }
    function getOptionalType(type, isProperty = false) {
        Debug.assert(strictNullChecks);
        const missingOrUndefined = isProperty ? undefinedOrMissingType : undefinedType;
        return type === missingOrUndefined || type.flags & 1048576 && type.types[0] === missingOrUndefined ? type : getUnionType([type, missingOrUndefined]);
    }
    function getGlobalNonNullableTypeInstantiation(type) {
        if (!deferredGlobalNonNullableTypeAlias) {
            deferredGlobalNonNullableTypeAlias = getGlobalSymbol("NonNullable", 524288, void 0) || unknownSymbol;
        }
        return deferredGlobalNonNullableTypeAlias !== unknownSymbol ? getTypeAliasInstantiation(deferredGlobalNonNullableTypeAlias, [type]) : getIntersectionType([type, emptyObjectType]);
    }
    function getNonNullableType(type) {
        return strictNullChecks ? getAdjustedTypeWithFacts(type, 2097152) : type;
    }
    function addOptionalTypeMarker(type) {
        return strictNullChecks ? getUnionType([type, optionalType]) : type;
    }
    function removeOptionalTypeMarker(type) {
        return strictNullChecks ? removeType(type, optionalType) : type;
    }
    function propagateOptionalTypeMarker(type, node, wasOptional) {
        return wasOptional ? isOutermostOptionalChain(node) ? getOptionalType(type) : addOptionalTypeMarker(type) : type;
    }
    function getOptionalExpressionType(exprType, expression) {
        return isExpressionOfOptionalChainRoot(expression) ? getNonNullableType(exprType) : isOptionalChain(expression) ? removeOptionalTypeMarker(exprType) : exprType;
    }
    function removeMissingType(type, isOptional) {
        return exactOptionalPropertyTypes && isOptional ? removeType(type, missingType) : type;
    }
    function containsMissingType(type) {
        return type === missingType || !!(type.flags & 1048576) && type.types[0] === missingType;
    }
    function removeMissingOrUndefinedType(type) {
        return exactOptionalPropertyTypes ? removeType(type, missingType) : getTypeWithFacts(type, 524288);
    }
    function isCoercibleUnderDoubleEquals(source, target) {
        return (source.flags & (8 | 4 | 512)) !== 0 && (target.flags & (8 | 4 | 16)) !== 0;
    }
    function isObjectTypeWithInferableIndex(type) {
        const objectFlags = getObjectFlags(type);
        return type.flags & 2097152 ? every(type.types, isObjectTypeWithInferableIndex) : !!(type.symbol && (type.symbol.flags & (4096 | 2048 | 384 | 512)) !== 0 && !(type.symbol.flags & 32) && !typeHasCallOrConstructSignatures(type)) || !!(objectFlags & 4194304) || !!(objectFlags & 1024 && isObjectTypeWithInferableIndex(type.source));
    }
    function createSymbolWithType(source, type) {
        const symbol = createSymbol(source.flags, source.escapedName, getCheckFlags(source) & 8);
        symbol.declarations = source.declarations;
        symbol.parent = source.parent;
        symbol.links.type = type;
        symbol.links.target = source;
        if (source.valueDeclaration) {
            symbol.valueDeclaration = source.valueDeclaration;
        }
        const nameType = getSymbolLinks(source).nameType;
        if (nameType) {
            symbol.links.nameType = nameType;
        }
        return symbol;
    }
    function transformTypeOfMembers(type, f) {
        const members = createSymbolTable();
        for (const property of getPropertiesOfObjectType(type)) {
            const original = getTypeOfSymbol(property);
            const updated = f(original);
            members.set(property.escapedName, updated === original ? property : createSymbolWithType(property, updated));
        }
        return members;
    }
    function getRegularTypeOfObjectLiteral(type) {
        if (!(isObjectLiteralType2(type) && getObjectFlags(type) & 8192)) {
            return type;
        }
        const regularType = type.regularType;
        if (regularType) {
            return regularType;
        }
        const resolved = type;
        const members = transformTypeOfMembers(type, getRegularTypeOfObjectLiteral);
        const regularNew = createAnonymousType(resolved.symbol, members, resolved.callSignatures, resolved.constructSignatures, resolved.indexInfos);
        regularNew.flags = resolved.flags;
        regularNew.objectFlags |= resolved.objectFlags & ~8192;
        type.regularType = regularNew;
        return regularNew;
    }
    function createWideningContext(parent2, propertyName, siblings) {
        return {
            parent: parent2,
            propertyName,
            siblings,
            resolvedProperties: void 0
        };
    }
    function getSiblingsOfContext(context) {
        if (!context.siblings) {
            const siblings = [];
            for (const type of getSiblingsOfContext(context.parent)) {
                if (isObjectLiteralType2(type)) {
                    const prop = getPropertyOfObjectType(type, context.propertyName);
                    if (prop) {
                        forEachType(getTypeOfSymbol(prop), t => {
                            siblings.push(t);
                        });
                    }
                }
            }
            context.siblings = siblings;
        }
        return context.siblings;
    }
    function getPropertiesOfContext(context) {
        if (!context.resolvedProperties) {
            const names = /* @__PURE__ */new Map();
            for (const t of getSiblingsOfContext(context)) {
                if (isObjectLiteralType2(t) && !(getObjectFlags(t) & 2097152)) {
                    for (const prop of getPropertiesOfType(t)) {
                        names.set(prop.escapedName, prop);
                    }
                }
            }
            context.resolvedProperties = arrayFrom(names.values());
        }
        return context.resolvedProperties;
    }
    function getWidenedProperty(prop, context) {
        if (!(prop.flags & 4)) {
            return prop;
        }
        const original = getTypeOfSymbol(prop);
        const propContext = context && createWideningContext(context, prop.escapedName, void 0);
        const widened = getWidenedTypeWithContext(original, propContext);
        return widened === original ? prop : createSymbolWithType(prop, widened);
    }
    function getUndefinedProperty(prop) {
        const cached = undefinedProperties.get(prop.escapedName);
        if (cached) {
            return cached;
        }
        const result = createSymbolWithType(prop, undefinedOrMissingType);
        result.flags |= 16777216;
        undefinedProperties.set(prop.escapedName, result);
        return result;
    }
    function getWidenedTypeOfObjectLiteral(type, context) {
        const members = createSymbolTable();
        for (const prop of getPropertiesOfObjectType(type)) {
            members.set(prop.escapedName, getWidenedProperty(prop, context));
        }
        if (context) {
            for (const prop of getPropertiesOfContext(context)) {
                if (!members.has(prop.escapedName)) {
                    members.set(prop.escapedName, getUndefinedProperty(prop));
                }
            }
        }
        const result = createAnonymousType(type.symbol, members, emptyArray, emptyArray, sameMap(getIndexInfosOfType(type), info => createIndexInfo(info.keyType, getWidenedType(info.type), info.isReadonly)));
        result.objectFlags |= getObjectFlags(type) & (4096 | 262144);
        return result;
    }
    function getWidenedType(type) {
        return getWidenedTypeWithContext(type, void 0);
    }
    function getWidenedTypeWithContext(type, context) {
        if (getObjectFlags(type) & 196608) {
            if (context === void 0 && type.widened) {
                return type.widened;
            }
            let result;
            if (type.flags & (1 | 98304)) {
                result = anyType;
            } else if (isObjectLiteralType2(type)) {
                result = getWidenedTypeOfObjectLiteral(type, context);
            } else if (type.flags & 1048576) {
                const unionContext = context || createWideningContext(void 0, void 0, type.types);
                const widenedTypes = sameMap(type.types, t => t.flags & 98304 ? t : getWidenedTypeWithContext(t, unionContext));
                result = getUnionType(widenedTypes, some(widenedTypes, isEmptyObjectType) ? 2 : 1);
            } else if (type.flags & 2097152) {
                result = getIntersectionType(sameMap(type.types, getWidenedType));
            } else if (isArrayOrTupleType(type)) {
                result = createTypeReference(type.target, sameMap(getTypeArguments(type), getWidenedType));
            }
            if (result && context === void 0) {
                type.widened = result;
            }
            return result || type;
        }
        return type;
    }
    function reportWideningErrorsInType(type) {
        let errorReported = false;
        if (getObjectFlags(type) & 65536) {
            if (type.flags & 1048576) {
                if (some(type.types, isEmptyObjectType)) {
                    errorReported = true;
                } else {
                    for (const t of type.types) {
                        if (reportWideningErrorsInType(t)) {
                            errorReported = true;
                        }
                    }
                }
            }
            if (isArrayOrTupleType(type)) {
                for (const t of getTypeArguments(type)) {
                    if (reportWideningErrorsInType(t)) {
                        errorReported = true;
                    }
                }
            }
            if (isObjectLiteralType2(type)) {
                for (const p of getPropertiesOfObjectType(type)) {
                    const t = getTypeOfSymbol(p);
                    if (getObjectFlags(t) & 65536) {
                        if (!reportWideningErrorsInType(t)) {
                            error(p.valueDeclaration, Diagnostics.Object_literal_s_property_0_implicitly_has_an_1_type, symbolToString(p), typeToString(getWidenedType(t)));
                        }
                        errorReported = true;
                    }
                }
            }
        }
        return errorReported;
    }
    function reportImplicitAny(declaration, type, wideningKind) {
        const typeAsString = typeToString(getWidenedType(type));
        if (isInJSFile(declaration) && !isCheckJsEnabledForFile(getSourceFileOfNode(declaration), compilerOptions)) {
            return;
        }
        let diagnostic;
        switch (declaration.kind) {
            case 223:
            case 169:
            case 168:
                diagnostic = noImplicitAny ? Diagnostics.Member_0_implicitly_has_an_1_type : Diagnostics.Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;
                break;
            case 166:
                const param = declaration;
                if (isIdentifier(param.name)) {
                    const originalKeywordKind = identifierToKeywordKind(param.name);
                    if ((isCallSignatureDeclaration(param.parent) || isMethodSignature(param.parent) || isFunctionTypeNode(param.parent)) && param.parent.parameters.indexOf(param) > -1 && (resolveName(param, param.name.escapedText, 788968, void 0, param.name.escapedText, true) || originalKeywordKind && isTypeNodeKind(originalKeywordKind))) {
                        const newName = "arg" + param.parent.parameters.indexOf(param);
                        const typeName = declarationNameToString(param.name) + (param.dotDotDotToken ? "[]" : "");
                        errorOrSuggestion(noImplicitAny, declaration, Diagnostics.Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1, newName, typeName);
                        return;
                    }
                }
                diagnostic = declaration.dotDotDotToken ? noImplicitAny ? Diagnostics.Rest_parameter_0_implicitly_has_an_any_type : Diagnostics.Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage : noImplicitAny ? Diagnostics.Parameter_0_implicitly_has_an_1_type : Diagnostics.Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;
                break;
            case 205:
                diagnostic = Diagnostics.Binding_element_0_implicitly_has_an_1_type;
                if (!noImplicitAny) {
                    return;
                }
                break;
            case 320:
                error(declaration, Diagnostics.Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString);
                return;
            case 326:
                if (noImplicitAny && isJSDocOverloadTag(declaration.parent)) {
                    error(declaration.parent.tagName, Diagnostics.This_overload_implicitly_returns_the_type_0_because_it_lacks_a_return_type_annotation, typeAsString);
                }
                return;
            case 259:
            case 171:
            case 170:
            case 174:
            case 175:
            case 215:
            case 216:
                if (noImplicitAny && !declaration.name) {
                    if (wideningKind === 3) {
                        error(declaration, Diagnostics.Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type_annotation, typeAsString);
                    } else {
                        error(declaration, Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString);
                    }
                    return;
                }
                diagnostic = !noImplicitAny ? Diagnostics._0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage : wideningKind === 3 ? Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type : Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type;
                break;
            case 197:
                if (noImplicitAny) {
                    error(declaration, Diagnostics.Mapped_object_type_implicitly_has_an_any_template_type);
                }
                return;
            default:
                diagnostic = noImplicitAny ? Diagnostics.Variable_0_implicitly_has_an_1_type : Diagnostics.Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage;
        }
        errorOrSuggestion(noImplicitAny, declaration, diagnostic, declarationNameToString(getNameOfDeclaration(declaration)), typeAsString);
    }
    function reportErrorsFromWidening(declaration, type, wideningKind) {
        addLazyDiagnostic(() => {
            if (noImplicitAny && getObjectFlags(type) & 65536 && (!wideningKind || !getContextualSignatureForFunctionLikeDeclaration(declaration))) {
                if (!reportWideningErrorsInType(type)) {
                    reportImplicitAny(declaration, type, wideningKind);
                }
            }
        });
    }
    function applyToParameterTypes(source, target, callback) {
        const sourceCount = getParameterCount(source);
        const targetCount = getParameterCount(target);
        const sourceRestType = getEffectiveRestType(source);
        const targetRestType = getEffectiveRestType(target);
        const targetNonRestCount = targetRestType ? targetCount - 1 : targetCount;
        const paramCount = sourceRestType ? targetNonRestCount : Math.min(sourceCount, targetNonRestCount);
        const sourceThisType = getThisTypeOfSignature(source);
        if (sourceThisType) {
            const targetThisType = getThisTypeOfSignature(target);
            if (targetThisType) {
                callback(sourceThisType, targetThisType);
            }
        }
        for (let i = 0; i < paramCount; i++) {
            callback(getTypeAtPosition(source, i), getTypeAtPosition(target, i));
        }
        if (targetRestType) {
            callback(getRestTypeAtPosition(source, paramCount), targetRestType);
        }
    }
    function applyToReturnTypes(source, target, callback) {
        const sourceTypePredicate = getTypePredicateOfSignature(source);
        const targetTypePredicate = getTypePredicateOfSignature(target);
        if (sourceTypePredicate && targetTypePredicate && typePredicateKindsMatch(sourceTypePredicate, targetTypePredicate) && sourceTypePredicate.type && targetTypePredicate.type) {
            callback(sourceTypePredicate.type, targetTypePredicate.type);
        } else {
            callback(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target));
        }
    }
    function createInferenceContext(typeParameters, signature, flags, compareTypes) {
        return createInferenceContextWorker(typeParameters.map(createInferenceInfo), signature, flags, compareTypes || compareTypesAssignable);
    }
    function cloneInferenceContext(context, extraFlags = 0) {
        return context && createInferenceContextWorker(map(context.inferences, cloneInferenceInfo), context.signature, context.flags | extraFlags, context.compareTypes);
    }
    function createInferenceContextWorker(inferences, signature, flags, compareTypes) {
        const context = {
            inferences,
            signature,
            flags,
            compareTypes,
            mapper: reportUnmeasurableMapper,
            nonFixingMapper: reportUnmeasurableMapper
        };
        context.mapper = makeFixingMapperForContext(context);
        context.nonFixingMapper = makeNonFixingMapperForContext(context);
        return context;
    }
    function makeFixingMapperForContext(context) {
        return makeDeferredTypeMapper(map(context.inferences, i => i.typeParameter), map(context.inferences, (inference, i) => () => {
            if (!inference.isFixed) {
                inferFromIntraExpressionSites(context);
                clearCachedInferences(context.inferences);
                inference.isFixed = true;
            }
            return getInferredType(context, i);
        }));
    }
    function makeNonFixingMapperForContext(context) {
        return makeDeferredTypeMapper(map(context.inferences, i => i.typeParameter), map(context.inferences, (_, i) => () => {
            return getInferredType(context, i);
        }));
    }
    function clearCachedInferences(inferences) {
        for (const inference of inferences) {
            if (!inference.isFixed) {
                inference.inferredType = void 0;
            }
        }
    }
    function addIntraExpressionInferenceSite(context, node, type) {
        var _a2;
        ((_a2 = context.intraExpressionInferenceSites) != null ? _a2 : context.intraExpressionInferenceSites = []).push({
            node,
            type
        });
    }
    function inferFromIntraExpressionSites(context) {
        if (context.intraExpressionInferenceSites) {
            for (const {
                node,
                type
            } of context.intraExpressionInferenceSites) {
                const contextualType = node.kind === 171 ? getContextualTypeForObjectLiteralMethod(node, 2) : getContextualType2(node, 2);
                if (contextualType) {
                    inferTypes(context.inferences, type, contextualType);
                }
            }
            context.intraExpressionInferenceSites = void 0;
        }
    }
    function createInferenceInfo(typeParameter) {
        return {
            typeParameter,
            candidates: void 0,
            contraCandidates: void 0,
            inferredType: void 0,
            priority: void 0,
            topLevel: true,
            isFixed: false,
            impliedArity: void 0
        };
    }
    function cloneInferenceInfo(inference) {
        return {
            typeParameter: inference.typeParameter,
            candidates: inference.candidates && inference.candidates.slice(),
            contraCandidates: inference.contraCandidates && inference.contraCandidates.slice(),
            inferredType: inference.inferredType,
            priority: inference.priority,
            topLevel: inference.topLevel,
            isFixed: inference.isFixed,
            impliedArity: inference.impliedArity
        };
    }
    function cloneInferredPartOfContext(context) {
        const inferences = filter(context.inferences, hasInferenceCandidates);
        return inferences.length ? createInferenceContextWorker(map(inferences, cloneInferenceInfo), context.signature, context.flags, context.compareTypes) : void 0;
    }
    function getMapperFromContext(context) {
        return context && context.mapper;
    }
    function couldContainTypeVariables(type) {
        const objectFlags = getObjectFlags(type);
        if (objectFlags & 524288) {
            return !!(objectFlags & 1048576);
        }
        const result = !!(type.flags & 465829888 || type.flags & 524288 && !isNonGenericTopLevelType(type) && (objectFlags & 4 && (type.node || forEach(getTypeArguments(type), couldContainTypeVariables)) || objectFlags & 16 && type.symbol && type.symbol.flags & (16 | 8192 | 32 | 2048 | 4096) && type.symbol.declarations || objectFlags & (32 | 1024 | 4194304 | 8388608)) || type.flags & 3145728 && !(type.flags & 1024) && !isNonGenericTopLevelType(type) && some(type.types, couldContainTypeVariables));
        if (type.flags & 3899393) {
            type.objectFlags |= 524288 | (result ? 1048576 : 0);
        }
        return result;
    }
    function isNonGenericTopLevelType(type) {
        if (type.aliasSymbol && !type.aliasTypeArguments) {
            const declaration = getDeclarationOfKind(type.aliasSymbol, 262);
            return !!(declaration && findAncestor(declaration.parent, n => n.kind === 308 ? true : n.kind === 264 ? false : "quit"));
        }
        return false;
    }
    function isTypeParameterAtTopLevel(type, tp, depth = 0) {
        return !!(type === tp || type.flags & 3145728 && some(type.types, t => isTypeParameterAtTopLevel(t, tp, depth)) || depth < 3 && type.flags & 16777216 && (isTypeParameterAtTopLevel(getTrueTypeFromConditionalType(type), tp, depth + 1) || isTypeParameterAtTopLevel(getFalseTypeFromConditionalType(type), tp, depth + 1)));
    }
    function isTypeParameterAtTopLevelInReturnType(signature, typeParameter) {
        const typePredicate = getTypePredicateOfSignature(signature);
        return typePredicate ? !!typePredicate.type && isTypeParameterAtTopLevel(typePredicate.type, typeParameter) : isTypeParameterAtTopLevel(getReturnTypeOfSignature(signature), typeParameter);
    }
    function createEmptyObjectTypeFromStringLiteral(type) {
        const members = createSymbolTable();
        forEachType(type, t => {
            if (!(t.flags & 128)) {
                return;
            }
            const name = escapeLeadingUnderscores(t.value);
            const literalProp = createSymbol(4, name);
            literalProp.links.type = anyType;
            if (t.symbol) {
                literalProp.declarations = t.symbol.declarations;
                literalProp.valueDeclaration = t.symbol.valueDeclaration;
            }
            members.set(name, literalProp);
        });
        const indexInfos = type.flags & 4 ? [createIndexInfo(stringType, emptyObjectType, false)] : emptyArray;
        return createAnonymousType(void 0, members, emptyArray, emptyArray, indexInfos);
    }
    function inferTypeForHomomorphicMappedType(source, target, constraint) {
        if (inInferTypeForHomomorphicMappedType) {
            return void 0;
        }
        const key = source.id + "," + target.id + "," + constraint.id;
        if (reverseMappedCache.has(key)) {
            return reverseMappedCache.get(key);
        }
        inInferTypeForHomomorphicMappedType = true;
        const type = createReverseMappedType(source, target, constraint);
        inInferTypeForHomomorphicMappedType = false;
        reverseMappedCache.set(key, type);
        return type;
    }
    function isPartiallyInferableType(type) {
        return !(getObjectFlags(type) & 262144) || isObjectLiteralType2(type) && some(getPropertiesOfType(type), prop => isPartiallyInferableType(getTypeOfSymbol(prop))) || isTupleType(type) && some(getTypeArguments(type), isPartiallyInferableType);
    }
    function createReverseMappedType(source, target, constraint) {
        if (!(getIndexInfoOfType(source, stringType) || getPropertiesOfType(source).length !== 0 && isPartiallyInferableType(source))) {
            return void 0;
        }
        if (isArrayType(source)) {
            return createArrayType(inferReverseMappedType(getTypeArguments(source)[0], target, constraint), isReadonlyArrayType(source));
        }
        if (isTupleType(source)) {
            const elementTypes = map(getTypeArguments(source), t => inferReverseMappedType(t, target, constraint));
            const elementFlags = getMappedTypeModifiers(target) & 4 ? sameMap(source.target.elementFlags, f => f & 2 ? 1 : f) : source.target.elementFlags;
            return createTupleType(elementTypes, elementFlags, source.target.readonly, source.target.labeledElementDeclarations);
        }
        const reversed = createObjectType(1024 | 16, void 0);
        reversed.source = source;
        reversed.mappedType = target;
        reversed.constraintType = constraint;
        return reversed;
    }
    function getTypeOfReverseMappedSymbol(symbol) {
        const links = getSymbolLinks(symbol);
        if (!links.type) {
            links.type = inferReverseMappedType(symbol.links.propertyType, symbol.links.mappedType, symbol.links.constraintType);
        }
        return links.type;
    }
    function inferReverseMappedType(sourceType, target, constraint) {
        const typeParameter = getIndexedAccessType(constraint.type, getTypeParameterFromMappedType(target));
        const templateType = getTemplateTypeFromMappedType(target);
        const inference = createInferenceInfo(typeParameter);
        inferTypes([inference], sourceType, templateType);
        return getTypeFromInference(inference) || unknownType;
    }
    function* getUnmatchedProperties(source, target, requireOptionalProperties, matchDiscriminantProperties) {
        const properties = getPropertiesOfType(target);
        for (const targetProp of properties) {
            if (isStaticPrivateIdentifierProperty(targetProp)) {
                continue;
            }
            if (requireOptionalProperties || !(targetProp.flags & 16777216 || getCheckFlags(targetProp) & 48)) {
                const sourceProp = getPropertyOfType(source, targetProp.escapedName);
                if (!sourceProp) {
                    yield targetProp;
                } else if (matchDiscriminantProperties) {
                    const targetType = getTypeOfSymbol(targetProp);
                    if (targetType.flags & 109472) {
                        const sourceType = getTypeOfSymbol(sourceProp);
                        if (!(sourceType.flags & 1 || getRegularTypeOfLiteralType(sourceType) === getRegularTypeOfLiteralType(targetType))) {
                            yield targetProp;
                        }
                    }
                }
            }
        }
    }
    function getUnmatchedProperty(source, target, requireOptionalProperties, matchDiscriminantProperties) {
        return firstOrUndefinedIterator(getUnmatchedProperties(source, target, requireOptionalProperties, matchDiscriminantProperties));
    }
    function tupleTypesDefinitelyUnrelated(source, target) {
        return !(target.target.combinedFlags & 8) && target.target.minLength > source.target.minLength || !target.target.hasRestElement && (source.target.hasRestElement || target.target.fixedLength < source.target.fixedLength);
    }
    function typesDefinitelyUnrelated(source, target) {
        return isTupleType(source) && isTupleType(target) ? tupleTypesDefinitelyUnrelated(source, target) : !!getUnmatchedProperty(source, target, false, true) && !!getUnmatchedProperty(target, source, false, false);
    }
    function getTypeFromInference(inference) {
        return inference.candidates ? getUnionType(inference.candidates, 2) : inference.contraCandidates ? getIntersectionType(inference.contraCandidates) : void 0;
    }
    function hasSkipDirectInferenceFlag(node) {
        return !!getNodeLinks(node).skipDirectInference;
    }
    function isFromInferenceBlockedSource(type) {
        return !!(type.symbol && some(type.symbol.declarations, hasSkipDirectInferenceFlag));
    }
    function isValidNumberString(s, roundTripOnly) {
        if (s === "") return false;
        const n = +s;
        return isFinite(n) && (!roundTripOnly || "" + n === s);
    }
    function parseBigIntLiteralType(text) {
        return getBigIntLiteralType(parseValidBigInt(text));
    }
    function isMemberOfStringMapping(source, target) {
        if (target.flags & 1) {
            return true;
        }
        if (target.flags & (4 | 134217728)) {
            return isTypeAssignableTo(source, target);
        }
        if (target.flags & 268435456) {
            const mappingStack = [];
            while (target.flags & 268435456) {
                mappingStack.unshift(target.symbol);
                target = target.type;
            }
            const mappedSource = reduceLeft(mappingStack, (memo, value) => getStringMappingType(value, memo), source);
            return mappedSource === source && isMemberOfStringMapping(source, target);
        }
        return false;
    }
    function isValidTypeForTemplateLiteralPlaceholder(source, target) {
        if (source === target || target.flags & (1 | 4)) {
            return true;
        }
        if (source.flags & 128) {
            const value = source.value;
            return !!(target.flags & 8 && isValidNumberString(value, false) || target.flags & 64 && isValidBigIntString(value, false) || target.flags & (512 | 98304) && value === target.intrinsicName || target.flags & 268435456 && isMemberOfStringMapping(getStringLiteralType(value), target));
        }
        if (source.flags & 134217728) {
            const texts = source.texts;
            return texts.length === 2 && texts[0] === "" && texts[1] === "" && isTypeAssignableTo(source.types[0], target);
        }
        return isTypeAssignableTo(source, target);
    }
    function inferTypesFromTemplateLiteralType(source, target) {
        return source.flags & 128 ? inferFromLiteralPartsToTemplateLiteral([source.value], emptyArray, target) : source.flags & 134217728 ? arraysEqual(source.texts, target.texts) ? map(source.types, getStringLikeTypeForType) : inferFromLiteralPartsToTemplateLiteral(source.texts, source.types, target) : void 0;
    }
    function isTypeMatchedByTemplateLiteralType(source, target) {
        const inferences = inferTypesFromTemplateLiteralType(source, target);
        return !!inferences && every(inferences, (r, i) => isValidTypeForTemplateLiteralPlaceholder(r, target.types[i]));
    }
    function getStringLikeTypeForType(type) {
        return type.flags & (1 | 402653316) ? type : getTemplateLiteralType(["", ""], [type]);
    }
    function inferFromLiteralPartsToTemplateLiteral(sourceTexts, sourceTypes, target) {
        const lastSourceIndex = sourceTexts.length - 1;
        const sourceStartText = sourceTexts[0];
        const sourceEndText = sourceTexts[lastSourceIndex];
        const targetTexts = target.texts;
        const lastTargetIndex = targetTexts.length - 1;
        const targetStartText = targetTexts[0];
        const targetEndText = targetTexts[lastTargetIndex];
        if (lastSourceIndex === 0 && sourceStartText.length < targetStartText.length + targetEndText.length || !sourceStartText.startsWith(targetStartText) || !sourceEndText.endsWith(targetEndText)) return void 0;
        const remainingEndText = sourceEndText.slice(0, sourceEndText.length - targetEndText.length);
        const matches = [];
        let seg = 0;
        let pos = targetStartText.length;
        for (let i = 1; i < lastTargetIndex; i++) {
            const delim = targetTexts[i];
            if (delim.length > 0) {
                let s = seg;
                let p = pos;
                while (true) {
                    p = getSourceText(s).indexOf(delim, p);
                    if (p >= 0) break;
                    s++;
                    if (s === sourceTexts.length) return void 0;
                    p = 0;
                }
                addMatch(s, p);
                pos += delim.length;
            } else if (pos < getSourceText(seg).length) {
                addMatch(seg, pos + 1);
            } else if (seg < lastSourceIndex) {
                addMatch(seg + 1, 0);
            } else {
                return void 0;
            }
        }
        addMatch(lastSourceIndex, getSourceText(lastSourceIndex).length);
        return matches;
        function getSourceText(index) {
            return index < lastSourceIndex ? sourceTexts[index] : remainingEndText;
        }
        function addMatch(s, p) {
            const matchType = s === seg ? getStringLiteralType(getSourceText(s).slice(pos, p)) : getTemplateLiteralType([sourceTexts[seg].slice(pos), ...sourceTexts.slice(seg + 1, s), getSourceText(s).slice(0, p)], sourceTypes.slice(seg, s));
            matches.push(matchType);
            seg = s;
            pos = p;
        }
    }
    function inferTypes(inferences, originalSource, originalTarget, priority = 0, contravariant = false) {
        let bivariant = false;
        let propagationType;
        let inferencePriority = 2048;
        let allowComplexConstraintInference = true;
        let visited;
        let sourceStack;
        let targetStack;
        let expandingFlags = 0;
        inferFromTypes(originalSource, originalTarget);
        function inferFromTypes(source, target) {
            if (!couldContainTypeVariables(target)) {
                return;
            }
            if (source === wildcardType) {
                const savePropagationType = propagationType;
                propagationType = source;
                inferFromTypes(target, target);
                propagationType = savePropagationType;
                return;
            }
            if (source.aliasSymbol && source.aliasSymbol === target.aliasSymbol) {
                if (source.aliasTypeArguments) {
                    const params = getSymbolLinks(source.aliasSymbol).typeParameters;
                    const minParams = getMinTypeArgumentCount(params);
                    const sourceTypes = fillMissingTypeArguments(source.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration));
                    const targetTypes = fillMissingTypeArguments(target.aliasTypeArguments, params, minParams, isInJSFile(source.aliasSymbol.valueDeclaration));
                    inferFromTypeArguments(sourceTypes, targetTypes, getAliasVariances(source.aliasSymbol));
                }
                return;
            }
            if (source === target && source.flags & 3145728) {
                for (const t of source.types) {
                    inferFromTypes(t, t);
                }
                return;
            }
            if (target.flags & 1048576) {
                const [tempSources, tempTargets] = inferFromMatchingTypes(source.flags & 1048576 ? source.types : [source], target.types, isTypeOrBaseIdenticalTo);
                const [sources, targets] = inferFromMatchingTypes(tempSources, tempTargets, isTypeCloselyMatchedBy);
                if (targets.length === 0) {
                    return;
                }
                target = getUnionType(targets);
                if (sources.length === 0) {
                    inferWithPriority(source, target, 1);
                    return;
                }
                source = getUnionType(sources);
            } else if (target.flags & 2097152 && !every(target.types, isNonGenericObjectType)) {
                if (!(source.flags & 1048576)) {
                    const [sources, targets] = inferFromMatchingTypes(source.flags & 2097152 ? source.types : [source], target.types, isTypeIdenticalTo);
                    if (sources.length === 0 || targets.length === 0) {
                        return;
                    }
                    source = getIntersectionType(sources);
                    target = getIntersectionType(targets);
                }
            } else if (target.flags & (8388608 | 33554432)) {
                target = getActualTypeVariable(target);
            }
            if (target.flags & 8650752) {
                if (isFromInferenceBlockedSource(source)) {
                    return;
                }
                const inference = getInferenceInfoForType(target);
                if (inference) {
                    if (getObjectFlags(source) & 262144 || source === nonInferrableAnyType) {
                        return;
                    }
                    if (!inference.isFixed) {
                        if (inference.priority === void 0 || priority < inference.priority) {
                            inference.candidates = void 0;
                            inference.contraCandidates = void 0;
                            inference.topLevel = true;
                            inference.priority = priority;
                        }
                        if (priority === inference.priority) {
                            const candidate = propagationType || source;
                            if (contravariant && !bivariant) {
                                if (!contains(inference.contraCandidates, candidate)) {
                                    inference.contraCandidates = append(inference.contraCandidates, candidate);
                                    clearCachedInferences(inferences);
                                }
                            } else if (!contains(inference.candidates, candidate)) {
                                inference.candidates = append(inference.candidates, candidate);
                                clearCachedInferences(inferences);
                            }
                        }
                        if (!(priority & 128) && target.flags & 262144 && inference.topLevel && !isTypeParameterAtTopLevel(originalTarget, target)) {
                            inference.topLevel = false;
                            clearCachedInferences(inferences);
                        }
                    }
                    inferencePriority = Math.min(inferencePriority, priority);
                    return;
                }
                const simplified = getSimplifiedType(target, false);
                if (simplified !== target) {
                    inferFromTypes(source, simplified);
                } else if (target.flags & 8388608) {
                    const indexType = getSimplifiedType(target.indexType, false);
                    if (indexType.flags & 465829888) {
                        const simplified2 = distributeIndexOverObjectType(getSimplifiedType(target.objectType, false), indexType, false);
                        if (simplified2 && simplified2 !== target) {
                            inferFromTypes(source, simplified2);
                        }
                    }
                }
            }
            if (getObjectFlags(source) & 4 && getObjectFlags(target) & 4 && (source.target === target.target || isArrayType(source) && isArrayType(target)) && !(source.node && target.node)) {
                inferFromTypeArguments(getTypeArguments(source), getTypeArguments(target), getVariances(source.target));
            } else if (source.flags & 4194304 && target.flags & 4194304) {
                inferFromContravariantTypes(source.type, target.type);
            } else if ((isLiteralType(source) || source.flags & 4) && target.flags & 4194304) {
                const empty = createEmptyObjectTypeFromStringLiteral(source);
                inferFromContravariantTypesWithPriority(empty, target.type, 256);
            } else if (source.flags & 8388608 && target.flags & 8388608) {
                inferFromTypes(source.objectType, target.objectType);
                inferFromTypes(source.indexType, target.indexType);
            } else if (source.flags & 268435456 && target.flags & 268435456) {
                if (source.symbol === target.symbol) {
                    inferFromTypes(source.type, target.type);
                }
            } else if (source.flags & 33554432) {
                inferFromTypes(source.baseType, target);
                inferWithPriority(getSubstitutionIntersection(source), target, 4);
            } else if (target.flags & 16777216) {
                invokeOnce(source, target, inferToConditionalType);
            } else if (target.flags & 3145728) {
                inferToMultipleTypes(source, target.types, target.flags);
            } else if (source.flags & 1048576) {
                const sourceTypes = source.types;
                for (const sourceType of sourceTypes) {
                    inferFromTypes(sourceType, target);
                }
            } else if (target.flags & 134217728) {
                inferToTemplateLiteralType(source, target);
            } else {
                source = getReducedType(source);
                if (!(priority & 512 && source.flags & (2097152 | 465829888))) {
                    const apparentSource = getApparentType(source);
                    if (apparentSource !== source && allowComplexConstraintInference && !(apparentSource.flags & (524288 | 2097152))) {
                        allowComplexConstraintInference = false;
                        return inferFromTypes(apparentSource, target);
                    }
                    source = apparentSource;
                }
                if (source.flags & (524288 | 2097152)) {
                    invokeOnce(source, target, inferFromObjectTypes);
                }
            }
        }
        function inferWithPriority(source, target, newPriority) {
            const savePriority = priority;
            priority |= newPriority;
            inferFromTypes(source, target);
            priority = savePriority;
        }
        function inferFromContravariantTypesWithPriority(source, target, newPriority) {
            const savePriority = priority;
            priority |= newPriority;
            inferFromContravariantTypes(source, target);
            priority = savePriority;
        }
        function inferToMultipleTypesWithPriority(source, targets, targetFlags, newPriority) {
            const savePriority = priority;
            priority |= newPriority;
            inferToMultipleTypes(source, targets, targetFlags);
            priority = savePriority;
        }
        function invokeOnce(source, target, action) {
            const key = source.id + "," + target.id;
            const status = visited && visited.get(key);
            if (status !== void 0) {
                inferencePriority = Math.min(inferencePriority, status);
                return;
            }
            (visited || (visited = /* @__PURE__ */new Map())).set(key, -1);
            const saveInferencePriority = inferencePriority;
            inferencePriority = 2048;
            const saveExpandingFlags = expandingFlags;
            const sourceIdentity = getRecursionIdentity(source);
            const targetIdentity = getRecursionIdentity(target);
            if (contains(sourceStack, sourceIdentity)) expandingFlags |= 1;
            if (contains(targetStack, targetIdentity)) expandingFlags |= 2;
            if (expandingFlags !== 3) {
                (sourceStack || (sourceStack = [])).push(sourceIdentity);
                (targetStack || (targetStack = [])).push(targetIdentity);
                action(source, target);
                targetStack.pop();
                sourceStack.pop();
            } else {
                inferencePriority = -1;
            }
            expandingFlags = saveExpandingFlags;
            visited.set(key, inferencePriority);
            inferencePriority = Math.min(inferencePriority, saveInferencePriority);
        }
        function inferFromMatchingTypes(sources, targets, matches) {
            let matchedSources;
            let matchedTargets;
            for (const t of targets) {
                for (const s of sources) {
                    if (matches(s, t)) {
                        inferFromTypes(s, t);
                        matchedSources = appendIfUnique(matchedSources, s);
                        matchedTargets = appendIfUnique(matchedTargets, t);
                    }
                }
            }
            return [matchedSources ? filter(sources, t => !contains(matchedSources, t)) : sources, matchedTargets ? filter(targets, t => !contains(matchedTargets, t)) : targets];
        }
        function inferFromTypeArguments(sourceTypes, targetTypes, variances) {
            const count = sourceTypes.length < targetTypes.length ? sourceTypes.length : targetTypes.length;
            for (let i = 0; i < count; i++) {
                if (i < variances.length && (variances[i] & 7) === 2) {
                    inferFromContravariantTypes(sourceTypes[i], targetTypes[i]);
                } else {
                    inferFromTypes(sourceTypes[i], targetTypes[i]);
                }
            }
        }
        function inferFromContravariantTypes(source, target) {
            contravariant = !contravariant;
            inferFromTypes(source, target);
            contravariant = !contravariant;
        }
        function inferFromContravariantTypesIfStrictFunctionTypes(source, target) {
            if (strictFunctionTypes || priority & 1024) {
                inferFromContravariantTypes(source, target);
            } else {
                inferFromTypes(source, target);
            }
        }
        function getInferenceInfoForType(type) {
            if (type.flags & 8650752) {
                for (const inference of inferences) {
                    if (type === inference.typeParameter) {
                        return inference;
                    }
                }
            }
            return void 0;
        }
        function getSingleTypeVariableFromIntersectionTypes(types) {
            let typeVariable;
            for (const type of types) {
                const t = type.flags & 2097152 && find(type.types, t2 => !!getInferenceInfoForType(t2));
                if (!t || typeVariable && t !== typeVariable) {
                    return void 0;
                }
                typeVariable = t;
            }
            return typeVariable;
        }
        function inferToMultipleTypes(source, targets, targetFlags) {
            let typeVariableCount = 0;
            if (targetFlags & 1048576) {
                let nakedTypeVariable;
                const sources = source.flags & 1048576 ? source.types : [source];
                const matched = new Array(sources.length);
                let inferenceCircularity = false;
                for (const t of targets) {
                    if (getInferenceInfoForType(t)) {
                        nakedTypeVariable = t;
                        typeVariableCount++;
                    } else {
                        for (let i = 0; i < sources.length; i++) {
                            const saveInferencePriority = inferencePriority;
                            inferencePriority = 2048;
                            inferFromTypes(sources[i], t);
                            if (inferencePriority === priority) matched[i] = true;
                            inferenceCircularity = inferenceCircularity || inferencePriority === -1;
                            inferencePriority = Math.min(inferencePriority, saveInferencePriority);
                        }
                    }
                }
                if (typeVariableCount === 0) {
                    const intersectionTypeVariable = getSingleTypeVariableFromIntersectionTypes(targets);
                    if (intersectionTypeVariable) {
                        inferWithPriority(source, intersectionTypeVariable, 1);
                    }
                    return;
                }
                if (typeVariableCount === 1 && !inferenceCircularity) {
                    const unmatched = flatMap(sources, (s, i) => matched[i] ? void 0 : s);
                    if (unmatched.length) {
                        inferFromTypes(getUnionType(unmatched), nakedTypeVariable);
                        return;
                    }
                }
            } else {
                for (const t of targets) {
                    if (getInferenceInfoForType(t)) {
                        typeVariableCount++;
                    } else {
                        inferFromTypes(source, t);
                    }
                }
            }
            if (targetFlags & 2097152 ? typeVariableCount === 1 : typeVariableCount > 0) {
                for (const t of targets) {
                    if (getInferenceInfoForType(t)) {
                        inferWithPriority(source, t, 1);
                    }
                }
            }
        }
        function inferToMappedType(source, target, constraintType) {
            if (constraintType.flags & 1048576) {
                let result = false;
                for (const type of constraintType.types) {
                    result = inferToMappedType(source, target, type) || result;
                }
                return result;
            }
            if (constraintType.flags & 4194304) {
                const inference = getInferenceInfoForType(constraintType.type);
                if (inference && !inference.isFixed && !isFromInferenceBlockedSource(source)) {
                    const inferredType = inferTypeForHomomorphicMappedType(source, target, constraintType);
                    if (inferredType) {
                        inferWithPriority(inferredType, inference.typeParameter, getObjectFlags(source) & 262144 ? 16 : 8);
                    }
                }
                return true;
            }
            if (constraintType.flags & 262144) {
                inferWithPriority(getIndexType(source), constraintType, 32);
                const extendedConstraint = getConstraintOfType(constraintType);
                if (extendedConstraint && inferToMappedType(source, target, extendedConstraint)) {
                    return true;
                }
                const propTypes = map(getPropertiesOfType(source), getTypeOfSymbol);
                const indexTypes = map(getIndexInfosOfType(source), info => info !== enumNumberIndexInfo ? info.type : neverType);
                inferFromTypes(getUnionType(concatenate(propTypes, indexTypes)), getTemplateTypeFromMappedType(target));
                return true;
            }
            return false;
        }
        function inferToConditionalType(source, target) {
            if (source.flags & 16777216) {
                inferFromTypes(source.checkType, target.checkType);
                inferFromTypes(source.extendsType, target.extendsType);
                inferFromTypes(getTrueTypeFromConditionalType(source), getTrueTypeFromConditionalType(target));
                inferFromTypes(getFalseTypeFromConditionalType(source), getFalseTypeFromConditionalType(target));
            } else {
                const targetTypes = [getTrueTypeFromConditionalType(target), getFalseTypeFromConditionalType(target)];
                inferToMultipleTypesWithPriority(source, targetTypes, target.flags, contravariant ? 64 : 0);
            }
        }
        function inferToTemplateLiteralType(source, target) {
            const matches = inferTypesFromTemplateLiteralType(source, target);
            const types = target.types;
            if (matches || every(target.texts, s => s.length === 0)) {
                for (let i = 0; i < types.length; i++) {
                    const source2 = matches ? matches[i] : neverType;
                    const target2 = types[i];
                    if (source2.flags & 128 && target2.flags & 8650752) {
                        const inferenceContext = getInferenceInfoForType(target2);
                        const constraint = inferenceContext ? getBaseConstraintOfType(inferenceContext.typeParameter) : void 0;
                        if (constraint && !isTypeAny(constraint)) {
                            const constraintTypes = constraint.flags & 1048576 ? constraint.types : [constraint];
                            let allTypeFlags = reduceLeft(constraintTypes, (flags, t) => flags | t.flags, 0);
                            if (!(allTypeFlags & 4)) {
                                const str = source2.value;
                                if (allTypeFlags & 296 && !isValidNumberString(str, true)) {
                                    allTypeFlags &= ~296;
                                }
                                if (allTypeFlags & 2112 && !isValidBigIntString(str, true)) {
                                    allTypeFlags &= ~2112;
                                }
                                const matchingType = reduceLeft(constraintTypes, (left, right) => !(right.flags & allTypeFlags) ? left : left.flags & 4 ? left : right.flags & 4 ? source2 : left.flags & 134217728 ? left : right.flags & 134217728 && isTypeMatchedByTemplateLiteralType(source2, right) ? source2 : left.flags & 268435456 ? left : right.flags & 268435456 && str === applyStringMapping(right.symbol, str) ? source2 : left.flags & 128 ? left : right.flags & 128 && right.value === str ? right : left.flags & 8 ? left : right.flags & 8 ? getNumberLiteralType(+str) : left.flags & 32 ? left : right.flags & 32 ? getNumberLiteralType(+str) : left.flags & 256 ? left : right.flags & 256 && right.value === +str ? right : left.flags & 64 ? left : right.flags & 64 ? parseBigIntLiteralType(str) : left.flags & 2048 ? left : right.flags & 2048 && pseudoBigIntToString(right.value) === str ? right : left.flags & 16 ? left : right.flags & 16 ? str === "true" ? trueType : str === "false" ? falseType : booleanType : left.flags & 512 ? left : right.flags & 512 && right.intrinsicName === str ? right : left.flags & 32768 ? left : right.flags & 32768 && right.intrinsicName === str ? right : left.flags & 65536 ? left : right.flags & 65536 && right.intrinsicName === str ? right : left, neverType);
                                if (!(matchingType.flags & 131072)) {
                                    inferFromTypes(matchingType, target2);
                                    continue;
                                }
                            }
                        }
                    }
                    inferFromTypes(source2, target2);
                }
            }
        }
        function inferFromObjectTypes(source, target) {
            var _a2, _b;
            if (getObjectFlags(source) & 4 && getObjectFlags(target) & 4 && (source.target === target.target || isArrayType(source) && isArrayType(target))) {
                inferFromTypeArguments(getTypeArguments(source), getTypeArguments(target), getVariances(source.target));
                return;
            }
            if (isGenericMappedType(source) && isGenericMappedType(target)) {
                inferFromTypes(getConstraintTypeFromMappedType(source), getConstraintTypeFromMappedType(target));
                inferFromTypes(getTemplateTypeFromMappedType(source), getTemplateTypeFromMappedType(target));
                const sourceNameType = getNameTypeFromMappedType(source);
                const targetNameType = getNameTypeFromMappedType(target);
                if (sourceNameType && targetNameType) inferFromTypes(sourceNameType, targetNameType);
            }
            if (getObjectFlags(target) & 32 && !target.declaration.nameType) {
                const constraintType = getConstraintTypeFromMappedType(target);
                if (inferToMappedType(source, target, constraintType)) {
                    return;
                }
            }
            if (!typesDefinitelyUnrelated(source, target)) {
                if (isArrayOrTupleType(source)) {
                    if (isTupleType(target)) {
                        const sourceArity = getTypeReferenceArity(source);
                        const targetArity = getTypeReferenceArity(target);
                        const elementTypes = getTypeArguments(target);
                        const elementFlags = target.target.elementFlags;
                        if (isTupleType(source) && isTupleTypeStructureMatching(source, target)) {
                            for (let i = 0; i < targetArity; i++) {
                                inferFromTypes(getTypeArguments(source)[i], elementTypes[i]);
                            }
                            return;
                        }
                        const startLength = isTupleType(source) ? Math.min(source.target.fixedLength, target.target.fixedLength) : 0;
                        const endLength = Math.min(isTupleType(source) ? getEndElementCount(source.target, 3) : 0, target.target.hasRestElement ? getEndElementCount(target.target, 3) : 0);
                        for (let i = 0; i < startLength; i++) {
                            inferFromTypes(getTypeArguments(source)[i], elementTypes[i]);
                        }
                        if (!isTupleType(source) || sourceArity - startLength - endLength === 1 && source.target.elementFlags[startLength] & 4) {
                            const restType = getTypeArguments(source)[startLength];
                            for (let i = startLength; i < targetArity - endLength; i++) {
                                inferFromTypes(elementFlags[i] & 8 ? createArrayType(restType) : restType, elementTypes[i]);
                            }
                        } else {
                            const middleLength = targetArity - startLength - endLength;
                            if (middleLength === 2) {
                                if (elementFlags[startLength] & elementFlags[startLength + 1] & 8) {
                                    const targetInfo = getInferenceInfoForType(elementTypes[startLength]);
                                    if (targetInfo && targetInfo.impliedArity !== void 0) {
                                        inferFromTypes(sliceTupleType(source, startLength, endLength + sourceArity - targetInfo.impliedArity), elementTypes[startLength]);
                                        inferFromTypes(sliceTupleType(source, startLength + targetInfo.impliedArity, endLength), elementTypes[startLength + 1]);
                                    }
                                } else if (elementFlags[startLength] & 8 && elementFlags[startLength + 1] & 4) {
                                    const param = (_a2 = getInferenceInfoForType(elementTypes[startLength])) == null ? void 0 : _a2.typeParameter;
                                    const constraint = param && getBaseConstraintOfType(param);
                                    if (constraint && isTupleType(constraint) && !constraint.target.hasRestElement) {
                                        const impliedArity = constraint.target.fixedLength;
                                        inferFromTypes(sliceTupleType(source, startLength, sourceArity - (startLength + impliedArity)), elementTypes[startLength]);
                                        inferFromTypes(getElementTypeOfSliceOfTupleType(source, startLength + impliedArity, endLength), elementTypes[startLength + 1]);
                                    }
                                } else if (elementFlags[startLength] & 4 && elementFlags[startLength + 1] & 8) {
                                    const param = (_b = getInferenceInfoForType(elementTypes[startLength + 1])) == null ? void 0 : _b.typeParameter;
                                    const constraint = param && getBaseConstraintOfType(param);
                                    if (constraint && isTupleType(constraint) && !constraint.target.hasRestElement) {
                                        const impliedArity = constraint.target.fixedLength;
                                        const endIndex = sourceArity - getEndElementCount(target.target, 3);
                                        const startIndex = endIndex - impliedArity;
                                        const trailingSlice = createTupleType(getTypeArguments(source).slice(startIndex, endIndex), source.target.elementFlags.slice(startIndex, endIndex), false, source.target.labeledElementDeclarations && source.target.labeledElementDeclarations.slice(startIndex, endIndex));
                                        inferFromTypes(getElementTypeOfSliceOfTupleType(source, startLength, endLength + impliedArity), elementTypes[startLength]);
                                        inferFromTypes(trailingSlice, elementTypes[startLength + 1]);
                                    }
                                }
                            } else if (middleLength === 1 && elementFlags[startLength] & 8) {
                                const endsInOptional = target.target.elementFlags[targetArity - 1] & 2;
                                const sourceSlice = sliceTupleType(source, startLength, endLength);
                                inferWithPriority(sourceSlice, elementTypes[startLength], endsInOptional ? 2 : 0);
                            } else if (middleLength === 1 && elementFlags[startLength] & 4) {
                                const restType = getElementTypeOfSliceOfTupleType(source, startLength, endLength);
                                if (restType) {
                                    inferFromTypes(restType, elementTypes[startLength]);
                                }
                            }
                        }
                        for (let i = 0; i < endLength; i++) {
                            inferFromTypes(getTypeArguments(source)[sourceArity - i - 1], elementTypes[targetArity - i - 1]);
                        }
                        return;
                    }
                    if (isArrayType(target)) {
                        inferFromIndexTypes(source, target);
                        return;
                    }
                }
                inferFromProperties(source, target);
                inferFromSignatures(source, target, 0);
                inferFromSignatures(source, target, 1);
                inferFromIndexTypes(source, target);
            }
        }
        function inferFromProperties(source, target) {
            const properties = getPropertiesOfObjectType(target);
            for (const targetProp of properties) {
                const sourceProp = getPropertyOfType(source, targetProp.escapedName);
                if (sourceProp && !some(sourceProp.declarations, hasSkipDirectInferenceFlag)) {
                    inferFromTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp));
                }
            }
        }
        function inferFromSignatures(source, target, kind) {
            const sourceSignatures = getSignaturesOfType(source, kind);
            const targetSignatures = getSignaturesOfType(target, kind);
            const sourceLen = sourceSignatures.length;
            const targetLen = targetSignatures.length;
            const len = sourceLen < targetLen ? sourceLen : targetLen;
            for (let i = 0; i < len; i++) {
                inferFromSignature(getBaseSignature(sourceSignatures[sourceLen - len + i]), getErasedSignature(targetSignatures[targetLen - len + i]));
            }
        }
        function inferFromSignature(source, target) {
            const saveBivariant = bivariant;
            const kind = target.declaration ? target.declaration.kind : 0;
            bivariant = bivariant || kind === 171 || kind === 170 || kind === 173;
            applyToParameterTypes(source, target, inferFromContravariantTypesIfStrictFunctionTypes);
            bivariant = saveBivariant;
            applyToReturnTypes(source, target, inferFromTypes);
        }
        function inferFromIndexTypes(source, target) {
            const priority2 = getObjectFlags(source) & getObjectFlags(target) & 32 ? 8 : 0;
            const indexInfos = getIndexInfosOfType(target);
            if (isObjectTypeWithInferableIndex(source)) {
                for (const targetInfo of indexInfos) {
                    const propTypes = [];
                    for (const prop of getPropertiesOfType(source)) {
                        if (isApplicableIndexType(getLiteralTypeFromProperty(prop, 8576), targetInfo.keyType)) {
                            const propType = getTypeOfSymbol(prop);
                            propTypes.push(prop.flags & 16777216 ? removeMissingOrUndefinedType(propType) : propType);
                        }
                    }
                    for (const info of getIndexInfosOfType(source)) {
                        if (isApplicableIndexType(info.keyType, targetInfo.keyType)) {
                            propTypes.push(info.type);
                        }
                    }
                    if (propTypes.length) {
                        inferWithPriority(getUnionType(propTypes), targetInfo.type, priority2);
                    }
                }
            }
            for (const targetInfo of indexInfos) {
                const sourceInfo = getApplicableIndexInfo(source, targetInfo.keyType);
                if (sourceInfo) {
                    inferWithPriority(sourceInfo.type, targetInfo.type, priority2);
                }
            }
        }
    }
    function isTypeOrBaseIdenticalTo(s, t) {
        return t === missingType ? s === t : isTypeIdenticalTo(s, t) || !!(t.flags & 4 && s.flags & 128 || t.flags & 8 && s.flags & 256);
    }
    function isTypeCloselyMatchedBy(s, t) {
        return !!(s.flags & 524288 && t.flags & 524288 && s.symbol && s.symbol === t.symbol || s.aliasSymbol && s.aliasTypeArguments && s.aliasSymbol === t.aliasSymbol);
    }
    function hasPrimitiveConstraint(type) {
        const constraint = getConstraintOfTypeParameter(type);
        return !!constraint && maybeTypeOfKind(constraint.flags & 16777216 ? getDefaultConstraintOfConditionalType(constraint) : constraint, 134348796 | 4194304 | 134217728 | 268435456);
    }
    function isObjectLiteralType2(type) {
        return !!(getObjectFlags(type) & 128);
    }
    function isObjectOrArrayLiteralType(type) {
        return !!(getObjectFlags(type) & (128 | 16384));
    }
    function unionObjectAndArrayLiteralCandidates(candidates) {
        if (candidates.length > 1) {
            const objectLiterals = filter(candidates, isObjectOrArrayLiteralType);
            if (objectLiterals.length) {
                const literalsType = getUnionType(objectLiterals, 2);
                return concatenate(filter(candidates, t => !isObjectOrArrayLiteralType(t)), [literalsType]);
            }
        }
        return candidates;
    }
    function getContravariantInference(inference) {
        return inference.priority & 416 ? getIntersectionType(inference.contraCandidates) : getCommonSubtype(inference.contraCandidates);
    }
    function getCovariantInference(inference, signature) {
        const candidates = unionObjectAndArrayLiteralCandidates(inference.candidates);
        const primitiveConstraint = hasPrimitiveConstraint(inference.typeParameter) || isConstTypeVariable(inference.typeParameter);
        const widenLiteralTypes = !primitiveConstraint && inference.topLevel && (inference.isFixed || !isTypeParameterAtTopLevelInReturnType(signature, inference.typeParameter));
        const baseCandidates = primitiveConstraint ? sameMap(candidates, getRegularTypeOfLiteralType) : widenLiteralTypes ? sameMap(candidates, getWidenedLiteralType) : candidates;
        const unwidenedType = inference.priority & 416 ? getUnionType(baseCandidates, 2) : getCommonSupertype(baseCandidates);
        return getWidenedType(unwidenedType);
    }
    function getInferredType(context, index) {
        const inference = context.inferences[index];
        if (!inference.inferredType) {
            let inferredType;
            const signature = context.signature;
            if (signature) {
                const inferredCovariantType = inference.candidates ? getCovariantInference(inference, signature) : void 0;
                if (inference.contraCandidates) {
                    const useCovariantType = inferredCovariantType && !(inferredCovariantType.flags & 131072) && some(inference.contraCandidates, t => isTypeSubtypeOf(inferredCovariantType, t)) && every(context.inferences, other => other !== inference && getConstraintOfTypeParameter(other.typeParameter) !== inference.typeParameter || every(other.candidates, t => isTypeSubtypeOf(t, inferredCovariantType)));
                    inferredType = useCovariantType ? inferredCovariantType : getContravariantInference(inference);
                } else if (inferredCovariantType) {
                    inferredType = inferredCovariantType;
                } else if (context.flags & 1) {
                    inferredType = silentNeverType;
                } else {
                    const defaultType = getDefaultFromTypeParameter(inference.typeParameter);
                    if (defaultType) {
                        inferredType = instantiateType(defaultType, mergeTypeMappers(createBackreferenceMapper(context, index), context.nonFixingMapper));
                    }
                }
            } else {
                inferredType = getTypeFromInference(inference);
            }
            inference.inferredType = inferredType || getDefaultTypeArgumentType(!!(context.flags & 2));
            const constraint = getConstraintOfTypeParameter(inference.typeParameter);
            if (constraint) {
                const instantiatedConstraint = instantiateType(constraint, context.nonFixingMapper);
                if (!inferredType || !context.compareTypes(inferredType, getTypeWithThisArgument(instantiatedConstraint, inferredType))) {
                    inference.inferredType = inferredType = instantiatedConstraint;
                }
            }
        }
        return inference.inferredType;
    }
    function getDefaultTypeArgumentType(isInJavaScriptFile) {
        return isInJavaScriptFile ? anyType : unknownType;
    }
    function getInferredTypes(context) {
        const result = [];
        for (let i = 0; i < context.inferences.length; i++) {
            result.push(getInferredType(context, i));
        }
        return result;
    }
    function getCannotFindNameDiagnosticForName(node) {
        switch (node.escapedText) {
            case "document":
            case "console":
                return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_include_dom;
            case "$":
                return compilerOptions.types ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery_and_then_add_jquery_to_the_types_field_in_your_tsconfig : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery;
            case "describe":
            case "suite":
            case "it":
            case "test":
                return compilerOptions.types ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha_and_then_add_jest_or_mocha_to_the_types_field_in_your_tsconfig : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha;
            case "process":
            case "require":
            case "Buffer":
            case "module":
                return compilerOptions.types ? Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode_and_then_add_node_to_the_types_field_in_your_tsconfig : Diagnostics.Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode;
            case "Map":
            case "Set":
            case "Promise":
            case "Symbol":
            case "WeakMap":
            case "WeakSet":
            case "Iterator":
            case "AsyncIterator":
            case "SharedArrayBuffer":
            case "Atomics":
            case "AsyncIterable":
            case "AsyncIterableIterator":
            case "AsyncGenerator":
            case "AsyncGeneratorFunction":
            case "BigInt":
            case "Reflect":
            case "BigInt64Array":
            case "BigUint64Array":
                return Diagnostics.Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_1_or_later;
            case "await":
                if (isCallExpression(node.parent)) {
                    return Diagnostics.Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function;
                }
            default:
                if (node.parent.kind === 300) {
                    return Diagnostics.No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer;
                } else {
                    return Diagnostics.Cannot_find_name_0;
                }
        }
    }
    function getResolvedSymbol(node) {
        const links = getNodeLinks(node);
        if (!links.resolvedSymbol) {
            links.resolvedSymbol = !nodeIsMissing(node) && resolveName(node, node.escapedText, 111551 | 1048576, getCannotFindNameDiagnosticForName(node), node, !isWriteOnlyAccess(node), false) || unknownSymbol;
        }
        return links.resolvedSymbol;
    }
    function isInTypeQuery(node) {
        return !!findAncestor(node, n => n.kind === 183 ? true : n.kind === 79 || n.kind === 163 ? false : "quit");
    }
    function isInAmbientOrTypeNode(node) {
        return !!(node.flags & 16777216 || findAncestor(node, n => isInterfaceDeclaration(n) || isTypeLiteralNode(n)));
    }
    function getFlowCacheKey(node, declaredType, initialType, flowContainer) {
        switch (node.kind) {
            case 79:
                if (!isThisInTypeQuery(node)) {
                    const symbol = getResolvedSymbol(node);
                    return symbol !== unknownSymbol ? `${flowContainer ? getNodeId(flowContainer) : "-1"}|${getTypeId(declaredType)}|${getTypeId(initialType)}|${getSymbolId(symbol)}` : void 0;
                }
            case 108:
                return `0|${flowContainer ? getNodeId(flowContainer) : "-1"}|${getTypeId(declaredType)}|${getTypeId(initialType)}`;
            case 232:
            case 214:
                return getFlowCacheKey(node.expression, declaredType, initialType, flowContainer);
            case 163:
                const left = getFlowCacheKey(node.left, declaredType, initialType, flowContainer);
                return left && left + "." + node.right.escapedText;
            case 208:
            case 209:
                const propName = getAccessedPropertyName(node);
                if (propName !== void 0) {
                    const key = getFlowCacheKey(node.expression, declaredType, initialType, flowContainer);
                    return key && key + "." + propName;
                }
                break;
            case 203:
            case 204:
            case 259:
            case 215:
            case 216:
            case 171:
                return `${getNodeId(node)}#${getTypeId(declaredType)}`;
        }
        return void 0;
    }
    function isMatchingReference(source, target) {
        switch (target.kind) {
            case 214:
            case 232:
                return isMatchingReference(source, target.expression);
            case 223:
                return isAssignmentExpression(target) && isMatchingReference(source, target.left) || isBinaryExpression(target) && target.operatorToken.kind === 27 && isMatchingReference(source, target.right);
        }
        switch (source.kind) {
            case 233:
                return target.kind === 233 && source.keywordToken === target.keywordToken && source.name.escapedText === target.name.escapedText;
            case 79:
            case 80:
                return isThisInTypeQuery(source) ? target.kind === 108 : target.kind === 79 && getResolvedSymbol(source) === getResolvedSymbol(target) || (isVariableDeclaration(target) || isBindingElement(target)) && getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(source)) === getSymbolOfDeclaration(target);
            case 108:
                return target.kind === 108;
            case 106:
                return target.kind === 106;
            case 232:
            case 214:
                return isMatchingReference(source.expression, target);
            case 208:
            case 209:
                const sourcePropertyName = getAccessedPropertyName(source);
                const targetPropertyName = isAccessExpression(target) ? getAccessedPropertyName(target) : void 0;
                return sourcePropertyName !== void 0 && targetPropertyName !== void 0 && targetPropertyName === sourcePropertyName && isMatchingReference(source.expression, target.expression);
            case 163:
                return isAccessExpression(target) && source.right.escapedText === getAccessedPropertyName(target) && isMatchingReference(source.left, target.expression);
            case 223:
                return isBinaryExpression(source) && source.operatorToken.kind === 27 && isMatchingReference(source.right, target);
        }
        return false;
    }
    function getAccessedPropertyName(access) {
        if (isPropertyAccessExpression(access)) {
            return access.name.escapedText;
        }
        if (isElementAccessExpression(access)) {
            return tryGetElementAccessExpressionName(access);
        }
        if (isBindingElement(access)) {
            const name = getDestructuringPropertyName(access);
            return name ? escapeLeadingUnderscores(name) : void 0;
        }
        if (isParameter(access)) {
            return "" + access.parent.parameters.indexOf(access);
        }
        return void 0;
    }
    function tryGetNameFromType(type) {
        return type.flags & 8192 ? type.escapedName : type.flags & 384 ? escapeLeadingUnderscores("" + type.value) : void 0;
    }
    function tryGetElementAccessExpressionName(node) {
        if (isStringOrNumericLiteralLike(node.argumentExpression)) {
            return escapeLeadingUnderscores(node.argumentExpression.text);
        }
        if (isEntityNameExpression(node.argumentExpression)) {
            const symbol = resolveEntityName(node.argumentExpression, 111551, true);
            if (!symbol || !(isConstVariable(symbol) || symbol.flags & 8)) return void 0;
            const declaration = symbol.valueDeclaration;
            if (declaration === void 0) return void 0;
            const type = tryGetTypeFromEffectiveTypeNode(declaration);
            if (type) {
                const name = tryGetNameFromType(type);
                if (name !== void 0) {
                    return name;
                }
            }
            if (hasOnlyExpressionInitializer(declaration) && isBlockScopedNameDeclaredBeforeUse(declaration, node.argumentExpression)) {
                const initializer = getEffectiveInitializer(declaration);
                if (initializer) {
                    return tryGetNameFromType(getTypeOfExpression(initializer));
                }
                if (isEnumMember(declaration)) {
                    return getTextOfPropertyName(declaration.name);
                }
            }
        }
        return void 0;
    }
    function containsMatchingReference(source, target) {
        while (isAccessExpression(source)) {
            source = source.expression;
            if (isMatchingReference(source, target)) {
                return true;
            }
        }
        return false;
    }
    function optionalChainContainsReference(source, target) {
        while (isOptionalChain(source)) {
            source = source.expression;
            if (isMatchingReference(source, target)) {
                return true;
            }
        }
        return false;
    }
    function isDiscriminantProperty(type, name) {
        if (type && type.flags & 1048576) {
            const prop = getUnionOrIntersectionProperty(type, name);
            if (prop && getCheckFlags(prop) & 2) {
                if (prop.links.isDiscriminantProperty === void 0) {
                    prop.links.isDiscriminantProperty = (prop.links.checkFlags & 192) === 192 && !isGenericType(getTypeOfSymbol(prop));
                }
                return !!prop.links.isDiscriminantProperty;
            }
        }
        return false;
    }
    function mapTypesByKeyProperty(types, name) {
        const map2 = /* @__PURE__ */new Map();
        let count = 0;
        for (const type of types) {
            if (type.flags & (524288 | 2097152 | 58982400)) {
                const discriminant = getTypeOfPropertyOfType(type, name);
                if (discriminant) {
                    if (!isLiteralType(discriminant)) {
                        return void 0;
                    }
                    let duplicate = false;
                    forEachType(discriminant, t => {
                        const id = getTypeId(getRegularTypeOfLiteralType(t));
                        const existing = map2.get(id);
                        if (!existing) {
                            map2.set(id, type);
                        } else if (existing !== unknownType) {
                            map2.set(id, unknownType);
                            duplicate = true;
                        }
                    });
                    if (!duplicate) count++;
                }
            }
        }
        return count >= 10 && count * 2 >= types.length ? map2 : void 0;
    }
    function getKeyPropertyName(unionType) {
        const types = unionType.types;
        if (types.length < 10 || getObjectFlags(unionType) & 32768 || countWhere(types, t => !!(t.flags & (524288 | 58982400))) < 10) {
            return void 0;
        }
        if (unionType.keyPropertyName === void 0) {
            const keyPropertyName = forEach(types, t => t.flags & (524288 | 58982400) ? forEach(getPropertiesOfType(t), p => isUnitType(getTypeOfSymbol(p)) ? p.escapedName : void 0) : void 0);
            const mapByKeyProperty = keyPropertyName && mapTypesByKeyProperty(types, keyPropertyName);
            unionType.keyPropertyName = mapByKeyProperty ? keyPropertyName : "";
            unionType.constituentMap = mapByKeyProperty;
        }
        return unionType.keyPropertyName.length ? unionType.keyPropertyName : void 0;
    }
    function getConstituentTypeForKeyType(unionType, keyType) {
        var _a2;
        const result = (_a2 = unionType.constituentMap) == null ? void 0 : _a2.get(getTypeId(getRegularTypeOfLiteralType(keyType)));
        return result !== unknownType ? result : void 0;
    }
    function getMatchingUnionConstituentForObjectLiteral(unionType, node) {
        const keyPropertyName = getKeyPropertyName(unionType);
        const propNode = keyPropertyName && find(node.properties, p => p.symbol && p.kind === 299 && p.symbol.escapedName === keyPropertyName && isPossiblyDiscriminantValue(p.initializer));
        const propType = propNode && getContextFreeTypeOfExpression(propNode.initializer);
        return propType && getConstituentTypeForKeyType(unionType, propType);
    }
    function isOrContainsMatchingReference(source, target) {
        return isMatchingReference(source, target) || containsMatchingReference(source, target);
    }
    function hasMatchingArgument(expression, reference) {
        if (expression.arguments) {
            for (const argument of expression.arguments) {
                if (isOrContainsMatchingReference(reference, argument)) {
                    return true;
                }
            }
        }
        if (expression.expression.kind === 208 && isOrContainsMatchingReference(reference, expression.expression.expression)) {
            return true;
        }
        return false;
    }
    function getFlowNodeId(flow) {
        if (!flow.id || flow.id < 0) {
            flow.id = nextFlowId;
            nextFlowId++;
        }
        return flow.id;
    }
    function typeMaybeAssignableTo(source, target) {
        if (!(source.flags & 1048576)) {
            return isTypeAssignableTo(source, target);
        }
        for (const t of source.types) {
            if (isTypeAssignableTo(t, target)) {
                return true;
            }
        }
        return false;
    }
    function getAssignmentReducedType(declaredType, assignedType) {
        var _a2;
        if (declaredType === assignedType) {
            return declaredType;
        }
        if (assignedType.flags & 131072) {
            return assignedType;
        }
        const key = `A${getTypeId(declaredType)},${getTypeId(assignedType)}`;
        return (_a2 = getCachedType(key)) != null ? _a2 : setCachedType(key, getAssignmentReducedTypeWorker(declaredType, assignedType));
    }
    function getAssignmentReducedTypeWorker(declaredType, assignedType) {
        const filteredType = filterType(declaredType, t => typeMaybeAssignableTo(assignedType, t));
        const reducedType = assignedType.flags & 512 && isFreshLiteralType(assignedType) ? mapType(filteredType, getFreshTypeOfLiteralType) : filteredType;
        return isTypeAssignableTo(assignedType, reducedType) ? reducedType : declaredType;
    }
    function isFunctionObjectType(type) {
        const resolved = resolveStructuredTypeMembers(type);
        return !!(resolved.callSignatures.length || resolved.constructSignatures.length || resolved.members.get("bind") && isTypeSubtypeOf(type, globalFunctionType));
    }
    function getTypeFacts(type) {
        if (type.flags & (2097152 | 465829888)) {
            type = getBaseConstraintOfType(type) || unknownType;
        }
        const flags = type.flags;
        if (flags & (4 | 268435456)) {
            return strictNullChecks ? 16317953 : 16776705;
        }
        if (flags & (128 | 134217728)) {
            const isEmpty = flags & 128 && type.value === "";
            return strictNullChecks ? isEmpty ? 12123649 : 7929345 : isEmpty ? 12582401 : 16776705;
        }
        if (flags & (8 | 32)) {
            return strictNullChecks ? 16317698 : 16776450;
        }
        if (flags & 256) {
            const isZero = type.value === 0;
            return strictNullChecks ? isZero ? 12123394 : 7929090 : isZero ? 12582146 : 16776450;
        }
        if (flags & 64) {
            return strictNullChecks ? 16317188 : 16775940;
        }
        if (flags & 2048) {
            const isZero = isZeroBigInt(type);
            return strictNullChecks ? isZero ? 12122884 : 7928580 : isZero ? 12581636 : 16775940;
        }
        if (flags & 16) {
            return strictNullChecks ? 16316168 : 16774920;
        }
        if (flags & 528) {
            return strictNullChecks ? type === falseType || type === regularFalseType ? 12121864 : 7927560 : type === falseType || type === regularFalseType ? 12580616 : 16774920;
        }
        if (flags & 524288) {
            return getObjectFlags(type) & 16 && isEmptyObjectType(type) ? strictNullChecks ? 83427327 : 83886079 : isFunctionObjectType(type) ? strictNullChecks ? 7880640 : 16728e3 : strictNullChecks ? 7888800 : 16736160;
        }
        if (flags & 16384) {
            return 9830144;
        }
        if (flags & 32768) {
            return 26607360;
        }
        if (flags & 65536) {
            return 42917664;
        }
        if (flags & 12288) {
            return strictNullChecks ? 7925520 : 16772880;
        }
        if (flags & 67108864) {
            return strictNullChecks ? 7888800 : 16736160;
        }
        if (flags & 131072) {
            return 0;
        }
        if (flags & 1048576) {
            return reduceLeft(type.types, (facts, t) => facts | getTypeFacts(t), 0);
        }
        if (flags & 2097152) {
            return getIntersectionTypeFacts(type);
        }
        return 83886079;
    }
    function getIntersectionTypeFacts(type) {
        const ignoreObjects = maybeTypeOfKind(type, 134348796);
        let oredFacts = 0;
        let andedFacts = 134217727;
        for (const t of type.types) {
            if (!(ignoreObjects && t.flags & 524288)) {
                const f = getTypeFacts(t);
                oredFacts |= f;
                andedFacts &= f;
            }
        }
        return oredFacts & 8256 | andedFacts & 134209471;
    }
    function getTypeWithFacts(type, include) {
        return filterType(type, t => (getTypeFacts(t) & include) !== 0);
    }
    function getAdjustedTypeWithFacts(type, facts) {
        const reduced = recombineUnknownType(getTypeWithFacts(strictNullChecks && type.flags & 2 ? unknownUnionType : type, facts));
        if (strictNullChecks) {
            switch (facts) {
                case 524288:
                    return mapType(reduced, t => getTypeFacts(t) & 65536 ? getIntersectionType([t, getTypeFacts(t) & 131072 && !maybeTypeOfKind(reduced, 65536) ? getUnionType([emptyObjectType, nullType]) : emptyObjectType]) : t);
                case 1048576:
                    return mapType(reduced, t => getTypeFacts(t) & 131072 ? getIntersectionType([t, getTypeFacts(t) & 65536 && !maybeTypeOfKind(reduced, 32768) ? getUnionType([emptyObjectType, undefinedType]) : emptyObjectType]) : t);
                case 2097152:
                case 4194304:
                    return mapType(reduced, t => getTypeFacts(t) & 262144 ? getGlobalNonNullableTypeInstantiation(t) : t);
            }
        }
        return reduced;
    }
    function recombineUnknownType(type) {
        return type === unknownUnionType ? unknownType : type;
    }
    function getTypeWithDefault(type, defaultExpression) {
        return defaultExpression ? getUnionType([getNonUndefinedType(type), getTypeOfExpression(defaultExpression)]) : type;
    }
    function getTypeOfDestructuredProperty(type, name) {
        var _a2;
        const nameType = getLiteralTypeFromPropertyName(name);
        if (!isTypeUsableAsPropertyName(nameType)) return errorType;
        const text = getPropertyNameFromType(nameType);
        return getTypeOfPropertyOfType(type, text) || includeUndefinedInIndexSignature((_a2 = getApplicableIndexInfoForName(type, text)) == null ? void 0 : _a2.type) || errorType;
    }
    function getTypeOfDestructuredArrayElement(type, index) {
        return everyType(type, isTupleLikeType) && getTupleElementType(type, index) || includeUndefinedInIndexSignature(checkIteratedTypeOrElementType(65, type, undefinedType, void 0)) || errorType;
    }
    function includeUndefinedInIndexSignature(type) {
        if (!type) return type;
        return compilerOptions.noUncheckedIndexedAccess ? getUnionType([type, missingType]) : type;
    }
    function getTypeOfDestructuredSpreadExpression(type) {
        return createArrayType(checkIteratedTypeOrElementType(65, type, undefinedType, void 0) || errorType);
    }
    function getAssignedTypeOfBinaryExpression(node) {
        const isDestructuringDefaultAssignment = node.parent.kind === 206 && isDestructuringAssignmentTarget(node.parent) || node.parent.kind === 299 && isDestructuringAssignmentTarget(node.parent.parent);
        return isDestructuringDefaultAssignment ? getTypeWithDefault(getAssignedType(node), node.right) : getTypeOfExpression(node.right);
    }
    function isDestructuringAssignmentTarget(parent2) {
        return parent2.parent.kind === 223 && parent2.parent.left === parent2 || parent2.parent.kind === 247 && parent2.parent.initializer === parent2;
    }
    function getAssignedTypeOfArrayLiteralElement(node, element) {
        return getTypeOfDestructuredArrayElement(getAssignedType(node), node.elements.indexOf(element));
    }
    function getAssignedTypeOfSpreadExpression(node) {
        return getTypeOfDestructuredSpreadExpression(getAssignedType(node.parent));
    }
    function getAssignedTypeOfPropertyAssignment(node) {
        return getTypeOfDestructuredProperty(getAssignedType(node.parent), node.name);
    }
    function getAssignedTypeOfShorthandPropertyAssignment(node) {
        return getTypeWithDefault(getAssignedTypeOfPropertyAssignment(node), node.objectAssignmentInitializer);
    }
    function getAssignedType(node) {
        const {
            parent: parent2
        } = node;
        switch (parent2.kind) {
            case 246:
                return stringType;
            case 247:
                return checkRightHandSideOfForOf(parent2) || errorType;
            case 223:
                return getAssignedTypeOfBinaryExpression(parent2);
            case 217:
                return undefinedType;
            case 206:
                return getAssignedTypeOfArrayLiteralElement(parent2, node);
            case 227:
                return getAssignedTypeOfSpreadExpression(parent2);
            case 299:
                return getAssignedTypeOfPropertyAssignment(parent2);
            case 300:
                return getAssignedTypeOfShorthandPropertyAssignment(parent2);
        }
        return errorType;
    }
    function getInitialTypeOfBindingElement(node) {
        const pattern = node.parent;
        const parentType = getInitialType(pattern.parent);
        const type = pattern.kind === 203 ? getTypeOfDestructuredProperty(parentType, node.propertyName || node.name) : !node.dotDotDotToken ? getTypeOfDestructuredArrayElement(parentType, pattern.elements.indexOf(node)) : getTypeOfDestructuredSpreadExpression(parentType);
        return getTypeWithDefault(type, node.initializer);
    }
    function getTypeOfInitializer(node) {
        const links = getNodeLinks(node);
        return links.resolvedType || getTypeOfExpression(node);
    }
    function getInitialTypeOfVariableDeclaration(node) {
        if (node.initializer) {
            return getTypeOfInitializer(node.initializer);
        }
        if (node.parent.parent.kind === 246) {
            return stringType;
        }
        if (node.parent.parent.kind === 247) {
            return checkRightHandSideOfForOf(node.parent.parent) || errorType;
        }
        return errorType;
    }
    function getInitialType(node) {
        return node.kind === 257 ? getInitialTypeOfVariableDeclaration(node) : getInitialTypeOfBindingElement(node);
    }
    function isEmptyArrayAssignment(node) {
        return node.kind === 257 && node.initializer && isEmptyArrayLiteral2(node.initializer) || node.kind !== 205 && node.parent.kind === 223 && isEmptyArrayLiteral2(node.parent.right);
    }
    function getReferenceCandidate(node) {
        switch (node.kind) {
            case 214:
                return getReferenceCandidate(node.expression);
            case 223:
                switch (node.operatorToken.kind) {
                    case 63:
                    case 75:
                    case 76:
                    case 77:
                        return getReferenceCandidate(node.left);
                    case 27:
                        return getReferenceCandidate(node.right);
                }
        }
        return node;
    }
    function getReferenceRoot(node) {
        const {
            parent: parent2
        } = node;
        return parent2.kind === 214 || parent2.kind === 223 && parent2.operatorToken.kind === 63 && parent2.left === node || parent2.kind === 223 && parent2.operatorToken.kind === 27 && parent2.right === node ? getReferenceRoot(parent2) : node;
    }
    function getTypeOfSwitchClause(clause) {
        if (clause.kind === 292) {
            return getRegularTypeOfLiteralType(getTypeOfExpression(clause.expression));
        }
        return neverType;
    }
    function getSwitchClauseTypes(switchStatement) {
        const links = getNodeLinks(switchStatement);
        if (!links.switchTypes) {
            links.switchTypes = [];
            for (const clause of switchStatement.caseBlock.clauses) {
                links.switchTypes.push(getTypeOfSwitchClause(clause));
            }
        }
        return links.switchTypes;
    }
    function getSwitchClauseTypeOfWitnesses(switchStatement) {
        if (some(switchStatement.caseBlock.clauses, clause => clause.kind === 292 && !isStringLiteralLike(clause.expression))) {
            return void 0;
        }
        const witnesses = [];
        for (const clause of switchStatement.caseBlock.clauses) {
            const text = clause.kind === 292 ? clause.expression.text : void 0;
            witnesses.push(text && !contains(witnesses, text) ? text : void 0);
        }
        return witnesses;
    }
    function eachTypeContainedIn(source, types) {
        return source.flags & 1048576 ? !forEach(source.types, t => !contains(types, t)) : contains(types, source);
    }
    function isTypeSubsetOf(source, target) {
        return source === target || target.flags & 1048576 && isTypeSubsetOfUnion(source, target);
    }
    function isTypeSubsetOfUnion(source, target) {
        if (source.flags & 1048576) {
            for (const t of source.types) {
                if (!containsType(target.types, t)) {
                    return false;
                }
            }
            return true;
        }
        if (source.flags & 1056 && getBaseTypeOfEnumLikeType(source) === target) {
            return true;
        }
        return containsType(target.types, source);
    }
    function forEachType(type, f) {
        return type.flags & 1048576 ? forEach(type.types, f) : f(type);
    }
    function someType(type, f) {
        return type.flags & 1048576 ? some(type.types, f) : f(type);
    }
    function everyType(type, f) {
        return type.flags & 1048576 ? every(type.types, f) : f(type);
    }
    function everyContainedType(type, f) {
        return type.flags & 3145728 ? every(type.types, f) : f(type);
    }
    function filterType(type, f) {
        if (type.flags & 1048576) {
            const types = type.types;
            const filtered = filter(types, f);
            if (filtered === types) {
                return type;
            }
            const origin = type.origin;
            let newOrigin;
            if (origin && origin.flags & 1048576) {
                const originTypes = origin.types;
                const originFiltered = filter(originTypes, t => !!(t.flags & 1048576) || f(t));
                if (originTypes.length - originFiltered.length === types.length - filtered.length) {
                    if (originFiltered.length === 1) {
                        return originFiltered[0];
                    }
                    newOrigin = createOriginUnionOrIntersectionType(1048576, originFiltered);
                }
            }
            return getUnionTypeFromSortedList(filtered, type.objectFlags & (32768 | 16777216), void 0, void 0, newOrigin);
        }
        return type.flags & 131072 || f(type) ? type : neverType;
    }
    function removeType(type, targetType) {
        return filterType(type, t => t !== targetType);
    }
    function mapType(type, mapper, noReductions) {
        if (type.flags & 131072) {
            return type;
        }
        if (!(type.flags & 1048576)) {
            return mapper(type);
        }
        const origin = type.origin;
        const types = origin && origin.flags & 1048576 ? origin.types : type.types;
        let mappedTypes;
        let changed = false;
        for (const t of types) {
            const mapped = t.flags & 1048576 ? mapType(t, mapper, noReductions) : mapper(t);
            changed || (changed = t !== mapped);
            if (mapped) {
                if (!mappedTypes) {
                    mappedTypes = [mapped];
                } else {
                    mappedTypes.push(mapped);
                }
            }
        }
        return changed ? mappedTypes && getUnionType(mappedTypes, noReductions ? 0 : 1) : type;
    }
    function mapTypeWithAlias(type, mapper, aliasSymbol, aliasTypeArguments) {
        return type.flags & 1048576 && aliasSymbol ? getUnionType(map(type.types, mapper), 1, aliasSymbol, aliasTypeArguments) : mapType(type, mapper);
    }
    function extractTypesOfKind(type, kind) {
        return filterType(type, t => (t.flags & kind) !== 0);
    }
    function replacePrimitivesWithLiterals(typeWithPrimitives, typeWithLiterals) {
        if (maybeTypeOfKind(typeWithPrimitives, 4 | 134217728 | 8 | 64) && maybeTypeOfKind(typeWithLiterals, 128 | 134217728 | 268435456 | 256 | 2048)) {
            return mapType(typeWithPrimitives, t => t.flags & 4 ? extractTypesOfKind(typeWithLiterals, 4 | 128 | 134217728 | 268435456) : isPatternLiteralType(t) && !maybeTypeOfKind(typeWithLiterals, 4 | 134217728 | 268435456) ? extractTypesOfKind(typeWithLiterals, 128) : t.flags & 8 ? extractTypesOfKind(typeWithLiterals, 8 | 256) : t.flags & 64 ? extractTypesOfKind(typeWithLiterals, 64 | 2048) : t);
        }
        return typeWithPrimitives;
    }
    function isIncomplete(flowType) {
        return flowType.flags === 0;
    }
    function getTypeFromFlowType(flowType) {
        return flowType.flags === 0 ? flowType.type : flowType;
    }
    function createFlowType(type, incomplete) {
        return incomplete ? {
            flags: 0,
            type: type.flags & 131072 ? silentNeverType : type
        } : type;
    }
    function createEvolvingArrayType(elementType) {
        const result = createObjectType(256);
        result.elementType = elementType;
        return result;
    }
    function getEvolvingArrayType(elementType) {
        return evolvingArrayTypes[elementType.id] || (evolvingArrayTypes[elementType.id] = createEvolvingArrayType(elementType));
    }
    function addEvolvingArrayElementType(evolvingArrayType, node) {
        const elementType = getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(getContextFreeTypeOfExpression(node)));
        return isTypeSubsetOf(elementType, evolvingArrayType.elementType) ? evolvingArrayType : getEvolvingArrayType(getUnionType([evolvingArrayType.elementType, elementType]));
    }
    function createFinalArrayType(elementType) {
        return elementType.flags & 131072 ? autoArrayType : createArrayType(elementType.flags & 1048576 ? getUnionType(elementType.types, 2) : elementType);
    }
    function getFinalArrayType(evolvingArrayType) {
        return evolvingArrayType.finalArrayType || (evolvingArrayType.finalArrayType = createFinalArrayType(evolvingArrayType.elementType));
    }
    function finalizeEvolvingArrayType(type) {
        return getObjectFlags(type) & 256 ? getFinalArrayType(type) : type;
    }
    function getElementTypeOfEvolvingArrayType(type) {
        return getObjectFlags(type) & 256 ? type.elementType : neverType;
    }
    function isEvolvingArrayTypeList(types) {
        let hasEvolvingArrayType = false;
        for (const t of types) {
            if (!(t.flags & 131072)) {
                if (!(getObjectFlags(t) & 256)) {
                    return false;
                }
                hasEvolvingArrayType = true;
            }
        }
        return hasEvolvingArrayType;
    }
    function isEvolvingArrayOperationTarget(node) {
        const root = getReferenceRoot(node);
        const parent2 = root.parent;
        const isLengthPushOrUnshift = isPropertyAccessExpression(parent2) && (parent2.name.escapedText === "length" || parent2.parent.kind === 210 && isIdentifier(parent2.name) && isPushOrUnshiftIdentifier(parent2.name));
        const isElementAssignment = parent2.kind === 209 && parent2.expression === root && parent2.parent.kind === 223 && parent2.parent.operatorToken.kind === 63 && parent2.parent.left === parent2 && !isAssignmentTarget(parent2.parent) && isTypeAssignableToKind(getTypeOfExpression(parent2.argumentExpression), 296);
        return isLengthPushOrUnshift || isElementAssignment;
    }
    function isDeclarationWithExplicitTypeAnnotation(node) {
        return (isVariableDeclaration(node) || isPropertyDeclaration(node) || isPropertySignature(node) || isParameter(node)) && !!(getEffectiveTypeAnnotationNode(node) || isInJSFile(node) && hasInitializer(node) && node.initializer && isFunctionExpressionOrArrowFunction(node.initializer) && getEffectiveReturnTypeNode(node.initializer));
    }
    function getExplicitTypeOfSymbol(symbol, diagnostic) {
        symbol = resolveSymbol(symbol);
        if (symbol.flags & (16 | 8192 | 32 | 512)) {
            return getTypeOfSymbol(symbol);
        }
        if (symbol.flags & (3 | 4)) {
            if (getCheckFlags(symbol) & 262144) {
                const origin = symbol.links.syntheticOrigin;
                if (origin && getExplicitTypeOfSymbol(origin)) {
                    return getTypeOfSymbol(symbol);
                }
            }
            const declaration = symbol.valueDeclaration;
            if (declaration) {
                if (isDeclarationWithExplicitTypeAnnotation(declaration)) {
                    return getTypeOfSymbol(symbol);
                }
                if (isVariableDeclaration(declaration) && declaration.parent.parent.kind === 247) {
                    const statement = declaration.parent.parent;
                    const expressionType = getTypeOfDottedName(statement.expression, void 0);
                    if (expressionType) {
                        const use = statement.awaitModifier ? 15 : 13;
                        return checkIteratedTypeOrElementType(use, expressionType, undefinedType, void 0);
                    }
                }
                if (diagnostic) {
                    addRelatedInfo(diagnostic, createDiagnosticForNode(declaration, Diagnostics._0_needs_an_explicit_type_annotation, symbolToString(symbol)));
                }
            }
        }
    }
    function getTypeOfDottedName(node, diagnostic) {
        if (!(node.flags & 33554432)) {
            switch (node.kind) {
                case 79:
                    const symbol = getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(node));
                    return getExplicitTypeOfSymbol(symbol, diagnostic);
                case 108:
                    return getExplicitThisType(node);
                case 106:
                    return checkSuperExpression(node);
                case 208:
                    {
                        const type = getTypeOfDottedName(node.expression, diagnostic);
                        if (type) {
                            const name = node.name;
                            let prop;
                            if (isPrivateIdentifier(name)) {
                                if (!type.symbol) {
                                    return void 0;
                                }
                                prop = getPropertyOfType(type, getSymbolNameForPrivateIdentifier(type.symbol, name.escapedText));
                            } else {
                                prop = getPropertyOfType(type, name.escapedText);
                            }
                            return prop && getExplicitTypeOfSymbol(prop, diagnostic);
                        }
                        return void 0;
                    }
                case 214:
                    return getTypeOfDottedName(node.expression, diagnostic);
            }
        }
    }
    function getEffectsSignature(node) {
        const links = getNodeLinks(node);
        let signature = links.effectsSignature;
        if (signature === void 0) {
            let funcType;
            if (node.parent.kind === 241) {
                funcType = getTypeOfDottedName(node.expression, void 0);
            } else if (node.expression.kind !== 106) {
                if (isOptionalChain(node)) {
                    funcType = checkNonNullType(getOptionalExpressionType(checkExpression(node.expression), node.expression), node.expression);
                } else {
                    funcType = checkNonNullExpression(node.expression);
                }
            }
            const signatures = getSignaturesOfType(funcType && getApparentType(funcType) || unknownType, 0);
            const candidate = signatures.length === 1 && !signatures[0].typeParameters ? signatures[0] : some(signatures, hasTypePredicateOrNeverReturnType) ? getResolvedSignature(node) : void 0;
            signature = links.effectsSignature = candidate && hasTypePredicateOrNeverReturnType(candidate) ? candidate : unknownSignature;
        }
        return signature === unknownSignature ? void 0 : signature;
    }
    function hasTypePredicateOrNeverReturnType(signature) {
        return !!(getTypePredicateOfSignature(signature) || signature.declaration && (getReturnTypeFromAnnotation(signature.declaration) || unknownType).flags & 131072);
    }
    function getTypePredicateArgument(predicate, callExpression) {
        if (predicate.kind === 1 || predicate.kind === 3) {
            return callExpression.arguments[predicate.parameterIndex];
        }
        const invokedExpression = skipParentheses(callExpression.expression);
        return isAccessExpression(invokedExpression) ? skipParentheses(invokedExpression.expression) : void 0;
    }
    function reportFlowControlError(node) {
        const block = findAncestor(node, isFunctionOrModuleBlock);
        const sourceFile = getSourceFileOfNode(node);
        const span = getSpanOfTokenAtPosition(sourceFile, block.statements.pos);
        diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.The_containing_function_or_module_body_is_too_large_for_control_flow_analysis));
    }
    function isReachableFlowNode(flow) {
        const result = isReachableFlowNodeWorker(flow, false);
        lastFlowNode = flow;
        lastFlowNodeReachable = result;
        return result;
    }
    function isFalseExpression(expr) {
        const node = skipParentheses(expr, true);
        return node.kind === 95 || node.kind === 223 && (node.operatorToken.kind === 55 && (isFalseExpression(node.left) || isFalseExpression(node.right)) || node.operatorToken.kind === 56 && isFalseExpression(node.left) && isFalseExpression(node.right));
    }
    function isReachableFlowNodeWorker(flow, noCacheCheck) {
        while (true) {
            if (flow === lastFlowNode) {
                return lastFlowNodeReachable;
            }
            const flags = flow.flags;
            if (flags & 4096) {
                if (!noCacheCheck) {
                    const id = getFlowNodeId(flow);
                    const reachable = flowNodeReachable[id];
                    return reachable !== void 0 ? reachable : flowNodeReachable[id] = isReachableFlowNodeWorker(flow, true);
                }
                noCacheCheck = false;
            }
            if (flags & (16 | 96 | 256)) {
                flow = flow.antecedent;
            } else if (flags & 512) {
                const signature = getEffectsSignature(flow.node);
                if (signature) {
                    const predicate = getTypePredicateOfSignature(signature);
                    if (predicate && predicate.kind === 3 && !predicate.type) {
                        const predicateArgument = flow.node.arguments[predicate.parameterIndex];
                        if (predicateArgument && isFalseExpression(predicateArgument)) {
                            return false;
                        }
                    }
                    if (getReturnTypeOfSignature(signature).flags & 131072) {
                        return false;
                    }
                }
                flow = flow.antecedent;
            } else if (flags & 4) {
                return some(flow.antecedents, f => isReachableFlowNodeWorker(f, false));
            } else if (flags & 8) {
                const antecedents = flow.antecedents;
                if (antecedents === void 0 || antecedents.length === 0) {
                    return false;
                }
                flow = antecedents[0];
            } else if (flags & 128) {
                if (flow.clauseStart === flow.clauseEnd && isExhaustiveSwitchStatement(flow.switchStatement)) {
                    return false;
                }
                flow = flow.antecedent;
            } else if (flags & 1024) {
                lastFlowNode = void 0;
                const target = flow.target;
                const saveAntecedents = target.antecedents;
                target.antecedents = flow.antecedents;
                const result = isReachableFlowNodeWorker(flow.antecedent, false);
                target.antecedents = saveAntecedents;
                return result;
            } else {
                return !(flags & 1);
            }
        }
    }
    function isPostSuperFlowNode(flow, noCacheCheck) {
        while (true) {
            const flags = flow.flags;
            if (flags & 4096) {
                if (!noCacheCheck) {
                    const id = getFlowNodeId(flow);
                    const postSuper = flowNodePostSuper[id];
                    return postSuper !== void 0 ? postSuper : flowNodePostSuper[id] = isPostSuperFlowNode(flow, true);
                }
                noCacheCheck = false;
            }
            if (flags & (16 | 96 | 256 | 128)) {
                flow = flow.antecedent;
            } else if (flags & 512) {
                if (flow.node.expression.kind === 106) {
                    return true;
                }
                flow = flow.antecedent;
            } else if (flags & 4) {
                return every(flow.antecedents, f => isPostSuperFlowNode(f, false));
            } else if (flags & 8) {
                flow = flow.antecedents[0];
            } else if (flags & 1024) {
                const target = flow.target;
                const saveAntecedents = target.antecedents;
                target.antecedents = flow.antecedents;
                const result = isPostSuperFlowNode(flow.antecedent, false);
                target.antecedents = saveAntecedents;
                return result;
            } else {
                return !!(flags & 1);
            }
        }
    }
    function isConstantReference(node) {
        switch (node.kind) {
            case 79:
                if (!isThisInTypeQuery(node)) {
                    const symbol = getResolvedSymbol(node);
                    return isConstVariable(symbol) || isParameterOrCatchClauseVariable(symbol) && !isSymbolAssigned(symbol);
                }
                break;
            case 208:
            case 209:
                return isConstantReference(node.expression) && isReadonlySymbol(getNodeLinks(node).resolvedSymbol || unknownSymbol);
        }
        return false;
    }
    function getFlowTypeOfReference(reference, declaredType, initialType = declaredType, flowContainer, flowNode = (_a2 => (_a2 = tryCast(reference, canHaveFlowNode)) == null ? void 0 : _a2.flowNode)()) {
        let key;
        let isKeySet = false;
        let flowDepth = 0;
        if (flowAnalysisDisabled) {
            return errorType;
        }
        if (!flowNode) {
            return declaredType;
        }
        flowInvocationCount++;
        const sharedFlowStart = sharedFlowCount;
        const evolvedType = getTypeFromFlowType(getTypeAtFlowNode(flowNode));
        sharedFlowCount = sharedFlowStart;
        const resultType = getObjectFlags(evolvedType) & 256 && isEvolvingArrayOperationTarget(reference) ? autoArrayType : finalizeEvolvingArrayType(evolvedType);
        if (resultType === unreachableNeverType || reference.parent && reference.parent.kind === 232 && !(resultType.flags & 131072) && getTypeWithFacts(resultType, 2097152).flags & 131072) {
            return declaredType;
        }
        return resultType === nonNullUnknownType ? unknownType : resultType;
        function getOrSetCacheKey() {
            if (isKeySet) {
                return key;
            }
            isKeySet = true;
            return key = getFlowCacheKey(reference, declaredType, initialType, flowContainer);
        }
        function getTypeAtFlowNode(flow) {
            var _a3;
            if (flowDepth === 2e3) {
                (_a3 = tracing) == null ? void 0 : _a3.instant(tracing.Phase.CheckTypes, "getTypeAtFlowNode_DepthLimit", {
                    flowId: flow.id
                });
                flowAnalysisDisabled = true;
                reportFlowControlError(reference);
                return errorType;
            }
            flowDepth++;
            let sharedFlow;
            while (true) {
                const flags = flow.flags;
                if (flags & 4096) {
                    for (let i = sharedFlowStart; i < sharedFlowCount; i++) {
                        if (sharedFlowNodes[i] === flow) {
                            flowDepth--;
                            return sharedFlowTypes[i];
                        }
                    }
                    sharedFlow = flow;
                }
                let type;
                if (flags & 16) {
                    type = getTypeAtFlowAssignment(flow);
                    if (!type) {
                        flow = flow.antecedent;
                        continue;
                    }
                } else if (flags & 512) {
                    type = getTypeAtFlowCall(flow);
                    if (!type) {
                        flow = flow.antecedent;
                        continue;
                    }
                } else if (flags & 96) {
                    type = getTypeAtFlowCondition(flow);
                } else if (flags & 128) {
                    type = getTypeAtSwitchClause(flow);
                } else if (flags & 12) {
                    if (flow.antecedents.length === 1) {
                        flow = flow.antecedents[0];
                        continue;
                    }
                    type = flags & 4 ? getTypeAtFlowBranchLabel(flow) : getTypeAtFlowLoopLabel(flow);
                } else if (flags & 256) {
                    type = getTypeAtFlowArrayMutation(flow);
                    if (!type) {
                        flow = flow.antecedent;
                        continue;
                    }
                } else if (flags & 1024) {
                    const target = flow.target;
                    const saveAntecedents = target.antecedents;
                    target.antecedents = flow.antecedents;
                    type = getTypeAtFlowNode(flow.antecedent);
                    target.antecedents = saveAntecedents;
                } else if (flags & 2) {
                    const container = flow.node;
                    if (container && container !== flowContainer && reference.kind !== 208 && reference.kind !== 209 && reference.kind !== 108) {
                        flow = container.flowNode;
                        continue;
                    }
                    type = initialType;
                } else {
                    type = convertAutoToAny(declaredType);
                }
                if (sharedFlow) {
                    sharedFlowNodes[sharedFlowCount] = sharedFlow;
                    sharedFlowTypes[sharedFlowCount] = type;
                    sharedFlowCount++;
                }
                flowDepth--;
                return type;
            }
        }
        function getInitialOrAssignedType(flow) {
            const node = flow.node;
            return getNarrowableTypeForReference(node.kind === 257 || node.kind === 205 ? getInitialType(node) : getAssignedType(node), reference);
        }
        function getTypeAtFlowAssignment(flow) {
            const node = flow.node;
            if (isMatchingReference(reference, node)) {
                if (!isReachableFlowNode(flow)) {
                    return unreachableNeverType;
                }
                if (getAssignmentTargetKind(node) === 2) {
                    const flowType = getTypeAtFlowNode(flow.antecedent);
                    return createFlowType(getBaseTypeOfLiteralType(getTypeFromFlowType(flowType)), isIncomplete(flowType));
                }
                if (declaredType === autoType || declaredType === autoArrayType) {
                    if (isEmptyArrayAssignment(node)) {
                        return getEvolvingArrayType(neverType);
                    }
                    const assignedType = getWidenedLiteralType(getInitialOrAssignedType(flow));
                    return isTypeAssignableTo(assignedType, declaredType) ? assignedType : anyArrayType;
                }
                if (declaredType.flags & 1048576) {
                    return getAssignmentReducedType(declaredType, getInitialOrAssignedType(flow));
                }
                return declaredType;
            }
            if (containsMatchingReference(reference, node)) {
                if (!isReachableFlowNode(flow)) {
                    return unreachableNeverType;
                }
                if (isVariableDeclaration(node) && (isInJSFile(node) || isVarConst(node))) {
                    const init = getDeclaredExpandoInitializer(node);
                    if (init && (init.kind === 215 || init.kind === 216)) {
                        return getTypeAtFlowNode(flow.antecedent);
                    }
                }
                return declaredType;
            }
            if (isVariableDeclaration(node) && node.parent.parent.kind === 246 && (isMatchingReference(reference, node.parent.parent.expression) || optionalChainContainsReference(node.parent.parent.expression, reference))) {
                return getNonNullableTypeIfNeeded(finalizeEvolvingArrayType(getTypeFromFlowType(getTypeAtFlowNode(flow.antecedent))));
            }
            return void 0;
        }
        function narrowTypeByAssertion(type, expr) {
            const node = skipParentheses(expr, true);
            if (node.kind === 95) {
                return unreachableNeverType;
            }
            if (node.kind === 223) {
                if (node.operatorToken.kind === 55) {
                    return narrowTypeByAssertion(narrowTypeByAssertion(type, node.left), node.right);
                }
                if (node.operatorToken.kind === 56) {
                    return getUnionType([narrowTypeByAssertion(type, node.left), narrowTypeByAssertion(type, node.right)]);
                }
            }
            return narrowType(type, node, true);
        }
        function getTypeAtFlowCall(flow) {
            const signature = getEffectsSignature(flow.node);
            if (signature) {
                const predicate = getTypePredicateOfSignature(signature);
                if (predicate && (predicate.kind === 2 || predicate.kind === 3)) {
                    const flowType = getTypeAtFlowNode(flow.antecedent);
                    const type = finalizeEvolvingArrayType(getTypeFromFlowType(flowType));
                    const narrowedType = predicate.type ? narrowTypeByTypePredicate(type, predicate, flow.node, true) : predicate.kind === 3 && predicate.parameterIndex >= 0 && predicate.parameterIndex < flow.node.arguments.length ? narrowTypeByAssertion(type, flow.node.arguments[predicate.parameterIndex]) : type;
                    return narrowedType === type ? flowType : createFlowType(narrowedType, isIncomplete(flowType));
                }
                if (getReturnTypeOfSignature(signature).flags & 131072) {
                    return unreachableNeverType;
                }
            }
            return void 0;
        }
        function getTypeAtFlowArrayMutation(flow) {
            if (declaredType === autoType || declaredType === autoArrayType) {
                const node = flow.node;
                const expr = node.kind === 210 ? node.expression.expression : node.left.expression;
                if (isMatchingReference(reference, getReferenceCandidate(expr))) {
                    const flowType = getTypeAtFlowNode(flow.antecedent);
                    const type = getTypeFromFlowType(flowType);
                    if (getObjectFlags(type) & 256) {
                        let evolvedType2 = type;
                        if (node.kind === 210) {
                            for (const arg of node.arguments) {
                                evolvedType2 = addEvolvingArrayElementType(evolvedType2, arg);
                            }
                        } else {
                            const indexType = getContextFreeTypeOfExpression(node.left.argumentExpression);
                            if (isTypeAssignableToKind(indexType, 296)) {
                                evolvedType2 = addEvolvingArrayElementType(evolvedType2, node.right);
                            }
                        }
                        return evolvedType2 === type ? flowType : createFlowType(evolvedType2, isIncomplete(flowType));
                    }
                    return flowType;
                }
            }
            return void 0;
        }
        function getTypeAtFlowCondition(flow) {
            const flowType = getTypeAtFlowNode(flow.antecedent);
            const type = getTypeFromFlowType(flowType);
            if (type.flags & 131072) {
                return flowType;
            }
            const assumeTrue = (flow.flags & 32) !== 0;
            const nonEvolvingType = finalizeEvolvingArrayType(type);
            const narrowedType = narrowType(nonEvolvingType, flow.node, assumeTrue);
            if (narrowedType === nonEvolvingType) {
                return flowType;
            }
            return createFlowType(narrowedType, isIncomplete(flowType));
        }
        function getTypeAtSwitchClause(flow) {
            const expr = flow.switchStatement.expression;
            const flowType = getTypeAtFlowNode(flow.antecedent);
            let type = getTypeFromFlowType(flowType);
            if (isMatchingReference(reference, expr)) {
                type = narrowTypeBySwitchOnDiscriminant(type, flow.switchStatement, flow.clauseStart, flow.clauseEnd);
            } else if (expr.kind === 218 && isMatchingReference(reference, expr.expression)) {
                type = narrowTypeBySwitchOnTypeOf(type, flow.switchStatement, flow.clauseStart, flow.clauseEnd);
            } else {
                if (strictNullChecks) {
                    if (optionalChainContainsReference(expr, reference)) {
                        type = narrowTypeBySwitchOptionalChainContainment(type, flow.switchStatement, flow.clauseStart, flow.clauseEnd, t => !(t.flags & (32768 | 131072)));
                    } else if (expr.kind === 218 && optionalChainContainsReference(expr.expression, reference)) {
                        type = narrowTypeBySwitchOptionalChainContainment(type, flow.switchStatement, flow.clauseStart, flow.clauseEnd, t => !(t.flags & 131072 || t.flags & 128 && t.value === "undefined"));
                    }
                }
                const access = getDiscriminantPropertyAccess(expr, type);
                if (access) {
                    type = narrowTypeBySwitchOnDiscriminantProperty(type, access, flow.switchStatement, flow.clauseStart, flow.clauseEnd);
                }
            }
            return createFlowType(type, isIncomplete(flowType));
        }
        function getTypeAtFlowBranchLabel(flow) {
            const antecedentTypes = [];
            let subtypeReduction = false;
            let seenIncomplete = false;
            let bypassFlow;
            for (const antecedent of flow.antecedents) {
                if (!bypassFlow && antecedent.flags & 128 && antecedent.clauseStart === antecedent.clauseEnd) {
                    bypassFlow = antecedent;
                    continue;
                }
                const flowType = getTypeAtFlowNode(antecedent);
                const type = getTypeFromFlowType(flowType);
                if (type === declaredType && declaredType === initialType) {
                    return type;
                }
                pushIfUnique(antecedentTypes, type);
                if (!isTypeSubsetOf(type, declaredType)) {
                    subtypeReduction = true;
                }
                if (isIncomplete(flowType)) {
                    seenIncomplete = true;
                }
            }
            if (bypassFlow) {
                const flowType = getTypeAtFlowNode(bypassFlow);
                const type = getTypeFromFlowType(flowType);
                if (!(type.flags & 131072) && !contains(antecedentTypes, type) && !isExhaustiveSwitchStatement(bypassFlow.switchStatement)) {
                    if (type === declaredType && declaredType === initialType) {
                        return type;
                    }
                    antecedentTypes.push(type);
                    if (!isTypeSubsetOf(type, declaredType)) {
                        subtypeReduction = true;
                    }
                    if (isIncomplete(flowType)) {
                        seenIncomplete = true;
                    }
                }
            }
            return createFlowType(getUnionOrEvolvingArrayType(antecedentTypes, subtypeReduction ? 2 : 1), seenIncomplete);
        }
        function getTypeAtFlowLoopLabel(flow) {
            const id = getFlowNodeId(flow);
            const cache = flowLoopCaches[id] || (flowLoopCaches[id] = /* @__PURE__ */new Map());
            const key2 = getOrSetCacheKey();
            if (!key2) {
                return declaredType;
            }
            const cached = cache.get(key2);
            if (cached) {
                return cached;
            }
            for (let i = flowLoopStart; i < flowLoopCount; i++) {
                if (flowLoopNodes[i] === flow && flowLoopKeys[i] === key2 && flowLoopTypes[i].length) {
                    return createFlowType(getUnionOrEvolvingArrayType(flowLoopTypes[i], 1), true);
                }
            }
            const antecedentTypes = [];
            let subtypeReduction = false;
            let firstAntecedentType;
            for (const antecedent of flow.antecedents) {
                let flowType;
                if (!firstAntecedentType) {
                    flowType = firstAntecedentType = getTypeAtFlowNode(antecedent);
                } else {
                    flowLoopNodes[flowLoopCount] = flow;
                    flowLoopKeys[flowLoopCount] = key2;
                    flowLoopTypes[flowLoopCount] = antecedentTypes;
                    flowLoopCount++;
                    const saveFlowTypeCache = flowTypeCache;
                    flowTypeCache = void 0;
                    flowType = getTypeAtFlowNode(antecedent);
                    flowTypeCache = saveFlowTypeCache;
                    flowLoopCount--;
                    const cached2 = cache.get(key2);
                    if (cached2) {
                        return cached2;
                    }
                }
                const type = getTypeFromFlowType(flowType);
                pushIfUnique(antecedentTypes, type);
                if (!isTypeSubsetOf(type, declaredType)) {
                    subtypeReduction = true;
                }
                if (type === declaredType) {
                    break;
                }
            }
            const result = getUnionOrEvolvingArrayType(antecedentTypes, subtypeReduction ? 2 : 1);
            if (isIncomplete(firstAntecedentType)) {
                return createFlowType(result, true);
            }
            cache.set(key2, result);
            return result;
        }
        function getUnionOrEvolvingArrayType(types, subtypeReduction) {
            if (isEvolvingArrayTypeList(types)) {
                return getEvolvingArrayType(getUnionType(map(types, getElementTypeOfEvolvingArrayType)));
            }
            const result = recombineUnknownType(getUnionType(sameMap(types, finalizeEvolvingArrayType), subtypeReduction));
            if (result !== declaredType && result.flags & declaredType.flags & 1048576 && arraysEqual(result.types, declaredType.types)) {
                return declaredType;
            }
            return result;
        }
        function getCandidateDiscriminantPropertyAccess(expr) {
            if (isBindingPattern(reference) || isFunctionExpressionOrArrowFunction(reference) || isObjectLiteralMethod(reference)) {
                if (isIdentifier(expr)) {
                    const symbol = getResolvedSymbol(expr);
                    const declaration = symbol.valueDeclaration;
                    if (declaration && (isBindingElement(declaration) || isParameter(declaration)) && reference === declaration.parent && !declaration.initializer && !declaration.dotDotDotToken) {
                        return declaration;
                    }
                }
            } else if (isAccessExpression(expr)) {
                if (isMatchingReference(reference, expr.expression)) {
                    return expr;
                }
            } else if (isIdentifier(expr)) {
                const symbol = getResolvedSymbol(expr);
                if (isConstVariable(symbol)) {
                    const declaration = symbol.valueDeclaration;
                    if (isVariableDeclaration(declaration) && !declaration.type && declaration.initializer && isAccessExpression(declaration.initializer) && isMatchingReference(reference, declaration.initializer.expression)) {
                        return declaration.initializer;
                    }
                    if (isBindingElement(declaration) && !declaration.initializer) {
                        const parent2 = declaration.parent.parent;
                        if (isVariableDeclaration(parent2) && !parent2.type && parent2.initializer && (isIdentifier(parent2.initializer) || isAccessExpression(parent2.initializer)) && isMatchingReference(reference, parent2.initializer)) {
                            return declaration;
                        }
                    }
                }
            }
            return void 0;
        }
        function getDiscriminantPropertyAccess(expr, computedType) {
            const type = declaredType.flags & 1048576 ? declaredType : computedType;
            if (type.flags & 1048576) {
                const access = getCandidateDiscriminantPropertyAccess(expr);
                if (access) {
                    const name = getAccessedPropertyName(access);
                    if (name && isDiscriminantProperty(type, name)) {
                        return access;
                    }
                }
            }
            return void 0;
        }
        function narrowTypeByDiscriminant(type, access, narrowType2) {
            const propName = getAccessedPropertyName(access);
            if (propName === void 0) {
                return type;
            }
            const optionalChain = isOptionalChain(access);
            const removeNullable = strictNullChecks && (optionalChain || isNonNullAccess(access)) && maybeTypeOfKind(type, 98304);
            let propType = getTypeOfPropertyOfType(removeNullable ? getTypeWithFacts(type, 2097152) : type, propName);
            if (!propType) {
                return type;
            }
            propType = removeNullable && optionalChain ? getOptionalType(propType) : propType;
            const narrowedPropType = narrowType2(propType);
            return filterType(type, t => {
                const discriminantType = getTypeOfPropertyOrIndexSignature(t, propName);
                return !(discriminantType.flags & 131072) && !(narrowedPropType.flags & 131072) && areTypesComparable(narrowedPropType, discriminantType);
            });
        }
        function narrowTypeByDiscriminantProperty(type, access, operator, value, assumeTrue) {
            if ((operator === 36 || operator === 37) && type.flags & 1048576) {
                const keyPropertyName = getKeyPropertyName(type);
                if (keyPropertyName && keyPropertyName === getAccessedPropertyName(access)) {
                    const candidate = getConstituentTypeForKeyType(type, getTypeOfExpression(value));
                    if (candidate) {
                        return operator === (assumeTrue ? 36 : 37) ? candidate : isUnitType(getTypeOfPropertyOfType(candidate, keyPropertyName) || unknownType) ? removeType(type, candidate) : type;
                    }
                }
            }
            return narrowTypeByDiscriminant(type, access, t => narrowTypeByEquality(t, operator, value, assumeTrue));
        }
        function narrowTypeBySwitchOnDiscriminantProperty(type, access, switchStatement, clauseStart, clauseEnd) {
            if (clauseStart < clauseEnd && type.flags & 1048576 && getKeyPropertyName(type) === getAccessedPropertyName(access)) {
                const clauseTypes = getSwitchClauseTypes(switchStatement).slice(clauseStart, clauseEnd);
                const candidate = getUnionType(map(clauseTypes, t => getConstituentTypeForKeyType(type, t) || unknownType));
                if (candidate !== unknownType) {
                    return candidate;
                }
            }
            return narrowTypeByDiscriminant(type, access, t => narrowTypeBySwitchOnDiscriminant(t, switchStatement, clauseStart, clauseEnd));
        }
        function narrowTypeByTruthiness(type, expr, assumeTrue) {
            if (isMatchingReference(reference, expr)) {
                return getAdjustedTypeWithFacts(type, assumeTrue ? 4194304 : 8388608);
            }
            if (strictNullChecks && assumeTrue && optionalChainContainsReference(expr, reference)) {
                type = getAdjustedTypeWithFacts(type, 2097152);
            }
            const access = getDiscriminantPropertyAccess(expr, type);
            if (access) {
                return narrowTypeByDiscriminant(type, access, t => getTypeWithFacts(t, assumeTrue ? 4194304 : 8388608));
            }
            return type;
        }
        function isTypePresencePossible(type, propName, assumeTrue) {
            const prop = getPropertyOfType(type, propName);
            return prop ? !!(prop.flags & 16777216) || assumeTrue : !!getApplicableIndexInfoForName(type, propName) || !assumeTrue;
        }
        function narrowTypeByInKeyword(type, nameType, assumeTrue) {
            const name = getPropertyNameFromType(nameType);
            const isKnownProperty2 = someType(type, t => isTypePresencePossible(t, name, true));
            if (isKnownProperty2) {
                return filterType(type, t => isTypePresencePossible(t, name, assumeTrue));
            }
            if (assumeTrue) {
                const recordSymbol = getGlobalRecordSymbol();
                if (recordSymbol) {
                    return getIntersectionType([type, getTypeAliasInstantiation(recordSymbol, [nameType, unknownType])]);
                }
            }
            return type;
        }
        function narrowTypeByBinaryExpression(type, expr, assumeTrue) {
            switch (expr.operatorToken.kind) {
                case 63:
                case 75:
                case 76:
                case 77:
                    return narrowTypeByTruthiness(narrowType(type, expr.right, assumeTrue), expr.left, assumeTrue);
                case 34:
                case 35:
                case 36:
                case 37:
                    const operator = expr.operatorToken.kind;
                    const left = getReferenceCandidate(expr.left);
                    const right = getReferenceCandidate(expr.right);
                    if (left.kind === 218 && isStringLiteralLike(right)) {
                        return narrowTypeByTypeof(type, left, operator, right, assumeTrue);
                    }
                    if (right.kind === 218 && isStringLiteralLike(left)) {
                        return narrowTypeByTypeof(type, right, operator, left, assumeTrue);
                    }
                    if (isMatchingReference(reference, left)) {
                        return narrowTypeByEquality(type, operator, right, assumeTrue);
                    }
                    if (isMatchingReference(reference, right)) {
                        return narrowTypeByEquality(type, operator, left, assumeTrue);
                    }
                    if (strictNullChecks) {
                        if (optionalChainContainsReference(left, reference)) {
                            type = narrowTypeByOptionalChainContainment(type, operator, right, assumeTrue);
                        } else if (optionalChainContainsReference(right, reference)) {
                            type = narrowTypeByOptionalChainContainment(type, operator, left, assumeTrue);
                        }
                    }
                    const leftAccess = getDiscriminantPropertyAccess(left, type);
                    if (leftAccess) {
                        return narrowTypeByDiscriminantProperty(type, leftAccess, operator, right, assumeTrue);
                    }
                    const rightAccess = getDiscriminantPropertyAccess(right, type);
                    if (rightAccess) {
                        return narrowTypeByDiscriminantProperty(type, rightAccess, operator, left, assumeTrue);
                    }
                    if (isMatchingConstructorReference(left)) {
                        return narrowTypeByConstructor(type, operator, right, assumeTrue);
                    }
                    if (isMatchingConstructorReference(right)) {
                        return narrowTypeByConstructor(type, operator, left, assumeTrue);
                    }
                    break;
                case 102:
                    return narrowTypeByInstanceof(type, expr, assumeTrue);
                case 101:
                    if (isPrivateIdentifier(expr.left)) {
                        return narrowTypeByPrivateIdentifierInInExpression(type, expr, assumeTrue);
                    }
                    const target = getReferenceCandidate(expr.right);
                    const leftType = getTypeOfExpression(expr.left);
                    if (leftType.flags & 8576) {
                        if (containsMissingType(type) && isAccessExpression(reference) && isMatchingReference(reference.expression, target) && getAccessedPropertyName(reference) === getPropertyNameFromType(leftType)) {
                            return getTypeWithFacts(type, assumeTrue ? 524288 : 65536);
                        }
                        if (isMatchingReference(reference, target)) {
                            return narrowTypeByInKeyword(type, leftType, assumeTrue);
                        }
                    }
                    break;
                case 27:
                    return narrowType(type, expr.right, assumeTrue);
                case 55:
                    return assumeTrue ? narrowType(narrowType(type, expr.left, true), expr.right, true) : getUnionType([narrowType(type, expr.left, false), narrowType(type, expr.right, false)]);
                case 56:
                    return assumeTrue ? getUnionType([narrowType(type, expr.left, true), narrowType(type, expr.right, true)]) : narrowType(narrowType(type, expr.left, false), expr.right, false);
            }
            return type;
        }
        function narrowTypeByPrivateIdentifierInInExpression(type, expr, assumeTrue) {
            const target = getReferenceCandidate(expr.right);
            if (!isMatchingReference(reference, target)) {
                return type;
            }
            Debug.assertNode(expr.left, isPrivateIdentifier);
            const symbol = getSymbolForPrivateIdentifierExpression(expr.left);
            if (symbol === void 0) {
                return type;
            }
            const classSymbol = symbol.parent;
            const targetType = hasStaticModifier(Debug.checkDefined(symbol.valueDeclaration, "should always have a declaration")) ? getTypeOfSymbol(classSymbol) : getDeclaredTypeOfSymbol(classSymbol);
            return getNarrowedType(type, targetType, assumeTrue, true);
        }
        function narrowTypeByOptionalChainContainment(type, operator, value, assumeTrue) {
            const equalsOperator = operator === 34 || operator === 36;
            const nullableFlags = operator === 34 || operator === 35 ? 98304 : 32768;
            const valueType = getTypeOfExpression(value);
            const removeNullable = equalsOperator !== assumeTrue && everyType(valueType, t => !!(t.flags & nullableFlags)) || equalsOperator === assumeTrue && everyType(valueType, t => !(t.flags & (3 | nullableFlags)));
            return removeNullable ? getAdjustedTypeWithFacts(type, 2097152) : type;
        }
        function narrowTypeByEquality(type, operator, value, assumeTrue) {
            if (type.flags & 1) {
                return type;
            }
            if (operator === 35 || operator === 37) {
                assumeTrue = !assumeTrue;
            }
            const valueType = getTypeOfExpression(value);
            const doubleEquals = operator === 34 || operator === 35;
            if (valueType.flags & 98304) {
                if (!strictNullChecks) {
                    return type;
                }
                const facts = doubleEquals ? assumeTrue ? 262144 : 2097152 : valueType.flags & 65536 ? assumeTrue ? 131072 : 1048576 : assumeTrue ? 65536 : 524288;
                return getAdjustedTypeWithFacts(type, facts);
            }
            if (assumeTrue) {
                if (!doubleEquals && (type.flags & 2 || someType(type, isEmptyAnonymousObjectType))) {
                    if (valueType.flags & (134348796 | 67108864) || isEmptyAnonymousObjectType(valueType)) {
                        return valueType;
                    }
                    if (valueType.flags & 524288) {
                        return nonPrimitiveType;
                    }
                }
                const filteredType = filterType(type, t => areTypesComparable(t, valueType) || doubleEquals && isCoercibleUnderDoubleEquals(t, valueType));
                return replacePrimitivesWithLiterals(filteredType, valueType);
            }
            if (isUnitType(valueType)) {
                return filterType(type, t => !(isUnitLikeType(t) && areTypesComparable(t, valueType)));
            }
            return type;
        }
        function narrowTypeByTypeof(type, typeOfExpr, operator, literal, assumeTrue) {
            if (operator === 35 || operator === 37) {
                assumeTrue = !assumeTrue;
            }
            const target = getReferenceCandidate(typeOfExpr.expression);
            if (!isMatchingReference(reference, target)) {
                if (strictNullChecks && optionalChainContainsReference(target, reference) && assumeTrue === (literal.text !== "undefined")) {
                    type = getAdjustedTypeWithFacts(type, 2097152);
                }
                const propertyAccess = getDiscriminantPropertyAccess(target, type);
                if (propertyAccess) {
                    return narrowTypeByDiscriminant(type, propertyAccess, t => narrowTypeByLiteralExpression(t, literal, assumeTrue));
                }
                return type;
            }
            return narrowTypeByLiteralExpression(type, literal, assumeTrue);
        }
        function narrowTypeByLiteralExpression(type, literal, assumeTrue) {
            return assumeTrue ? narrowTypeByTypeName(type, literal.text) : getAdjustedTypeWithFacts(type, typeofNEFacts.get(literal.text) || 32768);
        }
        function narrowTypeBySwitchOptionalChainContainment(type, switchStatement, clauseStart, clauseEnd, clauseCheck) {
            const everyClauseChecks = clauseStart !== clauseEnd && every(getSwitchClauseTypes(switchStatement).slice(clauseStart, clauseEnd), clauseCheck);
            return everyClauseChecks ? getTypeWithFacts(type, 2097152) : type;
        }
        function narrowTypeBySwitchOnDiscriminant(type, switchStatement, clauseStart, clauseEnd) {
            const switchTypes = getSwitchClauseTypes(switchStatement);
            if (!switchTypes.length) {
                return type;
            }
            const clauseTypes = switchTypes.slice(clauseStart, clauseEnd);
            const hasDefaultClause = clauseStart === clauseEnd || contains(clauseTypes, neverType);
            if (type.flags & 2 && !hasDefaultClause) {
                let groundClauseTypes;
                for (let i = 0; i < clauseTypes.length; i += 1) {
                    const t = clauseTypes[i];
                    if (t.flags & (134348796 | 67108864)) {
                        if (groundClauseTypes !== void 0) {
                            groundClauseTypes.push(t);
                        }
                    } else if (t.flags & 524288) {
                        if (groundClauseTypes === void 0) {
                            groundClauseTypes = clauseTypes.slice(0, i);
                        }
                        groundClauseTypes.push(nonPrimitiveType);
                    } else {
                        return type;
                    }
                }
                return getUnionType(groundClauseTypes === void 0 ? clauseTypes : groundClauseTypes);
            }
            const discriminantType = getUnionType(clauseTypes);
            const caseType = discriminantType.flags & 131072 ? neverType : replacePrimitivesWithLiterals(filterType(type, t => areTypesComparable(discriminantType, t)), discriminantType);
            if (!hasDefaultClause) {
                return caseType;
            }
            const defaultType = filterType(type, t => !(isUnitLikeType(t) && contains(switchTypes, getRegularTypeOfLiteralType(extractUnitType(t)))));
            return caseType.flags & 131072 ? defaultType : getUnionType([caseType, defaultType]);
        }
        function narrowTypeByTypeName(type, typeName) {
            switch (typeName) {
                case "string":
                    return narrowTypeByTypeFacts(type, stringType, 1);
                case "number":
                    return narrowTypeByTypeFacts(type, numberType, 2);
                case "bigint":
                    return narrowTypeByTypeFacts(type, bigintType, 4);
                case "boolean":
                    return narrowTypeByTypeFacts(type, booleanType, 8);
                case "symbol":
                    return narrowTypeByTypeFacts(type, esSymbolType, 16);
                case "object":
                    return type.flags & 1 ? type : getUnionType([narrowTypeByTypeFacts(type, nonPrimitiveType, 32), narrowTypeByTypeFacts(type, nullType, 131072)]);
                case "function":
                    return type.flags & 1 ? type : narrowTypeByTypeFacts(type, globalFunctionType, 64);
                case "undefined":
                    return narrowTypeByTypeFacts(type, undefinedType, 65536);
            }
            return narrowTypeByTypeFacts(type, nonPrimitiveType, 128);
        }
        function narrowTypeByTypeFacts(type, impliedType, facts) {
            return mapType(type, t => isTypeRelatedTo(t, impliedType, strictSubtypeRelation) ? getTypeFacts(t) & facts ? t : neverType : isTypeSubtypeOf(impliedType, t) ? impliedType : getTypeFacts(t) & facts ? getIntersectionType([t, impliedType]) : neverType);
        }
        function narrowTypeBySwitchOnTypeOf(type, switchStatement, clauseStart, clauseEnd) {
            const witnesses = getSwitchClauseTypeOfWitnesses(switchStatement);
            if (!witnesses) {
                return type;
            }
            const defaultIndex = findIndex(switchStatement.caseBlock.clauses, clause => clause.kind === 293);
            const hasDefaultClause = clauseStart === clauseEnd || defaultIndex >= clauseStart && defaultIndex < clauseEnd;
            if (hasDefaultClause) {
                const notEqualFacts = getNotEqualFactsFromTypeofSwitch(clauseStart, clauseEnd, witnesses);
                return filterType(type, t => (getTypeFacts(t) & notEqualFacts) === notEqualFacts);
            }
            const clauseWitnesses = witnesses.slice(clauseStart, clauseEnd);
            return getUnionType(map(clauseWitnesses, text => text ? narrowTypeByTypeName(type, text) : neverType));
        }
        function isMatchingConstructorReference(expr) {
            return (isPropertyAccessExpression(expr) && idText(expr.name) === "constructor" || isElementAccessExpression(expr) && isStringLiteralLike(expr.argumentExpression) && expr.argumentExpression.text === "constructor") && isMatchingReference(reference, expr.expression);
        }
        function narrowTypeByConstructor(type, operator, identifier, assumeTrue) {
            if (assumeTrue ? operator !== 34 && operator !== 36 : operator !== 35 && operator !== 37) {
                return type;
            }
            const identifierType = getTypeOfExpression(identifier);
            if (!isFunctionType(identifierType) && !isConstructorType(identifierType)) {
                return type;
            }
            const prototypeProperty = getPropertyOfType(identifierType, "prototype");
            if (!prototypeProperty) {
                return type;
            }
            const prototypeType = getTypeOfSymbol(prototypeProperty);
            const candidate = !isTypeAny(prototypeType) ? prototypeType : void 0;
            if (!candidate || candidate === globalObjectType || candidate === globalFunctionType) {
                return type;
            }
            if (isTypeAny(type)) {
                return candidate;
            }
            return filterType(type, t => isConstructedBy(t, candidate));
            function isConstructedBy(source, target) {
                if (source.flags & 524288 && getObjectFlags(source) & 1 || target.flags & 524288 && getObjectFlags(target) & 1) {
                    return source.symbol === target.symbol;
                }
                return isTypeSubtypeOf(source, target);
            }
        }
        function narrowTypeByInstanceof(type, expr, assumeTrue) {
            const left = getReferenceCandidate(expr.left);
            if (!isMatchingReference(reference, left)) {
                if (assumeTrue && strictNullChecks && optionalChainContainsReference(left, reference)) {
                    return getAdjustedTypeWithFacts(type, 2097152);
                }
                return type;
            }
            const rightType = getTypeOfExpression(expr.right);
            if (!isTypeDerivedFrom(rightType, globalFunctionType)) {
                return type;
            }
            const instanceType = mapType(rightType, getInstanceType);
            if (isTypeAny(type) && (instanceType === globalObjectType || instanceType === globalFunctionType) || !assumeTrue && !(instanceType.flags & 524288 && !isEmptyAnonymousObjectType(instanceType))) {
                return type;
            }
            return getNarrowedType(type, instanceType, assumeTrue, true);
        }
        function getInstanceType(constructorType) {
            const prototypePropertyType = getTypeOfPropertyOfType(constructorType, "prototype");
            if (prototypePropertyType && !isTypeAny(prototypePropertyType)) {
                return prototypePropertyType;
            }
            const constructSignatures = getSignaturesOfType(constructorType, 1);
            if (constructSignatures.length) {
                return getUnionType(map(constructSignatures, signature => getReturnTypeOfSignature(getErasedSignature(signature))));
            }
            return emptyObjectType;
        }
        function getNarrowedType(type, candidate, assumeTrue, checkDerived) {
            var _a3;
            const key2 = type.flags & 1048576 ? `N${getTypeId(type)},${getTypeId(candidate)},${(assumeTrue ? 1 : 0) | (checkDerived ? 2 : 0)}` : void 0;
            return (_a3 = getCachedType(key2)) != null ? _a3 : setCachedType(key2, getNarrowedTypeWorker(type, candidate, assumeTrue, checkDerived));
        }
        function getNarrowedTypeWorker(type, candidate, assumeTrue, checkDerived) {
            if (!assumeTrue) {
                if (checkDerived) {
                    return filterType(type, t => !isTypeDerivedFrom(t, candidate));
                }
                const trueType2 = getNarrowedType(type, candidate, true, false);
                return filterType(type, t => !isTypeSubsetOf(t, trueType2));
            }
            if (type.flags & 3) {
                return candidate;
            }
            const isRelated = checkDerived ? isTypeDerivedFrom : isTypeSubtypeOf;
            const keyPropertyName = type.flags & 1048576 ? getKeyPropertyName(type) : void 0;
            const narrowedType = mapType(candidate, c => {
                const discriminant = keyPropertyName && getTypeOfPropertyOfType(c, keyPropertyName);
                const matching = discriminant && getConstituentTypeForKeyType(type, discriminant);
                const directlyRelated = mapType(matching || type, checkDerived ? t => isTypeDerivedFrom(t, c) ? t : isTypeDerivedFrom(c, t) ? c : neverType : t => isTypeStrictSubtypeOf(t, c) ? t : isTypeStrictSubtypeOf(c, t) ? c : isTypeSubtypeOf(t, c) ? t : isTypeSubtypeOf(c, t) ? c : neverType);
                return directlyRelated.flags & 131072 ? mapType(type, t => maybeTypeOfKind(t, 465829888) && isRelated(c, getBaseConstraintOfType(t) || unknownType) ? getIntersectionType([t, c]) : neverType) : directlyRelated;
            });
            return !(narrowedType.flags & 131072) ? narrowedType : isTypeSubtypeOf(candidate, type) ? candidate : isTypeAssignableTo(type, candidate) ? type : isTypeAssignableTo(candidate, type) ? candidate : getIntersectionType([type, candidate]);
        }
        function narrowTypeByCallExpression(type, callExpression, assumeTrue) {
            if (hasMatchingArgument(callExpression, reference)) {
                const signature = assumeTrue || !isCallChain(callExpression) ? getEffectsSignature(callExpression) : void 0;
                const predicate = signature && getTypePredicateOfSignature(signature);
                if (predicate && (predicate.kind === 0 || predicate.kind === 1)) {
                    return narrowTypeByTypePredicate(type, predicate, callExpression, assumeTrue);
                }
            }
            if (containsMissingType(type) && isAccessExpression(reference) && isPropertyAccessExpression(callExpression.expression)) {
                const callAccess = callExpression.expression;
                if (isMatchingReference(reference.expression, getReferenceCandidate(callAccess.expression)) && isIdentifier(callAccess.name) && callAccess.name.escapedText === "hasOwnProperty" && callExpression.arguments.length === 1) {
                    const argument = callExpression.arguments[0];
                    if (isStringLiteralLike(argument) && getAccessedPropertyName(reference) === escapeLeadingUnderscores(argument.text)) {
                        return getTypeWithFacts(type, assumeTrue ? 524288 : 65536);
                    }
                }
            }
            return type;
        }
        function narrowTypeByTypePredicate(type, predicate, callExpression, assumeTrue) {
            if (predicate.type && !(isTypeAny(type) && (predicate.type === globalObjectType || predicate.type === globalFunctionType))) {
                const predicateArgument = getTypePredicateArgument(predicate, callExpression);
                if (predicateArgument) {
                    if (isMatchingReference(reference, predicateArgument)) {
                        return getNarrowedType(type, predicate.type, assumeTrue, false);
                    }
                    if (strictNullChecks && assumeTrue && optionalChainContainsReference(predicateArgument, reference) && !(getTypeFacts(predicate.type) & 65536)) {
                        type = getAdjustedTypeWithFacts(type, 2097152);
                    }
                    const access = getDiscriminantPropertyAccess(predicateArgument, type);
                    if (access) {
                        return narrowTypeByDiscriminant(type, access, t => getNarrowedType(t, predicate.type, assumeTrue, false));
                    }
                }
            }
            return type;
        }
        function narrowType(type, expr, assumeTrue) {
            if (isExpressionOfOptionalChainRoot(expr) || isBinaryExpression(expr.parent) && (expr.parent.operatorToken.kind === 60 || expr.parent.operatorToken.kind === 77) && expr.parent.left === expr) {
                return narrowTypeByOptionality(type, expr, assumeTrue);
            }
            switch (expr.kind) {
                case 79:
                    if (!isMatchingReference(reference, expr) && inlineLevel < 5) {
                        const symbol = getResolvedSymbol(expr);
                        if (isConstVariable(symbol)) {
                            const declaration = symbol.valueDeclaration;
                            if (declaration && isVariableDeclaration(declaration) && !declaration.type && declaration.initializer && isConstantReference(reference)) {
                                inlineLevel++;
                                const result = narrowType(type, declaration.initializer, assumeTrue);
                                inlineLevel--;
                                return result;
                            }
                        }
                    }
                case 108:
                case 106:
                case 208:
                case 209:
                    return narrowTypeByTruthiness(type, expr, assumeTrue);
                case 210:
                    return narrowTypeByCallExpression(type, expr, assumeTrue);
                case 214:
                case 232:
                    return narrowType(type, expr.expression, assumeTrue);
                case 223:
                    return narrowTypeByBinaryExpression(type, expr, assumeTrue);
                case 221:
                    if (expr.operator === 53) {
                        return narrowType(type, expr.operand, !assumeTrue);
                    }
                    break;
            }
            return type;
        }
        function narrowTypeByOptionality(type, expr, assumePresent) {
            if (isMatchingReference(reference, expr)) {
                return getAdjustedTypeWithFacts(type, assumePresent ? 2097152 : 262144);
            }
            const access = getDiscriminantPropertyAccess(expr, type);
            if (access) {
                return narrowTypeByDiscriminant(type, access, t => getTypeWithFacts(t, assumePresent ? 2097152 : 262144));
            }
            return type;
        }
    }
    function getTypeOfSymbolAtLocation(symbol, location) {
        symbol = getExportSymbolOfValueSymbolIfExported(symbol);
        if (location.kind === 79 || location.kind === 80) {
            if (isRightSideOfQualifiedNameOrPropertyAccess(location)) {
                location = location.parent;
            }
            if (isExpressionNode(location) && (!isAssignmentTarget(location) || isWriteAccess(location))) {
                const type = getTypeOfExpression(location);
                if (getExportSymbolOfValueSymbolIfExported(getNodeLinks(location).resolvedSymbol) === symbol) {
                    return type;
                }
            }
        }
        if (isDeclarationName(location) && isSetAccessor(location.parent) && getAnnotatedAccessorTypeNode(location.parent)) {
            return getWriteTypeOfAccessors(location.parent.symbol);
        }
        return getNonMissingTypeOfSymbol(symbol);
    }
    function getControlFlowContainer(node) {
        return findAncestor(node.parent, node2 => isFunctionLike(node2) && !getImmediatelyInvokedFunctionExpression(node2) || node2.kind === 265 || node2.kind === 308 || node2.kind === 169);
    }
    function isSymbolAssigned(symbol) {
        if (!symbol.valueDeclaration) {
            return false;
        }
        const parent2 = getRootDeclaration(symbol.valueDeclaration).parent;
        const links = getNodeLinks(parent2);
        if (!(links.flags & 524288)) {
            links.flags |= 524288;
            if (!hasParentWithAssignmentsMarked(parent2)) {
                markNodeAssignments(parent2);
            }
        }
        return symbol.isAssigned || false;
    }
    function hasParentWithAssignmentsMarked(node) {
        return !!findAncestor(node.parent, node2 => (isFunctionLike(node2) || isCatchClause(node2)) && !!(getNodeLinks(node2).flags & 524288));
    }
    function markNodeAssignments(node) {
        if (node.kind === 79) {
            if (isAssignmentTarget(node)) {
                const symbol = getResolvedSymbol(node);
                if (isParameterOrCatchClauseVariable(symbol)) {
                    symbol.isAssigned = true;
                }
            }
        } else {
            forEachChild(node, markNodeAssignments);
        }
    }
    function isConstVariable(symbol) {
        return symbol.flags & 3 && (getDeclarationNodeFlagsFromSymbol(symbol) & 2) !== 0;
    }
    function parameterInitializerContainsUndefined(declaration) {
        const links = getNodeLinks(declaration);
        if (links.parameterInitializerContainsUndefined === void 0) {
            if (!pushTypeResolution(declaration, 9)) {
                reportCircularityError(declaration.symbol);
                return true;
            }
            const containsUndefined = !!(getTypeFacts(checkDeclarationInitializer(declaration, 0)) & 16777216);
            if (!popTypeResolution()) {
                reportCircularityError(declaration.symbol);
                return true;
            }
            links.parameterInitializerContainsUndefined = containsUndefined;
        }
        return links.parameterInitializerContainsUndefined;
    }
    function removeOptionalityFromDeclaredType(declaredType, declaration) {
        const removeUndefined = strictNullChecks && declaration.kind === 166 && declaration.initializer && getTypeFacts(declaredType) & 16777216 && !parameterInitializerContainsUndefined(declaration);
        return removeUndefined ? getTypeWithFacts(declaredType, 524288) : declaredType;
    }
    function isConstraintPosition(type, node) {
        const parent2 = node.parent;
        return parent2.kind === 208 || parent2.kind === 163 || parent2.kind === 210 && parent2.expression === node || parent2.kind === 209 && parent2.expression === node && !(someType(type, isGenericTypeWithoutNullableConstraint) && isGenericIndexType(getTypeOfExpression(parent2.argumentExpression)));
    }
    function isGenericTypeWithUnionConstraint(type) {
        return type.flags & 2097152 ? some(type.types, isGenericTypeWithUnionConstraint) : !!(type.flags & 465829888 && getBaseConstraintOrType(type).flags & (98304 | 1048576));
    }
    function isGenericTypeWithoutNullableConstraint(type) {
        return type.flags & 2097152 ? some(type.types, isGenericTypeWithoutNullableConstraint) : !!(type.flags & 465829888 && !maybeTypeOfKind(getBaseConstraintOrType(type), 98304));
    }
    function hasContextualTypeWithNoGenericTypes(node, checkMode) {
        const contextualType = (isIdentifier(node) || isPropertyAccessExpression(node) || isElementAccessExpression(node)) && !((isJsxOpeningElement(node.parent) || isJsxSelfClosingElement(node.parent)) && node.parent.tagName === node) && (checkMode && checkMode & 64 ? getContextualType2(node, 8) : getContextualType2(node, void 0));
        return contextualType && !isGenericType(contextualType);
    }
    function getNarrowableTypeForReference(type, reference, checkMode) {
        const substituteConstraints = !(checkMode && checkMode & 2) && someType(type, isGenericTypeWithUnionConstraint) && (isConstraintPosition(type, reference) || hasContextualTypeWithNoGenericTypes(reference, checkMode));
        return substituteConstraints ? mapType(type, getBaseConstraintOrType) : type;
    }
    function isExportOrExportExpression(location) {
        return !!findAncestor(location, n => {
            const parent2 = n.parent;
            if (parent2 === void 0) {
                return "quit";
            }
            if (isExportAssignment(parent2)) {
                return parent2.expression === n && isEntityNameExpression(n);
            }
            if (isExportSpecifier(parent2)) {
                return parent2.name === n || parent2.propertyName === n;
            }
            return false;
        });
    }
    function markAliasReferenced(symbol, location) {
        if (compilerOptions.verbatimModuleSyntax) {
            return;
        }
        if (isNonLocalAlias(symbol, 111551) && !isInTypeQuery(location) && !getTypeOnlyAliasDeclaration(symbol, 111551)) {
            const target = resolveAlias(symbol);
            if (getAllSymbolFlags(target) & (111551 | 1048576)) {
                if (getIsolatedModules(compilerOptions) || shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(location) || !isConstEnumOrConstEnumOnlyModule(getExportSymbolOfValueSymbolIfExported(target))) {
                    markAliasSymbolAsReferenced(symbol);
                } else {
                    markConstEnumAliasAsReferenced(symbol);
                }
            }
        }
    }
    function getNarrowedTypeOfSymbol(symbol, location) {
        var _a2;
        const type = getTypeOfSymbol(symbol);
        const declaration = symbol.valueDeclaration;
        if (declaration) {
            if (isBindingElement(declaration) && !declaration.initializer && !declaration.dotDotDotToken && declaration.parent.elements.length >= 2) {
                const parent2 = declaration.parent.parent;
                if (parent2.kind === 257 && getCombinedNodeFlags(declaration) & 2 || parent2.kind === 166) {
                    const links = getNodeLinks(parent2);
                    if (!(links.flags & 16777216)) {
                        links.flags |= 16777216;
                        const parentType = getTypeForBindingElementParent(parent2, 0);
                        const parentTypeConstraint = parentType && mapType(parentType, getBaseConstraintOrType);
                        links.flags &= ~16777216;
                        if (parentTypeConstraint && parentTypeConstraint.flags & 1048576 && !(parent2.kind === 166 && isSymbolAssigned(symbol))) {
                            const pattern = declaration.parent;
                            const narrowedType = getFlowTypeOfReference(pattern, parentTypeConstraint, parentTypeConstraint, void 0, location.flowNode);
                            if (narrowedType.flags & 131072) {
                                return neverType;
                            }
                            return getBindingElementTypeFromParentType(declaration, narrowedType);
                        }
                    }
                }
            }
            if (isParameter(declaration) && !declaration.type && !declaration.initializer && !declaration.dotDotDotToken) {
                const func = declaration.parent;
                if (func.parameters.length >= 2 && isContextSensitiveFunctionOrObjectLiteralMethod(func)) {
                    const contextualSignature = getContextualSignature(func);
                    if (contextualSignature && contextualSignature.parameters.length === 1 && signatureHasRestParameter(contextualSignature)) {
                        const restType = getReducedApparentType(instantiateType(getTypeOfSymbol(contextualSignature.parameters[0]), (_a2 = getInferenceContext(func)) == null ? void 0 : _a2.nonFixingMapper));
                        if (restType.flags & 1048576 && everyType(restType, isTupleType) && !isSymbolAssigned(symbol)) {
                            const narrowedType = getFlowTypeOfReference(func, restType, restType, void 0, location.flowNode);
                            const index = func.parameters.indexOf(declaration) - (getThisParameter(func) ? 1 : 0);
                            return getIndexedAccessType(narrowedType, getNumberLiteralType(index));
                        }
                    }
                }
            }
        }
        return type;
    }
    function checkIdentifier(node, checkMode) {
        if (isThisInTypeQuery(node)) {
            return checkThisExpression(node);
        }
        const symbol = getResolvedSymbol(node);
        if (symbol === unknownSymbol) {
            return errorType;
        }
        if (symbol === argumentsSymbol) {
            if (isInPropertyInitializerOrClassStaticBlock(node)) {
                error(node, Diagnostics.arguments_cannot_be_referenced_in_property_initializers);
                return errorType;
            }
            const container = getContainingFunction(node);
            if (languageVersion < 2) {
                if (container.kind === 216) {
                    error(node, Diagnostics.The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_standard_function_expression);
                } else if (hasSyntacticModifier(container, 512)) {
                    error(node, Diagnostics.The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_using_a_standard_function_or_method);
                }
            }
            getNodeLinks(container).flags |= 512;
            return getTypeOfSymbol(symbol);
        }
        if (shouldMarkIdentifierAliasReferenced(node)) {
            markAliasReferenced(symbol, node);
        }
        const localOrExportSymbol = getExportSymbolOfValueSymbolIfExported(symbol);
        const targetSymbol = checkDeprecatedAliasedSymbol(localOrExportSymbol, node);
        if (isDeprecatedSymbol(targetSymbol) && isUncalledFunctionReference(node, targetSymbol) && targetSymbol.declarations) {
            addDeprecatedSuggestion(node, targetSymbol.declarations, node.escapedText);
        }
        let declaration = localOrExportSymbol.valueDeclaration;
        if (declaration && localOrExportSymbol.flags & 32) {
            if (declaration.kind === 260 && nodeIsDecorated(legacyDecorators, declaration)) {
                let container = getContainingClass(node);
                while (container !== void 0) {
                    if (container === declaration && container.name !== node) {
                        getNodeLinks(declaration).flags |= 1048576;
                        getNodeLinks(node).flags |= 2097152;
                        break;
                    }
                    container = getContainingClass(container);
                }
            } else if (declaration.kind === 228) {
                let container = getThisContainer(node, false, false);
                while (container.kind !== 308) {
                    if (container.parent === declaration) {
                        if (isPropertyDeclaration(container) && isStatic(container) || isClassStaticBlockDeclaration(container)) {
                            getNodeLinks(declaration).flags |= 1048576;
                            getNodeLinks(node).flags |= 2097152;
                        }
                        break;
                    }
                    container = getThisContainer(container, false, false);
                }
            }
        }
        checkNestedBlockScopedBinding(node, symbol);
        let type = getNarrowedTypeOfSymbol(localOrExportSymbol, node);
        const assignmentKind = getAssignmentTargetKind(node);
        if (assignmentKind) {
            if (!(localOrExportSymbol.flags & 3) && !(isInJSFile(node) && localOrExportSymbol.flags & 512)) {
                const assignmentError = localOrExportSymbol.flags & 384 ? Diagnostics.Cannot_assign_to_0_because_it_is_an_enum : localOrExportSymbol.flags & 32 ? Diagnostics.Cannot_assign_to_0_because_it_is_a_class : localOrExportSymbol.flags & 1536 ? Diagnostics.Cannot_assign_to_0_because_it_is_a_namespace : localOrExportSymbol.flags & 16 ? Diagnostics.Cannot_assign_to_0_because_it_is_a_function : localOrExportSymbol.flags & 2097152 ? Diagnostics.Cannot_assign_to_0_because_it_is_an_import : Diagnostics.Cannot_assign_to_0_because_it_is_not_a_variable;
                error(node, assignmentError, symbolToString(symbol));
                return errorType;
            }
            if (isReadonlySymbol(localOrExportSymbol)) {
                if (localOrExportSymbol.flags & 3) {
                    error(node, Diagnostics.Cannot_assign_to_0_because_it_is_a_constant, symbolToString(symbol));
                } else {
                    error(node, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, symbolToString(symbol));
                }
                return errorType;
            }
        }
        const isAlias = localOrExportSymbol.flags & 2097152;
        if (localOrExportSymbol.flags & 3) {
            if (assignmentKind === 1) {
                return type;
            }
        } else if (isAlias) {
            declaration = getDeclarationOfAliasSymbol(symbol);
        } else {
            return type;
        }
        if (!declaration) {
            return type;
        }
        type = getNarrowableTypeForReference(type, node, checkMode);
        const isParameter2 = getRootDeclaration(declaration).kind === 166;
        const declarationContainer = getControlFlowContainer(declaration);
        let flowContainer = getControlFlowContainer(node);
        const isOuterVariable = flowContainer !== declarationContainer;
        const isSpreadDestructuringAssignmentTarget = node.parent && node.parent.parent && isSpreadAssignment(node.parent) && isDestructuringAssignmentTarget(node.parent.parent);
        const isModuleExports = symbol.flags & 134217728;
        while (flowContainer !== declarationContainer && (flowContainer.kind === 215 || flowContainer.kind === 216 || isObjectLiteralOrClassExpressionMethodOrAccessor(flowContainer)) && (isConstVariable(localOrExportSymbol) && type !== autoArrayType || isParameter2 && !isSymbolAssigned(localOrExportSymbol))) {
            flowContainer = getControlFlowContainer(flowContainer);
        }
        const assumeInitialized = isParameter2 || isAlias || isOuterVariable || isSpreadDestructuringAssignmentTarget || isModuleExports || isSameScopedBindingElement(node, declaration) || type !== autoType && type !== autoArrayType && (!strictNullChecks || (type.flags & (3 | 16384)) !== 0 || isInTypeQuery(node) || isInAmbientOrTypeNode(node) || node.parent.kind === 278) || node.parent.kind === 232 || declaration.kind === 257 && declaration.exclamationToken || declaration.flags & 16777216;
        const initialType = assumeInitialized ? isParameter2 ? removeOptionalityFromDeclaredType(type, declaration) : type : type === autoType || type === autoArrayType ? undefinedType : getOptionalType(type);
        const flowType = getFlowTypeOfReference(node, type, initialType, flowContainer);
        if (!isEvolvingArrayOperationTarget(node) && (type === autoType || type === autoArrayType)) {
            if (flowType === autoType || flowType === autoArrayType) {
                if (noImplicitAny) {
                    error(getNameOfDeclaration(declaration), Diagnostics.Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined, symbolToString(symbol), typeToString(flowType));
                    error(node, Diagnostics.Variable_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType));
                }
                return convertAutoToAny(flowType);
            }
        } else if (!assumeInitialized && !containsUndefinedType(type) && containsUndefinedType(flowType)) {
            error(node, Diagnostics.Variable_0_is_used_before_being_assigned, symbolToString(symbol));
            return type;
        }
        return assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType;
    }
    function isSameScopedBindingElement(node, declaration) {
        if (isBindingElement(declaration)) {
            const bindingElement = findAncestor(node, isBindingElement);
            return bindingElement && getRootDeclaration(bindingElement) === getRootDeclaration(declaration);
        }
    }
    function shouldMarkIdentifierAliasReferenced(node) {
        var _a2;
        const parent2 = node.parent;
        if (parent2) {
            if (isPropertyAccessExpression(parent2) && parent2.expression === node) {
                return false;
            }
            if (isExportSpecifier(parent2) && parent2.isTypeOnly) {
                return false;
            }
            const greatGrandparent = (_a2 = parent2.parent) == null ? void 0 : _a2.parent;
            if (greatGrandparent && isExportDeclaration(greatGrandparent) && greatGrandparent.isTypeOnly) {
                return false;
            }
        }
        return true;
    }
    function isInsideFunctionOrInstancePropertyInitializer(node, threshold) {
        return !!findAncestor(node, n => n === threshold ? "quit" : isFunctionLike(n) || n.parent && isPropertyDeclaration(n.parent) && !hasStaticModifier(n.parent) && n.parent.initializer === n);
    }
    function getPartOfForStatementContainingNode(node, container) {
        return findAncestor(node, n => n === container ? "quit" : n === container.initializer || n === container.condition || n === container.incrementor || n === container.statement);
    }
    function getEnclosingIterationStatement(node) {
        return findAncestor(node, n => !n || nodeStartsNewLexicalEnvironment(n) ? "quit" : isIterationStatement(n, false));
    }
    function checkNestedBlockScopedBinding(node, symbol) {
        if (languageVersion >= 2 || (symbol.flags & (2 | 32)) === 0 || !symbol.valueDeclaration || isSourceFile(symbol.valueDeclaration) || symbol.valueDeclaration.parent.kind === 295) {
            return;
        }
        const container = getEnclosingBlockScopeContainer(symbol.valueDeclaration);
        const isCaptured = isInsideFunctionOrInstancePropertyInitializer(node, container);
        const enclosingIterationStatement = getEnclosingIterationStatement(container);
        if (enclosingIterationStatement) {
            if (isCaptured) {
                let capturesBlockScopeBindingInLoopBody = true;
                if (isForStatement(container)) {
                    const varDeclList = getAncestor(symbol.valueDeclaration, 258);
                    if (varDeclList && varDeclList.parent === container) {
                        const part = getPartOfForStatementContainingNode(node.parent, container);
                        if (part) {
                            const links = getNodeLinks(part);
                            links.flags |= 8192;
                            const capturedBindings = links.capturedBlockScopeBindings || (links.capturedBlockScopeBindings = []);
                            pushIfUnique(capturedBindings, symbol);
                            if (part === container.initializer) {
                                capturesBlockScopeBindingInLoopBody = false;
                            }
                        }
                    }
                }
                if (capturesBlockScopeBindingInLoopBody) {
                    getNodeLinks(enclosingIterationStatement).flags |= 4096;
                }
            }
            if (isForStatement(container)) {
                const varDeclList = getAncestor(symbol.valueDeclaration, 258);
                if (varDeclList && varDeclList.parent === container && isAssignedInBodyOfForStatement(node, container)) {
                    getNodeLinks(symbol.valueDeclaration).flags |= 262144;
                }
            }
            getNodeLinks(symbol.valueDeclaration).flags |= 32768;
        }
        if (isCaptured) {
            getNodeLinks(symbol.valueDeclaration).flags |= 16384;
        }
    }
    function isBindingCapturedByNode(node, decl) {
        const links = getNodeLinks(node);
        return !!links && contains(links.capturedBlockScopeBindings, getSymbolOfDeclaration(decl));
    }
    function isAssignedInBodyOfForStatement(node, container) {
        let current = node;
        while (current.parent.kind === 214) {
            current = current.parent;
        }
        let isAssigned = false;
        if (isAssignmentTarget(current)) {
            isAssigned = true;
        } else if (current.parent.kind === 221 || current.parent.kind === 222) {
            const expr = current.parent;
            isAssigned = expr.operator === 45 || expr.operator === 46;
        }
        if (!isAssigned) {
            return false;
        }
        return !!findAncestor(current, n => n === container ? "quit" : n === container.statement);
    }
    function captureLexicalThis(node, container) {
        getNodeLinks(node).flags |= 2;
        if (container.kind === 169 || container.kind === 173) {
            const classNode = container.parent;
            getNodeLinks(classNode).flags |= 4;
        } else {
            getNodeLinks(container).flags |= 4;
        }
    }
    function findFirstSuperCall(node) {
        return isSuperCall(node) ? node : isFunctionLike(node) ? void 0 : forEachChild(node, findFirstSuperCall);
    }
    function classDeclarationExtendsNull(classDecl) {
        const classSymbol = getSymbolOfDeclaration(classDecl);
        const classInstanceType = getDeclaredTypeOfSymbol(classSymbol);
        const baseConstructorType = getBaseConstructorTypeOfClass(classInstanceType);
        return baseConstructorType === nullWideningType;
    }
    function checkThisBeforeSuper(node, container, diagnosticMessage) {
        const containingClassDecl = container.parent;
        const baseTypeNode = getClassExtendsHeritageElement(containingClassDecl);
        if (baseTypeNode && !classDeclarationExtendsNull(containingClassDecl)) {
            if (canHaveFlowNode(node) && node.flowNode && !isPostSuperFlowNode(node.flowNode, false)) {
                error(node, diagnosticMessage);
            }
        }
    }
    function checkThisInStaticClassFieldInitializerInDecoratedClass(thisExpression, container) {
        if (isPropertyDeclaration(container) && hasStaticModifier(container) && legacyDecorators && container.initializer && textRangeContainsPositionInclusive(container.initializer, thisExpression.pos) && hasDecorators(container.parent)) {
            error(thisExpression, Diagnostics.Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class);
        }
    }
    function checkThisExpression(node) {
        const isNodeInTypeQuery = isInTypeQuery(node);
        let container = getThisContainer(node, true, true);
        let capturedByArrowFunction = false;
        let thisInComputedPropertyName = false;
        if (container.kind === 173) {
            checkThisBeforeSuper(node, container, Diagnostics.super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class);
        }
        while (true) {
            if (container.kind === 216) {
                container = getThisContainer(container, false, !thisInComputedPropertyName);
                capturedByArrowFunction = true;
            }
            if (container.kind === 164) {
                container = getThisContainer(container, !capturedByArrowFunction, false);
                thisInComputedPropertyName = true;
                continue;
            }
            break;
        }
        checkThisInStaticClassFieldInitializerInDecoratedClass(node, container);
        if (thisInComputedPropertyName) {
            error(node, Diagnostics.this_cannot_be_referenced_in_a_computed_property_name);
        } else {
            switch (container.kind) {
                case 264:
                    error(node, Diagnostics.this_cannot_be_referenced_in_a_module_or_namespace_body);
                    break;
                case 263:
                    error(node, Diagnostics.this_cannot_be_referenced_in_current_location);
                    break;
                case 173:
                    if (isInConstructorArgumentInitializer(node, container)) {
                        error(node, Diagnostics.this_cannot_be_referenced_in_constructor_arguments);
                    }
                    break;
            }
        }
        if (!isNodeInTypeQuery && capturedByArrowFunction && languageVersion < 2) {
            captureLexicalThis(node, container);
        }
        const type = tryGetThisTypeAt(node, true, container);
        if (noImplicitThis) {
            const globalThisType2 = getTypeOfSymbol(globalThisSymbol);
            if (type === globalThisType2 && capturedByArrowFunction) {
                error(node, Diagnostics.The_containing_arrow_function_captures_the_global_value_of_this);
            } else if (!type) {
                const diag2 = error(node, Diagnostics.this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation);
                if (!isSourceFile(container)) {
                    const outsideThis = tryGetThisTypeAt(container);
                    if (outsideThis && outsideThis !== globalThisType2) {
                        addRelatedInfo(diag2, createDiagnosticForNode(container, Diagnostics.An_outer_value_of_this_is_shadowed_by_this_container));
                    }
                }
            }
        }
        return type || anyType;
    }
    function tryGetThisTypeAt(node, includeGlobalThis = true, container = getThisContainer(node, false, false)) {
        const isInJS = isInJSFile(node);
        if (isFunctionLike(container) && (!isInParameterInitializerBeforeContainingFunction(node) || getThisParameter(container))) {
            let thisType = getThisTypeOfDeclaration(container) || isInJS && getTypeForThisExpressionFromJSDoc(container);
            if (!thisType) {
                const className = getClassNameFromPrototypeMethod(container);
                if (isInJS && className) {
                    const classSymbol = checkExpression(className).symbol;
                    if (classSymbol && classSymbol.members && classSymbol.flags & 16) {
                        thisType = getDeclaredTypeOfSymbol(classSymbol).thisType;
                    }
                } else if (isJSConstructor(container)) {
                    thisType = getDeclaredTypeOfSymbol(getMergedSymbol(container.symbol)).thisType;
                }
                thisType || (thisType = getContextualThisParameterType(container));
            }
            if (thisType) {
                return getFlowTypeOfReference(node, thisType);
            }
        }
        if (isClassLike(container.parent)) {
            const symbol = getSymbolOfDeclaration(container.parent);
            const type = isStatic(container) ? getTypeOfSymbol(symbol) : getDeclaredTypeOfSymbol(symbol).thisType;
            return getFlowTypeOfReference(node, type);
        }
        if (isSourceFile(container)) {
            if (container.commonJsModuleIndicator) {
                const fileSymbol = getSymbolOfDeclaration(container);
                return fileSymbol && getTypeOfSymbol(fileSymbol);
            } else if (container.externalModuleIndicator) {
                return undefinedType;
            } else if (includeGlobalThis) {
                return getTypeOfSymbol(globalThisSymbol);
            }
        }
    }
    function getExplicitThisType(node) {
        const container = getThisContainer(node, false, false);
        if (isFunctionLike(container)) {
            const signature = getSignatureFromDeclaration(container);
            if (signature.thisParameter) {
                return getExplicitTypeOfSymbol(signature.thisParameter);
            }
        }
        if (isClassLike(container.parent)) {
            const symbol = getSymbolOfDeclaration(container.parent);
            return isStatic(container) ? getTypeOfSymbol(symbol) : getDeclaredTypeOfSymbol(symbol).thisType;
        }
    }
    function getClassNameFromPrototypeMethod(container) {
        if (container.kind === 215 && isBinaryExpression(container.parent) && getAssignmentDeclarationKind(container.parent) === 3) {
            return container.parent.left.expression.expression;
        } else if (container.kind === 171 && container.parent.kind === 207 && isBinaryExpression(container.parent.parent) && getAssignmentDeclarationKind(container.parent.parent) === 6) {
            return container.parent.parent.left.expression;
        } else if (container.kind === 215 && container.parent.kind === 299 && container.parent.parent.kind === 207 && isBinaryExpression(container.parent.parent.parent) && getAssignmentDeclarationKind(container.parent.parent.parent) === 6) {
            return container.parent.parent.parent.left.expression;
        } else if (container.kind === 215 && isPropertyAssignment(container.parent) && isIdentifier(container.parent.name) && (container.parent.name.escapedText === "value" || container.parent.name.escapedText === "get" || container.parent.name.escapedText === "set") && isObjectLiteralExpression(container.parent.parent) && isCallExpression(container.parent.parent.parent) && container.parent.parent.parent.arguments[2] === container.parent.parent && getAssignmentDeclarationKind(container.parent.parent.parent) === 9) {
            return container.parent.parent.parent.arguments[0].expression;
        } else if (isMethodDeclaration(container) && isIdentifier(container.name) && (container.name.escapedText === "value" || container.name.escapedText === "get" || container.name.escapedText === "set") && isObjectLiteralExpression(container.parent) && isCallExpression(container.parent.parent) && container.parent.parent.arguments[2] === container.parent && getAssignmentDeclarationKind(container.parent.parent) === 9) {
            return container.parent.parent.arguments[0].expression;
        }
    }
    function getTypeForThisExpressionFromJSDoc(node) {
        const jsdocType = getJSDocType(node);
        if (jsdocType && jsdocType.kind === 320) {
            const jsDocFunctionType = jsdocType;
            if (jsDocFunctionType.parameters.length > 0 && jsDocFunctionType.parameters[0].name && jsDocFunctionType.parameters[0].name.escapedText === "this") {
                return getTypeFromTypeNode(jsDocFunctionType.parameters[0].type);
            }
        }
        const thisTag = getJSDocThisTag(node);
        if (thisTag && thisTag.typeExpression) {
            return getTypeFromTypeNode(thisTag.typeExpression);
        }
    }
    function isInConstructorArgumentInitializer(node, constructorDecl) {
        return !!findAncestor(node, n => isFunctionLikeDeclaration(n) ? "quit" : n.kind === 166 && n.parent === constructorDecl);
    }
    function checkSuperExpression(node) {
        const isCallExpression2 = node.parent.kind === 210 && node.parent.expression === node;
        const immediateContainer = getSuperContainer(node, true);
        let container = immediateContainer;
        let needToCaptureLexicalThis = false;
        let inAsyncFunction = false;
        if (!isCallExpression2) {
            while (container && container.kind === 216) {
                if (hasSyntacticModifier(container, 512)) inAsyncFunction = true;
                container = getSuperContainer(container, true);
                needToCaptureLexicalThis = languageVersion < 2;
            }
            if (container && hasSyntacticModifier(container, 512)) inAsyncFunction = true;
        }
        let nodeCheckFlag = 0;
        if (!container || !isLegalUsageOfSuperExpression(container)) {
            const current = findAncestor(node, n => n === container ? "quit" : n.kind === 164);
            if (current && current.kind === 164) {
                error(node, Diagnostics.super_cannot_be_referenced_in_a_computed_property_name);
            } else if (isCallExpression2) {
                error(node, Diagnostics.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors);
            } else if (!container || !container.parent || !(isClassLike(container.parent) || container.parent.kind === 207)) {
                error(node, Diagnostics.super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions);
            } else {
                error(node, Diagnostics.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class);
            }
            return errorType;
        }
        if (!isCallExpression2 && immediateContainer.kind === 173) {
            checkThisBeforeSuper(node, container, Diagnostics.super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class);
        }
        if (isStatic(container) || isCallExpression2) {
            nodeCheckFlag = 32;
            if (!isCallExpression2 && languageVersion >= 2 && languageVersion <= 8 && (isPropertyDeclaration(container) || isClassStaticBlockDeclaration(container))) {
                forEachEnclosingBlockScopeContainer(node.parent, current => {
                    if (!isSourceFile(current) || isExternalOrCommonJsModule(current)) {
                        getNodeLinks(current).flags |= 8388608;
                    }
                });
            }
        } else {
            nodeCheckFlag = 16;
        }
        getNodeLinks(node).flags |= nodeCheckFlag;
        if (container.kind === 171 && inAsyncFunction) {
            if (isSuperProperty(node.parent) && isAssignmentTarget(node.parent)) {
                getNodeLinks(container).flags |= 256;
            } else {
                getNodeLinks(container).flags |= 128;
            }
        }
        if (needToCaptureLexicalThis) {
            captureLexicalThis(node.parent, container);
        }
        if (container.parent.kind === 207) {
            if (languageVersion < 2) {
                error(node, Diagnostics.super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher);
                return errorType;
            } else {
                return anyType;
            }
        }
        const classLikeDeclaration = container.parent;
        if (!getClassExtendsHeritageElement(classLikeDeclaration)) {
            error(node, Diagnostics.super_can_only_be_referenced_in_a_derived_class);
            return errorType;
        }
        const classType = getDeclaredTypeOfSymbol(getSymbolOfDeclaration(classLikeDeclaration));
        const baseClassType = classType && getBaseTypes(classType)[0];
        if (!baseClassType) {
            return errorType;
        }
        if (container.kind === 173 && isInConstructorArgumentInitializer(node, container)) {
            error(node, Diagnostics.super_cannot_be_referenced_in_constructor_arguments);
            return errorType;
        }
        return nodeCheckFlag === 32 ? getBaseConstructorTypeOfClass(classType) : getTypeWithThisArgument(baseClassType, classType.thisType);
        function isLegalUsageOfSuperExpression(container2) {
            if (isCallExpression2) {
                return container2.kind === 173;
            } else {
                if (isClassLike(container2.parent) || container2.parent.kind === 207) {
                    if (isStatic(container2)) {
                        return container2.kind === 171 || container2.kind === 170 || container2.kind === 174 || container2.kind === 175 || container2.kind === 169 || container2.kind === 172;
                    } else {
                        return container2.kind === 171 || container2.kind === 170 || container2.kind === 174 || container2.kind === 175 || container2.kind === 169 || container2.kind === 168 || container2.kind === 173;
                    }
                }
            }
            return false;
        }
    }
    function getContainingObjectLiteral(func) {
        return (func.kind === 171 || func.kind === 174 || func.kind === 175) && func.parent.kind === 207 ? func.parent : func.kind === 215 && func.parent.kind === 299 ? func.parent.parent : void 0;
    }
    function getThisTypeArgument(type) {
        return getObjectFlags(type) & 4 && type.target === globalThisType ? getTypeArguments(type)[0] : void 0;
    }
    function getThisTypeFromContextualType(type) {
        return mapType(type, t => {
            return t.flags & 2097152 ? forEach(t.types, getThisTypeArgument) : getThisTypeArgument(t);
        });
    }
    function getContextualThisParameterType(func) {
        if (func.kind === 216) {
            return void 0;
        }
        if (isContextSensitiveFunctionOrObjectLiteralMethod(func)) {
            const contextualSignature = getContextualSignature(func);
            if (contextualSignature) {
                const thisParameter = contextualSignature.thisParameter;
                if (thisParameter) {
                    return getTypeOfSymbol(thisParameter);
                }
            }
        }
        const inJs = isInJSFile(func);
        if (noImplicitThis || inJs) {
            const containingLiteral = getContainingObjectLiteral(func);
            if (containingLiteral) {
                const contextualType = getApparentTypeOfContextualType(containingLiteral, void 0);
                let literal = containingLiteral;
                let type = contextualType;
                while (type) {
                    const thisType = getThisTypeFromContextualType(type);
                    if (thisType) {
                        return instantiateType(thisType, getMapperFromContext(getInferenceContext(containingLiteral)));
                    }
                    if (literal.parent.kind !== 299) {
                        break;
                    }
                    literal = literal.parent.parent;
                    type = getApparentTypeOfContextualType(literal, void 0);
                }
                return getWidenedType(contextualType ? getNonNullableType(contextualType) : checkExpressionCached(containingLiteral));
            }
            const parent2 = walkUpParenthesizedExpressions(func.parent);
            if (parent2.kind === 223 && parent2.operatorToken.kind === 63) {
                const target = parent2.left;
                if (isAccessExpression(target)) {
                    const {
                        expression
                    } = target;
                    if (inJs && isIdentifier(expression)) {
                        const sourceFile = getSourceFileOfNode(parent2);
                        if (sourceFile.commonJsModuleIndicator && getResolvedSymbol(expression) === sourceFile.symbol) {
                            return void 0;
                        }
                    }
                    return getWidenedType(checkExpressionCached(expression));
                }
            }
        }
        return void 0;
    }
    function getContextuallyTypedParameterType(parameter) {
        const func = parameter.parent;
        if (!isContextSensitiveFunctionOrObjectLiteralMethod(func)) {
            return void 0;
        }
        const iife = getImmediatelyInvokedFunctionExpression(func);
        if (iife && iife.arguments) {
            const args = getEffectiveCallArguments(iife);
            const indexOfParameter = func.parameters.indexOf(parameter);
            if (parameter.dotDotDotToken) {
                return getSpreadArgumentType(args, indexOfParameter, args.length, anyType, void 0, 0);
            }
            const links = getNodeLinks(iife);
            const cached = links.resolvedSignature;
            links.resolvedSignature = anySignature;
            const type = indexOfParameter < args.length ? getWidenedLiteralType(checkExpression(args[indexOfParameter])) : parameter.initializer ? void 0 : undefinedWideningType;
            links.resolvedSignature = cached;
            return type;
        }
        const contextualSignature = getContextualSignature(func);
        if (contextualSignature) {
            const index = func.parameters.indexOf(parameter) - (getThisParameter(func) ? 1 : 0);
            return parameter.dotDotDotToken && lastOrUndefined(func.parameters) === parameter ? getRestTypeAtPosition(contextualSignature, index) : tryGetTypeAtPosition(contextualSignature, index);
        }
    }
    function getContextualTypeForVariableLikeDeclaration(declaration, contextFlags) {
        const typeNode = getEffectiveTypeAnnotationNode(declaration) || (isInJSFile(declaration) ? tryGetJSDocSatisfiesTypeNode(declaration) : void 0);
        if (typeNode) {
            return getTypeFromTypeNode(typeNode);
        }
        switch (declaration.kind) {
            case 166:
                return getContextuallyTypedParameterType(declaration);
            case 205:
                return getContextualTypeForBindingElement(declaration, contextFlags);
            case 169:
                if (isStatic(declaration)) {
                    return getContextualTypeForStaticPropertyDeclaration(declaration, contextFlags);
                }
        }
    }
    function getContextualTypeForBindingElement(declaration, contextFlags) {
        const parent2 = declaration.parent.parent;
        const name = declaration.propertyName || declaration.name;
        const parentType = getContextualTypeForVariableLikeDeclaration(parent2, contextFlags) || parent2.kind !== 205 && parent2.initializer && checkDeclarationInitializer(parent2, declaration.dotDotDotToken ? 64 : 0);
        if (!parentType || isBindingPattern(name) || isComputedNonLiteralName(name)) return void 0;
        if (parent2.name.kind === 204) {
            const index = indexOfNode(declaration.parent.elements, declaration);
            if (index < 0) return void 0;
            return getContextualTypeForElementExpression(parentType, index);
        }
        const nameType = getLiteralTypeFromPropertyName(name);
        if (isTypeUsableAsPropertyName(nameType)) {
            const text = getPropertyNameFromType(nameType);
            return getTypeOfPropertyOfType(parentType, text);
        }
    }
    function getContextualTypeForStaticPropertyDeclaration(declaration, contextFlags) {
        const parentType = isExpression(declaration.parent) && getContextualType2(declaration.parent, contextFlags);
        if (!parentType) return void 0;
        return getTypeOfPropertyOfContextualType(parentType, getSymbolOfDeclaration(declaration).escapedName);
    }
    function getContextualTypeForInitializerExpression(node, contextFlags) {
        const declaration = node.parent;
        if (hasInitializer(declaration) && node === declaration.initializer) {
            const result = getContextualTypeForVariableLikeDeclaration(declaration, contextFlags);
            if (result) {
                return result;
            }
            if (!(contextFlags & 8) && isBindingPattern(declaration.name) && declaration.name.elements.length > 0) {
                return getTypeFromBindingPattern(declaration.name, true, false);
            }
        }
        return void 0;
    }
    function getContextualTypeForReturnExpression(node, contextFlags) {
        const func = getContainingFunction(node);
        if (func) {
            let contextualReturnType = getContextualReturnType(func, contextFlags);
            if (contextualReturnType) {
                const functionFlags = getFunctionFlags(func);
                if (functionFlags & 1) {
                    const isAsyncGenerator = (functionFlags & 2) !== 0;
                    if (contextualReturnType.flags & 1048576) {
                        contextualReturnType = filterType(contextualReturnType, type => !!getIterationTypeOfGeneratorFunctionReturnType(1, type, isAsyncGenerator));
                    }
                    const iterationReturnType = getIterationTypeOfGeneratorFunctionReturnType(1, contextualReturnType, (functionFlags & 2) !== 0);
                    if (!iterationReturnType) {
                        return void 0;
                    }
                    contextualReturnType = iterationReturnType;
                }
                if (functionFlags & 2) {
                    const contextualAwaitedType = mapType(contextualReturnType, getAwaitedTypeNoAlias);
                    return contextualAwaitedType && getUnionType([contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)]);
                }
                return contextualReturnType;
            }
        }
        return void 0;
    }
    function getContextualTypeForAwaitOperand(node, contextFlags) {
        const contextualType = getContextualType2(node, contextFlags);
        if (contextualType) {
            const contextualAwaitedType = getAwaitedTypeNoAlias(contextualType);
            return contextualAwaitedType && getUnionType([contextualAwaitedType, createPromiseLikeType(contextualAwaitedType)]);
        }
        return void 0;
    }
    function getContextualTypeForYieldOperand(node, contextFlags) {
        const func = getContainingFunction(node);
        if (func) {
            const functionFlags = getFunctionFlags(func);
            let contextualReturnType = getContextualReturnType(func, contextFlags);
            if (contextualReturnType) {
                const isAsyncGenerator = (functionFlags & 2) !== 0;
                if (!node.asteriskToken && contextualReturnType.flags & 1048576) {
                    contextualReturnType = filterType(contextualReturnType, type => !!getIterationTypeOfGeneratorFunctionReturnType(1, type, isAsyncGenerator));
                }
                return node.asteriskToken ? contextualReturnType : getIterationTypeOfGeneratorFunctionReturnType(0, contextualReturnType, isAsyncGenerator);
            }
        }
        return void 0;
    }
    function isInParameterInitializerBeforeContainingFunction(node) {
        let inBindingInitializer = false;
        while (node.parent && !isFunctionLike(node.parent)) {
            if (isParameter(node.parent) && (inBindingInitializer || node.parent.initializer === node)) {
                return true;
            }
            if (isBindingElement(node.parent) && node.parent.initializer === node) {
                inBindingInitializer = true;
            }
            node = node.parent;
        }
        return false;
    }
    function getContextualIterationType(kind, functionDecl) {
        const isAsync = !!(getFunctionFlags(functionDecl) & 2);
        const contextualReturnType = getContextualReturnType(functionDecl, void 0);
        if (contextualReturnType) {
            return getIterationTypeOfGeneratorFunctionReturnType(kind, contextualReturnType, isAsync) || void 0;
        }
        return void 0;
    }
    function getContextualReturnType(functionDecl, contextFlags) {
        const returnType = getReturnTypeFromAnnotation(functionDecl);
        if (returnType) {
            return returnType;
        }
        const signature = getContextualSignatureForFunctionLikeDeclaration(functionDecl);
        if (signature && !isResolvingReturnTypeOfSignature(signature)) {
            return getReturnTypeOfSignature(signature);
        }
        const iife = getImmediatelyInvokedFunctionExpression(functionDecl);
        if (iife) {
            return getContextualType2(iife, contextFlags);
        }
        return void 0;
    }
    function getContextualTypeForArgument(callTarget, arg) {
        const args = getEffectiveCallArguments(callTarget);
        const argIndex = args.indexOf(arg);
        return argIndex === -1 ? void 0 : getContextualTypeForArgumentAtIndex(callTarget, argIndex);
    }
    function getContextualTypeForArgumentAtIndex(callTarget, argIndex) {
        if (isImportCall(callTarget)) {
            return argIndex === 0 ? stringType : argIndex === 1 ? getGlobalImportCallOptionsType(false) : anyType;
        }
        const signature = getNodeLinks(callTarget).resolvedSignature === resolvingSignature ? resolvingSignature : getResolvedSignature(callTarget);
        if (isJsxOpeningLikeElement(callTarget) && argIndex === 0) {
            return getEffectiveFirstArgumentForJsxSignature(signature, callTarget);
        }
        const restIndex = signature.parameters.length - 1;
        return signatureHasRestParameter(signature) && argIndex >= restIndex ? getIndexedAccessType(getTypeOfSymbol(signature.parameters[restIndex]), getNumberLiteralType(argIndex - restIndex), 256) : getTypeAtPosition(signature, argIndex);
    }
    function getContextualTypeForDecorator(decorator) {
        const signature = getDecoratorCallSignature(decorator);
        return signature ? getOrCreateTypeFromSignature(signature) : void 0;
    }
    function getContextualTypeForSubstitutionExpression(template, substitutionExpression) {
        if (template.parent.kind === 212) {
            return getContextualTypeForArgument(template.parent, substitutionExpression);
        }
        return void 0;
    }
    function getContextualTypeForBinaryOperand(node, contextFlags) {
        const binaryExpression = node.parent;
        const {
            left,
            operatorToken,
            right
        } = binaryExpression;
        switch (operatorToken.kind) {
            case 63:
            case 76:
            case 75:
            case 77:
                return node === right ? getContextualTypeForAssignmentDeclaration(binaryExpression) : void 0;
            case 56:
            case 60:
                const type = getContextualType2(binaryExpression, contextFlags);
                return node === right && (type && type.pattern || !type && !isDefaultedExpandoInitializer(binaryExpression)) ? getTypeOfExpression(left) : type;
            case 55:
            case 27:
                return node === right ? getContextualType2(binaryExpression, contextFlags) : void 0;
            default:
                return void 0;
        }
    }
    function getSymbolForExpression(e) {
        if (canHaveSymbol(e) && e.symbol) {
            return e.symbol;
        }
        if (isIdentifier(e)) {
            return getResolvedSymbol(e);
        }
        if (isPropertyAccessExpression(e)) {
            const lhsType = getTypeOfExpression(e.expression);
            return isPrivateIdentifier(e.name) ? tryGetPrivateIdentifierPropertyOfType(lhsType, e.name) : getPropertyOfType(lhsType, e.name.escapedText);
        }
        if (isElementAccessExpression(e)) {
            const propType = checkExpressionCached(e.argumentExpression);
            if (!isTypeUsableAsPropertyName(propType)) {
                return void 0;
            }
            const lhsType = getTypeOfExpression(e.expression);
            return getPropertyOfType(lhsType, getPropertyNameFromType(propType));
        }
        return void 0;
        function tryGetPrivateIdentifierPropertyOfType(type, id) {
            const lexicallyScopedSymbol = lookupSymbolForPrivateIdentifierDeclaration(id.escapedText, id);
            return lexicallyScopedSymbol && getPrivateIdentifierPropertyOfType(type, lexicallyScopedSymbol);
        }
    }
    function getContextualTypeForAssignmentDeclaration(binaryExpression) {
        var _a2, _b;
        const kind = getAssignmentDeclarationKind(binaryExpression);
        switch (kind) {
            case 0:
            case 4:
                const lhsSymbol = getSymbolForExpression(binaryExpression.left);
                const decl = lhsSymbol && lhsSymbol.valueDeclaration;
                if (decl && (isPropertyDeclaration(decl) || isPropertySignature(decl))) {
                    const overallAnnotation = getEffectiveTypeAnnotationNode(decl);
                    return overallAnnotation && instantiateType(getTypeFromTypeNode(overallAnnotation), getSymbolLinks(lhsSymbol).mapper) || (isPropertyDeclaration(decl) ? decl.initializer && getTypeOfExpression(binaryExpression.left) : void 0);
                }
                if (kind === 0) {
                    return getTypeOfExpression(binaryExpression.left);
                }
                return getContextualTypeForThisPropertyAssignment(binaryExpression);
            case 5:
                if (isPossiblyAliasedThisProperty(binaryExpression, kind)) {
                    return getContextualTypeForThisPropertyAssignment(binaryExpression);
                } else if (!canHaveSymbol(binaryExpression.left) || !binaryExpression.left.symbol) {
                    return getTypeOfExpression(binaryExpression.left);
                } else {
                    const decl2 = binaryExpression.left.symbol.valueDeclaration;
                    if (!decl2) {
                        return void 0;
                    }
                    const lhs = cast(binaryExpression.left, isAccessExpression);
                    const overallAnnotation = getEffectiveTypeAnnotationNode(decl2);
                    if (overallAnnotation) {
                        return getTypeFromTypeNode(overallAnnotation);
                    } else if (isIdentifier(lhs.expression)) {
                        const id = lhs.expression;
                        const parentSymbol = resolveName(id, id.escapedText, 111551, void 0, id.escapedText, true);
                        if (parentSymbol) {
                            const annotated2 = parentSymbol.valueDeclaration && getEffectiveTypeAnnotationNode(parentSymbol.valueDeclaration);
                            if (annotated2) {
                                const nameStr = getElementOrPropertyAccessName(lhs);
                                if (nameStr !== void 0) {
                                    return getTypeOfPropertyOfContextualType(getTypeFromTypeNode(annotated2), nameStr);
                                }
                            }
                            return void 0;
                        }
                    }
                    return isInJSFile(decl2) ? void 0 : getTypeOfExpression(binaryExpression.left);
                }
            case 1:
            case 6:
            case 3:
            case 2:
                let valueDeclaration;
                if (kind !== 2) {
                    valueDeclaration = canHaveSymbol(binaryExpression.left) ? (_a2 = binaryExpression.left.symbol) == null ? void 0 : _a2.valueDeclaration : void 0;
                }
                valueDeclaration || (valueDeclaration = (_b = binaryExpression.symbol) == null ? void 0 : _b.valueDeclaration);
                const annotated = valueDeclaration && getEffectiveTypeAnnotationNode(valueDeclaration);
                return annotated ? getTypeFromTypeNode(annotated) : void 0;
            case 7:
            case 8:
            case 9:
                return Debug.fail("Does not apply");
            default:
                return Debug.assertNever(kind);
        }
    }
    function isPossiblyAliasedThisProperty(declaration, kind = getAssignmentDeclarationKind(declaration)) {
        if (kind === 4) {
            return true;
        }
        if (!isInJSFile(declaration) || kind !== 5 || !isIdentifier(declaration.left.expression)) {
            return false;
        }
        const name = declaration.left.expression.escapedText;
        const symbol = resolveName(declaration.left, name, 111551, void 0, void 0, true, true);
        return isThisInitializedDeclaration(symbol == null ? void 0 : symbol.valueDeclaration);
    }
    function getContextualTypeForThisPropertyAssignment(binaryExpression) {
        if (!binaryExpression.symbol) return getTypeOfExpression(binaryExpression.left);
        if (binaryExpression.symbol.valueDeclaration) {
            const annotated = getEffectiveTypeAnnotationNode(binaryExpression.symbol.valueDeclaration);
            if (annotated) {
                const type = getTypeFromTypeNode(annotated);
                if (type) {
                    return type;
                }
            }
        }
        const thisAccess = cast(binaryExpression.left, isAccessExpression);
        if (!isObjectLiteralMethod(getThisContainer(thisAccess.expression, false, false))) {
            return void 0;
        }
        const thisType = checkThisExpression(thisAccess.expression);
        const nameStr = getElementOrPropertyAccessName(thisAccess);
        return nameStr !== void 0 && getTypeOfPropertyOfContextualType(thisType, nameStr) || void 0;
    }
    function isCircularMappedProperty(symbol) {
        return !!(getCheckFlags(symbol) & 262144 && !symbol.links.type && findResolutionCycleStartIndex(symbol, 0) >= 0);
    }
    function getTypeOfPropertyOfContextualType(type, name, nameType) {
        return mapType(type, t => {
            var _a2;
            if (isGenericMappedType(t) && !t.declaration.nameType) {
                const constraint = getConstraintTypeFromMappedType(t);
                const constraintOfConstraint = getBaseConstraintOfType(constraint) || constraint;
                const propertyNameType = nameType || getStringLiteralType(unescapeLeadingUnderscores(name));
                if (isTypeAssignableTo(propertyNameType, constraintOfConstraint)) {
                    return substituteIndexedMappedType(t, propertyNameType);
                }
            } else if (t.flags & 3670016) {
                const prop = getPropertyOfType(t, name);
                if (prop) {
                    return isCircularMappedProperty(prop) ? void 0 : getTypeOfSymbol(prop);
                }
                if (isTupleType(t) && isNumericLiteralName(name) && +name >= 0) {
                    const restType = getElementTypeOfSliceOfTupleType(t, t.target.fixedLength, 0, false, true);
                    if (restType) {
                        return restType;
                    }
                }
                return (_a2 = findApplicableIndexInfo(getIndexInfosOfStructuredType(t), nameType || getStringLiteralType(unescapeLeadingUnderscores(name)))) == null ? void 0 : _a2.type;
            }
            return void 0;
        }, true);
    }
    function getContextualTypeForObjectLiteralMethod(node, contextFlags) {
        Debug.assert(isObjectLiteralMethod(node));
        if (node.flags & 33554432) {
            return void 0;
        }
        return getContextualTypeForObjectLiteralElement(node, contextFlags);
    }
    function getContextualTypeForObjectLiteralElement(element, contextFlags) {
        const objectLiteral = element.parent;
        const propertyAssignmentType = isPropertyAssignment(element) && getContextualTypeForVariableLikeDeclaration(element, contextFlags);
        if (propertyAssignmentType) {
            return propertyAssignmentType;
        }
        const type = getApparentTypeOfContextualType(objectLiteral, contextFlags);
        if (type) {
            if (hasBindableName(element)) {
                const symbol = getSymbolOfDeclaration(element);
                return getTypeOfPropertyOfContextualType(type, symbol.escapedName, getSymbolLinks(symbol).nameType);
            }
            if (element.name) {
                const nameType = getLiteralTypeFromPropertyName(element.name);
                return mapType(type, t => {
                    var _a2;
                    return (_a2 = findApplicableIndexInfo(getIndexInfosOfStructuredType(t), nameType)) == null ? void 0 : _a2.type;
                }, true);
            }
        }
        return void 0;
    }
    function getContextualTypeForElementExpression(arrayContextualType, index) {
        return arrayContextualType && (index >= 0 && getTypeOfPropertyOfContextualType(arrayContextualType, "" + index) || mapType(arrayContextualType, t => isTupleType(t) ? getElementTypeOfSliceOfTupleType(t, 0, 0, false, true) : getIteratedTypeOrElementType(1, t, undefinedType, void 0, false), true));
    }
    function getContextualTypeForConditionalOperand(node, contextFlags) {
        const conditional = node.parent;
        return node === conditional.whenTrue || node === conditional.whenFalse ? getContextualType2(conditional, contextFlags) : void 0;
    }
    function getContextualTypeForChildJsxExpression(node, child, contextFlags) {
        const attributesType = getApparentTypeOfContextualType(node.openingElement.tagName, contextFlags);
        const jsxChildrenPropertyName = getJsxElementChildrenPropertyName(getJsxNamespaceAt(node));
        if (!(attributesType && !isTypeAny(attributesType) && jsxChildrenPropertyName && jsxChildrenPropertyName !== "")) {
            return void 0;
        }
        const realChildren = getSemanticJsxChildren(node.children);
        const childIndex = realChildren.indexOf(child);
        const childFieldType = getTypeOfPropertyOfContextualType(attributesType, jsxChildrenPropertyName);
        return childFieldType && (realChildren.length === 1 ? childFieldType : mapType(childFieldType, t => {
            if (isArrayLikeType(t)) {
                return getIndexedAccessType(t, getNumberLiteralType(childIndex));
            } else {
                return t;
            }
        }, true));
    }
    function getContextualTypeForJsxExpression(node, contextFlags) {
        const exprParent = node.parent;
        return isJsxAttributeLike(exprParent) ? getContextualType2(node, contextFlags) : isJsxElement(exprParent) ? getContextualTypeForChildJsxExpression(exprParent, node, contextFlags) : void 0;
    }
    function getContextualTypeForJsxAttribute(attribute, contextFlags) {
        if (isJsxAttribute(attribute)) {
            const attributesType = getApparentTypeOfContextualType(attribute.parent, contextFlags);
            if (!attributesType || isTypeAny(attributesType)) {
                return void 0;
            }
            return getTypeOfPropertyOfContextualType(attributesType, attribute.name.escapedText);
        } else {
            return getContextualType2(attribute.parent, contextFlags);
        }
    }
    function isPossiblyDiscriminantValue(node) {
        switch (node.kind) {
            case 10:
            case 8:
            case 9:
            case 14:
            case 110:
            case 95:
            case 104:
            case 79:
            case 155:
                return true;
            case 208:
            case 214:
                return isPossiblyDiscriminantValue(node.expression);
            case 291:
                return !node.expression || isPossiblyDiscriminantValue(node.expression);
        }
        return false;
    }
    function discriminateContextualTypeByObjectMembers(node, contextualType) {
        return getMatchingUnionConstituentForObjectLiteral(contextualType, node) || discriminateTypeByDiscriminableItems(contextualType, concatenate(map(filter(node.properties, p => !!p.symbol && p.kind === 299 && isPossiblyDiscriminantValue(p.initializer) && isDiscriminantProperty(contextualType, p.symbol.escapedName)), prop => [() => getContextFreeTypeOfExpression(prop.initializer), prop.symbol.escapedName]), map(filter(getPropertiesOfType(contextualType), s => {
            var _a2;
            return !!(s.flags & 16777216) && !!((_a2 = node == null ? void 0 : node.symbol) == null ? void 0 : _a2.members) && !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName);
        }), s => [() => undefinedType, s.escapedName])), isTypeAssignableTo, contextualType);
    }
    function discriminateContextualTypeByJSXAttributes(node, contextualType) {
        return discriminateTypeByDiscriminableItems(contextualType, concatenate(map(filter(node.properties, p => !!p.symbol && p.kind === 288 && isDiscriminantProperty(contextualType, p.symbol.escapedName) && (!p.initializer || isPossiblyDiscriminantValue(p.initializer))), prop => [!prop.initializer ? () => trueType : () => getContextFreeTypeOfExpression(prop.initializer), prop.symbol.escapedName]), map(filter(getPropertiesOfType(contextualType), s => {
            var _a2;
            return !!(s.flags & 16777216) && !!((_a2 = node == null ? void 0 : node.symbol) == null ? void 0 : _a2.members) && !node.symbol.members.has(s.escapedName) && isDiscriminantProperty(contextualType, s.escapedName);
        }), s => [() => undefinedType, s.escapedName])), isTypeAssignableTo, contextualType);
    }
    function getApparentTypeOfContextualType(node, contextFlags) {
        const contextualType = isObjectLiteralMethod(node) ? getContextualTypeForObjectLiteralMethod(node, contextFlags) : getContextualType2(node, contextFlags);
        const instantiatedType = instantiateContextualType(contextualType, node, contextFlags);
        if (instantiatedType && !(contextFlags && contextFlags & 2 && instantiatedType.flags & 8650752)) {
            const apparentType = mapType(instantiatedType, getApparentType, true);
            return apparentType.flags & 1048576 && isObjectLiteralExpression(node) ? discriminateContextualTypeByObjectMembers(node, apparentType) : apparentType.flags & 1048576 && isJsxAttributes(node) ? discriminateContextualTypeByJSXAttributes(node, apparentType) : apparentType;
        }
    }
    function instantiateContextualType(contextualType, node, contextFlags) {
        if (contextualType && maybeTypeOfKind(contextualType, 465829888)) {
            const inferenceContext = getInferenceContext(node);
            if (inferenceContext && contextFlags & 1 && some(inferenceContext.inferences, hasInferenceCandidatesOrDefault)) {
                return instantiateInstantiableTypes(contextualType, inferenceContext.nonFixingMapper);
            }
            if (inferenceContext == null ? void 0 : inferenceContext.returnMapper) {
                const type = instantiateInstantiableTypes(contextualType, inferenceContext.returnMapper);
                return type.flags & 1048576 && containsType(type.types, regularFalseType) && containsType(type.types, regularTrueType) ? filterType(type, t => t !== regularFalseType && t !== regularTrueType) : type;
            }
        }
        return contextualType;
    }
    function instantiateInstantiableTypes(type, mapper) {
        if (type.flags & 465829888) {
            return instantiateType(type, mapper);
        }
        if (type.flags & 1048576) {
            return getUnionType(map(type.types, t => instantiateInstantiableTypes(t, mapper)), 0);
        }
        if (type.flags & 2097152) {
            return getIntersectionType(map(type.types, t => instantiateInstantiableTypes(t, mapper)));
        }
        return type;
    }
    function getContextualType2(node, contextFlags) {
        var _a2, _b;
        if (node.flags & 33554432) {
            return void 0;
        }
        const index = findContextualNode(node, !contextFlags);
        if (index >= 0) {
            return contextualTypes[index];
        }
        const {
            parent: parent2
        } = node;
        switch (parent2.kind) {
            case 257:
            case 166:
            case 169:
            case 168:
            case 205:
                return getContextualTypeForInitializerExpression(node, contextFlags);
            case 216:
            case 250:
                return getContextualTypeForReturnExpression(node, contextFlags);
            case 226:
                return getContextualTypeForYieldOperand(parent2, contextFlags);
            case 220:
                return getContextualTypeForAwaitOperand(parent2, contextFlags);
            case 210:
            case 211:
                return getContextualTypeForArgument(parent2, node);
            case 167:
                return getContextualTypeForDecorator(parent2);
            case 213:
            case 231:
                return isConstTypeReference(parent2.type) ? getContextualType2(parent2, contextFlags) : getTypeFromTypeNode(parent2.type);
            case 223:
                return getContextualTypeForBinaryOperand(node, contextFlags);
            case 299:
            case 300:
                return getContextualTypeForObjectLiteralElement(parent2, contextFlags);
            case 301:
                return getContextualType2(parent2.parent, contextFlags);
            case 206:
                {
                    const arrayLiteral = parent2;
                    const type = getApparentTypeOfContextualType(arrayLiteral, contextFlags);
                    const spreadIndex = (_b = (_a2 = getNodeLinks(arrayLiteral)).firstSpreadIndex) != null ? _b : _a2.firstSpreadIndex = findIndex(arrayLiteral.elements, isSpreadElement);
                    const elementIndex = indexOfNode(arrayLiteral.elements, node);
                    return getContextualTypeForElementExpression(type, spreadIndex < 0 || elementIndex < spreadIndex ? elementIndex : -1);
                }
            case 224:
                return getContextualTypeForConditionalOperand(node, contextFlags);
            case 236:
                Debug.assert(parent2.parent.kind === 225);
                return getContextualTypeForSubstitutionExpression(parent2.parent, node);
            case 214:
                {
                    if (isInJSFile(parent2)) {
                        if (isJSDocSatisfiesExpression(parent2)) {
                            return getTypeFromTypeNode(getJSDocSatisfiesExpressionType(parent2));
                        }
                        const typeTag = getJSDocTypeTag(parent2);
                        if (typeTag && !isConstTypeReference(typeTag.typeExpression.type)) {
                            return getTypeFromTypeNode(typeTag.typeExpression.type);
                        }
                    }
                    return getContextualType2(parent2, contextFlags);
                }
            case 232:
                return getContextualType2(parent2, contextFlags);
            case 235:
                return getTypeFromTypeNode(parent2.type);
            case 274:
                return tryGetTypeFromEffectiveTypeNode(parent2);
            case 291:
                return getContextualTypeForJsxExpression(parent2, contextFlags);
            case 288:
            case 290:
                return getContextualTypeForJsxAttribute(parent2, contextFlags);
            case 283:
            case 282:
                return getContextualJsxElementAttributesType(parent2, contextFlags);
        }
        return void 0;
    }
    function pushCachedContextualType(node) {
        pushContextualType(node, getContextualType2(node, void 0), true);
    }
    function pushContextualType(node, type, isCache) {
        contextualTypeNodes[contextualTypeCount] = node;
        contextualTypes[contextualTypeCount] = type;
        contextualIsCache[contextualTypeCount] = isCache;
        contextualTypeCount++;
    }
    function popContextualType() {
        contextualTypeCount--;
    }
    function findContextualNode(node, includeCaches) {
        for (let i = contextualTypeCount - 1; i >= 0; i--) {
            if (node === contextualTypeNodes[i] && (includeCaches || !contextualIsCache[i])) {
                return i;
            }
        }
        return -1;
    }
    function pushInferenceContext(node, inferenceContext) {
        inferenceContextNodes[inferenceContextCount] = node;
        inferenceContexts[inferenceContextCount] = inferenceContext;
        inferenceContextCount++;
    }
    function popInferenceContext() {
        inferenceContextCount--;
    }
    function getInferenceContext(node) {
        for (let i = inferenceContextCount - 1; i >= 0; i--) {
            if (isNodeDescendantOf(node, inferenceContextNodes[i])) {
                return inferenceContexts[i];
            }
        }
    }
    function getContextualJsxElementAttributesType(node, contextFlags) {
        if (isJsxOpeningElement(node) && contextFlags !== 4) {
            const index = findContextualNode(node.parent, !contextFlags);
            if (index >= 0) {
                return contextualTypes[index];
            }
        }
        return getContextualTypeForArgumentAtIndex(node, 0);
    }
    function getEffectiveFirstArgumentForJsxSignature(signature, node) {
        return getJsxReferenceKind(node) !== 0 ? getJsxPropsTypeFromCallSignature(signature, node) : getJsxPropsTypeFromClassType(signature, node);
    }
    function getJsxPropsTypeFromCallSignature(sig, context) {
        let propsType = getTypeOfFirstParameterOfSignatureWithFallback(sig, unknownType);
        propsType = getJsxManagedAttributesFromLocatedAttributes(context, getJsxNamespaceAt(context), propsType);
        const intrinsicAttribs = getJsxType(JsxNames.IntrinsicAttributes, context);
        if (!isErrorType(intrinsicAttribs)) {
            propsType = intersectTypes(intrinsicAttribs, propsType);
        }
        return propsType;
    }
    function getJsxPropsTypeForSignatureFromMember(sig, forcedLookupLocation) {
        if (sig.compositeSignatures) {
            const results = [];
            for (const signature of sig.compositeSignatures) {
                const instance = getReturnTypeOfSignature(signature);
                if (isTypeAny(instance)) {
                    return instance;
                }
                const propType = getTypeOfPropertyOfType(instance, forcedLookupLocation);
                if (!propType) {
                    return;
                }
                results.push(propType);
            }
            return getIntersectionType(results);
        }
        const instanceType = getReturnTypeOfSignature(sig);
        return isTypeAny(instanceType) ? instanceType : getTypeOfPropertyOfType(instanceType, forcedLookupLocation);
    }
    function getStaticTypeOfReferencedJsxConstructor(context) {
        if (isJsxIntrinsicIdentifier(context.tagName)) {
            const result = getIntrinsicAttributesTypeFromJsxOpeningLikeElement(context);
            const fakeSignature = createSignatureForJSXIntrinsic(context, result);
            return getOrCreateTypeFromSignature(fakeSignature);
        }
        const tagType = checkExpressionCached(context.tagName);
        if (tagType.flags & 128) {
            const result = getIntrinsicAttributesTypeFromStringLiteralType(tagType, context);
            if (!result) {
                return errorType;
            }
            const fakeSignature = createSignatureForJSXIntrinsic(context, result);
            return getOrCreateTypeFromSignature(fakeSignature);
        }
        return tagType;
    }
    function getJsxManagedAttributesFromLocatedAttributes(context, ns, attributesType) {
        const managedSym = getJsxLibraryManagedAttributes(ns);
        if (managedSym) {
            const declaredManagedType = getDeclaredTypeOfSymbol(managedSym);
            const ctorType = getStaticTypeOfReferencedJsxConstructor(context);
            if (managedSym.flags & 524288) {
                const params = getSymbolLinks(managedSym).typeParameters;
                if (length(params) >= 2) {
                    const args = fillMissingTypeArguments([ctorType, attributesType], params, 2, isInJSFile(context));
                    return getTypeAliasInstantiation(managedSym, args);
                }
            }
            if (length(declaredManagedType.typeParameters) >= 2) {
                const args = fillMissingTypeArguments([ctorType, attributesType], declaredManagedType.typeParameters, 2, isInJSFile(context));
                return createTypeReference(declaredManagedType, args);
            }
        }
        return attributesType;
    }
    function getJsxPropsTypeFromClassType(sig, context) {
        const ns = getJsxNamespaceAt(context);
        const forcedLookupLocation = getJsxElementPropertiesName(ns);
        let attributesType = forcedLookupLocation === void 0 ? getTypeOfFirstParameterOfSignatureWithFallback(sig, unknownType) : forcedLookupLocation === "" ? getReturnTypeOfSignature(sig) : getJsxPropsTypeForSignatureFromMember(sig, forcedLookupLocation);
        if (!attributesType) {
            if (!!forcedLookupLocation && !!length(context.attributes.properties)) {
                error(context, Diagnostics.JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property, unescapeLeadingUnderscores(forcedLookupLocation));
            }
            return unknownType;
        }
        attributesType = getJsxManagedAttributesFromLocatedAttributes(context, ns, attributesType);
        if (isTypeAny(attributesType)) {
            return attributesType;
        } else {
            let apparentAttributesType = attributesType;
            const intrinsicClassAttribs = getJsxType(JsxNames.IntrinsicClassAttributes, context);
            if (!isErrorType(intrinsicClassAttribs)) {
                const typeParams = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(intrinsicClassAttribs.symbol);
                const hostClassType = getReturnTypeOfSignature(sig);
                let libraryManagedAttributeType;
                if (typeParams) {
                    const inferredArgs = fillMissingTypeArguments([hostClassType], typeParams, getMinTypeArgumentCount(typeParams), isInJSFile(context));
                    libraryManagedAttributeType = instantiateType(intrinsicClassAttribs, createTypeMapper(typeParams, inferredArgs));
                } else libraryManagedAttributeType = intrinsicClassAttribs;
                apparentAttributesType = intersectTypes(libraryManagedAttributeType, apparentAttributesType);
            }
            const intrinsicAttribs = getJsxType(JsxNames.IntrinsicAttributes, context);
            if (!isErrorType(intrinsicAttribs)) {
                apparentAttributesType = intersectTypes(intrinsicAttribs, apparentAttributesType);
            }
            return apparentAttributesType;
        }
    }
    function getIntersectedSignatures(signatures) {
        return getStrictOptionValue(compilerOptions, "noImplicitAny") ? reduceLeft(signatures, (left, right) => left === right || !left ? left : compareTypeParametersIdentical(left.typeParameters, right.typeParameters) ? combineSignaturesOfIntersectionMembers(left, right) : void 0) : void 0;
    }
    function combineIntersectionThisParam(left, right, mapper) {
        if (!left || !right) {
            return left || right;
        }
        const thisType = getUnionType([getTypeOfSymbol(left), instantiateType(getTypeOfSymbol(right), mapper)]);
        return createSymbolWithType(left, thisType);
    }
    function combineIntersectionParameters(left, right, mapper) {
        const leftCount = getParameterCount(left);
        const rightCount = getParameterCount(right);
        const longest = leftCount >= rightCount ? left : right;
        const shorter = longest === left ? right : left;
        const longestCount = longest === left ? leftCount : rightCount;
        const eitherHasEffectiveRest = hasEffectiveRestParameter(left) || hasEffectiveRestParameter(right);
        const needsExtraRestElement = eitherHasEffectiveRest && !hasEffectiveRestParameter(longest);
        const params = new Array(longestCount + (needsExtraRestElement ? 1 : 0));
        for (let i = 0; i < longestCount; i++) {
            let longestParamType = tryGetTypeAtPosition(longest, i);
            if (longest === right) {
                longestParamType = instantiateType(longestParamType, mapper);
            }
            let shorterParamType = tryGetTypeAtPosition(shorter, i) || unknownType;
            if (shorter === right) {
                shorterParamType = instantiateType(shorterParamType, mapper);
            }
            const unionParamType = getUnionType([longestParamType, shorterParamType]);
            const isRestParam = eitherHasEffectiveRest && !needsExtraRestElement && i === longestCount - 1;
            const isOptional = i >= getMinArgumentCount(longest) && i >= getMinArgumentCount(shorter);
            const leftName = i >= leftCount ? void 0 : getParameterNameAtPosition(left, i);
            const rightName = i >= rightCount ? void 0 : getParameterNameAtPosition(right, i);
            const paramName = leftName === rightName ? leftName : !leftName ? rightName : !rightName ? leftName : void 0;
            const paramSymbol = createSymbol(1 | (isOptional && !isRestParam ? 16777216 : 0), paramName || `arg${i}`);
            paramSymbol.links.type = isRestParam ? createArrayType(unionParamType) : unionParamType;
            params[i] = paramSymbol;
        }
        if (needsExtraRestElement) {
            const restParamSymbol = createSymbol(1, "args");
            restParamSymbol.links.type = createArrayType(getTypeAtPosition(shorter, longestCount));
            if (shorter === right) {
                restParamSymbol.links.type = instantiateType(restParamSymbol.links.type, mapper);
            }
            params[longestCount] = restParamSymbol;
        }
        return params;
    }
    function combineSignaturesOfIntersectionMembers(left, right) {
        const typeParams = left.typeParameters || right.typeParameters;
        let paramMapper;
        if (left.typeParameters && right.typeParameters) {
            paramMapper = createTypeMapper(right.typeParameters, left.typeParameters);
        }
        const declaration = left.declaration;
        const params = combineIntersectionParameters(left, right, paramMapper);
        const thisParam = combineIntersectionThisParam(left.thisParameter, right.thisParameter, paramMapper);
        const minArgCount = Math.max(left.minArgumentCount, right.minArgumentCount);
        const result = createSignature(declaration, typeParams, thisParam, params, void 0, void 0, minArgCount, (left.flags | right.flags) & 39);
        result.compositeKind = 2097152;
        result.compositeSignatures = concatenate(left.compositeKind === 2097152 && left.compositeSignatures || [left], [right]);
        if (paramMapper) {
            result.mapper = left.compositeKind === 2097152 && left.mapper && left.compositeSignatures ? combineTypeMappers(left.mapper, paramMapper) : paramMapper;
        }
        return result;
    }
    function getContextualCallSignature(type, node) {
        const signatures = getSignaturesOfType(type, 0);
        const applicableByArity = filter(signatures, s => !isAritySmaller(s, node));
        return applicableByArity.length === 1 ? applicableByArity[0] : getIntersectedSignatures(applicableByArity);
    }
    function isAritySmaller(signature, target) {
        let targetParameterCount = 0;
        for (; targetParameterCount < target.parameters.length; targetParameterCount++) {
            const param = target.parameters[targetParameterCount];
            if (param.initializer || param.questionToken || param.dotDotDotToken || isJSDocOptionalParameter(param)) {
                break;
            }
        }
        if (target.parameters.length && parameterIsThisKeyword(target.parameters[0])) {
            targetParameterCount--;
        }
        return !hasEffectiveRestParameter(signature) && getParameterCount(signature) < targetParameterCount;
    }
    function getContextualSignatureForFunctionLikeDeclaration(node) {
        return isFunctionExpressionOrArrowFunction(node) || isObjectLiteralMethod(node) ? getContextualSignature(node) : void 0;
    }
    function getContextualSignature(node) {
        Debug.assert(node.kind !== 171 || isObjectLiteralMethod(node));
        const typeTagSignature = getSignatureOfTypeTag(node);
        if (typeTagSignature) {
            return typeTagSignature;
        }
        const type = getApparentTypeOfContextualType(node, 1);
        if (!type) {
            return void 0;
        }
        if (!(type.flags & 1048576)) {
            return getContextualCallSignature(type, node);
        }
        let signatureList;
        const types = type.types;
        for (const current of types) {
            const signature = getContextualCallSignature(current, node);
            if (signature) {
                if (!signatureList) {
                    signatureList = [signature];
                } else if (!compareSignaturesIdentical(signatureList[0], signature, false, true, true, compareTypesIdentical)) {
                    return void 0;
                } else {
                    signatureList.push(signature);
                }
            }
        }
        if (signatureList) {
            return signatureList.length === 1 ? signatureList[0] : createUnionSignature(signatureList[0], signatureList);
        }
    }
    function checkSpreadExpression(node, checkMode) {
        if (languageVersion < 2) {
            checkExternalEmitHelpers(node, compilerOptions.downlevelIteration ? 1536 : 1024);
        }
        const arrayOrIterableType = checkExpression(node.expression, checkMode);
        return checkIteratedTypeOrElementType(33, arrayOrIterableType, undefinedType, node.expression);
    }
    function checkSyntheticExpression(node) {
        return node.isSpread ? getIndexedAccessType(node.type, numberType) : node.type;
    }
    function hasDefaultValue(node) {
        return node.kind === 205 && !!node.initializer || node.kind === 223 && node.operatorToken.kind === 63;
    }
    function checkArrayLiteral(node, checkMode, forceTuple) {
        const elements = node.elements;
        const elementCount = elements.length;
        const elementTypes = [];
        const elementFlags = [];
        pushCachedContextualType(node);
        const inDestructuringPattern = isAssignmentTarget(node);
        const inConstContext = isConstContext(node);
        const contextualType = getApparentTypeOfContextualType(node, void 0);
        const inTupleContext = !!contextualType && someType(contextualType, isTupleLikeType);
        let hasOmittedExpression = false;
        for (let i = 0; i < elementCount; i++) {
            const e = elements[i];
            if (e.kind === 227) {
                if (languageVersion < 2) {
                    checkExternalEmitHelpers(e, compilerOptions.downlevelIteration ? 1536 : 1024);
                }
                const spreadType = checkExpression(e.expression, checkMode, forceTuple);
                if (isArrayLikeType(spreadType)) {
                    elementTypes.push(spreadType);
                    elementFlags.push(8);
                } else if (inDestructuringPattern) {
                    const restElementType = getIndexTypeOfType(spreadType, numberType) || getIteratedTypeOrElementType(65, spreadType, undefinedType, void 0, false) || unknownType;
                    elementTypes.push(restElementType);
                    elementFlags.push(4);
                } else {
                    elementTypes.push(checkIteratedTypeOrElementType(33, spreadType, undefinedType, e.expression));
                    elementFlags.push(4);
                }
            } else if (exactOptionalPropertyTypes && e.kind === 229) {
                hasOmittedExpression = true;
                elementTypes.push(undefinedOrMissingType);
                elementFlags.push(2);
            } else {
                const type = checkExpressionForMutableLocation(e, checkMode, forceTuple);
                elementTypes.push(addOptionality(type, true, hasOmittedExpression));
                elementFlags.push(hasOmittedExpression ? 2 : 1);
                if (inTupleContext && checkMode && checkMode & 2 && !(checkMode & 4) && isContextSensitive(e)) {
                    const inferenceContext = getInferenceContext(node);
                    Debug.assert(inferenceContext);
                    addIntraExpressionInferenceSite(inferenceContext, e, type);
                }
            }
        }
        popContextualType();
        if (inDestructuringPattern) {
            return createTupleType(elementTypes, elementFlags);
        }
        if (forceTuple || inConstContext || inTupleContext) {
            return createArrayLiteralType(createTupleType(elementTypes, elementFlags, inConstContext));
        }
        return createArrayLiteralType(createArrayType(elementTypes.length ? getUnionType(sameMap(elementTypes, (t, i) => elementFlags[i] & 8 ? getIndexedAccessTypeOrUndefined(t, numberType) || anyType : t), 2) : strictNullChecks ? implicitNeverType : undefinedWideningType, inConstContext));
    }
    function createArrayLiteralType(type) {
        if (!(getObjectFlags(type) & 4)) {
            return type;
        }
        let literalType = type.literalType;
        if (!literalType) {
            literalType = type.literalType = cloneTypeReference(type);
            literalType.objectFlags |= 16384 | 131072;
        }
        return literalType;
    }
    function isNumericName(name) {
        switch (name.kind) {
            case 164:
                return isNumericComputedName(name);
            case 79:
                return isNumericLiteralName(name.escapedText);
            case 8:
            case 10:
                return isNumericLiteralName(name.text);
            default:
                return false;
        }
    }
    function isNumericComputedName(name) {
        return isTypeAssignableToKind(checkComputedPropertyName(name), 296);
    }
    function checkComputedPropertyName(node) {
        const links = getNodeLinks(node.expression);
        if (!links.resolvedType) {
            if ((isTypeLiteralNode(node.parent.parent) || isClassLike(node.parent.parent) || isInterfaceDeclaration(node.parent.parent)) && isBinaryExpression(node.expression) && node.expression.operatorToken.kind === 101 && node.parent.kind !== 174 && node.parent.kind !== 175) {
                return links.resolvedType = errorType;
            }
            links.resolvedType = checkExpression(node.expression);
            if (isPropertyDeclaration(node.parent) && !hasStaticModifier(node.parent) && isClassExpression(node.parent.parent)) {
                const container = getEnclosingBlockScopeContainer(node.parent.parent);
                const enclosingIterationStatement = getEnclosingIterationStatement(container);
                if (enclosingIterationStatement) {
                    getNodeLinks(enclosingIterationStatement).flags |= 4096;
                    getNodeLinks(node).flags |= 32768;
                    getNodeLinks(node.parent.parent).flags |= 32768;
                }
            }
            if (links.resolvedType.flags & 98304 || !isTypeAssignableToKind(links.resolvedType, 402653316 | 296 | 12288) && !isTypeAssignableTo(links.resolvedType, stringNumberSymbolType)) {
                error(node, Diagnostics.A_computed_property_name_must_be_of_type_string_number_symbol_or_any);
            }
        }
        return links.resolvedType;
    }
    function isSymbolWithNumericName(symbol) {
        var _a2;
        const firstDecl = (_a2 = symbol.declarations) == null ? void 0 : _a2[0];
        return isNumericLiteralName(symbol.escapedName) || firstDecl && isNamedDeclaration(firstDecl) && isNumericName(firstDecl.name);
    }
    function isSymbolWithSymbolName(symbol) {
        var _a2;
        const firstDecl = (_a2 = symbol.declarations) == null ? void 0 : _a2[0];
        return isKnownSymbol(symbol) || firstDecl && isNamedDeclaration(firstDecl) && isComputedPropertyName(firstDecl.name) && isTypeAssignableToKind(checkComputedPropertyName(firstDecl.name), 4096);
    }
    function getObjectLiteralIndexInfo(node, offset, properties, keyType) {
        const propTypes = [];
        for (let i = offset; i < properties.length; i++) {
            const prop = properties[i];
            if (keyType === stringType && !isSymbolWithSymbolName(prop) || keyType === numberType && isSymbolWithNumericName(prop) || keyType === esSymbolType && isSymbolWithSymbolName(prop)) {
                propTypes.push(getTypeOfSymbol(properties[i]));
            }
        }
        const unionType = propTypes.length ? getUnionType(propTypes, 2) : undefinedType;
        return createIndexInfo(keyType, unionType, isConstContext(node));
    }
    function getImmediateAliasedSymbol(symbol) {
        Debug.assert((symbol.flags & 2097152) !== 0, "Should only get Alias here.");
        const links = getSymbolLinks(symbol);
        if (!links.immediateTarget) {
            const node = getDeclarationOfAliasSymbol(symbol);
            if (!node) return Debug.fail();
            links.immediateTarget = getTargetOfAliasDeclaration(node, true);
        }
        return links.immediateTarget;
    }
    function checkObjectLiteral(node, checkMode) {
        var _a2;
        const inDestructuringPattern = isAssignmentTarget(node);
        checkGrammarObjectLiteralExpression(node, inDestructuringPattern);
        const allPropertiesTable = strictNullChecks ? createSymbolTable() : void 0;
        let propertiesTable = createSymbolTable();
        let propertiesArray = [];
        let spread = emptyObjectType;
        pushCachedContextualType(node);
        const contextualType = getApparentTypeOfContextualType(node, void 0);
        const contextualTypeHasPattern = contextualType && contextualType.pattern && (contextualType.pattern.kind === 203 || contextualType.pattern.kind === 207);
        const inConstContext = isConstContext(node);
        const checkFlags = inConstContext ? 8 : 0;
        const isInJavascript = isInJSFile(node) && !isInJsonFile(node);
        const enumTag = getJSDocEnumTag(node);
        const isJSObjectLiteral = !contextualType && isInJavascript && !enumTag;
        let objectFlags = freshObjectLiteralFlag;
        let patternWithComputedProperties = false;
        let hasComputedStringProperty = false;
        let hasComputedNumberProperty = false;
        let hasComputedSymbolProperty = false;
        for (const elem of node.properties) {
            if (elem.name && isComputedPropertyName(elem.name)) {
                checkComputedPropertyName(elem.name);
            }
        }
        let offset = 0;
        for (const memberDecl of node.properties) {
            let member = getSymbolOfDeclaration(memberDecl);
            const computedNameType = memberDecl.name && memberDecl.name.kind === 164 ? checkComputedPropertyName(memberDecl.name) : void 0;
            if (memberDecl.kind === 299 || memberDecl.kind === 300 || isObjectLiteralMethod(memberDecl)) {
                let type = memberDecl.kind === 299 ? checkPropertyAssignment(memberDecl, checkMode) : memberDecl.kind === 300 ? checkExpressionForMutableLocation(!inDestructuringPattern && memberDecl.objectAssignmentInitializer ? memberDecl.objectAssignmentInitializer : memberDecl.name, checkMode) : checkObjectLiteralMethod(memberDecl, checkMode);
                if (isInJavascript) {
                    const jsDocType = getTypeForDeclarationFromJSDocComment(memberDecl);
                    if (jsDocType) {
                        checkTypeAssignableTo(type, jsDocType, memberDecl);
                        type = jsDocType;
                    } else if (enumTag && enumTag.typeExpression) {
                        checkTypeAssignableTo(type, getTypeFromTypeNode(enumTag.typeExpression), memberDecl);
                    }
                }
                objectFlags |= getObjectFlags(type) & 458752;
                const nameType = computedNameType && isTypeUsableAsPropertyName(computedNameType) ? computedNameType : void 0;
                const prop = nameType ? createSymbol(4 | member.flags, getPropertyNameFromType(nameType), checkFlags | 4096) : createSymbol(4 | member.flags, member.escapedName, checkFlags);
                if (nameType) {
                    prop.links.nameType = nameType;
                }
                if (inDestructuringPattern) {
                    const isOptional = memberDecl.kind === 299 && hasDefaultValue(memberDecl.initializer) || memberDecl.kind === 300 && memberDecl.objectAssignmentInitializer;
                    if (isOptional) {
                        prop.flags |= 16777216;
                    }
                } else if (contextualTypeHasPattern && !(getObjectFlags(contextualType) & 512)) {
                    const impliedProp = getPropertyOfType(contextualType, member.escapedName);
                    if (impliedProp) {
                        prop.flags |= impliedProp.flags & 16777216;
                    } else if (!compilerOptions.suppressExcessPropertyErrors && !getIndexInfoOfType(contextualType, stringType)) {
                        error(memberDecl.name, Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, symbolToString(member), typeToString(contextualType));
                    }
                }
                prop.declarations = member.declarations;
                prop.parent = member.parent;
                if (member.valueDeclaration) {
                    prop.valueDeclaration = member.valueDeclaration;
                }
                prop.links.type = type;
                prop.links.target = member;
                member = prop;
                allPropertiesTable == null ? void 0 : allPropertiesTable.set(prop.escapedName, prop);
                if (contextualType && checkMode && checkMode & 2 && !(checkMode & 4) && (memberDecl.kind === 299 || memberDecl.kind === 171) && isContextSensitive(memberDecl)) {
                    const inferenceContext = getInferenceContext(node);
                    Debug.assert(inferenceContext);
                    const inferenceNode = memberDecl.kind === 299 ? memberDecl.initializer : memberDecl;
                    addIntraExpressionInferenceSite(inferenceContext, inferenceNode, type);
                }
            } else if (memberDecl.kind === 301) {
                if (languageVersion < 2) {
                    checkExternalEmitHelpers(memberDecl, 2);
                }
                if (propertiesArray.length > 0) {
                    spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext);
                    propertiesArray = [];
                    propertiesTable = createSymbolTable();
                    hasComputedStringProperty = false;
                    hasComputedNumberProperty = false;
                    hasComputedSymbolProperty = false;
                }
                const type = getReducedType(checkExpression(memberDecl.expression));
                if (isValidSpreadType(type)) {
                    const mergedType = tryMergeUnionOfObjectTypeAndEmptyObject(type, inConstContext);
                    if (allPropertiesTable) {
                        checkSpreadPropOverrides(mergedType, allPropertiesTable, memberDecl);
                    }
                    offset = propertiesArray.length;
                    if (isErrorType(spread)) {
                        continue;
                    }
                    spread = getSpreadType(spread, mergedType, node.symbol, objectFlags, inConstContext);
                } else {
                    error(memberDecl, Diagnostics.Spread_types_may_only_be_created_from_object_types);
                    spread = errorType;
                }
                continue;
            } else {
                Debug.assert(memberDecl.kind === 174 || memberDecl.kind === 175);
                checkNodeDeferred(memberDecl);
            }
            if (computedNameType && !(computedNameType.flags & 8576)) {
                if (isTypeAssignableTo(computedNameType, stringNumberSymbolType)) {
                    if (isTypeAssignableTo(computedNameType, numberType)) {
                        hasComputedNumberProperty = true;
                    } else if (isTypeAssignableTo(computedNameType, esSymbolType)) {
                        hasComputedSymbolProperty = true;
                    } else {
                        hasComputedStringProperty = true;
                    }
                    if (inDestructuringPattern) {
                        patternWithComputedProperties = true;
                    }
                }
            } else {
                propertiesTable.set(member.escapedName, member);
            }
            propertiesArray.push(member);
        }
        popContextualType();
        if (contextualTypeHasPattern) {
            const rootPatternParent = findAncestor(contextualType.pattern.parent, n => n.kind === 257 || n.kind === 223 || n.kind === 166);
            const spreadOrOutsideRootObject = findAncestor(node, n => n === rootPatternParent || n.kind === 301);
            if (spreadOrOutsideRootObject.kind !== 301) {
                for (const prop of getPropertiesOfType(contextualType)) {
                    if (!propertiesTable.get(prop.escapedName) && !getPropertyOfType(spread, prop.escapedName)) {
                        if (!(prop.flags & 16777216)) {
                            error(prop.valueDeclaration || ((_a2 = tryCast(prop, isTransientSymbol)) == null ? void 0 : _a2.links.bindingElement), Diagnostics.Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value);
                        }
                        propertiesTable.set(prop.escapedName, prop);
                        propertiesArray.push(prop);
                    }
                }
            }
        }
        if (isErrorType(spread)) {
            return errorType;
        }
        if (spread !== emptyObjectType) {
            if (propertiesArray.length > 0) {
                spread = getSpreadType(spread, createObjectLiteralType(), node.symbol, objectFlags, inConstContext);
                propertiesArray = [];
                propertiesTable = createSymbolTable();
                hasComputedStringProperty = false;
                hasComputedNumberProperty = false;
            }
            return mapType(spread, t => t === emptyObjectType ? createObjectLiteralType() : t);
        }
        return createObjectLiteralType();
        function createObjectLiteralType() {
            const indexInfos = [];
            if (hasComputedStringProperty) indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, stringType));
            if (hasComputedNumberProperty) indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, numberType));
            if (hasComputedSymbolProperty) indexInfos.push(getObjectLiteralIndexInfo(node, offset, propertiesArray, esSymbolType));
            const result = createAnonymousType(node.symbol, propertiesTable, emptyArray, emptyArray, indexInfos);
            result.objectFlags |= objectFlags | 128 | 131072;
            if (isJSObjectLiteral) {
                result.objectFlags |= 4096;
            }
            if (patternWithComputedProperties) {
                result.objectFlags |= 512;
            }
            if (inDestructuringPattern) {
                result.pattern = node;
            }
            return result;
        }
    }
    function isValidSpreadType(type) {
        const t = removeDefinitelyFalsyTypes(mapType(type, getBaseConstraintOrType));
        return !!(t.flags & (1 | 67108864 | 524288 | 58982400) || t.flags & 3145728 && every(t.types, isValidSpreadType));
    }
    function checkJsxSelfClosingElementDeferred(node) {
        checkJsxOpeningLikeElementOrOpeningFragment(node);
    }
    function checkJsxSelfClosingElement(node, _checkMode) {
        checkNodeDeferred(node);
        return getJsxElementTypeAt(node) || anyType;
    }
    function checkJsxElementDeferred(node) {
        checkJsxOpeningLikeElementOrOpeningFragment(node.openingElement);
        if (isJsxIntrinsicIdentifier(node.closingElement.tagName)) {
            getIntrinsicTagSymbol(node.closingElement);
        } else {
            checkExpression(node.closingElement.tagName);
        }
        checkJsxChildren(node);
    }
    function checkJsxElement(node, _checkMode) {
        checkNodeDeferred(node);
        return getJsxElementTypeAt(node) || anyType;
    }
    function checkJsxFragment(node) {
        checkJsxOpeningLikeElementOrOpeningFragment(node.openingFragment);
        const nodeSourceFile = getSourceFileOfNode(node);
        if (getJSXTransformEnabled(compilerOptions) && (compilerOptions.jsxFactory || nodeSourceFile.pragmas.has("jsx")) && !compilerOptions.jsxFragmentFactory && !nodeSourceFile.pragmas.has("jsxfrag")) {
            error(node, compilerOptions.jsxFactory ? Diagnostics.The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_compiler_option : Diagnostics.An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments);
        }
        checkJsxChildren(node);
        return getJsxElementTypeAt(node) || anyType;
    }
    function isHyphenatedJsxName(name) {
        return stringContains(name, "-");
    }
    function isJsxIntrinsicIdentifier(tagName) {
        return tagName.kind === 79 && isIntrinsicJsxName(tagName.escapedText);
    }
    function checkJsxAttribute(node, checkMode) {
        return node.initializer ? checkExpressionForMutableLocation(node.initializer, checkMode) : trueType;
    }
    function createJsxAttributesTypeFromAttributesProperty(openingLikeElement, checkMode) {
        const attributes = openingLikeElement.attributes;
        const attributesType = getContextualType2(attributes, 0);
        const allAttributesTable = strictNullChecks ? createSymbolTable() : void 0;
        let attributesTable = createSymbolTable();
        let spread = emptyJsxObjectType;
        let hasSpreadAnyType = false;
        let typeToIntersect;
        let explicitlySpecifyChildrenAttribute = false;
        let objectFlags = 2048;
        const jsxChildrenPropertyName = getJsxElementChildrenPropertyName(getJsxNamespaceAt(openingLikeElement));
        for (const attributeDecl of attributes.properties) {
            const member = attributeDecl.symbol;
            if (isJsxAttribute(attributeDecl)) {
                const exprType = checkJsxAttribute(attributeDecl, checkMode);
                objectFlags |= getObjectFlags(exprType) & 458752;
                const attributeSymbol = createSymbol(4 | member.flags, member.escapedName);
                attributeSymbol.declarations = member.declarations;
                attributeSymbol.parent = member.parent;
                if (member.valueDeclaration) {
                    attributeSymbol.valueDeclaration = member.valueDeclaration;
                }
                attributeSymbol.links.type = exprType;
                attributeSymbol.links.target = member;
                attributesTable.set(attributeSymbol.escapedName, attributeSymbol);
                allAttributesTable == null ? void 0 : allAttributesTable.set(attributeSymbol.escapedName, attributeSymbol);
                if (attributeDecl.name.escapedText === jsxChildrenPropertyName) {
                    explicitlySpecifyChildrenAttribute = true;
                }
                if (attributesType) {
                    const prop = getPropertyOfType(attributesType, member.escapedName);
                    if (prop && prop.declarations && isDeprecatedSymbol(prop)) {
                        addDeprecatedSuggestion(attributeDecl.name, prop.declarations, attributeDecl.name.escapedText);
                    }
                }
            } else {
                Debug.assert(attributeDecl.kind === 290);
                if (attributesTable.size > 0) {
                    spread = getSpreadType(spread, createJsxAttributesType(), attributes.symbol, objectFlags, false);
                    attributesTable = createSymbolTable();
                }
                const exprType = getReducedType(checkExpressionCached(attributeDecl.expression, checkMode));
                if (isTypeAny(exprType)) {
                    hasSpreadAnyType = true;
                }
                if (isValidSpreadType(exprType)) {
                    spread = getSpreadType(spread, exprType, attributes.symbol, objectFlags, false);
                    if (allAttributesTable) {
                        checkSpreadPropOverrides(exprType, allAttributesTable, attributeDecl);
                    }
                } else {
                    error(attributeDecl.expression, Diagnostics.Spread_types_may_only_be_created_from_object_types);
                    typeToIntersect = typeToIntersect ? getIntersectionType([typeToIntersect, exprType]) : exprType;
                }
            }
        }
        if (!hasSpreadAnyType) {
            if (attributesTable.size > 0) {
                spread = getSpreadType(spread, createJsxAttributesType(), attributes.symbol, objectFlags, false);
            }
        }
        const parent2 = openingLikeElement.parent.kind === 281 ? openingLikeElement.parent : void 0;
        if (parent2 && parent2.openingElement === openingLikeElement && parent2.children.length > 0) {
            const childrenTypes = checkJsxChildren(parent2, checkMode);
            if (!hasSpreadAnyType && jsxChildrenPropertyName && jsxChildrenPropertyName !== "") {
                if (explicitlySpecifyChildrenAttribute) {
                    error(attributes, Diagnostics._0_are_specified_twice_The_attribute_named_0_will_be_overwritten, unescapeLeadingUnderscores(jsxChildrenPropertyName));
                }
                const contextualType = getApparentTypeOfContextualType(openingLikeElement.attributes, void 0);
                const childrenContextualType = contextualType && getTypeOfPropertyOfContextualType(contextualType, jsxChildrenPropertyName);
                const childrenPropSymbol = createSymbol(4, jsxChildrenPropertyName);
                childrenPropSymbol.links.type = childrenTypes.length === 1 ? childrenTypes[0] : childrenContextualType && someType(childrenContextualType, isTupleLikeType) ? createTupleType(childrenTypes) : createArrayType(getUnionType(childrenTypes));
                childrenPropSymbol.valueDeclaration = factory.createPropertySignature(void 0, unescapeLeadingUnderscores(jsxChildrenPropertyName), void 0, void 0);
                setParent(childrenPropSymbol.valueDeclaration, attributes);
                childrenPropSymbol.valueDeclaration.symbol = childrenPropSymbol;
                const childPropMap = createSymbolTable();
                childPropMap.set(jsxChildrenPropertyName, childrenPropSymbol);
                spread = getSpreadType(spread, createAnonymousType(attributes.symbol, childPropMap, emptyArray, emptyArray, emptyArray), attributes.symbol, objectFlags, false);
            }
        }
        if (hasSpreadAnyType) {
            return anyType;
        }
        if (typeToIntersect && spread !== emptyJsxObjectType) {
            return getIntersectionType([typeToIntersect, spread]);
        }
        return typeToIntersect || (spread === emptyJsxObjectType ? createJsxAttributesType() : spread);
        function createJsxAttributesType() {
            objectFlags |= freshObjectLiteralFlag;
            const result = createAnonymousType(attributes.symbol, attributesTable, emptyArray, emptyArray, emptyArray);
            result.objectFlags |= objectFlags | 128 | 131072;
            return result;
        }
    }
    function checkJsxChildren(node, checkMode) {
        const childrenTypes = [];
        for (const child of node.children) {
            if (child.kind === 11) {
                if (!child.containsOnlyTriviaWhiteSpaces) {
                    childrenTypes.push(stringType);
                }
            } else if (child.kind === 291 && !child.expression) {
                continue;
            } else {
                childrenTypes.push(checkExpressionForMutableLocation(child, checkMode));
            }
        }
        return childrenTypes;
    }
    function checkSpreadPropOverrides(type, props, spread) {
        for (const right of getPropertiesOfType(type)) {
            if (!(right.flags & 16777216)) {
                const left = props.get(right.escapedName);
                if (left) {
                    const diagnostic = error(left.valueDeclaration, Diagnostics._0_is_specified_more_than_once_so_this_usage_will_be_overwritten, unescapeLeadingUnderscores(left.escapedName));
                    addRelatedInfo(diagnostic, createDiagnosticForNode(spread, Diagnostics.This_spread_always_overwrites_this_property));
                }
            }
        }
    }
    function checkJsxAttributes(node, checkMode) {
        return createJsxAttributesTypeFromAttributesProperty(node.parent, checkMode);
    }
    function getJsxType(name, location) {
        const namespace = getJsxNamespaceAt(location);
        const exports = namespace && getExportsOfSymbol(namespace);
        const typeSymbol = exports && getSymbol2(exports, name, 788968);
        return typeSymbol ? getDeclaredTypeOfSymbol(typeSymbol) : errorType;
    }
    function getIntrinsicTagSymbol(node) {
        const links = getNodeLinks(node);
        if (!links.resolvedSymbol) {
            const intrinsicElementsType = getJsxType(JsxNames.IntrinsicElements, node);
            if (!isErrorType(intrinsicElementsType)) {
                if (!isIdentifier(node.tagName)) return Debug.fail();
                const intrinsicProp = getPropertyOfType(intrinsicElementsType, node.tagName.escapedText);
                if (intrinsicProp) {
                    links.jsxFlags |= 1;
                    return links.resolvedSymbol = intrinsicProp;
                }
                const indexSignatureType = getIndexTypeOfType(intrinsicElementsType, stringType);
                if (indexSignatureType) {
                    links.jsxFlags |= 2;
                    return links.resolvedSymbol = intrinsicElementsType.symbol;
                }
                error(node, Diagnostics.Property_0_does_not_exist_on_type_1, idText(node.tagName), "JSX." + JsxNames.IntrinsicElements);
                return links.resolvedSymbol = unknownSymbol;
            } else {
                if (noImplicitAny) {
                    error(node, Diagnostics.JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists, unescapeLeadingUnderscores(JsxNames.IntrinsicElements));
                }
                return links.resolvedSymbol = unknownSymbol;
            }
        }
        return links.resolvedSymbol;
    }
    function getJsxNamespaceContainerForImplicitImport(location) {
        const file = location && getSourceFileOfNode(location);
        const links = file && getNodeLinks(file);
        if (links && links.jsxImplicitImportContainer === false) {
            return void 0;
        }
        if (links && links.jsxImplicitImportContainer) {
            return links.jsxImplicitImportContainer;
        }
        const runtimeImportSpecifier = getJSXRuntimeImport(getJSXImplicitImportBase(compilerOptions, file), compilerOptions);
        if (!runtimeImportSpecifier) {
            return void 0;
        }
        const isClassic = getEmitModuleResolutionKind(compilerOptions) === 1;
        const errorMessage = isClassic ? Diagnostics.Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option : Diagnostics.Cannot_find_module_0_or_its_corresponding_type_declarations;
        const mod = resolveExternalModule(location, runtimeImportSpecifier, errorMessage, location);
        const result = mod && mod !== unknownSymbol ? getMergedSymbol(resolveSymbol(mod)) : void 0;
        if (links) {
            links.jsxImplicitImportContainer = result || false;
        }
        return result;
    }
    function getJsxNamespaceAt(location) {
        const links = location && getNodeLinks(location);
        if (links && links.jsxNamespace) {
            return links.jsxNamespace;
        }
        if (!links || links.jsxNamespace !== false) {
            let resolvedNamespace = getJsxNamespaceContainerForImplicitImport(location);
            if (!resolvedNamespace || resolvedNamespace === unknownSymbol) {
                const namespaceName = getJsxNamespace(location);
                resolvedNamespace = resolveName(location, namespaceName, 1920, void 0, namespaceName, false);
            }
            if (resolvedNamespace) {
                const candidate = resolveSymbol(getSymbol2(getExportsOfSymbol(resolveSymbol(resolvedNamespace)), JsxNames.JSX, 1920));
                if (candidate && candidate !== unknownSymbol) {
                    if (links) {
                        links.jsxNamespace = candidate;
                    }
                    return candidate;
                }
            }
            if (links) {
                links.jsxNamespace = false;
            }
        }
        const s = resolveSymbol(getGlobalSymbol(JsxNames.JSX, 1920, void 0));
        if (s === unknownSymbol) {
            return void 0;
        }
        return s;
    }
    function getNameFromJsxElementAttributesContainer(nameOfAttribPropContainer, jsxNamespace) {
        const jsxElementAttribPropInterfaceSym = jsxNamespace && getSymbol2(jsxNamespace.exports, nameOfAttribPropContainer, 788968);
        const jsxElementAttribPropInterfaceType = jsxElementAttribPropInterfaceSym && getDeclaredTypeOfSymbol(jsxElementAttribPropInterfaceSym);
        const propertiesOfJsxElementAttribPropInterface = jsxElementAttribPropInterfaceType && getPropertiesOfType(jsxElementAttribPropInterfaceType);
        if (propertiesOfJsxElementAttribPropInterface) {
            if (propertiesOfJsxElementAttribPropInterface.length === 0) {
                return "";
            } else if (propertiesOfJsxElementAttribPropInterface.length === 1) {
                return propertiesOfJsxElementAttribPropInterface[0].escapedName;
            } else if (propertiesOfJsxElementAttribPropInterface.length > 1 && jsxElementAttribPropInterfaceSym.declarations) {
                error(jsxElementAttribPropInterfaceSym.declarations[0], Diagnostics.The_global_type_JSX_0_may_not_have_more_than_one_property, unescapeLeadingUnderscores(nameOfAttribPropContainer));
            }
        }
        return void 0;
    }
    function getJsxLibraryManagedAttributes(jsxNamespace) {
        return jsxNamespace && getSymbol2(jsxNamespace.exports, JsxNames.LibraryManagedAttributes, 788968);
    }
    function getJsxElementPropertiesName(jsxNamespace) {
        return getNameFromJsxElementAttributesContainer(JsxNames.ElementAttributesPropertyNameContainer, jsxNamespace);
    }
    function getJsxElementChildrenPropertyName(jsxNamespace) {
        return getNameFromJsxElementAttributesContainer(JsxNames.ElementChildrenAttributeNameContainer, jsxNamespace);
    }
    function getUninstantiatedJsxSignaturesOfType(elementType, caller) {
        if (elementType.flags & 4) {
            return [anySignature];
        } else if (elementType.flags & 128) {
            const intrinsicType = getIntrinsicAttributesTypeFromStringLiteralType(elementType, caller);
            if (!intrinsicType) {
                error(caller, Diagnostics.Property_0_does_not_exist_on_type_1, elementType.value, "JSX." + JsxNames.IntrinsicElements);
                return emptyArray;
            } else {
                const fakeSignature = createSignatureForJSXIntrinsic(caller, intrinsicType);
                return [fakeSignature];
            }
        }
        const apparentElemType = getApparentType(elementType);
        let signatures = getSignaturesOfType(apparentElemType, 1);
        if (signatures.length === 0) {
            signatures = getSignaturesOfType(apparentElemType, 0);
        }
        if (signatures.length === 0 && apparentElemType.flags & 1048576) {
            signatures = getUnionSignatures(map(apparentElemType.types, t => getUninstantiatedJsxSignaturesOfType(t, caller)));
        }
        return signatures;
    }
    function getIntrinsicAttributesTypeFromStringLiteralType(type, location) {
        const intrinsicElementsType = getJsxType(JsxNames.IntrinsicElements, location);
        if (!isErrorType(intrinsicElementsType)) {
            const stringLiteralTypeName = type.value;
            const intrinsicProp = getPropertyOfType(intrinsicElementsType, escapeLeadingUnderscores(stringLiteralTypeName));
            if (intrinsicProp) {
                return getTypeOfSymbol(intrinsicProp);
            }
            const indexSignatureType = getIndexTypeOfType(intrinsicElementsType, stringType);
            if (indexSignatureType) {
                return indexSignatureType;
            }
            return void 0;
        }
        return anyType;
    }
    function checkJsxReturnAssignableToAppropriateBound(refKind, elemInstanceType, openingLikeElement) {
        if (refKind === 1) {
            const sfcReturnConstraint = getJsxStatelessElementTypeAt(openingLikeElement);
            if (sfcReturnConstraint) {
                checkTypeRelatedTo(elemInstanceType, sfcReturnConstraint, assignableRelation, openingLikeElement.tagName, Diagnostics.Its_return_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain);
            }
        } else if (refKind === 0) {
            const classConstraint = getJsxElementClassTypeAt(openingLikeElement);
            if (classConstraint) {
                checkTypeRelatedTo(elemInstanceType, classConstraint, assignableRelation, openingLikeElement.tagName, Diagnostics.Its_instance_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain);
            }
        } else {
            const sfcReturnConstraint = getJsxStatelessElementTypeAt(openingLikeElement);
            const classConstraint = getJsxElementClassTypeAt(openingLikeElement);
            if (!sfcReturnConstraint || !classConstraint) {
                return;
            }
            const combined = getUnionType([sfcReturnConstraint, classConstraint]);
            checkTypeRelatedTo(elemInstanceType, combined, assignableRelation, openingLikeElement.tagName, Diagnostics.Its_element_type_0_is_not_a_valid_JSX_element, generateInitialErrorChain);
        }
        function generateInitialErrorChain() {
            const componentName = getTextOfNode(openingLikeElement.tagName);
            return chainDiagnosticMessages(void 0, Diagnostics._0_cannot_be_used_as_a_JSX_component, componentName);
        }
    }
    function getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node) {
        Debug.assert(isJsxIntrinsicIdentifier(node.tagName));
        const links = getNodeLinks(node);
        if (!links.resolvedJsxElementAttributesType) {
            const symbol = getIntrinsicTagSymbol(node);
            if (links.jsxFlags & 1) {
                return links.resolvedJsxElementAttributesType = getTypeOfSymbol(symbol) || errorType;
            } else if (links.jsxFlags & 2) {
                return links.resolvedJsxElementAttributesType = getIndexTypeOfType(getJsxType(JsxNames.IntrinsicElements, node), stringType) || errorType;
            } else {
                return links.resolvedJsxElementAttributesType = errorType;
            }
        }
        return links.resolvedJsxElementAttributesType;
    }
    function getJsxElementClassTypeAt(location) {
        const type = getJsxType(JsxNames.ElementClass, location);
        if (isErrorType(type)) return void 0;
        return type;
    }
    function getJsxElementTypeAt(location) {
        return getJsxType(JsxNames.Element, location);
    }
    function getJsxStatelessElementTypeAt(location) {
        const jsxElementType = getJsxElementTypeAt(location);
        if (jsxElementType) {
            return getUnionType([jsxElementType, nullType]);
        }
    }
    function getJsxIntrinsicTagNamesAt(location) {
        const intrinsics = getJsxType(JsxNames.IntrinsicElements, location);
        return intrinsics ? getPropertiesOfType(intrinsics) : emptyArray;
    }
    function checkJsxPreconditions(errorNode) {
        if ((compilerOptions.jsx || 0) === 0) {
            error(errorNode, Diagnostics.Cannot_use_JSX_unless_the_jsx_flag_is_provided);
        }
        if (getJsxElementTypeAt(errorNode) === void 0) {
            if (noImplicitAny) {
                error(errorNode, Diagnostics.JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist);
            }
        }
    }
    function checkJsxOpeningLikeElementOrOpeningFragment(node) {
        const isNodeOpeningLikeElement = isJsxOpeningLikeElement(node);
        if (isNodeOpeningLikeElement) {
            checkGrammarJsxElement(node);
        }
        checkJsxPreconditions(node);
        if (!getJsxNamespaceContainerForImplicitImport(node)) {
            const jsxFactoryRefErr = diagnostics && compilerOptions.jsx === 2 ? Diagnostics.Cannot_find_name_0 : void 0;
            const jsxFactoryNamespace = getJsxNamespace(node);
            const jsxFactoryLocation = isNodeOpeningLikeElement ? node.tagName : node;
            let jsxFactorySym;
            if (!(isJsxOpeningFragment(node) && jsxFactoryNamespace === "null")) {
                jsxFactorySym = resolveName(jsxFactoryLocation, jsxFactoryNamespace, 111551, jsxFactoryRefErr, jsxFactoryNamespace, true);
            }
            if (jsxFactorySym) {
                jsxFactorySym.isReferenced = 67108863;
                if (!compilerOptions.verbatimModuleSyntax && jsxFactorySym.flags & 2097152 && !getTypeOnlyAliasDeclaration(jsxFactorySym)) {
                    markAliasSymbolAsReferenced(jsxFactorySym);
                }
            }
            if (isJsxOpeningFragment(node)) {
                const file = getSourceFileOfNode(node);
                const localJsxNamespace = getLocalJsxNamespace(file);
                if (localJsxNamespace) {
                    resolveName(jsxFactoryLocation, localJsxNamespace, 111551, jsxFactoryRefErr, localJsxNamespace, true);
                }
            }
        }
        if (isNodeOpeningLikeElement) {
            const jsxOpeningLikeNode = node;
            const sig = getResolvedSignature(jsxOpeningLikeNode);
            checkDeprecatedSignature(sig, node);
            checkJsxReturnAssignableToAppropriateBound(getJsxReferenceKind(jsxOpeningLikeNode), getReturnTypeOfSignature(sig), jsxOpeningLikeNode);
        }
    }
    function isKnownProperty(targetType, name, isComparingJsxAttributes) {
        if (targetType.flags & 524288) {
            if (getPropertyOfObjectType(targetType, name) || getApplicableIndexInfoForName(targetType, name) || isLateBoundName(name) && getIndexInfoOfType(targetType, stringType) || isComparingJsxAttributes && isHyphenatedJsxName(name)) {
                return true;
            }
        } else if (targetType.flags & 3145728 && isExcessPropertyCheckTarget(targetType)) {
            for (const t of targetType.types) {
                if (isKnownProperty(t, name, isComparingJsxAttributes)) {
                    return true;
                }
            }
        }
        return false;
    }
    function isExcessPropertyCheckTarget(type) {
        return !!(type.flags & 524288 && !(getObjectFlags(type) & 512) || type.flags & 67108864 || type.flags & 1048576 && some(type.types, isExcessPropertyCheckTarget) || type.flags & 2097152 && every(type.types, isExcessPropertyCheckTarget));
    }
    function checkJsxExpression(node, checkMode) {
        checkGrammarJsxExpression(node);
        if (node.expression) {
            const type = checkExpression(node.expression, checkMode);
            if (node.dotDotDotToken && type !== anyType && !isArrayType(type)) {
                error(node, Diagnostics.JSX_spread_child_must_be_an_array_type);
            }
            return type;
        } else {
            return errorType;
        }
    }
    function getDeclarationNodeFlagsFromSymbol(s) {
        return s.valueDeclaration ? getCombinedNodeFlags(s.valueDeclaration) : 0;
    }
    function isPrototypeProperty(symbol) {
        if (symbol.flags & 8192 || getCheckFlags(symbol) & 4) {
            return true;
        }
        if (isInJSFile(symbol.valueDeclaration)) {
            const parent2 = symbol.valueDeclaration.parent;
            return parent2 && isBinaryExpression(parent2) && getAssignmentDeclarationKind(parent2) === 3;
        }
    }
    function checkPropertyAccessibility(node, isSuper, writing, type, prop, reportError = true) {
        const errorNode = !reportError ? void 0 : node.kind === 163 ? node.right : node.kind === 202 ? node : node.kind === 205 && node.propertyName ? node.propertyName : node.name;
        return checkPropertyAccessibilityAtLocation(node, isSuper, writing, type, prop, errorNode);
    }
    function checkPropertyAccessibilityAtLocation(location, isSuper, writing, containingType, prop, errorNode) {
        const flags = getDeclarationModifierFlagsFromSymbol(prop, writing);
        if (isSuper) {
            if (languageVersion < 2) {
                if (symbolHasNonMethodDeclaration(prop)) {
                    if (errorNode) {
                        error(errorNode, Diagnostics.Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword);
                    }
                    return false;
                }
            }
            if (flags & 256) {
                if (errorNode) {
                    error(errorNode, Diagnostics.Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression, symbolToString(prop), typeToString(getDeclaringClass(prop)));
                }
                return false;
            }
        }
        if (flags & 256 && symbolHasNonMethodDeclaration(prop) && (isThisProperty(location) || isThisInitializedObjectBindingExpression(location) || isObjectBindingPattern(location.parent) && isThisInitializedDeclaration(location.parent.parent))) {
            const declaringClassDeclaration = getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop));
            if (declaringClassDeclaration && isNodeUsedDuringClassInitialization(location)) {
                if (errorNode) {
                    error(errorNode, Diagnostics.Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor, symbolToString(prop), getTextOfIdentifierOrLiteral(declaringClassDeclaration.name));
                }
                return false;
            }
        }
        if (!(flags & 24)) {
            return true;
        }
        if (flags & 8) {
            const declaringClassDeclaration = getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop));
            if (!isNodeWithinClass(location, declaringClassDeclaration)) {
                if (errorNode) {
                    error(errorNode, Diagnostics.Property_0_is_private_and_only_accessible_within_class_1, symbolToString(prop), typeToString(getDeclaringClass(prop)));
                }
                return false;
            }
            return true;
        }
        if (isSuper) {
            return true;
        }
        let enclosingClass = forEachEnclosingClass(location, enclosingDeclaration => {
            const enclosingClass2 = getDeclaredTypeOfSymbol(getSymbolOfDeclaration(enclosingDeclaration));
            return isClassDerivedFromDeclaringClasses(enclosingClass2, prop, writing);
        });
        if (!enclosingClass) {
            enclosingClass = getEnclosingClassFromThisParameter(location);
            enclosingClass = enclosingClass && isClassDerivedFromDeclaringClasses(enclosingClass, prop, writing);
            if (flags & 32 || !enclosingClass) {
                if (errorNode) {
                    error(errorNode, Diagnostics.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses, symbolToString(prop), typeToString(getDeclaringClass(prop) || containingType));
                }
                return false;
            }
        }
        if (flags & 32) {
            return true;
        }
        if (containingType.flags & 262144) {
            containingType = containingType.isThisType ? getConstraintOfTypeParameter(containingType) : getBaseConstraintOfType(containingType);
        }
        if (!containingType || !hasBaseType(containingType, enclosingClass)) {
            if (errorNode) {
                error(errorNode, Diagnostics.Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_class_2, symbolToString(prop), typeToString(enclosingClass), typeToString(containingType));
            }
            return false;
        }
        return true;
    }
    function getEnclosingClassFromThisParameter(node) {
        const thisParameter = getThisParameterFromNodeContext(node);
        let thisType = (thisParameter == null ? void 0 : thisParameter.type) && getTypeFromTypeNode(thisParameter.type);
        if (thisType && thisType.flags & 262144) {
            thisType = getConstraintOfTypeParameter(thisType);
        }
        if (thisType && getObjectFlags(thisType) & (3 | 4)) {
            return getTargetType(thisType);
        }
        return void 0;
    }
    function getThisParameterFromNodeContext(node) {
        const thisContainer = getThisContainer(node, false, false);
        return thisContainer && isFunctionLike(thisContainer) ? getThisParameter(thisContainer) : void 0;
    }
    function symbolHasNonMethodDeclaration(symbol) {
        return !!forEachProperty2(symbol, prop => !(prop.flags & 8192));
    }
    function checkNonNullExpression(node) {
        return checkNonNullType(checkExpression(node), node);
    }
    function isNullableType(type) {
        return !!(getTypeFacts(type) & 50331648);
    }
    function getNonNullableTypeIfNeeded(type) {
        return isNullableType(type) ? getNonNullableType(type) : type;
    }
    function reportObjectPossiblyNullOrUndefinedError(node, facts) {
        const nodeText2 = isEntityNameExpression(node) ? entityNameToString(node) : void 0;
        if (node.kind === 104) {
            error(node, Diagnostics.The_value_0_cannot_be_used_here, "null");
            return;
        }
        if (nodeText2 !== void 0 && nodeText2.length < 100) {
            if (isIdentifier(node) && nodeText2 === "undefined") {
                error(node, Diagnostics.The_value_0_cannot_be_used_here, "undefined");
                return;
            }
            error(node, facts & 16777216 ? facts & 33554432 ? Diagnostics._0_is_possibly_null_or_undefined : Diagnostics._0_is_possibly_undefined : Diagnostics._0_is_possibly_null, nodeText2);
        } else {
            error(node, facts & 16777216 ? facts & 33554432 ? Diagnostics.Object_is_possibly_null_or_undefined : Diagnostics.Object_is_possibly_undefined : Diagnostics.Object_is_possibly_null);
        }
    }
    function reportCannotInvokePossiblyNullOrUndefinedError(node, facts) {
        error(node, facts & 16777216 ? facts & 33554432 ? Diagnostics.Cannot_invoke_an_object_which_is_possibly_null_or_undefined : Diagnostics.Cannot_invoke_an_object_which_is_possibly_undefined : Diagnostics.Cannot_invoke_an_object_which_is_possibly_null);
    }
    function checkNonNullTypeWithReporter(type, node, reportError) {
        if (strictNullChecks && type.flags & 2) {
            if (isEntityNameExpression(node)) {
                const nodeText2 = entityNameToString(node);
                if (nodeText2.length < 100) {
                    error(node, Diagnostics._0_is_of_type_unknown, nodeText2);
                    return errorType;
                }
            }
            error(node, Diagnostics.Object_is_of_type_unknown);
            return errorType;
        }
        const facts = getTypeFacts(type);
        if (facts & 50331648) {
            reportError(node, facts);
            const t = getNonNullableType(type);
            return t.flags & (98304 | 131072) ? errorType : t;
        }
        return type;
    }
    function checkNonNullType(type, node) {
        return checkNonNullTypeWithReporter(type, node, reportObjectPossiblyNullOrUndefinedError);
    }
    function checkNonNullNonVoidType(type, node) {
        const nonNullType = checkNonNullType(type, node);
        if (nonNullType.flags & 16384) {
            if (isEntityNameExpression(node)) {
                const nodeText2 = entityNameToString(node);
                if (isIdentifier(node) && nodeText2 === "undefined") {
                    error(node, Diagnostics.The_value_0_cannot_be_used_here, nodeText2);
                    return nonNullType;
                }
                if (nodeText2.length < 100) {
                    error(node, Diagnostics._0_is_possibly_undefined, nodeText2);
                    return nonNullType;
                }
            }
            error(node, Diagnostics.Object_is_possibly_undefined);
        }
        return nonNullType;
    }
    function checkPropertyAccessExpression(node, checkMode) {
        return node.flags & 32 ? checkPropertyAccessChain(node, checkMode) : checkPropertyAccessExpressionOrQualifiedName(node, node.expression, checkNonNullExpression(node.expression), node.name, checkMode);
    }
    function checkPropertyAccessChain(node, checkMode) {
        const leftType = checkExpression(node.expression);
        const nonOptionalType = getOptionalExpressionType(leftType, node.expression);
        return propagateOptionalTypeMarker(checkPropertyAccessExpressionOrQualifiedName(node, node.expression, checkNonNullType(nonOptionalType, node.expression), node.name, checkMode), node, nonOptionalType !== leftType);
    }
    function checkQualifiedName(node, checkMode) {
        const leftType = isPartOfTypeQuery(node) && isThisIdentifier(node.left) ? checkNonNullType(checkThisExpression(node.left), node.left) : checkNonNullExpression(node.left);
        return checkPropertyAccessExpressionOrQualifiedName(node, node.left, leftType, node.right, checkMode);
    }
    function isMethodAccessForCall(node) {
        while (node.parent.kind === 214) {
            node = node.parent;
        }
        return isCallOrNewExpression(node.parent) && node.parent.expression === node;
    }
    function lookupSymbolForPrivateIdentifierDeclaration(propName, location) {
        for (let containingClass = getContainingClass(location); !!containingClass; containingClass = getContainingClass(containingClass)) {
            const {
                symbol
            } = containingClass;
            const name = getSymbolNameForPrivateIdentifier(symbol, propName);
            const prop = symbol.members && symbol.members.get(name) || symbol.exports && symbol.exports.get(name);
            if (prop) {
                return prop;
            }
        }
    }
    function checkGrammarPrivateIdentifierExpression(privId) {
        if (!getContainingClass(privId)) {
            return grammarErrorOnNode(privId, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
        }
        if (!isForInStatement(privId.parent)) {
            if (!isExpressionNode(privId)) {
                return grammarErrorOnNode(privId, Diagnostics.Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression);
            }
            const isInOperation = isBinaryExpression(privId.parent) && privId.parent.operatorToken.kind === 101;
            if (!getSymbolForPrivateIdentifierExpression(privId) && !isInOperation) {
                return grammarErrorOnNode(privId, Diagnostics.Cannot_find_name_0, idText(privId));
            }
        }
        return false;
    }
    function checkPrivateIdentifierExpression(privId) {
        checkGrammarPrivateIdentifierExpression(privId);
        const symbol = getSymbolForPrivateIdentifierExpression(privId);
        if (symbol) {
            markPropertyAsReferenced(symbol, void 0, false);
        }
        return anyType;
    }
    function getSymbolForPrivateIdentifierExpression(privId) {
        if (!isExpressionNode(privId)) {
            return void 0;
        }
        const links = getNodeLinks(privId);
        if (links.resolvedSymbol === void 0) {
            links.resolvedSymbol = lookupSymbolForPrivateIdentifierDeclaration(privId.escapedText, privId);
        }
        return links.resolvedSymbol;
    }
    function getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedIdentifier) {
        return getPropertyOfType(leftType, lexicallyScopedIdentifier.escapedName);
    }
    function checkPrivateIdentifierPropertyAccess(leftType, right, lexicallyScopedIdentifier) {
        let propertyOnType;
        const properties = getPropertiesOfType(leftType);
        if (properties) {
            forEach(properties, symbol => {
                const decl = symbol.valueDeclaration;
                if (decl && isNamedDeclaration(decl) && isPrivateIdentifier(decl.name) && decl.name.escapedText === right.escapedText) {
                    propertyOnType = symbol;
                    return true;
                }
            });
        }
        const diagName = diagnosticName(right);
        if (propertyOnType) {
            const typeValueDecl = Debug.checkDefined(propertyOnType.valueDeclaration);
            const typeClass = Debug.checkDefined(getContainingClass(typeValueDecl));
            if (lexicallyScopedIdentifier == null ? void 0 : lexicallyScopedIdentifier.valueDeclaration) {
                const lexicalValueDecl = lexicallyScopedIdentifier.valueDeclaration;
                const lexicalClass = getContainingClass(lexicalValueDecl);
                Debug.assert(!!lexicalClass);
                if (findAncestor(lexicalClass, n => typeClass === n)) {
                    const diagnostic = error(right, Diagnostics.The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_private_identifier_with_the_same_spelling, diagName, typeToString(leftType));
                    addRelatedInfo(diagnostic, createDiagnosticForNode(lexicalValueDecl, Diagnostics.The_shadowing_declaration_of_0_is_defined_here, diagName), createDiagnosticForNode(typeValueDecl, Diagnostics.The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here, diagName));
                    return true;
                }
            }
            error(right, Diagnostics.Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier, diagName, diagnosticName(typeClass.name || anon));
            return true;
        }
        return false;
    }
    function isThisPropertyAccessInConstructor(node, prop) {
        return (isConstructorDeclaredProperty(prop) || isThisProperty(node) && isAutoTypedProperty(prop)) && getThisContainer(node, true, false) === getDeclaringConstructor(prop);
    }
    function checkPropertyAccessExpressionOrQualifiedName(node, left, leftType, right, checkMode) {
        const parentSymbol = getNodeLinks(left).resolvedSymbol;
        const assignmentKind = getAssignmentTargetKind(node);
        const apparentType = getApparentType(assignmentKind !== 0 || isMethodAccessForCall(node) ? getWidenedType(leftType) : leftType);
        const isAnyLike = isTypeAny(apparentType) || apparentType === silentNeverType;
        let prop;
        if (isPrivateIdentifier(right)) {
            if (languageVersion < 99) {
                if (assignmentKind !== 0) {
                    checkExternalEmitHelpers(node, 1048576);
                }
                if (assignmentKind !== 1) {
                    checkExternalEmitHelpers(node, 524288);
                }
            }
            const lexicallyScopedSymbol = lookupSymbolForPrivateIdentifierDeclaration(right.escapedText, right);
            if (assignmentKind && lexicallyScopedSymbol && lexicallyScopedSymbol.valueDeclaration && isMethodDeclaration(lexicallyScopedSymbol.valueDeclaration)) {
                grammarErrorOnNode(right, Diagnostics.Cannot_assign_to_private_method_0_Private_methods_are_not_writable, idText(right));
            }
            if (isAnyLike) {
                if (lexicallyScopedSymbol) {
                    return isErrorType(apparentType) ? errorType : apparentType;
                }
                if (!getContainingClass(right)) {
                    grammarErrorOnNode(right, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
                    return anyType;
                }
            }
            prop = lexicallyScopedSymbol ? getPrivateIdentifierPropertyOfType(leftType, lexicallyScopedSymbol) : void 0;
            if (!prop && checkPrivateIdentifierPropertyAccess(leftType, right, lexicallyScopedSymbol)) {
                return errorType;
            } else {
                const isSetonlyAccessor = prop && prop.flags & 65536 && !(prop.flags & 32768);
                if (isSetonlyAccessor && assignmentKind !== 1) {
                    error(node, Diagnostics.Private_accessor_was_defined_without_a_getter);
                }
            }
        } else {
            if (isAnyLike) {
                if (isIdentifier(left) && parentSymbol) {
                    markAliasReferenced(parentSymbol, node);
                }
                return isErrorType(apparentType) ? errorType : apparentType;
            }
            prop = getPropertyOfType(apparentType, right.escapedText, false, node.kind === 163);
        }
        if (isIdentifier(left) && parentSymbol && (getIsolatedModules(compilerOptions) || !(prop && (isConstEnumOrConstEnumOnlyModule(prop) || prop.flags & 8 && node.parent.kind === 302)) || shouldPreserveConstEnums(compilerOptions) && isExportOrExportExpression(node))) {
            markAliasReferenced(parentSymbol, node);
        }
        let propType;
        if (!prop) {
            const indexInfo = !isPrivateIdentifier(right) && (assignmentKind === 0 || !isGenericObjectType(leftType) || isThisTypeParameter(leftType)) ? getApplicableIndexInfoForName(apparentType, right.escapedText) : void 0;
            if (!(indexInfo && indexInfo.type)) {
                const isUncheckedJS = isUncheckedJSSuggestion(node, leftType.symbol, true);
                if (!isUncheckedJS && isJSLiteralType(leftType)) {
                    return anyType;
                }
                if (leftType.symbol === globalThisSymbol) {
                    if (globalThisSymbol.exports.has(right.escapedText) && globalThisSymbol.exports.get(right.escapedText).flags & 418) {
                        error(right, Diagnostics.Property_0_does_not_exist_on_type_1, unescapeLeadingUnderscores(right.escapedText), typeToString(leftType));
                    } else if (noImplicitAny) {
                        error(right, Diagnostics.Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature, typeToString(leftType));
                    }
                    return anyType;
                }
                if (right.escapedText && !checkAndReportErrorForExtendingInterface(node)) {
                    reportNonexistentProperty(right, isThisTypeParameter(leftType) ? apparentType : leftType, isUncheckedJS);
                }
                return errorType;
            }
            if (indexInfo.isReadonly && (isAssignmentTarget(node) || isDeleteTarget(node))) {
                error(node, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(apparentType));
            }
            propType = compilerOptions.noUncheckedIndexedAccess && !isAssignmentTarget(node) ? getUnionType([indexInfo.type, missingType]) : indexInfo.type;
            if (compilerOptions.noPropertyAccessFromIndexSignature && isPropertyAccessExpression(node)) {
                error(right, Diagnostics.Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0, unescapeLeadingUnderscores(right.escapedText));
            }
            if (indexInfo.declaration && getCombinedNodeFlags(indexInfo.declaration) & 268435456) {
                addDeprecatedSuggestion(right, [indexInfo.declaration], right.escapedText);
            }
        } else {
            if (isDeprecatedSymbol(prop) && isUncalledFunctionReference(node, prop) && prop.declarations) {
                addDeprecatedSuggestion(right, prop.declarations, right.escapedText);
            }
            checkPropertyNotUsedBeforeDeclaration(prop, node, right);
            markPropertyAsReferenced(prop, node, isSelfTypeAccess(left, parentSymbol));
            getNodeLinks(node).resolvedSymbol = prop;
            const writing = isWriteAccess(node);
            checkPropertyAccessibility(node, left.kind === 106, writing, apparentType, prop);
            if (isAssignmentToReadonlyEntity(node, prop, assignmentKind)) {
                error(right, Diagnostics.Cannot_assign_to_0_because_it_is_a_read_only_property, idText(right));
                return errorType;
            }
            propType = isThisPropertyAccessInConstructor(node, prop) ? autoType : writing ? getWriteTypeOfSymbol(prop) : getTypeOfSymbol(prop);
        }
        return getFlowTypeOfAccessExpression(node, prop, propType, right, checkMode);
    }
    function isUncheckedJSSuggestion(node, suggestion, excludeClasses) {
        const file = getSourceFileOfNode(node);
        if (file) {
            if (compilerOptions.checkJs === void 0 && file.checkJsDirective === void 0 && (file.scriptKind === 1 || file.scriptKind === 2)) {
                const declarationFile = forEach(suggestion == null ? void 0 : suggestion.declarations, getSourceFileOfNode);
                return !(file !== declarationFile && !!declarationFile && isGlobalSourceFile(declarationFile)) && !(excludeClasses && suggestion && suggestion.flags & 32) && !(!!node && excludeClasses && isPropertyAccessExpression(node) && node.expression.kind === 108);
            }
        }
        return false;
    }
    function getFlowTypeOfAccessExpression(node, prop, propType, errorNode, checkMode) {
        const assignmentKind = getAssignmentTargetKind(node);
        if (assignmentKind === 1) {
            return removeMissingType(propType, !!(prop && prop.flags & 16777216));
        }
        if (prop && !(prop.flags & (3 | 4 | 98304)) && !(prop.flags & 8192 && propType.flags & 1048576) && !isDuplicatedCommonJSExport(prop.declarations)) {
            return propType;
        }
        if (propType === autoType) {
            return getFlowTypeOfProperty(node, prop);
        }
        propType = getNarrowableTypeForReference(propType, node, checkMode);
        let assumeUninitialized = false;
        if (strictNullChecks && strictPropertyInitialization && isAccessExpression(node) && node.expression.kind === 108) {
            const declaration = prop && prop.valueDeclaration;
            if (declaration && isPropertyWithoutInitializer(declaration)) {
                if (!isStatic(declaration)) {
                    const flowContainer = getControlFlowContainer(node);
                    if (flowContainer.kind === 173 && flowContainer.parent === declaration.parent && !(declaration.flags & 16777216)) {
                        assumeUninitialized = true;
                    }
                }
            }
        } else if (strictNullChecks && prop && prop.valueDeclaration && isPropertyAccessExpression(prop.valueDeclaration) && getAssignmentDeclarationPropertyAccessKind(prop.valueDeclaration) && getControlFlowContainer(node) === getControlFlowContainer(prop.valueDeclaration)) {
            assumeUninitialized = true;
        }
        const flowType = getFlowTypeOfReference(node, propType, assumeUninitialized ? getOptionalType(propType) : propType);
        if (assumeUninitialized && !containsUndefinedType(propType) && containsUndefinedType(flowType)) {
            error(errorNode, Diagnostics.Property_0_is_used_before_being_assigned, symbolToString(prop));
            return propType;
        }
        return assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType;
    }
    function checkPropertyNotUsedBeforeDeclaration(prop, node, right) {
        const {
            valueDeclaration
        } = prop;
        if (!valueDeclaration || getSourceFileOfNode(node).isDeclarationFile) {
            return;
        }
        let diagnosticMessage;
        const declarationName = idText(right);
        if (isInPropertyInitializerOrClassStaticBlock(node) && !isOptionalPropertyDeclaration(valueDeclaration) && !(isAccessExpression(node) && isAccessExpression(node.expression)) && !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right) && !(isMethodDeclaration(valueDeclaration) && getCombinedModifierFlags(valueDeclaration) & 32) && (compilerOptions.useDefineForClassFields || !isPropertyDeclaredInAncestorClass(prop))) {
            diagnosticMessage = error(right, Diagnostics.Property_0_is_used_before_its_initialization, declarationName);
        } else if (valueDeclaration.kind === 260 && node.parent.kind !== 180 && !(valueDeclaration.flags & 16777216) && !isBlockScopedNameDeclaredBeforeUse(valueDeclaration, right)) {
            diagnosticMessage = error(right, Diagnostics.Class_0_used_before_its_declaration, declarationName);
        }
        if (diagnosticMessage) {
            addRelatedInfo(diagnosticMessage, createDiagnosticForNode(valueDeclaration, Diagnostics._0_is_declared_here, declarationName));
        }
    }
    function isInPropertyInitializerOrClassStaticBlock(node) {
        return !!findAncestor(node, node2 => {
            switch (node2.kind) {
                case 169:
                    return true;
                case 299:
                case 171:
                case 174:
                case 175:
                case 301:
                case 164:
                case 236:
                case 291:
                case 288:
                case 289:
                case 290:
                case 283:
                case 230:
                case 294:
                    return false;
                case 216:
                case 241:
                    return isBlock(node2.parent) && isClassStaticBlockDeclaration(node2.parent.parent) ? true : "quit";
                default:
                    return isExpressionNode(node2) ? false : "quit";
            }
        });
    }
    function isPropertyDeclaredInAncestorClass(prop) {
        if (!(prop.parent.flags & 32)) {
            return false;
        }
        let classType = getTypeOfSymbol(prop.parent);
        while (true) {
            classType = classType.symbol && getSuperClass(classType);
            if (!classType) {
                return false;
            }
            const superProperty = getPropertyOfType(classType, prop.escapedName);
            if (superProperty && superProperty.valueDeclaration) {
                return true;
            }
        }
    }
    function getSuperClass(classType) {
        const x = getBaseTypes(classType);
        if (x.length === 0) {
            return void 0;
        }
        return getIntersectionType(x);
    }
    function reportNonexistentProperty(propNode, containingType, isUncheckedJS) {
        let errorInfo;
        let relatedInfo;
        if (!isPrivateIdentifier(propNode) && containingType.flags & 1048576 && !(containingType.flags & 134348796)) {
            for (const subtype of containingType.types) {
                if (!getPropertyOfType(subtype, propNode.escapedText) && !getApplicableIndexInfoForName(subtype, propNode.escapedText)) {
                    errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1, declarationNameToString(propNode), typeToString(subtype));
                    break;
                }
            }
        }
        if (typeHasStaticProperty(propNode.escapedText, containingType)) {
            const propName = declarationNameToString(propNode);
            const typeName = typeToString(containingType);
            errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead, propName, typeName, typeName + "." + propName);
        } else {
            const promisedType = getPromisedTypeOfPromise(containingType);
            if (promisedType && getPropertyOfType(promisedType, propNode.escapedText)) {
                errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1, declarationNameToString(propNode), typeToString(containingType));
                relatedInfo = createDiagnosticForNode(propNode, Diagnostics.Did_you_forget_to_use_await);
            } else {
                const missingProperty = declarationNameToString(propNode);
                const container = typeToString(containingType);
                const libSuggestion = getSuggestedLibForNonExistentProperty(missingProperty, containingType);
                if (libSuggestion !== void 0) {
                    errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2_or_later, missingProperty, container, libSuggestion);
                } else {
                    const suggestion = getSuggestedSymbolForNonexistentProperty(propNode, containingType);
                    if (suggestion !== void 0) {
                        const suggestedName = symbolName(suggestion);
                        const message = isUncheckedJS ? Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2 : Diagnostics.Property_0_does_not_exist_on_type_1_Did_you_mean_2;
                        errorInfo = chainDiagnosticMessages(errorInfo, message, missingProperty, container, suggestedName);
                        relatedInfo = suggestion.valueDeclaration && createDiagnosticForNode(suggestion.valueDeclaration, Diagnostics._0_is_declared_here, suggestedName);
                    } else {
                        const diagnostic = containerSeemsToBeEmptyDomElement(containingType) ? Diagnostics.Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom : Diagnostics.Property_0_does_not_exist_on_type_1;
                        errorInfo = chainDiagnosticMessages(elaborateNeverIntersection(errorInfo, containingType), diagnostic, missingProperty, container);
                    }
                }
            }
        }
        const resultDiagnostic = createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(propNode), propNode, errorInfo);
        if (relatedInfo) {
            addRelatedInfo(resultDiagnostic, relatedInfo);
        }
        addErrorOrSuggestion(!isUncheckedJS || errorInfo.code !== Diagnostics.Property_0_may_not_exist_on_type_1_Did_you_mean_2.code, resultDiagnostic);
    }
    function containerSeemsToBeEmptyDomElement(containingType) {
        return compilerOptions.lib && !compilerOptions.lib.includes("dom") && everyContainedType(containingType, type => type.symbol && /^(EventTarget|Node|((HTML[a-zA-Z]*)?Element))$/.test(unescapeLeadingUnderscores(type.symbol.escapedName))) && isEmptyObjectType(containingType);
    }
    function typeHasStaticProperty(propName, containingType) {
        const prop = containingType.symbol && getPropertyOfType(getTypeOfSymbol(containingType.symbol), propName);
        return prop !== void 0 && !!prop.valueDeclaration && isStatic(prop.valueDeclaration);
    }
    function getSuggestedLibForNonExistentName(name) {
        const missingName = diagnosticName(name);
        const allFeatures = getScriptTargetFeatures();
        const typeFeatures = allFeatures.get(missingName);
        return typeFeatures && firstIterator(typeFeatures.keys());
    }
    function getSuggestedLibForNonExistentProperty(missingProperty, containingType) {
        const container = getApparentType(containingType).symbol;
        if (!container) {
            return void 0;
        }
        const containingTypeName = symbolName(container);
        const allFeatures = getScriptTargetFeatures();
        const typeFeatures = allFeatures.get(containingTypeName);
        if (typeFeatures) {
            for (const [libTarget, featuresOfType] of typeFeatures) {
                if (contains(featuresOfType, missingProperty)) {
                    return libTarget;
                }
            }
        }
    }
    function getSuggestedSymbolForNonexistentClassMember(name, baseType) {
        return getSpellingSuggestionForName(name, getPropertiesOfType(baseType), 106500);
    }
    function getSuggestedSymbolForNonexistentProperty(name, containingType) {
        let props = getPropertiesOfType(containingType);
        if (typeof name !== "string") {
            const parent2 = name.parent;
            if (isPropertyAccessExpression(parent2)) {
                props = filter(props, prop => isValidPropertyAccessForCompletions(parent2, containingType, prop));
            }
            name = idText(name);
        }
        return getSpellingSuggestionForName(name, props, 111551);
    }
    function getSuggestedSymbolForNonexistentJSXAttribute(name, containingType) {
        const strName = isString(name) ? name : idText(name);
        const properties = getPropertiesOfType(containingType);
        const jsxSpecific = strName === "for" ? find(properties, x => symbolName(x) === "htmlFor") : strName === "class" ? find(properties, x => symbolName(x) === "className") : void 0;
        return jsxSpecific != null ? jsxSpecific : getSpellingSuggestionForName(strName, properties, 111551);
    }
    function getSuggestionForNonexistentProperty(name, containingType) {
        const suggestion = getSuggestedSymbolForNonexistentProperty(name, containingType);
        return suggestion && symbolName(suggestion);
    }
    function getSuggestedSymbolForNonexistentSymbol(location, outerName, meaning) {
        Debug.assert(outerName !== void 0, "outername should always be defined");
        const result = resolveNameHelper(location, outerName, meaning, void 0, outerName, false, false, true, (symbols, name, meaning2) => {
            Debug.assertEqual(outerName, name, "name should equal outerName");
            const symbol = getSymbol2(symbols, name, meaning2);
            if (symbol) return symbol;
            let candidates;
            if (symbols === globals) {
                const primitives = mapDefined(["string", "number", "boolean", "object", "bigint", "symbol"], s => symbols.has(s.charAt(0).toUpperCase() + s.slice(1)) ? createSymbol(524288, s) : void 0);
                candidates = primitives.concat(arrayFrom(symbols.values()));
            } else {
                candidates = arrayFrom(symbols.values());
            }
            return getSpellingSuggestionForName(unescapeLeadingUnderscores(name), candidates, meaning2);
        });
        return result;
    }
    function getSuggestionForNonexistentSymbol(location, outerName, meaning) {
        const symbolResult = getSuggestedSymbolForNonexistentSymbol(location, outerName, meaning);
        return symbolResult && symbolName(symbolResult);
    }
    function getSuggestedSymbolForNonexistentModule(name, targetModule) {
        return targetModule.exports && getSpellingSuggestionForName(idText(name), getExportsOfModuleAsArray(targetModule), 2623475);
    }
    function getSuggestionForNonexistentExport(name, targetModule) {
        const suggestion = getSuggestedSymbolForNonexistentModule(name, targetModule);
        return suggestion && symbolName(suggestion);
    }
    function getSuggestionForNonexistentIndexSignature(objectType, expr, keyedType) {
        function hasProp(name) {
            const prop = getPropertyOfObjectType(objectType, name);
            if (prop) {
                const s = getSingleCallSignature(getTypeOfSymbol(prop));
                return !!s && getMinArgumentCount(s) >= 1 && isTypeAssignableTo(keyedType, getTypeAtPosition(s, 0));
            }
            return false;
        }
        const suggestedMethod = isAssignmentTarget(expr) ? "set" : "get";
        if (!hasProp(suggestedMethod)) {
            return void 0;
        }
        let suggestion = tryGetPropertyAccessOrIdentifierToString(expr.expression);
        if (suggestion === void 0) {
            suggestion = suggestedMethod;
        } else {
            suggestion += "." + suggestedMethod;
        }
        return suggestion;
    }
    function getSpellingSuggestionForName(name, symbols, meaning) {
        return getSpellingSuggestion(name, symbols, getCandidateName);
        function getCandidateName(candidate) {
            const candidateName = symbolName(candidate);
            if (startsWith(candidateName, '"')) {
                return void 0;
            }
            if (candidate.flags & meaning) {
                return candidateName;
            }
            if (candidate.flags & 2097152) {
                const alias = tryResolveAlias(candidate);
                if (alias && alias.flags & meaning) {
                    return candidateName;
                }
            }
            return void 0;
        }
    }
    function markPropertyAsReferenced(prop, nodeForCheckWriteOnly, isSelfTypeAccess2) {
        const valueDeclaration = prop && prop.flags & 106500 && prop.valueDeclaration;
        if (!valueDeclaration) {
            return;
        }
        const hasPrivateModifier = hasEffectiveModifier(valueDeclaration, 8);
        const hasPrivateIdentifier = prop.valueDeclaration && isNamedDeclaration(prop.valueDeclaration) && isPrivateIdentifier(prop.valueDeclaration.name);
        if (!hasPrivateModifier && !hasPrivateIdentifier) {
            return;
        }
        if (nodeForCheckWriteOnly && isWriteOnlyAccess(nodeForCheckWriteOnly) && !(prop.flags & 65536)) {
            return;
        }
        if (isSelfTypeAccess2) {
            const containingMethod = findAncestor(nodeForCheckWriteOnly, isFunctionLikeDeclaration);
            if (containingMethod && containingMethod.symbol === prop) {
                return;
            }
        }
        (getCheckFlags(prop) & 1 ? getSymbolLinks(prop).target : prop).isReferenced = 67108863;
    }
    function isSelfTypeAccess(name, parent2) {
        return name.kind === 108 || !!parent2 && isEntityNameExpression(name) && parent2 === getResolvedSymbol(getFirstIdentifier(name));
    }
    function isValidPropertyAccess(node, propertyName) {
        switch (node.kind) {
            case 208:
                return isValidPropertyAccessWithType(node, node.expression.kind === 106, propertyName, getWidenedType(checkExpression(node.expression)));
            case 163:
                return isValidPropertyAccessWithType(node, false, propertyName, getWidenedType(checkExpression(node.left)));
            case 202:
                return isValidPropertyAccessWithType(node, false, propertyName, getTypeFromTypeNode(node));
        }
    }
    function isValidPropertyAccessForCompletions(node, type, property) {
        return isPropertyAccessible(node, node.kind === 208 && node.expression.kind === 106, false, type, property);
    }
    function isValidPropertyAccessWithType(node, isSuper, propertyName, type) {
        if (isTypeAny(type)) {
            return true;
        }
        const prop = getPropertyOfType(type, propertyName);
        return !!prop && isPropertyAccessible(node, isSuper, false, type, prop);
    }
    function isPropertyAccessible(node, isSuper, isWrite, containingType, property) {
        if (isTypeAny(containingType)) {
            return true;
        }
        if (property.valueDeclaration && isPrivateIdentifierClassElementDeclaration(property.valueDeclaration)) {
            const declClass = getContainingClass(property.valueDeclaration);
            return !isOptionalChain(node) && !!findAncestor(node, parent2 => parent2 === declClass);
        }
        return checkPropertyAccessibilityAtLocation(node, isSuper, isWrite, containingType, property);
    }
    function getForInVariableSymbol(node) {
        const initializer = node.initializer;
        if (initializer.kind === 258) {
            const variable = initializer.declarations[0];
            if (variable && !isBindingPattern(variable.name)) {
                return getSymbolOfDeclaration(variable);
            }
        } else if (initializer.kind === 79) {
            return getResolvedSymbol(initializer);
        }
        return void 0;
    }
    function hasNumericPropertyNames(type) {
        return getIndexInfosOfType(type).length === 1 && !!getIndexInfoOfType(type, numberType);
    }
    function isForInVariableForNumericPropertyNames(expr) {
        const e = skipParentheses(expr);
        if (e.kind === 79) {
            const symbol = getResolvedSymbol(e);
            if (symbol.flags & 3) {
                let child = expr;
                let node = expr.parent;
                while (node) {
                    if (node.kind === 246 && child === node.statement && getForInVariableSymbol(node) === symbol && hasNumericPropertyNames(getTypeOfExpression(node.expression))) {
                        return true;
                    }
                    child = node;
                    node = node.parent;
                }
            }
        }
        return false;
    }
    function checkIndexedAccess(node, checkMode) {
        return node.flags & 32 ? checkElementAccessChain(node, checkMode) : checkElementAccessExpression(node, checkNonNullExpression(node.expression), checkMode);
    }
    function checkElementAccessChain(node, checkMode) {
        const exprType = checkExpression(node.expression);
        const nonOptionalType = getOptionalExpressionType(exprType, node.expression);
        return propagateOptionalTypeMarker(checkElementAccessExpression(node, checkNonNullType(nonOptionalType, node.expression), checkMode), node, nonOptionalType !== exprType);
    }
    function checkElementAccessExpression(node, exprType, checkMode) {
        const objectType = getAssignmentTargetKind(node) !== 0 || isMethodAccessForCall(node) ? getWidenedType(exprType) : exprType;
        const indexExpression = node.argumentExpression;
        const indexType = checkExpression(indexExpression);
        if (isErrorType(objectType) || objectType === silentNeverType) {
            return objectType;
        }
        if (isConstEnumObjectType(objectType) && !isStringLiteralLike(indexExpression)) {
            error(indexExpression, Diagnostics.A_const_enum_member_can_only_be_accessed_using_a_string_literal);
            return errorType;
        }
        const effectiveIndexType = isForInVariableForNumericPropertyNames(indexExpression) ? numberType : indexType;
        const accessFlags = isAssignmentTarget(node) ? 4 | (isGenericObjectType(objectType) && !isThisTypeParameter(objectType) ? 2 : 0) : 32;
        const indexedAccessType = getIndexedAccessTypeOrUndefined(objectType, effectiveIndexType, accessFlags, node) || errorType;
        return checkIndexedAccessIndexType(getFlowTypeOfAccessExpression(node, getNodeLinks(node).resolvedSymbol, indexedAccessType, indexExpression, checkMode), node);
    }
    function callLikeExpressionMayHaveTypeArguments(node) {
        return isCallOrNewExpression(node) || isTaggedTemplateExpression(node) || isJsxOpeningLikeElement(node);
    }
    function resolveUntypedCall(node) {
        if (callLikeExpressionMayHaveTypeArguments(node)) {
            forEach(node.typeArguments, checkSourceElement);
        }
        if (node.kind === 212) {
            checkExpression(node.template);
        } else if (isJsxOpeningLikeElement(node)) {
            checkExpression(node.attributes);
        } else if (node.kind !== 167) {
            forEach(node.arguments, argument => {
                checkExpression(argument);
            });
        }
        return anySignature;
    }
    function resolveErrorCall(node) {
        resolveUntypedCall(node);
        return unknownSignature;
    }
    function reorderCandidates(signatures, result, callChainFlags) {
        let lastParent;
        let lastSymbol;
        let cutoffIndex = 0;
        let index;
        let specializedIndex = -1;
        let spliceIndex;
        Debug.assert(!result.length);
        for (const signature of signatures) {
            const symbol = signature.declaration && getSymbolOfDeclaration(signature.declaration);
            const parent2 = signature.declaration && signature.declaration.parent;
            if (!lastSymbol || symbol === lastSymbol) {
                if (lastParent && parent2 === lastParent) {
                    index = index + 1;
                } else {
                    lastParent = parent2;
                    index = cutoffIndex;
                }
            } else {
                index = cutoffIndex = result.length;
                lastParent = parent2;
            }
            lastSymbol = symbol;
            if (signatureHasLiteralTypes(signature)) {
                specializedIndex++;
                spliceIndex = specializedIndex;
                cutoffIndex++;
            } else {
                spliceIndex = index;
            }
            result.splice(spliceIndex, 0, callChainFlags ? getOptionalCallSignature(signature, callChainFlags) : signature);
        }
    }
    function isSpreadArgument(arg) {
        return !!arg && (arg.kind === 227 || arg.kind === 234 && arg.isSpread);
    }
    function getSpreadArgumentIndex(args) {
        return findIndex(args, isSpreadArgument);
    }
    function acceptsVoid(t) {
        return !!(t.flags & 16384);
    }
    function acceptsVoidUndefinedUnknownOrAny(t) {
        return !!(t.flags & (16384 | 32768 | 2 | 1));
    }
    function hasCorrectArity(node, args, signature, signatureHelpTrailingComma = false) {
        let argCount;
        let callIsIncomplete = false;
        let effectiveParameterCount = getParameterCount(signature);
        let effectiveMinimumArguments = getMinArgumentCount(signature);
        if (node.kind === 212) {
            argCount = args.length;
            if (node.template.kind === 225) {
                const lastSpan = last(node.template.templateSpans);
                callIsIncomplete = nodeIsMissing(lastSpan.literal) || !!lastSpan.literal.isUnterminated;
            } else {
                const templateLiteral = node.template;
                Debug.assert(templateLiteral.kind === 14);
                callIsIncomplete = !!templateLiteral.isUnterminated;
            }
        } else if (node.kind === 167) {
            argCount = getDecoratorArgumentCount(node, signature);
        } else if (isJsxOpeningLikeElement(node)) {
            callIsIncomplete = node.attributes.end === node.end;
            if (callIsIncomplete) {
                return true;
            }
            argCount = effectiveMinimumArguments === 0 ? args.length : 1;
            effectiveParameterCount = args.length === 0 ? effectiveParameterCount : 1;
            effectiveMinimumArguments = Math.min(effectiveMinimumArguments, 1);
        } else if (!node.arguments) {
            Debug.assert(node.kind === 211);
            return getMinArgumentCount(signature) === 0;
        } else {
            argCount = signatureHelpTrailingComma ? args.length + 1 : args.length;
            callIsIncomplete = node.arguments.end === node.end;
            const spreadArgIndex = getSpreadArgumentIndex(args);
            if (spreadArgIndex >= 0) {
                return spreadArgIndex >= getMinArgumentCount(signature) && (hasEffectiveRestParameter(signature) || spreadArgIndex < getParameterCount(signature));
            }
        }
        if (!hasEffectiveRestParameter(signature) && argCount > effectiveParameterCount) {
            return false;
        }
        if (callIsIncomplete || argCount >= effectiveMinimumArguments) {
            return true;
        }
        for (let i = argCount; i < effectiveMinimumArguments; i++) {
            const type = getTypeAtPosition(signature, i);
            if (filterType(type, isInJSFile(node) && !strictNullChecks ? acceptsVoidUndefinedUnknownOrAny : acceptsVoid).flags & 131072) {
                return false;
            }
        }
        return true;
    }
    function hasCorrectTypeArgumentArity(signature, typeArguments) {
        const numTypeParameters = length(signature.typeParameters);
        const minTypeArgumentCount = getMinTypeArgumentCount(signature.typeParameters);
        return !some(typeArguments) || typeArguments.length >= minTypeArgumentCount && typeArguments.length <= numTypeParameters;
    }
    function getSingleCallSignature(type) {
        return getSingleSignature(type, 0, false);
    }
    function getSingleCallOrConstructSignature(type) {
        return getSingleSignature(type, 0, false) || getSingleSignature(type, 1, false);
    }
    function getSingleSignature(type, kind, allowMembers) {
        if (type.flags & 524288) {
            const resolved = resolveStructuredTypeMembers(type);
            if (allowMembers || resolved.properties.length === 0 && resolved.indexInfos.length === 0) {
                if (kind === 0 && resolved.callSignatures.length === 1 && resolved.constructSignatures.length === 0) {
                    return resolved.callSignatures[0];
                }
                if (kind === 1 && resolved.constructSignatures.length === 1 && resolved.callSignatures.length === 0) {
                    return resolved.constructSignatures[0];
                }
            }
        }
        return void 0;
    }
    function instantiateSignatureInContextOf(signature, contextualSignature, inferenceContext, compareTypes) {
        const context = createInferenceContext(signature.typeParameters, signature, 0, compareTypes);
        const restType = getEffectiveRestType(contextualSignature);
        const mapper = inferenceContext && (restType && restType.flags & 262144 ? inferenceContext.nonFixingMapper : inferenceContext.mapper);
        const sourceSignature = mapper ? instantiateSignature(contextualSignature, mapper) : contextualSignature;
        applyToParameterTypes(sourceSignature, signature, (source, target) => {
            inferTypes(context.inferences, source, target);
        });
        if (!inferenceContext) {
            applyToReturnTypes(contextualSignature, signature, (source, target) => {
                inferTypes(context.inferences, source, target, 128);
            });
        }
        return getSignatureInstantiation(signature, getInferredTypes(context), isInJSFile(contextualSignature.declaration));
    }
    function inferJsxTypeArguments(node, signature, checkMode, context) {
        const paramType = getEffectiveFirstArgumentForJsxSignature(signature, node);
        const checkAttrType = checkExpressionWithContextualType(node.attributes, paramType, context, checkMode);
        inferTypes(context.inferences, checkAttrType, paramType);
        return getInferredTypes(context);
    }
    function getThisArgumentType(thisArgumentNode) {
        if (!thisArgumentNode) {
            return voidType;
        }
        const thisArgumentType = checkExpression(thisArgumentNode);
        return isOptionalChainRoot(thisArgumentNode.parent) ? getNonNullableType(thisArgumentType) : isOptionalChain(thisArgumentNode.parent) ? removeOptionalTypeMarker(thisArgumentType) : thisArgumentType;
    }
    function inferTypeArguments(node, signature, args, checkMode, context) {
        if (isJsxOpeningLikeElement(node)) {
            return inferJsxTypeArguments(node, signature, checkMode, context);
        }
        if (node.kind !== 167) {
            const skipBindingPatterns = every(signature.typeParameters, p => !!getDefaultFromTypeParameter(p));
            const contextualType = getContextualType2(node, skipBindingPatterns ? 8 : 0);
            if (contextualType) {
                const inferenceTargetType = getReturnTypeOfSignature(signature);
                if (couldContainTypeVariables(inferenceTargetType)) {
                    const outerContext = getInferenceContext(node);
                    const isFromBindingPattern = !skipBindingPatterns && getContextualType2(node, 8) !== contextualType;
                    if (!isFromBindingPattern) {
                        const outerMapper = getMapperFromContext(cloneInferenceContext(outerContext, 1));
                        const instantiatedType = instantiateType(contextualType, outerMapper);
                        const contextualSignature = getSingleCallSignature(instantiatedType);
                        const inferenceSourceType = contextualSignature && contextualSignature.typeParameters ? getOrCreateTypeFromSignature(getSignatureInstantiationWithoutFillingInTypeArguments(contextualSignature, contextualSignature.typeParameters)) : instantiatedType;
                        inferTypes(context.inferences, inferenceSourceType, inferenceTargetType, 128);
                    }
                    const returnContext = createInferenceContext(signature.typeParameters, signature, context.flags);
                    const returnSourceType = instantiateType(contextualType, outerContext && outerContext.returnMapper);
                    inferTypes(returnContext.inferences, returnSourceType, inferenceTargetType);
                    context.returnMapper = some(returnContext.inferences, hasInferenceCandidates) ? getMapperFromContext(cloneInferredPartOfContext(returnContext)) : void 0;
                }
            }
        }
        const restType = getNonArrayRestType(signature);
        const argCount = restType ? Math.min(getParameterCount(signature) - 1, args.length) : args.length;
        if (restType && restType.flags & 262144) {
            const info = find(context.inferences, info2 => info2.typeParameter === restType);
            if (info) {
                info.impliedArity = findIndex(args, isSpreadArgument, argCount) < 0 ? args.length - argCount : void 0;
            }
        }
        const thisType = getThisTypeOfSignature(signature);
        if (thisType && couldContainTypeVariables(thisType)) {
            const thisArgumentNode = getThisArgumentOfCall(node);
            inferTypes(context.inferences, getThisArgumentType(thisArgumentNode), thisType);
        }
        for (let i = 0; i < argCount; i++) {
            const arg = args[i];
            if (arg.kind !== 229 && !(checkMode & 32 && hasSkipDirectInferenceFlag(arg))) {
                const paramType = getTypeAtPosition(signature, i);
                if (couldContainTypeVariables(paramType)) {
                    const argType = checkExpressionWithContextualType(arg, paramType, context, checkMode);
                    inferTypes(context.inferences, argType, paramType);
                }
            }
        }
        if (restType && couldContainTypeVariables(restType)) {
            const spreadType = getSpreadArgumentType(args, argCount, args.length, restType, context, checkMode);
            inferTypes(context.inferences, spreadType, restType);
        }
        return getInferredTypes(context);
    }
    function getMutableArrayOrTupleType(type) {
        return type.flags & 1048576 ? mapType(type, getMutableArrayOrTupleType) : type.flags & 1 || isMutableArrayOrTuple(getBaseConstraintOfType(type) || type) ? type : isTupleType(type) ? createTupleType(getTypeArguments(type), type.target.elementFlags, false, type.target.labeledElementDeclarations) : createTupleType([type], [8]);
    }
    function getSpreadArgumentType(args, index, argCount, restType, context, checkMode) {
        if (index >= argCount - 1) {
            const arg = args[argCount - 1];
            if (isSpreadArgument(arg)) {
                return getMutableArrayOrTupleType(arg.kind === 234 ? arg.type : checkExpressionWithContextualType(arg.expression, restType, context, checkMode));
            }
        }
        const types = [];
        const flags = [];
        const names = [];
        const inConstContext = isConstTypeVariable(restType);
        for (let i = index; i < argCount; i++) {
            const arg = args[i];
            if (isSpreadArgument(arg)) {
                const spreadType = arg.kind === 234 ? arg.type : checkExpression(arg.expression);
                if (isArrayLikeType(spreadType)) {
                    types.push(spreadType);
                    flags.push(8);
                } else {
                    types.push(checkIteratedTypeOrElementType(33, spreadType, undefinedType, arg.kind === 227 ? arg.expression : arg));
                    flags.push(4);
                }
            } else {
                const contextualType = getIndexedAccessType(restType, getNumberLiteralType(i - index), 256);
                const argType = checkExpressionWithContextualType(arg, contextualType, context, checkMode);
                const hasPrimitiveContextualType = inConstContext || maybeTypeOfKind(contextualType, 134348796 | 4194304 | 134217728 | 268435456);
                types.push(hasPrimitiveContextualType ? getRegularTypeOfLiteralType(argType) : getWidenedLiteralType(argType));
                flags.push(1);
            }
            if (arg.kind === 234 && arg.tupleNameSource) {
                names.push(arg.tupleNameSource);
            }
        }
        return createTupleType(types, flags, inConstContext, length(names) === length(types) ? names : void 0);
    }
    function checkTypeArguments(signature, typeArgumentNodes, reportErrors2, headMessage) {
        const isJavascript = isInJSFile(signature.declaration);
        const typeParameters = signature.typeParameters;
        const typeArgumentTypes = fillMissingTypeArguments(map(typeArgumentNodes, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isJavascript);
        let mapper;
        for (let i = 0; i < typeArgumentNodes.length; i++) {
            Debug.assert(typeParameters[i] !== void 0, "Should not call checkTypeArguments with too many type arguments");
            const constraint = getConstraintOfTypeParameter(typeParameters[i]);
            if (constraint) {
                const errorInfo = reportErrors2 && headMessage ? () => chainDiagnosticMessages(void 0, Diagnostics.Type_0_does_not_satisfy_the_constraint_1) : void 0;
                const typeArgumentHeadMessage = headMessage || Diagnostics.Type_0_does_not_satisfy_the_constraint_1;
                if (!mapper) {
                    mapper = createTypeMapper(typeParameters, typeArgumentTypes);
                }
                const typeArgument = typeArgumentTypes[i];
                if (!checkTypeAssignableTo(typeArgument, getTypeWithThisArgument(instantiateType(constraint, mapper), typeArgument), reportErrors2 ? typeArgumentNodes[i] : void 0, typeArgumentHeadMessage, errorInfo)) {
                    return void 0;
                }
            }
        }
        return typeArgumentTypes;
    }
    function getJsxReferenceKind(node) {
        if (isJsxIntrinsicIdentifier(node.tagName)) {
            return 2;
        }
        const tagType = getApparentType(checkExpression(node.tagName));
        if (length(getSignaturesOfType(tagType, 1))) {
            return 0;
        }
        if (length(getSignaturesOfType(tagType, 0))) {
            return 1;
        }
        return 2;
    }
    function checkApplicableSignatureForJsxOpeningLikeElement(node, signature, relation, checkMode, reportErrors2, containingMessageChain, errorOutputContainer) {
        const paramType = getEffectiveFirstArgumentForJsxSignature(signature, node);
        const attributesType = checkExpressionWithContextualType(node.attributes, paramType, void 0, checkMode);
        return checkTagNameDoesNotExpectTooManyArguments() && checkTypeRelatedToAndOptionallyElaborate(attributesType, paramType, relation, reportErrors2 ? node.tagName : void 0, node.attributes, void 0, containingMessageChain, errorOutputContainer);
        function checkTagNameDoesNotExpectTooManyArguments() {
            var _a2;
            if (getJsxNamespaceContainerForImplicitImport(node)) {
                return true;
            }
            const tagType = isJsxOpeningElement(node) || isJsxSelfClosingElement(node) && !isJsxIntrinsicIdentifier(node.tagName) ? checkExpression(node.tagName) : void 0;
            if (!tagType) {
                return true;
            }
            const tagCallSignatures = getSignaturesOfType(tagType, 0);
            if (!length(tagCallSignatures)) {
                return true;
            }
            const factory2 = getJsxFactoryEntity(node);
            if (!factory2) {
                return true;
            }
            const factorySymbol = resolveEntityName(factory2, 111551, true, false, node);
            if (!factorySymbol) {
                return true;
            }
            const factoryType = getTypeOfSymbol(factorySymbol);
            const callSignatures = getSignaturesOfType(factoryType, 0);
            if (!length(callSignatures)) {
                return true;
            }
            let hasFirstParamSignatures = false;
            let maxParamCount = 0;
            for (const sig of callSignatures) {
                const firstparam = getTypeAtPosition(sig, 0);
                const signaturesOfParam = getSignaturesOfType(firstparam, 0);
                if (!length(signaturesOfParam)) continue;
                for (const paramSig of signaturesOfParam) {
                    hasFirstParamSignatures = true;
                    if (hasEffectiveRestParameter(paramSig)) {
                        return true;
                    }
                    const paramCount = getParameterCount(paramSig);
                    if (paramCount > maxParamCount) {
                        maxParamCount = paramCount;
                    }
                }
            }
            if (!hasFirstParamSignatures) {
                return true;
            }
            let absoluteMinArgCount = Infinity;
            for (const tagSig of tagCallSignatures) {
                const tagRequiredArgCount = getMinArgumentCount(tagSig);
                if (tagRequiredArgCount < absoluteMinArgCount) {
                    absoluteMinArgCount = tagRequiredArgCount;
                }
            }
            if (absoluteMinArgCount <= maxParamCount) {
                return true;
            }
            if (reportErrors2) {
                const diag2 = createDiagnosticForNode(node.tagName, Diagnostics.Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3, entityNameToString(node.tagName), absoluteMinArgCount, entityNameToString(factory2), maxParamCount);
                const tagNameDeclaration = (_a2 = getSymbolAtLocation(node.tagName)) == null ? void 0 : _a2.valueDeclaration;
                if (tagNameDeclaration) {
                    addRelatedInfo(diag2, createDiagnosticForNode(tagNameDeclaration, Diagnostics._0_is_declared_here, entityNameToString(node.tagName)));
                }
                if (errorOutputContainer && errorOutputContainer.skipLogging) {
                    (errorOutputContainer.errors || (errorOutputContainer.errors = [])).push(diag2);
                }
                if (!errorOutputContainer.skipLogging) {
                    diagnostics.add(diag2);
                }
            }
            return false;
        }
    }
    function getSignatureApplicabilityError(node, args, signature, relation, checkMode, reportErrors2, containingMessageChain) {
        const errorOutputContainer = {
            errors: void 0,
            skipLogging: true
        };
        if (isJsxOpeningLikeElement(node)) {
            if (!checkApplicableSignatureForJsxOpeningLikeElement(node, signature, relation, checkMode, reportErrors2, containingMessageChain, errorOutputContainer)) {
                Debug.assert(!reportErrors2 || !!errorOutputContainer.errors, "jsx should have errors when reporting errors");
                return errorOutputContainer.errors || emptyArray;
            }
            return void 0;
        }
        const thisType = getThisTypeOfSignature(signature);
        if (thisType && thisType !== voidType && !(isNewExpression(node) || isCallExpression(node) && isSuperProperty(node.expression))) {
            const thisArgumentNode = getThisArgumentOfCall(node);
            const thisArgumentType = getThisArgumentType(thisArgumentNode);
            const errorNode = reportErrors2 ? thisArgumentNode || node : void 0;
            const headMessage2 = Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1;
            if (!checkTypeRelatedTo(thisArgumentType, thisType, relation, errorNode, headMessage2, containingMessageChain, errorOutputContainer)) {
                Debug.assert(!reportErrors2 || !!errorOutputContainer.errors, "this parameter should have errors when reporting errors");
                return errorOutputContainer.errors || emptyArray;
            }
        }
        const headMessage = Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1;
        const restType = getNonArrayRestType(signature);
        const argCount = restType ? Math.min(getParameterCount(signature) - 1, args.length) : args.length;
        for (let i = 0; i < argCount; i++) {
            const arg = args[i];
            if (arg.kind !== 229) {
                const paramType = getTypeAtPosition(signature, i);
                const argType = checkExpressionWithContextualType(arg, paramType, void 0, checkMode);
                const checkArgType = checkMode & 4 ? getRegularTypeOfObjectLiteral(argType) : argType;
                if (!checkTypeRelatedToAndOptionallyElaborate(checkArgType, paramType, relation, reportErrors2 ? arg : void 0, arg, headMessage, containingMessageChain, errorOutputContainer)) {
                    Debug.assert(!reportErrors2 || !!errorOutputContainer.errors, "parameter should have errors when reporting errors");
                    maybeAddMissingAwaitInfo(arg, checkArgType, paramType);
                    return errorOutputContainer.errors || emptyArray;
                }
            }
        }
        if (restType) {
            const spreadType = getSpreadArgumentType(args, argCount, args.length, restType, void 0, checkMode);
            const restArgCount = args.length - argCount;
            const errorNode = !reportErrors2 ? void 0 : restArgCount === 0 ? node : restArgCount === 1 ? args[argCount] : setTextRangePosEnd(createSyntheticExpression(node, spreadType), args[argCount].pos, args[args.length - 1].end);
            if (!checkTypeRelatedTo(spreadType, restType, relation, errorNode, headMessage, void 0, errorOutputContainer)) {
                Debug.assert(!reportErrors2 || !!errorOutputContainer.errors, "rest parameter should have errors when reporting errors");
                maybeAddMissingAwaitInfo(errorNode, spreadType, restType);
                return errorOutputContainer.errors || emptyArray;
            }
        }
        return void 0;
        function maybeAddMissingAwaitInfo(errorNode, source, target) {
            if (errorNode && reportErrors2 && errorOutputContainer.errors && errorOutputContainer.errors.length) {
                if (getAwaitedTypeOfPromise(target)) {
                    return;
                }
                const awaitedTypeOfSource = getAwaitedTypeOfPromise(source);
                if (awaitedTypeOfSource && isTypeRelatedTo(awaitedTypeOfSource, target, relation)) {
                    addRelatedInfo(errorOutputContainer.errors[0], createDiagnosticForNode(errorNode, Diagnostics.Did_you_forget_to_use_await));
                }
            }
        }
    }
    function getThisArgumentOfCall(node) {
        const expression = node.kind === 210 ? node.expression : node.kind === 212 ? node.tag : void 0;
        if (expression) {
            const callee = skipOuterExpressions(expression);
            if (isAccessExpression(callee)) {
                return callee.expression;
            }
        }
    }
    function createSyntheticExpression(parent2, type, isSpread, tupleNameSource) {
        const result = parseNodeFactory.createSyntheticExpression(type, isSpread, tupleNameSource);
        setTextRange(result, parent2);
        setParent(result, parent2);
        return result;
    }
    function getEffectiveCallArguments(node) {
        if (node.kind === 212) {
            const template = node.template;
            const args2 = [createSyntheticExpression(template, getGlobalTemplateStringsArrayType())];
            if (template.kind === 225) {
                forEach(template.templateSpans, span => {
                    args2.push(span.expression);
                });
            }
            return args2;
        }
        if (node.kind === 167) {
            return getEffectiveDecoratorArguments(node);
        }
        if (isJsxOpeningLikeElement(node)) {
            return node.attributes.properties.length > 0 || isJsxOpeningElement(node) && node.parent.children.length > 0 ? [node.attributes] : emptyArray;
        }
        const args = node.arguments || emptyArray;
        const spreadIndex = getSpreadArgumentIndex(args);
        if (spreadIndex >= 0) {
            const effectiveArgs = args.slice(0, spreadIndex);
            for (let i = spreadIndex; i < args.length; i++) {
                const arg = args[i];
                const spreadType = arg.kind === 227 && (flowLoopCount ? checkExpression(arg.expression) : checkExpressionCached(arg.expression));
                if (spreadType && isTupleType(spreadType)) {
                    forEach(getTypeArguments(spreadType), (t, i2) => {
                        var _a2;
                        const flags = spreadType.target.elementFlags[i2];
                        const syntheticArg = createSyntheticExpression(arg, flags & 4 ? createArrayType(t) : t, !!(flags & 12), (_a2 = spreadType.target.labeledElementDeclarations) == null ? void 0 : _a2[i2]);
                        effectiveArgs.push(syntheticArg);
                    });
                } else {
                    effectiveArgs.push(arg);
                }
            }
            return effectiveArgs;
        }
        return args;
    }
    function getEffectiveDecoratorArguments(node) {
        const expr = node.expression;
        const signature = getDecoratorCallSignature(node);
        if (signature) {
            const args = [];
            for (const param of signature.parameters) {
                const type = getTypeOfSymbol(param);
                args.push(createSyntheticExpression(expr, type));
            }
            return args;
        }
        return Debug.fail();
    }
    function getDecoratorArgumentCount(node, signature) {
        return compilerOptions.experimentalDecorators ? getLegacyDecoratorArgumentCount(node, signature) : 2;
    }
    function getLegacyDecoratorArgumentCount(node, signature) {
        switch (node.parent.kind) {
            case 260:
            case 228:
                return 1;
            case 169:
                return hasAccessorModifier(node.parent) ? 3 : 2;
            case 171:
            case 174:
            case 175:
                return languageVersion === 0 || signature.parameters.length <= 2 ? 2 : 3;
            case 166:
                return 3;
            default:
                return Debug.fail();
        }
    }
    function getDiagnosticSpanForCallNode(node, doNotIncludeArguments) {
        let start;
        let length2;
        const sourceFile = getSourceFileOfNode(node);
        if (isPropertyAccessExpression(node.expression)) {
            const nameSpan = getErrorSpanForNode(sourceFile, node.expression.name);
            start = nameSpan.start;
            length2 = doNotIncludeArguments ? nameSpan.length : node.end - start;
        } else {
            const expressionSpan = getErrorSpanForNode(sourceFile, node.expression);
            start = expressionSpan.start;
            length2 = doNotIncludeArguments ? expressionSpan.length : node.end - start;
        }
        return {
            start,
            length: length2,
            sourceFile
        };
    }
    function getDiagnosticForCallNode(node, message, arg0, arg1, arg2, arg3) {
        if (isCallExpression(node)) {
            const {
                sourceFile,
                start,
                length: length2
            } = getDiagnosticSpanForCallNode(node);
            if ("message" in message) {
                return createFileDiagnostic(sourceFile, start, length2, message, arg0, arg1, arg2, arg3);
            }
            return createDiagnosticForFileFromMessageChain(sourceFile, message);
        } else {
            if ("message" in message) {
                return createDiagnosticForNode(node, message, arg0, arg1, arg2, arg3);
            }
            return createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node), node, message);
        }
    }
    function isPromiseResolveArityError(node) {
        if (!isCallExpression(node) || !isIdentifier(node.expression)) return false;
        const symbol = resolveName(node.expression, node.expression.escapedText, 111551, void 0, void 0, false);
        const decl = symbol == null ? void 0 : symbol.valueDeclaration;
        if (!decl || !isParameter(decl) || !isFunctionExpressionOrArrowFunction(decl.parent) || !isNewExpression(decl.parent.parent) || !isIdentifier(decl.parent.parent.expression)) {
            return false;
        }
        const globalPromiseSymbol = getGlobalPromiseConstructorSymbol(false);
        if (!globalPromiseSymbol) return false;
        const constructorSymbol = getSymbolAtLocation(decl.parent.parent.expression, true);
        return constructorSymbol === globalPromiseSymbol;
    }
    function getArgumentArityError(node, signatures, args, headMessage) {
        var _a2;
        const spreadIndex = getSpreadArgumentIndex(args);
        if (spreadIndex > -1) {
            return createDiagnosticForNode(args[spreadIndex], Diagnostics.A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter);
        }
        let min2 = Number.POSITIVE_INFINITY;
        let max = Number.NEGATIVE_INFINITY;
        let maxBelow = Number.NEGATIVE_INFINITY;
        let minAbove = Number.POSITIVE_INFINITY;
        let closestSignature;
        for (const sig of signatures) {
            const minParameter = getMinArgumentCount(sig);
            const maxParameter = getParameterCount(sig);
            if (minParameter < min2) {
                min2 = minParameter;
                closestSignature = sig;
            }
            max = Math.max(max, maxParameter);
            if (minParameter < args.length && minParameter > maxBelow) maxBelow = minParameter;
            if (args.length < maxParameter && maxParameter < minAbove) minAbove = maxParameter;
        }
        const hasRestParameter2 = some(signatures, hasEffectiveRestParameter);
        const parameterRange = hasRestParameter2 ? min2 : min2 < max ? min2 + "-" + max : min2;
        const isVoidPromiseError = !hasRestParameter2 && parameterRange === 1 && args.length === 0 && isPromiseResolveArityError(node);
        if (isVoidPromiseError && isInJSFile(node)) {
            return getDiagnosticForCallNode(node, Diagnostics.Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_without_arguments);
        }
        const error2 = isDecorator(node) ? hasRestParameter2 ? Diagnostics.The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_at_least_0 : Diagnostics.The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_0 : hasRestParameter2 ? Diagnostics.Expected_at_least_0_arguments_but_got_1 : isVoidPromiseError ? Diagnostics.Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise : Diagnostics.Expected_0_arguments_but_got_1;
        if (min2 < args.length && args.length < max) {
            if (headMessage) {
                let chain = chainDiagnosticMessages(void 0, Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments, args.length, maxBelow, minAbove);
                chain = chainDiagnosticMessages(chain, headMessage);
                return getDiagnosticForCallNode(node, chain);
            }
            return getDiagnosticForCallNode(node, Diagnostics.No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments, args.length, maxBelow, minAbove);
        } else if (args.length < min2) {
            let diagnostic;
            if (headMessage) {
                let chain = chainDiagnosticMessages(void 0, error2, parameterRange, args.length);
                chain = chainDiagnosticMessages(chain, headMessage);
                diagnostic = getDiagnosticForCallNode(node, chain);
            } else {
                diagnostic = getDiagnosticForCallNode(node, error2, parameterRange, args.length);
            }
            const parameter = (_a2 = closestSignature == null ? void 0 : closestSignature.declaration) == null ? void 0 : _a2.parameters[closestSignature.thisParameter ? args.length + 1 : args.length];
            if (parameter) {
                const parameterError = createDiagnosticForNode(parameter, isBindingPattern(parameter.name) ? Diagnostics.An_argument_matching_this_binding_pattern_was_not_provided : isRestParameter(parameter) ? Diagnostics.Arguments_for_the_rest_parameter_0_were_not_provided : Diagnostics.An_argument_for_0_was_not_provided, !parameter.name ? args.length : !isBindingPattern(parameter.name) ? idText(getFirstIdentifier(parameter.name)) : void 0);
                return addRelatedInfo(diagnostic, parameterError);
            }
            return diagnostic;
        } else {
            const errorSpan = factory.createNodeArray(args.slice(max));
            const pos = first(errorSpan).pos;
            let end = last(errorSpan).end;
            if (end === pos) {
                end++;
            }
            setTextRangePosEnd(errorSpan, pos, end);
            if (headMessage) {
                let chain = chainDiagnosticMessages(void 0, error2, parameterRange, args.length);
                chain = chainDiagnosticMessages(chain, headMessage);
                return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), errorSpan, chain);
            }
            return createDiagnosticForNodeArray(getSourceFileOfNode(node), errorSpan, error2, parameterRange, args.length);
        }
    }
    function getTypeArgumentArityError(node, signatures, typeArguments, headMessage) {
        const argCount = typeArguments.length;
        if (signatures.length === 1) {
            const sig = signatures[0];
            const min2 = getMinTypeArgumentCount(sig.typeParameters);
            const max = length(sig.typeParameters);
            if (headMessage) {
                let chain = chainDiagnosticMessages(void 0, Diagnostics.Expected_0_type_arguments_but_got_1, min2 < max ? min2 + "-" + max : min2, argCount);
                chain = chainDiagnosticMessages(chain, headMessage);
                return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain);
            }
            return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Expected_0_type_arguments_but_got_1, min2 < max ? min2 + "-" + max : min2, argCount);
        }
        let belowArgCount = -Infinity;
        let aboveArgCount = Infinity;
        for (const sig of signatures) {
            const min2 = getMinTypeArgumentCount(sig.typeParameters);
            const max = length(sig.typeParameters);
            if (min2 > argCount) {
                aboveArgCount = Math.min(aboveArgCount, min2);
            } else if (max < argCount) {
                belowArgCount = Math.max(belowArgCount, max);
            }
        }
        if (belowArgCount !== -Infinity && aboveArgCount !== Infinity) {
            if (headMessage) {
                let chain = chainDiagnosticMessages(void 0, Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments, argCount, belowArgCount, aboveArgCount);
                chain = chainDiagnosticMessages(chain, headMessage);
                return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain);
            }
            return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments, argCount, belowArgCount, aboveArgCount);
        }
        if (headMessage) {
            let chain = chainDiagnosticMessages(void 0, Diagnostics.Expected_0_type_arguments_but_got_1, belowArgCount === -Infinity ? aboveArgCount : belowArgCount, argCount);
            chain = chainDiagnosticMessages(chain, headMessage);
            return createDiagnosticForNodeArrayFromMessageChain(getSourceFileOfNode(node), typeArguments, chain);
        }
        return createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Expected_0_type_arguments_but_got_1, belowArgCount === -Infinity ? aboveArgCount : belowArgCount, argCount);
    }
    function resolveCall(node, signatures, candidatesOutArray, checkMode, callChainFlags, headMessage) {
        const isTaggedTemplate = node.kind === 212;
        const isDecorator2 = node.kind === 167;
        const isJsxOpeningOrSelfClosingElement = isJsxOpeningLikeElement(node);
        const reportErrors2 = !isInferencePartiallyBlocked && !candidatesOutArray;
        let typeArguments;
        if (!isDecorator2 && !isSuperCall(node)) {
            typeArguments = node.typeArguments;
            if (isTaggedTemplate || isJsxOpeningOrSelfClosingElement || node.expression.kind !== 106) {
                forEach(typeArguments, checkSourceElement);
            }
        }
        const candidates = candidatesOutArray || [];
        reorderCandidates(signatures, candidates, callChainFlags);
        if (!candidates.length) {
            if (reportErrors2) {
                diagnostics.add(getDiagnosticForCallNode(node, Diagnostics.Call_target_does_not_contain_any_signatures));
            }
            return resolveErrorCall(node);
        }
        const args = getEffectiveCallArguments(node);
        const isSingleNonGenericCandidate = candidates.length === 1 && !candidates[0].typeParameters;
        let argCheckMode = !isDecorator2 && !isSingleNonGenericCandidate && some(args, isContextSensitive) ? 4 : 0;
        argCheckMode |= checkMode & 32;
        let candidatesForArgumentError;
        let candidateForArgumentArityError;
        let candidateForTypeArgumentError;
        let result;
        const signatureHelpTrailingComma = !!(checkMode & 16) && node.kind === 210 && node.arguments.hasTrailingComma;
        if (candidates.length > 1) {
            result = chooseOverload(candidates, subtypeRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma);
        }
        if (!result) {
            result = chooseOverload(candidates, assignableRelation, isSingleNonGenericCandidate, signatureHelpTrailingComma);
        }
        if (result) {
            return result;
        }
        result = getCandidateForOverloadFailure(node, candidates, args, !!candidatesOutArray, checkMode);
        getNodeLinks(node).resolvedSignature = result;
        if (reportErrors2) {
            if (candidatesForArgumentError) {
                if (candidatesForArgumentError.length === 1 || candidatesForArgumentError.length > 3) {
                    const last2 = candidatesForArgumentError[candidatesForArgumentError.length - 1];
                    let chain;
                    if (candidatesForArgumentError.length > 3) {
                        chain = chainDiagnosticMessages(chain, Diagnostics.The_last_overload_gave_the_following_error);
                        chain = chainDiagnosticMessages(chain, Diagnostics.No_overload_matches_this_call);
                    }
                    if (headMessage) {
                        chain = chainDiagnosticMessages(chain, headMessage);
                    }
                    const diags = getSignatureApplicabilityError(node, args, last2, assignableRelation, 0, true, () => chain);
                    if (diags) {
                        for (const d of diags) {
                            if (last2.declaration && candidatesForArgumentError.length > 3) {
                                addRelatedInfo(d, createDiagnosticForNode(last2.declaration, Diagnostics.The_last_overload_is_declared_here));
                            }
                            addImplementationSuccessElaboration(last2, d);
                            diagnostics.add(d);
                        }
                    } else {
                        Debug.fail("No error for last overload signature");
                    }
                } else {
                    const allDiagnostics = [];
                    let max = 0;
                    let min2 = Number.MAX_VALUE;
                    let minIndex = 0;
                    let i = 0;
                    for (const c of candidatesForArgumentError) {
                        const chain2 = () => chainDiagnosticMessages(void 0, Diagnostics.Overload_0_of_1_2_gave_the_following_error, i + 1, candidates.length, signatureToString(c));
                        const diags2 = getSignatureApplicabilityError(node, args, c, assignableRelation, 0, true, chain2);
                        if (diags2) {
                            if (diags2.length <= min2) {
                                min2 = diags2.length;
                                minIndex = i;
                            }
                            max = Math.max(max, diags2.length);
                            allDiagnostics.push(diags2);
                        } else {
                            Debug.fail("No error for 3 or fewer overload signatures");
                        }
                        i++;
                    }
                    const diags = max > 1 ? allDiagnostics[minIndex] : flatten(allDiagnostics);
                    Debug.assert(diags.length > 0, "No errors reported for 3 or fewer overload signatures");
                    let chain = chainDiagnosticMessages(map(diags, createDiagnosticMessageChainFromDiagnostic), Diagnostics.No_overload_matches_this_call);
                    if (headMessage) {
                        chain = chainDiagnosticMessages(chain, headMessage);
                    }
                    const related = [...flatMap(diags, d => d.relatedInformation)];
                    let diag2;
                    if (every(diags, d => d.start === diags[0].start && d.length === diags[0].length && d.file === diags[0].file)) {
                        const {
                            file,
                            start,
                            length: length2
                        } = diags[0];
                        diag2 = {
                            file,
                            start,
                            length: length2,
                            code: chain.code,
                            category: chain.category,
                            messageText: chain,
                            relatedInformation: related
                        };
                    } else {
                        diag2 = createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node), node, chain, related);
                    }
                    addImplementationSuccessElaboration(candidatesForArgumentError[0], diag2);
                    diagnostics.add(diag2);
                }
            } else if (candidateForArgumentArityError) {
                diagnostics.add(getArgumentArityError(node, [candidateForArgumentArityError], args, headMessage));
            } else if (candidateForTypeArgumentError) {
                checkTypeArguments(candidateForTypeArgumentError, node.typeArguments, true, headMessage);
            } else {
                const signaturesWithCorrectTypeArgumentArity = filter(signatures, s => hasCorrectTypeArgumentArity(s, typeArguments));
                if (signaturesWithCorrectTypeArgumentArity.length === 0) {
                    diagnostics.add(getTypeArgumentArityError(node, signatures, typeArguments, headMessage));
                } else {
                    diagnostics.add(getArgumentArityError(node, signaturesWithCorrectTypeArgumentArity, args, headMessage));
                }
            }
        }
        return result;
        function addImplementationSuccessElaboration(failed, diagnostic) {
            var _a2, _b;
            const oldCandidatesForArgumentError = candidatesForArgumentError;
            const oldCandidateForArgumentArityError = candidateForArgumentArityError;
            const oldCandidateForTypeArgumentError = candidateForTypeArgumentError;
            const failedSignatureDeclarations = ((_b = (_a2 = failed.declaration) == null ? void 0 : _a2.symbol) == null ? void 0 : _b.declarations) || emptyArray;
            const isOverload = failedSignatureDeclarations.length > 1;
            const implDecl = isOverload ? find(failedSignatureDeclarations, d => isFunctionLikeDeclaration(d) && nodeIsPresent(d.body)) : void 0;
            if (implDecl) {
                const candidate = getSignatureFromDeclaration(implDecl);
                const isSingleNonGenericCandidate2 = !candidate.typeParameters;
                if (chooseOverload([candidate], assignableRelation, isSingleNonGenericCandidate2)) {
                    addRelatedInfo(diagnostic, createDiagnosticForNode(implDecl, Diagnostics.The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible));
                }
            }
            candidatesForArgumentError = oldCandidatesForArgumentError;
            candidateForArgumentArityError = oldCandidateForArgumentArityError;
            candidateForTypeArgumentError = oldCandidateForTypeArgumentError;
        }
        function chooseOverload(candidates2, relation, isSingleNonGenericCandidate2, signatureHelpTrailingComma2 = false) {
            candidatesForArgumentError = void 0;
            candidateForArgumentArityError = void 0;
            candidateForTypeArgumentError = void 0;
            if (isSingleNonGenericCandidate2) {
                const candidate = candidates2[0];
                if (some(typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma2)) {
                    return void 0;
                }
                if (getSignatureApplicabilityError(node, args, candidate, relation, 0, false, void 0)) {
                    candidatesForArgumentError = [candidate];
                    return void 0;
                }
                return candidate;
            }
            for (let candidateIndex = 0; candidateIndex < candidates2.length; candidateIndex++) {
                const candidate = candidates2[candidateIndex];
                if (!hasCorrectTypeArgumentArity(candidate, typeArguments) || !hasCorrectArity(node, args, candidate, signatureHelpTrailingComma2)) {
                    continue;
                }
                let checkCandidate;
                let inferenceContext;
                if (candidate.typeParameters) {
                    let typeArgumentTypes;
                    if (some(typeArguments)) {
                        typeArgumentTypes = checkTypeArguments(candidate, typeArguments, false);
                        if (!typeArgumentTypes) {
                            candidateForTypeArgumentError = candidate;
                            continue;
                        }
                    } else {
                        inferenceContext = createInferenceContext(candidate.typeParameters, candidate, isInJSFile(node) ? 2 : 0);
                        typeArgumentTypes = inferTypeArguments(node, candidate, args, argCheckMode | 8, inferenceContext);
                        argCheckMode |= inferenceContext.flags & 4 ? 8 : 0;
                    }
                    checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext && inferenceContext.inferredTypeParameters);
                    if (getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma2)) {
                        candidateForArgumentArityError = checkCandidate;
                        continue;
                    }
                } else {
                    checkCandidate = candidate;
                }
                if (getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, false, void 0)) {
                    (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);
                    continue;
                }
                if (argCheckMode) {
                    argCheckMode = checkMode & 32;
                    if (inferenceContext) {
                        const typeArgumentTypes = inferTypeArguments(node, candidate, args, argCheckMode, inferenceContext);
                        checkCandidate = getSignatureInstantiation(candidate, typeArgumentTypes, isInJSFile(candidate.declaration), inferenceContext.inferredTypeParameters);
                        if (getNonArrayRestType(candidate) && !hasCorrectArity(node, args, checkCandidate, signatureHelpTrailingComma2)) {
                            candidateForArgumentArityError = checkCandidate;
                            continue;
                        }
                    }
                    if (getSignatureApplicabilityError(node, args, checkCandidate, relation, argCheckMode, false, void 0)) {
                        (candidatesForArgumentError || (candidatesForArgumentError = [])).push(checkCandidate);
                        continue;
                    }
                }
                candidates2[candidateIndex] = checkCandidate;
                return checkCandidate;
            }
            return void 0;
        }
    }
    function getCandidateForOverloadFailure(node, candidates, args, hasCandidatesOutArray, checkMode) {
        Debug.assert(candidates.length > 0);
        checkNodeDeferred(node);
        return hasCandidatesOutArray || candidates.length === 1 || candidates.some(c => !!c.typeParameters) ? pickLongestCandidateSignature(node, candidates, args, checkMode) : createUnionOfSignaturesForOverloadFailure(candidates);
    }
    function createUnionOfSignaturesForOverloadFailure(candidates) {
        const thisParameters = mapDefined(candidates, c => c.thisParameter);
        let thisParameter;
        if (thisParameters.length) {
            thisParameter = createCombinedSymbolFromTypes(thisParameters, thisParameters.map(getTypeOfParameter));
        }
        const {
            min: minArgumentCount,
            max: maxNonRestParam
        } = minAndMax(candidates, getNumNonRestParameters);
        const parameters = [];
        for (let i = 0; i < maxNonRestParam; i++) {
            const symbols = mapDefined(candidates, s => signatureHasRestParameter(s) ? i < s.parameters.length - 1 ? s.parameters[i] : last(s.parameters) : i < s.parameters.length ? s.parameters[i] : void 0);
            Debug.assert(symbols.length !== 0);
            parameters.push(createCombinedSymbolFromTypes(symbols, mapDefined(candidates, candidate => tryGetTypeAtPosition(candidate, i))));
        }
        const restParameterSymbols = mapDefined(candidates, c => signatureHasRestParameter(c) ? last(c.parameters) : void 0);
        let flags = 0;
        if (restParameterSymbols.length !== 0) {
            const type = createArrayType(getUnionType(mapDefined(candidates, tryGetRestTypeOfSignature), 2));
            parameters.push(createCombinedSymbolForOverloadFailure(restParameterSymbols, type));
            flags |= 1;
        }
        if (candidates.some(signatureHasLiteralTypes)) {
            flags |= 2;
        }
        return createSignature(candidates[0].declaration, void 0, thisParameter, parameters, getIntersectionType(candidates.map(getReturnTypeOfSignature)), void 0, minArgumentCount, flags);
    }
    function getNumNonRestParameters(signature) {
        const numParams = signature.parameters.length;
        return signatureHasRestParameter(signature) ? numParams - 1 : numParams;
    }
    function createCombinedSymbolFromTypes(sources, types) {
        return createCombinedSymbolForOverloadFailure(sources, getUnionType(types, 2));
    }
    function createCombinedSymbolForOverloadFailure(sources, type) {
        return createSymbolWithType(first(sources), type);
    }
    function pickLongestCandidateSignature(node, candidates, args, checkMode) {
        const bestIndex = getLongestCandidateIndex(candidates, apparentArgumentCount === void 0 ? args.length : apparentArgumentCount);
        const candidate = candidates[bestIndex];
        const {
            typeParameters
        } = candidate;
        if (!typeParameters) {
            return candidate;
        }
        const typeArgumentNodes = callLikeExpressionMayHaveTypeArguments(node) ? node.typeArguments : void 0;
        const instantiated = typeArgumentNodes ? createSignatureInstantiation(candidate, getTypeArgumentsFromNodes(typeArgumentNodes, typeParameters, isInJSFile(node))) : inferSignatureInstantiationForOverloadFailure(node, typeParameters, candidate, args, checkMode);
        candidates[bestIndex] = instantiated;
        return instantiated;
    }
    function getTypeArgumentsFromNodes(typeArgumentNodes, typeParameters, isJs) {
        const typeArguments = typeArgumentNodes.map(getTypeOfNode);
        while (typeArguments.length > typeParameters.length) {
            typeArguments.pop();
        }
        while (typeArguments.length < typeParameters.length) {
            typeArguments.push(getDefaultFromTypeParameter(typeParameters[typeArguments.length]) || getConstraintOfTypeParameter(typeParameters[typeArguments.length]) || getDefaultTypeArgumentType(isJs));
        }
        return typeArguments;
    }
    function inferSignatureInstantiationForOverloadFailure(node, typeParameters, candidate, args, checkMode) {
        const inferenceContext = createInferenceContext(typeParameters, candidate, isInJSFile(node) ? 2 : 0);
        const typeArgumentTypes = inferTypeArguments(node, candidate, args, checkMode | 4 | 8, inferenceContext);
        return createSignatureInstantiation(candidate, typeArgumentTypes);
    }
    function getLongestCandidateIndex(candidates, argsCount) {
        let maxParamsIndex = -1;
        let maxParams = -1;
        for (let i = 0; i < candidates.length; i++) {
            const candidate = candidates[i];
            const paramCount = getParameterCount(candidate);
            if (hasEffectiveRestParameter(candidate) || paramCount >= argsCount) {
                return i;
            }
            if (paramCount > maxParams) {
                maxParams = paramCount;
                maxParamsIndex = i;
            }
        }
        return maxParamsIndex;
    }
    function resolveCallExpression(node, candidatesOutArray, checkMode) {
        if (node.expression.kind === 106) {
            const superType = checkSuperExpression(node.expression);
            if (isTypeAny(superType)) {
                for (const arg of node.arguments) {
                    checkExpression(arg);
                }
                return anySignature;
            }
            if (!isErrorType(superType)) {
                const baseTypeNode = getEffectiveBaseTypeNode(getContainingClass(node));
                if (baseTypeNode) {
                    const baseConstructors = getInstantiatedConstructorsForTypeArguments(superType, baseTypeNode.typeArguments, baseTypeNode);
                    return resolveCall(node, baseConstructors, candidatesOutArray, checkMode, 0);
                }
            }
            return resolveUntypedCall(node);
        }
        let callChainFlags;
        let funcType = checkExpression(node.expression);
        if (isCallChain(node)) {
            const nonOptionalType = getOptionalExpressionType(funcType, node.expression);
            callChainFlags = nonOptionalType === funcType ? 0 : isOutermostOptionalChain(node) ? 16 : 8;
            funcType = nonOptionalType;
        } else {
            callChainFlags = 0;
        }
        funcType = checkNonNullTypeWithReporter(funcType, node.expression, reportCannotInvokePossiblyNullOrUndefinedError);
        if (funcType === silentNeverType) {
            return silentNeverSignature;
        }
        const apparentType = getApparentType(funcType);
        if (isErrorType(apparentType)) {
            return resolveErrorCall(node);
        }
        const callSignatures = getSignaturesOfType(apparentType, 0);
        const numConstructSignatures = getSignaturesOfType(apparentType, 1).length;
        if (isUntypedFunctionCall(funcType, apparentType, callSignatures.length, numConstructSignatures)) {
            if (!isErrorType(funcType) && node.typeArguments) {
                error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
            }
            return resolveUntypedCall(node);
        }
        if (!callSignatures.length) {
            if (numConstructSignatures) {
                error(node, Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType));
            } else {
                let relatedInformation;
                if (node.arguments.length === 1) {
                    const text = getSourceFileOfNode(node).text;
                    if (isLineBreak(text.charCodeAt(skipTrivia(text, node.expression.end, true) - 1))) {
                        relatedInformation = createDiagnosticForNode(node.expression, Diagnostics.Are_you_missing_a_semicolon);
                    }
                }
                invocationError(node.expression, apparentType, 0, relatedInformation);
            }
            return resolveErrorCall(node);
        }
        if (checkMode & 8 && !node.typeArguments && callSignatures.some(isGenericFunctionReturningFunction)) {
            skippedGenericFunction(node, checkMode);
            return resolvingSignature;
        }
        if (callSignatures.some(sig => isInJSFile(sig.declaration) && !!getJSDocClassTag(sig.declaration))) {
            error(node, Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType));
            return resolveErrorCall(node);
        }
        return resolveCall(node, callSignatures, candidatesOutArray, checkMode, callChainFlags);
    }
    function isGenericFunctionReturningFunction(signature) {
        return !!(signature.typeParameters && isFunctionType(getReturnTypeOfSignature(signature)));
    }
    function isUntypedFunctionCall(funcType, apparentFuncType, numCallSignatures, numConstructSignatures) {
        return isTypeAny(funcType) || isTypeAny(apparentFuncType) && !!(funcType.flags & 262144) || !numCallSignatures && !numConstructSignatures && !(apparentFuncType.flags & 1048576) && !(getReducedType(apparentFuncType).flags & 131072) && isTypeAssignableTo(funcType, globalFunctionType);
    }
    function resolveNewExpression(node, candidatesOutArray, checkMode) {
        if (node.arguments && languageVersion < 1) {
            const spreadIndex = getSpreadArgumentIndex(node.arguments);
            if (spreadIndex >= 0) {
                error(node.arguments[spreadIndex], Diagnostics.Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher);
            }
        }
        let expressionType = checkNonNullExpression(node.expression);
        if (expressionType === silentNeverType) {
            return silentNeverSignature;
        }
        expressionType = getApparentType(expressionType);
        if (isErrorType(expressionType)) {
            return resolveErrorCall(node);
        }
        if (isTypeAny(expressionType)) {
            if (node.typeArguments) {
                error(node, Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
            }
            return resolveUntypedCall(node);
        }
        const constructSignatures = getSignaturesOfType(expressionType, 1);
        if (constructSignatures.length) {
            if (!isConstructorAccessible(node, constructSignatures[0])) {
                return resolveErrorCall(node);
            }
            if (someSignature(constructSignatures, signature => !!(signature.flags & 4))) {
                error(node, Diagnostics.Cannot_create_an_instance_of_an_abstract_class);
                return resolveErrorCall(node);
            }
            const valueDecl = expressionType.symbol && getClassLikeDeclarationOfSymbol(expressionType.symbol);
            if (valueDecl && hasSyntacticModifier(valueDecl, 256)) {
                error(node, Diagnostics.Cannot_create_an_instance_of_an_abstract_class);
                return resolveErrorCall(node);
            }
            return resolveCall(node, constructSignatures, candidatesOutArray, checkMode, 0);
        }
        const callSignatures = getSignaturesOfType(expressionType, 0);
        if (callSignatures.length) {
            const signature = resolveCall(node, callSignatures, candidatesOutArray, checkMode, 0);
            if (!noImplicitAny) {
                if (signature.declaration && !isJSConstructor(signature.declaration) && getReturnTypeOfSignature(signature) !== voidType) {
                    error(node, Diagnostics.Only_a_void_function_can_be_called_with_the_new_keyword);
                }
                if (getThisTypeOfSignature(signature) === voidType) {
                    error(node, Diagnostics.A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void);
                }
            }
            return signature;
        }
        invocationError(node.expression, expressionType, 1);
        return resolveErrorCall(node);
    }
    function someSignature(signatures, f) {
        if (isArray(signatures)) {
            return some(signatures, signature => someSignature(signature, f));
        }
        return signatures.compositeKind === 1048576 ? some(signatures.compositeSignatures, f) : f(signatures);
    }
    function typeHasProtectedAccessibleBase(target, type) {
        const baseTypes = getBaseTypes(type);
        if (!length(baseTypes)) {
            return false;
        }
        const firstBase = baseTypes[0];
        if (firstBase.flags & 2097152) {
            const types = firstBase.types;
            const mixinFlags = findMixins(types);
            let i = 0;
            for (const intersectionMember of firstBase.types) {
                if (!mixinFlags[i]) {
                    if (getObjectFlags(intersectionMember) & (1 | 2)) {
                        if (intersectionMember.symbol === target) {
                            return true;
                        }
                        if (typeHasProtectedAccessibleBase(target, intersectionMember)) {
                            return true;
                        }
                    }
                }
                i++;
            }
            return false;
        }
        if (firstBase.symbol === target) {
            return true;
        }
        return typeHasProtectedAccessibleBase(target, firstBase);
    }
    function isConstructorAccessible(node, signature) {
        if (!signature || !signature.declaration) {
            return true;
        }
        const declaration = signature.declaration;
        const modifiers = getSelectedEffectiveModifierFlags(declaration, 24);
        if (!modifiers || declaration.kind !== 173) {
            return true;
        }
        const declaringClassDeclaration = getClassLikeDeclarationOfSymbol(declaration.parent.symbol);
        const declaringClass = getDeclaredTypeOfSymbol(declaration.parent.symbol);
        if (!isNodeWithinClass(node, declaringClassDeclaration)) {
            const containingClass = getContainingClass(node);
            if (containingClass && modifiers & 16) {
                const containingType = getTypeOfNode(containingClass);
                if (typeHasProtectedAccessibleBase(declaration.parent.symbol, containingType)) {
                    return true;
                }
            }
            if (modifiers & 8) {
                error(node, Diagnostics.Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration, typeToString(declaringClass));
            }
            if (modifiers & 16) {
                error(node, Diagnostics.Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration, typeToString(declaringClass));
            }
            return false;
        }
        return true;
    }
    function invocationErrorDetails(errorTarget, apparentType, kind) {
        let errorInfo;
        const isCall = kind === 0;
        const awaitedType = getAwaitedType(apparentType);
        const maybeMissingAwait = awaitedType && getSignaturesOfType(awaitedType, kind).length > 0;
        if (apparentType.flags & 1048576) {
            const types = apparentType.types;
            let hasSignatures = false;
            for (const constituent of types) {
                const signatures = getSignaturesOfType(constituent, kind);
                if (signatures.length !== 0) {
                    hasSignatures = true;
                    if (errorInfo) {
                        break;
                    }
                } else {
                    if (!errorInfo) {
                        errorInfo = chainDiagnosticMessages(errorInfo, isCall ? Diagnostics.Type_0_has_no_call_signatures : Diagnostics.Type_0_has_no_construct_signatures, typeToString(constituent));
                        errorInfo = chainDiagnosticMessages(errorInfo, isCall ? Diagnostics.Not_all_constituents_of_type_0_are_callable : Diagnostics.Not_all_constituents_of_type_0_are_constructable, typeToString(apparentType));
                    }
                    if (hasSignatures) {
                        break;
                    }
                }
            }
            if (!hasSignatures) {
                errorInfo = chainDiagnosticMessages(void 0, isCall ? Diagnostics.No_constituent_of_type_0_is_callable : Diagnostics.No_constituent_of_type_0_is_constructable, typeToString(apparentType));
            }
            if (!errorInfo) {
                errorInfo = chainDiagnosticMessages(errorInfo, isCall ? Diagnostics.Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other : Diagnostics.Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other, typeToString(apparentType));
            }
        } else {
            errorInfo = chainDiagnosticMessages(errorInfo, isCall ? Diagnostics.Type_0_has_no_call_signatures : Diagnostics.Type_0_has_no_construct_signatures, typeToString(apparentType));
        }
        let headMessage = isCall ? Diagnostics.This_expression_is_not_callable : Diagnostics.This_expression_is_not_constructable;
        if (isCallExpression(errorTarget.parent) && errorTarget.parent.arguments.length === 0) {
            const {
                resolvedSymbol
            } = getNodeLinks(errorTarget);
            if (resolvedSymbol && resolvedSymbol.flags & 32768) {
                headMessage = Diagnostics.This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without;
            }
        }
        return {
            messageChain: chainDiagnosticMessages(errorInfo, headMessage),
            relatedMessage: maybeMissingAwait ? Diagnostics.Did_you_forget_to_use_await : void 0
        };
    }
    function invocationError(errorTarget, apparentType, kind, relatedInformation) {
        const {
            messageChain,
            relatedMessage: relatedInfo
        } = invocationErrorDetails(errorTarget, apparentType, kind);
        const diagnostic = createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorTarget), errorTarget, messageChain);
        if (relatedInfo) {
            addRelatedInfo(diagnostic, createDiagnosticForNode(errorTarget, relatedInfo));
        }
        if (isCallExpression(errorTarget.parent)) {
            const {
                start,
                length: length2
            } = getDiagnosticSpanForCallNode(errorTarget.parent, true);
            diagnostic.start = start;
            diagnostic.length = length2;
        }
        diagnostics.add(diagnostic);
        invocationErrorRecovery(apparentType, kind, relatedInformation ? addRelatedInfo(diagnostic, relatedInformation) : diagnostic);
    }
    function invocationErrorRecovery(apparentType, kind, diagnostic) {
        if (!apparentType.symbol) {
            return;
        }
        const importNode = getSymbolLinks(apparentType.symbol).originatingImport;
        if (importNode && !isImportCall(importNode)) {
            const sigs = getSignaturesOfType(getTypeOfSymbol(getSymbolLinks(apparentType.symbol).target), kind);
            if (!sigs || !sigs.length) return;
            addRelatedInfo(diagnostic, createDiagnosticForNode(importNode, Diagnostics.Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead));
        }
    }
    function resolveTaggedTemplateExpression(node, candidatesOutArray, checkMode) {
        const tagType = checkExpression(node.tag);
        const apparentType = getApparentType(tagType);
        if (isErrorType(apparentType)) {
            return resolveErrorCall(node);
        }
        const callSignatures = getSignaturesOfType(apparentType, 0);
        const numConstructSignatures = getSignaturesOfType(apparentType, 1).length;
        if (isUntypedFunctionCall(tagType, apparentType, callSignatures.length, numConstructSignatures)) {
            return resolveUntypedCall(node);
        }
        if (!callSignatures.length) {
            if (isArrayLiteralExpression(node.parent)) {
                const diagnostic = createDiagnosticForNode(node.tag, Diagnostics.It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tagged_template_expression_which_cannot_be_invoked);
                diagnostics.add(diagnostic);
                return resolveErrorCall(node);
            }
            invocationError(node.tag, apparentType, 0);
            return resolveErrorCall(node);
        }
        return resolveCall(node, callSignatures, candidatesOutArray, checkMode, 0);
    }
    function getDiagnosticHeadMessageForDecoratorResolution(node) {
        switch (node.parent.kind) {
            case 260:
            case 228:
                return Diagnostics.Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression;
            case 166:
                return Diagnostics.Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression;
            case 169:
                return Diagnostics.Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression;
            case 171:
            case 174:
            case 175:
                return Diagnostics.Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression;
            default:
                return Debug.fail();
        }
    }
    function resolveDecorator(node, candidatesOutArray, checkMode) {
        const funcType = checkExpression(node.expression);
        const apparentType = getApparentType(funcType);
        if (isErrorType(apparentType)) {
            return resolveErrorCall(node);
        }
        const callSignatures = getSignaturesOfType(apparentType, 0);
        const numConstructSignatures = getSignaturesOfType(apparentType, 1).length;
        if (isUntypedFunctionCall(funcType, apparentType, callSignatures.length, numConstructSignatures)) {
            return resolveUntypedCall(node);
        }
        if (isPotentiallyUncalledDecorator(node, callSignatures) && !isParenthesizedExpression(node.expression)) {
            const nodeStr = getTextOfNode(node.expression, false);
            error(node, Diagnostics._0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0, nodeStr);
            return resolveErrorCall(node);
        }
        const headMessage = getDiagnosticHeadMessageForDecoratorResolution(node);
        if (!callSignatures.length) {
            const errorDetails = invocationErrorDetails(node.expression, apparentType, 0);
            const messageChain = chainDiagnosticMessages(errorDetails.messageChain, headMessage);
            const diag2 = createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(node.expression), node.expression, messageChain);
            if (errorDetails.relatedMessage) {
                addRelatedInfo(diag2, createDiagnosticForNode(node.expression, errorDetails.relatedMessage));
            }
            diagnostics.add(diag2);
            invocationErrorRecovery(apparentType, 0, diag2);
            return resolveErrorCall(node);
        }
        return resolveCall(node, callSignatures, candidatesOutArray, checkMode, 0, headMessage);
    }
    function createSignatureForJSXIntrinsic(node, result) {
        const namespace = getJsxNamespaceAt(node);
        const exports = namespace && getExportsOfSymbol(namespace);
        const typeSymbol = exports && getSymbol2(exports, JsxNames.Element, 788968);
        const returnNode = typeSymbol && nodeBuilder.symbolToEntityName(typeSymbol, 788968, node);
        const declaration = factory.createFunctionTypeNode(void 0, [factory.createParameterDeclaration(void 0, void 0, "props", void 0, nodeBuilder.typeToTypeNode(result, node))], returnNode ? factory.createTypeReferenceNode(returnNode, void 0) : factory.createKeywordTypeNode(131));
        const parameterSymbol = createSymbol(1, "props");
        parameterSymbol.links.type = result;
        return createSignature(declaration, void 0, void 0, [parameterSymbol], typeSymbol ? getDeclaredTypeOfSymbol(typeSymbol) : errorType, void 0, 1, 0);
    }
    function resolveJsxOpeningLikeElement(node, candidatesOutArray, checkMode) {
        if (isJsxIntrinsicIdentifier(node.tagName)) {
            const result = getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node);
            const fakeSignature = createSignatureForJSXIntrinsic(node, result);
            checkTypeAssignableToAndOptionallyElaborate(checkExpressionWithContextualType(node.attributes, getEffectiveFirstArgumentForJsxSignature(fakeSignature, node), void 0, 0), result, node.tagName, node.attributes);
            if (length(node.typeArguments)) {
                forEach(node.typeArguments, checkSourceElement);
                diagnostics.add(createDiagnosticForNodeArray(getSourceFileOfNode(node), node.typeArguments, Diagnostics.Expected_0_type_arguments_but_got_1, 0, length(node.typeArguments)));
            }
            return fakeSignature;
        }
        const exprTypes = checkExpression(node.tagName);
        const apparentType = getApparentType(exprTypes);
        if (isErrorType(apparentType)) {
            return resolveErrorCall(node);
        }
        const signatures = getUninstantiatedJsxSignaturesOfType(exprTypes, node);
        if (isUntypedFunctionCall(exprTypes, apparentType, signatures.length, 0)) {
            return resolveUntypedCall(node);
        }
        if (signatures.length === 0) {
            error(node.tagName, Diagnostics.JSX_element_type_0_does_not_have_any_construct_or_call_signatures, getTextOfNode(node.tagName));
            return resolveErrorCall(node);
        }
        return resolveCall(node, signatures, candidatesOutArray, checkMode, 0);
    }
    function isPotentiallyUncalledDecorator(decorator, signatures) {
        return signatures.length && every(signatures, signature => signature.minArgumentCount === 0 && !signatureHasRestParameter(signature) && signature.parameters.length < getDecoratorArgumentCount(decorator, signature));
    }
    function resolveSignature(node, candidatesOutArray, checkMode) {
        switch (node.kind) {
            case 210:
                return resolveCallExpression(node, candidatesOutArray, checkMode);
            case 211:
                return resolveNewExpression(node, candidatesOutArray, checkMode);
            case 212:
                return resolveTaggedTemplateExpression(node, candidatesOutArray, checkMode);
            case 167:
                return resolveDecorator(node, candidatesOutArray, checkMode);
            case 283:
            case 282:
                return resolveJsxOpeningLikeElement(node, candidatesOutArray, checkMode);
        }
        throw Debug.assertNever(node, "Branch in 'resolveSignature' should be unreachable.");
    }
    function getResolvedSignature(node, candidatesOutArray, checkMode) {
        const links = getNodeLinks(node);
        const cached = links.resolvedSignature;
        if (cached && cached !== resolvingSignature && !candidatesOutArray) {
            return cached;
        }
        links.resolvedSignature = resolvingSignature;
        const result = resolveSignature(node, candidatesOutArray, checkMode || 0);
        if (result !== resolvingSignature) {
            links.resolvedSignature = flowLoopStart === flowLoopCount ? result : cached;
        }
        return result;
    }
    function isJSConstructor(node) {
        var _a2;
        if (!node || !isInJSFile(node)) {
            return false;
        }
        const func = isFunctionDeclaration(node) || isFunctionExpression(node) ? node : (isVariableDeclaration(node) || isPropertyAssignment(node)) && node.initializer && isFunctionExpression(node.initializer) ? node.initializer : void 0;
        if (func) {
            if (getJSDocClassTag(node)) return true;
            if (isPropertyAssignment(walkUpParenthesizedExpressions(func.parent))) return false;
            const symbol = getSymbolOfDeclaration(func);
            return !!((_a2 = symbol == null ? void 0 : symbol.members) == null ? void 0 : _a2.size);
        }
        return false;
    }
    function mergeJSSymbols(target, source) {
        var _a2, _b;
        if (source) {
            const links = getSymbolLinks(source);
            if (!links.inferredClassSymbol || !links.inferredClassSymbol.has(getSymbolId(target))) {
                const inferred = isTransientSymbol(target) ? target : cloneSymbol(target);
                inferred.exports = inferred.exports || createSymbolTable();
                inferred.members = inferred.members || createSymbolTable();
                inferred.flags |= source.flags & 32;
                if ((_a2 = source.exports) == null ? void 0 : _a2.size) {
                    mergeSymbolTable(inferred.exports, source.exports);
                }
                if ((_b = source.members) == null ? void 0 : _b.size) {
                    mergeSymbolTable(inferred.members, source.members);
                }
                (links.inferredClassSymbol || (links.inferredClassSymbol = /* @__PURE__ */new Map())).set(getSymbolId(inferred), inferred);
                return inferred;
            }
            return links.inferredClassSymbol.get(getSymbolId(target));
        }
    }
    function getAssignedClassSymbol(decl) {
        var _a2;
        const assignmentSymbol = decl && getSymbolOfExpando(decl, true);
        const prototype = (_a2 = assignmentSymbol == null ? void 0 : assignmentSymbol.exports) == null ? void 0 : _a2.get("prototype");
        const init = (prototype == null ? void 0 : prototype.valueDeclaration) && getAssignedJSPrototype(prototype.valueDeclaration);
        return init ? getSymbolOfDeclaration(init) : void 0;
    }
    function getSymbolOfExpando(node, allowDeclaration) {
        if (!node.parent) {
            return void 0;
        }
        let name;
        let decl;
        if (isVariableDeclaration(node.parent) && node.parent.initializer === node) {
            if (!isInJSFile(node) && !(isVarConst(node.parent) && isFunctionLikeDeclaration(node))) {
                return void 0;
            }
            name = node.parent.name;
            decl = node.parent;
        } else if (isBinaryExpression(node.parent)) {
            const parentNode = node.parent;
            const parentNodeOperator = node.parent.operatorToken.kind;
            if (parentNodeOperator === 63 && (allowDeclaration || parentNode.right === node)) {
                name = parentNode.left;
                decl = name;
            } else if (parentNodeOperator === 56 || parentNodeOperator === 60) {
                if (isVariableDeclaration(parentNode.parent) && parentNode.parent.initializer === parentNode) {
                    name = parentNode.parent.name;
                    decl = parentNode.parent;
                } else if (isBinaryExpression(parentNode.parent) && parentNode.parent.operatorToken.kind === 63 && (allowDeclaration || parentNode.parent.right === parentNode)) {
                    name = parentNode.parent.left;
                    decl = name;
                }
                if (!name || !isBindableStaticNameExpression(name) || !isSameEntityName(name, parentNode.left)) {
                    return void 0;
                }
            }
        } else if (allowDeclaration && isFunctionDeclaration(node)) {
            name = node.name;
            decl = node;
        }
        if (!decl || !name || !allowDeclaration && !getExpandoInitializer(node, isPrototypeAccess(name))) {
            return void 0;
        }
        return getSymbolOfNode(decl);
    }
    function getAssignedJSPrototype(node) {
        if (!node.parent) {
            return false;
        }
        let parent2 = node.parent;
        while (parent2 && parent2.kind === 208) {
            parent2 = parent2.parent;
        }
        if (parent2 && isBinaryExpression(parent2) && isPrototypeAccess(parent2.left) && parent2.operatorToken.kind === 63) {
            const right = getInitializerOfBinaryExpression(parent2);
            return isObjectLiteralExpression(right) && right;
        }
    }
    function checkCallExpression(node, checkMode) {
        var _a2, _b, _c;
        checkGrammarTypeArguments(node, node.typeArguments);
        const signature = getResolvedSignature(node, void 0, checkMode);
        if (signature === resolvingSignature) {
            return silentNeverType;
        }
        checkDeprecatedSignature(signature, node);
        if (node.expression.kind === 106) {
            return voidType;
        }
        if (node.kind === 211) {
            const declaration = signature.declaration;
            if (declaration && declaration.kind !== 173 && declaration.kind !== 177 && declaration.kind !== 182 && !(isJSDocSignature(declaration) && ((_b = (_a2 = getJSDocRoot(declaration)) == null ? void 0 : _a2.parent) == null ? void 0 : _b.kind) === 173) && !isJSDocConstructSignature(declaration) && !isJSConstructor(declaration)) {
                if (noImplicitAny) {
                    error(node, Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type);
                }
                return anyType;
            }
        }
        if (isInJSFile(node) && getEmitModuleResolutionKind(compilerOptions) !== 100 && isCommonJsRequire(node)) {
            return resolveExternalModuleTypeByLiteral(node.arguments[0]);
        }
        const returnType = getReturnTypeOfSignature(signature);
        if (returnType.flags & 12288 && isSymbolOrSymbolForCall(node)) {
            return getESSymbolLikeTypeForNode(walkUpParenthesizedExpressions(node.parent));
        }
        if (node.kind === 210 && !node.questionDotToken && node.parent.kind === 241 && returnType.flags & 16384 && getTypePredicateOfSignature(signature)) {
            if (!isDottedName(node.expression)) {
                error(node.expression, Diagnostics.Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name);
            } else if (!getEffectsSignature(node)) {
                const diagnostic = error(node.expression, Diagnostics.Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation);
                getTypeOfDottedName(node.expression, diagnostic);
            }
        }
        if (isInJSFile(node)) {
            const jsSymbol = getSymbolOfExpando(node, false);
            if ((_c = jsSymbol == null ? void 0 : jsSymbol.exports) == null ? void 0 : _c.size) {
                const jsAssignmentType = createAnonymousType(jsSymbol, jsSymbol.exports, emptyArray, emptyArray, emptyArray);
                jsAssignmentType.objectFlags |= 4096;
                return getIntersectionType([returnType, jsAssignmentType]);
            }
        }
        return returnType;
    }
    function checkDeprecatedSignature(signature, node) {
        if (signature.declaration && signature.declaration.flags & 268435456) {
            const suggestionNode = getDeprecatedSuggestionNode(node);
            const name = tryGetPropertyAccessOrIdentifierToString(getInvokedExpression(node));
            addDeprecatedSuggestionWithSignature(suggestionNode, signature.declaration, name, signatureToString(signature));
        }
    }
    function getDeprecatedSuggestionNode(node) {
        node = skipParentheses(node);
        switch (node.kind) {
            case 210:
            case 167:
            case 211:
                return getDeprecatedSuggestionNode(node.expression);
            case 212:
                return getDeprecatedSuggestionNode(node.tag);
            case 283:
            case 282:
                return getDeprecatedSuggestionNode(node.tagName);
            case 209:
                return node.argumentExpression;
            case 208:
                return node.name;
            case 180:
                const typeReference = node;
                return isQualifiedName(typeReference.typeName) ? typeReference.typeName.right : typeReference;
            default:
                return node;
        }
    }
    function isSymbolOrSymbolForCall(node) {
        if (!isCallExpression(node)) return false;
        let left = node.expression;
        if (isPropertyAccessExpression(left) && left.name.escapedText === "for") {
            left = left.expression;
        }
        if (!isIdentifier(left) || left.escapedText !== "Symbol") {
            return false;
        }
        const globalESSymbol = getGlobalESSymbolConstructorSymbol(false);
        if (!globalESSymbol) {
            return false;
        }
        return globalESSymbol === resolveName(left, "Symbol", 111551, void 0, void 0, false);
    }
    function checkImportCallExpression(node) {
        checkGrammarImportCallExpression(node);
        if (node.arguments.length === 0) {
            return createPromiseReturnType(node, anyType);
        }
        const specifier = node.arguments[0];
        const specifierType = checkExpressionCached(specifier);
        const optionsType = node.arguments.length > 1 ? checkExpressionCached(node.arguments[1]) : void 0;
        for (let i = 2; i < node.arguments.length; ++i) {
            checkExpressionCached(node.arguments[i]);
        }
        if (specifierType.flags & 32768 || specifierType.flags & 65536 || !isTypeAssignableTo(specifierType, stringType)) {
            error(specifier, Diagnostics.Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0, typeToString(specifierType));
        }
        if (optionsType) {
            const importCallOptionsType = getGlobalImportCallOptionsType(true);
            if (importCallOptionsType !== emptyObjectType) {
                checkTypeAssignableTo(optionsType, getNullableType(importCallOptionsType, 32768), node.arguments[1]);
            }
        }
        const moduleSymbol = resolveExternalModuleName(node, specifier);
        if (moduleSymbol) {
            const esModuleSymbol = resolveESModuleSymbol(moduleSymbol, specifier, true, false);
            if (esModuleSymbol) {
                return createPromiseReturnType(node, getTypeWithSyntheticDefaultOnly(getTypeOfSymbol(esModuleSymbol), esModuleSymbol, moduleSymbol, specifier) || getTypeWithSyntheticDefaultImportType(getTypeOfSymbol(esModuleSymbol), esModuleSymbol, moduleSymbol, specifier));
            }
        }
        return createPromiseReturnType(node, anyType);
    }
    function createDefaultPropertyWrapperForModule(symbol, originalSymbol, anonymousSymbol) {
        const memberTable = createSymbolTable();
        const newSymbol = createSymbol(2097152, "default");
        newSymbol.parent = originalSymbol;
        newSymbol.links.nameType = getStringLiteralType("default");
        newSymbol.links.aliasTarget = resolveSymbol(symbol);
        memberTable.set("default", newSymbol);
        return createAnonymousType(anonymousSymbol, memberTable, emptyArray, emptyArray, emptyArray);
    }
    function getTypeWithSyntheticDefaultOnly(type, symbol, originalSymbol, moduleSpecifier) {
        const hasDefaultOnly = isOnlyImportedAsDefault(moduleSpecifier);
        if (hasDefaultOnly && type && !isErrorType(type)) {
            const synthType = type;
            if (!synthType.defaultOnlyType) {
                const type2 = createDefaultPropertyWrapperForModule(symbol, originalSymbol);
                synthType.defaultOnlyType = type2;
            }
            return synthType.defaultOnlyType;
        }
        return void 0;
    }
    function getTypeWithSyntheticDefaultImportType(type, symbol, originalSymbol, moduleSpecifier) {
        var _a2;
        if (allowSyntheticDefaultImports && type && !isErrorType(type)) {
            const synthType = type;
            if (!synthType.syntheticType) {
                const file = (_a2 = originalSymbol.declarations) == null ? void 0 : _a2.find(isSourceFile);
                const hasSyntheticDefault = canHaveSyntheticDefault(file, originalSymbol, false, moduleSpecifier);
                if (hasSyntheticDefault) {
                    const anonymousSymbol = createSymbol(2048, "__type");
                    const defaultContainingObject = createDefaultPropertyWrapperForModule(symbol, originalSymbol, anonymousSymbol);
                    anonymousSymbol.links.type = defaultContainingObject;
                    synthType.syntheticType = isValidSpreadType(type) ? getSpreadType(type, defaultContainingObject, anonymousSymbol, 0, false) : defaultContainingObject;
                } else {
                    synthType.syntheticType = type;
                }
            }
            return synthType.syntheticType;
        }
        return type;
    }
    function isCommonJsRequire(node) {
        if (!isRequireCall(node, true)) {
            return false;
        }
        if (!isIdentifier(node.expression)) return Debug.fail();
        const resolvedRequire = resolveName(node.expression, node.expression.escapedText, 111551, void 0, void 0, true);
        if (resolvedRequire === requireSymbol) {
            return true;
        }
        if (resolvedRequire.flags & 2097152) {
            return false;
        }
        const targetDeclarationKind = resolvedRequire.flags & 16 ? 259 : resolvedRequire.flags & 3 ? 257 : 0;
        if (targetDeclarationKind !== 0) {
            const decl = getDeclarationOfKind(resolvedRequire, targetDeclarationKind);
            return !!decl && !!(decl.flags & 16777216);
        }
        return false;
    }
    function checkTaggedTemplateExpression(node) {
        if (!checkGrammarTaggedTemplateChain(node)) checkGrammarTypeArguments(node, node.typeArguments);
        if (languageVersion < 2) {
            checkExternalEmitHelpers(node, 262144);
        }
        const signature = getResolvedSignature(node);
        checkDeprecatedSignature(signature, node);
        return getReturnTypeOfSignature(signature);
    }
    function checkAssertion(node) {
        if (node.kind === 213) {
            const file = getSourceFileOfNode(node);
            if (file && fileExtensionIsOneOf(file.fileName, [".cts", ".mts"])) {
                grammarErrorOnNode(node, Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead);
            }
        }
        return checkAssertionWorker(node, node.type, node.expression);
    }
    function isValidConstAssertionArgument(node) {
        switch (node.kind) {
            case 10:
            case 14:
            case 8:
            case 9:
            case 110:
            case 95:
            case 206:
            case 207:
            case 225:
                return true;
            case 214:
                return isValidConstAssertionArgument(node.expression);
            case 221:
                const op = node.operator;
                const arg = node.operand;
                return op === 40 && (arg.kind === 8 || arg.kind === 9) || op === 39 && arg.kind === 8;
            case 208:
            case 209:
                const expr = skipParentheses(node.expression);
                const symbol = isEntityNameExpression(expr) ? resolveEntityName(expr, 111551, true) : void 0;
                return !!(symbol && symbol.flags & 384);
        }
        return false;
    }
    function checkAssertionWorker(errNode, type, expression, checkMode) {
        let exprType = checkExpression(expression, checkMode);
        if (isConstTypeReference(type)) {
            if (!isValidConstAssertionArgument(expression)) {
                error(expression, Diagnostics.A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals);
            }
            return getRegularTypeOfLiteralType(exprType);
        }
        checkSourceElement(type);
        exprType = getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(exprType));
        const targetType = getTypeFromTypeNode(type);
        if (!isErrorType(targetType)) {
            addLazyDiagnostic(() => {
                const widenedType = getWidenedType(exprType);
                if (!isTypeComparableTo(targetType, widenedType)) {
                    checkTypeComparableTo(exprType, targetType, errNode, Diagnostics.Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first);
                }
            });
        }
        return targetType;
    }
    function checkNonNullChain(node) {
        const leftType = checkExpression(node.expression);
        const nonOptionalType = getOptionalExpressionType(leftType, node.expression);
        return propagateOptionalTypeMarker(getNonNullableType(nonOptionalType), node, nonOptionalType !== leftType);
    }
    function checkNonNullAssertion(node) {
        return node.flags & 32 ? checkNonNullChain(node) : getNonNullableType(checkExpression(node.expression));
    }
    function checkExpressionWithTypeArguments(node) {
        checkGrammarExpressionWithTypeArguments(node);
        forEach(node.typeArguments, checkSourceElement);
        const exprType = node.kind === 230 ? checkExpression(node.expression) : isThisIdentifier(node.exprName) ? checkThisExpression(node.exprName) : checkExpression(node.exprName);
        return getInstantiationExpressionType(exprType, node);
    }
    function getInstantiationExpressionType(exprType, node) {
        const typeArguments = node.typeArguments;
        if (exprType === silentNeverType || isErrorType(exprType) || !some(typeArguments)) {
            return exprType;
        }
        let hasSomeApplicableSignature = false;
        let nonApplicableType;
        const result = getInstantiatedType(exprType);
        const errorType2 = hasSomeApplicableSignature ? nonApplicableType : exprType;
        if (errorType2) {
            diagnostics.add(createDiagnosticForNodeArray(getSourceFileOfNode(node), typeArguments, Diagnostics.Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable, typeToString(errorType2)));
        }
        return result;
        function getInstantiatedType(type) {
            let hasSignatures = false;
            let hasApplicableSignature = false;
            const result2 = getInstantiatedTypePart(type);
            hasSomeApplicableSignature || (hasSomeApplicableSignature = hasApplicableSignature);
            if (hasSignatures && !hasApplicableSignature) {
                nonApplicableType != null ? nonApplicableType : nonApplicableType = type;
            }
            return result2;
            function getInstantiatedTypePart(type2) {
                if (type2.flags & 524288) {
                    const resolved = resolveStructuredTypeMembers(type2);
                    const callSignatures = getInstantiatedSignatures(resolved.callSignatures);
                    const constructSignatures = getInstantiatedSignatures(resolved.constructSignatures);
                    hasSignatures || (hasSignatures = resolved.callSignatures.length !== 0 || resolved.constructSignatures.length !== 0);
                    hasApplicableSignature || (hasApplicableSignature = callSignatures.length !== 0 || constructSignatures.length !== 0);
                    if (callSignatures !== resolved.callSignatures || constructSignatures !== resolved.constructSignatures) {
                        const result3 = createAnonymousType(void 0, resolved.members, callSignatures, constructSignatures, resolved.indexInfos);
                        result3.objectFlags |= 8388608;
                        result3.node = node;
                        return result3;
                    }
                } else if (type2.flags & 58982400) {
                    const constraint = getBaseConstraintOfType(type2);
                    if (constraint) {
                        const instantiated = getInstantiatedTypePart(constraint);
                        if (instantiated !== constraint) {
                            return instantiated;
                        }
                    }
                } else if (type2.flags & 1048576) {
                    return mapType(type2, getInstantiatedType);
                } else if (type2.flags & 2097152) {
                    return getIntersectionType(sameMap(type2.types, getInstantiatedTypePart));
                }
                return type2;
            }
        }
        function getInstantiatedSignatures(signatures) {
            const applicableSignatures = filter(signatures, sig => !!sig.typeParameters && hasCorrectTypeArgumentArity(sig, typeArguments));
            return sameMap(applicableSignatures, sig => {
                const typeArgumentTypes = checkTypeArguments(sig, typeArguments, true);
                return typeArgumentTypes ? getSignatureInstantiation(sig, typeArgumentTypes, isInJSFile(sig.declaration)) : sig;
            });
        }
    }
    function checkSatisfiesExpression(node) {
        checkSourceElement(node.type);
        return checkSatisfiesExpressionWorker(node.expression, node.type);
    }
    function checkSatisfiesExpressionWorker(expression, target, checkMode) {
        const exprType = checkExpression(expression, checkMode);
        const targetType = getTypeFromTypeNode(target);
        if (isErrorType(targetType)) {
            return targetType;
        }
        checkTypeAssignableToAndOptionallyElaborate(exprType, targetType, target, expression, Diagnostics.Type_0_does_not_satisfy_the_expected_type_1);
        return exprType;
    }
    function checkMetaProperty(node) {
        checkGrammarMetaProperty(node);
        if (node.keywordToken === 103) {
            return checkNewTargetMetaProperty(node);
        }
        if (node.keywordToken === 100) {
            return checkImportMetaProperty(node);
        }
        return Debug.assertNever(node.keywordToken);
    }
    function checkMetaPropertyKeyword(node) {
        switch (node.keywordToken) {
            case 100:
                return getGlobalImportMetaExpressionType();
            case 103:
                const type = checkNewTargetMetaProperty(node);
                return isErrorType(type) ? errorType : createNewTargetExpressionType(type);
            default:
                Debug.assertNever(node.keywordToken);
        }
    }
    function checkNewTargetMetaProperty(node) {
        const container = getNewTargetContainer(node);
        if (!container) {
            error(node, Diagnostics.Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor, "new.target");
            return errorType;
        } else if (container.kind === 173) {
            const symbol = getSymbolOfDeclaration(container.parent);
            return getTypeOfSymbol(symbol);
        } else {
            const symbol = getSymbolOfDeclaration(container);
            return getTypeOfSymbol(symbol);
        }
    }
    function checkImportMetaProperty(node) {
        if (moduleKind === 100 || moduleKind === 199) {
            if (getSourceFileOfNode(node).impliedNodeFormat !== 99) {
                error(node, Diagnostics.The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output);
            }
        } else if (moduleKind < 6 && moduleKind !== 4) {
            error(node, Diagnostics.The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system_node16_or_nodenext);
        }
        const file = getSourceFileOfNode(node);
        Debug.assert(!!(file.flags & 4194304), "Containing file is missing import meta node flag.");
        return node.name.escapedText === "meta" ? getGlobalImportMetaType() : errorType;
    }
    function getTypeOfParameter(symbol) {
        const type = getTypeOfSymbol(symbol);
        if (strictNullChecks) {
            const declaration = symbol.valueDeclaration;
            if (declaration && hasInitializer(declaration)) {
                return getOptionalType(type);
            }
        }
        return type;
    }
    function getTupleElementLabel(d) {
        Debug.assert(isIdentifier(d.name));
        return d.name.escapedText;
    }
    function getParameterNameAtPosition(signature, pos, overrideRestType) {
        const paramCount = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
        if (pos < paramCount) {
            return signature.parameters[pos].escapedName;
        }
        const restParameter = signature.parameters[paramCount] || unknownSymbol;
        const restType = overrideRestType || getTypeOfSymbol(restParameter);
        if (isTupleType(restType)) {
            const associatedNames = restType.target.labeledElementDeclarations;
            const index = pos - paramCount;
            return associatedNames && getTupleElementLabel(associatedNames[index]) || restParameter.escapedName + "_" + index;
        }
        return restParameter.escapedName;
    }
    function getParameterIdentifierNameAtPosition(signature, pos) {
        var _a2;
        if (((_a2 = signature.declaration) == null ? void 0 : _a2.kind) === 320) {
            return void 0;
        }
        const paramCount = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
        if (pos < paramCount) {
            const param = signature.parameters[pos];
            return isParameterDeclarationWithIdentifierName(param) ? [param.escapedName, false] : void 0;
        }
        const restParameter = signature.parameters[paramCount] || unknownSymbol;
        if (!isParameterDeclarationWithIdentifierName(restParameter)) {
            return void 0;
        }
        const restType = getTypeOfSymbol(restParameter);
        if (isTupleType(restType)) {
            const associatedNames = restType.target.labeledElementDeclarations;
            const index = pos - paramCount;
            const associatedName = associatedNames == null ? void 0 : associatedNames[index];
            const isRestTupleElement = !!(associatedName == null ? void 0 : associatedName.dotDotDotToken);
            return associatedName ? [getTupleElementLabel(associatedName), isRestTupleElement] : void 0;
        }
        if (pos === paramCount) {
            return [restParameter.escapedName, true];
        }
        return void 0;
    }
    function isParameterDeclarationWithIdentifierName(symbol) {
        return symbol.valueDeclaration && isParameter(symbol.valueDeclaration) && isIdentifier(symbol.valueDeclaration.name);
    }
    function isValidDeclarationForTupleLabel(d) {
        return d.kind === 199 || isParameter(d) && d.name && isIdentifier(d.name);
    }
    function getNameableDeclarationAtPosition(signature, pos) {
        const paramCount = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
        if (pos < paramCount) {
            const decl = signature.parameters[pos].valueDeclaration;
            return decl && isValidDeclarationForTupleLabel(decl) ? decl : void 0;
        }
        const restParameter = signature.parameters[paramCount] || unknownSymbol;
        const restType = getTypeOfSymbol(restParameter);
        if (isTupleType(restType)) {
            const associatedNames = restType.target.labeledElementDeclarations;
            const index = pos - paramCount;
            return associatedNames && associatedNames[index];
        }
        return restParameter.valueDeclaration && isValidDeclarationForTupleLabel(restParameter.valueDeclaration) ? restParameter.valueDeclaration : void 0;
    }
    function getTypeAtPosition(signature, pos) {
        return tryGetTypeAtPosition(signature, pos) || anyType;
    }
    function tryGetTypeAtPosition(signature, pos) {
        const paramCount = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
        if (pos < paramCount) {
            return getTypeOfParameter(signature.parameters[pos]);
        }
        if (signatureHasRestParameter(signature)) {
            const restType = getTypeOfSymbol(signature.parameters[paramCount]);
            const index = pos - paramCount;
            if (!isTupleType(restType) || restType.target.hasRestElement || index < restType.target.fixedLength) {
                return getIndexedAccessType(restType, getNumberLiteralType(index));
            }
        }
        return void 0;
    }
    function getRestTypeAtPosition(source, pos) {
        const parameterCount = getParameterCount(source);
        const minArgumentCount = getMinArgumentCount(source);
        const restType = getEffectiveRestType(source);
        if (restType && pos >= parameterCount - 1) {
            return pos === parameterCount - 1 ? restType : createArrayType(getIndexedAccessType(restType, numberType));
        }
        const types = [];
        const flags = [];
        const names = [];
        for (let i = pos; i < parameterCount; i++) {
            if (!restType || i < parameterCount - 1) {
                types.push(getTypeAtPosition(source, i));
                flags.push(i < minArgumentCount ? 1 : 2);
            } else {
                types.push(restType);
                flags.push(8);
            }
            const name = getNameableDeclarationAtPosition(source, i);
            if (name) {
                names.push(name);
            }
        }
        return createTupleType(types, flags, false, length(names) === length(types) ? names : void 0);
    }
    function getParameterCount(signature) {
        const length2 = signature.parameters.length;
        if (signatureHasRestParameter(signature)) {
            const restType = getTypeOfSymbol(signature.parameters[length2 - 1]);
            if (isTupleType(restType)) {
                return length2 + restType.target.fixedLength - (restType.target.hasRestElement ? 0 : 1);
            }
        }
        return length2;
    }
    function getMinArgumentCount(signature, flags) {
        const strongArityForUntypedJS = flags & 1;
        const voidIsNonOptional = flags & 2;
        if (voidIsNonOptional || signature.resolvedMinArgumentCount === void 0) {
            let minArgumentCount;
            if (signatureHasRestParameter(signature)) {
                const restType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
                if (isTupleType(restType)) {
                    const firstOptionalIndex = findIndex(restType.target.elementFlags, f => !(f & 1));
                    const requiredCount = firstOptionalIndex < 0 ? restType.target.fixedLength : firstOptionalIndex;
                    if (requiredCount > 0) {
                        minArgumentCount = signature.parameters.length - 1 + requiredCount;
                    }
                }
            }
            if (minArgumentCount === void 0) {
                if (!strongArityForUntypedJS && signature.flags & 32) {
                    return 0;
                }
                minArgumentCount = signature.minArgumentCount;
            }
            if (voidIsNonOptional) {
                return minArgumentCount;
            }
            for (let i = minArgumentCount - 1; i >= 0; i--) {
                const type = getTypeAtPosition(signature, i);
                if (filterType(type, acceptsVoid).flags & 131072) {
                    break;
                }
                minArgumentCount = i;
            }
            signature.resolvedMinArgumentCount = minArgumentCount;
        }
        return signature.resolvedMinArgumentCount;
    }
    function hasEffectiveRestParameter(signature) {
        if (signatureHasRestParameter(signature)) {
            const restType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
            return !isTupleType(restType) || restType.target.hasRestElement;
        }
        return false;
    }
    function getEffectiveRestType(signature) {
        if (signatureHasRestParameter(signature)) {
            const restType = getTypeOfSymbol(signature.parameters[signature.parameters.length - 1]);
            if (!isTupleType(restType)) {
                return restType;
            }
            if (restType.target.hasRestElement) {
                return sliceTupleType(restType, restType.target.fixedLength);
            }
        }
        return void 0;
    }
    function getNonArrayRestType(signature) {
        const restType = getEffectiveRestType(signature);
        return restType && !isArrayType(restType) && !isTypeAny(restType) && (getReducedType(restType).flags & 131072) === 0 ? restType : void 0;
    }
    function getTypeOfFirstParameterOfSignature(signature) {
        return getTypeOfFirstParameterOfSignatureWithFallback(signature, neverType);
    }
    function getTypeOfFirstParameterOfSignatureWithFallback(signature, fallbackType) {
        return signature.parameters.length > 0 ? getTypeAtPosition(signature, 0) : fallbackType;
    }
    function inferFromAnnotatedParameters(signature, context, inferenceContext) {
        const len = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
        for (let i = 0; i < len; i++) {
            const declaration = signature.parameters[i].valueDeclaration;
            if (declaration.type) {
                const typeNode = getEffectiveTypeAnnotationNode(declaration);
                if (typeNode) {
                    inferTypes(inferenceContext.inferences, getTypeFromTypeNode(typeNode), getTypeAtPosition(context, i));
                }
            }
        }
    }
    function assignContextualParameterTypes(signature, context) {
        if (context.typeParameters) {
            if (!signature.typeParameters) {
                signature.typeParameters = context.typeParameters;
            } else {
                return;
            }
        }
        if (context.thisParameter) {
            const parameter = signature.thisParameter;
            if (!parameter || parameter.valueDeclaration && !parameter.valueDeclaration.type) {
                if (!parameter) {
                    signature.thisParameter = createSymbolWithType(context.thisParameter, void 0);
                }
                assignParameterType(signature.thisParameter, getTypeOfSymbol(context.thisParameter));
            }
        }
        const len = signature.parameters.length - (signatureHasRestParameter(signature) ? 1 : 0);
        for (let i = 0; i < len; i++) {
            const parameter = signature.parameters[i];
            if (!getEffectiveTypeAnnotationNode(parameter.valueDeclaration)) {
                const contextualParameterType = tryGetTypeAtPosition(context, i);
                assignParameterType(parameter, contextualParameterType);
            }
        }
        if (signatureHasRestParameter(signature)) {
            const parameter = last(signature.parameters);
            if (parameter.valueDeclaration ? !getEffectiveTypeAnnotationNode(parameter.valueDeclaration) : !!(getCheckFlags(parameter) & 65536)) {
                const contextualParameterType = getRestTypeAtPosition(context, len);
                assignParameterType(parameter, contextualParameterType);
            }
        }
    }
    function assignNonContextualParameterTypes(signature) {
        if (signature.thisParameter) {
            assignParameterType(signature.thisParameter);
        }
        for (const parameter of signature.parameters) {
            assignParameterType(parameter);
        }
    }
    function assignParameterType(parameter, type) {
        const links = getSymbolLinks(parameter);
        if (!links.type) {
            const declaration = parameter.valueDeclaration;
            links.type = type || (declaration ? getWidenedTypeForVariableLikeDeclaration(declaration, true) : getTypeOfSymbol(parameter));
            if (declaration && declaration.name.kind !== 79) {
                if (links.type === unknownType) {
                    links.type = getTypeFromBindingPattern(declaration.name);
                }
                assignBindingElementTypes(declaration.name, links.type);
            }
        } else if (type) {
            Debug.assertEqual(links.type, type, "Parameter symbol already has a cached type which differs from newly assigned type");
        }
    }
    function assignBindingElementTypes(pattern, parentType) {
        for (const element of pattern.elements) {
            if (!isOmittedExpression(element)) {
                const type = getBindingElementTypeFromParentType(element, parentType);
                if (element.name.kind === 79) {
                    getSymbolLinks(getSymbolOfDeclaration(element)).type = type;
                } else {
                    assignBindingElementTypes(element.name, type);
                }
            }
        }
    }
    function createClassDecoratorContextType(classType) {
        return tryCreateTypeReference(getGlobalClassDecoratorContextType(true), [classType]);
    }
    function createClassMethodDecoratorContextType(thisType, valueType) {
        return tryCreateTypeReference(getGlobalClassMethodDecoratorContextType(true), [thisType, valueType]);
    }
    function createClassGetterDecoratorContextType(thisType, valueType) {
        return tryCreateTypeReference(getGlobalClassGetterDecoratorContextType(true), [thisType, valueType]);
    }
    function createClassSetterDecoratorContextType(thisType, valueType) {
        return tryCreateTypeReference(getGlobalClassSetterDecoratorContextType(true), [thisType, valueType]);
    }
    function createClassAccessorDecoratorContextType(thisType, valueType) {
        return tryCreateTypeReference(getGlobalClassAccessorDecoratorContextType(true), [thisType, valueType]);
    }
    function createClassFieldDecoratorContextType(thisType, valueType) {
        return tryCreateTypeReference(getGlobalClassFieldDecoratorContextType(true), [thisType, valueType]);
    }
    function getClassMemberDecoratorContextOverrideType(nameType, isPrivate, isStatic2) {
        const key = `${isPrivate ? "p" : "P"}${isStatic2 ? "s" : "S"}${nameType.id}`;
        let overrideType = decoratorContextOverrideTypeCache.get(key);
        if (!overrideType) {
            const members = createSymbolTable();
            members.set("name", createProperty("name", nameType));
            members.set("private", createProperty("private", isPrivate ? trueType : falseType));
            members.set("static", createProperty("static", isStatic2 ? trueType : falseType));
            overrideType = createAnonymousType(void 0, members, emptyArray, emptyArray, emptyArray);
            decoratorContextOverrideTypeCache.set(key, overrideType);
        }
        return overrideType;
    }
    function createClassMemberDecoratorContextTypeForNode(node, thisType, valueType) {
        const isStatic2 = hasStaticModifier(node);
        const isPrivate = isPrivateIdentifier(node.name);
        const nameType = isPrivate ? getStringLiteralType(idText(node.name)) : getLiteralTypeFromPropertyName(node.name);
        const contextType = isMethodDeclaration(node) ? createClassMethodDecoratorContextType(thisType, valueType) : isGetAccessorDeclaration(node) ? createClassGetterDecoratorContextType(thisType, valueType) : isSetAccessorDeclaration(node) ? createClassSetterDecoratorContextType(thisType, valueType) : isAutoAccessorPropertyDeclaration(node) ? createClassAccessorDecoratorContextType(thisType, valueType) : isPropertyDeclaration(node) ? createClassFieldDecoratorContextType(thisType, valueType) : Debug.failBadSyntaxKind(node);
        const overrideType = getClassMemberDecoratorContextOverrideType(nameType, isPrivate, isStatic2);
        return getIntersectionType([contextType, overrideType]);
    }
    function createClassAccessorDecoratorTargetType(thisType, valueType) {
        return tryCreateTypeReference(getGlobalClassAccessorDecoratorTargetType(true), [thisType, valueType]);
    }
    function createClassAccessorDecoratorResultType(thisType, valueType) {
        return tryCreateTypeReference(getGlobalClassAccessorDecoratorResultType(true), [thisType, valueType]);
    }
    function createClassFieldDecoratorInitializerMutatorType(thisType, valueType) {
        const thisParam = createParameter("this", thisType);
        const valueParam = createParameter("value", valueType);
        return createFunctionType(void 0, thisParam, [valueParam], valueType, void 0, 1);
    }
    function createESDecoratorCallSignature(targetType, contextType, nonOptionalReturnType) {
        const targetParam = createParameter("target", targetType);
        const contextParam = createParameter("context", contextType);
        const returnType = getUnionType([nonOptionalReturnType, voidType]);
        return createCallSignature(void 0, void 0, [targetParam, contextParam], returnType);
    }
    function getESDecoratorCallSignature(decorator) {
        const {
            parent: parent2
        } = decorator;
        const links = getNodeLinks(parent2);
        if (!links.decoratorSignature) {
            links.decoratorSignature = anySignature;
            switch (parent2.kind) {
                case 260:
                case 228:
                    {
                        const node = parent2;
                        const targetType = getTypeOfSymbol(getSymbolOfDeclaration(node));
                        const contextType = createClassDecoratorContextType(targetType);
                        links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, targetType);
                        break;
                    }
                case 171:
                case 174:
                case 175:
                    {
                        const node = parent2;
                        if (!isClassLike(node.parent)) break;
                        const valueType = isMethodDeclaration(node) ? getOrCreateTypeFromSignature(getSignatureFromDeclaration(node)) : getTypeOfNode(node);
                        const thisType = hasStaticModifier(node) ? getTypeOfSymbol(getSymbolOfDeclaration(node.parent)) : getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node.parent));
                        const targetType = isGetAccessorDeclaration(node) ? createGetterFunctionType(valueType) : isSetAccessorDeclaration(node) ? createSetterFunctionType(valueType) : valueType;
                        const contextType = createClassMemberDecoratorContextTypeForNode(node, thisType, valueType);
                        const returnType = isGetAccessorDeclaration(node) ? createGetterFunctionType(valueType) : isSetAccessorDeclaration(node) ? createSetterFunctionType(valueType) : valueType;
                        links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, returnType);
                        break;
                    }
                case 169:
                    {
                        const node = parent2;
                        if (!isClassLike(node.parent)) break;
                        const valueType = getTypeOfNode(node);
                        const thisType = hasStaticModifier(node) ? getTypeOfSymbol(getSymbolOfDeclaration(node.parent)) : getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(node.parent));
                        const targetType = hasAccessorModifier(node) ? createClassAccessorDecoratorTargetType(thisType, valueType) : undefinedType;
                        const contextType = createClassMemberDecoratorContextTypeForNode(node, thisType, valueType);
                        const returnType = hasAccessorModifier(node) ? createClassAccessorDecoratorResultType(thisType, valueType) : createClassFieldDecoratorInitializerMutatorType(thisType, valueType);
                        links.decoratorSignature = createESDecoratorCallSignature(targetType, contextType, returnType);
                        break;
                    }
            }
        }
        return links.decoratorSignature === anySignature ? void 0 : links.decoratorSignature;
    }
    function getLegacyDecoratorCallSignature(decorator) {
        const {
            parent: parent2
        } = decorator;
        const links = getNodeLinks(parent2);
        if (!links.decoratorSignature) {
            links.decoratorSignature = anySignature;
            switch (parent2.kind) {
                case 260:
                case 228:
                    {
                        const node = parent2;
                        const targetType = getTypeOfSymbol(getSymbolOfDeclaration(node));
                        const targetParam = createParameter("target", targetType);
                        links.decoratorSignature = createCallSignature(void 0, void 0, [targetParam], getUnionType([targetType, voidType]));
                        break;
                    }
                case 166:
                    {
                        const node = parent2;
                        if (!isConstructorDeclaration(node.parent) && !(isMethodDeclaration(node.parent) || isSetAccessorDeclaration(node.parent) && isClassLike(node.parent.parent))) {
                            break;
                        }
                        if (getThisParameter(node.parent) === node) {
                            break;
                        }
                        const index = getThisParameter(node.parent) ? node.parent.parameters.indexOf(node) - 1 : node.parent.parameters.indexOf(node);
                        Debug.assert(index >= 0);
                        const targetType = isConstructorDeclaration(node.parent) ? getTypeOfSymbol(getSymbolOfDeclaration(node.parent.parent)) : getParentTypeOfClassElement(node.parent);
                        const keyType = isConstructorDeclaration(node.parent) ? undefinedType : getClassElementPropertyKeyType(node.parent);
                        const indexType = getNumberLiteralType(index);
                        const targetParam = createParameter("target", targetType);
                        const keyParam = createParameter("propertyKey", keyType);
                        const indexParam = createParameter("parameterIndex", indexType);
                        links.decoratorSignature = createCallSignature(void 0, void 0, [targetParam, keyParam, indexParam], voidType);
                        break;
                    }
                case 171:
                case 174:
                case 175:
                case 169:
                    {
                        const node = parent2;
                        if (!isClassLike(node.parent)) break;
                        const targetType = getParentTypeOfClassElement(node);
                        const targetParam = createParameter("target", targetType);
                        const keyType = getClassElementPropertyKeyType(node);
                        const keyParam = createParameter("propertyKey", keyType);
                        const returnType = isPropertyDeclaration(node) ? voidType : createTypedPropertyDescriptorType(getTypeOfNode(node));
                        const hasPropDesc = languageVersion !== 0 && (!isPropertyDeclaration(parent2) || hasAccessorModifier(parent2));
                        if (hasPropDesc) {
                            const descriptorType = createTypedPropertyDescriptorType(getTypeOfNode(node));
                            const descriptorParam = createParameter("descriptor", descriptorType);
                            links.decoratorSignature = createCallSignature(void 0, void 0, [targetParam, keyParam, descriptorParam], getUnionType([returnType, voidType]));
                        } else {
                            links.decoratorSignature = createCallSignature(void 0, void 0, [targetParam, keyParam], getUnionType([returnType, voidType]));
                        }
                        break;
                    }
            }
        }
        return links.decoratorSignature === anySignature ? void 0 : links.decoratorSignature;
    }
    function getDecoratorCallSignature(decorator) {
        return legacyDecorators ? getLegacyDecoratorCallSignature(decorator) : getESDecoratorCallSignature(decorator);
    }
    function createPromiseType(promisedType) {
        const globalPromiseType = getGlobalPromiseType(true);
        if (globalPromiseType !== emptyGenericType) {
            promisedType = getAwaitedTypeNoAlias(unwrapAwaitedType(promisedType)) || unknownType;
            return createTypeReference(globalPromiseType, [promisedType]);
        }
        return unknownType;
    }
    function createPromiseLikeType(promisedType) {
        const globalPromiseLikeType = getGlobalPromiseLikeType(true);
        if (globalPromiseLikeType !== emptyGenericType) {
            promisedType = getAwaitedTypeNoAlias(unwrapAwaitedType(promisedType)) || unknownType;
            return createTypeReference(globalPromiseLikeType, [promisedType]);
        }
        return unknownType;
    }
    function createPromiseReturnType(func, promisedType) {
        const promiseType = createPromiseType(promisedType);
        if (promiseType === unknownType) {
            error(func, isImportCall(func) ? Diagnostics.A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option : Diagnostics.An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option);
            return errorType;
        } else if (!getGlobalPromiseConstructorSymbol(true)) {
            error(func, isImportCall(func) ? Diagnostics.A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option : Diagnostics.An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option);
        }
        return promiseType;
    }
    function createNewTargetExpressionType(targetType) {
        const symbol = createSymbol(0, "NewTargetExpression");
        const targetPropertySymbol = createSymbol(4, "target", 8);
        targetPropertySymbol.parent = symbol;
        targetPropertySymbol.links.type = targetType;
        const members = createSymbolTable([targetPropertySymbol]);
        symbol.members = members;
        return createAnonymousType(symbol, members, emptyArray, emptyArray, emptyArray);
    }
    function getReturnTypeFromBody(func, checkMode) {
        if (!func.body) {
            return errorType;
        }
        const functionFlags = getFunctionFlags(func);
        const isAsync = (functionFlags & 2) !== 0;
        const isGenerator = (functionFlags & 1) !== 0;
        let returnType;
        let yieldType;
        let nextType;
        let fallbackReturnType = voidType;
        if (func.body.kind !== 238) {
            returnType = checkExpressionCached(func.body, checkMode && checkMode & ~8);
            if (isAsync) {
                returnType = unwrapAwaitedType(checkAwaitedType(returnType, false, func, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member));
            }
        } else if (isGenerator) {
            const returnTypes = checkAndAggregateReturnExpressionTypes(func, checkMode);
            if (!returnTypes) {
                fallbackReturnType = neverType;
            } else if (returnTypes.length > 0) {
                returnType = getUnionType(returnTypes, 2);
            }
            const {
                yieldTypes,
                nextTypes
            } = checkAndAggregateYieldOperandTypes(func, checkMode);
            yieldType = some(yieldTypes) ? getUnionType(yieldTypes, 2) : void 0;
            nextType = some(nextTypes) ? getIntersectionType(nextTypes) : void 0;
        } else {
            const types = checkAndAggregateReturnExpressionTypes(func, checkMode);
            if (!types) {
                return functionFlags & 2 ? createPromiseReturnType(func, neverType) : neverType;
            }
            if (types.length === 0) {
                return functionFlags & 2 ? createPromiseReturnType(func, voidType) : voidType;
            }
            returnType = getUnionType(types, 2);
        }
        if (returnType || yieldType || nextType) {
            if (yieldType) reportErrorsFromWidening(func, yieldType, 3);
            if (returnType) reportErrorsFromWidening(func, returnType, 1);
            if (nextType) reportErrorsFromWidening(func, nextType, 2);
            if (returnType && isUnitType(returnType) || yieldType && isUnitType(yieldType) || nextType && isUnitType(nextType)) {
                const contextualSignature = getContextualSignatureForFunctionLikeDeclaration(func);
                const contextualType = !contextualSignature ? void 0 : contextualSignature === getSignatureFromDeclaration(func) ? isGenerator ? void 0 : returnType : instantiateContextualType(getReturnTypeOfSignature(contextualSignature), func, void 0);
                if (isGenerator) {
                    yieldType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(yieldType, contextualType, 0, isAsync);
                    returnType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(returnType, contextualType, 1, isAsync);
                    nextType = getWidenedLiteralLikeTypeForContextualIterationTypeIfNeeded(nextType, contextualType, 2, isAsync);
                } else {
                    returnType = getWidenedLiteralLikeTypeForContextualReturnTypeIfNeeded(returnType, contextualType, isAsync);
                }
            }
            if (yieldType) yieldType = getWidenedType(yieldType);
            if (returnType) returnType = getWidenedType(returnType);
            if (nextType) nextType = getWidenedType(nextType);
        }
        if (isGenerator) {
            return createGeneratorReturnType(yieldType || neverType, returnType || fallbackReturnType, nextType || getContextualIterationType(2, func) || unknownType, isAsync);
        } else {
            return isAsync ? createPromiseType(returnType || fallbackReturnType) : returnType || fallbackReturnType;
        }
    }
    function createGeneratorReturnType(yieldType, returnType, nextType, isAsyncGenerator) {
        const resolver = isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver;
        const globalGeneratorType = resolver.getGlobalGeneratorType(false);
        yieldType = resolver.resolveIterationType(yieldType, void 0) || unknownType;
        returnType = resolver.resolveIterationType(returnType, void 0) || unknownType;
        nextType = resolver.resolveIterationType(nextType, void 0) || unknownType;
        if (globalGeneratorType === emptyGenericType) {
            const globalType = resolver.getGlobalIterableIteratorType(false);
            const iterationTypes = globalType !== emptyGenericType ? getIterationTypesOfGlobalIterableType(globalType, resolver) : void 0;
            const iterableIteratorReturnType = iterationTypes ? iterationTypes.returnType : anyType;
            const iterableIteratorNextType = iterationTypes ? iterationTypes.nextType : undefinedType;
            if (isTypeAssignableTo(returnType, iterableIteratorReturnType) && isTypeAssignableTo(iterableIteratorNextType, nextType)) {
                if (globalType !== emptyGenericType) {
                    return createTypeFromGenericGlobalType(globalType, [yieldType]);
                }
                resolver.getGlobalIterableIteratorType(true);
                return emptyObjectType;
            }
            resolver.getGlobalGeneratorType(true);
            return emptyObjectType;
        }
        return createTypeFromGenericGlobalType(globalGeneratorType, [yieldType, returnType, nextType]);
    }
    function checkAndAggregateYieldOperandTypes(func, checkMode) {
        const yieldTypes = [];
        const nextTypes = [];
        const isAsync = (getFunctionFlags(func) & 2) !== 0;
        forEachYieldExpression(func.body, yieldExpression => {
            const yieldExpressionType = yieldExpression.expression ? checkExpression(yieldExpression.expression, checkMode) : undefinedWideningType;
            pushIfUnique(yieldTypes, getYieldedTypeOfYieldExpression(yieldExpression, yieldExpressionType, anyType, isAsync));
            let nextType;
            if (yieldExpression.asteriskToken) {
                const iterationTypes = getIterationTypesOfIterable(yieldExpressionType, isAsync ? 19 : 17, yieldExpression.expression);
                nextType = iterationTypes && iterationTypes.nextType;
            } else {
                nextType = getContextualType2(yieldExpression, void 0);
            }
            if (nextType) pushIfUnique(nextTypes, nextType);
        });
        return {
            yieldTypes,
            nextTypes
        };
    }
    function getYieldedTypeOfYieldExpression(node, expressionType, sentType, isAsync) {
        const errorNode = node.expression || node;
        const yieldedType = node.asteriskToken ? checkIteratedTypeOrElementType(isAsync ? 19 : 17, expressionType, sentType, errorNode) : expressionType;
        return !isAsync ? yieldedType : getAwaitedType(yieldedType, errorNode, node.asteriskToken ? Diagnostics.Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member : Diagnostics.Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
    }
    function getNotEqualFactsFromTypeofSwitch(start, end, witnesses) {
        let facts = 0;
        for (let i = 0; i < witnesses.length; i++) {
            const witness = i < start || i >= end ? witnesses[i] : void 0;
            facts |= witness !== void 0 ? typeofNEFacts.get(witness) || 32768 : 0;
        }
        return facts;
    }
    function isExhaustiveSwitchStatement(node) {
        const links = getNodeLinks(node);
        if (links.isExhaustive === void 0) {
            links.isExhaustive = 0;
            const exhaustive = computeExhaustiveSwitchStatement(node);
            if (links.isExhaustive === 0) {
                links.isExhaustive = exhaustive;
            }
        } else if (links.isExhaustive === 0) {
            links.isExhaustive = false;
        }
        return links.isExhaustive;
    }
    function computeExhaustiveSwitchStatement(node) {
        if (node.expression.kind === 218) {
            const witnesses = getSwitchClauseTypeOfWitnesses(node);
            if (!witnesses) {
                return false;
            }
            const operandConstraint = getBaseConstraintOrType(checkExpressionCached(node.expression.expression));
            const notEqualFacts = getNotEqualFactsFromTypeofSwitch(0, 0, witnesses);
            if (operandConstraint.flags & 3) {
                return (556800 & notEqualFacts) === 556800;
            }
            return !someType(operandConstraint, t => (getTypeFacts(t) & notEqualFacts) === notEqualFacts);
        }
        const type = checkExpressionCached(node.expression);
        if (!isLiteralType(type)) {
            return false;
        }
        const switchTypes = getSwitchClauseTypes(node);
        if (!switchTypes.length || some(switchTypes, isNeitherUnitTypeNorNever)) {
            return false;
        }
        return eachTypeContainedIn(mapType(type, getRegularTypeOfLiteralType), switchTypes);
    }
    function functionHasImplicitReturn(func) {
        return func.endFlowNode && isReachableFlowNode(func.endFlowNode);
    }
    function checkAndAggregateReturnExpressionTypes(func, checkMode) {
        const functionFlags = getFunctionFlags(func);
        const aggregatedTypes = [];
        let hasReturnWithNoExpression = functionHasImplicitReturn(func);
        let hasReturnOfTypeNever = false;
        forEachReturnStatement(func.body, returnStatement => {
            const expr = returnStatement.expression;
            if (expr) {
                let type = checkExpressionCached(expr, checkMode && checkMode & ~8);
                if (functionFlags & 2) {
                    type = unwrapAwaitedType(checkAwaitedType(type, false, func, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member));
                }
                if (type.flags & 131072) {
                    hasReturnOfTypeNever = true;
                }
                pushIfUnique(aggregatedTypes, type);
            } else {
                hasReturnWithNoExpression = true;
            }
        });
        if (aggregatedTypes.length === 0 && !hasReturnWithNoExpression && (hasReturnOfTypeNever || mayReturnNever(func))) {
            return void 0;
        }
        if (strictNullChecks && aggregatedTypes.length && hasReturnWithNoExpression && !(isJSConstructor(func) && aggregatedTypes.some(t => t.symbol === func.symbol))) {
            pushIfUnique(aggregatedTypes, undefinedType);
        }
        return aggregatedTypes;
    }
    function mayReturnNever(func) {
        switch (func.kind) {
            case 215:
            case 216:
                return true;
            case 171:
                return func.parent.kind === 207;
            default:
                return false;
        }
    }
    function checkAllCodePathsInNonVoidFunctionReturnOrThrow(func, returnType) {
        addLazyDiagnostic(checkAllCodePathsInNonVoidFunctionReturnOrThrowDiagnostics);
        return;
        function checkAllCodePathsInNonVoidFunctionReturnOrThrowDiagnostics() {
            const functionFlags = getFunctionFlags(func);
            const type = returnType && unwrapReturnType(returnType, functionFlags);
            if (type && maybeTypeOfKind(type, 1 | 16384)) {
                return;
            }
            if (func.kind === 170 || nodeIsMissing(func.body) || func.body.kind !== 238 || !functionHasImplicitReturn(func)) {
                return;
            }
            const hasExplicitReturn = func.flags & 512;
            const errorNode = getEffectiveReturnTypeNode(func) || func;
            if (type && type.flags & 131072) {
                error(errorNode, Diagnostics.A_function_returning_never_cannot_have_a_reachable_end_point);
            } else if (type && !hasExplicitReturn) {
                error(errorNode, Diagnostics.A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value);
            } else if (type && strictNullChecks && !isTypeAssignableTo(undefinedType, type)) {
                error(errorNode, Diagnostics.Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined);
            } else if (compilerOptions.noImplicitReturns) {
                if (!type) {
                    if (!hasExplicitReturn) {
                        return;
                    }
                    const inferredReturnType = getReturnTypeOfSignature(getSignatureFromDeclaration(func));
                    if (isUnwrappedReturnTypeVoidOrAny(func, inferredReturnType)) {
                        return;
                    }
                }
                error(errorNode, Diagnostics.Not_all_code_paths_return_a_value);
            }
        }
    }
    function checkFunctionExpressionOrObjectLiteralMethod(node, checkMode) {
        Debug.assert(node.kind !== 171 || isObjectLiteralMethod(node));
        checkNodeDeferred(node);
        if (isFunctionExpression(node)) {
            checkCollisionsForDeclarationName(node, node.name);
        }
        if (checkMode && checkMode & 4 && isContextSensitive(node)) {
            if (!getEffectiveReturnTypeNode(node) && !hasContextSensitiveParameters(node)) {
                const contextualSignature = getContextualSignature(node);
                if (contextualSignature && couldContainTypeVariables(getReturnTypeOfSignature(contextualSignature))) {
                    const links = getNodeLinks(node);
                    if (links.contextFreeType) {
                        return links.contextFreeType;
                    }
                    const returnType = getReturnTypeFromBody(node, checkMode);
                    const returnOnlySignature = createSignature(void 0, void 0, void 0, emptyArray, returnType, void 0, 0, 0);
                    const returnOnlyType = createAnonymousType(node.symbol, emptySymbols, [returnOnlySignature], emptyArray, emptyArray);
                    returnOnlyType.objectFlags |= 262144;
                    return links.contextFreeType = returnOnlyType;
                }
            }
            return anyFunctionType;
        }
        const hasGrammarError = checkGrammarFunctionLikeDeclaration(node);
        if (!hasGrammarError && node.kind === 215) {
            checkGrammarForGenerator(node);
        }
        contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node, checkMode);
        return getTypeOfSymbol(getSymbolOfDeclaration(node));
    }
    function contextuallyCheckFunctionExpressionOrObjectLiteralMethod(node, checkMode) {
        const links = getNodeLinks(node);
        if (!(links.flags & 64)) {
            const contextualSignature = getContextualSignature(node);
            if (!(links.flags & 64)) {
                links.flags |= 64;
                const signature = firstOrUndefined(getSignaturesOfType(getTypeOfSymbol(getSymbolOfDeclaration(node)), 0));
                if (!signature) {
                    return;
                }
                if (isContextSensitive(node)) {
                    if (contextualSignature) {
                        const inferenceContext = getInferenceContext(node);
                        let instantiatedContextualSignature;
                        if (checkMode && checkMode & 2) {
                            inferFromAnnotatedParameters(signature, contextualSignature, inferenceContext);
                            const restType = getEffectiveRestType(contextualSignature);
                            if (restType && restType.flags & 262144) {
                                instantiatedContextualSignature = instantiateSignature(contextualSignature, inferenceContext.nonFixingMapper);
                            }
                        }
                        instantiatedContextualSignature || (instantiatedContextualSignature = inferenceContext ? instantiateSignature(contextualSignature, inferenceContext.mapper) : contextualSignature);
                        assignContextualParameterTypes(signature, instantiatedContextualSignature);
                    } else {
                        assignNonContextualParameterTypes(signature);
                    }
                }
                if (contextualSignature && !getReturnTypeFromAnnotation(node) && !signature.resolvedReturnType) {
                    const returnType = getReturnTypeFromBody(node, checkMode);
                    if (!signature.resolvedReturnType) {
                        signature.resolvedReturnType = returnType;
                    }
                }
                checkSignatureDeclaration(node);
            }
        }
    }
    function checkFunctionExpressionOrObjectLiteralMethodDeferred(node) {
        Debug.assert(node.kind !== 171 || isObjectLiteralMethod(node));
        const functionFlags = getFunctionFlags(node);
        const returnType = getReturnTypeFromAnnotation(node);
        checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType);
        if (node.body) {
            if (!getEffectiveReturnTypeNode(node)) {
                getReturnTypeOfSignature(getSignatureFromDeclaration(node));
            }
            if (node.body.kind === 238) {
                checkSourceElement(node.body);
            } else {
                const exprType = checkExpression(node.body);
                const returnOrPromisedType = returnType && unwrapReturnType(returnType, functionFlags);
                if (returnOrPromisedType) {
                    if ((functionFlags & 3) === 2) {
                        const awaitedType = checkAwaitedType(exprType, false, node.body, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
                        checkTypeAssignableToAndOptionallyElaborate(awaitedType, returnOrPromisedType, node.body, node.body);
                    } else {
                        checkTypeAssignableToAndOptionallyElaborate(exprType, returnOrPromisedType, node.body, node.body);
                    }
                }
            }
        }
    }
    function checkArithmeticOperandType(operand, type, diagnostic, isAwaitValid = false) {
        if (!isTypeAssignableTo(type, numberOrBigIntType)) {
            const awaitedType = isAwaitValid && getAwaitedTypeOfPromise(type);
            errorAndMaybeSuggestAwait(operand, !!awaitedType && isTypeAssignableTo(awaitedType, numberOrBigIntType), diagnostic);
            return false;
        }
        return true;
    }
    function isReadonlyAssignmentDeclaration(d) {
        if (!isCallExpression(d)) {
            return false;
        }
        if (!isBindableObjectDefinePropertyCall(d)) {
            return false;
        }
        const objectLitType = checkExpressionCached(d.arguments[2]);
        const valueType = getTypeOfPropertyOfType(objectLitType, "value");
        if (valueType) {
            const writableProp = getPropertyOfType(objectLitType, "writable");
            const writableType = writableProp && getTypeOfSymbol(writableProp);
            if (!writableType || writableType === falseType || writableType === regularFalseType) {
                return true;
            }
            if (writableProp && writableProp.valueDeclaration && isPropertyAssignment(writableProp.valueDeclaration)) {
                const initializer = writableProp.valueDeclaration.initializer;
                const rawOriginalType = checkExpression(initializer);
                if (rawOriginalType === falseType || rawOriginalType === regularFalseType) {
                    return true;
                }
            }
            return false;
        }
        const setProp = getPropertyOfType(objectLitType, "set");
        return !setProp;
    }
    function isReadonlySymbol(symbol) {
        return !!(getCheckFlags(symbol) & 8 || symbol.flags & 4 && getDeclarationModifierFlagsFromSymbol(symbol) & 64 || symbol.flags & 3 && getDeclarationNodeFlagsFromSymbol(symbol) & 2 || symbol.flags & 98304 && !(symbol.flags & 65536) || symbol.flags & 8 || some(symbol.declarations, isReadonlyAssignmentDeclaration));
    }
    function isAssignmentToReadonlyEntity(expr, symbol, assignmentKind) {
        var _a2, _b;
        if (assignmentKind === 0) {
            return false;
        }
        if (isReadonlySymbol(symbol)) {
            if (symbol.flags & 4 && isAccessExpression(expr) && expr.expression.kind === 108) {
                const ctor = getContainingFunction(expr);
                if (!(ctor && (ctor.kind === 173 || isJSConstructor(ctor)))) {
                    return true;
                }
                if (symbol.valueDeclaration) {
                    const isAssignmentDeclaration2 = isBinaryExpression(symbol.valueDeclaration);
                    const isLocalPropertyDeclaration = ctor.parent === symbol.valueDeclaration.parent;
                    const isLocalParameterProperty = ctor === symbol.valueDeclaration.parent;
                    const isLocalThisPropertyAssignment = isAssignmentDeclaration2 && ((_a2 = symbol.parent) == null ? void 0 : _a2.valueDeclaration) === ctor.parent;
                    const isLocalThisPropertyAssignmentConstructorFunction = isAssignmentDeclaration2 && ((_b = symbol.parent) == null ? void 0 : _b.valueDeclaration) === ctor;
                    const isWriteableSymbol = isLocalPropertyDeclaration || isLocalParameterProperty || isLocalThisPropertyAssignment || isLocalThisPropertyAssignmentConstructorFunction;
                    return !isWriteableSymbol;
                }
            }
            return true;
        }
        if (isAccessExpression(expr)) {
            const node = skipParentheses(expr.expression);
            if (node.kind === 79) {
                const symbol2 = getNodeLinks(node).resolvedSymbol;
                if (symbol2.flags & 2097152) {
                    const declaration = getDeclarationOfAliasSymbol(symbol2);
                    return !!declaration && declaration.kind === 271;
                }
            }
        }
        return false;
    }
    function checkReferenceExpression(expr, invalidReferenceMessage, invalidOptionalChainMessage) {
        const node = skipOuterExpressions(expr, 6 | 1);
        if (node.kind !== 79 && !isAccessExpression(node)) {
            error(expr, invalidReferenceMessage);
            return false;
        }
        if (node.flags & 32) {
            error(expr, invalidOptionalChainMessage);
            return false;
        }
        return true;
    }
    function checkDeleteExpression(node) {
        checkExpression(node.expression);
        const expr = skipParentheses(node.expression);
        if (!isAccessExpression(expr)) {
            error(expr, Diagnostics.The_operand_of_a_delete_operator_must_be_a_property_reference);
            return booleanType;
        }
        if (isPropertyAccessExpression(expr) && isPrivateIdentifier(expr.name)) {
            error(expr, Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_private_identifier);
        }
        const links = getNodeLinks(expr);
        const symbol = getExportSymbolOfValueSymbolIfExported(links.resolvedSymbol);
        if (symbol) {
            if (isReadonlySymbol(symbol)) {
                error(expr, Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_read_only_property);
            }
            checkDeleteExpressionMustBeOptional(expr, symbol);
        }
        return booleanType;
    }
    function checkDeleteExpressionMustBeOptional(expr, symbol) {
        const type = getTypeOfSymbol(symbol);
        if (strictNullChecks && !(type.flags & (3 | 131072)) && !(exactOptionalPropertyTypes ? symbol.flags & 16777216 : getTypeFacts(type) & 16777216)) {
            error(expr, Diagnostics.The_operand_of_a_delete_operator_must_be_optional);
        }
    }
    function checkTypeOfExpression(node) {
        checkExpression(node.expression);
        return typeofType;
    }
    function checkVoidExpression(node) {
        checkExpression(node.expression);
        return undefinedWideningType;
    }
    function checkAwaitExpressionGrammar(node) {
        const container = getContainingFunctionOrClassStaticBlock(node);
        if (container && isClassStaticBlockDeclaration(container)) {
            error(node, Diagnostics.Await_expression_cannot_be_used_inside_a_class_static_block);
        } else if (!(node.flags & 32768)) {
            if (isInTopLevelContext(node)) {
                const sourceFile = getSourceFileOfNode(node);
                if (!hasParseDiagnostics(sourceFile)) {
                    let span;
                    if (!isEffectiveExternalModule(sourceFile, compilerOptions)) {
                        span != null ? span : span = getSpanOfTokenAtPosition(sourceFile, node.pos);
                        const diagnostic = createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module);
                        diagnostics.add(diagnostic);
                    }
                    switch (moduleKind) {
                        case 100:
                        case 199:
                            if (sourceFile.impliedNodeFormat === 1) {
                                span != null ? span : span = getSpanOfTokenAtPosition(sourceFile, node.pos);
                                diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level));
                                break;
                            }
                        case 7:
                        case 99:
                        case 4:
                            if (languageVersion >= 4) {
                                break;
                            }
                        default:
                            span != null ? span : span = getSpanOfTokenAtPosition(sourceFile, node.pos);
                            diagnostics.add(createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_or_nodenext_and_the_target_option_is_set_to_es2017_or_higher));
                            break;
                    }
                }
            } else {
                const sourceFile = getSourceFileOfNode(node);
                if (!hasParseDiagnostics(sourceFile)) {
                    const span = getSpanOfTokenAtPosition(sourceFile, node.pos);
                    const diagnostic = createFileDiagnostic(sourceFile, span.start, span.length, Diagnostics.await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules);
                    if (container && container.kind !== 173 && (getFunctionFlags(container) & 2) === 0) {
                        const relatedInfo = createDiagnosticForNode(container, Diagnostics.Did_you_mean_to_mark_this_function_as_async);
                        addRelatedInfo(diagnostic, relatedInfo);
                    }
                    diagnostics.add(diagnostic);
                }
            }
        }
        if (isInParameterInitializerBeforeContainingFunction(node)) {
            error(node, Diagnostics.await_expressions_cannot_be_used_in_a_parameter_initializer);
        }
    }
    function checkAwaitExpression(node) {
        addLazyDiagnostic(() => checkAwaitExpressionGrammar(node));
        const operandType = checkExpression(node.expression);
        const awaitedType = checkAwaitedType(operandType, true, node, Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
        if (awaitedType === operandType && !isErrorType(awaitedType) && !(operandType.flags & 3)) {
            addErrorOrSuggestion(false, createDiagnosticForNode(node, Diagnostics.await_has_no_effect_on_the_type_of_this_expression));
        }
        return awaitedType;
    }
    function checkPrefixUnaryExpression(node) {
        const operandType = checkExpression(node.operand);
        if (operandType === silentNeverType) {
            return silentNeverType;
        }
        switch (node.operand.kind) {
            case 8:
                switch (node.operator) {
                    case 40:
                        return getFreshTypeOfLiteralType(getNumberLiteralType(-node.operand.text));
                    case 39:
                        return getFreshTypeOfLiteralType(getNumberLiteralType(+node.operand.text));
                }
                break;
            case 9:
                if (node.operator === 40) {
                    return getFreshTypeOfLiteralType(getBigIntLiteralType({
                        negative: true,
                        base10Value: parsePseudoBigInt(node.operand.text)
                    }));
                }
        }
        switch (node.operator) {
            case 39:
            case 40:
            case 54:
                checkNonNullType(operandType, node.operand);
                if (maybeTypeOfKindConsideringBaseConstraint(operandType, 12288)) {
                    error(node.operand, Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, tokenToString(node.operator));
                }
                if (node.operator === 39) {
                    if (maybeTypeOfKindConsideringBaseConstraint(operandType, 2112)) {
                        error(node.operand, Diagnostics.Operator_0_cannot_be_applied_to_type_1, tokenToString(node.operator), typeToString(getBaseTypeOfLiteralType(operandType)));
                    }
                    return numberType;
                }
                return getUnaryResultType(operandType);
            case 53:
                checkTruthinessExpression(node.operand);
                const facts = getTypeFacts(operandType) & (4194304 | 8388608);
                return facts === 4194304 ? falseType : facts === 8388608 ? trueType : booleanType;
            case 45:
            case 46:
                const ok = checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type);
                if (ok) {
                    checkReferenceExpression(node.operand, Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access, Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access);
                }
                return getUnaryResultType(operandType);
        }
        return errorType;
    }
    function checkPostfixUnaryExpression(node) {
        const operandType = checkExpression(node.operand);
        if (operandType === silentNeverType) {
            return silentNeverType;
        }
        const ok = checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type);
        if (ok) {
            checkReferenceExpression(node.operand, Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access, Diagnostics.The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access);
        }
        return getUnaryResultType(operandType);
    }
    function getUnaryResultType(operandType) {
        if (maybeTypeOfKind(operandType, 2112)) {
            return isTypeAssignableToKind(operandType, 3) || maybeTypeOfKind(operandType, 296) ? numberOrBigIntType : bigintType;
        }
        return numberType;
    }
    function maybeTypeOfKindConsideringBaseConstraint(type, kind) {
        if (maybeTypeOfKind(type, kind)) {
            return true;
        }
        const baseConstraint = getBaseConstraintOrType(type);
        return !!baseConstraint && maybeTypeOfKind(baseConstraint, kind);
    }
    function maybeTypeOfKind(type, kind) {
        if (type.flags & kind) {
            return true;
        }
        if (type.flags & 3145728) {
            const types = type.types;
            for (const t of types) {
                if (maybeTypeOfKind(t, kind)) {
                    return true;
                }
            }
        }
        return false;
    }
    function isTypeAssignableToKind(source, kind, strict) {
        if (source.flags & kind) {
            return true;
        }
        if (strict && source.flags & (3 | 16384 | 32768 | 65536)) {
            return false;
        }
        return !!(kind & 296) && isTypeAssignableTo(source, numberType) || !!(kind & 2112) && isTypeAssignableTo(source, bigintType) || !!(kind & 402653316) && isTypeAssignableTo(source, stringType) || !!(kind & 528) && isTypeAssignableTo(source, booleanType) || !!(kind & 16384) && isTypeAssignableTo(source, voidType) || !!(kind & 131072) && isTypeAssignableTo(source, neverType) || !!(kind & 65536) && isTypeAssignableTo(source, nullType) || !!(kind & 32768) && isTypeAssignableTo(source, undefinedType) || !!(kind & 4096) && isTypeAssignableTo(source, esSymbolType) || !!(kind & 67108864) && isTypeAssignableTo(source, nonPrimitiveType);
    }
    function allTypesAssignableToKind(source, kind, strict) {
        return source.flags & 1048576 ? every(source.types, subType => allTypesAssignableToKind(subType, kind, strict)) : isTypeAssignableToKind(source, kind, strict);
    }
    function isConstEnumObjectType(type) {
        return !!(getObjectFlags(type) & 16) && !!type.symbol && isConstEnumSymbol(type.symbol);
    }
    function isConstEnumSymbol(symbol) {
        return (symbol.flags & 128) !== 0;
    }
    function checkInstanceOfExpression(left, right, leftType, rightType) {
        if (leftType === silentNeverType || rightType === silentNeverType) {
            return silentNeverType;
        }
        if (!isTypeAny(leftType) && allTypesAssignableToKind(leftType, 134348796)) {
            error(left, Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);
        }
        if (!(isTypeAny(rightType) || typeHasCallOrConstructSignatures(rightType) || isTypeSubtypeOf(rightType, globalFunctionType))) {
            error(right, Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type);
        }
        return booleanType;
    }
    function hasEmptyObjectIntersection(type) {
        return someType(type, t => t === unknownEmptyObjectType || !!(t.flags & 2097152) && isEmptyAnonymousObjectType(getBaseConstraintOrType(t)));
    }
    function checkInExpression(left, right, leftType, rightType) {
        if (leftType === silentNeverType || rightType === silentNeverType) {
            return silentNeverType;
        }
        if (isPrivateIdentifier(left)) {
            if (languageVersion < 99) {
                checkExternalEmitHelpers(left, 2097152);
            }
            if (!getNodeLinks(left).resolvedSymbol && getContainingClass(left)) {
                const isUncheckedJS = isUncheckedJSSuggestion(left, rightType.symbol, true);
                reportNonexistentProperty(left, rightType, isUncheckedJS);
            }
        } else {
            checkTypeAssignableTo(checkNonNullType(leftType, left), stringNumberSymbolType, left);
        }
        if (checkTypeAssignableTo(checkNonNullType(rightType, right), nonPrimitiveType, right)) {
            if (hasEmptyObjectIntersection(rightType)) {
                error(right, Diagnostics.Type_0_may_represent_a_primitive_value_which_is_not_permitted_as_the_right_operand_of_the_in_operator, typeToString(rightType));
            }
        }
        return booleanType;
    }
    function checkObjectLiteralAssignment(node, sourceType, rightIsThis) {
        const properties = node.properties;
        if (strictNullChecks && properties.length === 0) {
            return checkNonNullType(sourceType, node);
        }
        for (let i = 0; i < properties.length; i++) {
            checkObjectLiteralDestructuringPropertyAssignment(node, sourceType, i, properties, rightIsThis);
        }
        return sourceType;
    }
    function checkObjectLiteralDestructuringPropertyAssignment(node, objectLiteralType, propertyIndex, allProperties, rightIsThis = false) {
        const properties = node.properties;
        const property = properties[propertyIndex];
        if (property.kind === 299 || property.kind === 300) {
            const name = property.name;
            const exprType = getLiteralTypeFromPropertyName(name);
            if (isTypeUsableAsPropertyName(exprType)) {
                const text = getPropertyNameFromType(exprType);
                const prop = getPropertyOfType(objectLiteralType, text);
                if (prop) {
                    markPropertyAsReferenced(prop, property, rightIsThis);
                    checkPropertyAccessibility(property, false, true, objectLiteralType, prop);
                }
            }
            const elementType = getIndexedAccessType(objectLiteralType, exprType, 32, name);
            const type = getFlowTypeOfDestructuring(property, elementType);
            return checkDestructuringAssignment(property.kind === 300 ? property : property.initializer, type);
        } else if (property.kind === 301) {
            if (propertyIndex < properties.length - 1) {
                error(property, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern);
            } else {
                if (languageVersion < 99) {
                    checkExternalEmitHelpers(property, 4);
                }
                const nonRestNames = [];
                if (allProperties) {
                    for (const otherProperty of allProperties) {
                        if (!isSpreadAssignment(otherProperty)) {
                            nonRestNames.push(otherProperty.name);
                        }
                    }
                }
                const type = getRestType(objectLiteralType, nonRestNames, objectLiteralType.symbol);
                checkGrammarForDisallowedTrailingComma(allProperties, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);
                return checkDestructuringAssignment(property.expression, type);
            }
        } else {
            error(property, Diagnostics.Property_assignment_expected);
        }
    }
    function checkArrayLiteralAssignment(node, sourceType, checkMode) {
        const elements = node.elements;
        if (languageVersion < 2 && compilerOptions.downlevelIteration) {
            checkExternalEmitHelpers(node, 512);
        }
        const possiblyOutOfBoundsType = checkIteratedTypeOrElementType(65 | 128, sourceType, undefinedType, node) || errorType;
        let inBoundsType = compilerOptions.noUncheckedIndexedAccess ? void 0 : possiblyOutOfBoundsType;
        for (let i = 0; i < elements.length; i++) {
            let type = possiblyOutOfBoundsType;
            if (node.elements[i].kind === 227) {
                type = inBoundsType = inBoundsType != null ? inBoundsType : checkIteratedTypeOrElementType(65, sourceType, undefinedType, node) || errorType;
            }
            checkArrayLiteralDestructuringElementAssignment(node, sourceType, i, type, checkMode);
        }
        return sourceType;
    }
    function checkArrayLiteralDestructuringElementAssignment(node, sourceType, elementIndex, elementType, checkMode) {
        const elements = node.elements;
        const element = elements[elementIndex];
        if (element.kind !== 229) {
            if (element.kind !== 227) {
                const indexType = getNumberLiteralType(elementIndex);
                if (isArrayLikeType(sourceType)) {
                    const accessFlags = 32 | (hasDefaultValue(element) ? 16 : 0);
                    const elementType2 = getIndexedAccessTypeOrUndefined(sourceType, indexType, accessFlags, createSyntheticExpression(element, indexType)) || errorType;
                    const assignedType = hasDefaultValue(element) ? getTypeWithFacts(elementType2, 524288) : elementType2;
                    const type = getFlowTypeOfDestructuring(element, assignedType);
                    return checkDestructuringAssignment(element, type, checkMode);
                }
                return checkDestructuringAssignment(element, elementType, checkMode);
            }
            if (elementIndex < elements.length - 1) {
                error(element, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern);
            } else {
                const restExpression = element.expression;
                if (restExpression.kind === 223 && restExpression.operatorToken.kind === 63) {
                    error(restExpression.operatorToken, Diagnostics.A_rest_element_cannot_have_an_initializer);
                } else {
                    checkGrammarForDisallowedTrailingComma(node.elements, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);
                    const type = everyType(sourceType, isTupleType) ? mapType(sourceType, t => sliceTupleType(t, elementIndex)) : createArrayType(elementType);
                    return checkDestructuringAssignment(restExpression, type, checkMode);
                }
            }
        }
        return void 0;
    }
    function checkDestructuringAssignment(exprOrAssignment, sourceType, checkMode, rightIsThis) {
        let target;
        if (exprOrAssignment.kind === 300) {
            const prop = exprOrAssignment;
            if (prop.objectAssignmentInitializer) {
                if (strictNullChecks && !(getTypeFacts(checkExpression(prop.objectAssignmentInitializer)) & 16777216)) {
                    sourceType = getTypeWithFacts(sourceType, 524288);
                }
                checkBinaryLikeExpression(prop.name, prop.equalsToken, prop.objectAssignmentInitializer, checkMode);
            }
            target = exprOrAssignment.name;
        } else {
            target = exprOrAssignment;
        }
        if (target.kind === 223 && target.operatorToken.kind === 63) {
            checkBinaryExpression(target, checkMode);
            target = target.left;
            if (strictNullChecks) {
                sourceType = getTypeWithFacts(sourceType, 524288);
            }
        }
        if (target.kind === 207) {
            return checkObjectLiteralAssignment(target, sourceType, rightIsThis);
        }
        if (target.kind === 206) {
            return checkArrayLiteralAssignment(target, sourceType, checkMode);
        }
        return checkReferenceAssignment(target, sourceType, checkMode);
    }
    function checkReferenceAssignment(target, sourceType, checkMode) {
        const targetType = checkExpression(target, checkMode);
        const error2 = target.parent.kind === 301 ? Diagnostics.The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access : Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access;
        const optionalError = target.parent.kind === 301 ? Diagnostics.The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access : Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access;
        if (checkReferenceExpression(target, error2, optionalError)) {
            checkTypeAssignableToAndOptionallyElaborate(sourceType, targetType, target, target);
        }
        if (isPrivateIdentifierPropertyAccessExpression(target)) {
            checkExternalEmitHelpers(target.parent, 1048576);
        }
        return sourceType;
    }
    function isSideEffectFree(node) {
        node = skipParentheses(node);
        switch (node.kind) {
            case 79:
            case 10:
            case 13:
            case 212:
            case 225:
            case 14:
            case 8:
            case 9:
            case 110:
            case 95:
            case 104:
            case 155:
            case 215:
            case 228:
            case 216:
            case 206:
            case 207:
            case 218:
            case 232:
            case 282:
            case 281:
                return true;
            case 224:
                return isSideEffectFree(node.whenTrue) && isSideEffectFree(node.whenFalse);
            case 223:
                if (isAssignmentOperator(node.operatorToken.kind)) {
                    return false;
                }
                return isSideEffectFree(node.left) && isSideEffectFree(node.right);
            case 221:
            case 222:
                switch (node.operator) {
                    case 53:
                    case 39:
                    case 40:
                    case 54:
                        return true;
                }
                return false;
            case 219:
            case 213:
            case 231:
            default:
                return false;
        }
    }
    function isTypeEqualityComparableTo(source, target) {
        return (target.flags & 98304) !== 0 || isTypeComparableTo(source, target);
    }
    function createCheckBinaryExpression() {
        const trampoline = createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, foldState);
        return (node, checkMode) => {
            const result = trampoline(node, checkMode);
            Debug.assertIsDefined(result);
            return result;
        };
        function onEnter(node, state, checkMode) {
            if (state) {
                state.stackIndex++;
                state.skip = false;
                setLeftType(state, void 0);
                setLastResult(state, void 0);
            } else {
                state = {
                    checkMode,
                    skip: false,
                    stackIndex: 0,
                    typeStack: [void 0, void 0]
                };
            }
            if (isInJSFile(node) && getAssignedExpandoInitializer(node)) {
                state.skip = true;
                setLastResult(state, checkExpression(node.right, checkMode));
                return state;
            }
            checkGrammarNullishCoalesceWithLogicalExpression(node);
            const operator = node.operatorToken.kind;
            if (operator === 63 && (node.left.kind === 207 || node.left.kind === 206)) {
                state.skip = true;
                setLastResult(state, checkDestructuringAssignment(node.left, checkExpression(node.right, checkMode), checkMode, node.right.kind === 108));
                return state;
            }
            return state;
        }
        function onLeft(left, state, _node) {
            if (!state.skip) {
                return maybeCheckExpression(state, left);
            }
        }
        function onOperator(operatorToken, state, node) {
            if (!state.skip) {
                const leftType = getLastResult(state);
                Debug.assertIsDefined(leftType);
                setLeftType(state, leftType);
                setLastResult(state, void 0);
                const operator = operatorToken.kind;
                if (isLogicalOrCoalescingBinaryOperator(operator)) {
                    let parent2 = node.parent;
                    while (parent2.kind === 214 || isLogicalOrCoalescingBinaryExpression(parent2)) {
                        parent2 = parent2.parent;
                    }
                    if (operator === 55 || isIfStatement(parent2)) {
                        checkTestingKnownTruthyCallableOrAwaitableType(node.left, leftType, isIfStatement(parent2) ? parent2.thenStatement : void 0);
                    }
                    checkTruthinessOfType(leftType, node.left);
                }
            }
        }
        function onRight(right, state, _node) {
            if (!state.skip) {
                return maybeCheckExpression(state, right);
            }
        }
        function onExit(node, state) {
            let result;
            if (state.skip) {
                result = getLastResult(state);
            } else {
                const leftType = getLeftType(state);
                Debug.assertIsDefined(leftType);
                const rightType = getLastResult(state);
                Debug.assertIsDefined(rightType);
                result = checkBinaryLikeExpressionWorker(node.left, node.operatorToken, node.right, leftType, rightType, node);
            }
            state.skip = false;
            setLeftType(state, void 0);
            setLastResult(state, void 0);
            state.stackIndex--;
            return result;
        }
        function foldState(state, result, _side) {
            setLastResult(state, result);
            return state;
        }
        function maybeCheckExpression(state, node) {
            if (isBinaryExpression(node)) {
                return node;
            }
            setLastResult(state, checkExpression(node, state.checkMode));
        }
        function getLeftType(state) {
            return state.typeStack[state.stackIndex];
        }
        function setLeftType(state, type) {
            state.typeStack[state.stackIndex] = type;
        }
        function getLastResult(state) {
            return state.typeStack[state.stackIndex + 1];
        }
        function setLastResult(state, type) {
            state.typeStack[state.stackIndex + 1] = type;
        }
    }
    function checkGrammarNullishCoalesceWithLogicalExpression(node) {
        const {
            left,
            operatorToken,
            right
        } = node;
        if (operatorToken.kind === 60) {
            if (isBinaryExpression(left) && (left.operatorToken.kind === 56 || left.operatorToken.kind === 55)) {
                grammarErrorOnNode(left, Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses, tokenToString(left.operatorToken.kind), tokenToString(operatorToken.kind));
            }
            if (isBinaryExpression(right) && (right.operatorToken.kind === 56 || right.operatorToken.kind === 55)) {
                grammarErrorOnNode(right, Diagnostics._0_and_1_operations_cannot_be_mixed_without_parentheses, tokenToString(right.operatorToken.kind), tokenToString(operatorToken.kind));
            }
        }
    }
    function checkBinaryLikeExpression(left, operatorToken, right, checkMode, errorNode) {
        const operator = operatorToken.kind;
        if (operator === 63 && (left.kind === 207 || left.kind === 206)) {
            return checkDestructuringAssignment(left, checkExpression(right, checkMode), checkMode, right.kind === 108);
        }
        let leftType;
        if (isLogicalOrCoalescingBinaryOperator(operator)) {
            leftType = checkTruthinessExpression(left, checkMode);
        } else {
            leftType = checkExpression(left, checkMode);
        }
        const rightType = checkExpression(right, checkMode);
        return checkBinaryLikeExpressionWorker(left, operatorToken, right, leftType, rightType, errorNode);
    }
    function checkBinaryLikeExpressionWorker(left, operatorToken, right, leftType, rightType, errorNode) {
        const operator = operatorToken.kind;
        switch (operator) {
            case 41:
            case 42:
            case 66:
            case 67:
            case 43:
            case 68:
            case 44:
            case 69:
            case 40:
            case 65:
            case 47:
            case 70:
            case 48:
            case 71:
            case 49:
            case 72:
            case 51:
            case 74:
            case 52:
            case 78:
            case 50:
            case 73:
                if (leftType === silentNeverType || rightType === silentNeverType) {
                    return silentNeverType;
                }
                leftType = checkNonNullType(leftType, left);
                rightType = checkNonNullType(rightType, right);
                let suggestedOperator;
                if (leftType.flags & 528 && rightType.flags & 528 && (suggestedOperator = getSuggestedBooleanOperator(operatorToken.kind)) !== void 0) {
                    error(errorNode || operatorToken, Diagnostics.The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead, tokenToString(operatorToken.kind), tokenToString(suggestedOperator));
                    return numberType;
                } else {
                    const leftOk = checkArithmeticOperandType(left, leftType, Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, true);
                    const rightOk = checkArithmeticOperandType(right, rightType, Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type, true);
                    let resultType2;
                    if (isTypeAssignableToKind(leftType, 3) && isTypeAssignableToKind(rightType, 3) || !(maybeTypeOfKind(leftType, 2112) || maybeTypeOfKind(rightType, 2112))) {
                        resultType2 = numberType;
                    } else if (bothAreBigIntLike(leftType, rightType)) {
                        switch (operator) {
                            case 49:
                            case 72:
                                reportOperatorError();
                                break;
                            case 42:
                            case 67:
                                if (languageVersion < 3) {
                                    error(errorNode, Diagnostics.Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later);
                                }
                        }
                        resultType2 = bigintType;
                    } else {
                        reportOperatorError(bothAreBigIntLike);
                        resultType2 = errorType;
                    }
                    if (leftOk && rightOk) {
                        checkAssignmentOperator(resultType2);
                    }
                    return resultType2;
                }
            case 39:
            case 64:
                if (leftType === silentNeverType || rightType === silentNeverType) {
                    return silentNeverType;
                }
                if (!isTypeAssignableToKind(leftType, 402653316) && !isTypeAssignableToKind(rightType, 402653316)) {
                    leftType = checkNonNullType(leftType, left);
                    rightType = checkNonNullType(rightType, right);
                }
                let resultType;
                if (isTypeAssignableToKind(leftType, 296, true) && isTypeAssignableToKind(rightType, 296, true)) {
                    resultType = numberType;
                } else if (isTypeAssignableToKind(leftType, 2112, true) && isTypeAssignableToKind(rightType, 2112, true)) {
                    resultType = bigintType;
                } else if (isTypeAssignableToKind(leftType, 402653316, true) || isTypeAssignableToKind(rightType, 402653316, true)) {
                    resultType = stringType;
                } else if (isTypeAny(leftType) || isTypeAny(rightType)) {
                    resultType = isErrorType(leftType) || isErrorType(rightType) ? errorType : anyType;
                }
                if (resultType && !checkForDisallowedESSymbolOperand(operator)) {
                    return resultType;
                }
                if (!resultType) {
                    const closeEnoughKind = 296 | 2112 | 402653316 | 3;
                    reportOperatorError((left2, right2) => isTypeAssignableToKind(left2, closeEnoughKind) && isTypeAssignableToKind(right2, closeEnoughKind));
                    return anyType;
                }
                if (operator === 64) {
                    checkAssignmentOperator(resultType);
                }
                return resultType;
            case 29:
            case 31:
            case 32:
            case 33:
                if (checkForDisallowedESSymbolOperand(operator)) {
                    leftType = getBaseTypeOfLiteralTypeForComparison(checkNonNullType(leftType, left));
                    rightType = getBaseTypeOfLiteralTypeForComparison(checkNonNullType(rightType, right));
                    reportOperatorErrorUnless((left2, right2) => {
                        if (isTypeAny(left2) || isTypeAny(right2)) {
                            return true;
                        }
                        const leftAssignableToNumber = isTypeAssignableTo(left2, numberOrBigIntType);
                        const rightAssignableToNumber = isTypeAssignableTo(right2, numberOrBigIntType);
                        return leftAssignableToNumber && rightAssignableToNumber || !leftAssignableToNumber && !rightAssignableToNumber && areTypesComparable(left2, right2);
                    });
                }
                return booleanType;
            case 34:
            case 35:
            case 36:
            case 37:
                if (isLiteralExpressionOfObject(left) || isLiteralExpressionOfObject(right)) {
                    const eqType = operator === 34 || operator === 36;
                    error(errorNode, Diagnostics.This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value, eqType ? "false" : "true");
                }
                checkNaNEquality(errorNode, operator, left, right);
                reportOperatorErrorUnless((left2, right2) => isTypeEqualityComparableTo(left2, right2) || isTypeEqualityComparableTo(right2, left2));
                return booleanType;
            case 102:
                return checkInstanceOfExpression(left, right, leftType, rightType);
            case 101:
                return checkInExpression(left, right, leftType, rightType);
            case 55:
            case 76:
                {
                    const resultType2 = getTypeFacts(leftType) & 4194304 ? getUnionType([extractDefinitelyFalsyTypes(strictNullChecks ? leftType : getBaseTypeOfLiteralType(rightType)), rightType]) : leftType;
                    if (operator === 76) {
                        checkAssignmentOperator(rightType);
                    }
                    return resultType2;
                }
            case 56:
            case 75:
                {
                    const resultType2 = getTypeFacts(leftType) & 8388608 ? getUnionType([getNonNullableType(removeDefinitelyFalsyTypes(leftType)), rightType], 2) : leftType;
                    if (operator === 75) {
                        checkAssignmentOperator(rightType);
                    }
                    return resultType2;
                }
            case 60:
            case 77:
                {
                    const resultType2 = getTypeFacts(leftType) & 262144 ? getUnionType([getNonNullableType(leftType), rightType], 2) : leftType;
                    if (operator === 77) {
                        checkAssignmentOperator(rightType);
                    }
                    return resultType2;
                }
            case 63:
                const declKind = isBinaryExpression(left.parent) ? getAssignmentDeclarationKind(left.parent) : 0;
                checkAssignmentDeclaration(declKind, rightType);
                if (isAssignmentDeclaration2(declKind)) {
                    if (!(rightType.flags & 524288) || declKind !== 2 && declKind !== 6 && !isEmptyObjectType(rightType) && !isFunctionObjectType(rightType) && !(getObjectFlags(rightType) & 1)) {
                        checkAssignmentOperator(rightType);
                    }
                    return leftType;
                } else {
                    checkAssignmentOperator(rightType);
                    return rightType;
                }
            case 27:
                if (!compilerOptions.allowUnreachableCode && isSideEffectFree(left) && !isIndirectCall(left.parent)) {
                    const sf = getSourceFileOfNode(left);
                    const sourceText = sf.text;
                    const start = skipTrivia(sourceText, left.pos);
                    const isInDiag2657 = sf.parseDiagnostics.some(diag2 => {
                        if (diag2.code !== Diagnostics.JSX_expressions_must_have_one_parent_element.code) return false;
                        return textSpanContainsPosition(diag2, start);
                    });
                    if (!isInDiag2657) error(left, Diagnostics.Left_side_of_comma_operator_is_unused_and_has_no_side_effects);
                }
                return rightType;
            default:
                return Debug.fail();
        }
        function bothAreBigIntLike(left2, right2) {
            return isTypeAssignableToKind(left2, 2112) && isTypeAssignableToKind(right2, 2112);
        }
        function checkAssignmentDeclaration(kind, rightType2) {
            if (kind === 2) {
                for (const prop of getPropertiesOfObjectType(rightType2)) {
                    const propType = getTypeOfSymbol(prop);
                    if (propType.symbol && propType.symbol.flags & 32) {
                        const name = prop.escapedName;
                        const symbol = resolveName(prop.valueDeclaration, name, 788968, void 0, name, false);
                        if ((symbol == null ? void 0 : symbol.declarations) && symbol.declarations.some(isJSDocTypedefTag)) {
                            addDuplicateDeclarationErrorsForSymbols(symbol, Diagnostics.Duplicate_identifier_0, unescapeLeadingUnderscores(name), prop);
                            addDuplicateDeclarationErrorsForSymbols(prop, Diagnostics.Duplicate_identifier_0, unescapeLeadingUnderscores(name), symbol);
                        }
                    }
                }
            }
        }
        function isIndirectCall(node) {
            return node.parent.kind === 214 && isNumericLiteral(node.left) && node.left.text === "0" && (isCallExpression(node.parent.parent) && node.parent.parent.expression === node.parent || node.parent.parent.kind === 212) && (isAccessExpression(node.right) || isIdentifier(node.right) && node.right.escapedText === "eval");
        }
        function checkForDisallowedESSymbolOperand(operator2) {
            const offendingSymbolOperand = maybeTypeOfKindConsideringBaseConstraint(leftType, 12288) ? left : maybeTypeOfKindConsideringBaseConstraint(rightType, 12288) ? right : void 0;
            if (offendingSymbolOperand) {
                error(offendingSymbolOperand, Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, tokenToString(operator2));
                return false;
            }
            return true;
        }
        function getSuggestedBooleanOperator(operator2) {
            switch (operator2) {
                case 51:
                case 74:
                    return 56;
                case 52:
                case 78:
                    return 37;
                case 50:
                case 73:
                    return 55;
                default:
                    return void 0;
            }
        }
        function checkAssignmentOperator(valueType) {
            if (isAssignmentOperator(operator)) {
                addLazyDiagnostic(checkAssignmentOperatorWorker);
            }
            function checkAssignmentOperatorWorker() {
                if (checkReferenceExpression(left, Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access)) {
                    let headMessage;
                    if (exactOptionalPropertyTypes && isPropertyAccessExpression(left) && maybeTypeOfKind(valueType, 32768)) {
                        const target = getTypeOfPropertyOfType(getTypeOfExpression(left.expression), left.name.escapedText);
                        if (isExactOptionalPropertyMismatch(valueType, target)) {
                            headMessage = Diagnostics.Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target;
                        }
                    }
                    checkTypeAssignableToAndOptionallyElaborate(valueType, leftType, left, right, headMessage);
                }
            }
        }
        function isAssignmentDeclaration2(kind) {
            var _a2;
            switch (kind) {
                case 2:
                    return true;
                case 1:
                case 5:
                case 6:
                case 3:
                case 4:
                    const symbol = getSymbolOfNode(left);
                    const init = getAssignedExpandoInitializer(right);
                    return !!init && isObjectLiteralExpression(init) && !!((_a2 = symbol == null ? void 0 : symbol.exports) == null ? void 0 : _a2.size);
                default:
                    return false;
            }
        }
        function reportOperatorErrorUnless(typesAreCompatible) {
            if (!typesAreCompatible(leftType, rightType)) {
                reportOperatorError(typesAreCompatible);
                return true;
            }
            return false;
        }
        function reportOperatorError(isRelated) {
            let wouldWorkWithAwait = false;
            const errNode = errorNode || operatorToken;
            if (isRelated) {
                const awaitedLeftType = getAwaitedTypeNoAlias(leftType);
                const awaitedRightType = getAwaitedTypeNoAlias(rightType);
                wouldWorkWithAwait = !(awaitedLeftType === leftType && awaitedRightType === rightType) && !!(awaitedLeftType && awaitedRightType) && isRelated(awaitedLeftType, awaitedRightType);
            }
            let effectiveLeft = leftType;
            let effectiveRight = rightType;
            if (!wouldWorkWithAwait && isRelated) {
                [effectiveLeft, effectiveRight] = getBaseTypesIfUnrelated(leftType, rightType, isRelated);
            }
            const [leftStr, rightStr] = getTypeNamesForErrorDisplay(effectiveLeft, effectiveRight);
            if (!tryGiveBetterPrimaryError(errNode, wouldWorkWithAwait, leftStr, rightStr)) {
                errorAndMaybeSuggestAwait(errNode, wouldWorkWithAwait, Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2, tokenToString(operatorToken.kind), leftStr, rightStr);
            }
        }
        function tryGiveBetterPrimaryError(errNode, maybeMissingAwait, leftStr, rightStr) {
            switch (operatorToken.kind) {
                case 36:
                case 34:
                case 37:
                case 35:
                    return errorAndMaybeSuggestAwait(errNode, maybeMissingAwait, Diagnostics.This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap, leftStr, rightStr);
                default:
                    return void 0;
            }
        }
        function checkNaNEquality(errorNode2, operator2, left2, right2) {
            const isLeftNaN = isGlobalNaN(skipParentheses(left2));
            const isRightNaN = isGlobalNaN(skipParentheses(right2));
            if (isLeftNaN || isRightNaN) {
                const err = error(errorNode2, Diagnostics.This_condition_will_always_return_0, tokenToString(operator2 === 36 || operator2 === 34 ? 95 : 110));
                if (isLeftNaN && isRightNaN) return;
                const operatorString = operator2 === 37 || operator2 === 35 ? tokenToString(53) : "";
                const location = isLeftNaN ? right2 : left2;
                const expression = skipParentheses(location);
                addRelatedInfo(err, createDiagnosticForNode(location, Diagnostics.Did_you_mean_0, `${operatorString}Number.isNaN(${isEntityNameExpression(expression) ? entityNameToString(expression) : "..."})`));
            }
        }
        function isGlobalNaN(expr) {
            if (isIdentifier(expr) && expr.escapedText === "NaN") {
                const globalNaNSymbol = getGlobalNaNSymbol();
                return !!globalNaNSymbol && globalNaNSymbol === getResolvedSymbol(expr);
            }
            return false;
        }
    }
    function getBaseTypesIfUnrelated(leftType, rightType, isRelated) {
        let effectiveLeft = leftType;
        let effectiveRight = rightType;
        const leftBase = getBaseTypeOfLiteralType(leftType);
        const rightBase = getBaseTypeOfLiteralType(rightType);
        if (!isRelated(leftBase, rightBase)) {
            effectiveLeft = leftBase;
            effectiveRight = rightBase;
        }
        return [effectiveLeft, effectiveRight];
    }
    function checkYieldExpression(node) {
        addLazyDiagnostic(checkYieldExpressionGrammar);
        const func = getContainingFunction(node);
        if (!func) return anyType;
        const functionFlags = getFunctionFlags(func);
        if (!(functionFlags & 1)) {
            return anyType;
        }
        const isAsync = (functionFlags & 2) !== 0;
        if (node.asteriskToken) {
            if (isAsync && languageVersion < 99) {
                checkExternalEmitHelpers(node, 26624);
            }
            if (!isAsync && languageVersion < 2 && compilerOptions.downlevelIteration) {
                checkExternalEmitHelpers(node, 256);
            }
        }
        const returnType = getReturnTypeFromAnnotation(func);
        const iterationTypes = returnType && getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsync);
        const signatureYieldType = iterationTypes && iterationTypes.yieldType || anyType;
        const signatureNextType = iterationTypes && iterationTypes.nextType || anyType;
        const resolvedSignatureNextType = isAsync ? getAwaitedType(signatureNextType) || anyType : signatureNextType;
        const yieldExpressionType = node.expression ? checkExpression(node.expression) : undefinedWideningType;
        const yieldedType = getYieldedTypeOfYieldExpression(node, yieldExpressionType, resolvedSignatureNextType, isAsync);
        if (returnType && yieldedType) {
            checkTypeAssignableToAndOptionallyElaborate(yieldedType, signatureYieldType, node.expression || node, node.expression);
        }
        if (node.asteriskToken) {
            const use = isAsync ? 19 : 17;
            return getIterationTypeOfIterable(use, 1, yieldExpressionType, node.expression) || anyType;
        } else if (returnType) {
            return getIterationTypeOfGeneratorFunctionReturnType(2, returnType, isAsync) || anyType;
        }
        let type = getContextualIterationType(2, func);
        if (!type) {
            type = anyType;
            addLazyDiagnostic(() => {
                if (noImplicitAny && !expressionResultIsUnused(node)) {
                    const contextualType = getContextualType2(node, void 0);
                    if (!contextualType || isTypeAny(contextualType)) {
                        error(node, Diagnostics.yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_type_annotation);
                    }
                }
            });
        }
        return type;
        function checkYieldExpressionGrammar() {
            if (!(node.flags & 8192)) {
                grammarErrorOnFirstToken(node, Diagnostics.A_yield_expression_is_only_allowed_in_a_generator_body);
            }
            if (isInParameterInitializerBeforeContainingFunction(node)) {
                error(node, Diagnostics.yield_expressions_cannot_be_used_in_a_parameter_initializer);
            }
        }
    }
    function checkConditionalExpression(node, checkMode) {
        const type = checkTruthinessExpression(node.condition);
        checkTestingKnownTruthyCallableOrAwaitableType(node.condition, type, node.whenTrue);
        const type1 = checkExpression(node.whenTrue, checkMode);
        const type2 = checkExpression(node.whenFalse, checkMode);
        return getUnionType([type1, type2], 2);
    }
    function isTemplateLiteralContext(node) {
        const parent2 = node.parent;
        return isParenthesizedExpression(parent2) && isTemplateLiteralContext(parent2) || isElementAccessExpression(parent2) && parent2.argumentExpression === node;
    }
    function checkTemplateExpression(node) {
        const texts = [node.head.text];
        const types = [];
        for (const span of node.templateSpans) {
            const type = checkExpression(span.expression);
            if (maybeTypeOfKindConsideringBaseConstraint(type, 12288)) {
                error(span.expression, Diagnostics.Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String);
            }
            texts.push(span.literal.text);
            types.push(isTypeAssignableTo(type, templateConstraintType) ? type : stringType);
        }
        return isConstContext(node) || isTemplateLiteralContext(node) || someType(getContextualType2(node, void 0) || unknownType, isTemplateLiteralContextualType) ? getTemplateLiteralType(texts, types) : stringType;
    }
    function isTemplateLiteralContextualType(type) {
        return !!(type.flags & (128 | 134217728) || type.flags & 58982400 && maybeTypeOfKind(getBaseConstraintOfType(type) || unknownType, 402653316));
    }
    function getContextNode2(node) {
        if (isJsxAttributes(node) && !isJsxSelfClosingElement(node.parent)) {
            return node.parent.parent;
        }
        return node;
    }
    function checkExpressionWithContextualType(node, contextualType, inferenceContext, checkMode) {
        const contextNode = getContextNode2(node);
        pushContextualType(contextNode, contextualType, false);
        pushInferenceContext(contextNode, inferenceContext);
        const type = checkExpression(node, checkMode | 1 | (inferenceContext ? 2 : 0));
        if (inferenceContext && inferenceContext.intraExpressionInferenceSites) {
            inferenceContext.intraExpressionInferenceSites = void 0;
        }
        const result = maybeTypeOfKind(type, 2944) && isLiteralOfContextualType(type, instantiateContextualType(contextualType, node, void 0)) ? getRegularTypeOfLiteralType(type) : type;
        popInferenceContext();
        popContextualType();
        return result;
    }
    function checkExpressionCached(node, checkMode) {
        if (checkMode) {
            return checkExpression(node, checkMode);
        }
        const links = getNodeLinks(node);
        if (!links.resolvedType) {
            const saveFlowLoopStart = flowLoopStart;
            const saveFlowTypeCache = flowTypeCache;
            flowLoopStart = flowLoopCount;
            flowTypeCache = void 0;
            links.resolvedType = checkExpression(node, checkMode);
            flowTypeCache = saveFlowTypeCache;
            flowLoopStart = saveFlowLoopStart;
        }
        return links.resolvedType;
    }
    function isTypeAssertion(node) {
        node = skipParentheses(node, true);
        return node.kind === 213 || node.kind === 231 || isJSDocTypeAssertion(node);
    }
    function checkDeclarationInitializer(declaration, checkMode, contextualType) {
        const initializer = getEffectiveInitializer(declaration);
        if (isInJSFile(declaration)) {
            const typeNode = tryGetJSDocSatisfiesTypeNode(declaration);
            if (typeNode) {
                return checkSatisfiesExpressionWorker(initializer, typeNode, checkMode);
            }
        }
        const type = getQuickTypeOfExpression(initializer) || (contextualType ? checkExpressionWithContextualType(initializer, contextualType, void 0, checkMode || 0) : checkExpressionCached(initializer, checkMode));
        return isParameter(declaration) && declaration.name.kind === 204 && isTupleType(type) && !type.target.hasRestElement && getTypeReferenceArity(type) < declaration.name.elements.length ? padTupleType(type, declaration.name) : type;
    }
    function padTupleType(type, pattern) {
        const patternElements = pattern.elements;
        const elementTypes = getTypeArguments(type).slice();
        const elementFlags = type.target.elementFlags.slice();
        for (let i = getTypeReferenceArity(type); i < patternElements.length; i++) {
            const e = patternElements[i];
            if (i < patternElements.length - 1 || !(e.kind === 205 && e.dotDotDotToken)) {
                elementTypes.push(!isOmittedExpression(e) && hasDefaultValue(e) ? getTypeFromBindingElement(e, false, false) : anyType);
                elementFlags.push(2);
                if (!isOmittedExpression(e) && !hasDefaultValue(e)) {
                    reportImplicitAny(e, anyType);
                }
            }
        }
        return createTupleType(elementTypes, elementFlags, type.target.readonly);
    }
    function widenTypeInferredFromInitializer(declaration, type) {
        const widened = getCombinedNodeFlags(declaration) & 2 || isDeclarationReadonly(declaration) ? type : getWidenedLiteralType(type);
        if (isInJSFile(declaration)) {
            if (isEmptyLiteralType(widened)) {
                reportImplicitAny(declaration, anyType);
                return anyType;
            } else if (isEmptyArrayLiteralType(widened)) {
                reportImplicitAny(declaration, anyArrayType);
                return anyArrayType;
            }
        }
        return widened;
    }
    function isLiteralOfContextualType(candidateType, contextualType) {
        if (contextualType) {
            if (contextualType.flags & 3145728) {
                const types = contextualType.types;
                return some(types, t => isLiteralOfContextualType(candidateType, t));
            }
            if (contextualType.flags & 58982400) {
                const constraint = getBaseConstraintOfType(contextualType) || unknownType;
                return maybeTypeOfKind(constraint, 4) && maybeTypeOfKind(candidateType, 128) || maybeTypeOfKind(constraint, 8) && maybeTypeOfKind(candidateType, 256) || maybeTypeOfKind(constraint, 64) && maybeTypeOfKind(candidateType, 2048) || maybeTypeOfKind(constraint, 4096) && maybeTypeOfKind(candidateType, 8192) || isLiteralOfContextualType(candidateType, constraint);
            }
            return !!(contextualType.flags & (128 | 4194304 | 134217728 | 268435456) && maybeTypeOfKind(candidateType, 128) || contextualType.flags & 256 && maybeTypeOfKind(candidateType, 256) || contextualType.flags & 2048 && maybeTypeOfKind(candidateType, 2048) || contextualType.flags & 512 && maybeTypeOfKind(candidateType, 512) || contextualType.flags & 8192 && maybeTypeOfKind(candidateType, 8192));
        }
        return false;
    }
    function isConstContext(node) {
        const parent2 = node.parent;
        return isAssertionExpression(parent2) && isConstTypeReference(parent2.type) || isJSDocTypeAssertion(parent2) && isConstTypeReference(getJSDocTypeAssertionType(parent2)) || isValidConstAssertionArgument(node) && isConstTypeParameterContext(node) || (isParenthesizedExpression(parent2) || isArrayLiteralExpression(parent2) || isSpreadElement(parent2)) && isConstContext(parent2) || (isPropertyAssignment(parent2) || isShorthandPropertyAssignment(parent2) || isTemplateSpan(parent2)) && isConstContext(parent2.parent);
    }
    function isConstTypeParameterContext(node) {
        const contextualType = getContextualType2(node, 0);
        return !!contextualType && someType(contextualType, isConstTypeVariable);
    }
    function checkExpressionForMutableLocation(node, checkMode, forceTuple) {
        const type = checkExpression(node, checkMode, forceTuple);
        return isConstContext(node) || isCommonJsExportedExpression(node) ? getRegularTypeOfLiteralType(type) : isTypeAssertion(node) ? type : getWidenedLiteralLikeTypeForContextualType(type, instantiateContextualType(getContextualType2(node, void 0), node, void 0));
    }
    function checkPropertyAssignment(node, checkMode) {
        if (node.name.kind === 164) {
            checkComputedPropertyName(node.name);
        }
        return checkExpressionForMutableLocation(node.initializer, checkMode);
    }
    function checkObjectLiteralMethod(node, checkMode) {
        checkGrammarMethod(node);
        if (node.name.kind === 164) {
            checkComputedPropertyName(node.name);
        }
        const uninstantiatedType = checkFunctionExpressionOrObjectLiteralMethod(node, checkMode);
        return instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode);
    }
    function instantiateTypeWithSingleGenericCallSignature(node, type, checkMode) {
        if (checkMode && checkMode & (2 | 8)) {
            const callSignature = getSingleSignature(type, 0, true);
            const constructSignature = getSingleSignature(type, 1, true);
            const signature = callSignature || constructSignature;
            if (signature && signature.typeParameters) {
                const contextualType = getApparentTypeOfContextualType(node, 2);
                if (contextualType) {
                    const contextualSignature = getSingleSignature(getNonNullableType(contextualType), callSignature ? 0 : 1, false);
                    if (contextualSignature && !contextualSignature.typeParameters) {
                        if (checkMode & 8) {
                            skippedGenericFunction(node, checkMode);
                            return anyFunctionType;
                        }
                        const context = getInferenceContext(node);
                        const returnType = context.signature && getReturnTypeOfSignature(context.signature);
                        const returnSignature = returnType && getSingleCallOrConstructSignature(returnType);
                        if (returnSignature && !returnSignature.typeParameters && !every(context.inferences, hasInferenceCandidates)) {
                            const uniqueTypeParameters = getUniqueTypeParameters(context, signature.typeParameters);
                            const instantiatedSignature = getSignatureInstantiationWithoutFillingInTypeArguments(signature, uniqueTypeParameters);
                            const inferences = map(context.inferences, info => createInferenceInfo(info.typeParameter));
                            applyToParameterTypes(instantiatedSignature, contextualSignature, (source, target) => {
                                inferTypes(inferences, source, target, 0, true);
                            });
                            if (some(inferences, hasInferenceCandidates)) {
                                applyToReturnTypes(instantiatedSignature, contextualSignature, (source, target) => {
                                    inferTypes(inferences, source, target);
                                });
                                if (!hasOverlappingInferences(context.inferences, inferences)) {
                                    mergeInferences(context.inferences, inferences);
                                    context.inferredTypeParameters = concatenate(context.inferredTypeParameters, uniqueTypeParameters);
                                    return getOrCreateTypeFromSignature(instantiatedSignature);
                                }
                            }
                        }
                        return getOrCreateTypeFromSignature(instantiateSignatureInContextOf(signature, contextualSignature, context));
                    }
                }
            }
        }
        return type;
    }
    function skippedGenericFunction(node, checkMode) {
        if (checkMode & 2) {
            const context = getInferenceContext(node);
            context.flags |= 4;
        }
    }
    function hasInferenceCandidates(info) {
        return !!(info.candidates || info.contraCandidates);
    }
    function hasInferenceCandidatesOrDefault(info) {
        return !!(info.candidates || info.contraCandidates || hasTypeParameterDefault(info.typeParameter));
    }
    function hasOverlappingInferences(a, b) {
        for (let i = 0; i < a.length; i++) {
            if (hasInferenceCandidates(a[i]) && hasInferenceCandidates(b[i])) {
                return true;
            }
        }
        return false;
    }
    function mergeInferences(target, source) {
        for (let i = 0; i < target.length; i++) {
            if (!hasInferenceCandidates(target[i]) && hasInferenceCandidates(source[i])) {
                target[i] = source[i];
            }
        }
    }
    function getUniqueTypeParameters(context, typeParameters) {
        const result = [];
        let oldTypeParameters;
        let newTypeParameters;
        for (const tp of typeParameters) {
            const name = tp.symbol.escapedName;
            if (hasTypeParameterByName(context.inferredTypeParameters, name) || hasTypeParameterByName(result, name)) {
                const newName = getUniqueTypeParameterName(concatenate(context.inferredTypeParameters, result), name);
                const symbol = createSymbol(262144, newName);
                const newTypeParameter = createTypeParameter(symbol);
                newTypeParameter.target = tp;
                oldTypeParameters = append(oldTypeParameters, tp);
                newTypeParameters = append(newTypeParameters, newTypeParameter);
                result.push(newTypeParameter);
            } else {
                result.push(tp);
            }
        }
        if (newTypeParameters) {
            const mapper = createTypeMapper(oldTypeParameters, newTypeParameters);
            for (const tp of newTypeParameters) {
                tp.mapper = mapper;
            }
        }
        return result;
    }
    function hasTypeParameterByName(typeParameters, name) {
        return some(typeParameters, tp => tp.symbol.escapedName === name);
    }
    function getUniqueTypeParameterName(typeParameters, baseName) {
        let len = baseName.length;
        while (len > 1 && baseName.charCodeAt(len - 1) >= 48 && baseName.charCodeAt(len - 1) <= 57) len--;
        const s = baseName.slice(0, len);
        for (let index = 1; true; index++) {
            const augmentedName = s + index;
            if (!hasTypeParameterByName(typeParameters, augmentedName)) {
                return augmentedName;
            }
        }
    }
    function getReturnTypeOfSingleNonGenericCallSignature(funcType) {
        const signature = getSingleCallSignature(funcType);
        if (signature && !signature.typeParameters) {
            return getReturnTypeOfSignature(signature);
        }
    }
    function getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr) {
        const funcType = checkExpression(expr.expression);
        const nonOptionalType = getOptionalExpressionType(funcType, expr.expression);
        const returnType = getReturnTypeOfSingleNonGenericCallSignature(funcType);
        return returnType && propagateOptionalTypeMarker(returnType, expr, nonOptionalType !== funcType);
    }
    function getTypeOfExpression(node) {
        const quickType = getQuickTypeOfExpression(node);
        if (quickType) {
            return quickType;
        }
        if (node.flags & 134217728 && flowTypeCache) {
            const cachedType = flowTypeCache[getNodeId(node)];
            if (cachedType) {
                return cachedType;
            }
        }
        const startInvocationCount = flowInvocationCount;
        const type = checkExpression(node);
        if (flowInvocationCount !== startInvocationCount) {
            const cache = flowTypeCache || (flowTypeCache = []);
            cache[getNodeId(node)] = type;
            setNodeFlags(node, node.flags | 134217728);
        }
        return type;
    }
    function getQuickTypeOfExpression(node) {
        let expr = skipParentheses(node, true);
        if (isJSDocTypeAssertion(expr)) {
            const type = getJSDocTypeAssertionType(expr);
            if (!isConstTypeReference(type)) {
                return getTypeFromTypeNode(type);
            }
        }
        expr = skipParentheses(node);
        if (isAwaitExpression(expr)) {
            const type = getQuickTypeOfExpression(expr.expression);
            return type ? getAwaitedType(type) : void 0;
        }
        if (isCallExpression(expr) && expr.expression.kind !== 106 && !isRequireCall(expr, true) && !isSymbolOrSymbolForCall(expr)) {
            return isCallChain(expr) ? getReturnTypeOfSingleNonGenericSignatureOfCallChain(expr) : getReturnTypeOfSingleNonGenericCallSignature(checkNonNullExpression(expr.expression));
        } else if (isAssertionExpression(expr) && !isConstTypeReference(expr.type)) {
            return getTypeFromTypeNode(expr.type);
        } else if (isLiteralExpression(node) || isBooleanLiteral(node)) {
            return checkExpression(node);
        }
        return void 0;
    }
    function getContextFreeTypeOfExpression(node) {
        const links = getNodeLinks(node);
        if (links.contextFreeType) {
            return links.contextFreeType;
        }
        pushContextualType(node, anyType, false);
        const type = links.contextFreeType = checkExpression(node, 4);
        popContextualType();
        return type;
    }
    function checkExpression(node, checkMode, forceTuple) {
        var _a2, _b;
        (_a2 = tracing) == null ? void 0 : _a2.push(tracing.Phase.Check, "checkExpression", {
            kind: node.kind,
            pos: node.pos,
            end: node.end,
            path: node.tracingPath
        });
        const saveCurrentNode = currentNode;
        currentNode = node;
        instantiationCount = 0;
        const uninstantiatedType = checkExpressionWorker(node, checkMode, forceTuple);
        const type = instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode);
        if (isConstEnumObjectType(type)) {
            checkConstEnumAccess(node, type);
        }
        currentNode = saveCurrentNode;
        (_b = tracing) == null ? void 0 : _b.pop();
        return type;
    }
    function checkConstEnumAccess(node, type) {
        const ok = node.parent.kind === 208 && node.parent.expression === node || node.parent.kind === 209 && node.parent.expression === node || (node.kind === 79 || node.kind === 163) && isInRightSideOfImportOrExportAssignment(node) || node.parent.kind === 183 && node.parent.exprName === node || node.parent.kind === 278;
        if (!ok) {
            error(node, Diagnostics.const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query);
        }
        if (getIsolatedModules(compilerOptions)) {
            Debug.assert(!!(type.symbol.flags & 128));
            const constEnumDeclaration = type.symbol.valueDeclaration;
            if (constEnumDeclaration.flags & 16777216) {
                error(node, Diagnostics.Cannot_access_ambient_const_enums_when_0_is_enabled, isolatedModulesLikeFlagName);
            }
        }
    }
    function checkParenthesizedExpression(node, checkMode) {
        if (hasJSDocNodes(node)) {
            if (isJSDocSatisfiesExpression(node)) {
                return checkSatisfiesExpressionWorker(node.expression, getJSDocSatisfiesExpressionType(node), checkMode);
            }
            if (isJSDocTypeAssertion(node)) {
                const type = getJSDocTypeAssertionType(node);
                return checkAssertionWorker(type, type, node.expression, checkMode);
            }
        }
        return checkExpression(node.expression, checkMode);
    }
    function checkExpressionWorker(node, checkMode, forceTuple) {
        const kind = node.kind;
        if (cancellationToken) {
            switch (kind) {
                case 228:
                case 215:
                case 216:
                    cancellationToken.throwIfCancellationRequested();
            }
        }
        switch (kind) {
            case 79:
                return checkIdentifier(node, checkMode);
            case 80:
                return checkPrivateIdentifierExpression(node);
            case 108:
                return checkThisExpression(node);
            case 106:
                return checkSuperExpression(node);
            case 104:
                return nullWideningType;
            case 14:
            case 10:
                return getFreshTypeOfLiteralType(getStringLiteralType(node.text));
            case 8:
                checkGrammarNumericLiteral(node);
                return getFreshTypeOfLiteralType(getNumberLiteralType(+node.text));
            case 9:
                checkGrammarBigIntLiteral(node);
                return getFreshTypeOfLiteralType(getBigIntLiteralType({
                    negative: false,
                    base10Value: parsePseudoBigInt(node.text)
                }));
            case 110:
                return trueType;
            case 95:
                return falseType;
            case 225:
                return checkTemplateExpression(node);
            case 13:
                return globalRegExpType;
            case 206:
                return checkArrayLiteral(node, checkMode, forceTuple);
            case 207:
                return checkObjectLiteral(node, checkMode);
            case 208:
                return checkPropertyAccessExpression(node, checkMode);
            case 163:
                return checkQualifiedName(node, checkMode);
            case 209:
                return checkIndexedAccess(node, checkMode);
            case 210:
                if (node.expression.kind === 100) {
                    return checkImportCallExpression(node);
                }
            case 211:
                return checkCallExpression(node, checkMode);
            case 212:
                return checkTaggedTemplateExpression(node);
            case 214:
                return checkParenthesizedExpression(node, checkMode);
            case 228:
                return checkClassExpression(node);
            case 215:
            case 216:
                return checkFunctionExpressionOrObjectLiteralMethod(node, checkMode);
            case 218:
                return checkTypeOfExpression(node);
            case 213:
            case 231:
                return checkAssertion(node);
            case 232:
                return checkNonNullAssertion(node);
            case 230:
                return checkExpressionWithTypeArguments(node);
            case 235:
                return checkSatisfiesExpression(node);
            case 233:
                return checkMetaProperty(node);
            case 217:
                return checkDeleteExpression(node);
            case 219:
                return checkVoidExpression(node);
            case 220:
                return checkAwaitExpression(node);
            case 221:
                return checkPrefixUnaryExpression(node);
            case 222:
                return checkPostfixUnaryExpression(node);
            case 223:
                return checkBinaryExpression(node, checkMode);
            case 224:
                return checkConditionalExpression(node, checkMode);
            case 227:
                return checkSpreadExpression(node, checkMode);
            case 229:
                return undefinedWideningType;
            case 226:
                return checkYieldExpression(node);
            case 234:
                return checkSyntheticExpression(node);
            case 291:
                return checkJsxExpression(node, checkMode);
            case 281:
                return checkJsxElement(node, checkMode);
            case 282:
                return checkJsxSelfClosingElement(node, checkMode);
            case 285:
                return checkJsxFragment(node);
            case 289:
                return checkJsxAttributes(node, checkMode);
            case 283:
                Debug.fail("Shouldn't ever directly check a JsxOpeningElement");
        }
        return errorType;
    }
    function checkTypeParameter(node) {
        checkGrammarModifiers(node);
        if (node.expression) {
            grammarErrorOnFirstToken(node.expression, Diagnostics.Type_expected);
        }
        checkSourceElement(node.constraint);
        checkSourceElement(node.default);
        const typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node));
        getBaseConstraintOfType(typeParameter);
        if (!hasNonCircularTypeParameterDefault(typeParameter)) {
            error(node.default, Diagnostics.Type_parameter_0_has_a_circular_default, typeToString(typeParameter));
        }
        const constraintType = getConstraintOfTypeParameter(typeParameter);
        const defaultType = getDefaultFromTypeParameter(typeParameter);
        if (constraintType && defaultType) {
            checkTypeAssignableTo(defaultType, getTypeWithThisArgument(instantiateType(constraintType, makeUnaryTypeMapper(typeParameter, defaultType)), defaultType), node.default, Diagnostics.Type_0_does_not_satisfy_the_constraint_1);
        }
        checkNodeDeferred(node);
        addLazyDiagnostic(() => checkTypeNameIsReserved(node.name, Diagnostics.Type_parameter_name_cannot_be_0));
    }
    function checkTypeParameterDeferred(node) {
        var _a2, _b;
        if (isInterfaceDeclaration(node.parent) || isClassLike(node.parent) || isTypeAliasDeclaration(node.parent)) {
            const typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfDeclaration(node));
            const modifiers = getTypeParameterModifiers(typeParameter) & (32768 | 65536);
            if (modifiers) {
                const symbol = getSymbolOfDeclaration(node.parent);
                if (isTypeAliasDeclaration(node.parent) && !(getObjectFlags(getDeclaredTypeOfSymbol(symbol)) & (16 | 32))) {
                    error(node, Diagnostics.Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_types);
                } else if (modifiers === 32768 || modifiers === 65536) {
                    (_a2 = tracing) == null ? void 0 : _a2.push(tracing.Phase.CheckTypes, "checkTypeParameterDeferred", {
                        parent: getTypeId(getDeclaredTypeOfSymbol(symbol)),
                        id: getTypeId(typeParameter)
                    });
                    const source = createMarkerType(symbol, typeParameter, modifiers === 65536 ? markerSubTypeForCheck : markerSuperTypeForCheck);
                    const target = createMarkerType(symbol, typeParameter, modifiers === 65536 ? markerSuperTypeForCheck : markerSubTypeForCheck);
                    const saveVarianceTypeParameter = typeParameter;
                    varianceTypeParameter = typeParameter;
                    checkTypeAssignableTo(source, target, node, Diagnostics.Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation);
                    varianceTypeParameter = saveVarianceTypeParameter;
                    (_b = tracing) == null ? void 0 : _b.pop();
                }
            }
        }
    }
    function checkParameter(node) {
        checkGrammarModifiers(node);
        checkVariableLikeDeclaration(node);
        const func = getContainingFunction(node);
        if (hasSyntacticModifier(node, 16476)) {
            if (!(func.kind === 173 && nodeIsPresent(func.body))) {
                error(node, Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation);
            }
            if (func.kind === 173 && isIdentifier(node.name) && node.name.escapedText === "constructor") {
                error(node.name, Diagnostics.constructor_cannot_be_used_as_a_parameter_property_name);
            }
        }
        if (!node.initializer && isOptionalDeclaration(node) && isBindingPattern(node.name) && func.body) {
            error(node, Diagnostics.A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature);
        }
        if (node.name && isIdentifier(node.name) && (node.name.escapedText === "this" || node.name.escapedText === "new")) {
            if (func.parameters.indexOf(node) !== 0) {
                error(node, Diagnostics.A_0_parameter_must_be_the_first_parameter, node.name.escapedText);
            }
            if (func.kind === 173 || func.kind === 177 || func.kind === 182) {
                error(node, Diagnostics.A_constructor_cannot_have_a_this_parameter);
            }
            if (func.kind === 216) {
                error(node, Diagnostics.An_arrow_function_cannot_have_a_this_parameter);
            }
            if (func.kind === 174 || func.kind === 175) {
                error(node, Diagnostics.get_and_set_accessors_cannot_declare_this_parameters);
            }
        }
        if (node.dotDotDotToken && !isBindingPattern(node.name) && !isTypeAssignableTo(getReducedType(getTypeOfSymbol(node.symbol)), anyReadonlyArrayType)) {
            error(node, Diagnostics.A_rest_parameter_must_be_of_an_array_type);
        }
    }
    function checkTypePredicate(node) {
        const parent2 = getTypePredicateParent(node);
        if (!parent2) {
            error(node, Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods);
            return;
        }
        const signature = getSignatureFromDeclaration(parent2);
        const typePredicate = getTypePredicateOfSignature(signature);
        if (!typePredicate) {
            return;
        }
        checkSourceElement(node.type);
        const {
            parameterName
        } = node;
        if (typePredicate.kind === 0 || typePredicate.kind === 2) {
            getTypeFromThisTypeNode(parameterName);
        } else {
            if (typePredicate.parameterIndex >= 0) {
                if (signatureHasRestParameter(signature) && typePredicate.parameterIndex === signature.parameters.length - 1) {
                    error(parameterName, Diagnostics.A_type_predicate_cannot_reference_a_rest_parameter);
                } else {
                    if (typePredicate.type) {
                        const leadingError = () => chainDiagnosticMessages(void 0, Diagnostics.A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type);
                        checkTypeAssignableTo(typePredicate.type, getTypeOfSymbol(signature.parameters[typePredicate.parameterIndex]), node.type, void 0, leadingError);
                    }
                }
            } else if (parameterName) {
                let hasReportedError = false;
                for (const {
                    name
                } of parent2.parameters) {
                    if (isBindingPattern(name) && checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, parameterName, typePredicate.parameterName)) {
                        hasReportedError = true;
                        break;
                    }
                }
                if (!hasReportedError) {
                    error(node.parameterName, Diagnostics.Cannot_find_parameter_0, typePredicate.parameterName);
                }
            }
        }
    }
    function getTypePredicateParent(node) {
        switch (node.parent.kind) {
            case 216:
            case 176:
            case 259:
            case 215:
            case 181:
            case 171:
            case 170:
                const parent2 = node.parent;
                if (node === parent2.type) {
                    return parent2;
                }
        }
    }
    function checkIfTypePredicateVariableIsDeclaredInBindingPattern(pattern, predicateVariableNode, predicateVariableName) {
        for (const element of pattern.elements) {
            if (isOmittedExpression(element)) {
                continue;
            }
            const name = element.name;
            if (name.kind === 79 && name.escapedText === predicateVariableName) {
                error(predicateVariableNode, Diagnostics.A_type_predicate_cannot_reference_element_0_in_a_binding_pattern, predicateVariableName);
                return true;
            } else if (name.kind === 204 || name.kind === 203) {
                if (checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, predicateVariableNode, predicateVariableName)) {
                    return true;
                }
            }
        }
    }
    function checkSignatureDeclaration(node) {
        if (node.kind === 178) {
            checkGrammarIndexSignature(node);
        } else if (node.kind === 181 || node.kind === 259 || node.kind === 182 || node.kind === 176 || node.kind === 173 || node.kind === 177) {
            checkGrammarFunctionLikeDeclaration(node);
        }
        const functionFlags = getFunctionFlags(node);
        if (!(functionFlags & 4)) {
            if ((functionFlags & 3) === 3 && languageVersion < 99) {
                checkExternalEmitHelpers(node, 6144);
            }
            if ((functionFlags & 3) === 2 && languageVersion < 4) {
                checkExternalEmitHelpers(node, 64);
            }
            if ((functionFlags & 3) !== 0 && languageVersion < 2) {
                checkExternalEmitHelpers(node, 128);
            }
        }
        checkTypeParameters(getEffectiveTypeParameterDeclarations(node));
        checkUnmatchedJSDocParameters(node);
        forEach(node.parameters, checkParameter);
        if (node.type) {
            checkSourceElement(node.type);
        }
        addLazyDiagnostic(checkSignatureDeclarationDiagnostics);
        function checkSignatureDeclarationDiagnostics() {
            checkCollisionWithArgumentsInGeneratedCode(node);
            const returnTypeNode = getEffectiveReturnTypeNode(node);
            if (noImplicitAny && !returnTypeNode) {
                switch (node.kind) {
                    case 177:
                        error(node, Diagnostics.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
                        break;
                    case 176:
                        error(node, Diagnostics.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
                        break;
                }
            }
            if (returnTypeNode) {
                const functionFlags2 = getFunctionFlags(node);
                if ((functionFlags2 & (4 | 1)) === 1) {
                    const returnType = getTypeFromTypeNode(returnTypeNode);
                    if (returnType === voidType) {
                        error(returnTypeNode, Diagnostics.A_generator_cannot_have_a_void_type_annotation);
                    } else {
                        const generatorYieldType = getIterationTypeOfGeneratorFunctionReturnType(0, returnType, (functionFlags2 & 2) !== 0) || anyType;
                        const generatorReturnType = getIterationTypeOfGeneratorFunctionReturnType(1, returnType, (functionFlags2 & 2) !== 0) || generatorYieldType;
                        const generatorNextType = getIterationTypeOfGeneratorFunctionReturnType(2, returnType, (functionFlags2 & 2) !== 0) || unknownType;
                        const generatorInstantiation = createGeneratorReturnType(generatorYieldType, generatorReturnType, generatorNextType, !!(functionFlags2 & 2));
                        checkTypeAssignableTo(generatorInstantiation, returnType, returnTypeNode);
                    }
                } else if ((functionFlags2 & 3) === 2) {
                    checkAsyncFunctionReturnType(node, returnTypeNode);
                }
            }
            if (node.kind !== 178 && node.kind !== 320) {
                registerForUnusedIdentifiersCheck(node);
            }
        }
    }
    function checkClassForDuplicateDeclarations(node) {
        const instanceNames = /* @__PURE__ */new Map();
        const staticNames = /* @__PURE__ */new Map();
        const privateIdentifiers = /* @__PURE__ */new Map();
        for (const member of node.members) {
            if (member.kind === 173) {
                for (const param of member.parameters) {
                    if (isParameterPropertyDeclaration(param, member) && !isBindingPattern(param.name)) {
                        addName(instanceNames, param.name, param.name.escapedText, 3);
                    }
                }
            } else {
                const isStaticMember = isStatic(member);
                const name = member.name;
                if (!name) {
                    continue;
                }
                const isPrivate = isPrivateIdentifier(name);
                const privateStaticFlags = isPrivate && isStaticMember ? 16 : 0;
                const names = isPrivate ? privateIdentifiers : isStaticMember ? staticNames : instanceNames;
                const memberName = name && getPropertyNameForPropertyNameNode(name);
                if (memberName) {
                    switch (member.kind) {
                        case 174:
                            addName(names, name, memberName, 1 | privateStaticFlags);
                            break;
                        case 175:
                            addName(names, name, memberName, 2 | privateStaticFlags);
                            break;
                        case 169:
                            addName(names, name, memberName, 3 | privateStaticFlags);
                            break;
                        case 171:
                            addName(names, name, memberName, 8 | privateStaticFlags);
                            break;
                    }
                }
            }
        }
        function addName(names, location, name, meaning) {
            const prev = names.get(name);
            if (prev) {
                if ((prev & 16) !== (meaning & 16)) {
                    error(location, Diagnostics.Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name, getTextOfNode(location));
                } else {
                    const prevIsMethod = !!(prev & 8);
                    const isMethod = !!(meaning & 8);
                    if (prevIsMethod || isMethod) {
                        if (prevIsMethod !== isMethod) {
                            error(location, Diagnostics.Duplicate_identifier_0, getTextOfNode(location));
                        }
                    } else if (prev & meaning & ~16) {
                        error(location, Diagnostics.Duplicate_identifier_0, getTextOfNode(location));
                    } else {
                        names.set(name, prev | meaning);
                    }
                }
            } else {
                names.set(name, meaning);
            }
        }
    }
    function checkClassForStaticPropertyNameConflicts(node) {
        for (const member of node.members) {
            const memberNameNode = member.name;
            const isStaticMember = isStatic(member);
            if (isStaticMember && memberNameNode) {
                const memberName = getPropertyNameForPropertyNameNode(memberNameNode);
                switch (memberName) {
                    case "name":
                    case "length":
                    case "caller":
                    case "arguments":
                    case "prototype":
                        const message = Diagnostics.Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1;
                        const className = getNameOfSymbolAsWritten(getSymbolOfDeclaration(node));
                        error(memberNameNode, message, memberName, className);
                        break;
                }
            }
        }
    }
    function checkObjectTypeForDuplicateDeclarations(node) {
        const names = /* @__PURE__ */new Map();
        for (const member of node.members) {
            if (member.kind === 168) {
                let memberName;
                const name = member.name;
                switch (name.kind) {
                    case 10:
                    case 8:
                        memberName = name.text;
                        break;
                    case 79:
                        memberName = idText(name);
                        break;
                    default:
                        continue;
                }
                if (names.get(memberName)) {
                    error(getNameOfDeclaration(member.symbol.valueDeclaration), Diagnostics.Duplicate_identifier_0, memberName);
                    error(member.name, Diagnostics.Duplicate_identifier_0, memberName);
                } else {
                    names.set(memberName, true);
                }
            }
        }
    }
    function checkTypeForDuplicateIndexSignatures(node) {
        if (node.kind === 261) {
            const nodeSymbol = getSymbolOfDeclaration(node);
            if (nodeSymbol.declarations && nodeSymbol.declarations.length > 0 && nodeSymbol.declarations[0] !== node) {
                return;
            }
        }
        const indexSymbol = getIndexSymbol(getSymbolOfDeclaration(node));
        if (indexSymbol == null ? void 0 : indexSymbol.declarations) {
            const indexSignatureMap = /* @__PURE__ */new Map();
            for (const declaration of indexSymbol.declarations) {
                if (declaration.parameters.length === 1 && declaration.parameters[0].type) {
                    forEachType(getTypeFromTypeNode(declaration.parameters[0].type), type => {
                        const entry = indexSignatureMap.get(getTypeId(type));
                        if (entry) {
                            entry.declarations.push(declaration);
                        } else {
                            indexSignatureMap.set(getTypeId(type), {
                                type,
                                declarations: [declaration]
                            });
                        }
                    });
                }
            }
            indexSignatureMap.forEach(entry => {
                if (entry.declarations.length > 1) {
                    for (const declaration of entry.declarations) {
                        error(declaration, Diagnostics.Duplicate_index_signature_for_type_0, typeToString(entry.type));
                    }
                }
            });
        }
    }
    function checkPropertyDeclaration(node) {
        if (!checkGrammarModifiers(node) && !checkGrammarProperty(node)) checkGrammarComputedPropertyName(node.name);
        checkVariableLikeDeclaration(node);
        setNodeLinksForPrivateIdentifierScope(node);
        if (hasSyntacticModifier(node, 256) && node.kind === 169 && node.initializer) {
            error(node, Diagnostics.Property_0_cannot_have_an_initializer_because_it_is_marked_abstract, declarationNameToString(node.name));
        }
    }
    function checkPropertySignature(node) {
        if (isPrivateIdentifier(node.name)) {
            error(node, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
        }
        return checkPropertyDeclaration(node);
    }
    function checkMethodDeclaration(node) {
        if (!checkGrammarMethod(node)) checkGrammarComputedPropertyName(node.name);
        if (isMethodDeclaration(node) && node.asteriskToken && isIdentifier(node.name) && idText(node.name) === "constructor") {
            error(node.name, Diagnostics.Class_constructor_may_not_be_a_generator);
        }
        checkFunctionOrMethodDeclaration(node);
        if (hasSyntacticModifier(node, 256) && node.kind === 171 && node.body) {
            error(node, Diagnostics.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract, declarationNameToString(node.name));
        }
        if (isPrivateIdentifier(node.name) && !getContainingClass(node)) {
            error(node, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
        }
        setNodeLinksForPrivateIdentifierScope(node);
    }
    function setNodeLinksForPrivateIdentifierScope(node) {
        if (isPrivateIdentifier(node.name) && languageVersion < 99) {
            for (let lexicalScope = getEnclosingBlockScopeContainer(node); !!lexicalScope; lexicalScope = getEnclosingBlockScopeContainer(lexicalScope)) {
                getNodeLinks(lexicalScope).flags |= 4194304;
            }
            if (isClassExpression(node.parent)) {
                const enclosingIterationStatement = getEnclosingIterationStatement(node.parent);
                if (enclosingIterationStatement) {
                    getNodeLinks(node.name).flags |= 32768;
                    getNodeLinks(enclosingIterationStatement).flags |= 4096;
                }
            }
        }
    }
    function checkClassStaticBlockDeclaration(node) {
        checkGrammarModifiers(node);
        forEachChild(node, checkSourceElement);
    }
    function checkConstructorDeclaration(node) {
        checkSignatureDeclaration(node);
        if (!checkGrammarConstructorTypeParameters(node)) checkGrammarConstructorTypeAnnotation(node);
        checkSourceElement(node.body);
        const symbol = getSymbolOfDeclaration(node);
        const firstDeclaration = getDeclarationOfKind(symbol, node.kind);
        if (node === firstDeclaration) {
            checkFunctionOrConstructorSymbol(symbol);
        }
        if (nodeIsMissing(node.body)) {
            return;
        }
        addLazyDiagnostic(checkConstructorDeclarationDiagnostics);
        return;
        function isInstancePropertyWithInitializerOrPrivateIdentifierProperty(n) {
            if (isPrivateIdentifierClassElementDeclaration(n)) {
                return true;
            }
            return n.kind === 169 && !isStatic(n) && !!n.initializer;
        }
        function checkConstructorDeclarationDiagnostics() {
            const containingClassDecl = node.parent;
            if (getClassExtendsHeritageElement(containingClassDecl)) {
                captureLexicalThis(node.parent, containingClassDecl);
                const classExtendsNull = classDeclarationExtendsNull(containingClassDecl);
                const superCall = findFirstSuperCall(node.body);
                if (superCall) {
                    if (classExtendsNull) {
                        error(superCall, Diagnostics.A_constructor_cannot_contain_a_super_call_when_its_class_extends_null);
                    }
                    const superCallShouldBeRootLevel = (getEmitScriptTarget(compilerOptions) !== 99 || !useDefineForClassFields) && (some(node.parent.members, isInstancePropertyWithInitializerOrPrivateIdentifierProperty) || some(node.parameters, p => hasSyntacticModifier(p, 16476)));
                    if (superCallShouldBeRootLevel) {
                        if (!superCallIsRootLevelInConstructor(superCall, node.body)) {
                            error(superCall, Diagnostics.A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_initialized_properties_parameter_properties_or_private_identifiers);
                        } else {
                            let superCallStatement;
                            for (const statement of node.body.statements) {
                                if (isExpressionStatement(statement) && isSuperCall(skipOuterExpressions(statement.expression))) {
                                    superCallStatement = statement;
                                    break;
                                }
                                if (nodeImmediatelyReferencesSuperOrThis(statement)) {
                                    break;
                                }
                            }
                            if (superCallStatement === void 0) {
                                error(node, Diagnostics.A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_class_contains_initialized_properties_parameter_properties_or_private_identifiers);
                            }
                        }
                    }
                } else if (!classExtendsNull) {
                    error(node, Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call);
                }
            }
        }
    }
    function superCallIsRootLevelInConstructor(superCall, body) {
        const superCallParent = walkUpParenthesizedExpressions(superCall.parent);
        return isExpressionStatement(superCallParent) && superCallParent.parent === body;
    }
    function nodeImmediatelyReferencesSuperOrThis(node) {
        if (node.kind === 106 || node.kind === 108) {
            return true;
        }
        if (isThisContainerOrFunctionBlock(node)) {
            return false;
        }
        return !!forEachChild(node, nodeImmediatelyReferencesSuperOrThis);
    }
    function checkAccessorDeclaration(node) {
        if (isIdentifier(node.name) && idText(node.name) === "constructor") {
            error(node.name, Diagnostics.Class_constructor_may_not_be_an_accessor);
        }
        addLazyDiagnostic(checkAccessorDeclarationDiagnostics);
        checkSourceElement(node.body);
        setNodeLinksForPrivateIdentifierScope(node);
        function checkAccessorDeclarationDiagnostics() {
            if (!checkGrammarFunctionLikeDeclaration(node) && !checkGrammarAccessor(node)) checkGrammarComputedPropertyName(node.name);
            checkDecorators(node);
            checkSignatureDeclaration(node);
            if (node.kind === 174) {
                if (!(node.flags & 16777216) && nodeIsPresent(node.body) && node.flags & 256) {
                    if (!(node.flags & 512)) {
                        error(node.name, Diagnostics.A_get_accessor_must_return_a_value);
                    }
                }
            }
            if (node.name.kind === 164) {
                checkComputedPropertyName(node.name);
            }
            if (hasBindableName(node)) {
                const symbol = getSymbolOfDeclaration(node);
                const getter = getDeclarationOfKind(symbol, 174);
                const setter = getDeclarationOfKind(symbol, 175);
                if (getter && setter && !(getNodeCheckFlags(getter) & 1)) {
                    getNodeLinks(getter).flags |= 1;
                    const getterFlags = getEffectiveModifierFlags(getter);
                    const setterFlags = getEffectiveModifierFlags(setter);
                    if ((getterFlags & 256) !== (setterFlags & 256)) {
                        error(getter.name, Diagnostics.Accessors_must_both_be_abstract_or_non_abstract);
                        error(setter.name, Diagnostics.Accessors_must_both_be_abstract_or_non_abstract);
                    }
                    if (getterFlags & 16 && !(setterFlags & (16 | 8)) || getterFlags & 8 && !(setterFlags & 8)) {
                        error(getter.name, Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter);
                        error(setter.name, Diagnostics.A_get_accessor_must_be_at_least_as_accessible_as_the_setter);
                    }
                    const getterType = getAnnotatedAccessorType(getter);
                    const setterType = getAnnotatedAccessorType(setter);
                    if (getterType && setterType) {
                        checkTypeAssignableTo(getterType, setterType, getter, Diagnostics.The_return_type_of_a_get_accessor_must_be_assignable_to_its_set_accessor_type);
                    }
                }
            }
            const returnType = getTypeOfAccessors(getSymbolOfDeclaration(node));
            if (node.kind === 174) {
                checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType);
            }
        }
    }
    function checkMissingDeclaration(node) {
        checkDecorators(node);
    }
    function getEffectiveTypeArgumentAtIndex(node, typeParameters, index) {
        if (node.typeArguments && index < node.typeArguments.length) {
            return getTypeFromTypeNode(node.typeArguments[index]);
        }
        return getEffectiveTypeArguments2(node, typeParameters)[index];
    }
    function getEffectiveTypeArguments2(node, typeParameters) {
        return fillMissingTypeArguments(map(node.typeArguments, getTypeFromTypeNode), typeParameters, getMinTypeArgumentCount(typeParameters), isInJSFile(node));
    }
    function checkTypeArgumentConstraints(node, typeParameters) {
        let typeArguments;
        let mapper;
        let result = true;
        for (let i = 0; i < typeParameters.length; i++) {
            const constraint = getConstraintOfTypeParameter(typeParameters[i]);
            if (constraint) {
                if (!typeArguments) {
                    typeArguments = getEffectiveTypeArguments2(node, typeParameters);
                    mapper = createTypeMapper(typeParameters, typeArguments);
                }
                result = result && checkTypeAssignableTo(typeArguments[i], instantiateType(constraint, mapper), node.typeArguments[i], Diagnostics.Type_0_does_not_satisfy_the_constraint_1);
            }
        }
        return result;
    }
    function getTypeParametersForTypeAndSymbol(type, symbol) {
        if (!isErrorType(type)) {
            return symbol.flags & 524288 && getSymbolLinks(symbol).typeParameters || (getObjectFlags(type) & 4 ? type.target.localTypeParameters : void 0);
        }
        return void 0;
    }
    function getTypeParametersForTypeReferenceOrImport(node) {
        const type = getTypeFromTypeNode(node);
        if (!isErrorType(type)) {
            const symbol = getNodeLinks(node).resolvedSymbol;
            if (symbol) {
                return getTypeParametersForTypeAndSymbol(type, symbol);
            }
        }
        return void 0;
    }
    function checkTypeReferenceNode(node) {
        checkGrammarTypeArguments(node, node.typeArguments);
        if (node.kind === 180 && !isInJSFile(node) && !isInJSDoc(node) && node.typeArguments && node.typeName.end !== node.typeArguments.pos) {
            const sourceFile = getSourceFileOfNode(node);
            if (scanTokenAtPosition(sourceFile, node.typeName.end) === 24) {
                grammarErrorAtPos(node, skipTrivia(sourceFile.text, node.typeName.end), 1, Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments);
            }
        }
        forEach(node.typeArguments, checkSourceElement);
        checkTypeReferenceOrImport(node);
    }
    function checkTypeReferenceOrImport(node) {
        const type = getTypeFromTypeNode(node);
        if (!isErrorType(type)) {
            if (node.typeArguments) {
                addLazyDiagnostic(() => {
                    const typeParameters = getTypeParametersForTypeReferenceOrImport(node);
                    if (typeParameters) {
                        checkTypeArgumentConstraints(node, typeParameters);
                    }
                });
            }
            const symbol = getNodeLinks(node).resolvedSymbol;
            if (symbol) {
                if (some(symbol.declarations, d => isTypeDeclaration(d) && !!(d.flags & 268435456))) {
                    addDeprecatedSuggestion(getDeprecatedSuggestionNode(node), symbol.declarations, symbol.escapedName);
                }
            }
        }
    }
    function getTypeArgumentConstraint(node) {
        const typeReferenceNode = tryCast(node.parent, isTypeReferenceType);
        if (!typeReferenceNode) return void 0;
        const typeParameters = getTypeParametersForTypeReferenceOrImport(typeReferenceNode);
        if (!typeParameters) return void 0;
        const constraint = getConstraintOfTypeParameter(typeParameters[typeReferenceNode.typeArguments.indexOf(node)]);
        return constraint && instantiateType(constraint, createTypeMapper(typeParameters, getEffectiveTypeArguments2(typeReferenceNode, typeParameters)));
    }
    function checkTypeQuery(node) {
        getTypeFromTypeQueryNode(node);
    }
    function checkTypeLiteral(node) {
        forEach(node.members, checkSourceElement);
        addLazyDiagnostic(checkTypeLiteralDiagnostics);
        function checkTypeLiteralDiagnostics() {
            const type = getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node);
            checkIndexConstraints(type, type.symbol);
            checkTypeForDuplicateIndexSignatures(node);
            checkObjectTypeForDuplicateDeclarations(node);
        }
    }
    function checkArrayType(node) {
        checkSourceElement(node.elementType);
    }
    function checkTupleType(node) {
        const elementTypes = node.elements;
        let seenOptionalElement = false;
        let seenRestElement = false;
        const hasNamedElement = some(elementTypes, isNamedTupleMember);
        for (const e of elementTypes) {
            if (e.kind !== 199 && hasNamedElement) {
                grammarErrorOnNode(e, Diagnostics.Tuple_members_must_all_have_names_or_all_not_have_names);
                break;
            }
            const flags = getTupleElementFlags(e);
            if (flags & 8) {
                const type = getTypeFromTypeNode(e.type);
                if (!isArrayLikeType(type)) {
                    error(e, Diagnostics.A_rest_element_type_must_be_an_array_type);
                    break;
                }
                if (isArrayType(type) || isTupleType(type) && type.target.combinedFlags & 4) {
                    seenRestElement = true;
                }
            } else if (flags & 4) {
                if (seenRestElement) {
                    grammarErrorOnNode(e, Diagnostics.A_rest_element_cannot_follow_another_rest_element);
                    break;
                }
                seenRestElement = true;
            } else if (flags & 2) {
                if (seenRestElement) {
                    grammarErrorOnNode(e, Diagnostics.An_optional_element_cannot_follow_a_rest_element);
                    break;
                }
                seenOptionalElement = true;
            } else if (seenOptionalElement) {
                grammarErrorOnNode(e, Diagnostics.A_required_element_cannot_follow_an_optional_element);
                break;
            }
        }
        forEach(node.elements, checkSourceElement);
        getTypeFromTypeNode(node);
    }
    function checkUnionOrIntersectionType(node) {
        forEach(node.types, checkSourceElement);
        getTypeFromTypeNode(node);
    }
    function checkIndexedAccessIndexType(type, accessNode) {
        if (!(type.flags & 8388608)) {
            return type;
        }
        const objectType = type.objectType;
        const indexType = type.indexType;
        if (isTypeAssignableTo(indexType, getIndexType(objectType, false))) {
            if (accessNode.kind === 209 && isAssignmentTarget(accessNode) && getObjectFlags(objectType) & 32 && getMappedTypeModifiers(objectType) & 1) {
                error(accessNode, Diagnostics.Index_signature_in_type_0_only_permits_reading, typeToString(objectType));
            }
            return type;
        }
        const apparentObjectType = getApparentType(objectType);
        if (getIndexInfoOfType(apparentObjectType, numberType) && isTypeAssignableToKind(indexType, 296)) {
            return type;
        }
        if (isGenericObjectType(objectType)) {
            const propertyName = getPropertyNameFromIndex(indexType, accessNode);
            if (propertyName) {
                const propertySymbol = forEachType(apparentObjectType, t => getPropertyOfType(t, propertyName));
                if (propertySymbol && getDeclarationModifierFlagsFromSymbol(propertySymbol) & 24) {
                    error(accessNode, Diagnostics.Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter, unescapeLeadingUnderscores(propertyName));
                    return errorType;
                }
            }
        }
        error(accessNode, Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(objectType));
        return errorType;
    }
    function checkIndexedAccessType(node) {
        checkSourceElement(node.objectType);
        checkSourceElement(node.indexType);
        checkIndexedAccessIndexType(getTypeFromIndexedAccessTypeNode(node), node);
    }
    function checkMappedType(node) {
        checkGrammarMappedType(node);
        checkSourceElement(node.typeParameter);
        checkSourceElement(node.nameType);
        checkSourceElement(node.type);
        if (!node.type) {
            reportImplicitAny(node, anyType);
        }
        const type = getTypeFromMappedTypeNode(node);
        const nameType = getNameTypeFromMappedType(type);
        if (nameType) {
            checkTypeAssignableTo(nameType, keyofConstraintType, node.nameType);
        } else {
            const constraintType = getConstraintTypeFromMappedType(type);
            checkTypeAssignableTo(constraintType, keyofConstraintType, getEffectiveConstraintOfTypeParameter(node.typeParameter));
        }
    }
    function checkGrammarMappedType(node) {
        var _a2;
        if ((_a2 = node.members) == null ? void 0 : _a2.length) {
            return grammarErrorOnNode(node.members[0], Diagnostics.A_mapped_type_may_not_declare_properties_or_methods);
        }
    }
    function checkThisType(node) {
        getTypeFromThisTypeNode(node);
    }
    function checkTypeOperator(node) {
        checkGrammarTypeOperatorNode(node);
        checkSourceElement(node.type);
    }
    function checkConditionalType(node) {
        forEachChild(node, checkSourceElement);
    }
    function checkInferType(node) {
        if (!findAncestor(node, n => n.parent && n.parent.kind === 191 && n.parent.extendsType === n)) {
            grammarErrorOnNode(node, Diagnostics.infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type);
        }
        checkSourceElement(node.typeParameter);
        const symbol = getSymbolOfDeclaration(node.typeParameter);
        if (symbol.declarations && symbol.declarations.length > 1) {
            const links = getSymbolLinks(symbol);
            if (!links.typeParametersChecked) {
                links.typeParametersChecked = true;
                const typeParameter = getDeclaredTypeOfTypeParameter(symbol);
                const declarations = getDeclarationsOfKind(symbol, 165);
                if (!areTypeParametersIdentical(declarations, [typeParameter], decl => [decl])) {
                    const name = symbolToString(symbol);
                    for (const declaration of declarations) {
                        error(declaration.name, Diagnostics.All_declarations_of_0_must_have_identical_constraints, name);
                    }
                }
            }
        }
        registerForUnusedIdentifiersCheck(node);
    }
    function checkTemplateLiteralType(node) {
        for (const span of node.templateSpans) {
            checkSourceElement(span.type);
            const type = getTypeFromTypeNode(span.type);
            checkTypeAssignableTo(type, templateConstraintType, span.type);
        }
        getTypeFromTypeNode(node);
    }
    function checkImportType(node) {
        checkSourceElement(node.argument);
        if (node.assertions) {
            const override = getResolutionModeOverrideForClause(node.assertions.assertClause, grammarErrorOnNode);
            if (override) {
                if (!isNightly()) {
                    grammarErrorOnNode(node.assertions.assertClause, Diagnostics.resolution_mode_assertions_are_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next);
                }
                if (getEmitModuleResolutionKind(compilerOptions) !== 3 && getEmitModuleResolutionKind(compilerOptions) !== 99) {
                    grammarErrorOnNode(node.assertions.assertClause, Diagnostics.resolution_mode_assertions_are_only_supported_when_moduleResolution_is_node16_or_nodenext);
                }
            }
        }
        checkTypeReferenceOrImport(node);
    }
    function checkNamedTupleMember(node) {
        if (node.dotDotDotToken && node.questionToken) {
            grammarErrorOnNode(node, Diagnostics.A_tuple_member_cannot_be_both_optional_and_rest);
        }
        if (node.type.kind === 187) {
            grammarErrorOnNode(node.type, Diagnostics.A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type);
        }
        if (node.type.kind === 188) {
            grammarErrorOnNode(node.type, Diagnostics.A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type);
        }
        checkSourceElement(node.type);
        getTypeFromTypeNode(node);
    }
    function isPrivateWithinAmbient(node) {
        return (hasEffectiveModifier(node, 8) || isPrivateIdentifierClassElementDeclaration(node)) && !!(node.flags & 16777216);
    }
    function getEffectiveDeclarationFlags(n, flagsToCheck) {
        let flags = getCombinedModifierFlags(n);
        if (n.parent.kind !== 261 && n.parent.kind !== 260 && n.parent.kind !== 228 && n.flags & 16777216) {
            if (!(flags & 2) && !(isModuleBlock(n.parent) && isModuleDeclaration(n.parent.parent) && isGlobalScopeAugmentation(n.parent.parent))) {
                flags |= 1;
            }
            flags |= 2;
        }
        return flags & flagsToCheck;
    }
    function checkFunctionOrConstructorSymbol(symbol) {
        addLazyDiagnostic(() => checkFunctionOrConstructorSymbolWorker(symbol));
    }
    function checkFunctionOrConstructorSymbolWorker(symbol) {
        function getCanonicalOverload(overloads, implementation) {
            const implementationSharesContainerWithFirstOverload = implementation !== void 0 && implementation.parent === overloads[0].parent;
            return implementationSharesContainerWithFirstOverload ? implementation : overloads[0];
        }
        function checkFlagAgreementBetweenOverloads(overloads, implementation, flagsToCheck2, someOverloadFlags, allOverloadFlags) {
            const someButNotAllOverloadFlags = someOverloadFlags ^ allOverloadFlags;
            if (someButNotAllOverloadFlags !== 0) {
                const canonicalFlags = getEffectiveDeclarationFlags(getCanonicalOverload(overloads, implementation), flagsToCheck2);
                forEach(overloads, o => {
                    const deviation = getEffectiveDeclarationFlags(o, flagsToCheck2) ^ canonicalFlags;
                    if (deviation & 1) {
                        error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_exported_or_non_exported);
                    } else if (deviation & 2) {
                        error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_ambient_or_non_ambient);
                    } else if (deviation & (8 | 16)) {
                        error(getNameOfDeclaration(o) || o, Diagnostics.Overload_signatures_must_all_be_public_private_or_protected);
                    } else if (deviation & 256) {
                        error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_abstract_or_non_abstract);
                    }
                });
            }
        }
        function checkQuestionTokenAgreementBetweenOverloads(overloads, implementation, someHaveQuestionToken2, allHaveQuestionToken2) {
            if (someHaveQuestionToken2 !== allHaveQuestionToken2) {
                const canonicalHasQuestionToken = hasQuestionToken(getCanonicalOverload(overloads, implementation));
                forEach(overloads, o => {
                    const deviation = hasQuestionToken(o) !== canonicalHasQuestionToken;
                    if (deviation) {
                        error(getNameOfDeclaration(o), Diagnostics.Overload_signatures_must_all_be_optional_or_required);
                    }
                });
            }
        }
        const flagsToCheck = 1 | 2 | 8 | 16 | 256;
        let someNodeFlags = 0;
        let allNodeFlags = flagsToCheck;
        let someHaveQuestionToken = false;
        let allHaveQuestionToken = true;
        let hasOverloads = false;
        let bodyDeclaration;
        let lastSeenNonAmbientDeclaration;
        let previousDeclaration;
        const declarations = symbol.declarations;
        const isConstructor = (symbol.flags & 16384) !== 0;
        function reportImplementationExpectedError(node) {
            if (node.name && nodeIsMissing(node.name)) {
                return;
            }
            let seen = false;
            const subsequentNode = forEachChild(node.parent, c => {
                if (seen) {
                    return c;
                } else {
                    seen = c === node;
                }
            });
            if (subsequentNode && subsequentNode.pos === node.end) {
                if (subsequentNode.kind === node.kind) {
                    const errorNode2 = subsequentNode.name || subsequentNode;
                    const subsequentName = subsequentNode.name;
                    if (node.name && subsequentName && (isPrivateIdentifier(node.name) && isPrivateIdentifier(subsequentName) && node.name.escapedText === subsequentName.escapedText || isComputedPropertyName(node.name) && isComputedPropertyName(subsequentName) || isPropertyNameLiteral(node.name) && isPropertyNameLiteral(subsequentName) && getEscapedTextOfIdentifierOrLiteral(node.name) === getEscapedTextOfIdentifierOrLiteral(subsequentName))) {
                        const reportError = (node.kind === 171 || node.kind === 170) && isStatic(node) !== isStatic(subsequentNode);
                        if (reportError) {
                            const diagnostic = isStatic(node) ? Diagnostics.Function_overload_must_be_static : Diagnostics.Function_overload_must_not_be_static;
                            error(errorNode2, diagnostic);
                        }
                        return;
                    }
                    if (nodeIsPresent(subsequentNode.body)) {
                        error(errorNode2, Diagnostics.Function_implementation_name_must_be_0, declarationNameToString(node.name));
                        return;
                    }
                }
            }
            const errorNode = node.name || node;
            if (isConstructor) {
                error(errorNode, Diagnostics.Constructor_implementation_is_missing);
            } else {
                if (hasSyntacticModifier(node, 256)) {
                    error(errorNode, Diagnostics.All_declarations_of_an_abstract_method_must_be_consecutive);
                } else {
                    error(errorNode, Diagnostics.Function_implementation_is_missing_or_not_immediately_following_the_declaration);
                }
            }
        }
        let duplicateFunctionDeclaration = false;
        let multipleConstructorImplementation = false;
        let hasNonAmbientClass = false;
        const functionDeclarations = [];
        if (declarations) {
            for (const current of declarations) {
                const node = current;
                const inAmbientContext = node.flags & 16777216;
                const inAmbientContextOrInterface = node.parent && (node.parent.kind === 261 || node.parent.kind === 184) || inAmbientContext;
                if (inAmbientContextOrInterface) {
                    previousDeclaration = void 0;
                }
                if ((node.kind === 260 || node.kind === 228) && !inAmbientContext) {
                    hasNonAmbientClass = true;
                }
                if (node.kind === 259 || node.kind === 171 || node.kind === 170 || node.kind === 173) {
                    functionDeclarations.push(node);
                    const currentNodeFlags = getEffectiveDeclarationFlags(node, flagsToCheck);
                    someNodeFlags |= currentNodeFlags;
                    allNodeFlags &= currentNodeFlags;
                    someHaveQuestionToken = someHaveQuestionToken || hasQuestionToken(node);
                    allHaveQuestionToken = allHaveQuestionToken && hasQuestionToken(node);
                    const bodyIsPresent = nodeIsPresent(node.body);
                    if (bodyIsPresent && bodyDeclaration) {
                        if (isConstructor) {
                            multipleConstructorImplementation = true;
                        } else {
                            duplicateFunctionDeclaration = true;
                        }
                    } else if ((previousDeclaration == null ? void 0 : previousDeclaration.parent) === node.parent && previousDeclaration.end !== node.pos) {
                        reportImplementationExpectedError(previousDeclaration);
                    }
                    if (bodyIsPresent) {
                        if (!bodyDeclaration) {
                            bodyDeclaration = node;
                        }
                    } else {
                        hasOverloads = true;
                    }
                    previousDeclaration = node;
                    if (!inAmbientContextOrInterface) {
                        lastSeenNonAmbientDeclaration = node;
                    }
                }
                if (isInJSFile(current) && isFunctionLike(current) && current.jsDoc) {
                    for (const node2 of current.jsDoc) {
                        if (node2.tags) {
                            for (const tag of node2.tags) {
                                if (isJSDocOverloadTag(tag)) {
                                    hasOverloads = true;
                                }
                            }
                        }
                    }
                }
            }
        }
        if (multipleConstructorImplementation) {
            forEach(functionDeclarations, declaration => {
                error(declaration, Diagnostics.Multiple_constructor_implementations_are_not_allowed);
            });
        }
        if (duplicateFunctionDeclaration) {
            forEach(functionDeclarations, declaration => {
                error(getNameOfDeclaration(declaration) || declaration, Diagnostics.Duplicate_function_implementation);
            });
        }
        if (hasNonAmbientClass && !isConstructor && symbol.flags & 16 && declarations) {
            const relatedDiagnostics = filter(declarations, d => d.kind === 260).map(d => createDiagnosticForNode(d, Diagnostics.Consider_adding_a_declare_modifier_to_this_class));
            forEach(declarations, declaration => {
                const diagnostic = declaration.kind === 260 ? Diagnostics.Class_declaration_cannot_implement_overload_list_for_0 : declaration.kind === 259 ? Diagnostics.Function_with_bodies_can_only_merge_with_classes_that_are_ambient : void 0;
                if (diagnostic) {
                    addRelatedInfo(error(getNameOfDeclaration(declaration) || declaration, diagnostic, symbolName(symbol)), ...relatedDiagnostics);
                }
            });
        }
        if (lastSeenNonAmbientDeclaration && !lastSeenNonAmbientDeclaration.body && !hasSyntacticModifier(lastSeenNonAmbientDeclaration, 256) && !lastSeenNonAmbientDeclaration.questionToken) {
            reportImplementationExpectedError(lastSeenNonAmbientDeclaration);
        }
        if (hasOverloads) {
            if (declarations) {
                checkFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags);
                checkQuestionTokenAgreementBetweenOverloads(declarations, bodyDeclaration, someHaveQuestionToken, allHaveQuestionToken);
            }
            if (bodyDeclaration) {
                const signatures = getSignaturesOfSymbol(symbol);
                const bodySignature = getSignatureFromDeclaration(bodyDeclaration);
                for (const signature of signatures) {
                    if (!isImplementationCompatibleWithOverload(bodySignature, signature)) {
                        const errorNode = signature.declaration && isJSDocSignature(signature.declaration) ? signature.declaration.parent.tagName : signature.declaration;
                        addRelatedInfo(error(errorNode, Diagnostics.This_overload_signature_is_not_compatible_with_its_implementation_signature), createDiagnosticForNode(bodyDeclaration, Diagnostics.The_implementation_signature_is_declared_here));
                        break;
                    }
                }
            }
        }
    }
    function checkExportsOnMergedDeclarations(node) {
        addLazyDiagnostic(() => checkExportsOnMergedDeclarationsWorker(node));
    }
    function checkExportsOnMergedDeclarationsWorker(node) {
        let symbol = node.localSymbol;
        if (!symbol) {
            symbol = getSymbolOfDeclaration(node);
            if (!symbol.exportSymbol) {
                return;
            }
        }
        if (getDeclarationOfKind(symbol, node.kind) !== node) {
            return;
        }
        let exportedDeclarationSpaces = 0;
        let nonExportedDeclarationSpaces = 0;
        let defaultExportedDeclarationSpaces = 0;
        for (const d of symbol.declarations) {
            const declarationSpaces = getDeclarationSpaces(d);
            const effectiveDeclarationFlags = getEffectiveDeclarationFlags(d, 1 | 1024);
            if (effectiveDeclarationFlags & 1) {
                if (effectiveDeclarationFlags & 1024) {
                    defaultExportedDeclarationSpaces |= declarationSpaces;
                } else {
                    exportedDeclarationSpaces |= declarationSpaces;
                }
            } else {
                nonExportedDeclarationSpaces |= declarationSpaces;
            }
        }
        const nonDefaultExportedDeclarationSpaces = exportedDeclarationSpaces | nonExportedDeclarationSpaces;
        const commonDeclarationSpacesForExportsAndLocals = exportedDeclarationSpaces & nonExportedDeclarationSpaces;
        const commonDeclarationSpacesForDefaultAndNonDefault = defaultExportedDeclarationSpaces & nonDefaultExportedDeclarationSpaces;
        if (commonDeclarationSpacesForExportsAndLocals || commonDeclarationSpacesForDefaultAndNonDefault) {
            for (const d of symbol.declarations) {
                const declarationSpaces = getDeclarationSpaces(d);
                const name = getNameOfDeclaration(d);
                if (declarationSpaces & commonDeclarationSpacesForDefaultAndNonDefault) {
                    error(name, Diagnostics.Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead, declarationNameToString(name));
                } else if (declarationSpaces & commonDeclarationSpacesForExportsAndLocals) {
                    error(name, Diagnostics.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local, declarationNameToString(name));
                }
            }
        }
        function getDeclarationSpaces(decl) {
            let d = decl;
            switch (d.kind) {
                case 261:
                case 262:
                case 349:
                case 341:
                case 343:
                    return 2;
                case 264:
                    return isAmbientModule(d) || getModuleInstanceState(d) !== 0 ? 4 | 1 : 4;
                case 260:
                case 263:
                case 302:
                    return 2 | 1;
                case 308:
                    return 2 | 1 | 4;
                case 274:
                case 223:
                    const node2 = d;
                    const expression = isExportAssignment(node2) ? node2.expression : node2.right;
                    if (!isEntityNameExpression(expression)) {
                        return 1;
                    }
                    d = expression;
                case 268:
                case 271:
                case 270:
                    let result = 0;
                    const target = resolveAlias(getSymbolOfDeclaration(d));
                    forEach(target.declarations, d2 => {
                        result |= getDeclarationSpaces(d2);
                    });
                    return result;
                case 257:
                case 205:
                case 259:
                case 273:
                case 79:
                    return 1;
                case 170:
                case 168:
                    return 2;
                default:
                    return Debug.failBadSyntaxKind(d);
            }
        }
    }
    function getAwaitedTypeOfPromise(type, errorNode, diagnosticMessage, arg0) {
        const promisedType = getPromisedTypeOfPromise(type, errorNode);
        return promisedType && getAwaitedType(promisedType, errorNode, diagnosticMessage, arg0);
    }
    function getPromisedTypeOfPromise(type, errorNode, thisTypeForErrorOut) {
        if (isTypeAny(type)) {
            return void 0;
        }
        const typeAsPromise = type;
        if (typeAsPromise.promisedTypeOfPromise) {
            return typeAsPromise.promisedTypeOfPromise;
        }
        if (isReferenceToType2(type, getGlobalPromiseType(false))) {
            return typeAsPromise.promisedTypeOfPromise = getTypeArguments(type)[0];
        }
        if (allTypesAssignableToKind(getBaseConstraintOrType(type), 134348796 | 131072)) {
            return void 0;
        }
        const thenFunction = getTypeOfPropertyOfType(type, "then");
        if (isTypeAny(thenFunction)) {
            return void 0;
        }
        const thenSignatures = thenFunction ? getSignaturesOfType(thenFunction, 0) : emptyArray;
        if (thenSignatures.length === 0) {
            if (errorNode) {
                error(errorNode, Diagnostics.A_promise_must_have_a_then_method);
            }
            return void 0;
        }
        let thisTypeForError;
        let candidates;
        for (const thenSignature of thenSignatures) {
            const thisType = getThisTypeOfSignature(thenSignature);
            if (thisType && thisType !== voidType && !isTypeRelatedTo(type, thisType, subtypeRelation)) {
                thisTypeForError = thisType;
            } else {
                candidates = append(candidates, thenSignature);
            }
        }
        if (!candidates) {
            Debug.assertIsDefined(thisTypeForError);
            if (thisTypeForErrorOut) {
                thisTypeForErrorOut.value = thisTypeForError;
            }
            if (errorNode) {
                error(errorNode, Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1, typeToString(type), typeToString(thisTypeForError));
            }
            return void 0;
        }
        const onfulfilledParameterType = getTypeWithFacts(getUnionType(map(candidates, getTypeOfFirstParameterOfSignature)), 2097152);
        if (isTypeAny(onfulfilledParameterType)) {
            return void 0;
        }
        const onfulfilledParameterSignatures = getSignaturesOfType(onfulfilledParameterType, 0);
        if (onfulfilledParameterSignatures.length === 0) {
            if (errorNode) {
                error(errorNode, Diagnostics.The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback);
            }
            return void 0;
        }
        return typeAsPromise.promisedTypeOfPromise = getUnionType(map(onfulfilledParameterSignatures, getTypeOfFirstParameterOfSignature), 2);
    }
    function checkAwaitedType(type, withAlias, errorNode, diagnosticMessage, arg0) {
        const awaitedType = withAlias ? getAwaitedType(type, errorNode, diagnosticMessage, arg0) : getAwaitedTypeNoAlias(type, errorNode, diagnosticMessage, arg0);
        return awaitedType || errorType;
    }
    function isThenableType(type) {
        if (allTypesAssignableToKind(getBaseConstraintOrType(type), 134348796 | 131072)) {
            return false;
        }
        const thenFunction = getTypeOfPropertyOfType(type, "then");
        return !!thenFunction && getSignaturesOfType(getTypeWithFacts(thenFunction, 2097152), 0).length > 0;
    }
    function isAwaitedTypeInstantiation(type) {
        var _a2;
        if (type.flags & 16777216) {
            const awaitedSymbol = getGlobalAwaitedSymbol(false);
            return !!awaitedSymbol && type.aliasSymbol === awaitedSymbol && ((_a2 = type.aliasTypeArguments) == null ? void 0 : _a2.length) === 1;
        }
        return false;
    }
    function unwrapAwaitedType(type) {
        return type.flags & 1048576 ? mapType(type, unwrapAwaitedType) : isAwaitedTypeInstantiation(type) ? type.aliasTypeArguments[0] : type;
    }
    function isAwaitedTypeNeeded(type) {
        if (isTypeAny(type) || isAwaitedTypeInstantiation(type)) {
            return false;
        }
        if (isGenericObjectType(type)) {
            const baseConstraint = getBaseConstraintOfType(type);
            if (baseConstraint ? baseConstraint.flags & 3 || isEmptyObjectType(baseConstraint) || someType(baseConstraint, isThenableType) : maybeTypeOfKind(type, 8650752)) {
                return true;
            }
        }
        return false;
    }
    function tryCreateAwaitedType(type) {
        const awaitedSymbol = getGlobalAwaitedSymbol(true);
        if (awaitedSymbol) {
            return getTypeAliasInstantiation(awaitedSymbol, [unwrapAwaitedType(type)]);
        }
        return void 0;
    }
    function createAwaitedTypeIfNeeded(type) {
        if (isAwaitedTypeNeeded(type)) {
            const awaitedType = tryCreateAwaitedType(type);
            if (awaitedType) {
                return awaitedType;
            }
        }
        Debug.assert(isAwaitedTypeInstantiation(type) || getPromisedTypeOfPromise(type) === void 0, "type provided should not be a non-generic 'promise'-like.");
        return type;
    }
    function getAwaitedType(type, errorNode, diagnosticMessage, arg0) {
        const awaitedType = getAwaitedTypeNoAlias(type, errorNode, diagnosticMessage, arg0);
        return awaitedType && createAwaitedTypeIfNeeded(awaitedType);
    }
    function getAwaitedTypeNoAlias(type, errorNode, diagnosticMessage, arg0) {
        if (isTypeAny(type)) {
            return type;
        }
        if (isAwaitedTypeInstantiation(type)) {
            return type;
        }
        const typeAsAwaitable = type;
        if (typeAsAwaitable.awaitedTypeOfType) {
            return typeAsAwaitable.awaitedTypeOfType;
        }
        if (type.flags & 1048576) {
            if (awaitedTypeStack.lastIndexOf(type.id) >= 0) {
                if (errorNode) {
                    error(errorNode, Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method);
                }
                return void 0;
            }
            const mapper = errorNode ? constituentType => getAwaitedTypeNoAlias(constituentType, errorNode, diagnosticMessage, arg0) : getAwaitedTypeNoAlias;
            awaitedTypeStack.push(type.id);
            const mapped = mapType(type, mapper);
            awaitedTypeStack.pop();
            return typeAsAwaitable.awaitedTypeOfType = mapped;
        }
        if (isAwaitedTypeNeeded(type)) {
            return typeAsAwaitable.awaitedTypeOfType = type;
        }
        const thisTypeForErrorOut = {
            value: void 0
        };
        const promisedType = getPromisedTypeOfPromise(type, void 0, thisTypeForErrorOut);
        if (promisedType) {
            if (type.id === promisedType.id || awaitedTypeStack.lastIndexOf(promisedType.id) >= 0) {
                if (errorNode) {
                    error(errorNode, Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method);
                }
                return void 0;
            }
            awaitedTypeStack.push(type.id);
            const awaitedType = getAwaitedTypeNoAlias(promisedType, errorNode, diagnosticMessage, arg0);
            awaitedTypeStack.pop();
            if (!awaitedType) {
                return void 0;
            }
            return typeAsAwaitable.awaitedTypeOfType = awaitedType;
        }
        if (isThenableType(type)) {
            if (errorNode) {
                Debug.assertIsDefined(diagnosticMessage);
                let chain;
                if (thisTypeForErrorOut.value) {
                    chain = chainDiagnosticMessages(chain, Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1, typeToString(type), typeToString(thisTypeForErrorOut.value));
                }
                chain = chainDiagnosticMessages(chain, diagnosticMessage, arg0);
                diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(errorNode), errorNode, chain));
            }
            return void 0;
        }
        return typeAsAwaitable.awaitedTypeOfType = type;
    }
    function checkAsyncFunctionReturnType(node, returnTypeNode) {
        const returnType = getTypeFromTypeNode(returnTypeNode);
        if (languageVersion >= 2) {
            if (isErrorType(returnType)) {
                return;
            }
            const globalPromiseType = getGlobalPromiseType(true);
            if (globalPromiseType !== emptyGenericType && !isReferenceToType2(returnType, globalPromiseType)) {
                error(returnTypeNode, Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0, typeToString(getAwaitedTypeNoAlias(returnType) || voidType));
                return;
            }
        } else {
            markTypeNodeAsReferenced(returnTypeNode);
            if (isErrorType(returnType)) {
                return;
            }
            const promiseConstructorName = getEntityNameFromTypeNode(returnTypeNode);
            if (promiseConstructorName === void 0) {
                error(returnTypeNode, Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, typeToString(returnType));
                return;
            }
            const promiseConstructorSymbol = resolveEntityName(promiseConstructorName, 111551, true);
            const promiseConstructorType = promiseConstructorSymbol ? getTypeOfSymbol(promiseConstructorSymbol) : errorType;
            if (isErrorType(promiseConstructorType)) {
                if (promiseConstructorName.kind === 79 && promiseConstructorName.escapedText === "Promise" && getTargetType(returnType) === getGlobalPromiseType(false)) {
                    error(returnTypeNode, Diagnostics.An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option);
                } else {
                    error(returnTypeNode, Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, entityNameToString(promiseConstructorName));
                }
                return;
            }
            const globalPromiseConstructorLikeType = getGlobalPromiseConstructorLikeType(true);
            if (globalPromiseConstructorLikeType === emptyObjectType) {
                error(returnTypeNode, Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, entityNameToString(promiseConstructorName));
                return;
            }
            if (!checkTypeAssignableTo(promiseConstructorType, globalPromiseConstructorLikeType, returnTypeNode, Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value)) {
                return;
            }
            const rootName = promiseConstructorName && getFirstIdentifier(promiseConstructorName);
            const collidingSymbol = getSymbol2(node.locals, rootName.escapedText, 111551);
            if (collidingSymbol) {
                error(collidingSymbol.valueDeclaration, Diagnostics.Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions, idText(rootName), entityNameToString(promiseConstructorName));
                return;
            }
        }
        checkAwaitedType(returnType, false, node, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
    }
    function checkDecorator(node) {
        const signature = getResolvedSignature(node);
        checkDeprecatedSignature(signature, node);
        const returnType = getReturnTypeOfSignature(signature);
        if (returnType.flags & 1) {
            return;
        }
        const decoratorSignature = getDecoratorCallSignature(node);
        if (!(decoratorSignature == null ? void 0 : decoratorSignature.resolvedReturnType)) return;
        let headMessage;
        const expectedReturnType = decoratorSignature.resolvedReturnType;
        switch (node.parent.kind) {
            case 260:
            case 228:
                headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1;
                break;
            case 169:
                if (!legacyDecorators) {
                    headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1;
                    break;
                }
            case 166:
                headMessage = Diagnostics.Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any;
                break;
            case 171:
            case 174:
            case 175:
                headMessage = Diagnostics.Decorator_function_return_type_0_is_not_assignable_to_type_1;
                break;
            default:
                return Debug.failBadSyntaxKind(node.parent);
        }
        checkTypeAssignableTo(returnType, expectedReturnType, node.expression, headMessage);
    }
    function createCallSignature(typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount = parameters.length, flags = 0) {
        const decl = factory.createFunctionTypeNode(void 0, emptyArray, factory.createKeywordTypeNode(131));
        return createSignature(decl, typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags);
    }
    function createFunctionType(typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags) {
        const signature = createCallSignature(typeParameters, thisParameter, parameters, returnType, typePredicate, minArgumentCount, flags);
        return getOrCreateTypeFromSignature(signature);
    }
    function createGetterFunctionType(type) {
        return createFunctionType(void 0, void 0, emptyArray, type);
    }
    function createSetterFunctionType(type) {
        const valueParam = createParameter("value", type);
        return createFunctionType(void 0, void 0, [valueParam], voidType);
    }
    function markTypeNodeAsReferenced(node) {
        markEntityNameOrEntityExpressionAsReference(node && getEntityNameFromTypeNode(node), false);
    }
    function markEntityNameOrEntityExpressionAsReference(typeName, forDecoratorMetadata) {
        if (!typeName) return;
        const rootName = getFirstIdentifier(typeName);
        const meaning = (typeName.kind === 79 ? 788968 : 1920) | 2097152;
        const rootSymbol = resolveName(rootName, rootName.escapedText, meaning, void 0, void 0, true);
        if (rootSymbol && rootSymbol.flags & 2097152) {
            if (!compilerOptions.verbatimModuleSyntax && symbolIsValue(rootSymbol) && !isConstEnumOrConstEnumOnlyModule(resolveAlias(rootSymbol)) && !getTypeOnlyAliasDeclaration(rootSymbol)) {
                markAliasSymbolAsReferenced(rootSymbol);
            } else if (forDecoratorMetadata && getIsolatedModules(compilerOptions) && getEmitModuleKind(compilerOptions) >= 5 && !symbolIsValue(rootSymbol) && !some(rootSymbol.declarations, isTypeOnlyImportOrExportDeclaration)) {
                const diag2 = error(typeName, Diagnostics.A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_when_isolatedModules_and_emitDecoratorMetadata_are_enabled);
                const aliasDeclaration = find(rootSymbol.declarations || emptyArray, isAliasSymbolDeclaration2);
                if (aliasDeclaration) {
                    addRelatedInfo(diag2, createDiagnosticForNode(aliasDeclaration, Diagnostics._0_was_imported_here, idText(rootName)));
                }
            }
        }
    }
    function markDecoratorMedataDataTypeNodeAsReferenced(node) {
        const entityName = getEntityNameForDecoratorMetadata(node);
        if (entityName && isEntityName(entityName)) {
            markEntityNameOrEntityExpressionAsReference(entityName, true);
        }
    }
    function getEntityNameForDecoratorMetadata(node) {
        if (node) {
            switch (node.kind) {
                case 190:
                case 189:
                    return getEntityNameForDecoratorMetadataFromTypeList(node.types);
                case 191:
                    return getEntityNameForDecoratorMetadataFromTypeList([node.trueType, node.falseType]);
                case 193:
                case 199:
                    return getEntityNameForDecoratorMetadata(node.type);
                case 180:
                    return node.typeName;
            }
        }
    }
    function getEntityNameForDecoratorMetadataFromTypeList(types) {
        let commonEntityName;
        for (let typeNode of types) {
            while (typeNode.kind === 193 || typeNode.kind === 199) {
                typeNode = typeNode.type;
            }
            if (typeNode.kind === 144) {
                continue;
            }
            if (!strictNullChecks && (typeNode.kind === 198 && typeNode.literal.kind === 104 || typeNode.kind === 155)) {
                continue;
            }
            const individualEntityName = getEntityNameForDecoratorMetadata(typeNode);
            if (!individualEntityName) {
                return void 0;
            }
            if (commonEntityName) {
                if (!isIdentifier(commonEntityName) || !isIdentifier(individualEntityName) || commonEntityName.escapedText !== individualEntityName.escapedText) {
                    return void 0;
                }
            } else {
                commonEntityName = individualEntityName;
            }
        }
        return commonEntityName;
    }
    function getParameterTypeNodeForDecoratorCheck(node) {
        const typeNode = getEffectiveTypeAnnotationNode(node);
        return isRestParameter(node) ? getRestParameterElementType(typeNode) : typeNode;
    }
    function checkDecorators(node) {
        if (!canHaveDecorators(node) || !hasDecorators(node) || !node.modifiers || !nodeCanBeDecorated(legacyDecorators, node, node.parent, node.parent.parent)) {
            return;
        }
        const firstDecorator = find(node.modifiers, isDecorator);
        if (!firstDecorator) {
            return;
        }
        if (legacyDecorators) {
            checkExternalEmitHelpers(firstDecorator, 8);
            if (node.kind === 166) {
                checkExternalEmitHelpers(firstDecorator, 32);
            }
        } else if (languageVersion < 99) {
            checkExternalEmitHelpers(firstDecorator, 8);
            if (isClassDeclaration(node)) {
                if (!node.name) {
                    checkExternalEmitHelpers(firstDecorator, 8388608);
                } else {
                    const member = getFirstTransformableStaticClassElement(node);
                    if (member) {
                        checkExternalEmitHelpers(firstDecorator, 8388608);
                    }
                }
            } else if (!isClassExpression(node)) {
                if (isPrivateIdentifier(node.name) && (isMethodDeclaration(node) || isAccessor(node) || isAutoAccessorPropertyDeclaration(node))) {
                    checkExternalEmitHelpers(firstDecorator, 8388608);
                }
                if (isComputedPropertyName(node.name)) {
                    checkExternalEmitHelpers(firstDecorator, 16777216);
                }
            }
        }
        if (compilerOptions.emitDecoratorMetadata) {
            checkExternalEmitHelpers(firstDecorator, 16);
            switch (node.kind) {
                case 260:
                    const constructor = getFirstConstructorWithBody(node);
                    if (constructor) {
                        for (const parameter of constructor.parameters) {
                            markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));
                        }
                    }
                    break;
                case 174:
                case 175:
                    const otherKind = node.kind === 174 ? 175 : 174;
                    const otherAccessor = getDeclarationOfKind(getSymbolOfDeclaration(node), otherKind);
                    markDecoratorMedataDataTypeNodeAsReferenced(getAnnotatedAccessorTypeNode(node) || otherAccessor && getAnnotatedAccessorTypeNode(otherAccessor));
                    break;
                case 171:
                    for (const parameter of node.parameters) {
                        markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));
                    }
                    markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveReturnTypeNode(node));
                    break;
                case 169:
                    markDecoratorMedataDataTypeNodeAsReferenced(getEffectiveTypeAnnotationNode(node));
                    break;
                case 166:
                    markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(node));
                    const containingSignature = node.parent;
                    for (const parameter of containingSignature.parameters) {
                        markDecoratorMedataDataTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));
                    }
                    break;
            }
        }
        for (const modifier of node.modifiers) {
            if (isDecorator(modifier)) {
                checkDecorator(modifier);
            }
        }
    }
    function checkFunctionDeclaration(node) {
        addLazyDiagnostic(checkFunctionDeclarationDiagnostics);
        function checkFunctionDeclarationDiagnostics() {
            checkFunctionOrMethodDeclaration(node);
            checkGrammarForGenerator(node);
            checkCollisionsForDeclarationName(node, node.name);
        }
    }
    function checkJSDocTypeAliasTag(node) {
        if (!node.typeExpression) {
            error(node.name, Diagnostics.JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags);
        }
        if (node.name) {
            checkTypeNameIsReserved(node.name, Diagnostics.Type_alias_name_cannot_be_0);
        }
        checkSourceElement(node.typeExpression);
        checkTypeParameters(getEffectiveTypeParameterDeclarations(node));
    }
    function checkJSDocTemplateTag(node) {
        checkSourceElement(node.constraint);
        for (const tp of node.typeParameters) {
            checkSourceElement(tp);
        }
    }
    function checkJSDocTypeTag(node) {
        checkSourceElement(node.typeExpression);
    }
    function checkJSDocSatisfiesTag(node) {
        checkSourceElement(node.typeExpression);
        const host2 = getEffectiveJSDocHost(node);
        if (host2) {
            const tags = getAllJSDocTags(host2, isJSDocSatisfiesTag);
            if (length(tags) > 1) {
                for (let i = 1; i < length(tags); i++) {
                    const tagName = tags[i].tagName;
                    error(tagName, Diagnostics._0_tag_already_specified, idText(tagName));
                }
            }
        }
    }
    function checkJSDocLinkLikeTag(node) {
        if (node.name) {
            resolveJSDocMemberName(node.name, true);
        }
    }
    function checkJSDocParameterTag(node) {
        checkSourceElement(node.typeExpression);
    }
    function checkJSDocPropertyTag(node) {
        checkSourceElement(node.typeExpression);
    }
    function checkJSDocFunctionType(node) {
        addLazyDiagnostic(checkJSDocFunctionTypeImplicitAny);
        checkSignatureDeclaration(node);
        function checkJSDocFunctionTypeImplicitAny() {
            if (!node.type && !isJSDocConstructSignature(node)) {
                reportImplicitAny(node, anyType);
            }
        }
    }
    function checkJSDocImplementsTag(node) {
        const classLike = getEffectiveJSDocHost(node);
        if (!classLike || !isClassDeclaration(classLike) && !isClassExpression(classLike)) {
            error(classLike, Diagnostics.JSDoc_0_is_not_attached_to_a_class, idText(node.tagName));
        }
    }
    function checkJSDocAugmentsTag(node) {
        const classLike = getEffectiveJSDocHost(node);
        if (!classLike || !isClassDeclaration(classLike) && !isClassExpression(classLike)) {
            error(classLike, Diagnostics.JSDoc_0_is_not_attached_to_a_class, idText(node.tagName));
            return;
        }
        const augmentsTags = getJSDocTags(classLike).filter(isJSDocAugmentsTag);
        Debug.assert(augmentsTags.length > 0);
        if (augmentsTags.length > 1) {
            error(augmentsTags[1], Diagnostics.Class_declarations_cannot_have_more_than_one_augments_or_extends_tag);
        }
        const name = getIdentifierFromEntityNameExpression(node.class.expression);
        const extend2 = getClassExtendsHeritageElement(classLike);
        if (extend2) {
            const className = getIdentifierFromEntityNameExpression(extend2.expression);
            if (className && name.escapedText !== className.escapedText) {
                error(name, Diagnostics.JSDoc_0_1_does_not_match_the_extends_2_clause, idText(node.tagName), idText(name), idText(className));
            }
        }
    }
    function checkJSDocAccessibilityModifiers(node) {
        const host2 = getJSDocHost(node);
        if (host2 && isPrivateIdentifierClassElementDeclaration(host2)) {
            error(node, Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier);
        }
    }
    function getIdentifierFromEntityNameExpression(node) {
        switch (node.kind) {
            case 79:
                return node;
            case 208:
                return node.name;
            default:
                return void 0;
        }
    }
    function checkFunctionOrMethodDeclaration(node) {
        var _a2;
        checkDecorators(node);
        checkSignatureDeclaration(node);
        const functionFlags = getFunctionFlags(node);
        if (node.name && node.name.kind === 164) {
            checkComputedPropertyName(node.name);
        }
        if (hasBindableName(node)) {
            const symbol = getSymbolOfDeclaration(node);
            const localSymbol = node.localSymbol || symbol;
            const firstDeclaration = (_a2 = localSymbol.declarations) == null ? void 0 : _a2.find(declaration => declaration.kind === node.kind && !(declaration.flags & 262144));
            if (node === firstDeclaration) {
                checkFunctionOrConstructorSymbol(localSymbol);
            }
            if (symbol.parent) {
                checkFunctionOrConstructorSymbol(symbol);
            }
        }
        const body = node.kind === 170 ? void 0 : node.body;
        checkSourceElement(body);
        checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, getReturnTypeFromAnnotation(node));
        addLazyDiagnostic(checkFunctionOrMethodDeclarationDiagnostics);
        if (isInJSFile(node)) {
            const typeTag = getJSDocTypeTag(node);
            if (typeTag && typeTag.typeExpression && !getContextualCallSignature(getTypeFromTypeNode(typeTag.typeExpression), node)) {
                error(typeTag.typeExpression.type, Diagnostics.The_type_of_a_function_declaration_must_match_the_function_s_signature);
            }
        }
        function checkFunctionOrMethodDeclarationDiagnostics() {
            if (!getEffectiveReturnTypeNode(node)) {
                if (nodeIsMissing(body) && !isPrivateWithinAmbient(node)) {
                    reportImplicitAny(node, anyType);
                }
                if (functionFlags & 1 && nodeIsPresent(body)) {
                    getReturnTypeOfSignature(getSignatureFromDeclaration(node));
                }
            }
        }
    }
    function registerForUnusedIdentifiersCheck(node) {
        addLazyDiagnostic(registerForUnusedIdentifiersCheckDiagnostics);
        function registerForUnusedIdentifiersCheckDiagnostics() {
            const sourceFile = getSourceFileOfNode(node);
            let potentiallyUnusedIdentifiers = allPotentiallyUnusedIdentifiers.get(sourceFile.path);
            if (!potentiallyUnusedIdentifiers) {
                potentiallyUnusedIdentifiers = [];
                allPotentiallyUnusedIdentifiers.set(sourceFile.path, potentiallyUnusedIdentifiers);
            }
            potentiallyUnusedIdentifiers.push(node);
        }
    }
    function checkUnusedIdentifiers(potentiallyUnusedIdentifiers, addDiagnostic) {
        for (const node of potentiallyUnusedIdentifiers) {
            switch (node.kind) {
                case 260:
                case 228:
                    checkUnusedClassMembers(node, addDiagnostic);
                    checkUnusedTypeParameters(node, addDiagnostic);
                    break;
                case 308:
                case 264:
                case 238:
                case 266:
                case 245:
                case 246:
                case 247:
                    checkUnusedLocalsAndParameters(node, addDiagnostic);
                    break;
                case 173:
                case 215:
                case 259:
                case 216:
                case 171:
                case 174:
                case 175:
                    if (node.body) {
                        checkUnusedLocalsAndParameters(node, addDiagnostic);
                    }
                    checkUnusedTypeParameters(node, addDiagnostic);
                    break;
                case 170:
                case 176:
                case 177:
                case 181:
                case 182:
                case 262:
                case 261:
                    checkUnusedTypeParameters(node, addDiagnostic);
                    break;
                case 192:
                    checkUnusedInferTypeParameter(node, addDiagnostic);
                    break;
                default:
                    Debug.assertNever(node, "Node should not have been registered for unused identifiers check");
            }
        }
    }
    function errorUnusedLocal(declaration, name, addDiagnostic) {
        const node = getNameOfDeclaration(declaration) || declaration;
        const message = isTypeDeclaration(declaration) ? Diagnostics._0_is_declared_but_never_used : Diagnostics._0_is_declared_but_its_value_is_never_read;
        addDiagnostic(declaration, 0, createDiagnosticForNode(node, message, name));
    }
    function isIdentifierThatStartsWithUnderscore(node) {
        return isIdentifier(node) && idText(node).charCodeAt(0) === 95;
    }
    function checkUnusedClassMembers(node, addDiagnostic) {
        for (const member of node.members) {
            switch (member.kind) {
                case 171:
                case 169:
                case 174:
                case 175:
                    if (member.kind === 175 && member.symbol.flags & 32768) {
                        break;
                    }
                    const symbol = getSymbolOfDeclaration(member);
                    if (!symbol.isReferenced && (hasEffectiveModifier(member, 8) || isNamedDeclaration(member) && isPrivateIdentifier(member.name)) && !(member.flags & 16777216)) {
                        addDiagnostic(member, 0, createDiagnosticForNode(member.name, Diagnostics._0_is_declared_but_its_value_is_never_read, symbolToString(symbol)));
                    }
                    break;
                case 173:
                    for (const parameter of member.parameters) {
                        if (!parameter.symbol.isReferenced && hasSyntacticModifier(parameter, 8)) {
                            addDiagnostic(parameter, 0, createDiagnosticForNode(parameter.name, Diagnostics.Property_0_is_declared_but_its_value_is_never_read, symbolName(parameter.symbol)));
                        }
                    }
                    break;
                case 178:
                case 237:
                case 172:
                    break;
                default:
                    Debug.fail("Unexpected class member");
            }
        }
    }
    function checkUnusedInferTypeParameter(node, addDiagnostic) {
        const {
            typeParameter
        } = node;
        if (isTypeParameterUnused(typeParameter)) {
            addDiagnostic(node, 1, createDiagnosticForNode(node, Diagnostics._0_is_declared_but_its_value_is_never_read, idText(typeParameter.name)));
        }
    }
    function checkUnusedTypeParameters(node, addDiagnostic) {
        const declarations = getSymbolOfDeclaration(node).declarations;
        if (!declarations || last(declarations) !== node) return;
        const typeParameters = getEffectiveTypeParameterDeclarations(node);
        const seenParentsWithEveryUnused = /* @__PURE__ */new Set();
        for (const typeParameter of typeParameters) {
            if (!isTypeParameterUnused(typeParameter)) continue;
            const name = idText(typeParameter.name);
            const {
                parent: parent2
            } = typeParameter;
            if (parent2.kind !== 192 && parent2.typeParameters.every(isTypeParameterUnused)) {
                if (tryAddToSet(seenParentsWithEveryUnused, parent2)) {
                    const sourceFile = getSourceFileOfNode(parent2);
                    const range = isJSDocTemplateTag(parent2) ? rangeOfNode(parent2) : rangeOfTypeParameters(sourceFile, parent2.typeParameters);
                    const only = parent2.typeParameters.length === 1;
                    const message = only ? Diagnostics._0_is_declared_but_its_value_is_never_read : Diagnostics.All_type_parameters_are_unused;
                    const arg0 = only ? name : void 0;
                    addDiagnostic(typeParameter, 1, createFileDiagnostic(sourceFile, range.pos, range.end - range.pos, message, arg0));
                }
            } else {
                addDiagnostic(typeParameter, 1, createDiagnosticForNode(typeParameter, Diagnostics._0_is_declared_but_its_value_is_never_read, name));
            }
        }
    }
    function isTypeParameterUnused(typeParameter) {
        return !(getMergedSymbol(typeParameter.symbol).isReferenced & 262144) && !isIdentifierThatStartsWithUnderscore(typeParameter.name);
    }
    function addToGroup(map2, key, value, getKey) {
        const keyString = String(getKey(key));
        const group2 = map2.get(keyString);
        if (group2) {
            group2[1].push(value);
        } else {
            map2.set(keyString, [key, [value]]);
        }
    }
    function tryGetRootParameterDeclaration(node) {
        return tryCast(getRootDeclaration(node), isParameter);
    }
    function isValidUnusedLocalDeclaration(declaration) {
        if (isBindingElement(declaration)) {
            if (isObjectBindingPattern(declaration.parent)) {
                return !!(declaration.propertyName && isIdentifierThatStartsWithUnderscore(declaration.name));
            }
            return isIdentifierThatStartsWithUnderscore(declaration.name);
        }
        return isAmbientModule(declaration) || (isVariableDeclaration(declaration) && isForInOrOfStatement(declaration.parent.parent) || isImportedDeclaration(declaration)) && isIdentifierThatStartsWithUnderscore(declaration.name);
    }
    function checkUnusedLocalsAndParameters(nodeWithLocals, addDiagnostic) {
        const unusedImports = /* @__PURE__ */new Map();
        const unusedDestructures = /* @__PURE__ */new Map();
        const unusedVariables = /* @__PURE__ */new Map();
        nodeWithLocals.locals.forEach(local => {
            if (local.flags & 262144 ? !(local.flags & 3 && !(local.isReferenced & 3)) : local.isReferenced || local.exportSymbol) {
                return;
            }
            if (local.declarations) {
                for (const declaration of local.declarations) {
                    if (isValidUnusedLocalDeclaration(declaration)) {
                        continue;
                    }
                    if (isImportedDeclaration(declaration)) {
                        addToGroup(unusedImports, importClauseFromImported(declaration), declaration, getNodeId);
                    } else if (isBindingElement(declaration) && isObjectBindingPattern(declaration.parent)) {
                        const lastElement = last(declaration.parent.elements);
                        if (declaration === lastElement || !last(declaration.parent.elements).dotDotDotToken) {
                            addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId);
                        }
                    } else if (isVariableDeclaration(declaration)) {
                        addToGroup(unusedVariables, declaration.parent, declaration, getNodeId);
                    } else {
                        const parameter = local.valueDeclaration && tryGetRootParameterDeclaration(local.valueDeclaration);
                        const name = local.valueDeclaration && getNameOfDeclaration(local.valueDeclaration);
                        if (parameter && name) {
                            if (!isParameterPropertyDeclaration(parameter, parameter.parent) && !parameterIsThisKeyword(parameter) && !isIdentifierThatStartsWithUnderscore(name)) {
                                if (isBindingElement(declaration) && isArrayBindingPattern(declaration.parent)) {
                                    addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId);
                                } else {
                                    addDiagnostic(parameter, 1, createDiagnosticForNode(name, Diagnostics._0_is_declared_but_its_value_is_never_read, symbolName(local)));
                                }
                            }
                        } else {
                            errorUnusedLocal(declaration, symbolName(local), addDiagnostic);
                        }
                    }
                }
            }
        });
        unusedImports.forEach(([importClause, unuseds]) => {
            const importDecl = importClause.parent;
            const nDeclarations = (importClause.name ? 1 : 0) + (importClause.namedBindings ? importClause.namedBindings.kind === 271 ? 1 : importClause.namedBindings.elements.length : 0);
            if (nDeclarations === unuseds.length) {
                addDiagnostic(importDecl, 0, unuseds.length === 1 ? createDiagnosticForNode(importDecl, Diagnostics._0_is_declared_but_its_value_is_never_read, idText(first(unuseds).name)) : createDiagnosticForNode(importDecl, Diagnostics.All_imports_in_import_declaration_are_unused));
            } else {
                for (const unused of unuseds) errorUnusedLocal(unused, idText(unused.name), addDiagnostic);
            }
        });
        unusedDestructures.forEach(([bindingPattern, bindingElements]) => {
            const kind = tryGetRootParameterDeclaration(bindingPattern.parent) ? 1 : 0;
            if (bindingPattern.elements.length === bindingElements.length) {
                if (bindingElements.length === 1 && bindingPattern.parent.kind === 257 && bindingPattern.parent.parent.kind === 258) {
                    addToGroup(unusedVariables, bindingPattern.parent.parent, bindingPattern.parent, getNodeId);
                } else {
                    addDiagnostic(bindingPattern, kind, bindingElements.length === 1 ? createDiagnosticForNode(bindingPattern, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(first(bindingElements).name)) : createDiagnosticForNode(bindingPattern, Diagnostics.All_destructured_elements_are_unused));
                }
            } else {
                for (const e of bindingElements) {
                    addDiagnostic(e, kind, createDiagnosticForNode(e, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(e.name)));
                }
            }
        });
        unusedVariables.forEach(([declarationList, declarations]) => {
            if (declarationList.declarations.length === declarations.length) {
                addDiagnostic(declarationList, 0, declarations.length === 1 ? createDiagnosticForNode(first(declarations).name, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(first(declarations).name)) : createDiagnosticForNode(declarationList.parent.kind === 240 ? declarationList.parent : declarationList, Diagnostics.All_variables_are_unused));
            } else {
                for (const decl of declarations) {
                    addDiagnostic(decl, 0, createDiagnosticForNode(decl, Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(decl.name)));
                }
            }
        });
    }
    function checkPotentialUncheckedRenamedBindingElementsInTypes() {
        var _a2;
        for (const node of potentialUnusedRenamedBindingElementsInTypes) {
            if (!((_a2 = getSymbolOfDeclaration(node)) == null ? void 0 : _a2.isReferenced)) {
                const wrappingDeclaration = walkUpBindingElementsAndPatterns(node);
                Debug.assert(isParameterDeclaration(wrappingDeclaration), "Only parameter declaration should be checked here");
                const diagnostic = createDiagnosticForNode(node.name, Diagnostics._0_is_an_unused_renaming_of_1_Did_you_intend_to_use_it_as_a_type_annotation, declarationNameToString(node.name), declarationNameToString(node.propertyName));
                if (!wrappingDeclaration.type) {
                    addRelatedInfo(diagnostic, createFileDiagnostic(getSourceFileOfNode(wrappingDeclaration), wrappingDeclaration.end, 1, Diagnostics.We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here, declarationNameToString(node.propertyName)));
                }
                diagnostics.add(diagnostic);
            }
        }
    }
    function bindingNameText(name) {
        switch (name.kind) {
            case 79:
                return idText(name);
            case 204:
            case 203:
                return bindingNameText(cast(first(name.elements), isBindingElement).name);
            default:
                return Debug.assertNever(name);
        }
    }
    function isImportedDeclaration(node) {
        return node.kind === 270 || node.kind === 273 || node.kind === 271;
    }
    function importClauseFromImported(decl) {
        return decl.kind === 270 ? decl : decl.kind === 271 ? decl.parent : decl.parent.parent;
    }
    function checkBlock(node) {
        if (node.kind === 238) {
            checkGrammarStatementInAmbientContext(node);
        }
        if (isFunctionOrModuleBlock(node)) {
            const saveFlowAnalysisDisabled = flowAnalysisDisabled;
            forEach(node.statements, checkSourceElement);
            flowAnalysisDisabled = saveFlowAnalysisDisabled;
        } else {
            forEach(node.statements, checkSourceElement);
        }
        if (node.locals) {
            registerForUnusedIdentifiersCheck(node);
        }
    }
    function checkCollisionWithArgumentsInGeneratedCode(node) {
        if (languageVersion >= 2 || !hasRestParameter(node) || node.flags & 16777216 || nodeIsMissing(node.body)) {
            return;
        }
        forEach(node.parameters, p => {
            if (p.name && !isBindingPattern(p.name) && p.name.escapedText === argumentsSymbol.escapedName) {
                errorSkippedOn("noEmit", p, Diagnostics.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters);
            }
        });
    }
    function needCollisionCheckForIdentifier(node, identifier, name) {
        if ((identifier == null ? void 0 : identifier.escapedText) !== name) {
            return false;
        }
        if (node.kind === 169 || node.kind === 168 || node.kind === 171 || node.kind === 170 || node.kind === 174 || node.kind === 175 || node.kind === 299) {
            return false;
        }
        if (node.flags & 16777216) {
            return false;
        }
        if (isImportClause(node) || isImportEqualsDeclaration(node) || isImportSpecifier(node)) {
            if (isTypeOnlyImportOrExportDeclaration(node)) {
                return false;
            }
        }
        const root = getRootDeclaration(node);
        if (isParameter(root) && nodeIsMissing(root.parent.body)) {
            return false;
        }
        return true;
    }
    function checkIfThisIsCapturedInEnclosingScope(node) {
        findAncestor(node, current => {
            if (getNodeCheckFlags(current) & 4) {
                const isDeclaration2 = node.kind !== 79;
                if (isDeclaration2) {
                    error(getNameOfDeclaration(node), Diagnostics.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference);
                } else {
                    error(node, Diagnostics.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference);
                }
                return true;
            }
            return false;
        });
    }
    function checkIfNewTargetIsCapturedInEnclosingScope(node) {
        findAncestor(node, current => {
            if (getNodeCheckFlags(current) & 8) {
                const isDeclaration2 = node.kind !== 79;
                if (isDeclaration2) {
                    error(getNameOfDeclaration(node), Diagnostics.Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference);
                } else {
                    error(node, Diagnostics.Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference);
                }
                return true;
            }
            return false;
        });
    }
    function checkCollisionWithRequireExportsInGeneratedCode(node, name) {
        if (moduleKind >= 5 && !(moduleKind >= 100 && getSourceFileOfNode(node).impliedNodeFormat === 1)) {
            return;
        }
        if (!name || !needCollisionCheckForIdentifier(node, name, "require") && !needCollisionCheckForIdentifier(node, name, "exports")) {
            return;
        }
        if (isModuleDeclaration(node) && getModuleInstanceState(node) !== 1) {
            return;
        }
        const parent2 = getDeclarationContainer(node);
        if (parent2.kind === 308 && isExternalOrCommonJsModule(parent2)) {
            errorSkippedOn("noEmit", name, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module, declarationNameToString(name), declarationNameToString(name));
        }
    }
    function checkCollisionWithGlobalPromiseInGeneratedCode(node, name) {
        if (!name || languageVersion >= 4 || !needCollisionCheckForIdentifier(node, name, "Promise")) {
            return;
        }
        if (isModuleDeclaration(node) && getModuleInstanceState(node) !== 1) {
            return;
        }
        const parent2 = getDeclarationContainer(node);
        if (parent2.kind === 308 && isExternalOrCommonJsModule(parent2) && parent2.flags & 2048) {
            errorSkippedOn("noEmit", name, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions, declarationNameToString(name), declarationNameToString(name));
        }
    }
    function recordPotentialCollisionWithWeakMapSetInGeneratedCode(node, name) {
        if (languageVersion <= 8 && (needCollisionCheckForIdentifier(node, name, "WeakMap") || needCollisionCheckForIdentifier(node, name, "WeakSet"))) {
            potentialWeakMapSetCollisions.push(node);
        }
    }
    function checkWeakMapSetCollision(node) {
        const enclosingBlockScope = getEnclosingBlockScopeContainer(node);
        if (getNodeCheckFlags(enclosingBlockScope) & 4194304) {
            Debug.assert(isNamedDeclaration(node) && isIdentifier(node.name) && typeof node.name.escapedText === "string", "The target of a WeakMap/WeakSet collision check should be an identifier");
            errorSkippedOn("noEmit", node, Diagnostics.Compiler_reserves_name_0_when_emitting_private_identifier_downlevel, node.name.escapedText);
        }
    }
    function recordPotentialCollisionWithReflectInGeneratedCode(node, name) {
        if (name && languageVersion >= 2 && languageVersion <= 8 && needCollisionCheckForIdentifier(node, name, "Reflect")) {
            potentialReflectCollisions.push(node);
        }
    }
    function checkReflectCollision(node) {
        let hasCollision = false;
        if (isClassExpression(node)) {
            for (const member of node.members) {
                if (getNodeCheckFlags(member) & 8388608) {
                    hasCollision = true;
                    break;
                }
            }
        } else if (isFunctionExpression(node)) {
            if (getNodeCheckFlags(node) & 8388608) {
                hasCollision = true;
            }
        } else {
            const container = getEnclosingBlockScopeContainer(node);
            if (container && getNodeCheckFlags(container) & 8388608) {
                hasCollision = true;
            }
        }
        if (hasCollision) {
            Debug.assert(isNamedDeclaration(node) && isIdentifier(node.name), "The target of a Reflect collision check should be an identifier");
            errorSkippedOn("noEmit", node, Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializers, declarationNameToString(node.name), "Reflect");
        }
    }
    function checkCollisionsForDeclarationName(node, name) {
        if (!name) return;
        checkCollisionWithRequireExportsInGeneratedCode(node, name);
        checkCollisionWithGlobalPromiseInGeneratedCode(node, name);
        recordPotentialCollisionWithWeakMapSetInGeneratedCode(node, name);
        recordPotentialCollisionWithReflectInGeneratedCode(node, name);
        if (isClassLike(node)) {
            checkTypeNameIsReserved(name, Diagnostics.Class_name_cannot_be_0);
            if (!(node.flags & 16777216)) {
                checkClassNameCollisionWithObject(name);
            }
        } else if (isEnumDeclaration(node)) {
            checkTypeNameIsReserved(name, Diagnostics.Enum_name_cannot_be_0);
        }
    }
    function checkVarDeclaredNamesNotShadowed(node) {
        if ((getCombinedNodeFlags(node) & 3) !== 0 || isParameterDeclaration(node)) {
            return;
        }
        if (node.kind === 257 && !node.initializer) {
            return;
        }
        const symbol = getSymbolOfDeclaration(node);
        if (symbol.flags & 1) {
            if (!isIdentifier(node.name)) return Debug.fail();
            const localDeclarationSymbol = resolveName(node, node.name.escapedText, 3, void 0, void 0, false);
            if (localDeclarationSymbol && localDeclarationSymbol !== symbol && localDeclarationSymbol.flags & 2) {
                if (getDeclarationNodeFlagsFromSymbol(localDeclarationSymbol) & 3) {
                    const varDeclList = getAncestor(localDeclarationSymbol.valueDeclaration, 258);
                    const container = varDeclList.parent.kind === 240 && varDeclList.parent.parent ? varDeclList.parent.parent : void 0;
                    const namesShareScope = container && (container.kind === 238 && isFunctionLike(container.parent) || container.kind === 265 || container.kind === 264 || container.kind === 308);
                    if (!namesShareScope) {
                        const name = symbolToString(localDeclarationSymbol);
                        error(node, Diagnostics.Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1, name, name);
                    }
                }
            }
        }
    }
    function convertAutoToAny(type) {
        return type === autoType ? anyType : type === autoArrayType ? anyArrayType : type;
    }
    function checkVariableLikeDeclaration(node) {
        var _a2;
        checkDecorators(node);
        if (!isBindingElement(node)) {
            checkSourceElement(node.type);
        }
        if (!node.name) {
            return;
        }
        if (node.name.kind === 164) {
            checkComputedPropertyName(node.name);
            if (hasOnlyExpressionInitializer(node) && node.initializer) {
                checkExpressionCached(node.initializer);
            }
        }
        if (isBindingElement(node)) {
            if (node.propertyName && isIdentifier(node.name) && isParameterDeclaration(node) && nodeIsMissing(getContainingFunction(node).body)) {
                potentialUnusedRenamedBindingElementsInTypes.push(node);
                return;
            }
            if (isObjectBindingPattern(node.parent) && node.dotDotDotToken && languageVersion < 5) {
                checkExternalEmitHelpers(node, 4);
            }
            if (node.propertyName && node.propertyName.kind === 164) {
                checkComputedPropertyName(node.propertyName);
            }
            const parent2 = node.parent.parent;
            const parentCheckMode = node.dotDotDotToken ? 64 : 0;
            const parentType = getTypeForBindingElementParent(parent2, parentCheckMode);
            const name = node.propertyName || node.name;
            if (parentType && !isBindingPattern(name)) {
                const exprType = getLiteralTypeFromPropertyName(name);
                if (isTypeUsableAsPropertyName(exprType)) {
                    const nameText = getPropertyNameFromType(exprType);
                    const property = getPropertyOfType(parentType, nameText);
                    if (property) {
                        markPropertyAsReferenced(property, void 0, false);
                        checkPropertyAccessibility(node, !!parent2.initializer && parent2.initializer.kind === 106, false, parentType, property);
                    }
                }
            }
        }
        if (isBindingPattern(node.name)) {
            if (node.name.kind === 204 && languageVersion < 2 && compilerOptions.downlevelIteration) {
                checkExternalEmitHelpers(node, 512);
            }
            forEach(node.name.elements, checkSourceElement);
        }
        if (isParameter(node) && node.initializer && nodeIsMissing(getContainingFunction(node).body)) {
            error(node, Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation);
            return;
        }
        if (isBindingPattern(node.name)) {
            const needCheckInitializer = hasOnlyExpressionInitializer(node) && node.initializer && node.parent.parent.kind !== 246;
            const needCheckWidenedType = !some(node.name.elements, not(isOmittedExpression));
            if (needCheckInitializer || needCheckWidenedType) {
                const widenedType = getWidenedTypeForVariableLikeDeclaration(node);
                if (needCheckInitializer) {
                    const initializerType = checkExpressionCached(node.initializer);
                    if (strictNullChecks && needCheckWidenedType) {
                        checkNonNullNonVoidType(initializerType, node);
                    } else {
                        checkTypeAssignableToAndOptionallyElaborate(initializerType, getWidenedTypeForVariableLikeDeclaration(node), node, node.initializer);
                    }
                }
                if (needCheckWidenedType) {
                    if (isArrayBindingPattern(node.name)) {
                        checkIteratedTypeOrElementType(65, widenedType, undefinedType, node);
                    } else if (strictNullChecks) {
                        checkNonNullNonVoidType(widenedType, node);
                    }
                }
            }
            return;
        }
        const symbol = getSymbolOfDeclaration(node);
        if (symbol.flags & 2097152 && (isVariableDeclarationInitializedToBareOrAccessedRequire(node) || isBindingElementOfBareOrAccessedRequire(node))) {
            checkAliasSymbol(node);
            return;
        }
        const type = convertAutoToAny(getTypeOfSymbol(symbol));
        if (node === symbol.valueDeclaration) {
            const initializer = hasOnlyExpressionInitializer(node) && getEffectiveInitializer(node);
            if (initializer) {
                const isJSObjectLiteralInitializer = isInJSFile(node) && isObjectLiteralExpression(initializer) && (initializer.properties.length === 0 || isPrototypeAccess(node.name)) && !!((_a2 = symbol.exports) == null ? void 0 : _a2.size);
                if (!isJSObjectLiteralInitializer && node.parent.parent.kind !== 246) {
                    checkTypeAssignableToAndOptionallyElaborate(checkExpressionCached(initializer), type, node, initializer, void 0);
                }
            }
            if (symbol.declarations && symbol.declarations.length > 1) {
                if (some(symbol.declarations, d => d !== node && isVariableLike(d) && !areDeclarationFlagsIdentical(d, node))) {
                    error(node.name, Diagnostics.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name));
                }
            }
        } else {
            const declarationType = convertAutoToAny(getWidenedTypeForVariableLikeDeclaration(node));
            if (!isErrorType(type) && !isErrorType(declarationType) && !isTypeIdenticalTo(type, declarationType) && !(symbol.flags & 67108864)) {
                errorNextVariableOrPropertyDeclarationMustHaveSameType(symbol.valueDeclaration, type, node, declarationType);
            }
            if (hasOnlyExpressionInitializer(node) && node.initializer) {
                checkTypeAssignableToAndOptionallyElaborate(checkExpressionCached(node.initializer), declarationType, node, node.initializer, void 0);
            }
            if (symbol.valueDeclaration && !areDeclarationFlagsIdentical(node, symbol.valueDeclaration)) {
                error(node.name, Diagnostics.All_declarations_of_0_must_have_identical_modifiers, declarationNameToString(node.name));
            }
        }
        if (node.kind !== 169 && node.kind !== 168) {
            checkExportsOnMergedDeclarations(node);
            if (node.kind === 257 || node.kind === 205) {
                checkVarDeclaredNamesNotShadowed(node);
            }
            checkCollisionsForDeclarationName(node, node.name);
        }
    }
    function errorNextVariableOrPropertyDeclarationMustHaveSameType(firstDeclaration, firstType, nextDeclaration, nextType) {
        const nextDeclarationName = getNameOfDeclaration(nextDeclaration);
        const message = nextDeclaration.kind === 169 || nextDeclaration.kind === 168 ? Diagnostics.Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2 : Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2;
        const declName = declarationNameToString(nextDeclarationName);
        const err = error(nextDeclarationName, message, declName, typeToString(firstType), typeToString(nextType));
        if (firstDeclaration) {
            addRelatedInfo(err, createDiagnosticForNode(firstDeclaration, Diagnostics._0_was_also_declared_here, declName));
        }
    }
    function areDeclarationFlagsIdentical(left, right) {
        if (left.kind === 166 && right.kind === 257 || left.kind === 257 && right.kind === 166) {
            return true;
        }
        if (hasQuestionToken(left) !== hasQuestionToken(right)) {
            return false;
        }
        const interestingFlags = 8 | 16 | 512 | 256 | 64 | 32;
        return getSelectedEffectiveModifierFlags(left, interestingFlags) === getSelectedEffectiveModifierFlags(right, interestingFlags);
    }
    function checkVariableDeclaration(node) {
        var _a2, _b;
        (_a2 = tracing) == null ? void 0 : _a2.push(tracing.Phase.Check, "checkVariableDeclaration", {
            kind: node.kind,
            pos: node.pos,
            end: node.end,
            path: node.tracingPath
        });
        checkGrammarVariableDeclaration(node);
        checkVariableLikeDeclaration(node);
        (_b = tracing) == null ? void 0 : _b.pop();
    }
    function checkBindingElement(node) {
        checkGrammarBindingElement(node);
        return checkVariableLikeDeclaration(node);
    }
    function checkVariableStatement(node) {
        if (!checkGrammarModifiers(node) && !checkGrammarVariableDeclarationList(node.declarationList)) checkGrammarForDisallowedLetOrConstStatement(node);
        forEach(node.declarationList.declarations, checkSourceElement);
    }
    function checkExpressionStatement(node) {
        checkGrammarStatementInAmbientContext(node);
        checkExpression(node.expression);
    }
    function checkIfStatement(node) {
        checkGrammarStatementInAmbientContext(node);
        const type = checkTruthinessExpression(node.expression);
        checkTestingKnownTruthyCallableOrAwaitableType(node.expression, type, node.thenStatement);
        checkSourceElement(node.thenStatement);
        if (node.thenStatement.kind === 239) {
            error(node.thenStatement, Diagnostics.The_body_of_an_if_statement_cannot_be_the_empty_statement);
        }
        checkSourceElement(node.elseStatement);
    }
    function checkTestingKnownTruthyCallableOrAwaitableType(condExpr, condType, body) {
        if (!strictNullChecks) return;
        bothHelper(condExpr, body);
        function bothHelper(condExpr2, body2) {
            condExpr2 = skipParentheses(condExpr2);
            helper(condExpr2, body2);
            while (isBinaryExpression(condExpr2) && (condExpr2.operatorToken.kind === 56 || condExpr2.operatorToken.kind === 60)) {
                condExpr2 = skipParentheses(condExpr2.left);
                helper(condExpr2, body2);
            }
        }
        function helper(condExpr2, body2) {
            const location = isLogicalOrCoalescingBinaryExpression(condExpr2) ? skipParentheses(condExpr2.right) : condExpr2;
            if (isModuleExportsAccessExpression(location)) {
                return;
            }
            if (isLogicalOrCoalescingBinaryExpression(location)) {
                bothHelper(location, body2);
                return;
            }
            const type = location === condExpr2 ? condType : checkTruthinessExpression(location);
            const isPropertyExpressionCast = isPropertyAccessExpression(location) && isTypeAssertion(location.expression);
            if (!(getTypeFacts(type) & 4194304) || isPropertyExpressionCast) return;
            const callSignatures = getSignaturesOfType(type, 0);
            const isPromise = !!getAwaitedTypeOfPromise(type);
            if (callSignatures.length === 0 && !isPromise) {
                return;
            }
            const testedNode = isIdentifier(location) ? location : isPropertyAccessExpression(location) ? location.name : void 0;
            const testedSymbol = testedNode && getSymbolAtLocation(testedNode);
            if (!testedSymbol && !isPromise) {
                return;
            }
            const isUsed = testedSymbol && isBinaryExpression(condExpr2.parent) && isSymbolUsedInBinaryExpressionChain(condExpr2.parent, testedSymbol) || testedSymbol && body2 && isSymbolUsedInConditionBody(condExpr2, body2, testedNode, testedSymbol);
            if (!isUsed) {
                if (isPromise) {
                    errorAndMaybeSuggestAwait(location, true, Diagnostics.This_condition_will_always_return_true_since_this_0_is_always_defined, getTypeNameForErrorDisplay(type));
                } else {
                    error(location, Diagnostics.This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead);
                }
            }
        }
    }
    function isSymbolUsedInConditionBody(expr, body, testedNode, testedSymbol) {
        return !!forEachChild(body, function check(childNode) {
            if (isIdentifier(childNode)) {
                const childSymbol = getSymbolAtLocation(childNode);
                if (childSymbol && childSymbol === testedSymbol) {
                    if (isIdentifier(expr) || isIdentifier(testedNode) && isBinaryExpression(testedNode.parent)) {
                        return true;
                    }
                    let testedExpression = testedNode.parent;
                    let childExpression = childNode.parent;
                    while (testedExpression && childExpression) {
                        if (isIdentifier(testedExpression) && isIdentifier(childExpression) || testedExpression.kind === 108 && childExpression.kind === 108) {
                            return getSymbolAtLocation(testedExpression) === getSymbolAtLocation(childExpression);
                        } else if (isPropertyAccessExpression(testedExpression) && isPropertyAccessExpression(childExpression)) {
                            if (getSymbolAtLocation(testedExpression.name) !== getSymbolAtLocation(childExpression.name)) {
                                return false;
                            }
                            childExpression = childExpression.expression;
                            testedExpression = testedExpression.expression;
                        } else if (isCallExpression(testedExpression) && isCallExpression(childExpression)) {
                            childExpression = childExpression.expression;
                            testedExpression = testedExpression.expression;
                        } else {
                            return false;
                        }
                    }
                }
            }
            return forEachChild(childNode, check);
        });
    }
    function isSymbolUsedInBinaryExpressionChain(node, testedSymbol) {
        while (isBinaryExpression(node) && node.operatorToken.kind === 55) {
            const isUsed = forEachChild(node.right, function visit(child) {
                if (isIdentifier(child)) {
                    const symbol = getSymbolAtLocation(child);
                    if (symbol && symbol === testedSymbol) {
                        return true;
                    }
                }
                return forEachChild(child, visit);
            });
            if (isUsed) {
                return true;
            }
            node = node.parent;
        }
        return false;
    }
    function checkDoStatement(node) {
        checkGrammarStatementInAmbientContext(node);
        checkSourceElement(node.statement);
        checkTruthinessExpression(node.expression);
    }
    function checkWhileStatement(node) {
        checkGrammarStatementInAmbientContext(node);
        checkTruthinessExpression(node.expression);
        checkSourceElement(node.statement);
    }
    function checkTruthinessOfType(type, node) {
        if (type.flags & 16384) {
            error(node, Diagnostics.An_expression_of_type_void_cannot_be_tested_for_truthiness);
        }
        return type;
    }
    function checkTruthinessExpression(node, checkMode) {
        return checkTruthinessOfType(checkExpression(node, checkMode), node);
    }
    function checkForStatement(node) {
        if (!checkGrammarStatementInAmbientContext(node)) {
            if (node.initializer && node.initializer.kind === 258) {
                checkGrammarVariableDeclarationList(node.initializer);
            }
        }
        if (node.initializer) {
            if (node.initializer.kind === 258) {
                forEach(node.initializer.declarations, checkVariableDeclaration);
            } else {
                checkExpression(node.initializer);
            }
        }
        if (node.condition) checkTruthinessExpression(node.condition);
        if (node.incrementor) checkExpression(node.incrementor);
        checkSourceElement(node.statement);
        if (node.locals) {
            registerForUnusedIdentifiersCheck(node);
        }
    }
    function checkForOfStatement(node) {
        checkGrammarForInOrForOfStatement(node);
        const container = getContainingFunctionOrClassStaticBlock(node);
        if (node.awaitModifier) {
            if (container && isClassStaticBlockDeclaration(container)) {
                grammarErrorOnNode(node.awaitModifier, Diagnostics.For_await_loops_cannot_be_used_inside_a_class_static_block);
            } else {
                const functionFlags = getFunctionFlags(container);
                if ((functionFlags & (4 | 2)) === 2 && languageVersion < 99) {
                    checkExternalEmitHelpers(node, 16384);
                }
            }
        } else if (compilerOptions.downlevelIteration && languageVersion < 2) {
            checkExternalEmitHelpers(node, 256);
        }
        if (node.initializer.kind === 258) {
            checkForInOrForOfVariableDeclaration(node);
        } else {
            const varExpr = node.initializer;
            const iteratedType = checkRightHandSideOfForOf(node);
            if (varExpr.kind === 206 || varExpr.kind === 207) {
                checkDestructuringAssignment(varExpr, iteratedType || errorType);
            } else {
                const leftType = checkExpression(varExpr);
                checkReferenceExpression(varExpr, Diagnostics.The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access);
                if (iteratedType) {
                    checkTypeAssignableToAndOptionallyElaborate(iteratedType, leftType, varExpr, node.expression);
                }
            }
        }
        checkSourceElement(node.statement);
        if (node.locals) {
            registerForUnusedIdentifiersCheck(node);
        }
    }
    function checkForInStatement(node) {
        checkGrammarForInOrForOfStatement(node);
        const rightType = getNonNullableTypeIfNeeded(checkExpression(node.expression));
        if (node.initializer.kind === 258) {
            const variable = node.initializer.declarations[0];
            if (variable && isBindingPattern(variable.name)) {
                error(variable.name, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern);
            }
            checkForInOrForOfVariableDeclaration(node);
        } else {
            const varExpr = node.initializer;
            const leftType = checkExpression(varExpr);
            if (varExpr.kind === 206 || varExpr.kind === 207) {
                error(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern);
            } else if (!isTypeAssignableTo(getIndexTypeOrString(rightType), leftType)) {
                error(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any);
            } else {
                checkReferenceExpression(varExpr, Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access, Diagnostics.The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access);
            }
        }
        if (rightType === neverType || !isTypeAssignableToKind(rightType, 67108864 | 58982400)) {
            error(node.expression, Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0, typeToString(rightType));
        }
        checkSourceElement(node.statement);
        if (node.locals) {
            registerForUnusedIdentifiersCheck(node);
        }
    }
    function checkForInOrForOfVariableDeclaration(iterationStatement) {
        const variableDeclarationList = iterationStatement.initializer;
        if (variableDeclarationList.declarations.length >= 1) {
            const decl = variableDeclarationList.declarations[0];
            checkVariableDeclaration(decl);
        }
    }
    function checkRightHandSideOfForOf(statement) {
        const use = statement.awaitModifier ? 15 : 13;
        return checkIteratedTypeOrElementType(use, checkNonNullExpression(statement.expression), undefinedType, statement.expression);
    }
    function checkIteratedTypeOrElementType(use, inputType, sentType, errorNode) {
        if (isTypeAny(inputType)) {
            return inputType;
        }
        return getIteratedTypeOrElementType(use, inputType, sentType, errorNode, true) || anyType;
    }
    function getIteratedTypeOrElementType(use, inputType, sentType, errorNode, checkAssignability) {
        const allowAsyncIterables = (use & 2) !== 0;
        if (inputType === neverType) {
            reportTypeNotIterableError(errorNode, inputType, allowAsyncIterables);
            return void 0;
        }
        const uplevelIteration = languageVersion >= 2;
        const downlevelIteration = !uplevelIteration && compilerOptions.downlevelIteration;
        const possibleOutOfBounds = compilerOptions.noUncheckedIndexedAccess && !!(use & 128);
        if (uplevelIteration || downlevelIteration || allowAsyncIterables) {
            const iterationTypes = getIterationTypesOfIterable(inputType, use, uplevelIteration ? errorNode : void 0);
            if (checkAssignability) {
                if (iterationTypes) {
                    const diagnostic = use & 8 ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0 : use & 32 ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0 : use & 64 ? Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0 : use & 16 ? Diagnostics.Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0 : void 0;
                    if (diagnostic) {
                        checkTypeAssignableTo(sentType, iterationTypes.nextType, errorNode, diagnostic);
                    }
                }
            }
            if (iterationTypes || uplevelIteration) {
                return possibleOutOfBounds ? includeUndefinedInIndexSignature(iterationTypes && iterationTypes.yieldType) : iterationTypes && iterationTypes.yieldType;
            }
        }
        let arrayType = inputType;
        let reportedError = false;
        let hasStringConstituent = false;
        if (use & 4) {
            if (arrayType.flags & 1048576) {
                const arrayTypes = inputType.types;
                const filteredTypes = filter(arrayTypes, t => !(t.flags & 402653316));
                if (filteredTypes !== arrayTypes) {
                    arrayType = getUnionType(filteredTypes, 2);
                }
            } else if (arrayType.flags & 402653316) {
                arrayType = neverType;
            }
            hasStringConstituent = arrayType !== inputType;
            if (hasStringConstituent) {
                if (languageVersion < 1) {
                    if (errorNode) {
                        error(errorNode, Diagnostics.Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher);
                        reportedError = true;
                    }
                }
                if (arrayType.flags & 131072) {
                    return possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType;
                }
            }
        }
        if (!isArrayLikeType(arrayType)) {
            if (errorNode && !reportedError) {
                const allowsStrings = !!(use & 4) && !hasStringConstituent;
                const [defaultDiagnostic, maybeMissingAwait] = getIterationDiagnosticDetails(allowsStrings, downlevelIteration);
                errorAndMaybeSuggestAwait(errorNode, maybeMissingAwait && !!getAwaitedTypeOfPromise(arrayType), defaultDiagnostic, typeToString(arrayType));
            }
            return hasStringConstituent ? possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType : void 0;
        }
        const arrayElementType = getIndexTypeOfType(arrayType, numberType);
        if (hasStringConstituent && arrayElementType) {
            if (arrayElementType.flags & 402653316 && !compilerOptions.noUncheckedIndexedAccess) {
                return stringType;
            }
            return getUnionType(possibleOutOfBounds ? [arrayElementType, stringType, undefinedType] : [arrayElementType, stringType], 2);
        }
        return use & 128 ? includeUndefinedInIndexSignature(arrayElementType) : arrayElementType;
        function getIterationDiagnosticDetails(allowsStrings, downlevelIteration2) {
            var _a2;
            if (downlevelIteration2) {
                return allowsStrings ? [Diagnostics.Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true] : [Diagnostics.Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true];
            }
            const yieldType = getIterationTypeOfIterable(use, 0, inputType, void 0);
            if (yieldType) {
                return [Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, false];
            }
            if (isES2015OrLaterIterable((_a2 = inputType.symbol) == null ? void 0 : _a2.escapedName)) {
                return [Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, true];
            }
            return allowsStrings ? [Diagnostics.Type_0_is_not_an_array_type_or_a_string_type, true] : [Diagnostics.Type_0_is_not_an_array_type, true];
        }
    }
    function isES2015OrLaterIterable(n) {
        switch (n) {
            case "Float32Array":
            case "Float64Array":
            case "Int16Array":
            case "Int32Array":
            case "Int8Array":
            case "NodeList":
            case "Uint16Array":
            case "Uint32Array":
            case "Uint8Array":
            case "Uint8ClampedArray":
                return true;
        }
        return false;
    }
    function getIterationTypeOfIterable(use, typeKind, inputType, errorNode) {
        if (isTypeAny(inputType)) {
            return void 0;
        }
        const iterationTypes = getIterationTypesOfIterable(inputType, use, errorNode);
        return iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(typeKind)];
    }
    function createIterationTypes(yieldType = neverType, returnType = neverType, nextType = unknownType) {
        if (yieldType.flags & 67359327 && returnType.flags & (1 | 131072 | 2 | 16384 | 32768) && nextType.flags & (1 | 131072 | 2 | 16384 | 32768)) {
            const id = getTypeListId([yieldType, returnType, nextType]);
            let iterationTypes = iterationTypesCache.get(id);
            if (!iterationTypes) {
                iterationTypes = {
                    yieldType,
                    returnType,
                    nextType
                };
                iterationTypesCache.set(id, iterationTypes);
            }
            return iterationTypes;
        }
        return {
            yieldType,
            returnType,
            nextType
        };
    }
    function combineIterationTypes(array) {
        let yieldTypes;
        let returnTypes;
        let nextTypes;
        for (const iterationTypes of array) {
            if (iterationTypes === void 0 || iterationTypes === noIterationTypes) {
                continue;
            }
            if (iterationTypes === anyIterationTypes) {
                return anyIterationTypes;
            }
            yieldTypes = append(yieldTypes, iterationTypes.yieldType);
            returnTypes = append(returnTypes, iterationTypes.returnType);
            nextTypes = append(nextTypes, iterationTypes.nextType);
        }
        if (yieldTypes || returnTypes || nextTypes) {
            return createIterationTypes(yieldTypes && getUnionType(yieldTypes), returnTypes && getUnionType(returnTypes), nextTypes && getIntersectionType(nextTypes));
        }
        return noIterationTypes;
    }
    function getCachedIterationTypes(type, cacheKey) {
        return type[cacheKey];
    }
    function setCachedIterationTypes(type, cacheKey, cachedTypes2) {
        return type[cacheKey] = cachedTypes2;
    }
    function getIterationTypesOfIterable(type, use, errorNode) {
        var _a2, _b;
        if (isTypeAny(type)) {
            return anyIterationTypes;
        }
        if (!(type.flags & 1048576)) {
            const errorOutputContainer = errorNode ? {
                errors: void 0
            } : void 0;
            const iterationTypes2 = getIterationTypesOfIterableWorker(type, use, errorNode, errorOutputContainer);
            if (iterationTypes2 === noIterationTypes) {
                if (errorNode) {
                    const rootDiag = reportTypeNotIterableError(errorNode, type, !!(use & 2));
                    if (errorOutputContainer == null ? void 0 : errorOutputContainer.errors) {
                        addRelatedInfo(rootDiag, ...errorOutputContainer.errors);
                    }
                }
                return void 0;
            } else if ((_a2 = errorOutputContainer == null ? void 0 : errorOutputContainer.errors) == null ? void 0 : _a2.length) {
                for (const diag2 of errorOutputContainer.errors) {
                    diagnostics.add(diag2);
                }
            }
            return iterationTypes2;
        }
        const cacheKey = use & 2 ? "iterationTypesOfAsyncIterable" : "iterationTypesOfIterable";
        const cachedTypes2 = getCachedIterationTypes(type, cacheKey);
        if (cachedTypes2) return cachedTypes2 === noIterationTypes ? void 0 : cachedTypes2;
        let allIterationTypes;
        for (const constituent of type.types) {
            const errorOutputContainer = errorNode ? {
                errors: void 0
            } : void 0;
            const iterationTypes2 = getIterationTypesOfIterableWorker(constituent, use, errorNode, errorOutputContainer);
            if (iterationTypes2 === noIterationTypes) {
                if (errorNode) {
                    const rootDiag = reportTypeNotIterableError(errorNode, type, !!(use & 2));
                    if (errorOutputContainer == null ? void 0 : errorOutputContainer.errors) {
                        addRelatedInfo(rootDiag, ...errorOutputContainer.errors);
                    }
                }
                setCachedIterationTypes(type, cacheKey, noIterationTypes);
                return void 0;
            } else if ((_b = errorOutputContainer == null ? void 0 : errorOutputContainer.errors) == null ? void 0 : _b.length) {
                for (const diag2 of errorOutputContainer.errors) {
                    diagnostics.add(diag2);
                }
            }
            allIterationTypes = append(allIterationTypes, iterationTypes2);
        }
        const iterationTypes = allIterationTypes ? combineIterationTypes(allIterationTypes) : noIterationTypes;
        setCachedIterationTypes(type, cacheKey, iterationTypes);
        return iterationTypes === noIterationTypes ? void 0 : iterationTypes;
    }
    function getAsyncFromSyncIterationTypes(iterationTypes, errorNode) {
        if (iterationTypes === noIterationTypes) return noIterationTypes;
        if (iterationTypes === anyIterationTypes) return anyIterationTypes;
        const {
            yieldType,
            returnType,
            nextType
        } = iterationTypes;
        if (errorNode) {
            getGlobalAwaitedSymbol(true);
        }
        return createIterationTypes(getAwaitedType(yieldType, errorNode) || anyType, getAwaitedType(returnType, errorNode) || anyType, nextType);
    }
    function getIterationTypesOfIterableWorker(type, use, errorNode, errorOutputContainer) {
        if (isTypeAny(type)) {
            return anyIterationTypes;
        }
        let noCache = false;
        if (use & 2) {
            const iterationTypes = getIterationTypesOfIterableCached(type, asyncIterationTypesResolver) || getIterationTypesOfIterableFast(type, asyncIterationTypesResolver);
            if (iterationTypes) {
                if (iterationTypes === noIterationTypes && errorNode) {
                    noCache = true;
                } else {
                    return use & 8 ? getAsyncFromSyncIterationTypes(iterationTypes, errorNode) : iterationTypes;
                }
            }
        }
        if (use & 1) {
            let iterationTypes = getIterationTypesOfIterableCached(type, syncIterationTypesResolver) || getIterationTypesOfIterableFast(type, syncIterationTypesResolver);
            if (iterationTypes) {
                if (iterationTypes === noIterationTypes && errorNode) {
                    noCache = true;
                } else {
                    if (use & 2) {
                        if (iterationTypes !== noIterationTypes) {
                            iterationTypes = getAsyncFromSyncIterationTypes(iterationTypes, errorNode);
                            return noCache ? iterationTypes : setCachedIterationTypes(type, "iterationTypesOfAsyncIterable", iterationTypes);
                        }
                    } else {
                        return iterationTypes;
                    }
                }
            }
        }
        if (use & 2) {
            const iterationTypes = getIterationTypesOfIterableSlow(type, asyncIterationTypesResolver, errorNode, errorOutputContainer, noCache);
            if (iterationTypes !== noIterationTypes) {
                return iterationTypes;
            }
        }
        if (use & 1) {
            let iterationTypes = getIterationTypesOfIterableSlow(type, syncIterationTypesResolver, errorNode, errorOutputContainer, noCache);
            if (iterationTypes !== noIterationTypes) {
                if (use & 2) {
                    iterationTypes = getAsyncFromSyncIterationTypes(iterationTypes, errorNode);
                    return noCache ? iterationTypes : setCachedIterationTypes(type, "iterationTypesOfAsyncIterable", iterationTypes);
                } else {
                    return iterationTypes;
                }
            }
        }
        return noIterationTypes;
    }
    function getIterationTypesOfIterableCached(type, resolver) {
        return getCachedIterationTypes(type, resolver.iterableCacheKey);
    }
    function getIterationTypesOfGlobalIterableType(globalType, resolver) {
        const globalIterationTypes = getIterationTypesOfIterableCached(globalType, resolver) || getIterationTypesOfIterableSlow(globalType, resolver, void 0, void 0, false);
        return globalIterationTypes === noIterationTypes ? defaultIterationTypes : globalIterationTypes;
    }
    function getIterationTypesOfIterableFast(type, resolver) {
        let globalType;
        if (isReferenceToType2(type, globalType = resolver.getGlobalIterableType(false)) || isReferenceToType2(type, globalType = resolver.getGlobalIterableIteratorType(false))) {
            const [yieldType] = getTypeArguments(type);
            const {
                returnType,
                nextType
            } = getIterationTypesOfGlobalIterableType(globalType, resolver);
            return setCachedIterationTypes(type, resolver.iterableCacheKey, createIterationTypes(resolver.resolveIterationType(yieldType, void 0) || yieldType, resolver.resolveIterationType(returnType, void 0) || returnType, nextType));
        }
        if (isReferenceToType2(type, resolver.getGlobalGeneratorType(false))) {
            const [yieldType, returnType, nextType] = getTypeArguments(type);
            return setCachedIterationTypes(type, resolver.iterableCacheKey, createIterationTypes(resolver.resolveIterationType(yieldType, void 0) || yieldType, resolver.resolveIterationType(returnType, void 0) || returnType, nextType));
        }
    }
    function getPropertyNameForKnownSymbolName(symbolName2) {
        const ctorType = getGlobalESSymbolConstructorSymbol(false);
        const uniqueType = ctorType && getTypeOfPropertyOfType(getTypeOfSymbol(ctorType), escapeLeadingUnderscores(symbolName2));
        return uniqueType && isTypeUsableAsPropertyName(uniqueType) ? getPropertyNameFromType(uniqueType) : `__@${symbolName2}`;
    }
    function getIterationTypesOfIterableSlow(type, resolver, errorNode, errorOutputContainer, noCache) {
        var _a2;
        const method = getPropertyOfType(type, getPropertyNameForKnownSymbolName(resolver.iteratorSymbolName));
        const methodType = method && !(method.flags & 16777216) ? getTypeOfSymbol(method) : void 0;
        if (isTypeAny(methodType)) {
            return noCache ? anyIterationTypes : setCachedIterationTypes(type, resolver.iterableCacheKey, anyIterationTypes);
        }
        const signatures = methodType ? getSignaturesOfType(methodType, 0) : void 0;
        if (!some(signatures)) {
            return noCache ? noIterationTypes : setCachedIterationTypes(type, resolver.iterableCacheKey, noIterationTypes);
        }
        const iteratorType = getIntersectionType(map(signatures, getReturnTypeOfSignature));
        const iterationTypes = (_a2 = getIterationTypesOfIteratorWorker(iteratorType, resolver, errorNode, errorOutputContainer, noCache)) != null ? _a2 : noIterationTypes;
        return noCache ? iterationTypes : setCachedIterationTypes(type, resolver.iterableCacheKey, iterationTypes);
    }
    function reportTypeNotIterableError(errorNode, type, allowAsyncIterables) {
        const message = allowAsyncIterables ? Diagnostics.Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator : Diagnostics.Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator;
        const suggestAwait = !!getAwaitedTypeOfPromise(type) || !allowAsyncIterables && isForOfStatement(errorNode.parent) && errorNode.parent.expression === errorNode && getGlobalAsyncIterableType(false) !== emptyGenericType && isTypeAssignableTo(type, getGlobalAsyncIterableType(false));
        return errorAndMaybeSuggestAwait(errorNode, suggestAwait, message, typeToString(type));
    }
    function getIterationTypesOfIterator(type, resolver, errorNode, errorOutputContainer) {
        return getIterationTypesOfIteratorWorker(type, resolver, errorNode, errorOutputContainer, false);
    }
    function getIterationTypesOfIteratorWorker(type, resolver, errorNode, errorOutputContainer, noCache) {
        if (isTypeAny(type)) {
            return anyIterationTypes;
        }
        let iterationTypes = getIterationTypesOfIteratorCached(type, resolver) || getIterationTypesOfIteratorFast(type, resolver);
        if (iterationTypes === noIterationTypes && errorNode) {
            iterationTypes = void 0;
            noCache = true;
        }
        iterationTypes != null ? iterationTypes : iterationTypes = getIterationTypesOfIteratorSlow(type, resolver, errorNode, errorOutputContainer, noCache);
        return iterationTypes === noIterationTypes ? void 0 : iterationTypes;
    }
    function getIterationTypesOfIteratorCached(type, resolver) {
        return getCachedIterationTypes(type, resolver.iteratorCacheKey);
    }
    function getIterationTypesOfIteratorFast(type, resolver) {
        const globalType = resolver.getGlobalIterableIteratorType(false);
        if (isReferenceToType2(type, globalType)) {
            const [yieldType] = getTypeArguments(type);
            const globalIterationTypes = getIterationTypesOfIteratorCached(globalType, resolver) || getIterationTypesOfIteratorSlow(globalType, resolver, void 0, void 0, false);
            const {
                returnType,
                nextType
            } = globalIterationTypes === noIterationTypes ? defaultIterationTypes : globalIterationTypes;
            return setCachedIterationTypes(type, resolver.iteratorCacheKey, createIterationTypes(yieldType, returnType, nextType));
        }
        if (isReferenceToType2(type, resolver.getGlobalIteratorType(false)) || isReferenceToType2(type, resolver.getGlobalGeneratorType(false))) {
            const [yieldType, returnType, nextType] = getTypeArguments(type);
            return setCachedIterationTypes(type, resolver.iteratorCacheKey, createIterationTypes(yieldType, returnType, nextType));
        }
    }
    function isIteratorResult(type, kind) {
        const doneType = getTypeOfPropertyOfType(type, "done") || falseType;
        return isTypeAssignableTo(kind === 0 ? falseType : trueType, doneType);
    }
    function isYieldIteratorResult(type) {
        return isIteratorResult(type, 0);
    }
    function isReturnIteratorResult(type) {
        return isIteratorResult(type, 1);
    }
    function getIterationTypesOfIteratorResult(type) {
        if (isTypeAny(type)) {
            return anyIterationTypes;
        }
        const cachedTypes2 = getCachedIterationTypes(type, "iterationTypesOfIteratorResult");
        if (cachedTypes2) {
            return cachedTypes2;
        }
        if (isReferenceToType2(type, getGlobalIteratorYieldResultType(false))) {
            const yieldType2 = getTypeArguments(type)[0];
            return setCachedIterationTypes(type, "iterationTypesOfIteratorResult", createIterationTypes(yieldType2, void 0, void 0));
        }
        if (isReferenceToType2(type, getGlobalIteratorReturnResultType(false))) {
            const returnType2 = getTypeArguments(type)[0];
            return setCachedIterationTypes(type, "iterationTypesOfIteratorResult", createIterationTypes(void 0, returnType2, void 0));
        }
        const yieldIteratorResult = filterType(type, isYieldIteratorResult);
        const yieldType = yieldIteratorResult !== neverType ? getTypeOfPropertyOfType(yieldIteratorResult, "value") : void 0;
        const returnIteratorResult = filterType(type, isReturnIteratorResult);
        const returnType = returnIteratorResult !== neverType ? getTypeOfPropertyOfType(returnIteratorResult, "value") : void 0;
        if (!yieldType && !returnType) {
            return setCachedIterationTypes(type, "iterationTypesOfIteratorResult", noIterationTypes);
        }
        return setCachedIterationTypes(type, "iterationTypesOfIteratorResult", createIterationTypes(yieldType, returnType || voidType, void 0));
    }
    function getIterationTypesOfMethod(type, resolver, methodName, errorNode, errorOutputContainer) {
        var _a2, _b, _c, _d, _e, _f;
        const method = getPropertyOfType(type, methodName);
        if (!method && methodName !== "next") {
            return void 0;
        }
        const methodType = method && !(methodName === "next" && method.flags & 16777216) ? methodName === "next" ? getTypeOfSymbol(method) : getTypeWithFacts(getTypeOfSymbol(method), 2097152) : void 0;
        if (isTypeAny(methodType)) {
            return methodName === "next" ? anyIterationTypes : anyIterationTypesExceptNext;
        }
        const methodSignatures = methodType ? getSignaturesOfType(methodType, 0) : emptyArray;
        if (methodSignatures.length === 0) {
            if (errorNode) {
                const diagnostic = methodName === "next" ? resolver.mustHaveANextMethodDiagnostic : resolver.mustBeAMethodDiagnostic;
                if (errorOutputContainer) {
                    (_a2 = errorOutputContainer.errors) != null ? _a2 : errorOutputContainer.errors = [];
                    errorOutputContainer.errors.push(createDiagnosticForNode(errorNode, diagnostic, methodName));
                } else {
                    error(errorNode, diagnostic, methodName);
                }
            }
            return methodName === "next" ? noIterationTypes : void 0;
        }
        if ((methodType == null ? void 0 : methodType.symbol) && methodSignatures.length === 1) {
            const globalGeneratorType = resolver.getGlobalGeneratorType(false);
            const globalIteratorType = resolver.getGlobalIteratorType(false);
            const isGeneratorMethod = ((_c = (_b = globalGeneratorType.symbol) == null ? void 0 : _b.members) == null ? void 0 : _c.get(methodName)) === methodType.symbol;
            const isIteratorMethod = !isGeneratorMethod && ((_e = (_d = globalIteratorType.symbol) == null ? void 0 : _d.members) == null ? void 0 : _e.get(methodName)) === methodType.symbol;
            if (isGeneratorMethod || isIteratorMethod) {
                const globalType = isGeneratorMethod ? globalGeneratorType : globalIteratorType;
                const {
                    mapper
                } = methodType;
                return createIterationTypes(getMappedType(globalType.typeParameters[0], mapper), getMappedType(globalType.typeParameters[1], mapper), methodName === "next" ? getMappedType(globalType.typeParameters[2], mapper) : void 0);
            }
        }
        let methodParameterTypes;
        let methodReturnTypes;
        for (const signature of methodSignatures) {
            if (methodName !== "throw" && some(signature.parameters)) {
                methodParameterTypes = append(methodParameterTypes, getTypeAtPosition(signature, 0));
            }
            methodReturnTypes = append(methodReturnTypes, getReturnTypeOfSignature(signature));
        }
        let returnTypes;
        let nextType;
        if (methodName !== "throw") {
            const methodParameterType = methodParameterTypes ? getUnionType(methodParameterTypes) : unknownType;
            if (methodName === "next") {
                nextType = methodParameterType;
            } else if (methodName === "return") {
                const resolvedMethodParameterType = resolver.resolveIterationType(methodParameterType, errorNode) || anyType;
                returnTypes = append(returnTypes, resolvedMethodParameterType);
            }
        }
        let yieldType;
        const methodReturnType = methodReturnTypes ? getIntersectionType(methodReturnTypes) : neverType;
        const resolvedMethodReturnType = resolver.resolveIterationType(methodReturnType, errorNode) || anyType;
        const iterationTypes = getIterationTypesOfIteratorResult(resolvedMethodReturnType);
        if (iterationTypes === noIterationTypes) {
            if (errorNode) {
                if (errorOutputContainer) {
                    (_f = errorOutputContainer.errors) != null ? _f : errorOutputContainer.errors = [];
                    errorOutputContainer.errors.push(createDiagnosticForNode(errorNode, resolver.mustHaveAValueDiagnostic, methodName));
                } else {
                    error(errorNode, resolver.mustHaveAValueDiagnostic, methodName);
                }
            }
            yieldType = anyType;
            returnTypes = append(returnTypes, anyType);
        } else {
            yieldType = iterationTypes.yieldType;
            returnTypes = append(returnTypes, iterationTypes.returnType);
        }
        return createIterationTypes(yieldType, getUnionType(returnTypes), nextType);
    }
    function getIterationTypesOfIteratorSlow(type, resolver, errorNode, errorOutputContainer, noCache) {
        const iterationTypes = combineIterationTypes([getIterationTypesOfMethod(type, resolver, "next", errorNode, errorOutputContainer), getIterationTypesOfMethod(type, resolver, "return", errorNode, errorOutputContainer), getIterationTypesOfMethod(type, resolver, "throw", errorNode, errorOutputContainer)]);
        return noCache ? iterationTypes : setCachedIterationTypes(type, resolver.iteratorCacheKey, iterationTypes);
    }
    function getIterationTypeOfGeneratorFunctionReturnType(kind, returnType, isAsyncGenerator) {
        if (isTypeAny(returnType)) {
            return void 0;
        }
        const iterationTypes = getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsyncGenerator);
        return iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(kind)];
    }
    function getIterationTypesOfGeneratorFunctionReturnType(type, isAsyncGenerator) {
        if (isTypeAny(type)) {
            return anyIterationTypes;
        }
        const use = isAsyncGenerator ? 2 : 1;
        const resolver = isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver;
        return getIterationTypesOfIterable(type, use, void 0) || getIterationTypesOfIterator(type, resolver, void 0, void 0);
    }
    function checkBreakOrContinueStatement(node) {
        if (!checkGrammarStatementInAmbientContext(node)) checkGrammarBreakOrContinueStatement(node);
    }
    function unwrapReturnType(returnType, functionFlags) {
        const isGenerator = !!(functionFlags & 1);
        const isAsync = !!(functionFlags & 2);
        if (isGenerator) {
            const returnIterationType = getIterationTypeOfGeneratorFunctionReturnType(1, returnType, isAsync);
            if (!returnIterationType) {
                return errorType;
            }
            return isAsync ? getAwaitedTypeNoAlias(unwrapAwaitedType(returnIterationType)) : returnIterationType;
        }
        return isAsync ? getAwaitedTypeNoAlias(returnType) || errorType : returnType;
    }
    function isUnwrappedReturnTypeVoidOrAny(func, returnType) {
        const unwrappedReturnType = unwrapReturnType(returnType, getFunctionFlags(func));
        return !!unwrappedReturnType && maybeTypeOfKind(unwrappedReturnType, 16384 | 3);
    }
    function checkReturnStatement(node) {
        var _a2;
        if (checkGrammarStatementInAmbientContext(node)) {
            return;
        }
        const container = getContainingFunctionOrClassStaticBlock(node);
        if (container && isClassStaticBlockDeclaration(container)) {
            grammarErrorOnFirstToken(node, Diagnostics.A_return_statement_cannot_be_used_inside_a_class_static_block);
            return;
        }
        if (!container) {
            grammarErrorOnFirstToken(node, Diagnostics.A_return_statement_can_only_be_used_within_a_function_body);
            return;
        }
        const signature = getSignatureFromDeclaration(container);
        const returnType = getReturnTypeOfSignature(signature);
        const functionFlags = getFunctionFlags(container);
        if (strictNullChecks || node.expression || returnType.flags & 131072) {
            const exprType = node.expression ? checkExpressionCached(node.expression) : undefinedType;
            if (container.kind === 175) {
                if (node.expression) {
                    error(node, Diagnostics.Setters_cannot_return_a_value);
                }
            } else if (container.kind === 173) {
                if (node.expression && !checkTypeAssignableToAndOptionallyElaborate(exprType, returnType, node, node.expression)) {
                    error(node, Diagnostics.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class);
                }
            } else if (getReturnTypeFromAnnotation(container)) {
                const unwrappedReturnType = (_a2 = unwrapReturnType(returnType, functionFlags)) != null ? _a2 : returnType;
                const unwrappedExprType = functionFlags & 2 ? checkAwaitedType(exprType, false, node, Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member) : exprType;
                if (unwrappedReturnType) {
                    checkTypeAssignableToAndOptionallyElaborate(unwrappedExprType, unwrappedReturnType, node, node.expression);
                }
            }
        } else if (container.kind !== 173 && compilerOptions.noImplicitReturns && !isUnwrappedReturnTypeVoidOrAny(container, returnType)) {
            error(node, Diagnostics.Not_all_code_paths_return_a_value);
        }
    }
    function checkWithStatement(node) {
        if (!checkGrammarStatementInAmbientContext(node)) {
            if (node.flags & 32768) {
                grammarErrorOnFirstToken(node, Diagnostics.with_statements_are_not_allowed_in_an_async_function_block);
            }
        }
        checkExpression(node.expression);
        const sourceFile = getSourceFileOfNode(node);
        if (!hasParseDiagnostics(sourceFile)) {
            const start = getSpanOfTokenAtPosition(sourceFile, node.pos).start;
            const end = node.statement.pos;
            grammarErrorAtPos(sourceFile, start, end - start, Diagnostics.The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any);
        }
    }
    function checkSwitchStatement(node) {
        checkGrammarStatementInAmbientContext(node);
        let firstDefaultClause;
        let hasDuplicateDefaultClause = false;
        const expressionType = checkExpression(node.expression);
        forEach(node.caseBlock.clauses, clause => {
            if (clause.kind === 293 && !hasDuplicateDefaultClause) {
                if (firstDefaultClause === void 0) {
                    firstDefaultClause = clause;
                } else {
                    grammarErrorOnNode(clause, Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement);
                    hasDuplicateDefaultClause = true;
                }
            }
            if (clause.kind === 292) {
                addLazyDiagnostic(createLazyCaseClauseDiagnostics(clause));
            }
            forEach(clause.statements, checkSourceElement);
            if (compilerOptions.noFallthroughCasesInSwitch && clause.fallthroughFlowNode && isReachableFlowNode(clause.fallthroughFlowNode)) {
                error(clause, Diagnostics.Fallthrough_case_in_switch);
            }
            function createLazyCaseClauseDiagnostics(clause2) {
                return () => {
                    const caseType = checkExpression(clause2.expression);
                    if (!isTypeEqualityComparableTo(expressionType, caseType)) {
                        checkTypeComparableTo(caseType, expressionType, clause2.expression, void 0);
                    }
                };
            }
        });
        if (node.caseBlock.locals) {
            registerForUnusedIdentifiersCheck(node.caseBlock);
        }
    }
    function checkLabeledStatement(node) {
        if (!checkGrammarStatementInAmbientContext(node)) {
            findAncestor(node.parent, current => {
                if (isFunctionLike(current)) {
                    return "quit";
                }
                if (current.kind === 253 && current.label.escapedText === node.label.escapedText) {
                    grammarErrorOnNode(node.label, Diagnostics.Duplicate_label_0, getTextOfNode(node.label));
                    return true;
                }
                return false;
            });
        }
        checkSourceElement(node.statement);
    }
    function checkThrowStatement(node) {
        if (!checkGrammarStatementInAmbientContext(node)) {
            if (isIdentifier(node.expression) && !node.expression.escapedText) {
                grammarErrorAfterFirstToken(node, Diagnostics.Line_break_not_permitted_here);
            }
        }
        if (node.expression) {
            checkExpression(node.expression);
        }
    }
    function checkTryStatement(node) {
        checkGrammarStatementInAmbientContext(node);
        checkBlock(node.tryBlock);
        const catchClause = node.catchClause;
        if (catchClause) {
            if (catchClause.variableDeclaration) {
                const declaration = catchClause.variableDeclaration;
                checkVariableLikeDeclaration(declaration);
                const typeNode = getEffectiveTypeAnnotationNode(declaration);
                if (typeNode) {
                    const type = getTypeFromTypeNode(typeNode);
                    if (type && !(type.flags & 3)) {
                        grammarErrorOnFirstToken(typeNode, Diagnostics.Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified);
                    }
                } else if (declaration.initializer) {
                    grammarErrorOnFirstToken(declaration.initializer, Diagnostics.Catch_clause_variable_cannot_have_an_initializer);
                } else {
                    const blockLocals = catchClause.block.locals;
                    if (blockLocals) {
                        forEachKey(catchClause.locals, caughtName => {
                            const blockLocal = blockLocals.get(caughtName);
                            if ((blockLocal == null ? void 0 : blockLocal.valueDeclaration) && (blockLocal.flags & 2) !== 0) {
                                grammarErrorOnNode(blockLocal.valueDeclaration, Diagnostics.Cannot_redeclare_identifier_0_in_catch_clause, caughtName);
                            }
                        });
                    }
                }
            }
            checkBlock(catchClause.block);
        }
        if (node.finallyBlock) {
            checkBlock(node.finallyBlock);
        }
    }
    function checkIndexConstraints(type, symbol, isStaticIndex) {
        const indexInfos = getIndexInfosOfType(type);
        if (indexInfos.length === 0) {
            return;
        }
        for (const prop of getPropertiesOfObjectType(type)) {
            if (!(isStaticIndex && prop.flags & 4194304)) {
                checkIndexConstraintForProperty(type, prop, getLiteralTypeFromProperty(prop, 8576, true), getNonMissingTypeOfSymbol(prop));
            }
        }
        const typeDeclaration = symbol.valueDeclaration;
        if (typeDeclaration && isClassLike(typeDeclaration)) {
            for (const member of typeDeclaration.members) {
                if (!isStatic(member) && !hasBindableName(member)) {
                    const symbol2 = getSymbolOfDeclaration(member);
                    checkIndexConstraintForProperty(type, symbol2, getTypeOfExpression(member.name.expression), getNonMissingTypeOfSymbol(symbol2));
                }
            }
        }
        if (indexInfos.length > 1) {
            for (const info of indexInfos) {
                checkIndexConstraintForIndexSignature(type, info);
            }
        }
    }
    function checkIndexConstraintForProperty(type, prop, propNameType, propType) {
        const declaration = prop.valueDeclaration;
        const name = getNameOfDeclaration(declaration);
        if (name && isPrivateIdentifier(name)) {
            return;
        }
        const indexInfos = getApplicableIndexInfos(type, propNameType);
        const interfaceDeclaration = getObjectFlags(type) & 2 ? getDeclarationOfKind(type.symbol, 261) : void 0;
        const propDeclaration = declaration && declaration.kind === 223 || name && name.kind === 164 ? declaration : void 0;
        const localPropDeclaration = getParentOfSymbol(prop) === type.symbol ? declaration : void 0;
        for (const info of indexInfos) {
            const localIndexDeclaration = info.declaration && getParentOfSymbol(getSymbolOfDeclaration(info.declaration)) === type.symbol ? info.declaration : void 0;
            const errorNode = localPropDeclaration || localIndexDeclaration || (interfaceDeclaration && !some(getBaseTypes(type), base => !!getPropertyOfObjectType(base, prop.escapedName) && !!getIndexTypeOfType(base, info.keyType)) ? interfaceDeclaration : void 0);
            if (errorNode && !isTypeAssignableTo(propType, info.type)) {
                const diagnostic = createError(errorNode, Diagnostics.Property_0_of_type_1_is_not_assignable_to_2_index_type_3, symbolToString(prop), typeToString(propType), typeToString(info.keyType), typeToString(info.type));
                if (propDeclaration && errorNode !== propDeclaration) {
                    addRelatedInfo(diagnostic, createDiagnosticForNode(propDeclaration, Diagnostics._0_is_declared_here, symbolToString(prop)));
                }
                diagnostics.add(diagnostic);
            }
        }
    }
    function checkIndexConstraintForIndexSignature(type, checkInfo) {
        const declaration = checkInfo.declaration;
        const indexInfos = getApplicableIndexInfos(type, checkInfo.keyType);
        const interfaceDeclaration = getObjectFlags(type) & 2 ? getDeclarationOfKind(type.symbol, 261) : void 0;
        const localCheckDeclaration = declaration && getParentOfSymbol(getSymbolOfDeclaration(declaration)) === type.symbol ? declaration : void 0;
        for (const info of indexInfos) {
            if (info === checkInfo) continue;
            const localIndexDeclaration = info.declaration && getParentOfSymbol(getSymbolOfDeclaration(info.declaration)) === type.symbol ? info.declaration : void 0;
            const errorNode = localCheckDeclaration || localIndexDeclaration || (interfaceDeclaration && !some(getBaseTypes(type), base => !!getIndexInfoOfType(base, checkInfo.keyType) && !!getIndexTypeOfType(base, info.keyType)) ? interfaceDeclaration : void 0);
            if (errorNode && !isTypeAssignableTo(checkInfo.type, info.type)) {
                error(errorNode, Diagnostics._0_index_type_1_is_not_assignable_to_2_index_type_3, typeToString(checkInfo.keyType), typeToString(checkInfo.type), typeToString(info.keyType), typeToString(info.type));
            }
        }
    }
    function checkTypeNameIsReserved(name, message) {
        switch (name.escapedText) {
            case "any":
            case "unknown":
            case "never":
            case "number":
            case "bigint":
            case "boolean":
            case "string":
            case "symbol":
            case "void":
            case "object":
                error(name, message, name.escapedText);
        }
    }
    function checkClassNameCollisionWithObject(name) {
        if (languageVersion >= 1 && name.escapedText === "Object" && (moduleKind < 5 || getSourceFileOfNode(name).impliedNodeFormat === 1)) {
            error(name, Diagnostics.Class_name_cannot_be_Object_when_targeting_ES5_with_module_0, ModuleKind[moduleKind]);
        }
    }
    function checkUnmatchedJSDocParameters(node) {
        const jsdocParameters = filter(getJSDocTags(node), isJSDocParameterTag);
        if (!length(jsdocParameters)) return;
        const isJs = isInJSFile(node);
        const parameters = /* @__PURE__ */new Set();
        const excludedParameters = /* @__PURE__ */new Set();
        forEach(node.parameters, ({
            name
        }, index) => {
            if (isIdentifier(name)) {
                parameters.add(name.escapedText);
            }
            if (isBindingPattern(name)) {
                excludedParameters.add(index);
            }
        });
        const containsArguments = containsArgumentsReference(node);
        if (containsArguments) {
            const lastJSDocParamIndex = jsdocParameters.length - 1;
            const lastJSDocParam = jsdocParameters[lastJSDocParamIndex];
            if (isJs && lastJSDocParam && isIdentifier(lastJSDocParam.name) && lastJSDocParam.typeExpression && lastJSDocParam.typeExpression.type && !parameters.has(lastJSDocParam.name.escapedText) && !excludedParameters.has(lastJSDocParamIndex) && !isArrayType(getTypeFromTypeNode(lastJSDocParam.typeExpression.type))) {
                error(lastJSDocParam.name, Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type, idText(lastJSDocParam.name));
            }
        } else {
            forEach(jsdocParameters, ({
                name,
                isNameFirst
            }, index) => {
                if (excludedParameters.has(index) || isIdentifier(name) && parameters.has(name.escapedText)) {
                    return;
                }
                if (isQualifiedName(name)) {
                    if (isJs) {
                        error(name, Diagnostics.Qualified_name_0_is_not_allowed_without_a_leading_param_object_1, entityNameToString(name), entityNameToString(name.left));
                    }
                } else {
                    if (!isNameFirst) {
                        errorOrSuggestion(isJs, name, Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name, idText(name));
                    }
                }
            });
        }
    }
    function checkTypeParameters(typeParameterDeclarations) {
        let seenDefault = false;
        if (typeParameterDeclarations) {
            for (let i = 0; i < typeParameterDeclarations.length; i++) {
                const node = typeParameterDeclarations[i];
                checkTypeParameter(node);
                addLazyDiagnostic(createCheckTypeParameterDiagnostic(node, i));
            }
        }
        function createCheckTypeParameterDiagnostic(node, i) {
            return () => {
                if (node.default) {
                    seenDefault = true;
                    checkTypeParametersNotReferenced(node.default, typeParameterDeclarations, i);
                } else if (seenDefault) {
                    error(node, Diagnostics.Required_type_parameters_may_not_follow_optional_type_parameters);
                }
                for (let j = 0; j < i; j++) {
                    if (typeParameterDeclarations[j].symbol === node.symbol) {
                        error(node.name, Diagnostics.Duplicate_identifier_0, declarationNameToString(node.name));
                    }
                }
            };
        }
    }
    function checkTypeParametersNotReferenced(root, typeParameters, index) {
        visit(root);
        function visit(node) {
            if (node.kind === 180) {
                const type = getTypeFromTypeReference(node);
                if (type.flags & 262144) {
                    for (let i = index; i < typeParameters.length; i++) {
                        if (type.symbol === getSymbolOfDeclaration(typeParameters[i])) {
                            error(node, Diagnostics.Type_parameter_defaults_can_only_reference_previously_declared_type_parameters);
                        }
                    }
                }
            }
            forEachChild(node, visit);
        }
    }
    function checkTypeParameterListsIdentical(symbol) {
        if (symbol.declarations && symbol.declarations.length === 1) {
            return;
        }
        const links = getSymbolLinks(symbol);
        if (!links.typeParametersChecked) {
            links.typeParametersChecked = true;
            const declarations = getClassOrInterfaceDeclarationsOfSymbol(symbol);
            if (!declarations || declarations.length <= 1) {
                return;
            }
            const type = getDeclaredTypeOfSymbol(symbol);
            if (!areTypeParametersIdentical(declarations, type.localTypeParameters, getEffectiveTypeParameterDeclarations)) {
                const name = symbolToString(symbol);
                for (const declaration of declarations) {
                    error(declaration.name, Diagnostics.All_declarations_of_0_must_have_identical_type_parameters, name);
                }
            }
        }
    }
    function areTypeParametersIdentical(declarations, targetParameters, getTypeParameterDeclarations) {
        const maxTypeArgumentCount = length(targetParameters);
        const minTypeArgumentCount = getMinTypeArgumentCount(targetParameters);
        for (const declaration of declarations) {
            const sourceParameters = getTypeParameterDeclarations(declaration);
            const numTypeParameters = sourceParameters.length;
            if (numTypeParameters < minTypeArgumentCount || numTypeParameters > maxTypeArgumentCount) {
                return false;
            }
            for (let i = 0; i < numTypeParameters; i++) {
                const source = sourceParameters[i];
                const target = targetParameters[i];
                if (source.name.escapedText !== target.symbol.escapedName) {
                    return false;
                }
                const constraint = getEffectiveConstraintOfTypeParameter(source);
                const sourceConstraint = constraint && getTypeFromTypeNode(constraint);
                const targetConstraint = getConstraintOfTypeParameter(target);
                if (sourceConstraint && targetConstraint && !isTypeIdenticalTo(sourceConstraint, targetConstraint)) {
                    return false;
                }
                const sourceDefault = source.default && getTypeFromTypeNode(source.default);
                const targetDefault = getDefaultFromTypeParameter(target);
                if (sourceDefault && targetDefault && !isTypeIdenticalTo(sourceDefault, targetDefault)) {
                    return false;
                }
            }
        }
        return true;
    }
    function getFirstTransformableStaticClassElement(node) {
        var _a2;
        const willTransformStaticElementsOfDecoratedClass = !legacyDecorators && languageVersion < 99 && classOrConstructorParameterIsDecorated(false, node);
        const willTransformPrivateElementsOrClassStaticBlocks = languageVersion <= 9;
        const willTransformInitializers = !useDefineForClassFields || languageVersion < 9;
        if (willTransformStaticElementsOfDecoratedClass || willTransformPrivateElementsOrClassStaticBlocks) {
            for (const member of node.members) {
                if (willTransformStaticElementsOfDecoratedClass && classElementOrClassElementParameterIsDecorated(false, member, node)) {
                    return (_a2 = firstOrUndefined(getDecorators(node))) != null ? _a2 : node;
                } else if (willTransformPrivateElementsOrClassStaticBlocks) {
                    if (isClassStaticBlockDeclaration(member)) {
                        return member;
                    } else if (isStatic(member)) {
                        if (isPrivateIdentifierClassElementDeclaration(member) || willTransformInitializers && isInitializedProperty(member)) {
                            return member;
                        }
                    }
                }
            }
        }
    }
    function checkClassExpressionExternalHelpers(node) {
        var _a2;
        if (node.name) return;
        const parent2 = walkUpOuterExpressions(node);
        if (!isNamedEvaluationSource(parent2)) return;
        const willTransformESDecorators = !legacyDecorators && languageVersion < 99;
        let location;
        if (willTransformESDecorators && classOrConstructorParameterIsDecorated(false, node)) {
            location = (_a2 = firstOrUndefined(getDecorators(node))) != null ? _a2 : node;
        } else {
            location = getFirstTransformableStaticClassElement(node);
        }
        if (location) {
            checkExternalEmitHelpers(location, 8388608);
            if ((isPropertyAssignment(parent2) || isPropertyDeclaration(parent2) || isBindingElement(parent2)) && isComputedPropertyName(parent2.name)) {
                checkExternalEmitHelpers(location, 16777216);
            }
        }
    }
    function checkClassExpression(node) {
        checkClassLikeDeclaration(node);
        checkNodeDeferred(node);
        checkClassExpressionExternalHelpers(node);
        return getTypeOfSymbol(getSymbolOfDeclaration(node));
    }
    function checkClassExpressionDeferred(node) {
        forEach(node.members, checkSourceElement);
        registerForUnusedIdentifiersCheck(node);
    }
    function checkClassDeclaration(node) {
        const firstDecorator = find(node.modifiers, isDecorator);
        if (legacyDecorators && firstDecorator && some(node.members, p => hasStaticModifier(p) && isPrivateIdentifierClassElementDeclaration(p))) {
            grammarErrorOnNode(firstDecorator, Diagnostics.Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator);
        }
        if (!node.name && !hasSyntacticModifier(node, 1024)) {
            grammarErrorOnFirstToken(node, Diagnostics.A_class_declaration_without_the_default_modifier_must_have_a_name);
        }
        checkClassLikeDeclaration(node);
        forEach(node.members, checkSourceElement);
        registerForUnusedIdentifiersCheck(node);
    }
    function checkClassLikeDeclaration(node) {
        checkGrammarClassLikeDeclaration(node);
        checkDecorators(node);
        checkCollisionsForDeclarationName(node, node.name);
        checkTypeParameters(getEffectiveTypeParameterDeclarations(node));
        checkExportsOnMergedDeclarations(node);
        const symbol = getSymbolOfDeclaration(node);
        const type = getDeclaredTypeOfSymbol(symbol);
        const typeWithThis = getTypeWithThisArgument(type);
        const staticType = getTypeOfSymbol(symbol);
        checkTypeParameterListsIdentical(symbol);
        checkFunctionOrConstructorSymbol(symbol);
        checkClassForDuplicateDeclarations(node);
        const nodeInAmbientContext = !!(node.flags & 16777216);
        if (!nodeInAmbientContext) {
            checkClassForStaticPropertyNameConflicts(node);
        }
        const baseTypeNode = getEffectiveBaseTypeNode(node);
        if (baseTypeNode) {
            forEach(baseTypeNode.typeArguments, checkSourceElement);
            if (languageVersion < 2) {
                checkExternalEmitHelpers(baseTypeNode.parent, 1);
            }
            const extendsNode = getClassExtendsHeritageElement(node);
            if (extendsNode && extendsNode !== baseTypeNode) {
                checkExpression(extendsNode.expression);
            }
            const baseTypes = getBaseTypes(type);
            if (baseTypes.length) {
                addLazyDiagnostic(() => {
                    const baseType = baseTypes[0];
                    const baseConstructorType = getBaseConstructorTypeOfClass(type);
                    const staticBaseType = getApparentType(baseConstructorType);
                    checkBaseTypeAccessibility(staticBaseType, baseTypeNode);
                    checkSourceElement(baseTypeNode.expression);
                    if (some(baseTypeNode.typeArguments)) {
                        forEach(baseTypeNode.typeArguments, checkSourceElement);
                        for (const constructor of getConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode)) {
                            if (!checkTypeArgumentConstraints(baseTypeNode, constructor.typeParameters)) {
                                break;
                            }
                        }
                    }
                    const baseWithThis = getTypeWithThisArgument(baseType, type.thisType);
                    if (!checkTypeAssignableTo(typeWithThis, baseWithThis, void 0)) {
                        issueMemberSpecificError(node, typeWithThis, baseWithThis, Diagnostics.Class_0_incorrectly_extends_base_class_1);
                    } else {
                        checkTypeAssignableTo(staticType, getTypeWithoutSignatures(staticBaseType), node.name || node, Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1);
                    }
                    if (baseConstructorType.flags & 8650752) {
                        if (!isMixinConstructorType(staticType)) {
                            error(node.name || node, Diagnostics.A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any);
                        } else {
                            const constructSignatures = getSignaturesOfType(baseConstructorType, 1);
                            if (constructSignatures.some(signature => signature.flags & 4) && !hasSyntacticModifier(node, 256)) {
                                error(node.name || node, Diagnostics.A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract);
                            }
                        }
                    }
                    if (!(staticBaseType.symbol && staticBaseType.symbol.flags & 32) && !(baseConstructorType.flags & 8650752)) {
                        const constructors = getInstantiatedConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode);
                        if (forEach(constructors, sig => !isJSConstructor(sig.declaration) && !isTypeIdenticalTo(getReturnTypeOfSignature(sig), baseType))) {
                            error(baseTypeNode.expression, Diagnostics.Base_constructors_must_all_have_the_same_return_type);
                        }
                    }
                    checkKindsOfPropertyMemberOverrides(type, baseType);
                });
            }
        }
        checkMembersForOverrideModifier(node, type, typeWithThis, staticType);
        const implementedTypeNodes = getEffectiveImplementsTypeNodes(node);
        if (implementedTypeNodes) {
            for (const typeRefNode of implementedTypeNodes) {
                if (!isEntityNameExpression(typeRefNode.expression) || isOptionalChain(typeRefNode.expression)) {
                    error(typeRefNode.expression, Diagnostics.A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments);
                }
                checkTypeReferenceNode(typeRefNode);
                addLazyDiagnostic(createImplementsDiagnostics(typeRefNode));
            }
        }
        addLazyDiagnostic(() => {
            checkIndexConstraints(type, symbol);
            checkIndexConstraints(staticType, symbol, true);
            checkTypeForDuplicateIndexSignatures(node);
            checkPropertyInitialization(node);
        });
        function createImplementsDiagnostics(typeRefNode) {
            return () => {
                const t = getReducedType(getTypeFromTypeNode(typeRefNode));
                if (!isErrorType(t)) {
                    if (isValidBaseType(t)) {
                        const genericDiag = t.symbol && t.symbol.flags & 32 ? Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass : Diagnostics.Class_0_incorrectly_implements_interface_1;
                        const baseWithThis = getTypeWithThisArgument(t, type.thisType);
                        if (!checkTypeAssignableTo(typeWithThis, baseWithThis, void 0)) {
                            issueMemberSpecificError(node, typeWithThis, baseWithThis, genericDiag);
                        }
                    } else {
                        error(typeRefNode, Diagnostics.A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members);
                    }
                }
            };
        }
    }
    function checkMembersForOverrideModifier(node, type, typeWithThis, staticType) {
        const baseTypeNode = getEffectiveBaseTypeNode(node);
        const baseTypes = baseTypeNode && getBaseTypes(type);
        const baseWithThis = (baseTypes == null ? void 0 : baseTypes.length) ? getTypeWithThisArgument(first(baseTypes), type.thisType) : void 0;
        const baseStaticType = getBaseConstructorTypeOfClass(type);
        for (const member of node.members) {
            if (hasAmbientModifier(member)) {
                continue;
            }
            if (isConstructorDeclaration(member)) {
                forEach(member.parameters, param => {
                    if (isParameterPropertyDeclaration(param, member)) {
                        checkExistingMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type, typeWithThis, param, true);
                    }
                });
            }
            checkExistingMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type, typeWithThis, member, false);
        }
    }
    function checkExistingMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type, typeWithThis, member, memberIsParameterProperty, reportErrors2 = true) {
        const declaredProp = member.name && getSymbolAtLocation(member.name) || getSymbolAtLocation(member);
        if (!declaredProp) {
            return 0;
        }
        return checkMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type, typeWithThis, hasOverrideModifier(member), hasAbstractModifier(member), isStatic(member), memberIsParameterProperty, symbolName(declaredProp), reportErrors2 ? member : void 0);
    }
    function checkMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type, typeWithThis, memberHasOverrideModifier, memberHasAbstractModifier, memberIsStatic, memberIsParameterProperty, memberName, errorNode) {
        const isJs = isInJSFile(node);
        const nodeInAmbientContext = !!(node.flags & 16777216);
        if (baseWithThis && (memberHasOverrideModifier || compilerOptions.noImplicitOverride)) {
            const memberEscapedName = escapeLeadingUnderscores(memberName);
            const thisType = memberIsStatic ? staticType : typeWithThis;
            const baseType = memberIsStatic ? baseStaticType : baseWithThis;
            const prop = getPropertyOfType(thisType, memberEscapedName);
            const baseProp = getPropertyOfType(baseType, memberEscapedName);
            const baseClassName = typeToString(baseWithThis);
            if (prop && !baseProp && memberHasOverrideModifier) {
                if (errorNode) {
                    const suggestion = getSuggestedSymbolForNonexistentClassMember(memberName, baseType);
                    suggestion ? error(errorNode, isJs ? Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1 : Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1, baseClassName, symbolToString(suggestion)) : error(errorNode, isJs ? Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0 : Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0, baseClassName);
                }
                return 2;
            } else if (prop && (baseProp == null ? void 0 : baseProp.declarations) && compilerOptions.noImplicitOverride && !nodeInAmbientContext) {
                const baseHasAbstract = some(baseProp.declarations, hasAbstractModifier);
                if (memberHasOverrideModifier) {
                    return 0;
                }
                if (!baseHasAbstract) {
                    if (errorNode) {
                        const diag2 = memberIsParameterProperty ? isJs ? Diagnostics.This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 : Diagnostics.This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0 : isJs ? Diagnostics.This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 : Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0;
                        error(errorNode, diag2, baseClassName);
                    }
                    return 1;
                } else if (memberHasAbstractModifier && baseHasAbstract) {
                    if (errorNode) {
                        error(errorNode, Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0, baseClassName);
                    }
                    return 1;
                }
            }
        } else if (memberHasOverrideModifier) {
            if (errorNode) {
                const className = typeToString(type);
                error(errorNode, isJs ? Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class : Diagnostics.This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class, className);
            }
            return 2;
        }
        return 0;
    }
    function issueMemberSpecificError(node, typeWithThis, baseWithThis, broadDiag) {
        let issuedMemberError = false;
        for (const member of node.members) {
            if (isStatic(member)) {
                continue;
            }
            const declaredProp = member.name && getSymbolAtLocation(member.name) || getSymbolAtLocation(member);
            if (declaredProp) {
                const prop = getPropertyOfType(typeWithThis, declaredProp.escapedName);
                const baseProp = getPropertyOfType(baseWithThis, declaredProp.escapedName);
                if (prop && baseProp) {
                    const rootChain = () => chainDiagnosticMessages(void 0, Diagnostics.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2, symbolToString(declaredProp), typeToString(typeWithThis), typeToString(baseWithThis));
                    if (!checkTypeAssignableTo(getTypeOfSymbol(prop), getTypeOfSymbol(baseProp), member.name || member, void 0, rootChain)) {
                        issuedMemberError = true;
                    }
                }
            }
        }
        if (!issuedMemberError) {
            checkTypeAssignableTo(typeWithThis, baseWithThis, node.name || node, broadDiag);
        }
    }
    function checkBaseTypeAccessibility(type, node) {
        const signatures = getSignaturesOfType(type, 1);
        if (signatures.length) {
            const declaration = signatures[0].declaration;
            if (declaration && hasEffectiveModifier(declaration, 8)) {
                const typeClassDeclaration = getClassLikeDeclarationOfSymbol(type.symbol);
                if (!isNodeWithinClass(node, typeClassDeclaration)) {
                    error(node, Diagnostics.Cannot_extend_a_class_0_Class_constructor_is_marked_as_private, getFullyQualifiedName(type.symbol));
                }
            }
        }
    }
    function getMemberOverrideModifierStatus(node, member, memberSymbol) {
        if (!member.name) {
            return 0;
        }
        const classSymbol = getSymbolOfDeclaration(node);
        const type = getDeclaredTypeOfSymbol(classSymbol);
        const typeWithThis = getTypeWithThisArgument(type);
        const staticType = getTypeOfSymbol(classSymbol);
        const baseTypeNode = getEffectiveBaseTypeNode(node);
        const baseTypes = baseTypeNode && getBaseTypes(type);
        const baseWithThis = (baseTypes == null ? void 0 : baseTypes.length) ? getTypeWithThisArgument(first(baseTypes), type.thisType) : void 0;
        const baseStaticType = getBaseConstructorTypeOfClass(type);
        const memberHasOverrideModifier = member.parent ? hasOverrideModifier(member) : hasSyntacticModifier(member, 16384);
        return checkMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type, typeWithThis, memberHasOverrideModifier, hasAbstractModifier(member), isStatic(member), false, symbolName(memberSymbol));
    }
    function getTargetSymbol(s) {
        return getCheckFlags(s) & 1 ? s.links.target : s;
    }
    function getClassOrInterfaceDeclarationsOfSymbol(symbol) {
        return filter(symbol.declarations, d => d.kind === 260 || d.kind === 261);
    }
    function checkKindsOfPropertyMemberOverrides(type, baseType) {
        var _a2, _b, _c, _d;
        const baseProperties = getPropertiesOfType(baseType);
        basePropertyCheck: for (const baseProperty of baseProperties) {
            const base = getTargetSymbol(baseProperty);
            if (base.flags & 4194304) {
                continue;
            }
            const baseSymbol = getPropertyOfObjectType(type, base.escapedName);
            if (!baseSymbol) {
                continue;
            }
            const derived = getTargetSymbol(baseSymbol);
            const baseDeclarationFlags = getDeclarationModifierFlagsFromSymbol(base);
            Debug.assert(!!derived, "derived should point to something, even if it is the base class' declaration.");
            if (derived === base) {
                const derivedClassDecl = getClassLikeDeclarationOfSymbol(type.symbol);
                if (baseDeclarationFlags & 256 && (!derivedClassDecl || !hasSyntacticModifier(derivedClassDecl, 256))) {
                    for (const otherBaseType of getBaseTypes(type)) {
                        if (otherBaseType === baseType) continue;
                        const baseSymbol2 = getPropertyOfObjectType(otherBaseType, base.escapedName);
                        const derivedElsewhere = baseSymbol2 && getTargetSymbol(baseSymbol2);
                        if (derivedElsewhere && derivedElsewhere !== base) {
                            continue basePropertyCheck;
                        }
                    }
                    if (derivedClassDecl.kind === 228) {
                        error(derivedClassDecl, Diagnostics.Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1, symbolToString(baseProperty), typeToString(baseType));
                    } else {
                        error(derivedClassDecl, Diagnostics.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2, typeToString(type), symbolToString(baseProperty), typeToString(baseType));
                    }
                }
            } else {
                const derivedDeclarationFlags = getDeclarationModifierFlagsFromSymbol(derived);
                if (baseDeclarationFlags & 8 || derivedDeclarationFlags & 8) {
                    continue;
                }
                let errorMessage;
                const basePropertyFlags = base.flags & 98308;
                const derivedPropertyFlags = derived.flags & 98308;
                if (basePropertyFlags && derivedPropertyFlags) {
                    if ((getCheckFlags(base) & 6 ? (_a2 = base.declarations) == null ? void 0 : _a2.some(d => isPropertyAbstractOrInterface(d, baseDeclarationFlags)) : (_b = base.declarations) == null ? void 0 : _b.every(d => isPropertyAbstractOrInterface(d, baseDeclarationFlags))) || getCheckFlags(base) & 262144 || derived.valueDeclaration && isBinaryExpression(derived.valueDeclaration)) {
                        continue;
                    }
                    const overriddenInstanceProperty = basePropertyFlags !== 4 && derivedPropertyFlags === 4;
                    const overriddenInstanceAccessor = basePropertyFlags === 4 && derivedPropertyFlags !== 4;
                    if (overriddenInstanceProperty || overriddenInstanceAccessor) {
                        const errorMessage2 = overriddenInstanceProperty ? Diagnostics._0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property : Diagnostics._0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor;
                        error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage2, symbolToString(base), typeToString(baseType), typeToString(type));
                    } else if (useDefineForClassFields) {
                        const uninitialized = (_c = derived.declarations) == null ? void 0 : _c.find(d => d.kind === 169 && !d.initializer);
                        if (uninitialized && !(derived.flags & 33554432) && !(baseDeclarationFlags & 256) && !(derivedDeclarationFlags & 256) && !((_d = derived.declarations) == null ? void 0 : _d.some(d => !!(d.flags & 16777216)))) {
                            const constructor = findConstructorDeclaration(getClassLikeDeclarationOfSymbol(type.symbol));
                            const propName = uninitialized.name;
                            if (uninitialized.exclamationToken || !constructor || !isIdentifier(propName) || !strictNullChecks || !isPropertyInitializedInConstructor(propName, type, constructor)) {
                                const errorMessage2 = Diagnostics.Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration;
                                error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage2, symbolToString(base), typeToString(baseType));
                            }
                        }
                    }
                    continue;
                } else if (isPrototypeProperty(base)) {
                    if (isPrototypeProperty(derived) || derived.flags & 4) {
                        continue;
                    } else {
                        Debug.assert(!!(derived.flags & 98304));
                        errorMessage = Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;
                    }
                } else if (base.flags & 98304) {
                    errorMessage = Diagnostics.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;
                } else {
                    errorMessage = Diagnostics.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;
                }
                error(getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, typeToString(baseType), symbolToString(base), typeToString(type));
            }
        }
    }
    function isPropertyAbstractOrInterface(declaration, baseDeclarationFlags) {
        return baseDeclarationFlags & 256 && (!isPropertyDeclaration(declaration) || !declaration.initializer) || isInterfaceDeclaration(declaration.parent);
    }
    function getNonInheritedProperties(type, baseTypes, properties) {
        if (!length(baseTypes)) {
            return properties;
        }
        const seen = /* @__PURE__ */new Map();
        forEach(properties, p => {
            seen.set(p.escapedName, p);
        });
        for (const base of baseTypes) {
            const properties2 = getPropertiesOfType(getTypeWithThisArgument(base, type.thisType));
            for (const prop of properties2) {
                const existing = seen.get(prop.escapedName);
                if (existing && prop.parent === existing.parent) {
                    seen.delete(prop.escapedName);
                }
            }
        }
        return arrayFrom(seen.values());
    }
    function checkInheritedPropertiesAreIdentical(type, typeNode) {
        const baseTypes = getBaseTypes(type);
        if (baseTypes.length < 2) {
            return true;
        }
        const seen = /* @__PURE__ */new Map();
        forEach(resolveDeclaredMembers(type).declaredProperties, p => {
            seen.set(p.escapedName, {
                prop: p,
                containingType: type
            });
        });
        let ok = true;
        for (const base of baseTypes) {
            const properties = getPropertiesOfType(getTypeWithThisArgument(base, type.thisType));
            for (const prop of properties) {
                const existing = seen.get(prop.escapedName);
                if (!existing) {
                    seen.set(prop.escapedName, {
                        prop,
                        containingType: base
                    });
                } else {
                    const isInheritedProperty = existing.containingType !== type;
                    if (isInheritedProperty && !isPropertyIdenticalTo(existing.prop, prop)) {
                        ok = false;
                        const typeName1 = typeToString(existing.containingType);
                        const typeName2 = typeToString(base);
                        let errorInfo = chainDiagnosticMessages(void 0, Diagnostics.Named_property_0_of_types_1_and_2_are_not_identical, symbolToString(prop), typeName1, typeName2);
                        errorInfo = chainDiagnosticMessages(errorInfo, Diagnostics.Interface_0_cannot_simultaneously_extend_types_1_and_2, typeToString(type), typeName1, typeName2);
                        diagnostics.add(createDiagnosticForNodeFromMessageChain(getSourceFileOfNode(typeNode), typeNode, errorInfo));
                    }
                }
            }
        }
        return ok;
    }
    function checkPropertyInitialization(node) {
        if (!strictNullChecks || !strictPropertyInitialization || node.flags & 16777216) {
            return;
        }
        const constructor = findConstructorDeclaration(node);
        for (const member of node.members) {
            if (getEffectiveModifierFlags(member) & 2) {
                continue;
            }
            if (!isStatic(member) && isPropertyWithoutInitializer(member)) {
                const propName = member.name;
                if (isIdentifier(propName) || isPrivateIdentifier(propName) || isComputedPropertyName(propName)) {
                    const type = getTypeOfSymbol(getSymbolOfDeclaration(member));
                    if (!(type.flags & 3 || containsUndefinedType(type))) {
                        if (!constructor || !isPropertyInitializedInConstructor(propName, type, constructor)) {
                            error(member.name, Diagnostics.Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor, declarationNameToString(propName));
                        }
                    }
                }
            }
        }
    }
    function isPropertyWithoutInitializer(node) {
        return node.kind === 169 && !hasAbstractModifier(node) && !node.exclamationToken && !node.initializer;
    }
    function isPropertyInitializedInStaticBlocks(propName, propType, staticBlocks, startPos, endPos) {
        for (const staticBlock of staticBlocks) {
            if (staticBlock.pos >= startPos && staticBlock.pos <= endPos) {
                const reference = factory.createPropertyAccessExpression(factory.createThis(), propName);
                setParent(reference.expression, reference);
                setParent(reference, staticBlock);
                reference.flowNode = staticBlock.returnFlowNode;
                const flowType = getFlowTypeOfReference(reference, propType, getOptionalType(propType));
                if (!containsUndefinedType(flowType)) {
                    return true;
                }
            }
        }
        return false;
    }
    function isPropertyInitializedInConstructor(propName, propType, constructor) {
        const reference = isComputedPropertyName(propName) ? factory.createElementAccessExpression(factory.createThis(), propName.expression) : factory.createPropertyAccessExpression(factory.createThis(), propName);
        setParent(reference.expression, reference);
        setParent(reference, constructor);
        reference.flowNode = constructor.returnFlowNode;
        const flowType = getFlowTypeOfReference(reference, propType, getOptionalType(propType));
        return !containsUndefinedType(flowType);
    }
    function checkInterfaceDeclaration(node) {
        if (!checkGrammarModifiers(node)) checkGrammarInterfaceDeclaration(node);
        checkTypeParameters(node.typeParameters);
        addLazyDiagnostic(() => {
            checkTypeNameIsReserved(node.name, Diagnostics.Interface_name_cannot_be_0);
            checkExportsOnMergedDeclarations(node);
            const symbol = getSymbolOfDeclaration(node);
            checkTypeParameterListsIdentical(symbol);
            const firstInterfaceDecl = getDeclarationOfKind(symbol, 261);
            if (node === firstInterfaceDecl) {
                const type = getDeclaredTypeOfSymbol(symbol);
                const typeWithThis = getTypeWithThisArgument(type);
                if (checkInheritedPropertiesAreIdentical(type, node.name)) {
                    for (const baseType of getBaseTypes(type)) {
                        checkTypeAssignableTo(typeWithThis, getTypeWithThisArgument(baseType, type.thisType), node.name, Diagnostics.Interface_0_incorrectly_extends_interface_1);
                    }
                    checkIndexConstraints(type, symbol);
                }
            }
            checkObjectTypeForDuplicateDeclarations(node);
        });
        forEach(getInterfaceBaseTypeNodes(node), heritageElement => {
            if (!isEntityNameExpression(heritageElement.expression) || isOptionalChain(heritageElement.expression)) {
                error(heritageElement.expression, Diagnostics.An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments);
            }
            checkTypeReferenceNode(heritageElement);
        });
        forEach(node.members, checkSourceElement);
        addLazyDiagnostic(() => {
            checkTypeForDuplicateIndexSignatures(node);
            registerForUnusedIdentifiersCheck(node);
        });
    }
    function checkTypeAliasDeclaration(node) {
        checkGrammarModifiers(node);
        checkTypeNameIsReserved(node.name, Diagnostics.Type_alias_name_cannot_be_0);
        checkExportsOnMergedDeclarations(node);
        checkTypeParameters(node.typeParameters);
        if (node.type.kind === 139) {
            if (!intrinsicTypeKinds.has(node.name.escapedText) || length(node.typeParameters) !== 1) {
                error(node.type, Diagnostics.The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types);
            }
        } else {
            checkSourceElement(node.type);
            registerForUnusedIdentifiersCheck(node);
        }
    }
    function computeEnumMemberValues(node) {
        const nodeLinks2 = getNodeLinks(node);
        if (!(nodeLinks2.flags & 1024)) {
            nodeLinks2.flags |= 1024;
            let autoValue = 0;
            for (const member of node.members) {
                const value = computeMemberValue(member, autoValue);
                getNodeLinks(member).enumMemberValue = value;
                autoValue = typeof value === "number" ? value + 1 : void 0;
            }
        }
    }
    function computeMemberValue(member, autoValue) {
        if (isComputedNonLiteralName(member.name)) {
            error(member.name, Diagnostics.Computed_property_names_are_not_allowed_in_enums);
        } else {
            const text = getTextOfPropertyName(member.name);
            if (isNumericLiteralName(text) && !isInfinityOrNaNString(text)) {
                error(member.name, Diagnostics.An_enum_member_cannot_have_a_numeric_name);
            }
        }
        if (member.initializer) {
            return computeConstantValue(member);
        }
        if (member.parent.flags & 16777216 && !isEnumConst(member.parent)) {
            return void 0;
        }
        if (autoValue !== void 0) {
            return autoValue;
        }
        error(member.name, Diagnostics.Enum_member_must_have_initializer);
        return void 0;
    }
    function computeConstantValue(member) {
        const isConstEnum = isEnumConst(member.parent);
        const initializer = member.initializer;
        const value = evaluate(initializer, member);
        if (value !== void 0) {
            if (isConstEnum && typeof value === "number" && !isFinite(value)) {
                error(initializer, isNaN(value) ? Diagnostics.const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN : Diagnostics.const_enum_member_initializer_was_evaluated_to_a_non_finite_value);
            }
        } else if (isConstEnum) {
            error(initializer, Diagnostics.const_enum_member_initializers_must_be_constant_expressions);
        } else if (member.parent.flags & 16777216) {
            error(initializer, Diagnostics.In_ambient_enum_declarations_member_initializer_must_be_constant_expression);
        } else {
            checkTypeAssignableTo(checkExpression(initializer), numberType, initializer, Diagnostics.Type_0_is_not_assignable_to_type_1_as_required_for_computed_enum_member_values);
        }
        return value;
    }
    function evaluate(expr, location) {
        switch (expr.kind) {
            case 221:
                const value = evaluate(expr.operand, location);
                if (typeof value === "number") {
                    switch (expr.operator) {
                        case 39:
                            return value;
                        case 40:
                            return -value;
                        case 54:
                            return ~value;
                    }
                }
                break;
            case 223:
                const left = evaluate(expr.left, location);
                const right = evaluate(expr.right, location);
                if (typeof left === "number" && typeof right === "number") {
                    switch (expr.operatorToken.kind) {
                        case 51:
                            return left | right;
                        case 50:
                            return left & right;
                        case 48:
                            return left >> right;
                        case 49:
                            return left >>> right;
                        case 47:
                            return left << right;
                        case 52:
                            return left ^ right;
                        case 41:
                            return left * right;
                        case 43:
                            return left / right;
                        case 39:
                            return left + right;
                        case 40:
                            return left - right;
                        case 44:
                            return left % right;
                        case 42:
                            return left ** right;
                    }
                } else if ((typeof left === "string" || typeof left === "number") && (typeof right === "string" || typeof right === "number") && expr.operatorToken.kind === 39) {
                    return "" + left + right;
                }
                break;
            case 10:
            case 14:
                return expr.text;
            case 225:
                return evaluateTemplateExpression(expr, location);
            case 8:
                checkGrammarNumericLiteral(expr);
                return +expr.text;
            case 214:
                return evaluate(expr.expression, location);
            case 79:
                if (isInfinityOrNaNString(expr.escapedText)) {
                    return +expr.escapedText;
                }
            case 208:
                if (isEntityNameExpression(expr)) {
                    const symbol = resolveEntityName(expr, 111551, true);
                    if (symbol) {
                        if (symbol.flags & 8) {
                            return evaluateEnumMember(expr, symbol, location);
                        }
                        if (isConstVariable(symbol)) {
                            const declaration = symbol.valueDeclaration;
                            if (declaration && !declaration.type && declaration.initializer && declaration !== location && isBlockScopedNameDeclaredBeforeUse(declaration, location)) {
                                return evaluate(declaration.initializer, declaration);
                            }
                        }
                    }
                }
                break;
            case 209:
                const root = expr.expression;
                if (isEntityNameExpression(root) && isStringLiteralLike(expr.argumentExpression)) {
                    const rootSymbol = resolveEntityName(root, 111551, true);
                    if (rootSymbol && rootSymbol.flags & 384) {
                        const name = escapeLeadingUnderscores(expr.argumentExpression.text);
                        const member = rootSymbol.exports.get(name);
                        if (member) {
                            return evaluateEnumMember(expr, member, location);
                        }
                    }
                }
                break;
        }
        return void 0;
    }
    function evaluateEnumMember(expr, symbol, location) {
        const declaration = symbol.valueDeclaration;
        if (!declaration || declaration === location) {
            error(expr, Diagnostics.Property_0_is_used_before_being_assigned, symbolToString(symbol));
            return void 0;
        }
        if (!isBlockScopedNameDeclaredBeforeUse(declaration, location)) {
            error(expr, Diagnostics.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums);
            return 0;
        }
        return getEnumMemberValue(declaration);
    }
    function evaluateTemplateExpression(expr, location) {
        let result = expr.head.text;
        for (const span of expr.templateSpans) {
            const value = evaluate(span.expression, location);
            if (value === void 0) {
                return void 0;
            }
            result += value;
            result += span.literal.text;
        }
        return result;
    }
    function checkEnumDeclaration(node) {
        addLazyDiagnostic(() => checkEnumDeclarationWorker(node));
    }
    function checkEnumDeclarationWorker(node) {
        checkGrammarModifiers(node);
        checkCollisionsForDeclarationName(node, node.name);
        checkExportsOnMergedDeclarations(node);
        node.members.forEach(checkEnumMember);
        computeEnumMemberValues(node);
        const enumSymbol = getSymbolOfDeclaration(node);
        const firstDeclaration = getDeclarationOfKind(enumSymbol, node.kind);
        if (node === firstDeclaration) {
            if (enumSymbol.declarations && enumSymbol.declarations.length > 1) {
                const enumIsConst = isEnumConst(node);
                forEach(enumSymbol.declarations, decl => {
                    if (isEnumDeclaration(decl) && isEnumConst(decl) !== enumIsConst) {
                        error(getNameOfDeclaration(decl), Diagnostics.Enum_declarations_must_all_be_const_or_non_const);
                    }
                });
            }
            let seenEnumMissingInitialInitializer = false;
            forEach(enumSymbol.declarations, declaration => {
                if (declaration.kind !== 263) {
                    return false;
                }
                const enumDeclaration = declaration;
                if (!enumDeclaration.members.length) {
                    return false;
                }
                const firstEnumMember = enumDeclaration.members[0];
                if (!firstEnumMember.initializer) {
                    if (seenEnumMissingInitialInitializer) {
                        error(firstEnumMember.name, Diagnostics.In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element);
                    } else {
                        seenEnumMissingInitialInitializer = true;
                    }
                }
            });
        }
    }
    function checkEnumMember(node) {
        if (isPrivateIdentifier(node.name)) {
            error(node, Diagnostics.An_enum_member_cannot_be_named_with_a_private_identifier);
        }
        if (node.initializer) {
            checkExpression(node.initializer);
        }
    }
    function getFirstNonAmbientClassOrFunctionDeclaration(symbol) {
        const declarations = symbol.declarations;
        if (declarations) {
            for (const declaration of declarations) {
                if ((declaration.kind === 260 || declaration.kind === 259 && nodeIsPresent(declaration.body)) && !(declaration.flags & 16777216)) {
                    return declaration;
                }
            }
        }
        return void 0;
    }
    function inSameLexicalScope(node1, node2) {
        const container1 = getEnclosingBlockScopeContainer(node1);
        const container2 = getEnclosingBlockScopeContainer(node2);
        if (isGlobalSourceFile(container1)) {
            return isGlobalSourceFile(container2);
        } else if (isGlobalSourceFile(container2)) {
            return false;
        } else {
            return container1 === container2;
        }
    }
    function checkModuleDeclaration(node) {
        if (node.body) {
            checkSourceElement(node.body);
            if (!isGlobalScopeAugmentation(node)) {
                registerForUnusedIdentifiersCheck(node);
            }
        }
        addLazyDiagnostic(checkModuleDeclarationDiagnostics);
        function checkModuleDeclarationDiagnostics() {
            var _a2, _b;
            const isGlobalAugmentation = isGlobalScopeAugmentation(node);
            const inAmbientContext = node.flags & 16777216;
            if (isGlobalAugmentation && !inAmbientContext) {
                error(node.name, Diagnostics.Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context);
            }
            const isAmbientExternalModule = isAmbientModule(node);
            const contextErrorMessage = isAmbientExternalModule ? Diagnostics.An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file : Diagnostics.A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module;
            if (checkGrammarModuleElementContext(node, contextErrorMessage)) {
                return;
            }
            if (!checkGrammarModifiers(node)) {
                if (!inAmbientContext && node.name.kind === 10) {
                    grammarErrorOnNode(node.name, Diagnostics.Only_ambient_modules_can_use_quoted_names);
                }
            }
            if (isIdentifier(node.name)) {
                checkCollisionsForDeclarationName(node, node.name);
            }
            checkExportsOnMergedDeclarations(node);
            const symbol = getSymbolOfDeclaration(node);
            if (symbol.flags & 512 && !inAmbientContext && isInstantiatedModule(node, shouldPreserveConstEnums(compilerOptions))) {
                if (getIsolatedModules(compilerOptions) && !getSourceFileOfNode(node).externalModuleIndicator) {
                    error(node.name, Diagnostics.Namespaces_are_not_allowed_in_global_script_files_when_0_is_enabled_If_this_file_is_not_intended_to_be_a_global_script_set_moduleDetection_to_force_or_add_an_empty_export_statement, isolatedModulesLikeFlagName);
                }
                if (((_a2 = symbol.declarations) == null ? void 0 : _a2.length) > 1) {
                    const firstNonAmbientClassOrFunc = getFirstNonAmbientClassOrFunctionDeclaration(symbol);
                    if (firstNonAmbientClassOrFunc) {
                        if (getSourceFileOfNode(node) !== getSourceFileOfNode(firstNonAmbientClassOrFunc)) {
                            error(node.name, Diagnostics.A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged);
                        } else if (node.pos < firstNonAmbientClassOrFunc.pos) {
                            error(node.name, Diagnostics.A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged);
                        }
                    }
                    const mergedClass = getDeclarationOfKind(symbol, 260);
                    if (mergedClass && inSameLexicalScope(node, mergedClass)) {
                        getNodeLinks(node).flags |= 2048;
                    }
                }
                if (compilerOptions.verbatimModuleSyntax && node.parent.kind === 308 && (moduleKind === 1 || node.parent.impliedNodeFormat === 1)) {
                    const exportModifier = (_b = node.modifiers) == null ? void 0 : _b.find(m => m.kind === 93);
                    if (exportModifier) {
                        error(exportModifier, Diagnostics.A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled);
                    }
                }
            }
            if (isAmbientExternalModule) {
                if (isExternalModuleAugmentation(node)) {
                    const checkBody = isGlobalAugmentation || getSymbolOfDeclaration(node).flags & 33554432;
                    if (checkBody && node.body) {
                        for (const statement of node.body.statements) {
                            checkModuleAugmentationElement(statement, isGlobalAugmentation);
                        }
                    }
                } else if (isGlobalSourceFile(node.parent)) {
                    if (isGlobalAugmentation) {
                        error(node.name, Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations);
                    } else if (isExternalModuleNameRelative(getTextOfIdentifierOrLiteral(node.name))) {
                        error(node.name, Diagnostics.Ambient_module_declaration_cannot_specify_relative_module_name);
                    }
                } else {
                    if (isGlobalAugmentation) {
                        error(node.name, Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations);
                    } else {
                        error(node.name, Diagnostics.Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces);
                    }
                }
            }
        }
    }
    function checkModuleAugmentationElement(node, isGlobalAugmentation) {
        switch (node.kind) {
            case 240:
                for (const decl of node.declarationList.declarations) {
                    checkModuleAugmentationElement(decl, isGlobalAugmentation);
                }
                break;
            case 274:
            case 275:
                grammarErrorOnFirstToken(node, Diagnostics.Exports_and_export_assignments_are_not_permitted_in_module_augmentations);
                break;
            case 268:
            case 269:
                grammarErrorOnFirstToken(node, Diagnostics.Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module);
                break;
            case 205:
            case 257:
                const name = node.name;
                if (isBindingPattern(name)) {
                    for (const el of name.elements) {
                        checkModuleAugmentationElement(el, isGlobalAugmentation);
                    }
                    break;
                }
            case 260:
            case 263:
            case 259:
            case 261:
            case 264:
            case 262:
                if (isGlobalAugmentation) {
                    return;
                }
                break;
        }
    }
    function getFirstNonModuleExportsIdentifier(node) {
        switch (node.kind) {
            case 79:
                return node;
            case 163:
                do {
                    node = node.left;
                } while (node.kind !== 79);
                return node;
            case 208:
                do {
                    if (isModuleExportsAccessExpression(node.expression) && !isPrivateIdentifier(node.name)) {
                        return node.name;
                    }
                    node = node.expression;
                } while (node.kind !== 79);
                return node;
        }
    }
    function checkExternalImportOrExportDeclaration(node) {
        const moduleName = getExternalModuleName(node);
        if (!moduleName || nodeIsMissing(moduleName)) {
            return false;
        }
        if (!isStringLiteral(moduleName)) {
            error(moduleName, Diagnostics.String_literal_expected);
            return false;
        }
        const inAmbientExternalModule = node.parent.kind === 265 && isAmbientModule(node.parent.parent);
        if (node.parent.kind !== 308 && !inAmbientExternalModule) {
            error(moduleName, node.kind === 275 ? Diagnostics.Export_declarations_are_not_permitted_in_a_namespace : Diagnostics.Import_declarations_in_a_namespace_cannot_reference_a_module);
            return false;
        }
        if (inAmbientExternalModule && isExternalModuleNameRelative(moduleName.text)) {
            if (!isTopLevelInExternalModuleAugmentation(node)) {
                error(node, Diagnostics.Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name);
                return false;
            }
        }
        if (!isImportEqualsDeclaration(node) && node.assertClause) {
            let hasError = false;
            for (const clause of node.assertClause.elements) {
                if (!isStringLiteral(clause.value)) {
                    hasError = true;
                    error(clause.value, Diagnostics.Import_assertion_values_must_be_string_literal_expressions);
                }
            }
            return !hasError;
        }
        return true;
    }
    function checkAliasSymbol(node) {
        var _a2, _b, _c, _d, _e;
        let symbol = getSymbolOfDeclaration(node);
        const target = resolveAlias(symbol);
        if (target !== unknownSymbol) {
            symbol = getMergedSymbol(symbol.exportSymbol || symbol);
            if (isInJSFile(node) && !(target.flags & 111551) && !isTypeOnlyImportOrExportDeclaration(node)) {
                const errorNode = isImportOrExportSpecifier(node) ? node.propertyName || node.name : isNamedDeclaration(node) ? node.name : node;
                Debug.assert(node.kind !== 277);
                if (node.kind === 278) {
                    const diag2 = error(errorNode, Diagnostics.Types_cannot_appear_in_export_declarations_in_JavaScript_files);
                    const alreadyExportedSymbol = (_b = (_a2 = getSourceFileOfNode(node).symbol) == null ? void 0 : _a2.exports) == null ? void 0 : _b.get((node.propertyName || node.name).escapedText);
                    if (alreadyExportedSymbol === target) {
                        const exportingDeclaration = (_c = alreadyExportedSymbol.declarations) == null ? void 0 : _c.find(isJSDocNode);
                        if (exportingDeclaration) {
                            addRelatedInfo(diag2, createDiagnosticForNode(exportingDeclaration, Diagnostics._0_is_automatically_exported_here, unescapeLeadingUnderscores(alreadyExportedSymbol.escapedName)));
                        }
                    }
                } else {
                    Debug.assert(node.kind !== 257);
                    const importDeclaration = findAncestor(node, or(isImportDeclaration, isImportEqualsDeclaration));
                    const moduleSpecifier = (_e = importDeclaration && ((_d = tryGetModuleSpecifierFromDeclaration(importDeclaration)) == null ? void 0 : _d.text)) != null ? _e : "...";
                    const importedIdentifier = unescapeLeadingUnderscores(isIdentifier(errorNode) ? errorNode.escapedText : symbol.escapedName);
                    error(errorNode, Diagnostics._0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation, importedIdentifier, `import("${moduleSpecifier}").${importedIdentifier}`);
                }
                return;
            }
            const targetFlags = getAllSymbolFlags(target);
            const excludedMeanings = (symbol.flags & (111551 | 1048576) ? 111551 : 0) | (symbol.flags & 788968 ? 788968 : 0) | (symbol.flags & 1920 ? 1920 : 0);
            if (targetFlags & excludedMeanings) {
                const message = node.kind === 278 ? Diagnostics.Export_declaration_conflicts_with_exported_declaration_of_0 : Diagnostics.Import_declaration_conflicts_with_local_declaration_of_0;
                error(node, message, symbolToString(symbol));
            }
            if (getIsolatedModules(compilerOptions) && !isTypeOnlyImportOrExportDeclaration(node) && !(node.flags & 16777216)) {
                const typeOnlyAlias = getTypeOnlyAliasDeclaration(symbol);
                const isType = !(targetFlags & 111551);
                if (isType || typeOnlyAlias) {
                    switch (node.kind) {
                        case 270:
                        case 273:
                        case 268:
                            {
                                if (compilerOptions.preserveValueImports || compilerOptions.verbatimModuleSyntax) {
                                    Debug.assertIsDefined(node.name, "An ImportClause with a symbol should have a name");
                                    const message = compilerOptions.verbatimModuleSyntax && isInternalModuleImportEqualsDeclaration(node) ? Diagnostics.An_import_alias_cannot_resolve_to_a_type_or_type_only_declaration_when_verbatimModuleSyntax_is_enabled : isType ? compilerOptions.verbatimModuleSyntax ? Diagnostics._0_is_a_type_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled : Diagnostics._0_is_a_type_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedModules_are_both_enabled : compilerOptions.verbatimModuleSyntax ? Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled : Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedModules_are_both_enabled;
                                    const name = idText(node.kind === 273 ? node.propertyName || node.name : node.name);
                                    addTypeOnlyDeclarationRelatedInfo(error(node, message, name), isType ? void 0 : typeOnlyAlias, name);
                                }
                                if (isType && node.kind === 268 && hasEffectiveModifier(node, 1)) {
                                    error(node, Diagnostics.Cannot_use_export_import_on_a_type_or_type_only_namespace_when_0_is_enabled, isolatedModulesLikeFlagName);
                                }
                                break;
                            }
                        case 278:
                            {
                                if (compilerOptions.verbatimModuleSyntax || getSourceFileOfNode(typeOnlyAlias) !== getSourceFileOfNode(node)) {
                                    const name = idText(node.propertyName || node.name);
                                    const diagnostic = isType ? error(node, Diagnostics.Re_exporting_a_type_when_0_is_enabled_requires_using_export_type, isolatedModulesLikeFlagName) : error(node, Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_1_is_enabled, name, isolatedModulesLikeFlagName);
                                    addTypeOnlyDeclarationRelatedInfo(diagnostic, isType ? void 0 : typeOnlyAlias, name);
                                    break;
                                }
                            }
                    }
                }
                if (compilerOptions.verbatimModuleSyntax && node.kind !== 268 && !isInJSFile(node) && (moduleKind === 1 || getSourceFileOfNode(node).impliedNodeFormat === 1)) {
                    error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled);
                }
            }
            if (isImportSpecifier(node)) {
                const targetSymbol = checkDeprecatedAliasedSymbol(symbol, node);
                if (isDeprecatedAliasedSymbol(targetSymbol) && targetSymbol.declarations) {
                    addDeprecatedSuggestion(node, targetSymbol.declarations, targetSymbol.escapedName);
                }
            }
        }
    }
    function isDeprecatedAliasedSymbol(symbol) {
        return !!symbol.declarations && every(symbol.declarations, d => !!(getCombinedNodeFlags(d) & 268435456));
    }
    function checkDeprecatedAliasedSymbol(symbol, location) {
        if (!(symbol.flags & 2097152)) return symbol;
        const targetSymbol = resolveAlias(symbol);
        if (targetSymbol === unknownSymbol) return targetSymbol;
        while (symbol.flags & 2097152) {
            const target = getImmediateAliasedSymbol(symbol);
            if (target) {
                if (target === targetSymbol) break;
                if (target.declarations && length(target.declarations)) {
                    if (isDeprecatedAliasedSymbol(target)) {
                        addDeprecatedSuggestion(location, target.declarations, target.escapedName);
                        break;
                    } else {
                        if (symbol === targetSymbol) break;
                        symbol = target;
                    }
                }
            } else {
                break;
            }
        }
        return targetSymbol;
    }
    function checkImportBinding(node) {
        checkCollisionsForDeclarationName(node, node.name);
        checkAliasSymbol(node);
        if (node.kind === 273 && idText(node.propertyName || node.name) === "default" && getESModuleInterop(compilerOptions) && moduleKind !== 4 && (moduleKind < 5 || getSourceFileOfNode(node).impliedNodeFormat === 1)) {
            checkExternalEmitHelpers(node, 131072);
        }
    }
    function checkAssertClause(declaration) {
        var _a2;
        if (declaration.assertClause) {
            const validForTypeAssertions = isExclusivelyTypeOnlyImportOrExport(declaration);
            const override = getResolutionModeOverrideForClause(declaration.assertClause, validForTypeAssertions ? grammarErrorOnNode : void 0);
            if (validForTypeAssertions && override) {
                if (!isNightly()) {
                    grammarErrorOnNode(declaration.assertClause, Diagnostics.resolution_mode_assertions_are_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next);
                }
                if (getEmitModuleResolutionKind(compilerOptions) !== 3 && getEmitModuleResolutionKind(compilerOptions) !== 99) {
                    return grammarErrorOnNode(declaration.assertClause, Diagnostics.resolution_mode_assertions_are_only_supported_when_moduleResolution_is_node16_or_nodenext);
                }
                return;
            }
            const mode = moduleKind === 199 && declaration.moduleSpecifier && getUsageModeForExpression(declaration.moduleSpecifier);
            if (mode !== 99 && moduleKind !== 99) {
                return grammarErrorOnNode(declaration.assertClause, moduleKind === 199 ? Diagnostics.Import_assertions_are_not_allowed_on_statements_that_transpile_to_commonjs_require_calls : Diagnostics.Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_or_nodenext);
            }
            if (isImportDeclaration(declaration) ? (_a2 = declaration.importClause) == null ? void 0 : _a2.isTypeOnly : declaration.isTypeOnly) {
                return grammarErrorOnNode(declaration.assertClause, Diagnostics.Import_assertions_cannot_be_used_with_type_only_imports_or_exports);
            }
            if (override) {
                return grammarErrorOnNode(declaration.assertClause, Diagnostics.resolution_mode_can_only_be_set_for_type_only_imports);
            }
        }
    }
    function checkImportDeclaration(node) {
        if (checkGrammarModuleElementContext(node, isInJSFile(node) ? Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module)) {
            return;
        }
        if (!checkGrammarModifiers(node) && hasEffectiveModifiers(node)) {
            grammarErrorOnFirstToken(node, Diagnostics.An_import_declaration_cannot_have_modifiers);
        }
        if (checkExternalImportOrExportDeclaration(node)) {
            const importClause = node.importClause;
            if (importClause && !checkGrammarImportClause(importClause)) {
                if (importClause.name) {
                    checkImportBinding(importClause);
                }
                if (importClause.namedBindings) {
                    if (importClause.namedBindings.kind === 271) {
                        checkImportBinding(importClause.namedBindings);
                        if (moduleKind !== 4 && (moduleKind < 5 || getSourceFileOfNode(node).impliedNodeFormat === 1) && getESModuleInterop(compilerOptions)) {
                            checkExternalEmitHelpers(node, 65536);
                        }
                    } else {
                        const moduleExisted = resolveExternalModuleName(node, node.moduleSpecifier);
                        if (moduleExisted) {
                            forEach(importClause.namedBindings.elements, checkImportBinding);
                        }
                    }
                }
            }
        }
        checkAssertClause(node);
    }
    function checkImportEqualsDeclaration(node) {
        if (checkGrammarModuleElementContext(node, isInJSFile(node) ? Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module)) {
            return;
        }
        checkGrammarModifiers(node);
        if (isInternalModuleImportEqualsDeclaration(node) || checkExternalImportOrExportDeclaration(node)) {
            checkImportBinding(node);
            if (hasSyntacticModifier(node, 1)) {
                markExportAsReferenced(node);
            }
            if (node.moduleReference.kind !== 280) {
                const target = resolveAlias(getSymbolOfDeclaration(node));
                if (target !== unknownSymbol) {
                    const targetFlags = getAllSymbolFlags(target);
                    if (targetFlags & 111551) {
                        const moduleName = getFirstIdentifier(node.moduleReference);
                        if (!(resolveEntityName(moduleName, 111551 | 1920).flags & 1920)) {
                            error(moduleName, Diagnostics.Module_0_is_hidden_by_a_local_declaration_with_the_same_name, declarationNameToString(moduleName));
                        }
                    }
                    if (targetFlags & 788968) {
                        checkTypeNameIsReserved(node.name, Diagnostics.Import_name_cannot_be_0);
                    }
                }
                if (node.isTypeOnly) {
                    grammarErrorOnNode(node, Diagnostics.An_import_alias_cannot_use_import_type);
                }
            } else {
                if (moduleKind >= 5 && getSourceFileOfNode(node).impliedNodeFormat === void 0 && !node.isTypeOnly && !(node.flags & 16777216)) {
                    grammarErrorOnNode(node, Diagnostics.Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead);
                }
            }
        }
    }
    function checkExportDeclaration(node) {
        if (checkGrammarModuleElementContext(node, isInJSFile(node) ? Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_module : Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module)) {
            return;
        }
        if (!checkGrammarModifiers(node) && hasSyntacticModifiers(node)) {
            grammarErrorOnFirstToken(node, Diagnostics.An_export_declaration_cannot_have_modifiers);
        }
        if (node.moduleSpecifier && node.exportClause && isNamedExports(node.exportClause) && length(node.exportClause.elements) && languageVersion === 0) {
            checkExternalEmitHelpers(node, 4194304);
        }
        checkGrammarExportDeclaration(node);
        if (!node.moduleSpecifier || checkExternalImportOrExportDeclaration(node)) {
            if (node.exportClause && !isNamespaceExport(node.exportClause)) {
                forEach(node.exportClause.elements, checkExportSpecifier);
                const inAmbientExternalModule = node.parent.kind === 265 && isAmbientModule(node.parent.parent);
                const inAmbientNamespaceDeclaration = !inAmbientExternalModule && node.parent.kind === 265 && !node.moduleSpecifier && node.flags & 16777216;
                if (node.parent.kind !== 308 && !inAmbientExternalModule && !inAmbientNamespaceDeclaration) {
                    error(node, Diagnostics.Export_declarations_are_not_permitted_in_a_namespace);
                }
            } else {
                const moduleSymbol = resolveExternalModuleName(node, node.moduleSpecifier);
                if (moduleSymbol && hasExportAssignmentSymbol(moduleSymbol)) {
                    error(node.moduleSpecifier, Diagnostics.Module_0_uses_export_and_cannot_be_used_with_export_Asterisk, symbolToString(moduleSymbol));
                } else if (node.exportClause) {
                    checkAliasSymbol(node.exportClause);
                }
                if (moduleKind !== 4 && (moduleKind < 5 || getSourceFileOfNode(node).impliedNodeFormat === 1)) {
                    if (node.exportClause) {
                        if (getESModuleInterop(compilerOptions)) {
                            checkExternalEmitHelpers(node, 65536);
                        }
                    } else {
                        checkExternalEmitHelpers(node, 32768);
                    }
                }
            }
        }
        checkAssertClause(node);
    }
    function checkGrammarExportDeclaration(node) {
        var _a2;
        if (node.isTypeOnly && ((_a2 = node.exportClause) == null ? void 0 : _a2.kind) === 276) {
            return checkGrammarNamedImportsOrExports(node.exportClause);
        }
        return false;
    }
    function checkGrammarModuleElementContext(node, errorMessage) {
        const isInAppropriateContext = node.parent.kind === 308 || node.parent.kind === 265 || node.parent.kind === 264;
        if (!isInAppropriateContext) {
            grammarErrorOnFirstToken(node, errorMessage);
        }
        return !isInAppropriateContext;
    }
    function importClauseContainsReferencedImport(importClause) {
        return forEachImportClauseDeclaration(importClause, declaration => {
            return !!getSymbolOfDeclaration(declaration).isReferenced;
        });
    }
    function importClauseContainsConstEnumUsedAsValue(importClause) {
        return forEachImportClauseDeclaration(importClause, declaration => {
            return !!getSymbolLinks(getSymbolOfDeclaration(declaration)).constEnumReferenced;
        });
    }
    function canConvertImportDeclarationToTypeOnly(statement) {
        return isImportDeclaration(statement) && statement.importClause && !statement.importClause.isTypeOnly && importClauseContainsReferencedImport(statement.importClause) && !isReferencedAliasDeclaration(statement.importClause, true) && !importClauseContainsConstEnumUsedAsValue(statement.importClause);
    }
    function canConvertImportEqualsDeclarationToTypeOnly(statement) {
        return isImportEqualsDeclaration(statement) && isExternalModuleReference(statement.moduleReference) && !statement.isTypeOnly && getSymbolOfDeclaration(statement).isReferenced && !isReferencedAliasDeclaration(statement, false) && !getSymbolLinks(getSymbolOfDeclaration(statement)).constEnumReferenced;
    }
    function checkImportsForTypeOnlyConversion(sourceFile) {
        for (const statement of sourceFile.statements) {
            if (canConvertImportDeclarationToTypeOnly(statement) || canConvertImportEqualsDeclarationToTypeOnly(statement)) {
                error(statement, Diagnostics.This_import_is_never_used_as_a_value_and_must_use_import_type_because_importsNotUsedAsValues_is_set_to_error);
            }
        }
    }
    function checkExportSpecifier(node) {
        checkAliasSymbol(node);
        if (getEmitDeclarations(compilerOptions)) {
            collectLinkedAliases(node.propertyName || node.name, true);
        }
        if (!node.parent.parent.moduleSpecifier) {
            const exportedName = node.propertyName || node.name;
            const symbol = resolveName(exportedName, exportedName.escapedText, 111551 | 788968 | 1920 | 2097152, void 0, void 0, true);
            if (symbol && (symbol === undefinedSymbol || symbol === globalThisSymbol || symbol.declarations && isGlobalSourceFile(getDeclarationContainer(symbol.declarations[0])))) {
                error(exportedName, Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, idText(exportedName));
            } else {
                if (!node.isTypeOnly && !node.parent.parent.isTypeOnly) {
                    markExportAsReferenced(node);
                }
                const target = symbol && (symbol.flags & 2097152 ? resolveAlias(symbol) : symbol);
                if (!target || getAllSymbolFlags(target) & 111551) {
                    checkExpressionCached(node.propertyName || node.name);
                }
            }
        } else {
            if (getESModuleInterop(compilerOptions) && moduleKind !== 4 && (moduleKind < 5 || getSourceFileOfNode(node).impliedNodeFormat === 1) && idText(node.propertyName || node.name) === "default") {
                checkExternalEmitHelpers(node, 131072);
            }
        }
    }
    function checkExportAssignment(node) {
        const illegalContextMessage = node.isExportEquals ? Diagnostics.An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration : Diagnostics.A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration;
        if (checkGrammarModuleElementContext(node, illegalContextMessage)) {
            return;
        }
        const container = node.parent.kind === 308 ? node.parent : node.parent.parent;
        if (container.kind === 264 && !isAmbientModule(container)) {
            if (node.isExportEquals) {
                error(node, Diagnostics.An_export_assignment_cannot_be_used_in_a_namespace);
            } else {
                error(node, Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module);
            }
            return;
        }
        if (!checkGrammarModifiers(node) && hasEffectiveModifiers(node)) {
            grammarErrorOnFirstToken(node, Diagnostics.An_export_assignment_cannot_have_modifiers);
        }
        const typeAnnotationNode = getEffectiveTypeAnnotationNode(node);
        if (typeAnnotationNode) {
            checkTypeAssignableTo(checkExpressionCached(node.expression), getTypeFromTypeNode(typeAnnotationNode), node.expression);
        }
        const isIllegalExportDefaultInCJS = !node.isExportEquals && !(node.flags & 16777216) && compilerOptions.verbatimModuleSyntax && (moduleKind === 1 || getSourceFileOfNode(node).impliedNodeFormat === 1);
        if (node.expression.kind === 79) {
            const id = node.expression;
            const sym = getExportSymbolOfValueSymbolIfExported(resolveEntityName(id, 67108863, true, true, node));
            if (sym) {
                markAliasReferenced(sym, id);
                if (getAllSymbolFlags(sym) & 111551) {
                    checkExpressionCached(id);
                    if (!isIllegalExportDefaultInCJS && compilerOptions.verbatimModuleSyntax && getTypeOnlyAliasDeclaration(sym, 111551)) {
                        error(id, node.isExportEquals ? Diagnostics.An_export_declaration_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration : Diagnostics.An_export_default_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration, idText(id));
                    }
                } else if (!isIllegalExportDefaultInCJS && compilerOptions.verbatimModuleSyntax) {
                    error(id, node.isExportEquals ? Diagnostics.An_export_declaration_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type : Diagnostics.An_export_default_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type, idText(id));
                }
            } else {
                checkExpressionCached(id);
            }
            if (getEmitDeclarations(compilerOptions)) {
                collectLinkedAliases(id, true);
            }
        } else {
            checkExpressionCached(node.expression);
        }
        if (isIllegalExportDefaultInCJS) {
            error(node, Diagnostics.ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled);
        }
        checkExternalModuleExports(container);
        if (node.flags & 16777216 && !isEntityNameExpression(node.expression)) {
            grammarErrorOnNode(node.expression, Diagnostics.The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context);
        }
        if (node.isExportEquals) {
            if (moduleKind >= 5 && (node.flags & 16777216 && getSourceFileOfNode(node).impliedNodeFormat === 99 || !(node.flags & 16777216) && getSourceFileOfNode(node).impliedNodeFormat !== 1)) {
                grammarErrorOnNode(node, Diagnostics.Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead);
            } else if (moduleKind === 4 && !(node.flags & 16777216)) {
                grammarErrorOnNode(node, Diagnostics.Export_assignment_is_not_supported_when_module_flag_is_system);
            }
        }
    }
    function hasExportedMembers(moduleSymbol) {
        return forEachEntry(moduleSymbol.exports, (_, id) => id !== "export=");
    }
    function checkExternalModuleExports(node) {
        const moduleSymbol = getSymbolOfDeclaration(node);
        const links = getSymbolLinks(moduleSymbol);
        if (!links.exportsChecked) {
            const exportEqualsSymbol = moduleSymbol.exports.get("export=");
            if (exportEqualsSymbol && hasExportedMembers(moduleSymbol)) {
                const declaration = getDeclarationOfAliasSymbol(exportEqualsSymbol) || exportEqualsSymbol.valueDeclaration;
                if (declaration && !isTopLevelInExternalModuleAugmentation(declaration) && !isInJSFile(declaration)) {
                    error(declaration, Diagnostics.An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements);
                }
            }
            const exports = getExportsOfModule(moduleSymbol);
            if (exports) {
                exports.forEach(({
                    declarations,
                    flags
                }, id) => {
                    if (id === "__export") {
                        return;
                    }
                    if (flags & (1920 | 384)) {
                        return;
                    }
                    const exportedDeclarationsCount = countWhere(declarations, and(isNotOverloadAndNotAccessor, not(isInterfaceDeclaration)));
                    if (flags & 524288 && exportedDeclarationsCount <= 2) {
                        return;
                    }
                    if (exportedDeclarationsCount > 1) {
                        if (!isDuplicatedCommonJSExport(declarations)) {
                            for (const declaration of declarations) {
                                if (isNotOverload(declaration)) {
                                    diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Cannot_redeclare_exported_variable_0, unescapeLeadingUnderscores(id)));
                                }
                            }
                        }
                    }
                });
            }
            links.exportsChecked = true;
        }
    }
    function isDuplicatedCommonJSExport(declarations) {
        return declarations && declarations.length > 1 && declarations.every(d => isInJSFile(d) && isAccessExpression(d) && (isExportsIdentifier(d.expression) || isModuleExportsAccessExpression(d.expression)));
    }
    function checkSourceElement(node) {
        if (node) {
            const saveCurrentNode = currentNode;
            currentNode = node;
            instantiationCount = 0;
            checkSourceElementWorker(node);
            currentNode = saveCurrentNode;
        }
    }
    function checkSourceElementWorker(node) {
        if (canHaveJSDoc(node)) {
            forEach(node.jsDoc, ({
                comment,
                tags
            }) => {
                checkJSDocCommentWorker(comment);
                forEach(tags, tag => {
                    checkJSDocCommentWorker(tag.comment);
                    if (isInJSFile(node)) {
                        checkSourceElement(tag);
                    }
                });
            });
        }
        const kind = node.kind;
        if (cancellationToken) {
            switch (kind) {
                case 264:
                case 260:
                case 261:
                case 259:
                    cancellationToken.throwIfCancellationRequested();
            }
        }
        if (kind >= 240 && kind <= 256 && canHaveFlowNode(node) && node.flowNode && !isReachableFlowNode(node.flowNode)) {
            errorOrSuggestion(compilerOptions.allowUnreachableCode === false, node, Diagnostics.Unreachable_code_detected);
        }
        switch (kind) {
            case 165:
                return checkTypeParameter(node);
            case 166:
                return checkParameter(node);
            case 169:
                return checkPropertyDeclaration(node);
            case 168:
                return checkPropertySignature(node);
            case 182:
            case 181:
            case 176:
            case 177:
            case 178:
                return checkSignatureDeclaration(node);
            case 171:
            case 170:
                return checkMethodDeclaration(node);
            case 172:
                return checkClassStaticBlockDeclaration(node);
            case 173:
                return checkConstructorDeclaration(node);
            case 174:
            case 175:
                return checkAccessorDeclaration(node);
            case 180:
                return checkTypeReferenceNode(node);
            case 179:
                return checkTypePredicate(node);
            case 183:
                return checkTypeQuery(node);
            case 184:
                return checkTypeLiteral(node);
            case 185:
                return checkArrayType(node);
            case 186:
                return checkTupleType(node);
            case 189:
            case 190:
                return checkUnionOrIntersectionType(node);
            case 193:
            case 187:
            case 188:
                return checkSourceElement(node.type);
            case 194:
                return checkThisType(node);
            case 195:
                return checkTypeOperator(node);
            case 191:
                return checkConditionalType(node);
            case 192:
                return checkInferType(node);
            case 200:
                return checkTemplateLiteralType(node);
            case 202:
                return checkImportType(node);
            case 199:
                return checkNamedTupleMember(node);
            case 331:
                return checkJSDocAugmentsTag(node);
            case 332:
                return checkJSDocImplementsTag(node);
            case 349:
            case 341:
            case 343:
                return checkJSDocTypeAliasTag(node);
            case 348:
                return checkJSDocTemplateTag(node);
            case 347:
                return checkJSDocTypeTag(node);
            case 327:
            case 328:
            case 329:
                return checkJSDocLinkLikeTag(node);
            case 344:
                return checkJSDocParameterTag(node);
            case 351:
                return checkJSDocPropertyTag(node);
            case 320:
                checkJSDocFunctionType(node);
            case 318:
            case 317:
            case 315:
            case 316:
            case 325:
                checkJSDocTypeIsInJsFile(node);
                forEachChild(node, checkSourceElement);
                return;
            case 321:
                checkJSDocVariadicType(node);
                return;
            case 312:
                return checkSourceElement(node.type);
            case 336:
            case 338:
            case 337:
                return checkJSDocAccessibilityModifiers(node);
            case 353:
                return checkJSDocSatisfiesTag(node);
            case 196:
                return checkIndexedAccessType(node);
            case 197:
                return checkMappedType(node);
            case 259:
                return checkFunctionDeclaration(node);
            case 238:
            case 265:
                return checkBlock(node);
            case 240:
                return checkVariableStatement(node);
            case 241:
                return checkExpressionStatement(node);
            case 242:
                return checkIfStatement(node);
            case 243:
                return checkDoStatement(node);
            case 244:
                return checkWhileStatement(node);
            case 245:
                return checkForStatement(node);
            case 246:
                return checkForInStatement(node);
            case 247:
                return checkForOfStatement(node);
            case 248:
            case 249:
                return checkBreakOrContinueStatement(node);
            case 250:
                return checkReturnStatement(node);
            case 251:
                return checkWithStatement(node);
            case 252:
                return checkSwitchStatement(node);
            case 253:
                return checkLabeledStatement(node);
            case 254:
                return checkThrowStatement(node);
            case 255:
                return checkTryStatement(node);
            case 257:
                return checkVariableDeclaration(node);
            case 205:
                return checkBindingElement(node);
            case 260:
                return checkClassDeclaration(node);
            case 261:
                return checkInterfaceDeclaration(node);
            case 262:
                return checkTypeAliasDeclaration(node);
            case 263:
                return checkEnumDeclaration(node);
            case 264:
                return checkModuleDeclaration(node);
            case 269:
                return checkImportDeclaration(node);
            case 268:
                return checkImportEqualsDeclaration(node);
            case 275:
                return checkExportDeclaration(node);
            case 274:
                return checkExportAssignment(node);
            case 239:
            case 256:
                checkGrammarStatementInAmbientContext(node);
                return;
            case 279:
                return checkMissingDeclaration(node);
        }
    }
    function checkJSDocCommentWorker(node) {
        if (isArray(node)) {
            forEach(node, tag => {
                if (isJSDocLinkLike(tag)) {
                    checkSourceElement(tag);
                }
            });
        }
    }
    function checkJSDocTypeIsInJsFile(node) {
        if (!isInJSFile(node)) {
            if (isJSDocNonNullableType(node) || isJSDocNullableType(node)) {
                const token = tokenToString(isJSDocNonNullableType(node) ? 53 : 57);
                const diagnostic = node.postfix ? Diagnostics._0_at_the_end_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1 : Diagnostics._0_at_the_start_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1;
                const typeNode = node.type;
                const type = getTypeFromTypeNode(typeNode);
                grammarErrorOnNode(node, diagnostic, token, typeToString(isJSDocNullableType(node) && !(type === neverType || type === voidType) ? getUnionType(append([type, undefinedType], node.postfix ? void 0 : nullType)) : type));
            } else {
                grammarErrorOnNode(node, Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments);
            }
        }
    }
    function checkJSDocVariadicType(node) {
        checkJSDocTypeIsInJsFile(node);
        checkSourceElement(node.type);
        const {
            parent: parent2
        } = node;
        if (isParameter(parent2) && isJSDocFunctionType(parent2.parent)) {
            if (last(parent2.parent.parameters) !== parent2) {
                error(node, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);
            }
            return;
        }
        if (!isJSDocTypeExpression(parent2)) {
            error(node, Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature);
        }
        const paramTag = node.parent.parent;
        if (!isJSDocParameterTag(paramTag)) {
            error(node, Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature);
            return;
        }
        const param = getParameterSymbolFromJSDoc(paramTag);
        if (!param) {
            return;
        }
        const host2 = getHostSignatureFromJSDoc(paramTag);
        if (!host2 || last(host2.parameters).symbol !== param) {
            error(node, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);
        }
    }
    function getTypeFromJSDocVariadicType(node) {
        const type = getTypeFromTypeNode(node.type);
        const {
            parent: parent2
        } = node;
        const paramTag = node.parent.parent;
        if (isJSDocTypeExpression(node.parent) && isJSDocParameterTag(paramTag)) {
            const host2 = getHostSignatureFromJSDoc(paramTag);
            const isCallbackTag = isJSDocCallbackTag(paramTag.parent.parent);
            if (host2 || isCallbackTag) {
                const lastParamDeclaration = isCallbackTag ? lastOrUndefined(paramTag.parent.parent.typeExpression.parameters) : lastOrUndefined(host2.parameters);
                const symbol = getParameterSymbolFromJSDoc(paramTag);
                if (!lastParamDeclaration || symbol && lastParamDeclaration.symbol === symbol && isRestParameter(lastParamDeclaration)) {
                    return createArrayType(type);
                }
            }
        }
        if (isParameter(parent2) && isJSDocFunctionType(parent2.parent)) {
            return createArrayType(type);
        }
        return addOptionality(type);
    }
    function checkNodeDeferred(node) {
        const enclosingFile = getSourceFileOfNode(node);
        const links = getNodeLinks(enclosingFile);
        if (!(links.flags & 1)) {
            links.deferredNodes || (links.deferredNodes = /* @__PURE__ */new Set());
            links.deferredNodes.add(node);
        } else {
            Debug.assert(!links.deferredNodes, "A type-checked file should have no deferred nodes.");
        }
    }
    function checkDeferredNodes(context) {
        const links = getNodeLinks(context);
        if (links.deferredNodes) {
            links.deferredNodes.forEach(checkDeferredNode);
        }
        links.deferredNodes = void 0;
    }
    function checkDeferredNode(node) {
        var _a2, _b;
        (_a2 = tracing) == null ? void 0 : _a2.push(tracing.Phase.Check, "checkDeferredNode", {
            kind: node.kind,
            pos: node.pos,
            end: node.end,
            path: node.tracingPath
        });
        const saveCurrentNode = currentNode;
        currentNode = node;
        instantiationCount = 0;
        switch (node.kind) {
            case 210:
            case 211:
            case 212:
            case 167:
            case 283:
                resolveUntypedCall(node);
                break;
            case 215:
            case 216:
            case 171:
            case 170:
                checkFunctionExpressionOrObjectLiteralMethodDeferred(node);
                break;
            case 174:
            case 175:
                checkAccessorDeclaration(node);
                break;
            case 228:
                checkClassExpressionDeferred(node);
                break;
            case 165:
                checkTypeParameterDeferred(node);
                break;
            case 282:
                checkJsxSelfClosingElementDeferred(node);
                break;
            case 281:
                checkJsxElementDeferred(node);
                break;
        }
        currentNode = saveCurrentNode;
        (_b = tracing) == null ? void 0 : _b.pop();
    }
    function checkSourceFile(node) {
        var _a2, _b;
        (_a2 = tracing) == null ? void 0 : _a2.push(tracing.Phase.Check, "checkSourceFile", {
            path: node.path
        }, true);
        mark("beforeCheck");
        checkSourceFileWorker(node);
        mark("afterCheck");
        measure("Check", "beforeCheck", "afterCheck");
        (_b = tracing) == null ? void 0 : _b.pop();
    }
    function unusedIsError(kind, isAmbient) {
        if (isAmbient) {
            return false;
        }
        switch (kind) {
            case 0:
                return !!compilerOptions.noUnusedLocals;
            case 1:
                return !!compilerOptions.noUnusedParameters;
            default:
                return Debug.assertNever(kind);
        }
    }
    function getPotentiallyUnusedIdentifiers(sourceFile) {
        return allPotentiallyUnusedIdentifiers.get(sourceFile.path) || emptyArray;
    }
    function checkSourceFileWorker(node) {
        const links = getNodeLinks(node);
        if (!(links.flags & 1)) {
            if (skipTypeChecking(node, compilerOptions, host)) {
                return;
            }
            checkGrammarSourceFile(node);
            clear(potentialThisCollisions);
            clear(potentialNewTargetCollisions);
            clear(potentialWeakMapSetCollisions);
            clear(potentialReflectCollisions);
            clear(potentialUnusedRenamedBindingElementsInTypes);
            forEach(node.statements, checkSourceElement);
            checkSourceElement(node.endOfFileToken);
            checkDeferredNodes(node);
            if (isExternalOrCommonJsModule(node)) {
                registerForUnusedIdentifiersCheck(node);
            }
            addLazyDiagnostic(() => {
                if (!node.isDeclarationFile && (compilerOptions.noUnusedLocals || compilerOptions.noUnusedParameters)) {
                    checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(node), (containingNode, kind, diag2) => {
                        if (!containsParseError(containingNode) && unusedIsError(kind, !!(containingNode.flags & 16777216))) {
                            diagnostics.add(diag2);
                        }
                    });
                }
                if (!node.isDeclarationFile) {
                    checkPotentialUncheckedRenamedBindingElementsInTypes();
                }
            });
            if (compilerOptions.importsNotUsedAsValues === 2 && !node.isDeclarationFile && isExternalModule(node)) {
                checkImportsForTypeOnlyConversion(node);
            }
            if (isExternalOrCommonJsModule(node)) {
                checkExternalModuleExports(node);
            }
            if (potentialThisCollisions.length) {
                forEach(potentialThisCollisions, checkIfThisIsCapturedInEnclosingScope);
                clear(potentialThisCollisions);
            }
            if (potentialNewTargetCollisions.length) {
                forEach(potentialNewTargetCollisions, checkIfNewTargetIsCapturedInEnclosingScope);
                clear(potentialNewTargetCollisions);
            }
            if (potentialWeakMapSetCollisions.length) {
                forEach(potentialWeakMapSetCollisions, checkWeakMapSetCollision);
                clear(potentialWeakMapSetCollisions);
            }
            if (potentialReflectCollisions.length) {
                forEach(potentialReflectCollisions, checkReflectCollision);
                clear(potentialReflectCollisions);
            }
            links.flags |= 1;
        }
    }
    function getDiagnostics2(sourceFile, ct) {
        try {
            cancellationToken = ct;
            return getDiagnosticsWorker(sourceFile);
        } finally {
            cancellationToken = void 0;
        }
    }
    function ensurePendingDiagnosticWorkComplete() {
        for (const cb of deferredDiagnosticsCallbacks) {
            cb();
        }
        deferredDiagnosticsCallbacks = [];
    }
    function checkSourceFileWithEagerDiagnostics(sourceFile) {
        ensurePendingDiagnosticWorkComplete();
        const oldAddLazyDiagnostics = addLazyDiagnostic;
        addLazyDiagnostic = cb => cb();
        checkSourceFile(sourceFile);
        addLazyDiagnostic = oldAddLazyDiagnostics;
    }
    function getDiagnosticsWorker(sourceFile) {
        if (sourceFile) {
            ensurePendingDiagnosticWorkComplete();
            const previousGlobalDiagnostics = diagnostics.getGlobalDiagnostics();
            const previousGlobalDiagnosticsSize = previousGlobalDiagnostics.length;
            checkSourceFileWithEagerDiagnostics(sourceFile);
            const semanticDiagnostics = diagnostics.getDiagnostics(sourceFile.fileName);
            const currentGlobalDiagnostics = diagnostics.getGlobalDiagnostics();
            if (currentGlobalDiagnostics !== previousGlobalDiagnostics) {
                const deferredGlobalDiagnostics = relativeComplement(previousGlobalDiagnostics, currentGlobalDiagnostics, compareDiagnostics);
                return concatenate(deferredGlobalDiagnostics, semanticDiagnostics);
            } else if (previousGlobalDiagnosticsSize === 0 && currentGlobalDiagnostics.length > 0) {
                return concatenate(currentGlobalDiagnostics, semanticDiagnostics);
            }
            return semanticDiagnostics;
        }
        forEach(host.getSourceFiles(), checkSourceFileWithEagerDiagnostics);
        return diagnostics.getDiagnostics();
    }
    function getGlobalDiagnostics() {
        ensurePendingDiagnosticWorkComplete();
        return diagnostics.getGlobalDiagnostics();
    }
    function getSymbolsInScope(location, meaning) {
        if (location.flags & 33554432) {
            return [];
        }
        const symbols = createSymbolTable();
        let isStaticSymbol = false;
        populateSymbols();
        symbols.delete("this");
        return symbolsToArray(symbols);
        function populateSymbols() {
            while (location) {
                if (canHaveLocals(location) && location.locals && !isGlobalSourceFile(location)) {
                    copySymbols(location.locals, meaning);
                }
                switch (location.kind) {
                    case 308:
                        if (!isExternalModule(location)) break;
                    case 264:
                        copyLocallyVisibleExportSymbols(getSymbolOfDeclaration(location).exports, meaning & 2623475);
                        break;
                    case 263:
                        copySymbols(getSymbolOfDeclaration(location).exports, meaning & 8);
                        break;
                    case 228:
                        const className = location.name;
                        if (className) {
                            copySymbol(location.symbol, meaning);
                        }
                    case 260:
                    case 261:
                        if (!isStaticSymbol) {
                            copySymbols(getMembersOfSymbol(getSymbolOfDeclaration(location)), meaning & 788968);
                        }
                        break;
                    case 215:
                        const funcName = location.name;
                        if (funcName) {
                            copySymbol(location.symbol, meaning);
                        }
                        break;
                }
                if (introducesArgumentsExoticObject(location)) {
                    copySymbol(argumentsSymbol, meaning);
                }
                isStaticSymbol = isStatic(location);
                location = location.parent;
            }
            copySymbols(globals, meaning);
        }
        function copySymbol(symbol, meaning2) {
            if (getCombinedLocalAndExportSymbolFlags(symbol) & meaning2) {
                const id = symbol.escapedName;
                if (!symbols.has(id)) {
                    symbols.set(id, symbol);
                }
            }
        }
        function copySymbols(source, meaning2) {
            if (meaning2) {
                source.forEach(symbol => {
                    copySymbol(symbol, meaning2);
                });
            }
        }
        function copyLocallyVisibleExportSymbols(source, meaning2) {
            if (meaning2) {
                source.forEach(symbol => {
                    if (!getDeclarationOfKind(symbol, 278) && !getDeclarationOfKind(symbol, 277)) {
                        copySymbol(symbol, meaning2);
                    }
                });
            }
        }
    }
    function isTypeDeclarationName(name) {
        return name.kind === 79 && isTypeDeclaration(name.parent) && getNameOfDeclaration(name.parent) === name;
    }
    function isTypeReferenceIdentifier(node) {
        while (node.parent.kind === 163) {
            node = node.parent;
        }
        return node.parent.kind === 180;
    }
    function isInNameOfExpressionWithTypeArguments(node) {
        while (node.parent.kind === 208) {
            node = node.parent;
        }
        return node.parent.kind === 230;
    }
    function forEachEnclosingClass(node, callback) {
        let result;
        let containingClass = getContainingClass(node);
        while (containingClass) {
            if (result = callback(containingClass)) break;
            containingClass = getContainingClass(containingClass);
        }
        return result;
    }
    function isNodeUsedDuringClassInitialization(node) {
        return !!findAncestor(node, element => {
            if (isConstructorDeclaration(element) && nodeIsPresent(element.body) || isPropertyDeclaration(element)) {
                return true;
            } else if (isClassLike(element) || isFunctionLikeDeclaration(element)) {
                return "quit";
            }
            return false;
        });
    }
    function isNodeWithinClass(node, classDeclaration) {
        return !!forEachEnclosingClass(node, n => n === classDeclaration);
    }
    function getLeftSideOfImportEqualsOrExportAssignment(nodeOnRightSide) {
        while (nodeOnRightSide.parent.kind === 163) {
            nodeOnRightSide = nodeOnRightSide.parent;
        }
        if (nodeOnRightSide.parent.kind === 268) {
            return nodeOnRightSide.parent.moduleReference === nodeOnRightSide ? nodeOnRightSide.parent : void 0;
        }
        if (nodeOnRightSide.parent.kind === 274) {
            return nodeOnRightSide.parent.expression === nodeOnRightSide ? nodeOnRightSide.parent : void 0;
        }
        return void 0;
    }
    function isInRightSideOfImportOrExportAssignment(node) {
        return getLeftSideOfImportEqualsOrExportAssignment(node) !== void 0;
    }
    function getSpecialPropertyAssignmentSymbolFromEntityName(entityName) {
        const specialPropertyAssignmentKind = getAssignmentDeclarationKind(entityName.parent.parent);
        switch (specialPropertyAssignmentKind) {
            case 1:
            case 3:
                return getSymbolOfNode(entityName.parent);
            case 4:
            case 2:
            case 5:
                return getSymbolOfDeclaration(entityName.parent.parent);
        }
    }
    function isImportTypeQualifierPart(node) {
        let parent2 = node.parent;
        while (isQualifiedName(parent2)) {
            node = parent2;
            parent2 = parent2.parent;
        }
        if (parent2 && parent2.kind === 202 && parent2.qualifier === node) {
            return parent2;
        }
        return void 0;
    }
    function getSymbolOfNameOrPropertyAccessExpression(name) {
        if (isDeclarationName(name)) {
            return getSymbolOfNode(name.parent);
        }
        if (isInJSFile(name) && name.parent.kind === 208 && name.parent === name.parent.parent.left) {
            if (!isPrivateIdentifier(name) && !isJSDocMemberName(name)) {
                const specialPropertyAssignmentSymbol = getSpecialPropertyAssignmentSymbolFromEntityName(name);
                if (specialPropertyAssignmentSymbol) {
                    return specialPropertyAssignmentSymbol;
                }
            }
        }
        if (name.parent.kind === 274 && isEntityNameExpression(name)) {
            const success = resolveEntityName(name, 111551 | 788968 | 1920 | 2097152, true);
            if (success && success !== unknownSymbol) {
                return success;
            }
        } else if (isEntityName(name) && isInRightSideOfImportOrExportAssignment(name)) {
            const importEqualsDeclaration = getAncestor(name, 268);
            Debug.assert(importEqualsDeclaration !== void 0);
            return getSymbolOfPartOfRightHandSideOfImportEquals(name, true);
        }
        if (isEntityName(name)) {
            const possibleImportNode = isImportTypeQualifierPart(name);
            if (possibleImportNode) {
                getTypeFromTypeNode(possibleImportNode);
                const sym = getNodeLinks(name).resolvedSymbol;
                return sym === unknownSymbol ? void 0 : sym;
            }
        }
        while (isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName(name)) {
            name = name.parent;
        }
        if (isInNameOfExpressionWithTypeArguments(name)) {
            let meaning = 0;
            if (name.parent.kind === 230) {
                meaning = isPartOfTypeNode(name) ? 788968 : 111551;
                if (isExpressionWithTypeArgumentsInClassExtendsClause(name.parent)) {
                    meaning |= 111551;
                }
            } else {
                meaning = 1920;
            }
            meaning |= 2097152;
            const entityNameSymbol = isEntityNameExpression(name) ? resolveEntityName(name, meaning) : void 0;
            if (entityNameSymbol) {
                return entityNameSymbol;
            }
        }
        if (name.parent.kind === 344) {
            return getParameterSymbolFromJSDoc(name.parent);
        }
        if (name.parent.kind === 165 && name.parent.parent.kind === 348) {
            Debug.assert(!isInJSFile(name));
            const typeParameter = getTypeParameterFromJsDoc(name.parent);
            return typeParameter && typeParameter.symbol;
        }
        if (isExpressionNode(name)) {
            if (nodeIsMissing(name)) {
                return void 0;
            }
            const isJSDoc2 = findAncestor(name, or(isJSDocLinkLike, isJSDocNameReference, isJSDocMemberName));
            const meaning = isJSDoc2 ? 788968 | 1920 | 111551 : 111551;
            if (name.kind === 79) {
                if (isJSXTagName(name) && isJsxIntrinsicIdentifier(name)) {
                    const symbol = getIntrinsicTagSymbol(name.parent);
                    return symbol === unknownSymbol ? void 0 : symbol;
                }
                const result = resolveEntityName(name, meaning, false, true, getHostSignatureFromJSDoc(name));
                if (!result && isJSDoc2) {
                    const container = findAncestor(name, or(isClassLike, isInterfaceDeclaration));
                    if (container) {
                        return resolveJSDocMemberName(name, false, getSymbolOfDeclaration(container));
                    }
                }
                if (result && isJSDoc2) {
                    const container = getJSDocHost(name);
                    if (container && isEnumMember(container) && container === result.valueDeclaration) {
                        return resolveEntityName(name, meaning, true, true, getSourceFileOfNode(container)) || result;
                    }
                }
                return result;
            } else if (isPrivateIdentifier(name)) {
                return getSymbolForPrivateIdentifierExpression(name);
            } else if (name.kind === 208 || name.kind === 163) {
                const links = getNodeLinks(name);
                if (links.resolvedSymbol) {
                    return links.resolvedSymbol;
                }
                if (name.kind === 208) {
                    checkPropertyAccessExpression(name, 0);
                    if (!links.resolvedSymbol) {
                        const expressionType = checkExpressionCached(name.expression);
                        const infos = getApplicableIndexInfos(expressionType, getLiteralTypeFromPropertyName(name.name));
                        if (infos.length && expressionType.members) {
                            const resolved = resolveStructuredTypeMembers(expressionType);
                            const symbol = resolved.members.get("__index");
                            if (infos === getIndexInfosOfType(expressionType)) {
                                links.resolvedSymbol = symbol;
                            } else if (symbol) {
                                const symbolLinks2 = getSymbolLinks(symbol);
                                const declarationList = mapDefined(infos, i => i.declaration);
                                const nodeListId = map(declarationList, getNodeId).join(",");
                                if (!symbolLinks2.filteredIndexSymbolCache) {
                                    symbolLinks2.filteredIndexSymbolCache = /* @__PURE__ */new Map();
                                }
                                if (symbolLinks2.filteredIndexSymbolCache.has(nodeListId)) {
                                    links.resolvedSymbol = symbolLinks2.filteredIndexSymbolCache.get(nodeListId);
                                } else {
                                    const copy = createSymbol(131072, "__index");
                                    copy.declarations = mapDefined(infos, i => i.declaration);
                                    copy.parent = expressionType.aliasSymbol ? expressionType.aliasSymbol : expressionType.symbol ? expressionType.symbol : getSymbolAtLocation(copy.declarations[0].parent);
                                    symbolLinks2.filteredIndexSymbolCache.set(nodeListId, copy);
                                    links.resolvedSymbol = symbolLinks2.filteredIndexSymbolCache.get(nodeListId);
                                }
                            }
                        }
                    }
                } else {
                    checkQualifiedName(name, 0);
                }
                if (!links.resolvedSymbol && isJSDoc2 && isQualifiedName(name)) {
                    return resolveJSDocMemberName(name);
                }
                return links.resolvedSymbol;
            } else if (isJSDocMemberName(name)) {
                return resolveJSDocMemberName(name);
            }
        } else if (isTypeReferenceIdentifier(name)) {
            const meaning = name.parent.kind === 180 ? 788968 : 1920;
            const symbol = resolveEntityName(name, meaning, false, true);
            return symbol && symbol !== unknownSymbol ? symbol : getUnresolvedSymbolForEntityName(name);
        }
        if (name.parent.kind === 179) {
            return resolveEntityName(name, 1);
        }
        return void 0;
    }
    function resolveJSDocMemberName(name, ignoreErrors, container) {
        if (isEntityName(name)) {
            const meaning = 788968 | 1920 | 111551;
            let symbol = resolveEntityName(name, meaning, ignoreErrors, true, getHostSignatureFromJSDoc(name));
            if (!symbol && isIdentifier(name) && container) {
                symbol = getMergedSymbol(getSymbol2(getExportsOfSymbol(container), name.escapedText, meaning));
            }
            if (symbol) {
                return symbol;
            }
        }
        const left = isIdentifier(name) ? container : resolveJSDocMemberName(name.left, ignoreErrors, container);
        const right = isIdentifier(name) ? name.escapedText : name.right.escapedText;
        if (left) {
            const proto = left.flags & 111551 && getPropertyOfType(getTypeOfSymbol(left), "prototype");
            const t = proto ? getTypeOfSymbol(proto) : getDeclaredTypeOfSymbol(left);
            return getPropertyOfType(t, right);
        }
    }
    function getSymbolAtLocation(node, ignoreErrors) {
        if (isSourceFile(node)) {
            return isExternalModule(node) ? getMergedSymbol(node.symbol) : void 0;
        }
        const {
            parent: parent2
        } = node;
        const grandParent = parent2.parent;
        if (node.flags & 33554432) {
            return void 0;
        }
        if (isDeclarationNameOrImportPropertyName(node)) {
            const parentSymbol = getSymbolOfDeclaration(parent2);
            return isImportOrExportSpecifier(node.parent) && node.parent.propertyName === node ? getImmediateAliasedSymbol(parentSymbol) : parentSymbol;
        } else if (isLiteralComputedPropertyDeclarationName(node)) {
            return getSymbolOfDeclaration(parent2.parent);
        }
        if (node.kind === 79) {
            if (isInRightSideOfImportOrExportAssignment(node)) {
                return getSymbolOfNameOrPropertyAccessExpression(node);
            } else if (parent2.kind === 205 && grandParent.kind === 203 && node === parent2.propertyName) {
                const typeOfPattern = getTypeOfNode(grandParent);
                const propertyDeclaration = getPropertyOfType(typeOfPattern, node.escapedText);
                if (propertyDeclaration) {
                    return propertyDeclaration;
                }
            } else if (isMetaProperty(parent2) && parent2.name === node) {
                if (parent2.keywordToken === 103 && idText(node) === "target") {
                    return checkNewTargetMetaProperty(parent2).symbol;
                }
                if (parent2.keywordToken === 100 && idText(node) === "meta") {
                    return getGlobalImportMetaExpressionType().members.get("meta");
                }
                return void 0;
            }
        }
        switch (node.kind) {
            case 79:
            case 80:
            case 208:
            case 163:
                if (!isThisInTypeQuery(node)) {
                    return getSymbolOfNameOrPropertyAccessExpression(node);
                }
            case 108:
                const container = getThisContainer(node, false, false);
                if (isFunctionLike(container)) {
                    const sig = getSignatureFromDeclaration(container);
                    if (sig.thisParameter) {
                        return sig.thisParameter;
                    }
                }
                if (isInExpressionContext(node)) {
                    return checkExpression(node).symbol;
                }
            case 194:
                return getTypeFromThisTypeNode(node).symbol;
            case 106:
                return checkExpression(node).symbol;
            case 135:
                const constructorDeclaration = node.parent;
                if (constructorDeclaration && constructorDeclaration.kind === 173) {
                    return constructorDeclaration.parent.symbol;
                }
                return void 0;
            case 10:
            case 14:
                if (isExternalModuleImportEqualsDeclaration(node.parent.parent) && getExternalModuleImportEqualsDeclarationExpression(node.parent.parent) === node || (node.parent.kind === 269 || node.parent.kind === 275) && node.parent.moduleSpecifier === node || isInJSFile(node) && getEmitModuleResolutionKind(compilerOptions) !== 100 && isRequireCall(node.parent, false) || isImportCall(node.parent) || isLiteralTypeNode(node.parent) && isLiteralImportTypeNode(node.parent.parent) && node.parent.parent.argument === node.parent) {
                    return resolveExternalModuleName(node, node, ignoreErrors);
                }
                if (isCallExpression(parent2) && isBindableObjectDefinePropertyCall(parent2) && parent2.arguments[1] === node) {
                    return getSymbolOfDeclaration(parent2);
                }
            case 8:
                const objectType = isElementAccessExpression(parent2) ? parent2.argumentExpression === node ? getTypeOfExpression(parent2.expression) : void 0 : isLiteralTypeNode(parent2) && isIndexedAccessTypeNode(grandParent) ? getTypeFromTypeNode(grandParent.objectType) : void 0;
                return objectType && getPropertyOfType(objectType, escapeLeadingUnderscores(node.text));
            case 88:
            case 98:
            case 38:
            case 84:
                return getSymbolOfNode(node.parent);
            case 202:
                return isLiteralImportTypeNode(node) ? getSymbolAtLocation(node.argument.literal, ignoreErrors) : void 0;
            case 93:
                return isExportAssignment(node.parent) ? Debug.checkDefined(node.parent.symbol) : void 0;
            case 100:
            case 103:
                return isMetaProperty(node.parent) ? checkMetaPropertyKeyword(node.parent).symbol : void 0;
            case 233:
                return checkExpression(node).symbol;
            default:
                return void 0;
        }
    }
    function getIndexInfosAtLocation(node) {
        if (isIdentifier(node) && isPropertyAccessExpression(node.parent) && node.parent.name === node) {
            const keyType = getLiteralTypeFromPropertyName(node);
            const objectType = getTypeOfExpression(node.parent.expression);
            const objectTypes = objectType.flags & 1048576 ? objectType.types : [objectType];
            return flatMap(objectTypes, t => filter(getIndexInfosOfType(t), info => isApplicableIndexType(keyType, info.keyType)));
        }
        return void 0;
    }
    function getShorthandAssignmentValueSymbol(location) {
        if (location && location.kind === 300) {
            return resolveEntityName(location.name, 111551 | 2097152);
        }
        return void 0;
    }
    function getExportSpecifierLocalTargetSymbol(node) {
        if (isExportSpecifier(node)) {
            return node.parent.parent.moduleSpecifier ? getExternalModuleMember(node.parent.parent, node) : resolveEntityName(node.propertyName || node.name, 111551 | 788968 | 1920 | 2097152);
        } else {
            return resolveEntityName(node, 111551 | 788968 | 1920 | 2097152);
        }
    }
    function getTypeOfNode(node) {
        if (isSourceFile(node) && !isExternalModule(node)) {
            return errorType;
        }
        if (node.flags & 33554432) {
            return errorType;
        }
        const classDecl = tryGetClassImplementingOrExtendingExpressionWithTypeArguments(node);
        const classType = classDecl && getDeclaredTypeOfClassOrInterface(getSymbolOfDeclaration(classDecl.class));
        if (isPartOfTypeNode(node)) {
            const typeFromTypeNode = getTypeFromTypeNode(node);
            return classType ? getTypeWithThisArgument(typeFromTypeNode, classType.thisType) : typeFromTypeNode;
        }
        if (isExpressionNode(node)) {
            return getRegularTypeOfExpression(node);
        }
        if (classType && !classDecl.isImplements) {
            const baseType = firstOrUndefined(getBaseTypes(classType));
            return baseType ? getTypeWithThisArgument(baseType, classType.thisType) : errorType;
        }
        if (isTypeDeclaration(node)) {
            const symbol = getSymbolOfDeclaration(node);
            return getDeclaredTypeOfSymbol(symbol);
        }
        if (isTypeDeclarationName(node)) {
            const symbol = getSymbolAtLocation(node);
            return symbol ? getDeclaredTypeOfSymbol(symbol) : errorType;
        }
        if (isDeclaration(node)) {
            const symbol = getSymbolOfDeclaration(node);
            return symbol ? getTypeOfSymbol(symbol) : errorType;
        }
        if (isDeclarationNameOrImportPropertyName(node)) {
            const symbol = getSymbolAtLocation(node);
            if (symbol) {
                return getTypeOfSymbol(symbol);
            }
            return errorType;
        }
        if (isBindingPattern(node)) {
            return getTypeForVariableLikeDeclaration(node.parent, true, 0) || errorType;
        }
        if (isInRightSideOfImportOrExportAssignment(node)) {
            const symbol = getSymbolAtLocation(node);
            if (symbol) {
                const declaredType = getDeclaredTypeOfSymbol(symbol);
                return !isErrorType(declaredType) ? declaredType : getTypeOfSymbol(symbol);
            }
        }
        if (isMetaProperty(node.parent) && node.parent.keywordToken === node.kind) {
            return checkMetaPropertyKeyword(node.parent);
        }
        return errorType;
    }
    function getTypeOfAssignmentPattern(expr) {
        Debug.assert(expr.kind === 207 || expr.kind === 206);
        if (expr.parent.kind === 247) {
            const iteratedType = checkRightHandSideOfForOf(expr.parent);
            return checkDestructuringAssignment(expr, iteratedType || errorType);
        }
        if (expr.parent.kind === 223) {
            const iteratedType = getTypeOfExpression(expr.parent.right);
            return checkDestructuringAssignment(expr, iteratedType || errorType);
        }
        if (expr.parent.kind === 299) {
            const node2 = cast(expr.parent.parent, isObjectLiteralExpression);
            const typeOfParentObjectLiteral = getTypeOfAssignmentPattern(node2) || errorType;
            const propertyIndex = indexOfNode(node2.properties, expr.parent);
            return checkObjectLiteralDestructuringPropertyAssignment(node2, typeOfParentObjectLiteral, propertyIndex);
        }
        const node = cast(expr.parent, isArrayLiteralExpression);
        const typeOfArrayLiteral = getTypeOfAssignmentPattern(node) || errorType;
        const elementType = checkIteratedTypeOrElementType(65, typeOfArrayLiteral, undefinedType, expr.parent) || errorType;
        return checkArrayLiteralDestructuringElementAssignment(node, typeOfArrayLiteral, node.elements.indexOf(expr), elementType);
    }
    function getPropertySymbolOfDestructuringAssignment(location) {
        const typeOfObjectLiteral = getTypeOfAssignmentPattern(cast(location.parent.parent, isAssignmentPattern));
        return typeOfObjectLiteral && getPropertyOfType(typeOfObjectLiteral, location.escapedText);
    }
    function getRegularTypeOfExpression(expr) {
        if (isRightSideOfQualifiedNameOrPropertyAccess(expr)) {
            expr = expr.parent;
        }
        return getRegularTypeOfLiteralType(getTypeOfExpression(expr));
    }
    function getParentTypeOfClassElement(node) {
        const classSymbol = getSymbolOfNode(node.parent);
        return isStatic(node) ? getTypeOfSymbol(classSymbol) : getDeclaredTypeOfSymbol(classSymbol);
    }
    function getClassElementPropertyKeyType(element) {
        const name = element.name;
        switch (name.kind) {
            case 79:
                return getStringLiteralType(idText(name));
            case 8:
            case 10:
                return getStringLiteralType(name.text);
            case 164:
                const nameType = checkComputedPropertyName(name);
                return isTypeAssignableToKind(nameType, 12288) ? nameType : stringType;
            default:
                return Debug.fail("Unsupported property name.");
        }
    }
    function getAugmentedPropertiesOfType(type) {
        type = getApparentType(type);
        const propsByName = createSymbolTable(getPropertiesOfType(type));
        const functionType = getSignaturesOfType(type, 0).length ? globalCallableFunctionType : getSignaturesOfType(type, 1).length ? globalNewableFunctionType : void 0;
        if (functionType) {
            forEach(getPropertiesOfType(functionType), p => {
                if (!propsByName.has(p.escapedName)) {
                    propsByName.set(p.escapedName, p);
                }
            });
        }
        return getNamedMembers(propsByName);
    }
    function typeHasCallOrConstructSignatures(type) {
        return getSignaturesOfType(type, 0).length !== 0 || getSignaturesOfType(type, 1).length !== 0;
    }
    function getRootSymbols(symbol) {
        const roots = getImmediateRootSymbols(symbol);
        return roots ? flatMap(roots, getRootSymbols) : [symbol];
    }
    function getImmediateRootSymbols(symbol) {
        if (getCheckFlags(symbol) & 6) {
            return mapDefined(getSymbolLinks(symbol).containingType.types, type => getPropertyOfType(type, symbol.escapedName));
        } else if (symbol.flags & 33554432) {
            const {
                links: {
                    leftSpread,
                    rightSpread,
                    syntheticOrigin
                }
            } = symbol;
            return leftSpread ? [leftSpread, rightSpread] : syntheticOrigin ? [syntheticOrigin] : singleElementArray(tryGetTarget(symbol));
        }
        return void 0;
    }
    function tryGetTarget(symbol) {
        let target;
        let next = symbol;
        while (next = getSymbolLinks(next).target) {
            target = next;
        }
        return target;
    }
    function isArgumentsLocalBinding(nodeIn) {
        if (isGeneratedIdentifier(nodeIn)) return false;
        const node = getParseTreeNode(nodeIn, isIdentifier);
        if (!node) return false;
        const parent2 = node.parent;
        if (!parent2) return false;
        const isPropertyName2 = (isPropertyAccessExpression(parent2) || isPropertyAssignment(parent2)) && parent2.name === node;
        return !isPropertyName2 && getReferencedValueSymbol(node) === argumentsSymbol;
    }
    function moduleExportsSomeValue(moduleReferenceExpression) {
        let moduleSymbol = resolveExternalModuleName(moduleReferenceExpression.parent, moduleReferenceExpression);
        if (!moduleSymbol || isShorthandAmbientModuleSymbol(moduleSymbol)) {
            return true;
        }
        const hasExportAssignment = hasExportAssignmentSymbol(moduleSymbol);
        moduleSymbol = resolveExternalModuleSymbol(moduleSymbol);
        const symbolLinks2 = getSymbolLinks(moduleSymbol);
        if (symbolLinks2.exportsSomeValue === void 0) {
            symbolLinks2.exportsSomeValue = hasExportAssignment ? !!(moduleSymbol.flags & 111551) : forEachEntry(getExportsOfModule(moduleSymbol), isValue);
        }
        return symbolLinks2.exportsSomeValue;
        function isValue(s) {
            s = resolveSymbol(s);
            return s && !!(getAllSymbolFlags(s) & 111551);
        }
    }
    function isNameOfModuleOrEnumDeclaration(node) {
        return isModuleOrEnumDeclaration(node.parent) && node === node.parent.name;
    }
    function getReferencedExportContainer(nodeIn, prefixLocals) {
        var _a2;
        const node = getParseTreeNode(nodeIn, isIdentifier);
        if (node) {
            let symbol = getReferencedValueSymbol(node, isNameOfModuleOrEnumDeclaration(node));
            if (symbol) {
                if (symbol.flags & 1048576) {
                    const exportSymbol = getMergedSymbol(symbol.exportSymbol);
                    if (!prefixLocals && exportSymbol.flags & 944 && !(exportSymbol.flags & 3)) {
                        return void 0;
                    }
                    symbol = exportSymbol;
                }
                const parentSymbol = getParentOfSymbol(symbol);
                if (parentSymbol) {
                    if (parentSymbol.flags & 512 && ((_a2 = parentSymbol.valueDeclaration) == null ? void 0 : _a2.kind) === 308) {
                        const symbolFile = parentSymbol.valueDeclaration;
                        const referenceFile = getSourceFileOfNode(node);
                        const symbolIsUmdExport = symbolFile !== referenceFile;
                        return symbolIsUmdExport ? void 0 : symbolFile;
                    }
                    return findAncestor(node.parent, n => isModuleOrEnumDeclaration(n) && getSymbolOfDeclaration(n) === parentSymbol);
                }
            }
        }
    }
    function getReferencedImportDeclaration(nodeIn) {
        const specifier = getIdentifierGeneratedImportReference(nodeIn);
        if (specifier) {
            return specifier;
        }
        const node = getParseTreeNode(nodeIn, isIdentifier);
        if (node) {
            const symbol = getReferencedValueOrAliasSymbol(node);
            if (isNonLocalAlias(symbol, 111551) && !getTypeOnlyAliasDeclaration(symbol, 111551)) {
                return getDeclarationOfAliasSymbol(symbol);
            }
        }
        return void 0;
    }
    function isSymbolOfDestructuredElementOfCatchBinding(symbol) {
        return symbol.valueDeclaration && isBindingElement(symbol.valueDeclaration) && walkUpBindingElementsAndPatterns(symbol.valueDeclaration).parent.kind === 295;
    }
    function isSymbolOfDeclarationWithCollidingName(symbol) {
        if (symbol.flags & 418 && symbol.valueDeclaration && !isSourceFile(symbol.valueDeclaration)) {
            const links = getSymbolLinks(symbol);
            if (links.isDeclarationWithCollidingName === void 0) {
                const container = getEnclosingBlockScopeContainer(symbol.valueDeclaration);
                if (isStatementWithLocals(container) || isSymbolOfDestructuredElementOfCatchBinding(symbol)) {
                    const nodeLinks2 = getNodeLinks(symbol.valueDeclaration);
                    if (resolveName(container.parent, symbol.escapedName, 111551, void 0, void 0, false)) {
                        links.isDeclarationWithCollidingName = true;
                    } else if (nodeLinks2.flags & 16384) {
                        const isDeclaredInLoop = nodeLinks2.flags & 32768;
                        const inLoopInitializer = isIterationStatement(container, false);
                        const inLoopBodyBlock = container.kind === 238 && isIterationStatement(container.parent, false);
                        links.isDeclarationWithCollidingName = !isBlockScopedContainerTopLevel(container) && (!isDeclaredInLoop || !inLoopInitializer && !inLoopBodyBlock);
                    } else {
                        links.isDeclarationWithCollidingName = false;
                    }
                }
            }
            return links.isDeclarationWithCollidingName;
        }
        return false;
    }
    function getReferencedDeclarationWithCollidingName(nodeIn) {
        if (!isGeneratedIdentifier(nodeIn)) {
            const node = getParseTreeNode(nodeIn, isIdentifier);
            if (node) {
                const symbol = getReferencedValueSymbol(node);
                if (symbol && isSymbolOfDeclarationWithCollidingName(symbol)) {
                    return symbol.valueDeclaration;
                }
            }
        }
        return void 0;
    }
    function isDeclarationWithCollidingName(nodeIn) {
        const node = getParseTreeNode(nodeIn, isDeclaration);
        if (node) {
            const symbol = getSymbolOfDeclaration(node);
            if (symbol) {
                return isSymbolOfDeclarationWithCollidingName(symbol);
            }
        }
        return false;
    }
    function isValueAliasDeclaration(node) {
        Debug.assert(!compilerOptions.verbatimModuleSyntax);
        switch (node.kind) {
            case 268:
                return isAliasResolvedToValue(getSymbolOfDeclaration(node));
            case 270:
            case 271:
            case 273:
            case 278:
                const symbol = getSymbolOfDeclaration(node);
                return !!symbol && isAliasResolvedToValue(symbol) && !getTypeOnlyAliasDeclaration(symbol, 111551);
            case 275:
                const exportClause = node.exportClause;
                return !!exportClause && (isNamespaceExport(exportClause) || some(exportClause.elements, isValueAliasDeclaration));
            case 274:
                return node.expression && node.expression.kind === 79 ? isAliasResolvedToValue(getSymbolOfDeclaration(node)) : true;
        }
        return false;
    }
    function isTopLevelValueImportEqualsWithEntityName(nodeIn) {
        const node = getParseTreeNode(nodeIn, isImportEqualsDeclaration);
        if (node === void 0 || node.parent.kind !== 308 || !isInternalModuleImportEqualsDeclaration(node)) {
            return false;
        }
        const isValue = isAliasResolvedToValue(getSymbolOfDeclaration(node));
        return isValue && node.moduleReference && !nodeIsMissing(node.moduleReference);
    }
    function isAliasResolvedToValue(symbol) {
        var _a2;
        if (!symbol) {
            return false;
        }
        const target = getExportSymbolOfValueSymbolIfExported(resolveAlias(symbol));
        if (target === unknownSymbol) {
            return true;
        }
        return !!(((_a2 = getAllSymbolFlags(target)) != null ? _a2 : -1) & 111551) && (shouldPreserveConstEnums(compilerOptions) || !isConstEnumOrConstEnumOnlyModule(target));
    }
    function isConstEnumOrConstEnumOnlyModule(s) {
        return isConstEnumSymbol(s) || !!s.constEnumOnlyModule;
    }
    function isReferencedAliasDeclaration(node, checkChildren) {
        Debug.assert(!compilerOptions.verbatimModuleSyntax);
        if (isAliasSymbolDeclaration2(node)) {
            const symbol = getSymbolOfDeclaration(node);
            const links = symbol && getSymbolLinks(symbol);
            if (links == null ? void 0 : links.referenced) {
                return true;
            }
            const target = getSymbolLinks(symbol).aliasTarget;
            if (target && getEffectiveModifierFlags(node) & 1 && getAllSymbolFlags(target) & 111551 && (shouldPreserveConstEnums(compilerOptions) || !isConstEnumOrConstEnumOnlyModule(target))) {
                return true;
            }
        }
        if (checkChildren) {
            return !!forEachChild(node, node2 => isReferencedAliasDeclaration(node2, checkChildren));
        }
        return false;
    }
    function isImplementationOfOverload(node) {
        if (nodeIsPresent(node.body)) {
            if (isGetAccessor(node) || isSetAccessor(node)) return false;
            const symbol = getSymbolOfDeclaration(node);
            const signaturesOfSymbol = getSignaturesOfSymbol(symbol);
            return signaturesOfSymbol.length > 1 || signaturesOfSymbol.length === 1 && signaturesOfSymbol[0].declaration !== node;
        }
        return false;
    }
    function isRequiredInitializedParameter(parameter) {
        return !!strictNullChecks && !isOptionalParameter(parameter) && !isJSDocParameterTag(parameter) && !!parameter.initializer && !hasSyntacticModifier(parameter, 16476);
    }
    function isOptionalUninitializedParameterProperty(parameter) {
        return strictNullChecks && isOptionalParameter(parameter) && !parameter.initializer && hasSyntacticModifier(parameter, 16476);
    }
    function isExpandoFunctionDeclaration(node) {
        const declaration = getParseTreeNode(node, isFunctionDeclaration);
        if (!declaration) {
            return false;
        }
        const symbol = getSymbolOfDeclaration(declaration);
        if (!symbol || !(symbol.flags & 16)) {
            return false;
        }
        return !!forEachEntry(getExportsOfSymbol(symbol), p => p.flags & 111551 && p.valueDeclaration && isPropertyAccessExpression(p.valueDeclaration));
    }
    function getPropertiesOfContainerFunction(node) {
        const declaration = getParseTreeNode(node, isFunctionDeclaration);
        if (!declaration) {
            return emptyArray;
        }
        const symbol = getSymbolOfDeclaration(declaration);
        return symbol && getPropertiesOfType(getTypeOfSymbol(symbol)) || emptyArray;
    }
    function getNodeCheckFlags(node) {
        var _a2;
        const nodeId = node.id || 0;
        if (nodeId < 0 || nodeId >= nodeLinks.length) return 0;
        return ((_a2 = nodeLinks[nodeId]) == null ? void 0 : _a2.flags) || 0;
    }
    function getEnumMemberValue(node) {
        computeEnumMemberValues(node.parent);
        return getNodeLinks(node).enumMemberValue;
    }
    function canHaveConstantValue(node) {
        switch (node.kind) {
            case 302:
            case 208:
            case 209:
                return true;
        }
        return false;
    }
    function getConstantValue2(node) {
        if (node.kind === 302) {
            return getEnumMemberValue(node);
        }
        const symbol = getNodeLinks(node).resolvedSymbol;
        if (symbol && symbol.flags & 8) {
            const member = symbol.valueDeclaration;
            if (isEnumConst(member.parent)) {
                return getEnumMemberValue(member);
            }
        }
        return void 0;
    }
    function isFunctionType(type) {
        return !!(type.flags & 524288) && getSignaturesOfType(type, 0).length > 0;
    }
    function getTypeReferenceSerializationKind(typeNameIn, location) {
        var _a2;
        const typeName = getParseTreeNode(typeNameIn, isEntityName);
        if (!typeName) return 0;
        if (location) {
            location = getParseTreeNode(location);
            if (!location) return 0;
        }
        let isTypeOnly = false;
        if (isQualifiedName(typeName)) {
            const rootValueSymbol = resolveEntityName(getFirstIdentifier(typeName), 111551, true, true, location);
            isTypeOnly = !!((_a2 = rootValueSymbol == null ? void 0 : rootValueSymbol.declarations) == null ? void 0 : _a2.every(isTypeOnlyImportOrExportDeclaration));
        }
        const valueSymbol = resolveEntityName(typeName, 111551, true, true, location);
        const resolvedSymbol = valueSymbol && valueSymbol.flags & 2097152 ? resolveAlias(valueSymbol) : valueSymbol;
        isTypeOnly || (isTypeOnly = !!(valueSymbol && getTypeOnlyAliasDeclaration(valueSymbol, 111551)));
        const typeSymbol = resolveEntityName(typeName, 788968, true, false, location);
        if (resolvedSymbol && resolvedSymbol === typeSymbol) {
            const globalPromiseSymbol = getGlobalPromiseConstructorSymbol(false);
            if (globalPromiseSymbol && resolvedSymbol === globalPromiseSymbol) {
                return 9;
            }
            const constructorType = getTypeOfSymbol(resolvedSymbol);
            if (constructorType && isConstructorType(constructorType)) {
                return isTypeOnly ? 10 : 1;
            }
        }
        if (!typeSymbol) {
            return isTypeOnly ? 11 : 0;
        }
        const type = getDeclaredTypeOfSymbol(typeSymbol);
        if (isErrorType(type)) {
            return isTypeOnly ? 11 : 0;
        } else if (type.flags & 3) {
            return 11;
        } else if (isTypeAssignableToKind(type, 16384 | 98304 | 131072)) {
            return 2;
        } else if (isTypeAssignableToKind(type, 528)) {
            return 6;
        } else if (isTypeAssignableToKind(type, 296)) {
            return 3;
        } else if (isTypeAssignableToKind(type, 2112)) {
            return 4;
        } else if (isTypeAssignableToKind(type, 402653316)) {
            return 5;
        } else if (isTupleType(type)) {
            return 7;
        } else if (isTypeAssignableToKind(type, 12288)) {
            return 8;
        } else if (isFunctionType(type)) {
            return 10;
        } else if (isArrayType(type)) {
            return 7;
        } else {
            return 11;
        }
    }
    function createTypeOfDeclaration(declarationIn, enclosingDeclaration, flags, tracker, addUndefined) {
        const declaration = getParseTreeNode(declarationIn, isVariableLikeOrAccessor);
        if (!declaration) {
            return factory.createToken(131);
        }
        const symbol = getSymbolOfDeclaration(declaration);
        let type = symbol && !(symbol.flags & (2048 | 131072)) ? getWidenedLiteralType(getTypeOfSymbol(symbol)) : errorType;
        if (type.flags & 8192 && type.symbol === symbol) {
            flags |= 1048576;
        }
        if (addUndefined) {
            type = getOptionalType(type);
        }
        return nodeBuilder.typeToTypeNode(type, enclosingDeclaration, flags | 1024, tracker);
    }
    function createReturnTypeOfSignatureDeclaration(signatureDeclarationIn, enclosingDeclaration, flags, tracker) {
        const signatureDeclaration = getParseTreeNode(signatureDeclarationIn, isFunctionLike);
        if (!signatureDeclaration) {
            return factory.createToken(131);
        }
        const signature = getSignatureFromDeclaration(signatureDeclaration);
        return nodeBuilder.typeToTypeNode(getReturnTypeOfSignature(signature), enclosingDeclaration, flags | 1024, tracker);
    }
    function createTypeOfExpression(exprIn, enclosingDeclaration, flags, tracker) {
        const expr = getParseTreeNode(exprIn, isExpression);
        if (!expr) {
            return factory.createToken(131);
        }
        const type = getWidenedType(getRegularTypeOfExpression(expr));
        return nodeBuilder.typeToTypeNode(type, enclosingDeclaration, flags | 1024, tracker);
    }
    function hasGlobalName(name) {
        return globals.has(escapeLeadingUnderscores(name));
    }
    function getReferencedValueSymbol(reference, startInDeclarationContainer) {
        const resolvedSymbol = getNodeLinks(reference).resolvedSymbol;
        if (resolvedSymbol) {
            return resolvedSymbol;
        }
        let location = reference;
        if (startInDeclarationContainer) {
            const parent2 = reference.parent;
            if (isDeclaration(parent2) && reference === parent2.name) {
                location = getDeclarationContainer(parent2);
            }
        }
        return resolveName(location, reference.escapedText, 111551 | 1048576 | 2097152, void 0, void 0, true);
    }
    function getReferencedValueOrAliasSymbol(reference) {
        const resolvedSymbol = getNodeLinks(reference).resolvedSymbol;
        if (resolvedSymbol && resolvedSymbol !== unknownSymbol) {
            return resolvedSymbol;
        }
        return resolveName(reference, reference.escapedText, 111551 | 1048576 | 2097152, void 0, void 0, true, void 0, void 0);
    }
    function getReferencedValueDeclaration(referenceIn) {
        if (!isGeneratedIdentifier(referenceIn)) {
            const reference = getParseTreeNode(referenceIn, isIdentifier);
            if (reference) {
                const symbol = getReferencedValueSymbol(reference);
                if (symbol) {
                    return getExportSymbolOfValueSymbolIfExported(symbol).valueDeclaration;
                }
            }
        }
        return void 0;
    }
    function isLiteralConstDeclaration(node) {
        if (isDeclarationReadonly(node) || isVariableDeclaration(node) && isVarConst(node)) {
            return isFreshLiteralType(getTypeOfSymbol(getSymbolOfDeclaration(node)));
        }
        return false;
    }
    function literalTypeToNode(type, enclosing, tracker) {
        const enumResult = type.flags & 1056 ? nodeBuilder.symbolToExpression(type.symbol, 111551, enclosing, void 0, tracker) : type === trueType ? factory.createTrue() : type === falseType && factory.createFalse();
        if (enumResult) return enumResult;
        const literalValue = type.value;
        return typeof literalValue === "object" ? factory.createBigIntLiteral(literalValue) : typeof literalValue === "number" ? factory.createNumericLiteral(literalValue) : factory.createStringLiteral(literalValue);
    }
    function createLiteralConstValue(node, tracker) {
        const type = getTypeOfSymbol(getSymbolOfDeclaration(node));
        return literalTypeToNode(type, node, tracker);
    }
    function getJsxFactoryEntity(location) {
        return location ? (getJsxNamespace(location), getSourceFileOfNode(location).localJsxFactory || _jsxFactoryEntity) : _jsxFactoryEntity;
    }
    function getJsxFragmentFactoryEntity(location) {
        if (location) {
            const file = getSourceFileOfNode(location);
            if (file) {
                if (file.localJsxFragmentFactory) {
                    return file.localJsxFragmentFactory;
                }
                const jsxFragPragmas = file.pragmas.get("jsxfrag");
                const jsxFragPragma = isArray(jsxFragPragmas) ? jsxFragPragmas[0] : jsxFragPragmas;
                if (jsxFragPragma) {
                    file.localJsxFragmentFactory = parseIsolatedEntityName(jsxFragPragma.arguments.factory, languageVersion);
                    return file.localJsxFragmentFactory;
                }
            }
        }
        if (compilerOptions.jsxFragmentFactory) {
            return parseIsolatedEntityName(compilerOptions.jsxFragmentFactory, languageVersion);
        }
    }
    function createResolver() {
        const resolvedTypeReferenceDirectives = host.getResolvedTypeReferenceDirectives();
        let fileToDirective;
        if (resolvedTypeReferenceDirectives) {
            fileToDirective = /* @__PURE__ */new Map();
            resolvedTypeReferenceDirectives.forEach(({
                resolvedTypeReferenceDirective
            }, key, mode) => {
                if (!(resolvedTypeReferenceDirective == null ? void 0 : resolvedTypeReferenceDirective.resolvedFileName)) {
                    return;
                }
                const file = host.getSourceFile(resolvedTypeReferenceDirective.resolvedFileName);
                if (file) {
                    addReferencedFilesToTypeDirective(file, key, mode);
                }
            });
        }
        return {
            getReferencedExportContainer,
            getReferencedImportDeclaration,
            getReferencedDeclarationWithCollidingName,
            isDeclarationWithCollidingName,
            isValueAliasDeclaration: nodeIn => {
                const node = getParseTreeNode(nodeIn);
                return node ? isValueAliasDeclaration(node) : true;
            },
            hasGlobalName,
            isReferencedAliasDeclaration: (nodeIn, checkChildren) => {
                const node = getParseTreeNode(nodeIn);
                return node ? isReferencedAliasDeclaration(node, checkChildren) : true;
            },
            getNodeCheckFlags: nodeIn => {
                const node = getParseTreeNode(nodeIn);
                return node ? getNodeCheckFlags(node) : 0;
            },
            isTopLevelValueImportEqualsWithEntityName,
            isDeclarationVisible,
            isImplementationOfOverload,
            isRequiredInitializedParameter,
            isOptionalUninitializedParameterProperty,
            isExpandoFunctionDeclaration,
            getPropertiesOfContainerFunction,
            createTypeOfDeclaration,
            createReturnTypeOfSignatureDeclaration,
            createTypeOfExpression,
            createLiteralConstValue,
            isSymbolAccessible,
            isEntityNameVisible,
            getConstantValue: nodeIn => {
                const node = getParseTreeNode(nodeIn, canHaveConstantValue);
                return node ? getConstantValue2(node) : void 0;
            },
            collectLinkedAliases,
            getReferencedValueDeclaration,
            getTypeReferenceSerializationKind,
            isOptionalParameter,
            moduleExportsSomeValue,
            isArgumentsLocalBinding,
            getExternalModuleFileFromDeclaration: nodeIn => {
                const node = getParseTreeNode(nodeIn, hasPossibleExternalModuleReference);
                return node && getExternalModuleFileFromDeclaration(node);
            },
            getTypeReferenceDirectivesForEntityName,
            getTypeReferenceDirectivesForSymbol,
            isLiteralConstDeclaration,
            isLateBound: nodeIn => {
                const node = getParseTreeNode(nodeIn, isDeclaration);
                const symbol = node && getSymbolOfDeclaration(node);
                return !!(symbol && getCheckFlags(symbol) & 4096);
            },
            getJsxFactoryEntity,
            getJsxFragmentFactoryEntity,
            getAllAccessorDeclarations(accessor) {
                accessor = getParseTreeNode(accessor, isGetOrSetAccessorDeclaration);
                const otherKind = accessor.kind === 175 ? 174 : 175;
                const otherAccessor = getDeclarationOfKind(getSymbolOfDeclaration(accessor), otherKind);
                const firstAccessor = otherAccessor && otherAccessor.pos < accessor.pos ? otherAccessor : accessor;
                const secondAccessor = otherAccessor && otherAccessor.pos < accessor.pos ? accessor : otherAccessor;
                const setAccessor = accessor.kind === 175 ? accessor : otherAccessor;
                const getAccessor = accessor.kind === 174 ? accessor : otherAccessor;
                return {
                    firstAccessor,
                    secondAccessor,
                    setAccessor,
                    getAccessor
                };
            },
            getSymbolOfExternalModuleSpecifier: moduleName => resolveExternalModuleNameWorker(moduleName, moduleName, void 0),
            isBindingCapturedByNode: (node, decl) => {
                const parseNode = getParseTreeNode(node);
                const parseDecl = getParseTreeNode(decl);
                return !!parseNode && !!parseDecl && (isVariableDeclaration(parseDecl) || isBindingElement(parseDecl)) && isBindingCapturedByNode(parseNode, parseDecl);
            },
            getDeclarationStatementsForSourceFile: (node, flags, tracker, bundled) => {
                const n = getParseTreeNode(node);
                Debug.assert(n && n.kind === 308, "Non-sourcefile node passed into getDeclarationsForSourceFile");
                const sym = getSymbolOfDeclaration(node);
                if (!sym) {
                    return !node.locals ? [] : nodeBuilder.symbolTableToDeclarationStatements(node.locals, node, flags, tracker, bundled);
                }
                return !sym.exports ? [] : nodeBuilder.symbolTableToDeclarationStatements(sym.exports, node, flags, tracker, bundled);
            },
            isImportRequiredByAugmentation
        };
        function isImportRequiredByAugmentation(node) {
            const file = getSourceFileOfNode(node);
            if (!file.symbol) return false;
            const importTarget = getExternalModuleFileFromDeclaration(node);
            if (!importTarget) return false;
            if (importTarget === file) return false;
            const exports = getExportsOfModule(file.symbol);
            for (const s of arrayFrom(exports.values())) {
                if (s.mergeId) {
                    const merged = getMergedSymbol(s);
                    if (merged.declarations) {
                        for (const d of merged.declarations) {
                            const declFile = getSourceFileOfNode(d);
                            if (declFile === importTarget) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }
        function isInHeritageClause(node) {
            return node.parent && node.parent.kind === 230 && node.parent.parent && node.parent.parent.kind === 294;
        }
        function getTypeReferenceDirectivesForEntityName(node) {
            if (!fileToDirective) {
                return void 0;
            }
            let meaning;
            if (node.parent.kind === 164) {
                meaning = 111551 | 1048576;
            } else {
                meaning = 788968 | 1920;
                if (node.kind === 79 && isInTypeQuery(node) || node.kind === 208 && !isInHeritageClause(node)) {
                    meaning = 111551 | 1048576;
                }
            }
            const symbol = resolveEntityName(node, meaning, true);
            return symbol && symbol !== unknownSymbol ? getTypeReferenceDirectivesForSymbol(symbol, meaning) : void 0;
        }
        function getTypeReferenceDirectivesForSymbol(symbol, meaning) {
            if (!fileToDirective || !isSymbolFromTypeDeclarationFile(symbol)) {
                return void 0;
            }
            let typeReferenceDirectives;
            for (const decl of symbol.declarations) {
                if (decl.symbol && decl.symbol.flags & meaning) {
                    const file = getSourceFileOfNode(decl);
                    const typeReferenceDirective = fileToDirective.get(file.path);
                    if (typeReferenceDirective) {
                        (typeReferenceDirectives || (typeReferenceDirectives = [])).push(typeReferenceDirective);
                    } else {
                        return void 0;
                    }
                }
            }
            return typeReferenceDirectives;
        }
        function isSymbolFromTypeDeclarationFile(symbol) {
            if (!symbol.declarations) {
                return false;
            }
            let current = symbol;
            while (true) {
                const parent2 = getParentOfSymbol(current);
                if (parent2) {
                    current = parent2;
                } else {
                    break;
                }
            }
            if (current.valueDeclaration && current.valueDeclaration.kind === 308 && current.flags & 512) {
                return false;
            }
            for (const decl of symbol.declarations) {
                const file = getSourceFileOfNode(decl);
                if (fileToDirective.has(file.path)) {
                    return true;
                }
            }
            return false;
        }
        function addReferencedFilesToTypeDirective(file, key, mode) {
            if (fileToDirective.has(file.path)) return;
            fileToDirective.set(file.path, [key, mode]);
            for (const {
                fileName,
                resolutionMode
            } of file.referencedFiles) {
                const resolvedFile = resolveTripleslashReference(fileName, file.fileName);
                const referencedFile = host.getSourceFile(resolvedFile);
                if (referencedFile) {
                    addReferencedFilesToTypeDirective(referencedFile, key, resolutionMode || file.impliedNodeFormat);
                }
            }
        }
    }
    function getExternalModuleFileFromDeclaration(declaration) {
        const specifier = declaration.kind === 264 ? tryCast(declaration.name, isStringLiteral) : getExternalModuleName(declaration);
        const moduleSymbol = resolveExternalModuleNameWorker(specifier, specifier, void 0);
        if (!moduleSymbol) {
            return void 0;
        }
        return getDeclarationOfKind(moduleSymbol, 308);
    }
    function initializeTypeChecker() {
        for (const file of host.getSourceFiles()) {
            bindSourceFile(file, compilerOptions);
        }
        amalgamatedDuplicates = /* @__PURE__ */new Map();
        let augmentations;
        for (const file of host.getSourceFiles()) {
            if (file.redirectInfo) {
                continue;
            }
            if (!isExternalOrCommonJsModule(file)) {
                const fileGlobalThisSymbol = file.locals.get("globalThis");
                if (fileGlobalThisSymbol == null ? void 0 : fileGlobalThisSymbol.declarations) {
                    for (const declaration of fileGlobalThisSymbol.declarations) {
                        diagnostics.add(createDiagnosticForNode(declaration, Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0, "globalThis"));
                    }
                }
                mergeSymbolTable(globals, file.locals);
            }
            if (file.jsGlobalAugmentations) {
                mergeSymbolTable(globals, file.jsGlobalAugmentations);
            }
            if (file.patternAmbientModules && file.patternAmbientModules.length) {
                patternAmbientModules = concatenate(patternAmbientModules, file.patternAmbientModules);
            }
            if (file.moduleAugmentations.length) {
                (augmentations || (augmentations = [])).push(file.moduleAugmentations);
            }
            if (file.symbol && file.symbol.globalExports) {
                const source = file.symbol.globalExports;
                source.forEach((sourceSymbol, id) => {
                    if (!globals.has(id)) {
                        globals.set(id, sourceSymbol);
                    }
                });
            }
        }
        if (augmentations) {
            for (const list of augmentations) {
                for (const augmentation of list) {
                    if (!isGlobalScopeAugmentation(augmentation.parent)) continue;
                    mergeModuleAugmentation(augmentation);
                }
            }
        }
        addToSymbolTable(globals, builtinGlobals, Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0);
        getSymbolLinks(undefinedSymbol).type = undefinedWideningType;
        getSymbolLinks(argumentsSymbol).type = getGlobalType("IArguments", 0, true);
        getSymbolLinks(unknownSymbol).type = errorType;
        getSymbolLinks(globalThisSymbol).type = createObjectType(16, globalThisSymbol);
        globalArrayType = getGlobalType("Array", 1, true);
        globalObjectType = getGlobalType("Object", 0, true);
        globalFunctionType = getGlobalType("Function", 0, true);
        globalCallableFunctionType = strictBindCallApply && getGlobalType("CallableFunction", 0, true) || globalFunctionType;
        globalNewableFunctionType = strictBindCallApply && getGlobalType("NewableFunction", 0, true) || globalFunctionType;
        globalStringType = getGlobalType("String", 0, true);
        globalNumberType = getGlobalType("Number", 0, true);
        globalBooleanType = getGlobalType("Boolean", 0, true);
        globalRegExpType = getGlobalType("RegExp", 0, true);
        anyArrayType = createArrayType(anyType);
        autoArrayType = createArrayType(autoType);
        if (autoArrayType === emptyObjectType) {
            autoArrayType = createAnonymousType(void 0, emptySymbols, emptyArray, emptyArray, emptyArray);
        }
        globalReadonlyArrayType = getGlobalTypeOrUndefined("ReadonlyArray", 1) || globalArrayType;
        anyReadonlyArrayType = globalReadonlyArrayType ? createTypeFromGenericGlobalType(globalReadonlyArrayType, [anyType]) : anyArrayType;
        globalThisType = getGlobalTypeOrUndefined("ThisType", 1);
        if (augmentations) {
            for (const list of augmentations) {
                for (const augmentation of list) {
                    if (isGlobalScopeAugmentation(augmentation.parent)) continue;
                    mergeModuleAugmentation(augmentation);
                }
            }
        }
        amalgamatedDuplicates.forEach(({
            firstFile,
            secondFile,
            conflictingSymbols
        }) => {
            if (conflictingSymbols.size < 8) {
                conflictingSymbols.forEach(({
                    isBlockScoped,
                    firstFileLocations,
                    secondFileLocations
                }, symbolName2) => {
                    const message = isBlockScoped ? Diagnostics.Cannot_redeclare_block_scoped_variable_0 : Diagnostics.Duplicate_identifier_0;
                    for (const node of firstFileLocations) {
                        addDuplicateDeclarationError(node, message, symbolName2, secondFileLocations);
                    }
                    for (const node of secondFileLocations) {
                        addDuplicateDeclarationError(node, message, symbolName2, firstFileLocations);
                    }
                });
            } else {
                const list = arrayFrom(conflictingSymbols.keys()).join(", ");
                diagnostics.add(addRelatedInfo(createDiagnosticForNode(firstFile, Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list), createDiagnosticForNode(secondFile, Diagnostics.Conflicts_are_in_this_file)));
                diagnostics.add(addRelatedInfo(createDiagnosticForNode(secondFile, Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list), createDiagnosticForNode(firstFile, Diagnostics.Conflicts_are_in_this_file)));
            }
        });
        amalgamatedDuplicates = void 0;
    }
    function checkExternalEmitHelpers(location, helpers) {
        if ((requestedExternalEmitHelpers & helpers) !== helpers && compilerOptions.importHelpers) {
            const sourceFile = getSourceFileOfNode(location);
            if (isEffectiveExternalModule(sourceFile, compilerOptions) && !(location.flags & 16777216)) {
                const helpersModule = resolveHelpersModule(sourceFile, location);
                if (helpersModule !== unknownSymbol) {
                    const uncheckedHelpers = helpers & ~requestedExternalEmitHelpers;
                    for (let helper = 1; helper <= 16777216; helper <<= 1) {
                        if (uncheckedHelpers & helper) {
                            for (const name of getHelperNames(helper)) {
                                if (requestedExternalEmitHelperNames.has(name)) continue;
                                requestedExternalEmitHelperNames.add(name);
                                const symbol = getSymbol2(helpersModule.exports, escapeLeadingUnderscores(name), 111551);
                                if (!symbol) {
                                    error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name);
                                } else if (helper & 524288) {
                                    if (!some(getSignaturesOfSymbol(symbol), signature => getParameterCount(signature) > 3)) {
                                        error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 4);
                                    }
                                } else if (helper & 1048576) {
                                    if (!some(getSignaturesOfSymbol(symbol), signature => getParameterCount(signature) > 4)) {
                                        error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 5);
                                    }
                                } else if (helper & 1024) {
                                    if (!some(getSignaturesOfSymbol(symbol), signature => getParameterCount(signature) > 2)) {
                                        error(location, Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, externalHelpersModuleNameText, name, 3);
                                    }
                                }
                            }
                        }
                    }
                }
                requestedExternalEmitHelpers |= helpers;
            }
        }
    }
    function getHelperNames(helper) {
        switch (helper) {
            case 1:
                return ["__extends"];
            case 2:
                return ["__assign"];
            case 4:
                return ["__rest"];
            case 8:
                return legacyDecorators ? ["__decorate"] : ["__esDecorate", "__runInitializers"];
            case 16:
                return ["__metadata"];
            case 32:
                return ["__param"];
            case 64:
                return ["__awaiter"];
            case 128:
                return ["__generator"];
            case 256:
                return ["__values"];
            case 512:
                return ["__read"];
            case 1024:
                return ["__spreadArray"];
            case 2048:
                return ["__await"];
            case 4096:
                return ["__asyncGenerator"];
            case 8192:
                return ["__asyncDelegator"];
            case 16384:
                return ["__asyncValues"];
            case 32768:
                return ["__exportStar"];
            case 65536:
                return ["__importStar"];
            case 131072:
                return ["__importDefault"];
            case 262144:
                return ["__makeTemplateObject"];
            case 524288:
                return ["__classPrivateFieldGet"];
            case 1048576:
                return ["__classPrivateFieldSet"];
            case 2097152:
                return ["__classPrivateFieldIn"];
            case 4194304:
                return ["__createBinding"];
            case 8388608:
                return ["__setFunctionName"];
            case 16777216:
                return ["__propKey"];
            default:
                return Debug.fail("Unrecognized helper");
        }
    }
    function resolveHelpersModule(node, errorNode) {
        if (!externalHelpersModule) {
            externalHelpersModule = resolveExternalModule(node, externalHelpersModuleNameText, Diagnostics.This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found, errorNode) || unknownSymbol;
        }
        return externalHelpersModule;
    }
    function checkGrammarModifiers(node) {
        const quickResult = reportObviousDecoratorErrors(node) || reportObviousModifierErrors(node);
        if (quickResult !== void 0) {
            return quickResult;
        }
        if (isParameter(node) && parameterIsThisKeyword(node)) {
            return grammarErrorOnFirstToken(node, Diagnostics.Neither_decorators_nor_modifiers_may_be_applied_to_this_parameters);
        }
        let lastStatic, lastDeclare, lastAsync, lastOverride, firstDecorator;
        let flags = 0;
        let sawExportBeforeDecorators = false;
        let hasLeadingDecorators = false;
        for (const modifier of node.modifiers) {
            if (isDecorator(modifier)) {
                if (!nodeCanBeDecorated(legacyDecorators, node, node.parent, node.parent.parent)) {
                    if (node.kind === 171 && !nodeIsPresent(node.body)) {
                        return grammarErrorOnFirstToken(node, Diagnostics.A_decorator_can_only_decorate_a_method_implementation_not_an_overload);
                    } else {
                        return grammarErrorOnFirstToken(node, Diagnostics.Decorators_are_not_valid_here);
                    }
                } else if (legacyDecorators && (node.kind === 174 || node.kind === 175)) {
                    const accessors = getAllAccessorDeclarations(node.parent.members, node);
                    if (hasDecorators(accessors.firstAccessor) && node === accessors.secondAccessor) {
                        return grammarErrorOnFirstToken(node, Diagnostics.Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name);
                    }
                }
                if (flags & ~(1025 | 131072)) {
                    return grammarErrorOnNode(modifier, Diagnostics.Decorators_are_not_valid_here);
                }
                if (hasLeadingDecorators && flags & 126975) {
                    Debug.assertIsDefined(firstDecorator);
                    const sourceFile = getSourceFileOfNode(modifier);
                    if (!hasParseDiagnostics(sourceFile)) {
                        addRelatedInfo(error(modifier, Diagnostics.Decorators_may_not_appear_after_export_or_export_default_if_they_also_appear_before_export), createDiagnosticForNode(firstDecorator, Diagnostics.Decorator_used_before_export_here));
                        return true;
                    }
                    return false;
                }
                flags |= 131072;
                if (!(flags & 126975)) {
                    hasLeadingDecorators = true;
                } else if (flags & 1) {
                    sawExportBeforeDecorators = true;
                }
                firstDecorator != null ? firstDecorator : firstDecorator = modifier;
            } else {
                if (modifier.kind !== 146) {
                    if (node.kind === 168 || node.kind === 170) {
                        return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_type_member, tokenToString(modifier.kind));
                    }
                    if (node.kind === 178 && (modifier.kind !== 124 || !isClassLike(node.parent))) {
                        return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_an_index_signature, tokenToString(modifier.kind));
                    }
                }
                if (modifier.kind !== 101 && modifier.kind !== 145 && modifier.kind !== 85) {
                    if (node.kind === 165) {
                        return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_type_parameter, tokenToString(modifier.kind));
                    }
                }
                switch (modifier.kind) {
                    case 85:
                        if (node.kind !== 263 && node.kind !== 165) {
                            return grammarErrorOnNode(node, Diagnostics.A_class_member_cannot_have_the_0_keyword, tokenToString(85));
                        }
                        const parent2 = node.parent;
                        if (node.kind === 165 && !(isFunctionLikeDeclaration(parent2) || isClassLike(parent2) || isFunctionTypeNode(parent2) || isConstructorTypeNode(parent2) || isCallSignatureDeclaration(parent2) || isConstructSignatureDeclaration(parent2) || isMethodSignature(parent2))) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_can_only_appear_on_a_type_parameter_of_a_function_method_or_class, tokenToString(modifier.kind));
                        }
                        break;
                    case 161:
                        if (flags & 16384) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "override");
                        } else if (flags & 2) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "override", "declare");
                        } else if (flags & 64) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "readonly");
                        } else if (flags & 128) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "accessor");
                        } else if (flags & 512) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "override", "async");
                        }
                        flags |= 16384;
                        lastOverride = modifier;
                        break;
                    case 123:
                    case 122:
                    case 121:
                        const text = visibilityToString(modifierToFlag(modifier.kind));
                        if (flags & 28) {
                            return grammarErrorOnNode(modifier, Diagnostics.Accessibility_modifier_already_seen);
                        } else if (flags & 16384) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "override");
                        } else if (flags & 32) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "static");
                        } else if (flags & 128) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "accessor");
                        } else if (flags & 64) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "readonly");
                        } else if (flags & 512) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "async");
                        } else if (node.parent.kind === 265 || node.parent.kind === 308) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, text);
                        } else if (flags & 256) {
                            if (modifier.kind === 121) {
                                return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, text, "abstract");
                            } else {
                                return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, text, "abstract");
                            }
                        } else if (isPrivateIdentifierClassElementDeclaration(node)) {
                            return grammarErrorOnNode(modifier, Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier);
                        }
                        flags |= modifierToFlag(modifier.kind);
                        break;
                    case 124:
                        if (flags & 32) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "static");
                        } else if (flags & 64) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "readonly");
                        } else if (flags & 512) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "async");
                        } else if (flags & 128) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "accessor");
                        } else if (node.parent.kind === 265 || node.parent.kind === 308) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, "static");
                        } else if (node.kind === 166) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "static");
                        } else if (flags & 256) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract");
                        } else if (flags & 16384) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "static", "override");
                        }
                        flags |= 32;
                        lastStatic = modifier;
                        break;
                    case 127:
                        if (flags & 128) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "accessor");
                        } else if (flags & 64) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "accessor", "readonly");
                        } else if (flags & 2) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "accessor", "declare");
                        } else if (node.kind !== 169) {
                            return grammarErrorOnNode(modifier, Diagnostics.accessor_modifier_can_only_appear_on_a_property_declaration);
                        }
                        flags |= 128;
                        break;
                    case 146:
                        if (flags & 64) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "readonly");
                        } else if (node.kind !== 169 && node.kind !== 168 && node.kind !== 178 && node.kind !== 166) {
                            return grammarErrorOnNode(modifier, Diagnostics.readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature);
                        } else if (flags & 128) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "readonly", "accessor");
                        }
                        flags |= 64;
                        break;
                    case 93:
                        if (compilerOptions.verbatimModuleSyntax && !(node.flags & 16777216) && node.kind !== 262 && node.kind !== 261 && node.kind !== 264 && node.parent.kind === 308 && (moduleKind === 1 || getSourceFileOfNode(node).impliedNodeFormat === 1)) {
                            return grammarErrorOnNode(modifier, Diagnostics.A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled);
                        }
                        if (flags & 1) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "export");
                        } else if (flags & 2) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "declare");
                        } else if (flags & 256) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "abstract");
                        } else if (flags & 512) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "async");
                        } else if (isClassLike(node.parent)) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "export");
                        } else if (node.kind === 166) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "export");
                        }
                        flags |= 1;
                        break;
                    case 88:
                        const container = node.parent.kind === 308 ? node.parent : node.parent.parent;
                        if (container.kind === 264 && !isAmbientModule(container)) {
                            return grammarErrorOnNode(modifier, Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module);
                        } else if (!(flags & 1)) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "export", "default");
                        } else if (sawExportBeforeDecorators) {
                            return grammarErrorOnNode(firstDecorator, Diagnostics.Decorators_are_not_valid_here);
                        }
                        flags |= 1024;
                        break;
                    case 136:
                        if (flags & 2) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "declare");
                        } else if (flags & 512) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async");
                        } else if (flags & 16384) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "override");
                        } else if (isClassLike(node.parent) && !isPropertyDeclaration(node)) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "declare");
                        } else if (node.kind === 166) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "declare");
                        } else if (node.parent.flags & 16777216 && node.parent.kind === 265) {
                            return grammarErrorOnNode(modifier, Diagnostics.A_declare_modifier_cannot_be_used_in_an_already_ambient_context);
                        } else if (isPrivateIdentifierClassElementDeclaration(node)) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "declare");
                        } else if (flags & 128) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "declare", "accessor");
                        }
                        flags |= 2;
                        lastDeclare = modifier;
                        break;
                    case 126:
                        if (flags & 256) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "abstract");
                        }
                        if (node.kind !== 260 && node.kind !== 182) {
                            if (node.kind !== 171 && node.kind !== 169 && node.kind !== 174 && node.kind !== 175) {
                                return grammarErrorOnNode(modifier, Diagnostics.abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration);
                            }
                            if (!(node.parent.kind === 260 && hasSyntacticModifier(node.parent, 256))) {
                                return grammarErrorOnNode(modifier, Diagnostics.Abstract_methods_can_only_appear_within_an_abstract_class);
                            }
                            if (flags & 32) {
                                return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract");
                            }
                            if (flags & 8) {
                                return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "private", "abstract");
                            }
                            if (flags & 512 && lastAsync) {
                                return grammarErrorOnNode(lastAsync, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract");
                            }
                            if (flags & 16384) {
                                return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "abstract", "override");
                            }
                            if (flags & 128) {
                                return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "abstract", "accessor");
                            }
                        }
                        if (isNamedDeclaration(node) && node.name.kind === 80) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "abstract");
                        }
                        flags |= 256;
                        break;
                    case 132:
                        if (flags & 512) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, "async");
                        } else if (flags & 2 || node.parent.flags & 16777216) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async");
                        } else if (node.kind === 166) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_appear_on_a_parameter, "async");
                        }
                        if (flags & 256) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract");
                        }
                        flags |= 512;
                        lastAsync = modifier;
                        break;
                    case 101:
                    case 145:
                        const inOutFlag = modifier.kind === 101 ? 32768 : 65536;
                        const inOutText = modifier.kind === 101 ? "in" : "out";
                        if (node.kind !== 165 || !(isInterfaceDeclaration(node.parent) || isClassLike(node.parent) || isTypeAliasDeclaration(node.parent))) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias, inOutText);
                        }
                        if (flags & inOutFlag) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_already_seen, inOutText);
                        }
                        if (inOutFlag & 32768 && flags & 65536) {
                            return grammarErrorOnNode(modifier, Diagnostics._0_modifier_must_precede_1_modifier, "in", "out");
                        }
                        flags |= inOutFlag;
                        break;
                }
            }
        }
        if (node.kind === 173) {
            if (flags & 32) {
                return grammarErrorOnNode(lastStatic, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "static");
            }
            if (flags & 16384) {
                return grammarErrorOnNode(lastOverride, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "override");
            }
            if (flags & 512) {
                return grammarErrorOnNode(lastAsync, Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "async");
            }
            return false;
        } else if ((node.kind === 269 || node.kind === 268) && flags & 2) {
            return grammarErrorOnNode(lastDeclare, Diagnostics.A_0_modifier_cannot_be_used_with_an_import_declaration, "declare");
        } else if (node.kind === 166 && flags & 16476 && isBindingPattern(node.name)) {
            return grammarErrorOnNode(node, Diagnostics.A_parameter_property_may_not_be_declared_using_a_binding_pattern);
        } else if (node.kind === 166 && flags & 16476 && node.dotDotDotToken) {
            return grammarErrorOnNode(node, Diagnostics.A_parameter_property_cannot_be_declared_using_a_rest_parameter);
        }
        if (flags & 512) {
            return checkGrammarAsyncModifier(node, lastAsync);
        }
        return false;
    }
    function reportObviousModifierErrors(node) {
        if (!node.modifiers) return false;
        const modifier = findFirstIllegalModifier(node);
        return modifier && grammarErrorOnFirstToken(modifier, Diagnostics.Modifiers_cannot_appear_here);
    }
    function findFirstModifierExcept(node, allowedModifier) {
        const modifier = find(node.modifiers, isModifier);
        return modifier && modifier.kind !== allowedModifier ? modifier : void 0;
    }
    function findFirstIllegalModifier(node) {
        switch (node.kind) {
            case 174:
            case 175:
            case 173:
            case 169:
            case 168:
            case 171:
            case 170:
            case 178:
            case 264:
            case 269:
            case 268:
            case 275:
            case 274:
            case 215:
            case 216:
            case 166:
            case 165:
                return void 0;
            case 172:
            case 299:
            case 300:
            case 267:
            case 279:
                return find(node.modifiers, isModifier);
            default:
                if (node.parent.kind === 265 || node.parent.kind === 308) {
                    return void 0;
                }
                switch (node.kind) {
                    case 259:
                        return findFirstModifierExcept(node, 132);
                    case 260:
                    case 182:
                        return findFirstModifierExcept(node, 126);
                    case 228:
                    case 261:
                    case 240:
                    case 262:
                        return find(node.modifiers, isModifier);
                    case 263:
                        return findFirstModifierExcept(node, 85);
                    default:
                        Debug.assertNever(node);
                }
        }
    }
    function reportObviousDecoratorErrors(node) {
        const decorator = findFirstIllegalDecorator(node);
        return decorator && grammarErrorOnFirstToken(decorator, Diagnostics.Decorators_are_not_valid_here);
    }
    function findFirstIllegalDecorator(node) {
        return canHaveIllegalDecorators(node) ? find(node.modifiers, isDecorator) : void 0;
    }
    function checkGrammarAsyncModifier(node, asyncModifier) {
        switch (node.kind) {
            case 171:
            case 259:
            case 215:
            case 216:
                return false;
        }
        return grammarErrorOnNode(asyncModifier, Diagnostics._0_modifier_cannot_be_used_here, "async");
    }
    function checkGrammarForDisallowedTrailingComma(list, diag2 = Diagnostics.Trailing_comma_not_allowed) {
        if (list && list.hasTrailingComma) {
            return grammarErrorAtPos(list[0], list.end - ",".length, ",".length, diag2);
        }
        return false;
    }
    function checkGrammarTypeParameterList(typeParameters, file) {
        if (typeParameters && typeParameters.length === 0) {
            const start = typeParameters.pos - "<".length;
            const end = skipTrivia(file.text, typeParameters.end) + ">".length;
            return grammarErrorAtPos(file, start, end - start, Diagnostics.Type_parameter_list_cannot_be_empty);
        }
        return false;
    }
    function checkGrammarParameterList(parameters) {
        let seenOptionalParameter = false;
        const parameterCount = parameters.length;
        for (let i = 0; i < parameterCount; i++) {
            const parameter = parameters[i];
            if (parameter.dotDotDotToken) {
                if (i !== parameterCount - 1) {
                    return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);
                }
                if (!(parameter.flags & 16777216)) {
                    checkGrammarForDisallowedTrailingComma(parameters, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);
                }
                if (parameter.questionToken) {
                    return grammarErrorOnNode(parameter.questionToken, Diagnostics.A_rest_parameter_cannot_be_optional);
                }
                if (parameter.initializer) {
                    return grammarErrorOnNode(parameter.name, Diagnostics.A_rest_parameter_cannot_have_an_initializer);
                }
            } else if (isOptionalParameter(parameter)) {
                seenOptionalParameter = true;
                if (parameter.questionToken && parameter.initializer) {
                    return grammarErrorOnNode(parameter.name, Diagnostics.Parameter_cannot_have_question_mark_and_initializer);
                }
            } else if (seenOptionalParameter && !parameter.initializer) {
                return grammarErrorOnNode(parameter.name, Diagnostics.A_required_parameter_cannot_follow_an_optional_parameter);
            }
        }
    }
    function getNonSimpleParameters(parameters) {
        return filter(parameters, parameter => !!parameter.initializer || isBindingPattern(parameter.name) || isRestParameter(parameter));
    }
    function checkGrammarForUseStrictSimpleParameterList(node) {
        if (languageVersion >= 3) {
            const useStrictDirective = node.body && isBlock(node.body) && findUseStrictPrologue(node.body.statements);
            if (useStrictDirective) {
                const nonSimpleParameters = getNonSimpleParameters(node.parameters);
                if (length(nonSimpleParameters)) {
                    forEach(nonSimpleParameters, parameter => {
                        addRelatedInfo(error(parameter, Diagnostics.This_parameter_is_not_allowed_with_use_strict_directive), createDiagnosticForNode(useStrictDirective, Diagnostics.use_strict_directive_used_here));
                    });
                    const diagnostics2 = nonSimpleParameters.map((parameter, index) => index === 0 ? createDiagnosticForNode(parameter, Diagnostics.Non_simple_parameter_declared_here) : createDiagnosticForNode(parameter, Diagnostics.and_here));
                    addRelatedInfo(error(useStrictDirective, Diagnostics.use_strict_directive_cannot_be_used_with_non_simple_parameter_list), ...diagnostics2);
                    return true;
                }
            }
        }
        return false;
    }
    function checkGrammarFunctionLikeDeclaration(node) {
        const file = getSourceFileOfNode(node);
        return checkGrammarModifiers(node) || checkGrammarTypeParameterList(node.typeParameters, file) || checkGrammarParameterList(node.parameters) || checkGrammarArrowFunction(node, file) || isFunctionLikeDeclaration(node) && checkGrammarForUseStrictSimpleParameterList(node);
    }
    function checkGrammarClassLikeDeclaration(node) {
        const file = getSourceFileOfNode(node);
        return checkGrammarClassDeclarationHeritageClauses(node) || checkGrammarTypeParameterList(node.typeParameters, file);
    }
    function checkGrammarArrowFunction(node, file) {
        if (!isArrowFunction(node)) {
            return false;
        }
        if (node.typeParameters && !(length(node.typeParameters) > 1 || node.typeParameters.hasTrailingComma || node.typeParameters[0].constraint)) {
            if (file && fileExtensionIsOneOf(file.fileName, [".mts", ".cts"])) {
                grammarErrorOnNode(node.typeParameters[0], Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_constraint);
            }
        }
        const {
            equalsGreaterThanToken
        } = node;
        const startLine = getLineAndCharacterOfPosition(file, equalsGreaterThanToken.pos).line;
        const endLine = getLineAndCharacterOfPosition(file, equalsGreaterThanToken.end).line;
        return startLine !== endLine && grammarErrorOnNode(equalsGreaterThanToken, Diagnostics.Line_terminator_not_permitted_before_arrow);
    }
    function checkGrammarIndexSignatureParameters(node) {
        const parameter = node.parameters[0];
        if (node.parameters.length !== 1) {
            if (parameter) {
                return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_must_have_exactly_one_parameter);
            } else {
                return grammarErrorOnNode(node, Diagnostics.An_index_signature_must_have_exactly_one_parameter);
            }
        }
        checkGrammarForDisallowedTrailingComma(node.parameters, Diagnostics.An_index_signature_cannot_have_a_trailing_comma);
        if (parameter.dotDotDotToken) {
            return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.An_index_signature_cannot_have_a_rest_parameter);
        }
        if (hasEffectiveModifiers(parameter)) {
            return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_cannot_have_an_accessibility_modifier);
        }
        if (parameter.questionToken) {
            return grammarErrorOnNode(parameter.questionToken, Diagnostics.An_index_signature_parameter_cannot_have_a_question_mark);
        }
        if (parameter.initializer) {
            return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_cannot_have_an_initializer);
        }
        if (!parameter.type) {
            return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_must_have_a_type_annotation);
        }
        const type = getTypeFromTypeNode(parameter.type);
        if (someType(type, t => !!(t.flags & 8576)) || isGenericType(type)) {
            return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_object_type_instead);
        }
        if (!everyType(type, isValidIndexKeyType)) {
            return grammarErrorOnNode(parameter.name, Diagnostics.An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type);
        }
        if (!node.type) {
            return grammarErrorOnNode(node, Diagnostics.An_index_signature_must_have_a_type_annotation);
        }
        return false;
    }
    function checkGrammarIndexSignature(node) {
        return checkGrammarModifiers(node) || checkGrammarIndexSignatureParameters(node);
    }
    function checkGrammarForAtLeastOneTypeArgument(node, typeArguments) {
        if (typeArguments && typeArguments.length === 0) {
            const sourceFile = getSourceFileOfNode(node);
            const start = typeArguments.pos - "<".length;
            const end = skipTrivia(sourceFile.text, typeArguments.end) + ">".length;
            return grammarErrorAtPos(sourceFile, start, end - start, Diagnostics.Type_argument_list_cannot_be_empty);
        }
        return false;
    }
    function checkGrammarTypeArguments(node, typeArguments) {
        return checkGrammarForDisallowedTrailingComma(typeArguments) || checkGrammarForAtLeastOneTypeArgument(node, typeArguments);
    }
    function checkGrammarTaggedTemplateChain(node) {
        if (node.questionDotToken || node.flags & 32) {
            return grammarErrorOnNode(node.template, Diagnostics.Tagged_template_expressions_are_not_permitted_in_an_optional_chain);
        }
        return false;
    }
    function checkGrammarHeritageClause(node) {
        const types = node.types;
        if (checkGrammarForDisallowedTrailingComma(types)) {
            return true;
        }
        if (types && types.length === 0) {
            const listType = tokenToString(node.token);
            return grammarErrorAtPos(node, types.pos, 0, Diagnostics._0_list_cannot_be_empty, listType);
        }
        return some(types, checkGrammarExpressionWithTypeArguments);
    }
    function checkGrammarExpressionWithTypeArguments(node) {
        if (isExpressionWithTypeArguments(node) && isImportKeyword(node.expression) && node.typeArguments) {
            return grammarErrorOnNode(node, Diagnostics.This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments);
        }
        return checkGrammarTypeArguments(node, node.typeArguments);
    }
    function checkGrammarClassDeclarationHeritageClauses(node) {
        let seenExtendsClause = false;
        let seenImplementsClause = false;
        if (!checkGrammarModifiers(node) && node.heritageClauses) {
            for (const heritageClause of node.heritageClauses) {
                if (heritageClause.token === 94) {
                    if (seenExtendsClause) {
                        return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_already_seen);
                    }
                    if (seenImplementsClause) {
                        return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_must_precede_implements_clause);
                    }
                    if (heritageClause.types.length > 1) {
                        return grammarErrorOnFirstToken(heritageClause.types[1], Diagnostics.Classes_can_only_extend_a_single_class);
                    }
                    seenExtendsClause = true;
                } else {
                    Debug.assert(heritageClause.token === 117);
                    if (seenImplementsClause) {
                        return grammarErrorOnFirstToken(heritageClause, Diagnostics.implements_clause_already_seen);
                    }
                    seenImplementsClause = true;
                }
                checkGrammarHeritageClause(heritageClause);
            }
        }
    }
    function checkGrammarInterfaceDeclaration(node) {
        let seenExtendsClause = false;
        if (node.heritageClauses) {
            for (const heritageClause of node.heritageClauses) {
                if (heritageClause.token === 94) {
                    if (seenExtendsClause) {
                        return grammarErrorOnFirstToken(heritageClause, Diagnostics.extends_clause_already_seen);
                    }
                    seenExtendsClause = true;
                } else {
                    Debug.assert(heritageClause.token === 117);
                    return grammarErrorOnFirstToken(heritageClause, Diagnostics.Interface_declaration_cannot_have_implements_clause);
                }
                checkGrammarHeritageClause(heritageClause);
            }
        }
        return false;
    }
    function checkGrammarComputedPropertyName(node) {
        if (node.kind !== 164) {
            return false;
        }
        const computedPropertyName = node;
        if (computedPropertyName.expression.kind === 223 && computedPropertyName.expression.operatorToken.kind === 27) {
            return grammarErrorOnNode(computedPropertyName.expression, Diagnostics.A_comma_expression_is_not_allowed_in_a_computed_property_name);
        }
        return false;
    }
    function checkGrammarForGenerator(node) {
        if (node.asteriskToken) {
            Debug.assert(node.kind === 259 || node.kind === 215 || node.kind === 171);
            if (node.flags & 16777216) {
                return grammarErrorOnNode(node.asteriskToken, Diagnostics.Generators_are_not_allowed_in_an_ambient_context);
            }
            if (!node.body) {
                return grammarErrorOnNode(node.asteriskToken, Diagnostics.An_overload_signature_cannot_be_declared_as_a_generator);
            }
        }
    }
    function checkGrammarForInvalidQuestionMark(questionToken, message) {
        return !!questionToken && grammarErrorOnNode(questionToken, message);
    }
    function checkGrammarForInvalidExclamationToken(exclamationToken, message) {
        return !!exclamationToken && grammarErrorOnNode(exclamationToken, message);
    }
    function checkGrammarObjectLiteralExpression(node, inDestructuring) {
        const seen = /* @__PURE__ */new Map();
        for (const prop of node.properties) {
            if (prop.kind === 301) {
                if (inDestructuring) {
                    const expression = skipParentheses(prop.expression);
                    if (isArrayLiteralExpression(expression) || isObjectLiteralExpression(expression)) {
                        return grammarErrorOnNode(prop.expression, Diagnostics.A_rest_element_cannot_contain_a_binding_pattern);
                    }
                }
                continue;
            }
            const name = prop.name;
            if (name.kind === 164) {
                checkGrammarComputedPropertyName(name);
            }
            if (prop.kind === 300 && !inDestructuring && prop.objectAssignmentInitializer) {
                grammarErrorOnNode(prop.equalsToken, Diagnostics.Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern);
            }
            if (name.kind === 80) {
                grammarErrorOnNode(name, Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
            }
            if (canHaveModifiers(prop) && prop.modifiers) {
                for (const mod of prop.modifiers) {
                    if (isModifier(mod) && (mod.kind !== 132 || prop.kind !== 171)) {
                        grammarErrorOnNode(mod, Diagnostics._0_modifier_cannot_be_used_here, getTextOfNode(mod));
                    }
                }
            } else if (canHaveIllegalModifiers(prop) && prop.modifiers) {
                for (const mod of prop.modifiers) {
                    if (isModifier(mod)) {
                        grammarErrorOnNode(mod, Diagnostics._0_modifier_cannot_be_used_here, getTextOfNode(mod));
                    }
                }
            }
            let currentKind;
            switch (prop.kind) {
                case 300:
                case 299:
                    checkGrammarForInvalidExclamationToken(prop.exclamationToken, Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context);
                    checkGrammarForInvalidQuestionMark(prop.questionToken, Diagnostics.An_object_member_cannot_be_declared_optional);
                    if (name.kind === 8) {
                        checkGrammarNumericLiteral(name);
                    }
                    currentKind = 4;
                    break;
                case 171:
                    currentKind = 8;
                    break;
                case 174:
                    currentKind = 1;
                    break;
                case 175:
                    currentKind = 2;
                    break;
                default:
                    throw Debug.assertNever(prop, "Unexpected syntax kind:" + prop.kind);
            }
            if (!inDestructuring) {
                const effectiveName = getPropertyNameForPropertyNameNode(name);
                if (effectiveName === void 0) {
                    continue;
                }
                const existingKind = seen.get(effectiveName);
                if (!existingKind) {
                    seen.set(effectiveName, currentKind);
                } else {
                    if (currentKind & 8 && existingKind & 8) {
                        grammarErrorOnNode(name, Diagnostics.Duplicate_identifier_0, getTextOfNode(name));
                    } else if (currentKind & 4 && existingKind & 4) {
                        grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_multiple_properties_with_the_same_name, getTextOfNode(name));
                    } else if (currentKind & 3 && existingKind & 3) {
                        if (existingKind !== 3 && currentKind !== existingKind) {
                            seen.set(effectiveName, currentKind | existingKind);
                        } else {
                            return grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name);
                        }
                    } else {
                        return grammarErrorOnNode(name, Diagnostics.An_object_literal_cannot_have_property_and_accessor_with_the_same_name);
                    }
                }
            }
        }
    }
    function checkGrammarJsxElement(node) {
        checkGrammarJsxName(node.tagName);
        checkGrammarTypeArguments(node, node.typeArguments);
        const seen = /* @__PURE__ */new Map();
        for (const attr of node.attributes.properties) {
            if (attr.kind === 290) {
                continue;
            }
            const {
                name,
                initializer
            } = attr;
            if (!seen.get(name.escapedText)) {
                seen.set(name.escapedText, true);
            } else {
                return grammarErrorOnNode(name, Diagnostics.JSX_elements_cannot_have_multiple_attributes_with_the_same_name);
            }
            if (initializer && initializer.kind === 291 && !initializer.expression) {
                return grammarErrorOnNode(initializer, Diagnostics.JSX_attributes_must_only_be_assigned_a_non_empty_expression);
            }
        }
    }
    function checkGrammarJsxName(node) {
        if (isPropertyAccessExpression(node)) {
            let propName = node;
            do {
                const check2 = checkGrammarJsxNestedIdentifier(propName.name);
                if (check2) {
                    return check2;
                }
                propName = propName.expression;
            } while (isPropertyAccessExpression(propName));
            const check = checkGrammarJsxNestedIdentifier(propName);
            if (check) {
                return check;
            }
        }
        function checkGrammarJsxNestedIdentifier(name) {
            if (isIdentifier(name) && idText(name).indexOf(":") !== -1) {
                return grammarErrorOnNode(name, Diagnostics.JSX_property_access_expressions_cannot_include_JSX_namespace_names);
            }
        }
    }
    function checkGrammarJsxExpression(node) {
        if (node.expression && isCommaSequence(node.expression)) {
            return grammarErrorOnNode(node.expression, Diagnostics.JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array);
        }
    }
    function checkGrammarForInOrForOfStatement(forInOrOfStatement) {
        if (checkGrammarStatementInAmbientContext(forInOrOfStatement)) {
            return true;
        }
        if (forInOrOfStatement.kind === 247 && forInOrOfStatement.awaitModifier) {
            if (!(forInOrOfStatement.flags & 32768)) {
                const sourceFile = getSourceFileOfNode(forInOrOfStatement);
                if (isInTopLevelContext(forInOrOfStatement)) {
                    if (!hasParseDiagnostics(sourceFile)) {
                        if (!isEffectiveExternalModule(sourceFile, compilerOptions)) {
                            diagnostics.add(createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module));
                        }
                        switch (moduleKind) {
                            case 100:
                            case 199:
                                if (sourceFile.impliedNodeFormat === 1) {
                                    diagnostics.add(createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level));
                                    break;
                                }
                            case 7:
                            case 99:
                            case 4:
                                if (languageVersion >= 4) {
                                    break;
                                }
                            default:
                                diagnostics.add(createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_or_nodenext_and_the_target_option_is_set_to_es2017_or_higher));
                                break;
                        }
                    }
                } else {
                    if (!hasParseDiagnostics(sourceFile)) {
                        const diagnostic = createDiagnosticForNode(forInOrOfStatement.awaitModifier, Diagnostics.for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules);
                        const func = getContainingFunction(forInOrOfStatement);
                        if (func && func.kind !== 173) {
                            Debug.assert((getFunctionFlags(func) & 2) === 0, "Enclosing function should never be an async function.");
                            const relatedInfo = createDiagnosticForNode(func, Diagnostics.Did_you_mean_to_mark_this_function_as_async);
                            addRelatedInfo(diagnostic, relatedInfo);
                        }
                        diagnostics.add(diagnostic);
                        return true;
                    }
                }
                return false;
            }
        }
        if (isForOfStatement(forInOrOfStatement) && !(forInOrOfStatement.flags & 32768) && isIdentifier(forInOrOfStatement.initializer) && forInOrOfStatement.initializer.escapedText === "async") {
            grammarErrorOnNode(forInOrOfStatement.initializer, Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_async);
            return false;
        }
        if (forInOrOfStatement.initializer.kind === 258) {
            const variableList = forInOrOfStatement.initializer;
            if (!checkGrammarVariableDeclarationList(variableList)) {
                const declarations = variableList.declarations;
                if (!declarations.length) {
                    return false;
                }
                if (declarations.length > 1) {
                    const diagnostic = forInOrOfStatement.kind === 246 ? Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement : Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement;
                    return grammarErrorOnFirstToken(variableList.declarations[1], diagnostic);
                }
                const firstDeclaration = declarations[0];
                if (firstDeclaration.initializer) {
                    const diagnostic = forInOrOfStatement.kind === 246 ? Diagnostics.The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer : Diagnostics.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer;
                    return grammarErrorOnNode(firstDeclaration.name, diagnostic);
                }
                if (firstDeclaration.type) {
                    const diagnostic = forInOrOfStatement.kind === 246 ? Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation : Diagnostics.The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation;
                    return grammarErrorOnNode(firstDeclaration, diagnostic);
                }
            }
        }
        return false;
    }
    function checkGrammarAccessor(accessor) {
        if (!(accessor.flags & 16777216) && accessor.parent.kind !== 184 && accessor.parent.kind !== 261) {
            if (languageVersion < 1) {
                return grammarErrorOnNode(accessor.name, Diagnostics.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher);
            }
            if (languageVersion < 2 && isPrivateIdentifier(accessor.name)) {
                return grammarErrorOnNode(accessor.name, Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher);
            }
            if (accessor.body === void 0 && !hasSyntacticModifier(accessor, 256)) {
                return grammarErrorAtPos(accessor, accessor.end - 1, ";".length, Diagnostics._0_expected, "{");
            }
        }
        if (accessor.body) {
            if (hasSyntacticModifier(accessor, 256)) {
                return grammarErrorOnNode(accessor, Diagnostics.An_abstract_accessor_cannot_have_an_implementation);
            }
            if (accessor.parent.kind === 184 || accessor.parent.kind === 261) {
                return grammarErrorOnNode(accessor.body, Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts);
            }
        }
        if (accessor.typeParameters) {
            return grammarErrorOnNode(accessor.name, Diagnostics.An_accessor_cannot_have_type_parameters);
        }
        if (!doesAccessorHaveCorrectParameterCount(accessor)) {
            return grammarErrorOnNode(accessor.name, accessor.kind === 174 ? Diagnostics.A_get_accessor_cannot_have_parameters : Diagnostics.A_set_accessor_must_have_exactly_one_parameter);
        }
        if (accessor.kind === 175) {
            if (accessor.type) {
                return grammarErrorOnNode(accessor.name, Diagnostics.A_set_accessor_cannot_have_a_return_type_annotation);
            }
            const parameter = Debug.checkDefined(getSetAccessorValueParameter(accessor), "Return value does not match parameter count assertion.");
            if (parameter.dotDotDotToken) {
                return grammarErrorOnNode(parameter.dotDotDotToken, Diagnostics.A_set_accessor_cannot_have_rest_parameter);
            }
            if (parameter.questionToken) {
                return grammarErrorOnNode(parameter.questionToken, Diagnostics.A_set_accessor_cannot_have_an_optional_parameter);
            }
            if (parameter.initializer) {
                return grammarErrorOnNode(accessor.name, Diagnostics.A_set_accessor_parameter_cannot_have_an_initializer);
            }
        }
        return false;
    }
    function doesAccessorHaveCorrectParameterCount(accessor) {
        return getAccessorThisParameter(accessor) || accessor.parameters.length === (accessor.kind === 174 ? 0 : 1);
    }
    function getAccessorThisParameter(accessor) {
        if (accessor.parameters.length === (accessor.kind === 174 ? 1 : 2)) {
            return getThisParameter(accessor);
        }
    }
    function checkGrammarTypeOperatorNode(node) {
        if (node.operator === 156) {
            if (node.type.kind !== 153) {
                return grammarErrorOnNode(node.type, Diagnostics._0_expected, tokenToString(153));
            }
            let parent2 = walkUpParenthesizedTypes(node.parent);
            if (isInJSFile(parent2) && isJSDocTypeExpression(parent2)) {
                const host2 = getJSDocHost(parent2);
                if (host2) {
                    parent2 = getSingleVariableOfVariableStatement(host2) || host2;
                }
            }
            switch (parent2.kind) {
                case 257:
                    const decl = parent2;
                    if (decl.name.kind !== 79) {
                        return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name);
                    }
                    if (!isVariableDeclarationInVariableStatement(decl)) {
                        return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement);
                    }
                    if (!(decl.parent.flags & 2)) {
                        return grammarErrorOnNode(parent2.name, Diagnostics.A_variable_whose_type_is_a_unique_symbol_type_must_be_const);
                    }
                    break;
                case 169:
                    if (!isStatic(parent2) || !hasEffectiveReadonlyModifier(parent2)) {
                        return grammarErrorOnNode(parent2.name, Diagnostics.A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly);
                    }
                    break;
                case 168:
                    if (!hasSyntacticModifier(parent2, 64)) {
                        return grammarErrorOnNode(parent2.name, Diagnostics.A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly);
                    }
                    break;
                default:
                    return grammarErrorOnNode(node, Diagnostics.unique_symbol_types_are_not_allowed_here);
            }
        } else if (node.operator === 146) {
            if (node.type.kind !== 185 && node.type.kind !== 186) {
                return grammarErrorOnFirstToken(node, Diagnostics.readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types, tokenToString(153));
            }
        }
    }
    function checkGrammarForInvalidDynamicName(node, message) {
        if (isNonBindableDynamicName(node)) {
            return grammarErrorOnNode(node, message);
        }
    }
    function checkGrammarMethod(node) {
        if (checkGrammarFunctionLikeDeclaration(node)) {
            return true;
        }
        if (node.kind === 171) {
            if (node.parent.kind === 207) {
                if (node.modifiers && !(node.modifiers.length === 1 && first(node.modifiers).kind === 132)) {
                    return grammarErrorOnFirstToken(node, Diagnostics.Modifiers_cannot_appear_here);
                } else if (checkGrammarForInvalidQuestionMark(node.questionToken, Diagnostics.An_object_member_cannot_be_declared_optional)) {
                    return true;
                } else if (checkGrammarForInvalidExclamationToken(node.exclamationToken, Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context)) {
                    return true;
                } else if (node.body === void 0) {
                    return grammarErrorAtPos(node, node.end - 1, ";".length, Diagnostics._0_expected, "{");
                }
            }
            if (checkGrammarForGenerator(node)) {
                return true;
            }
        }
        if (isClassLike(node.parent)) {
            if (languageVersion < 2 && isPrivateIdentifier(node.name)) {
                return grammarErrorOnNode(node.name, Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher);
            }
            if (node.flags & 16777216) {
                return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type);
            } else if (node.kind === 171 && !node.body) {
                return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type);
            }
        } else if (node.parent.kind === 261) {
            return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type);
        } else if (node.parent.kind === 184) {
            return checkGrammarForInvalidDynamicName(node.name, Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type);
        }
    }
    function checkGrammarBreakOrContinueStatement(node) {
        let current = node;
        while (current) {
            if (isFunctionLikeOrClassStaticBlockDeclaration(current)) {
                return grammarErrorOnNode(node, Diagnostics.Jump_target_cannot_cross_function_boundary);
            }
            switch (current.kind) {
                case 253:
                    if (node.label && current.label.escapedText === node.label.escapedText) {
                        const isMisplacedContinueLabel = node.kind === 248 && !isIterationStatement(current.statement, true);
                        if (isMisplacedContinueLabel) {
                            return grammarErrorOnNode(node, Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement);
                        }
                        return false;
                    }
                    break;
                case 252:
                    if (node.kind === 249 && !node.label) {
                        return false;
                    }
                    break;
                default:
                    if (isIterationStatement(current, false) && !node.label) {
                        return false;
                    }
                    break;
            }
            current = current.parent;
        }
        if (node.label) {
            const message = node.kind === 249 ? Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement : Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement;
            return grammarErrorOnNode(node, message);
        } else {
            const message = node.kind === 249 ? Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement : Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement;
            return grammarErrorOnNode(node, message);
        }
    }
    function checkGrammarBindingElement(node) {
        if (node.dotDotDotToken) {
            const elements = node.parent.elements;
            if (node !== last(elements)) {
                return grammarErrorOnNode(node, Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern);
            }
            checkGrammarForDisallowedTrailingComma(elements, Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);
            if (node.propertyName) {
                return grammarErrorOnNode(node.name, Diagnostics.A_rest_element_cannot_have_a_property_name);
            }
        }
        if (node.dotDotDotToken && node.initializer) {
            return grammarErrorAtPos(node, node.initializer.pos - 1, 1, Diagnostics.A_rest_element_cannot_have_an_initializer);
        }
    }
    function isStringOrNumberLiteralExpression(expr) {
        return isStringOrNumericLiteralLike(expr) || expr.kind === 221 && expr.operator === 40 && expr.operand.kind === 8;
    }
    function isBigIntLiteralExpression(expr) {
        return expr.kind === 9 || expr.kind === 221 && expr.operator === 40 && expr.operand.kind === 9;
    }
    function isSimpleLiteralEnumReference(expr) {
        if ((isPropertyAccessExpression(expr) || isElementAccessExpression(expr) && isStringOrNumberLiteralExpression(expr.argumentExpression)) && isEntityNameExpression(expr.expression)) {
            return !!(checkExpressionCached(expr).flags & 1056);
        }
    }
    function checkAmbientInitializer(node) {
        const initializer = node.initializer;
        if (initializer) {
            const isInvalidInitializer = !(isStringOrNumberLiteralExpression(initializer) || isSimpleLiteralEnumReference(initializer) || initializer.kind === 110 || initializer.kind === 95 || isBigIntLiteralExpression(initializer));
            const isConstOrReadonly = isDeclarationReadonly(node) || isVariableDeclaration(node) && isVarConst(node);
            if (isConstOrReadonly && !node.type) {
                if (isInvalidInitializer) {
                    return grammarErrorOnNode(initializer, Diagnostics.A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference);
                }
            } else {
                return grammarErrorOnNode(initializer, Diagnostics.Initializers_are_not_allowed_in_ambient_contexts);
            }
        }
    }
    function checkGrammarVariableDeclaration(node) {
        if (node.parent.parent.kind !== 246 && node.parent.parent.kind !== 247) {
            if (node.flags & 16777216) {
                checkAmbientInitializer(node);
            } else if (!node.initializer) {
                if (isBindingPattern(node.name) && !isBindingPattern(node.parent)) {
                    return grammarErrorOnNode(node, Diagnostics.A_destructuring_declaration_must_have_an_initializer);
                }
                if (isVarConst(node)) {
                    return grammarErrorOnNode(node, Diagnostics.const_declarations_must_be_initialized);
                }
            }
        }
        if (node.exclamationToken && (node.parent.parent.kind !== 240 || !node.type || node.initializer || node.flags & 16777216)) {
            const message = node.initializer ? Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions : !node.type ? Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations : Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context;
            return grammarErrorOnNode(node.exclamationToken, message);
        }
        if ((moduleKind < 5 || getSourceFileOfNode(node).impliedNodeFormat === 1) && moduleKind !== 4 && !(node.parent.parent.flags & 16777216) && hasSyntacticModifier(node.parent.parent, 1)) {
            checkESModuleMarker(node.name);
        }
        const checkLetConstNames = isLet(node) || isVarConst(node);
        return checkLetConstNames && checkGrammarNameInLetOrConstDeclarations(node.name);
    }
    function checkESModuleMarker(name) {
        if (name.kind === 79) {
            if (idText(name) === "__esModule") {
                return grammarErrorOnNodeSkippedOn("noEmit", name, Diagnostics.Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules);
            }
        } else {
            const elements = name.elements;
            for (const element of elements) {
                if (!isOmittedExpression(element)) {
                    return checkESModuleMarker(element.name);
                }
            }
        }
        return false;
    }
    function checkGrammarNameInLetOrConstDeclarations(name) {
        if (name.kind === 79) {
            if (name.escapedText === "let") {
                return grammarErrorOnNode(name, Diagnostics.let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations);
            }
        } else {
            const elements = name.elements;
            for (const element of elements) {
                if (!isOmittedExpression(element)) {
                    checkGrammarNameInLetOrConstDeclarations(element.name);
                }
            }
        }
        return false;
    }
    function checkGrammarVariableDeclarationList(declarationList) {
        const declarations = declarationList.declarations;
        if (checkGrammarForDisallowedTrailingComma(declarationList.declarations)) {
            return true;
        }
        if (!declarationList.declarations.length) {
            return grammarErrorAtPos(declarationList, declarations.pos, declarations.end - declarations.pos, Diagnostics.Variable_declaration_list_cannot_be_empty);
        }
        return false;
    }
    function checkGrammarForDisallowedLetOrConstStatement(node) {
    }
    function checkGrammarMetaProperty(node) {
    }
    function hasParseDiagnostics(sourceFile) {
    }
    function grammarErrorOnFirstToken(node, message, arg0) {
    }
    function grammarErrorAtPos(nodeForSourceFile, start, length2, message, arg0) {
    }
    function grammarErrorOnNodeSkippedOn(key, node, message) {
    }
    function grammarErrorOnNode(node, message, arg0, arg1, arg2) {
    }
    function checkGrammarConstructorTypeParameters(node) {
    }
    function checkGrammarConstructorTypeAnnotation(node) {
    }
    function checkGrammarProperty(node) {
    }
    function checkGrammarSourceFile(node) {
    }
    function checkGrammarStatementInAmbientContext(node) {
    }
    function checkGrammarNumericLiteral(node) {
    }
    function checkGrammarBigIntLiteral(node) {
    }
    function grammarErrorAfterFirstToken(node, message) {
    }
    function getAmbientModules() {
    }
    function checkGrammarImportClause(node) {
    }
    function checkGrammarNamedImportsOrExports(namedBindings) {

    }
    function checkGrammarImportCallExpression(node) {

    }
    function findMatchingTypeReferenceOrTypeAliasReference(source, unionTarget) {

    }
    function findBestTypeForObjectLiteral(source, unionTarget) {
    }
    function findBestTypeForInvokable(source, unionTarget) {
    }
    function findMostOverlappyType(source, unionTarget) {
    }
    function findMatchingDiscriminantType(source, target, isRelatedTo, skipPartial) {
    }
}