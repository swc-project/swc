#![doc = r" This file is generated by `tools/generate-code`. DO NOT MODIFY."]
#![allow(unused_variables)]
#![allow(clippy::all)]
use swc_ecma_ast::*;
#[doc = r" A visitor trait for traversing the AST."]
pub trait Visit {
    #[doc = "Visit a node of type `Accessibility`.\n\nBy default, this method calls \
             [`Accessibility::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_accessibility(&mut self, node: &Accessibility) {
        <Accessibility as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ArrayLit`.\n\nBy default, this method calls \
             [`ArrayLit::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_array_lit(&mut self, node: &ArrayLit) {
        <ArrayLit as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ArrayPat`.\n\nBy default, this method calls \
             [`ArrayPat::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_array_pat(&mut self, node: &ArrayPat) {
        <ArrayPat as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ArrowExpr`.\n\nBy default, this method calls \
             [`ArrowExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_arrow_expr(&mut self, node: &ArrowExpr) {
        <ArrowExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignExpr`.\n\nBy default, this method calls \
             [`AssignExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_assign_expr(&mut self, node: &AssignExpr) {
        <AssignExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignOp`.\n\nBy default, this method calls \
             [`AssignOp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_assign_op(&mut self, node: &AssignOp) {
        <AssignOp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignPat`.\n\nBy default, this method calls \
             [`AssignPat::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_assign_pat(&mut self, node: &AssignPat) {
        <AssignPat as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignPatProp`.\n\nBy default, this method calls \
             [`AssignPatProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_assign_pat_prop(&mut self, node: &AssignPatProp) {
        <AssignPatProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignProp`.\n\nBy default, this method calls \
             [`AssignProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_assign_prop(&mut self, node: &AssignProp) {
        <AssignProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignTarget`.\n\nBy default, this method calls \
             [`AssignTarget::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_assign_target(&mut self, node: &AssignTarget) {
        <AssignTarget as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignTargetPat`.\n\nBy default, this method calls \
             [`AssignTargetPat::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_assign_target_pat(&mut self, node: &AssignTargetPat) {
        <AssignTargetPat as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_atoms :: Atom`.\n\nBy default, this method calls \
             [`swc_atoms :: Atom::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_atom(&mut self, node: &swc_atoms::Atom) {
        <swc_atoms::Atom as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `AutoAccessor`.\n\nBy default, this method calls \
             [`AutoAccessor::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_auto_accessor(&mut self, node: &AutoAccessor) {
        <AutoAccessor as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `AwaitExpr`.\n\nBy default, this method calls \
             [`AwaitExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_await_expr(&mut self, node: &AwaitExpr) {
        <AwaitExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `BigInt`.\n\nBy default, this method calls \
             [`BigInt::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_big_int(&mut self, node: &BigInt) {
        <BigInt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `BigIntValue`.\n\nBy default, this method calls \
             [`BigIntValue::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_big_int_value(&mut self, node: &BigIntValue) {
        <BigIntValue as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `BinExpr`.\n\nBy default, this method calls \
             [`BinExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_bin_expr(&mut self, node: &BinExpr) {
        <BinExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `BinaryOp`.\n\nBy default, this method calls \
             [`BinaryOp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_binary_op(&mut self, node: &BinaryOp) {
        <BinaryOp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `BindingIdent`.\n\nBy default, this method calls \
             [`BindingIdent::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_binding_ident(&mut self, node: &BindingIdent) {
        <BindingIdent as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `BlockStmt`.\n\nBy default, this method calls \
             [`BlockStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_block_stmt(&mut self, node: &BlockStmt) {
        <BlockStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `BlockStmtOrExpr`.\n\nBy default, this method calls \
             [`BlockStmtOrExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_block_stmt_or_expr(&mut self, node: &BlockStmtOrExpr) {
        <BlockStmtOrExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Bool`.\n\nBy default, this method calls \
             [`Bool::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_bool(&mut self, node: &Bool) {
        <Bool as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `BreakStmt`.\n\nBy default, this method calls \
             [`BreakStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_break_stmt(&mut self, node: &BreakStmt) {
        <BreakStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `CallExpr`.\n\nBy default, this method calls \
             [`CallExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_call_expr(&mut self, node: &CallExpr) {
        <CallExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Callee`.\n\nBy default, this method calls \
             [`Callee::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_callee(&mut self, node: &Callee) {
        <Callee as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `CatchClause`.\n\nBy default, this method calls \
             [`CatchClause::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_catch_clause(&mut self, node: &CatchClause) {
        <CatchClause as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Class`.\n\nBy default, this method calls \
             [`Class::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_class(&mut self, node: &Class) {
        <Class as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassDecl`.\n\nBy default, this method calls \
             [`ClassDecl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_class_decl(&mut self, node: &ClassDecl) {
        <ClassDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassExpr`.\n\nBy default, this method calls \
             [`ClassExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_class_expr(&mut self, node: &ClassExpr) {
        <ClassExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassMember`.\n\nBy default, this method calls \
             [`ClassMember::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_class_member(&mut self, node: &ClassMember) {
        <ClassMember as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ClassMember >`.\n\nBy default, this method calls [`Vec < \
             ClassMember >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_class_members(&mut self, node: &[ClassMember]) {
        <[ClassMember] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassMethod`.\n\nBy default, this method calls \
             [`ClassMethod::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_class_method(&mut self, node: &ClassMethod) {
        <ClassMethod as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassProp`.\n\nBy default, this method calls \
             [`ClassProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_class_prop(&mut self, node: &ClassProp) {
        <ClassProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ComputedPropName`.\n\nBy default, this method calls \
             [`ComputedPropName::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_computed_prop_name(&mut self, node: &ComputedPropName) {
        <ComputedPropName as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `CondExpr`.\n\nBy default, this method calls \
             [`CondExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_cond_expr(&mut self, node: &CondExpr) {
        <CondExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Constructor`.\n\nBy default, this method calls \
             [`Constructor::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_constructor(&mut self, node: &Constructor) {
        <Constructor as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ContinueStmt`.\n\nBy default, this method calls \
             [`ContinueStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_continue_stmt(&mut self, node: &ContinueStmt) {
        <ContinueStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `DebuggerStmt`.\n\nBy default, this method calls \
             [`DebuggerStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_debugger_stmt(&mut self, node: &DebuggerStmt) {
        <DebuggerStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Decl`.\n\nBy default, this method calls \
             [`Decl::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_decl(&mut self, node: &Decl) {
        <Decl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Decorator`.\n\nBy default, this method calls \
             [`Decorator::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_decorator(&mut self, node: &Decorator) {
        <Decorator as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Decorator >`.\n\nBy default, this method calls [`Vec < \
             Decorator >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_decorators(&mut self, node: &[Decorator]) {
        <[Decorator] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `DefaultDecl`.\n\nBy default, this method calls \
             [`DefaultDecl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_default_decl(&mut self, node: &DefaultDecl) {
        <DefaultDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `DoWhileStmt`.\n\nBy default, this method calls \
             [`DoWhileStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_do_while_stmt(&mut self, node: &DoWhileStmt) {
        <DoWhileStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `EmptyStmt`.\n\nBy default, this method calls \
             [`EmptyStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_empty_stmt(&mut self, node: &EmptyStmt) {
        <EmptyStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `EsVersion`.\n\nBy default, this method calls \
             [`EsVersion::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_es_version(&mut self, node: &EsVersion) {
        <EsVersion as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportAll`.\n\nBy default, this method calls \
             [`ExportAll::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_export_all(&mut self, node: &ExportAll) {
        <ExportAll as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDecl`.\n\nBy default, this method calls \
             [`ExportDecl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_export_decl(&mut self, node: &ExportDecl) {
        <ExportDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDefaultDecl`.\n\nBy default, this method calls \
             [`ExportDefaultDecl::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_export_default_decl(&mut self, node: &ExportDefaultDecl) {
        <ExportDefaultDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDefaultExpr`.\n\nBy default, this method calls \
             [`ExportDefaultExpr::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_export_default_expr(&mut self, node: &ExportDefaultExpr) {
        <ExportDefaultExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ExportDefaultSpecifier::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_export_default_specifier(&mut self, node: &ExportDefaultSpecifier) {
        <ExportDefaultSpecifier as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportNamedSpecifier`.\n\nBy default, this method calls \
             [`ExportNamedSpecifier::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_export_named_specifier(&mut self, node: &ExportNamedSpecifier) {
        <ExportNamedSpecifier as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportNamespaceSpecifier`.\n\nBy default, this method calls \
             [`ExportNamespaceSpecifier::visit_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_export_namespace_specifier(&mut self, node: &ExportNamespaceSpecifier) {
        <ExportNamespaceSpecifier as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportSpecifier`.\n\nBy default, this method calls \
             [`ExportSpecifier::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_export_specifier(&mut self, node: &ExportSpecifier) {
        <ExportSpecifier as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ExportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ExportSpecifier >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_export_specifiers(&mut self, node: &[ExportSpecifier]) {
        <[ExportSpecifier] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Expr`.\n\nBy default, this method calls \
             [`Expr::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_expr(&mut self, node: &Expr) {
        <Expr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExprOrSpread`.\n\nBy default, this method calls \
             [`ExprOrSpread::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_expr_or_spread(&mut self, node: &ExprOrSpread) {
        <ExprOrSpread as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ExprOrSpread >`.\n\nBy default, this method calls [`Vec < \
             ExprOrSpread >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_expr_or_spreads(&mut self, node: &[ExprOrSpread]) {
        <[ExprOrSpread] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExprStmt`.\n\nBy default, this method calls \
             [`ExprStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_expr_stmt(&mut self, node: &ExprStmt) {
        <ExprStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Box < Expr > >`.\n\nBy default, this method calls [`Vec < \
             Box < Expr > >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_exprs(&mut self, node: &[Box<Expr>]) {
        <[Box<Expr>] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `FnDecl`.\n\nBy default, this method calls \
             [`FnDecl::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_fn_decl(&mut self, node: &FnDecl) {
        <FnDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `FnExpr`.\n\nBy default, this method calls \
             [`FnExpr::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_fn_expr(&mut self, node: &FnExpr) {
        <FnExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForHead`.\n\nBy default, this method calls \
             [`ForHead::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_for_head(&mut self, node: &ForHead) {
        <ForHead as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForInStmt`.\n\nBy default, this method calls \
             [`ForInStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_for_in_stmt(&mut self, node: &ForInStmt) {
        <ForInStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForOfStmt`.\n\nBy default, this method calls \
             [`ForOfStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_for_of_stmt(&mut self, node: &ForOfStmt) {
        <ForOfStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForStmt`.\n\nBy default, this method calls \
             [`ForStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_for_stmt(&mut self, node: &ForStmt) {
        <ForStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Function`.\n\nBy default, this method calls \
             [`Function::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_function(&mut self, node: &Function) {
        <Function as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `GetterProp`.\n\nBy default, this method calls \
             [`GetterProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_getter_prop(&mut self, node: &GetterProp) {
        <GetterProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Ident`.\n\nBy default, this method calls \
             [`Ident::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_ident(&mut self, node: &Ident) {
        <Ident as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `IdentName`.\n\nBy default, this method calls \
             [`IdentName::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ident_name(&mut self, node: &IdentName) {
        <IdentName as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `IfStmt`.\n\nBy default, this method calls \
             [`IfStmt::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_if_stmt(&mut self, node: &IfStmt) {
        <IfStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Import`.\n\nBy default, this method calls \
             [`Import::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_import(&mut self, node: &Import) {
        <Import as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportDecl`.\n\nBy default, this method calls \
             [`ImportDecl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_import_decl(&mut self, node: &ImportDecl) {
        <ImportDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ImportDefaultSpecifier::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_import_default_specifier(&mut self, node: &ImportDefaultSpecifier) {
        <ImportDefaultSpecifier as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportNamedSpecifier`.\n\nBy default, this method calls \
             [`ImportNamedSpecifier::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_import_named_specifier(&mut self, node: &ImportNamedSpecifier) {
        <ImportNamedSpecifier as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportPhase`.\n\nBy default, this method calls \
             [`ImportPhase::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_import_phase(&mut self, node: &ImportPhase) {
        <ImportPhase as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportSpecifier`.\n\nBy default, this method calls \
             [`ImportSpecifier::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_import_specifier(&mut self, node: &ImportSpecifier) {
        <ImportSpecifier as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ImportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ImportSpecifier >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_import_specifiers(&mut self, node: &[ImportSpecifier]) {
        <[ImportSpecifier] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportStarAsSpecifier`.\n\nBy default, this method calls \
             [`ImportStarAsSpecifier::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_import_star_as_specifier(&mut self, node: &ImportStarAsSpecifier) {
        <ImportStarAsSpecifier as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportWith`.\n\nBy default, this method calls \
             [`ImportWith::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_import_with(&mut self, node: &ImportWith) {
        <ImportWith as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportWithItem`.\n\nBy default, this method calls \
             [`ImportWithItem::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_import_with_item(&mut self, node: &ImportWithItem) {
        <ImportWithItem as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ImportWithItem >`.\n\nBy default, this method calls [`Vec \
             < ImportWithItem >::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_import_with_items(&mut self, node: &[ImportWithItem]) {
        <[ImportWithItem] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Invalid`.\n\nBy default, this method calls \
             [`Invalid::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_invalid(&mut self, node: &Invalid) {
        <Invalid as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttr`.\n\nBy default, this method calls \
             [`JSXAttr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_jsx_attr(&mut self, node: &JSXAttr) {
        <JSXAttr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttrName`.\n\nBy default, this method calls \
             [`JSXAttrName::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_jsx_attr_name(&mut self, node: &JSXAttrName) {
        <JSXAttrName as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttrOrSpread`.\n\nBy default, this method calls \
             [`JSXAttrOrSpread::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_jsx_attr_or_spread(&mut self, node: &JSXAttrOrSpread) {
        <JSXAttrOrSpread as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < JSXAttrOrSpread >`.\n\nBy default, this method calls \
             [`Vec < JSXAttrOrSpread >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_jsx_attr_or_spreads(&mut self, node: &[JSXAttrOrSpread]) {
        <[JSXAttrOrSpread] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttrValue`.\n\nBy default, this method calls \
             [`JSXAttrValue::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_jsx_attr_value(&mut self, node: &JSXAttrValue) {
        <JSXAttrValue as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXClosingElement`.\n\nBy default, this method calls \
             [`JSXClosingElement::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_jsx_closing_element(&mut self, node: &JSXClosingElement) {
        <JSXClosingElement as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXClosingFragment`.\n\nBy default, this method calls \
             [`JSXClosingFragment::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_jsx_closing_fragment(&mut self, node: &JSXClosingFragment) {
        <JSXClosingFragment as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXElement`.\n\nBy default, this method calls \
             [`JSXElement::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_jsx_element(&mut self, node: &JSXElement) {
        <JSXElement as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXElementChild`.\n\nBy default, this method calls \
             [`JSXElementChild::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_jsx_element_child(&mut self, node: &JSXElementChild) {
        <JSXElementChild as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < JSXElementChild >`.\n\nBy default, this method calls \
             [`Vec < JSXElementChild >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_jsx_element_childs(&mut self, node: &[JSXElementChild]) {
        <[JSXElementChild] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXElementName`.\n\nBy default, this method calls \
             [`JSXElementName::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_jsx_element_name(&mut self, node: &JSXElementName) {
        <JSXElementName as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXEmptyExpr`.\n\nBy default, this method calls \
             [`JSXEmptyExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_jsx_empty_expr(&mut self, node: &JSXEmptyExpr) {
        <JSXEmptyExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXExpr`.\n\nBy default, this method calls \
             [`JSXExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_jsx_expr(&mut self, node: &JSXExpr) {
        <JSXExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXExprContainer`.\n\nBy default, this method calls \
             [`JSXExprContainer::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_jsx_expr_container(&mut self, node: &JSXExprContainer) {
        <JSXExprContainer as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXFragment`.\n\nBy default, this method calls \
             [`JSXFragment::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_jsx_fragment(&mut self, node: &JSXFragment) {
        <JSXFragment as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXMemberExpr`.\n\nBy default, this method calls \
             [`JSXMemberExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_jsx_member_expr(&mut self, node: &JSXMemberExpr) {
        <JSXMemberExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXNamespacedName`.\n\nBy default, this method calls \
             [`JSXNamespacedName::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_jsx_namespaced_name(&mut self, node: &JSXNamespacedName) {
        <JSXNamespacedName as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXObject`.\n\nBy default, this method calls \
             [`JSXObject::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_jsx_object(&mut self, node: &JSXObject) {
        <JSXObject as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXOpeningElement`.\n\nBy default, this method calls \
             [`JSXOpeningElement::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_jsx_opening_element(&mut self, node: &JSXOpeningElement) {
        <JSXOpeningElement as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXOpeningFragment`.\n\nBy default, this method calls \
             [`JSXOpeningFragment::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_jsx_opening_fragment(&mut self, node: &JSXOpeningFragment) {
        <JSXOpeningFragment as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXSpreadChild`.\n\nBy default, this method calls \
             [`JSXSpreadChild::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_jsx_spread_child(&mut self, node: &JSXSpreadChild) {
        <JSXSpreadChild as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXText`.\n\nBy default, this method calls \
             [`JSXText::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_jsx_text(&mut self, node: &JSXText) {
        <JSXText as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Key`.\n\nBy default, this method calls \
             [`Key::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_key(&mut self, node: &Key) {
        <Key as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `KeyValuePatProp`.\n\nBy default, this method calls \
             [`KeyValuePatProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_key_value_pat_prop(&mut self, node: &KeyValuePatProp) {
        <KeyValuePatProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `KeyValueProp`.\n\nBy default, this method calls \
             [`KeyValueProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_key_value_prop(&mut self, node: &KeyValueProp) {
        <KeyValueProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `LabeledStmt`.\n\nBy default, this method calls \
             [`LabeledStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_labeled_stmt(&mut self, node: &LabeledStmt) {
        <LabeledStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Lit`.\n\nBy default, this method calls \
             [`Lit::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_lit(&mut self, node: &Lit) {
        <Lit as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `MemberExpr`.\n\nBy default, this method calls \
             [`MemberExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_member_expr(&mut self, node: &MemberExpr) {
        <MemberExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `MemberProp`.\n\nBy default, this method calls \
             [`MemberProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_member_prop(&mut self, node: &MemberProp) {
        <MemberProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `MetaPropExpr`.\n\nBy default, this method calls \
             [`MetaPropExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_meta_prop_expr(&mut self, node: &MetaPropExpr) {
        <MetaPropExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `MetaPropKind`.\n\nBy default, this method calls \
             [`MetaPropKind::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_meta_prop_kind(&mut self, node: &MetaPropKind) {
        <MetaPropKind as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `MethodKind`.\n\nBy default, this method calls \
             [`MethodKind::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_method_kind(&mut self, node: &MethodKind) {
        <MethodKind as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `MethodProp`.\n\nBy default, this method calls \
             [`MethodProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_method_prop(&mut self, node: &MethodProp) {
        <MethodProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Module`.\n\nBy default, this method calls \
             [`Module::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_module(&mut self, node: &Module) {
        <Module as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ModuleDecl`.\n\nBy default, this method calls \
             [`ModuleDecl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_module_decl(&mut self, node: &ModuleDecl) {
        <ModuleDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ModuleExportName`.\n\nBy default, this method calls \
             [`ModuleExportName::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_module_export_name(&mut self, node: &ModuleExportName) {
        <ModuleExportName as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ModuleItem`.\n\nBy default, this method calls \
             [`ModuleItem::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_module_item(&mut self, node: &ModuleItem) {
        <ModuleItem as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ModuleItem >`.\n\nBy default, this method calls [`Vec < \
             ModuleItem >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_module_items(&mut self, node: &[ModuleItem]) {
        <[ModuleItem] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `NamedExport`.\n\nBy default, this method calls \
             [`NamedExport::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_named_export(&mut self, node: &NamedExport) {
        <NamedExport as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `NewExpr`.\n\nBy default, this method calls \
             [`NewExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_new_expr(&mut self, node: &NewExpr) {
        <NewExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Null`.\n\nBy default, this method calls \
             [`Null::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_null(&mut self, node: &Null) {
        <Null as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Number`.\n\nBy default, this method calls \
             [`Number::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_number(&mut self, node: &Number) {
        <Number as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ObjectLit`.\n\nBy default, this method calls \
             [`ObjectLit::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_object_lit(&mut self, node: &ObjectLit) {
        <ObjectLit as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ObjectPat`.\n\nBy default, this method calls \
             [`ObjectPat::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_object_pat(&mut self, node: &ObjectPat) {
        <ObjectPat as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ObjectPatProp`.\n\nBy default, this method calls \
             [`ObjectPatProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_object_pat_prop(&mut self, node: &ObjectPatProp) {
        <ObjectPatProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ObjectPatProp >`.\n\nBy default, this method calls [`Vec \
             < ObjectPatProp >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_object_pat_props(&mut self, node: &[ObjectPatProp]) {
        <[ObjectPatProp] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Accessibility >`.\n\nBy default, this method calls \
             [`Option < Accessibility >::visit_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_opt_accessibility(&mut self, node: &Option<Accessibility>) {
        <Option<Accessibility> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < swc_atoms :: Atom >`.\n\nBy default, this method calls \
             [`Option < swc_atoms :: Atom >::visit_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_opt_atom(&mut self, node: &Option<swc_atoms::Atom>) {
        <Option<swc_atoms::Atom> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < BlockStmt >`.\n\nBy default, this method calls \
             [`Option < BlockStmt >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_opt_block_stmt(&mut self, node: &Option<BlockStmt>) {
        <Option<BlockStmt> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `OptCall`.\n\nBy default, this method calls \
             [`OptCall::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_opt_call(&mut self, node: &OptCall) {
        <OptCall as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < CatchClause >`.\n\nBy default, this method calls \
             [`Option < CatchClause >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_opt_catch_clause(&mut self, node: &Option<CatchClause>) {
        <Option<CatchClause> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `OptChainBase`.\n\nBy default, this method calls \
             [`OptChainBase::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_opt_chain_base(&mut self, node: &OptChainBase) {
        <OptChainBase as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `OptChainExpr`.\n\nBy default, this method calls \
             [`OptChainExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_opt_chain_expr(&mut self, node: &OptChainExpr) {
        <OptChainExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < Expr > >`.\n\nBy default, this method calls \
             [`Option < Box < Expr > >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_opt_expr(&mut self, node: &Option<Box<Expr>>) {
        <Option<Box<Expr>> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < ExprOrSpread >`.\n\nBy default, this method calls \
             [`Option < ExprOrSpread >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_opt_expr_or_spread(&mut self, node: &Option<ExprOrSpread>) {
        <Option<ExprOrSpread> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Vec < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Option < Vec < ExprOrSpread > >::visit_children_with`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_opt_expr_or_spreads(&mut self, node: &Option<Vec<ExprOrSpread>>) {
        <Option<Vec<ExprOrSpread>> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Ident >`.\n\nBy default, this method calls [`Option < \
             Ident >::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_opt_ident(&mut self, node: &Option<Ident>) {
        <Option<Ident> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < JSXAttrValue >`.\n\nBy default, this method calls \
             [`Option < JSXAttrValue >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_opt_jsx_attr_value(&mut self, node: &Option<JSXAttrValue>) {
        <Option<JSXAttrValue> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < JSXClosingElement >`.\n\nBy default, this method calls \
             [`Option < JSXClosingElement >::visit_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_opt_jsx_closing_element(&mut self, node: &Option<JSXClosingElement>) {
        <Option<JSXClosingElement> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < ModuleExportName >`.\n\nBy default, this method calls \
             [`Option < ModuleExportName >::visit_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_opt_module_export_name(&mut self, node: &Option<ModuleExportName>) {
        <Option<ModuleExportName> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Vec < ModuleItem > >`.\n\nBy default, this method \
             calls [`Option < Vec < ModuleItem > >::visit_children_with`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_opt_module_items(&mut self, node: &Option<Vec<ModuleItem>>) {
        <Option<Vec<ModuleItem>> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < ObjectLit > >`.\n\nBy default, this method calls \
             [`Option < Box < ObjectLit > >::visit_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_opt_object_lit(&mut self, node: &Option<Box<ObjectLit>>) {
        <Option<Box<ObjectLit>> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Pat >`.\n\nBy default, this method calls [`Option < \
             Pat >::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_opt_pat(&mut self, node: &Option<Pat>) {
        <Option<Pat> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < swc_common :: Span >`.\n\nBy default, this method \
             calls [`Option < swc_common :: Span >::visit_children_with`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_opt_span(&mut self, node: &Option<swc_common::Span>) {
        <Option<swc_common::Span> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < Stmt > >`.\n\nBy default, this method calls \
             [`Option < Box < Stmt > >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_opt_stmt(&mut self, node: &Option<Box<Stmt>>) {
        <Option<Box<Stmt>> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < Str > >`.\n\nBy default, this method calls \
             [`Option < Box < Str > >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_opt_str(&mut self, node: &Option<Box<Str>>) {
        <Option<Box<Str>> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < TruePlusMinus >`.\n\nBy default, this method calls \
             [`Option < TruePlusMinus >::visit_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_opt_true_plus_minus(&mut self, node: &Option<TruePlusMinus>) {
        <Option<TruePlusMinus> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < TsEntityName >`.\n\nBy default, this method calls \
             [`Option < TsEntityName >::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_opt_ts_entity_name(&mut self, node: &Option<TsEntityName>) {
        <Option<TsEntityName> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < TsNamespaceBody >`.\n\nBy default, this method calls \
             [`Option < TsNamespaceBody >::visit_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_opt_ts_namespace_body(&mut self, node: &Option<TsNamespaceBody>) {
        <Option<TsNamespaceBody> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < TsType > >`.\n\nBy default, this method calls \
             [`Option < Box < TsType > >::visit_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_opt_ts_type(&mut self, node: &Option<Box<TsType>>) {
        <Option<Box<TsType>> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < TsTypeAnn > >`.\n\nBy default, this method calls \
             [`Option < Box < TsTypeAnn > >::visit_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_opt_ts_type_ann(&mut self, node: &Option<Box<TsTypeAnn>>) {
        <Option<Box<TsTypeAnn>> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < TsTypeParamDecl > >`.\n\nBy default, this method \
             calls [`Option < Box < TsTypeParamDecl > >::visit_children_with`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_opt_ts_type_param_decl(&mut self, node: &Option<Box<TsTypeParamDecl>>) {
        <Option<Box<TsTypeParamDecl>> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < TsTypeParamInstantiation > >`.\n\nBy default, \
             this method calls [`Option < Box < TsTypeParamInstantiation > \
             >::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_opt_ts_type_param_instantiation(
        &mut self,
        node: &Option<Box<TsTypeParamInstantiation>>,
    ) {
        <Option<Box<TsTypeParamInstantiation>> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < VarDeclOrExpr >`.\n\nBy default, this method calls \
             [`Option < VarDeclOrExpr >::visit_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_opt_var_decl_or_expr(&mut self, node: &Option<VarDeclOrExpr>) {
        <Option<VarDeclOrExpr> as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Option < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Vec < Option < ExprOrSpread > >::visit_children_with`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_opt_vec_expr_or_spreads(&mut self, node: &[Option<ExprOrSpread>]) {
        <[Option<ExprOrSpread>] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Option < Pat > >`.\n\nBy default, this method calls [`Vec \
             < Option < Pat > >::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_opt_vec_pats(&mut self, node: &[Option<Pat>]) {
        <[Option<Pat>] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Param`.\n\nBy default, this method calls \
             [`Param::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_param(&mut self, node: &Param) {
        <Param as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ParamOrTsParamProp`.\n\nBy default, this method calls \
             [`ParamOrTsParamProp::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_param_or_ts_param_prop(&mut self, node: &ParamOrTsParamProp) {
        <ParamOrTsParamProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ParamOrTsParamProp >`.\n\nBy default, this method calls \
             [`Vec < ParamOrTsParamProp >::visit_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_param_or_ts_param_props(&mut self, node: &[ParamOrTsParamProp]) {
        <[ParamOrTsParamProp] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Param >`.\n\nBy default, this method calls [`Vec < Param \
             >::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_params(&mut self, node: &[Param]) {
        <[Param] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ParenExpr`.\n\nBy default, this method calls \
             [`ParenExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_paren_expr(&mut self, node: &ParenExpr) {
        <ParenExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Pat`.\n\nBy default, this method calls \
             [`Pat::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_pat(&mut self, node: &Pat) {
        <Pat as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Pat >`.\n\nBy default, this method calls [`Vec < Pat \
             >::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_pats(&mut self, node: &[Pat]) {
        <[Pat] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `PrivateMethod`.\n\nBy default, this method calls \
             [`PrivateMethod::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_private_method(&mut self, node: &PrivateMethod) {
        <PrivateMethod as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `PrivateName`.\n\nBy default, this method calls \
             [`PrivateName::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_private_name(&mut self, node: &PrivateName) {
        <PrivateName as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `PrivateProp`.\n\nBy default, this method calls \
             [`PrivateProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_private_prop(&mut self, node: &PrivateProp) {
        <PrivateProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Program`.\n\nBy default, this method calls \
             [`Program::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_program(&mut self, node: &Program) {
        <Program as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Prop`.\n\nBy default, this method calls \
             [`Prop::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_prop(&mut self, node: &Prop) {
        <Prop as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `PropName`.\n\nBy default, this method calls \
             [`PropName::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_prop_name(&mut self, node: &PropName) {
        <PropName as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `PropOrSpread`.\n\nBy default, this method calls \
             [`PropOrSpread::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_prop_or_spread(&mut self, node: &PropOrSpread) {
        <PropOrSpread as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < PropOrSpread >`.\n\nBy default, this method calls [`Vec < \
             PropOrSpread >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_prop_or_spreads(&mut self, node: &[PropOrSpread]) {
        <[PropOrSpread] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Regex`.\n\nBy default, this method calls \
             [`Regex::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_regex(&mut self, node: &Regex) {
        <Regex as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ReservedUnused`.\n\nBy default, this method calls \
             [`ReservedUnused::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_reserved_unused(&mut self, node: &ReservedUnused) {
        <ReservedUnused as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `RestPat`.\n\nBy default, this method calls \
             [`RestPat::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_rest_pat(&mut self, node: &RestPat) {
        <RestPat as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ReturnStmt`.\n\nBy default, this method calls \
             [`ReturnStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_return_stmt(&mut self, node: &ReturnStmt) {
        <ReturnStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Script`.\n\nBy default, this method calls \
             [`Script::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_script(&mut self, node: &Script) {
        <Script as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `SeqExpr`.\n\nBy default, this method calls \
             [`SeqExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_seq_expr(&mut self, node: &SeqExpr) {
        <SeqExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `SetterProp`.\n\nBy default, this method calls \
             [`SetterProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_setter_prop(&mut self, node: &SetterProp) {
        <SetterProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `SimpleAssignTarget`.\n\nBy default, this method calls \
             [`SimpleAssignTarget::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_simple_assign_target(&mut self, node: &SimpleAssignTarget) {
        <SimpleAssignTarget as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_common :: Span`.\n\nBy default, this method calls \
             [`swc_common :: Span::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_span(&mut self, node: &swc_common::Span) {
        <swc_common::Span as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `SpreadElement`.\n\nBy default, this method calls \
             [`SpreadElement::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_spread_element(&mut self, node: &SpreadElement) {
        <SpreadElement as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `StaticBlock`.\n\nBy default, this method calls \
             [`StaticBlock::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_static_block(&mut self, node: &StaticBlock) {
        <StaticBlock as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Stmt`.\n\nBy default, this method calls \
             [`Stmt::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_stmt(&mut self, node: &Stmt) {
        <Stmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Stmt >`.\n\nBy default, this method calls [`Vec < Stmt \
             >::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_stmts(&mut self, node: &[Stmt]) {
        <[Stmt] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Str`.\n\nBy default, this method calls \
             [`Str::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_str(&mut self, node: &Str) {
        <Str as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Super`.\n\nBy default, this method calls \
             [`Super::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_super(&mut self, node: &Super) {
        <Super as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `SuperProp`.\n\nBy default, this method calls \
             [`SuperProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_super_prop(&mut self, node: &SuperProp) {
        <SuperProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `SuperPropExpr`.\n\nBy default, this method calls \
             [`SuperPropExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_super_prop_expr(&mut self, node: &SuperPropExpr) {
        <SuperPropExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `SwitchCase`.\n\nBy default, this method calls \
             [`SwitchCase::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_switch_case(&mut self, node: &SwitchCase) {
        <SwitchCase as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < SwitchCase >`.\n\nBy default, this method calls [`Vec < \
             SwitchCase >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_switch_cases(&mut self, node: &[SwitchCase]) {
        <[SwitchCase] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `SwitchStmt`.\n\nBy default, this method calls \
             [`SwitchStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_switch_stmt(&mut self, node: &SwitchStmt) {
        <SwitchStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_common :: SyntaxContext`.\n\nBy default, this method calls \
             [`swc_common :: SyntaxContext::visit_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_syntax_context(&mut self, node: &swc_common::SyntaxContext) {
        <swc_common::SyntaxContext as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TaggedTpl`.\n\nBy default, this method calls \
             [`TaggedTpl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_tagged_tpl(&mut self, node: &TaggedTpl) {
        <TaggedTpl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ThisExpr`.\n\nBy default, this method calls \
             [`ThisExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_this_expr(&mut self, node: &ThisExpr) {
        <ThisExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `ThrowStmt`.\n\nBy default, this method calls \
             [`ThrowStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_throw_stmt(&mut self, node: &ThrowStmt) {
        <ThrowStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Tpl`.\n\nBy default, this method calls \
             [`Tpl::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_tpl(&mut self, node: &Tpl) {
        <Tpl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TplElement`.\n\nBy default, this method calls \
             [`TplElement::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_tpl_element(&mut self, node: &TplElement) {
        <TplElement as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TplElement >`.\n\nBy default, this method calls [`Vec < \
             TplElement >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_tpl_elements(&mut self, node: &[TplElement]) {
        <[TplElement] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TruePlusMinus`.\n\nBy default, this method calls \
             [`TruePlusMinus::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_true_plus_minus(&mut self, node: &TruePlusMinus) {
        <TruePlusMinus as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TryStmt`.\n\nBy default, this method calls \
             [`TryStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_try_stmt(&mut self, node: &TryStmt) {
        <TryStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsArrayType`.\n\nBy default, this method calls \
             [`TsArrayType::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_array_type(&mut self, node: &TsArrayType) {
        <TsArrayType as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsAsExpr`.\n\nBy default, this method calls \
             [`TsAsExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_as_expr(&mut self, node: &TsAsExpr) {
        <TsAsExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsCallSignatureDecl`.\n\nBy default, this method calls \
             [`TsCallSignatureDecl::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_call_signature_decl(&mut self, node: &TsCallSignatureDecl) {
        <TsCallSignatureDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsConditionalType`.\n\nBy default, this method calls \
             [`TsConditionalType::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_conditional_type(&mut self, node: &TsConditionalType) {
        <TsConditionalType as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsConstAssertion`.\n\nBy default, this method calls \
             [`TsConstAssertion::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_const_assertion(&mut self, node: &TsConstAssertion) {
        <TsConstAssertion as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsConstructSignatureDecl`.\n\nBy default, this method calls \
             [`TsConstructSignatureDecl::visit_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_construct_signature_decl(&mut self, node: &TsConstructSignatureDecl) {
        <TsConstructSignatureDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsConstructorType`.\n\nBy default, this method calls \
             [`TsConstructorType::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_constructor_type(&mut self, node: &TsConstructorType) {
        <TsConstructorType as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsEntityName`.\n\nBy default, this method calls \
             [`TsEntityName::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_entity_name(&mut self, node: &TsEntityName) {
        <TsEntityName as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsEnumDecl`.\n\nBy default, this method calls \
             [`TsEnumDecl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_enum_decl(&mut self, node: &TsEnumDecl) {
        <TsEnumDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsEnumMember`.\n\nBy default, this method calls \
             [`TsEnumMember::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_enum_member(&mut self, node: &TsEnumMember) {
        <TsEnumMember as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsEnumMemberId`.\n\nBy default, this method calls \
             [`TsEnumMemberId::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_enum_member_id(&mut self, node: &TsEnumMemberId) {
        <TsEnumMemberId as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TsEnumMember >`.\n\nBy default, this method calls [`Vec < \
             TsEnumMember >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_enum_members(&mut self, node: &[TsEnumMember]) {
        <[TsEnumMember] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsExportAssignment`.\n\nBy default, this method calls \
             [`TsExportAssignment::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_export_assignment(&mut self, node: &TsExportAssignment) {
        <TsExportAssignment as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsExprWithTypeArgs`.\n\nBy default, this method calls \
             [`TsExprWithTypeArgs::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_expr_with_type_args(&mut self, node: &TsExprWithTypeArgs) {
        <TsExprWithTypeArgs as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TsExprWithTypeArgs >`.\n\nBy default, this method calls \
             [`Vec < TsExprWithTypeArgs >::visit_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_expr_with_type_argss(&mut self, node: &[TsExprWithTypeArgs]) {
        <[TsExprWithTypeArgs] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsExternalModuleRef`.\n\nBy default, this method calls \
             [`TsExternalModuleRef::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_external_module_ref(&mut self, node: &TsExternalModuleRef) {
        <TsExternalModuleRef as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsFnOrConstructorType`.\n\nBy default, this method calls \
             [`TsFnOrConstructorType::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_fn_or_constructor_type(&mut self, node: &TsFnOrConstructorType) {
        <TsFnOrConstructorType as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsFnParam`.\n\nBy default, this method calls \
             [`TsFnParam::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_fn_param(&mut self, node: &TsFnParam) {
        <TsFnParam as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TsFnParam >`.\n\nBy default, this method calls [`Vec < \
             TsFnParam >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_fn_params(&mut self, node: &[TsFnParam]) {
        <[TsFnParam] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsFnType`.\n\nBy default, this method calls \
             [`TsFnType::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_fn_type(&mut self, node: &TsFnType) {
        <TsFnType as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsGetterSignature`.\n\nBy default, this method calls \
             [`TsGetterSignature::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_getter_signature(&mut self, node: &TsGetterSignature) {
        <TsGetterSignature as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsImportEqualsDecl`.\n\nBy default, this method calls \
             [`TsImportEqualsDecl::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_import_equals_decl(&mut self, node: &TsImportEqualsDecl) {
        <TsImportEqualsDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsImportType`.\n\nBy default, this method calls \
             [`TsImportType::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_import_type(&mut self, node: &TsImportType) {
        <TsImportType as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsIndexSignature`.\n\nBy default, this method calls \
             [`TsIndexSignature::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_index_signature(&mut self, node: &TsIndexSignature) {
        <TsIndexSignature as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsIndexedAccessType`.\n\nBy default, this method calls \
             [`TsIndexedAccessType::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_indexed_access_type(&mut self, node: &TsIndexedAccessType) {
        <TsIndexedAccessType as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsInferType`.\n\nBy default, this method calls \
             [`TsInferType::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_infer_type(&mut self, node: &TsInferType) {
        <TsInferType as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsInstantiation`.\n\nBy default, this method calls \
             [`TsInstantiation::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_instantiation(&mut self, node: &TsInstantiation) {
        <TsInstantiation as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsInterfaceBody`.\n\nBy default, this method calls \
             [`TsInterfaceBody::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_interface_body(&mut self, node: &TsInterfaceBody) {
        <TsInterfaceBody as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsInterfaceDecl`.\n\nBy default, this method calls \
             [`TsInterfaceDecl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_interface_decl(&mut self, node: &TsInterfaceDecl) {
        <TsInterfaceDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsIntersectionType`.\n\nBy default, this method calls \
             [`TsIntersectionType::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_intersection_type(&mut self, node: &TsIntersectionType) {
        <TsIntersectionType as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsKeywordType`.\n\nBy default, this method calls \
             [`TsKeywordType::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_keyword_type(&mut self, node: &TsKeywordType) {
        <TsKeywordType as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsKeywordTypeKind`.\n\nBy default, this method calls \
             [`TsKeywordTypeKind::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_keyword_type_kind(&mut self, node: &TsKeywordTypeKind) {
        <TsKeywordTypeKind as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsLit`.\n\nBy default, this method calls \
             [`TsLit::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_ts_lit(&mut self, node: &TsLit) {
        <TsLit as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsLitType`.\n\nBy default, this method calls \
             [`TsLitType::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_lit_type(&mut self, node: &TsLitType) {
        <TsLitType as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsMappedType`.\n\nBy default, this method calls \
             [`TsMappedType::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_mapped_type(&mut self, node: &TsMappedType) {
        <TsMappedType as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsMethodSignature`.\n\nBy default, this method calls \
             [`TsMethodSignature::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_method_signature(&mut self, node: &TsMethodSignature) {
        <TsMethodSignature as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsModuleBlock`.\n\nBy default, this method calls \
             [`TsModuleBlock::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_module_block(&mut self, node: &TsModuleBlock) {
        <TsModuleBlock as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsModuleDecl`.\n\nBy default, this method calls \
             [`TsModuleDecl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_module_decl(&mut self, node: &TsModuleDecl) {
        <TsModuleDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsModuleName`.\n\nBy default, this method calls \
             [`TsModuleName::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_module_name(&mut self, node: &TsModuleName) {
        <TsModuleName as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsModuleRef`.\n\nBy default, this method calls \
             [`TsModuleRef::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_module_ref(&mut self, node: &TsModuleRef) {
        <TsModuleRef as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsNamespaceBody`.\n\nBy default, this method calls \
             [`TsNamespaceBody::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_namespace_body(&mut self, node: &TsNamespaceBody) {
        <TsNamespaceBody as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsNamespaceDecl`.\n\nBy default, this method calls \
             [`TsNamespaceDecl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_namespace_decl(&mut self, node: &TsNamespaceDecl) {
        <TsNamespaceDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsNamespaceExportDecl`.\n\nBy default, this method calls \
             [`TsNamespaceExportDecl::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_namespace_export_decl(&mut self, node: &TsNamespaceExportDecl) {
        <TsNamespaceExportDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsNonNullExpr`.\n\nBy default, this method calls \
             [`TsNonNullExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_non_null_expr(&mut self, node: &TsNonNullExpr) {
        <TsNonNullExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsOptionalType`.\n\nBy default, this method calls \
             [`TsOptionalType::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_optional_type(&mut self, node: &TsOptionalType) {
        <TsOptionalType as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsParamProp`.\n\nBy default, this method calls \
             [`TsParamProp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_param_prop(&mut self, node: &TsParamProp) {
        <TsParamProp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsParamPropParam`.\n\nBy default, this method calls \
             [`TsParamPropParam::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_param_prop_param(&mut self, node: &TsParamPropParam) {
        <TsParamPropParam as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsParenthesizedType`.\n\nBy default, this method calls \
             [`TsParenthesizedType::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_parenthesized_type(&mut self, node: &TsParenthesizedType) {
        <TsParenthesizedType as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsPropertySignature`.\n\nBy default, this method calls \
             [`TsPropertySignature::visit_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_property_signature(&mut self, node: &TsPropertySignature) {
        <TsPropertySignature as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsQualifiedName`.\n\nBy default, this method calls \
             [`TsQualifiedName::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_qualified_name(&mut self, node: &TsQualifiedName) {
        <TsQualifiedName as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsRestType`.\n\nBy default, this method calls \
             [`TsRestType::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_rest_type(&mut self, node: &TsRestType) {
        <TsRestType as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsSatisfiesExpr`.\n\nBy default, this method calls \
             [`TsSatisfiesExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_satisfies_expr(&mut self, node: &TsSatisfiesExpr) {
        <TsSatisfiesExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsSetterSignature`.\n\nBy default, this method calls \
             [`TsSetterSignature::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_setter_signature(&mut self, node: &TsSetterSignature) {
        <TsSetterSignature as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsThisType`.\n\nBy default, this method calls \
             [`TsThisType::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_this_type(&mut self, node: &TsThisType) {
        <TsThisType as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsThisTypeOrIdent`.\n\nBy default, this method calls \
             [`TsThisTypeOrIdent::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_this_type_or_ident(&mut self, node: &TsThisTypeOrIdent) {
        <TsThisTypeOrIdent as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTplLitType`.\n\nBy default, this method calls \
             [`TsTplLitType::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_tpl_lit_type(&mut self, node: &TsTplLitType) {
        <TsTplLitType as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTupleElement`.\n\nBy default, this method calls \
             [`TsTupleElement::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_tuple_element(&mut self, node: &TsTupleElement) {
        <TsTupleElement as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TsTupleElement >`.\n\nBy default, this method calls [`Vec \
             < TsTupleElement >::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_tuple_elements(&mut self, node: &[TsTupleElement]) {
        <[TsTupleElement] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTupleType`.\n\nBy default, this method calls \
             [`TsTupleType::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_tuple_type(&mut self, node: &TsTupleType) {
        <TsTupleType as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsType`.\n\nBy default, this method calls \
             [`TsType::visit_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_ts_type(&mut self, node: &TsType) {
        <TsType as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeAliasDecl`.\n\nBy default, this method calls \
             [`TsTypeAliasDecl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_type_alias_decl(&mut self, node: &TsTypeAliasDecl) {
        <TsTypeAliasDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeAnn`.\n\nBy default, this method calls \
             [`TsTypeAnn::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_type_ann(&mut self, node: &TsTypeAnn) {
        <TsTypeAnn as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeAssertion`.\n\nBy default, this method calls \
             [`TsTypeAssertion::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_type_assertion(&mut self, node: &TsTypeAssertion) {
        <TsTypeAssertion as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeElement`.\n\nBy default, this method calls \
             [`TsTypeElement::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_type_element(&mut self, node: &TsTypeElement) {
        <TsTypeElement as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TsTypeElement >`.\n\nBy default, this method calls [`Vec \
             < TsTypeElement >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_type_elements(&mut self, node: &[TsTypeElement]) {
        <[TsTypeElement] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeLit`.\n\nBy default, this method calls \
             [`TsTypeLit::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_type_lit(&mut self, node: &TsTypeLit) {
        <TsTypeLit as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeOperator`.\n\nBy default, this method calls \
             [`TsTypeOperator::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_type_operator(&mut self, node: &TsTypeOperator) {
        <TsTypeOperator as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeOperatorOp`.\n\nBy default, this method calls \
             [`TsTypeOperatorOp::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_type_operator_op(&mut self, node: &TsTypeOperatorOp) {
        <TsTypeOperatorOp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeParam`.\n\nBy default, this method calls \
             [`TsTypeParam::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_type_param(&mut self, node: &TsTypeParam) {
        <TsTypeParam as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeParamDecl`.\n\nBy default, this method calls \
             [`TsTypeParamDecl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_type_param_decl(&mut self, node: &TsTypeParamDecl) {
        <TsTypeParamDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeParamInstantiation`.\n\nBy default, this method calls \
             [`TsTypeParamInstantiation::visit_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_type_param_instantiation(&mut self, node: &TsTypeParamInstantiation) {
        <TsTypeParamInstantiation as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TsTypeParam >`.\n\nBy default, this method calls [`Vec < \
             TsTypeParam >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_type_params(&mut self, node: &[TsTypeParam]) {
        <[TsTypeParam] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypePredicate`.\n\nBy default, this method calls \
             [`TsTypePredicate::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_type_predicate(&mut self, node: &TsTypePredicate) {
        <TsTypePredicate as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeQuery`.\n\nBy default, this method calls \
             [`TsTypeQuery::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_type_query(&mut self, node: &TsTypeQuery) {
        <TsTypeQuery as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeQueryExpr`.\n\nBy default, this method calls \
             [`TsTypeQueryExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_type_query_expr(&mut self, node: &TsTypeQueryExpr) {
        <TsTypeQueryExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeRef`.\n\nBy default, this method calls \
             [`TsTypeRef::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_type_ref(&mut self, node: &TsTypeRef) {
        <TsTypeRef as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Box < TsType > >`.\n\nBy default, this method calls [`Vec \
             < Box < TsType > >::visit_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_types(&mut self, node: &[Box<TsType>]) {
        <[Box<TsType>] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsUnionOrIntersectionType`.\n\nBy default, this method calls \
             [`TsUnionOrIntersectionType::visit_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_union_or_intersection_type(&mut self, node: &TsUnionOrIntersectionType) {
        <TsUnionOrIntersectionType as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsUnionType`.\n\nBy default, this method calls \
             [`TsUnionType::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_union_type(&mut self, node: &TsUnionType) {
        <TsUnionType as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `UnaryExpr`.\n\nBy default, this method calls \
             [`UnaryExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_unary_expr(&mut self, node: &UnaryExpr) {
        <UnaryExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `UnaryOp`.\n\nBy default, this method calls \
             [`UnaryOp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_unary_op(&mut self, node: &UnaryOp) {
        <UnaryOp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `UpdateExpr`.\n\nBy default, this method calls \
             [`UpdateExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_update_expr(&mut self, node: &UpdateExpr) {
        <UpdateExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `UpdateOp`.\n\nBy default, this method calls \
             [`UpdateOp::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_update_op(&mut self, node: &UpdateOp) {
        <UpdateOp as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `UsingDecl`.\n\nBy default, this method calls \
             [`UsingDecl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_using_decl(&mut self, node: &UsingDecl) {
        <UsingDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDecl`.\n\nBy default, this method calls \
             [`VarDecl::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_var_decl(&mut self, node: &VarDecl) {
        <VarDecl as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDeclKind`.\n\nBy default, this method calls \
             [`VarDeclKind::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_var_decl_kind(&mut self, node: &VarDeclKind) {
        <VarDeclKind as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDeclOrExpr`.\n\nBy default, this method calls \
             [`VarDeclOrExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_var_decl_or_expr(&mut self, node: &VarDeclOrExpr) {
        <VarDeclOrExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDeclarator`.\n\nBy default, this method calls \
             [`VarDeclarator::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_var_declarator(&mut self, node: &VarDeclarator) {
        <VarDeclarator as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < VarDeclarator >`.\n\nBy default, this method calls [`Vec \
             < VarDeclarator >::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_var_declarators(&mut self, node: &[VarDeclarator]) {
        <[VarDeclarator] as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `WhileStmt`.\n\nBy default, this method calls \
             [`WhileStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_while_stmt(&mut self, node: &WhileStmt) {
        <WhileStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `WithStmt`.\n\nBy default, this method calls \
             [`WithStmt::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_with_stmt(&mut self, node: &WithStmt) {
        <WithStmt as VisitWith<Self>>::visit_children_with(node, self)
    }
    #[doc = "Visit a node of type `YieldExpr`.\n\nBy default, this method calls \
             [`YieldExpr::visit_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_yield_expr(&mut self, node: &YieldExpr) {
        <YieldExpr as VisitWith<Self>>::visit_children_with(node, self)
    }
}
impl<V> Visit for &mut V
where
    V: ?Sized + Visit,
{
    fn visit_accessibility(&mut self, node: &Accessibility) {
        Visit::visit_accessibility(&mut **self, node)
    }

    fn visit_array_lit(&mut self, node: &ArrayLit) {
        Visit::visit_array_lit(&mut **self, node)
    }

    fn visit_array_pat(&mut self, node: &ArrayPat) {
        Visit::visit_array_pat(&mut **self, node)
    }

    fn visit_arrow_expr(&mut self, node: &ArrowExpr) {
        Visit::visit_arrow_expr(&mut **self, node)
    }

    fn visit_assign_expr(&mut self, node: &AssignExpr) {
        Visit::visit_assign_expr(&mut **self, node)
    }

    fn visit_assign_op(&mut self, node: &AssignOp) {
        Visit::visit_assign_op(&mut **self, node)
    }

    fn visit_assign_pat(&mut self, node: &AssignPat) {
        Visit::visit_assign_pat(&mut **self, node)
    }

    fn visit_assign_pat_prop(&mut self, node: &AssignPatProp) {
        Visit::visit_assign_pat_prop(&mut **self, node)
    }

    fn visit_assign_prop(&mut self, node: &AssignProp) {
        Visit::visit_assign_prop(&mut **self, node)
    }

    fn visit_assign_target(&mut self, node: &AssignTarget) {
        Visit::visit_assign_target(&mut **self, node)
    }

    fn visit_assign_target_pat(&mut self, node: &AssignTargetPat) {
        Visit::visit_assign_target_pat(&mut **self, node)
    }

    fn visit_atom(&mut self, node: &swc_atoms::Atom) {
        Visit::visit_atom(&mut **self, node)
    }

    fn visit_auto_accessor(&mut self, node: &AutoAccessor) {
        Visit::visit_auto_accessor(&mut **self, node)
    }

    fn visit_await_expr(&mut self, node: &AwaitExpr) {
        Visit::visit_await_expr(&mut **self, node)
    }

    fn visit_big_int(&mut self, node: &BigInt) {
        Visit::visit_big_int(&mut **self, node)
    }

    fn visit_big_int_value(&mut self, node: &BigIntValue) {
        Visit::visit_big_int_value(&mut **self, node)
    }

    fn visit_bin_expr(&mut self, node: &BinExpr) {
        Visit::visit_bin_expr(&mut **self, node)
    }

    fn visit_binary_op(&mut self, node: &BinaryOp) {
        Visit::visit_binary_op(&mut **self, node)
    }

    fn visit_binding_ident(&mut self, node: &BindingIdent) {
        Visit::visit_binding_ident(&mut **self, node)
    }

    fn visit_block_stmt(&mut self, node: &BlockStmt) {
        Visit::visit_block_stmt(&mut **self, node)
    }

    fn visit_block_stmt_or_expr(&mut self, node: &BlockStmtOrExpr) {
        Visit::visit_block_stmt_or_expr(&mut **self, node)
    }

    fn visit_bool(&mut self, node: &Bool) {
        Visit::visit_bool(&mut **self, node)
    }

    fn visit_break_stmt(&mut self, node: &BreakStmt) {
        Visit::visit_break_stmt(&mut **self, node)
    }

    fn visit_call_expr(&mut self, node: &CallExpr) {
        Visit::visit_call_expr(&mut **self, node)
    }

    fn visit_callee(&mut self, node: &Callee) {
        Visit::visit_callee(&mut **self, node)
    }

    fn visit_catch_clause(&mut self, node: &CatchClause) {
        Visit::visit_catch_clause(&mut **self, node)
    }

    fn visit_class(&mut self, node: &Class) {
        Visit::visit_class(&mut **self, node)
    }

    fn visit_class_decl(&mut self, node: &ClassDecl) {
        Visit::visit_class_decl(&mut **self, node)
    }

    fn visit_class_expr(&mut self, node: &ClassExpr) {
        Visit::visit_class_expr(&mut **self, node)
    }

    fn visit_class_member(&mut self, node: &ClassMember) {
        Visit::visit_class_member(&mut **self, node)
    }

    fn visit_class_members(&mut self, node: &[ClassMember]) {
        Visit::visit_class_members(&mut **self, node)
    }

    fn visit_class_method(&mut self, node: &ClassMethod) {
        Visit::visit_class_method(&mut **self, node)
    }

    fn visit_class_prop(&mut self, node: &ClassProp) {
        Visit::visit_class_prop(&mut **self, node)
    }

    fn visit_computed_prop_name(&mut self, node: &ComputedPropName) {
        Visit::visit_computed_prop_name(&mut **self, node)
    }

    fn visit_cond_expr(&mut self, node: &CondExpr) {
        Visit::visit_cond_expr(&mut **self, node)
    }

    fn visit_constructor(&mut self, node: &Constructor) {
        Visit::visit_constructor(&mut **self, node)
    }

    fn visit_continue_stmt(&mut self, node: &ContinueStmt) {
        Visit::visit_continue_stmt(&mut **self, node)
    }

    fn visit_debugger_stmt(&mut self, node: &DebuggerStmt) {
        Visit::visit_debugger_stmt(&mut **self, node)
    }

    fn visit_decl(&mut self, node: &Decl) {
        Visit::visit_decl(&mut **self, node)
    }

    fn visit_decorator(&mut self, node: &Decorator) {
        Visit::visit_decorator(&mut **self, node)
    }

    fn visit_decorators(&mut self, node: &[Decorator]) {
        Visit::visit_decorators(&mut **self, node)
    }

    fn visit_default_decl(&mut self, node: &DefaultDecl) {
        Visit::visit_default_decl(&mut **self, node)
    }

    fn visit_do_while_stmt(&mut self, node: &DoWhileStmt) {
        Visit::visit_do_while_stmt(&mut **self, node)
    }

    fn visit_empty_stmt(&mut self, node: &EmptyStmt) {
        Visit::visit_empty_stmt(&mut **self, node)
    }

    fn visit_es_version(&mut self, node: &EsVersion) {
        Visit::visit_es_version(&mut **self, node)
    }

    fn visit_export_all(&mut self, node: &ExportAll) {
        Visit::visit_export_all(&mut **self, node)
    }

    fn visit_export_decl(&mut self, node: &ExportDecl) {
        Visit::visit_export_decl(&mut **self, node)
    }

    fn visit_export_default_decl(&mut self, node: &ExportDefaultDecl) {
        Visit::visit_export_default_decl(&mut **self, node)
    }

    fn visit_export_default_expr(&mut self, node: &ExportDefaultExpr) {
        Visit::visit_export_default_expr(&mut **self, node)
    }

    fn visit_export_default_specifier(&mut self, node: &ExportDefaultSpecifier) {
        Visit::visit_export_default_specifier(&mut **self, node)
    }

    fn visit_export_named_specifier(&mut self, node: &ExportNamedSpecifier) {
        Visit::visit_export_named_specifier(&mut **self, node)
    }

    fn visit_export_namespace_specifier(&mut self, node: &ExportNamespaceSpecifier) {
        Visit::visit_export_namespace_specifier(&mut **self, node)
    }

    fn visit_export_specifier(&mut self, node: &ExportSpecifier) {
        Visit::visit_export_specifier(&mut **self, node)
    }

    fn visit_export_specifiers(&mut self, node: &[ExportSpecifier]) {
        Visit::visit_export_specifiers(&mut **self, node)
    }

    fn visit_expr(&mut self, node: &Expr) {
        Visit::visit_expr(&mut **self, node)
    }

    fn visit_expr_or_spread(&mut self, node: &ExprOrSpread) {
        Visit::visit_expr_or_spread(&mut **self, node)
    }

    fn visit_expr_or_spreads(&mut self, node: &[ExprOrSpread]) {
        Visit::visit_expr_or_spreads(&mut **self, node)
    }

    fn visit_expr_stmt(&mut self, node: &ExprStmt) {
        Visit::visit_expr_stmt(&mut **self, node)
    }

    fn visit_exprs(&mut self, node: &[Box<Expr>]) {
        Visit::visit_exprs(&mut **self, node)
    }

    fn visit_fn_decl(&mut self, node: &FnDecl) {
        Visit::visit_fn_decl(&mut **self, node)
    }

    fn visit_fn_expr(&mut self, node: &FnExpr) {
        Visit::visit_fn_expr(&mut **self, node)
    }

    fn visit_for_head(&mut self, node: &ForHead) {
        Visit::visit_for_head(&mut **self, node)
    }

    fn visit_for_in_stmt(&mut self, node: &ForInStmt) {
        Visit::visit_for_in_stmt(&mut **self, node)
    }

    fn visit_for_of_stmt(&mut self, node: &ForOfStmt) {
        Visit::visit_for_of_stmt(&mut **self, node)
    }

    fn visit_for_stmt(&mut self, node: &ForStmt) {
        Visit::visit_for_stmt(&mut **self, node)
    }

    fn visit_function(&mut self, node: &Function) {
        Visit::visit_function(&mut **self, node)
    }

    fn visit_getter_prop(&mut self, node: &GetterProp) {
        Visit::visit_getter_prop(&mut **self, node)
    }

    fn visit_ident(&mut self, node: &Ident) {
        Visit::visit_ident(&mut **self, node)
    }

    fn visit_ident_name(&mut self, node: &IdentName) {
        Visit::visit_ident_name(&mut **self, node)
    }

    fn visit_if_stmt(&mut self, node: &IfStmt) {
        Visit::visit_if_stmt(&mut **self, node)
    }

    fn visit_import(&mut self, node: &Import) {
        Visit::visit_import(&mut **self, node)
    }

    fn visit_import_decl(&mut self, node: &ImportDecl) {
        Visit::visit_import_decl(&mut **self, node)
    }

    fn visit_import_default_specifier(&mut self, node: &ImportDefaultSpecifier) {
        Visit::visit_import_default_specifier(&mut **self, node)
    }

    fn visit_import_named_specifier(&mut self, node: &ImportNamedSpecifier) {
        Visit::visit_import_named_specifier(&mut **self, node)
    }

    fn visit_import_phase(&mut self, node: &ImportPhase) {
        Visit::visit_import_phase(&mut **self, node)
    }

    fn visit_import_specifier(&mut self, node: &ImportSpecifier) {
        Visit::visit_import_specifier(&mut **self, node)
    }

    fn visit_import_specifiers(&mut self, node: &[ImportSpecifier]) {
        Visit::visit_import_specifiers(&mut **self, node)
    }

    fn visit_import_star_as_specifier(&mut self, node: &ImportStarAsSpecifier) {
        Visit::visit_import_star_as_specifier(&mut **self, node)
    }

    fn visit_import_with(&mut self, node: &ImportWith) {
        Visit::visit_import_with(&mut **self, node)
    }

    fn visit_import_with_item(&mut self, node: &ImportWithItem) {
        Visit::visit_import_with_item(&mut **self, node)
    }

    fn visit_import_with_items(&mut self, node: &[ImportWithItem]) {
        Visit::visit_import_with_items(&mut **self, node)
    }

    fn visit_invalid(&mut self, node: &Invalid) {
        Visit::visit_invalid(&mut **self, node)
    }

    fn visit_jsx_attr(&mut self, node: &JSXAttr) {
        Visit::visit_jsx_attr(&mut **self, node)
    }

    fn visit_jsx_attr_name(&mut self, node: &JSXAttrName) {
        Visit::visit_jsx_attr_name(&mut **self, node)
    }

    fn visit_jsx_attr_or_spread(&mut self, node: &JSXAttrOrSpread) {
        Visit::visit_jsx_attr_or_spread(&mut **self, node)
    }

    fn visit_jsx_attr_or_spreads(&mut self, node: &[JSXAttrOrSpread]) {
        Visit::visit_jsx_attr_or_spreads(&mut **self, node)
    }

    fn visit_jsx_attr_value(&mut self, node: &JSXAttrValue) {
        Visit::visit_jsx_attr_value(&mut **self, node)
    }

    fn visit_jsx_closing_element(&mut self, node: &JSXClosingElement) {
        Visit::visit_jsx_closing_element(&mut **self, node)
    }

    fn visit_jsx_closing_fragment(&mut self, node: &JSXClosingFragment) {
        Visit::visit_jsx_closing_fragment(&mut **self, node)
    }

    fn visit_jsx_element(&mut self, node: &JSXElement) {
        Visit::visit_jsx_element(&mut **self, node)
    }

    fn visit_jsx_element_child(&mut self, node: &JSXElementChild) {
        Visit::visit_jsx_element_child(&mut **self, node)
    }

    fn visit_jsx_element_childs(&mut self, node: &[JSXElementChild]) {
        Visit::visit_jsx_element_childs(&mut **self, node)
    }

    fn visit_jsx_element_name(&mut self, node: &JSXElementName) {
        Visit::visit_jsx_element_name(&mut **self, node)
    }

    fn visit_jsx_empty_expr(&mut self, node: &JSXEmptyExpr) {
        Visit::visit_jsx_empty_expr(&mut **self, node)
    }

    fn visit_jsx_expr(&mut self, node: &JSXExpr) {
        Visit::visit_jsx_expr(&mut **self, node)
    }

    fn visit_jsx_expr_container(&mut self, node: &JSXExprContainer) {
        Visit::visit_jsx_expr_container(&mut **self, node)
    }

    fn visit_jsx_fragment(&mut self, node: &JSXFragment) {
        Visit::visit_jsx_fragment(&mut **self, node)
    }

    fn visit_jsx_member_expr(&mut self, node: &JSXMemberExpr) {
        Visit::visit_jsx_member_expr(&mut **self, node)
    }

    fn visit_jsx_namespaced_name(&mut self, node: &JSXNamespacedName) {
        Visit::visit_jsx_namespaced_name(&mut **self, node)
    }

    fn visit_jsx_object(&mut self, node: &JSXObject) {
        Visit::visit_jsx_object(&mut **self, node)
    }

    fn visit_jsx_opening_element(&mut self, node: &JSXOpeningElement) {
        Visit::visit_jsx_opening_element(&mut **self, node)
    }

    fn visit_jsx_opening_fragment(&mut self, node: &JSXOpeningFragment) {
        Visit::visit_jsx_opening_fragment(&mut **self, node)
    }

    fn visit_jsx_spread_child(&mut self, node: &JSXSpreadChild) {
        Visit::visit_jsx_spread_child(&mut **self, node)
    }

    fn visit_jsx_text(&mut self, node: &JSXText) {
        Visit::visit_jsx_text(&mut **self, node)
    }

    fn visit_key(&mut self, node: &Key) {
        Visit::visit_key(&mut **self, node)
    }

    fn visit_key_value_pat_prop(&mut self, node: &KeyValuePatProp) {
        Visit::visit_key_value_pat_prop(&mut **self, node)
    }

    fn visit_key_value_prop(&mut self, node: &KeyValueProp) {
        Visit::visit_key_value_prop(&mut **self, node)
    }

    fn visit_labeled_stmt(&mut self, node: &LabeledStmt) {
        Visit::visit_labeled_stmt(&mut **self, node)
    }

    fn visit_lit(&mut self, node: &Lit) {
        Visit::visit_lit(&mut **self, node)
    }

    fn visit_member_expr(&mut self, node: &MemberExpr) {
        Visit::visit_member_expr(&mut **self, node)
    }

    fn visit_member_prop(&mut self, node: &MemberProp) {
        Visit::visit_member_prop(&mut **self, node)
    }

    fn visit_meta_prop_expr(&mut self, node: &MetaPropExpr) {
        Visit::visit_meta_prop_expr(&mut **self, node)
    }

    fn visit_meta_prop_kind(&mut self, node: &MetaPropKind) {
        Visit::visit_meta_prop_kind(&mut **self, node)
    }

    fn visit_method_kind(&mut self, node: &MethodKind) {
        Visit::visit_method_kind(&mut **self, node)
    }

    fn visit_method_prop(&mut self, node: &MethodProp) {
        Visit::visit_method_prop(&mut **self, node)
    }

    fn visit_module(&mut self, node: &Module) {
        Visit::visit_module(&mut **self, node)
    }

    fn visit_module_decl(&mut self, node: &ModuleDecl) {
        Visit::visit_module_decl(&mut **self, node)
    }

    fn visit_module_export_name(&mut self, node: &ModuleExportName) {
        Visit::visit_module_export_name(&mut **self, node)
    }

    fn visit_module_item(&mut self, node: &ModuleItem) {
        Visit::visit_module_item(&mut **self, node)
    }

    fn visit_module_items(&mut self, node: &[ModuleItem]) {
        Visit::visit_module_items(&mut **self, node)
    }

    fn visit_named_export(&mut self, node: &NamedExport) {
        Visit::visit_named_export(&mut **self, node)
    }

    fn visit_new_expr(&mut self, node: &NewExpr) {
        Visit::visit_new_expr(&mut **self, node)
    }

    fn visit_null(&mut self, node: &Null) {
        Visit::visit_null(&mut **self, node)
    }

    fn visit_number(&mut self, node: &Number) {
        Visit::visit_number(&mut **self, node)
    }

    fn visit_object_lit(&mut self, node: &ObjectLit) {
        Visit::visit_object_lit(&mut **self, node)
    }

    fn visit_object_pat(&mut self, node: &ObjectPat) {
        Visit::visit_object_pat(&mut **self, node)
    }

    fn visit_object_pat_prop(&mut self, node: &ObjectPatProp) {
        Visit::visit_object_pat_prop(&mut **self, node)
    }

    fn visit_object_pat_props(&mut self, node: &[ObjectPatProp]) {
        Visit::visit_object_pat_props(&mut **self, node)
    }

    fn visit_opt_accessibility(&mut self, node: &Option<Accessibility>) {
        Visit::visit_opt_accessibility(&mut **self, node)
    }

    fn visit_opt_atom(&mut self, node: &Option<swc_atoms::Atom>) {
        Visit::visit_opt_atom(&mut **self, node)
    }

    fn visit_opt_block_stmt(&mut self, node: &Option<BlockStmt>) {
        Visit::visit_opt_block_stmt(&mut **self, node)
    }

    fn visit_opt_call(&mut self, node: &OptCall) {
        Visit::visit_opt_call(&mut **self, node)
    }

    fn visit_opt_catch_clause(&mut self, node: &Option<CatchClause>) {
        Visit::visit_opt_catch_clause(&mut **self, node)
    }

    fn visit_opt_chain_base(&mut self, node: &OptChainBase) {
        Visit::visit_opt_chain_base(&mut **self, node)
    }

    fn visit_opt_chain_expr(&mut self, node: &OptChainExpr) {
        Visit::visit_opt_chain_expr(&mut **self, node)
    }

    fn visit_opt_expr(&mut self, node: &Option<Box<Expr>>) {
        Visit::visit_opt_expr(&mut **self, node)
    }

    fn visit_opt_expr_or_spread(&mut self, node: &Option<ExprOrSpread>) {
        Visit::visit_opt_expr_or_spread(&mut **self, node)
    }

    fn visit_opt_expr_or_spreads(&mut self, node: &Option<Vec<ExprOrSpread>>) {
        Visit::visit_opt_expr_or_spreads(&mut **self, node)
    }

    fn visit_opt_ident(&mut self, node: &Option<Ident>) {
        Visit::visit_opt_ident(&mut **self, node)
    }

    fn visit_opt_jsx_attr_value(&mut self, node: &Option<JSXAttrValue>) {
        Visit::visit_opt_jsx_attr_value(&mut **self, node)
    }

    fn visit_opt_jsx_closing_element(&mut self, node: &Option<JSXClosingElement>) {
        Visit::visit_opt_jsx_closing_element(&mut **self, node)
    }

    fn visit_opt_module_export_name(&mut self, node: &Option<ModuleExportName>) {
        Visit::visit_opt_module_export_name(&mut **self, node)
    }

    fn visit_opt_module_items(&mut self, node: &Option<Vec<ModuleItem>>) {
        Visit::visit_opt_module_items(&mut **self, node)
    }

    fn visit_opt_object_lit(&mut self, node: &Option<Box<ObjectLit>>) {
        Visit::visit_opt_object_lit(&mut **self, node)
    }

    fn visit_opt_pat(&mut self, node: &Option<Pat>) {
        Visit::visit_opt_pat(&mut **self, node)
    }

    fn visit_opt_span(&mut self, node: &Option<swc_common::Span>) {
        Visit::visit_opt_span(&mut **self, node)
    }

    fn visit_opt_stmt(&mut self, node: &Option<Box<Stmt>>) {
        Visit::visit_opt_stmt(&mut **self, node)
    }

    fn visit_opt_str(&mut self, node: &Option<Box<Str>>) {
        Visit::visit_opt_str(&mut **self, node)
    }

    fn visit_opt_true_plus_minus(&mut self, node: &Option<TruePlusMinus>) {
        Visit::visit_opt_true_plus_minus(&mut **self, node)
    }

    fn visit_opt_ts_entity_name(&mut self, node: &Option<TsEntityName>) {
        Visit::visit_opt_ts_entity_name(&mut **self, node)
    }

    fn visit_opt_ts_namespace_body(&mut self, node: &Option<TsNamespaceBody>) {
        Visit::visit_opt_ts_namespace_body(&mut **self, node)
    }

    fn visit_opt_ts_type(&mut self, node: &Option<Box<TsType>>) {
        Visit::visit_opt_ts_type(&mut **self, node)
    }

    fn visit_opt_ts_type_ann(&mut self, node: &Option<Box<TsTypeAnn>>) {
        Visit::visit_opt_ts_type_ann(&mut **self, node)
    }

    fn visit_opt_ts_type_param_decl(&mut self, node: &Option<Box<TsTypeParamDecl>>) {
        Visit::visit_opt_ts_type_param_decl(&mut **self, node)
    }

    fn visit_opt_ts_type_param_instantiation(
        &mut self,
        node: &Option<Box<TsTypeParamInstantiation>>,
    ) {
        Visit::visit_opt_ts_type_param_instantiation(&mut **self, node)
    }

    fn visit_opt_var_decl_or_expr(&mut self, node: &Option<VarDeclOrExpr>) {
        Visit::visit_opt_var_decl_or_expr(&mut **self, node)
    }

    fn visit_opt_vec_expr_or_spreads(&mut self, node: &[Option<ExprOrSpread>]) {
        Visit::visit_opt_vec_expr_or_spreads(&mut **self, node)
    }

    fn visit_opt_vec_pats(&mut self, node: &[Option<Pat>]) {
        Visit::visit_opt_vec_pats(&mut **self, node)
    }

    fn visit_param(&mut self, node: &Param) {
        Visit::visit_param(&mut **self, node)
    }

    fn visit_param_or_ts_param_prop(&mut self, node: &ParamOrTsParamProp) {
        Visit::visit_param_or_ts_param_prop(&mut **self, node)
    }

    fn visit_param_or_ts_param_props(&mut self, node: &[ParamOrTsParamProp]) {
        Visit::visit_param_or_ts_param_props(&mut **self, node)
    }

    fn visit_params(&mut self, node: &[Param]) {
        Visit::visit_params(&mut **self, node)
    }

    fn visit_paren_expr(&mut self, node: &ParenExpr) {
        Visit::visit_paren_expr(&mut **self, node)
    }

    fn visit_pat(&mut self, node: &Pat) {
        Visit::visit_pat(&mut **self, node)
    }

    fn visit_pats(&mut self, node: &[Pat]) {
        Visit::visit_pats(&mut **self, node)
    }

    fn visit_private_method(&mut self, node: &PrivateMethod) {
        Visit::visit_private_method(&mut **self, node)
    }

    fn visit_private_name(&mut self, node: &PrivateName) {
        Visit::visit_private_name(&mut **self, node)
    }

    fn visit_private_prop(&mut self, node: &PrivateProp) {
        Visit::visit_private_prop(&mut **self, node)
    }

    fn visit_program(&mut self, node: &Program) {
        Visit::visit_program(&mut **self, node)
    }

    fn visit_prop(&mut self, node: &Prop) {
        Visit::visit_prop(&mut **self, node)
    }

    fn visit_prop_name(&mut self, node: &PropName) {
        Visit::visit_prop_name(&mut **self, node)
    }

    fn visit_prop_or_spread(&mut self, node: &PropOrSpread) {
        Visit::visit_prop_or_spread(&mut **self, node)
    }

    fn visit_prop_or_spreads(&mut self, node: &[PropOrSpread]) {
        Visit::visit_prop_or_spreads(&mut **self, node)
    }

    fn visit_regex(&mut self, node: &Regex) {
        Visit::visit_regex(&mut **self, node)
    }

    fn visit_reserved_unused(&mut self, node: &ReservedUnused) {
        Visit::visit_reserved_unused(&mut **self, node)
    }

    fn visit_rest_pat(&mut self, node: &RestPat) {
        Visit::visit_rest_pat(&mut **self, node)
    }

    fn visit_return_stmt(&mut self, node: &ReturnStmt) {
        Visit::visit_return_stmt(&mut **self, node)
    }

    fn visit_script(&mut self, node: &Script) {
        Visit::visit_script(&mut **self, node)
    }

    fn visit_seq_expr(&mut self, node: &SeqExpr) {
        Visit::visit_seq_expr(&mut **self, node)
    }

    fn visit_setter_prop(&mut self, node: &SetterProp) {
        Visit::visit_setter_prop(&mut **self, node)
    }

    fn visit_simple_assign_target(&mut self, node: &SimpleAssignTarget) {
        Visit::visit_simple_assign_target(&mut **self, node)
    }

    fn visit_span(&mut self, node: &swc_common::Span) {
        Visit::visit_span(&mut **self, node)
    }

    fn visit_spread_element(&mut self, node: &SpreadElement) {
        Visit::visit_spread_element(&mut **self, node)
    }

    fn visit_static_block(&mut self, node: &StaticBlock) {
        Visit::visit_static_block(&mut **self, node)
    }

    fn visit_stmt(&mut self, node: &Stmt) {
        Visit::visit_stmt(&mut **self, node)
    }

    fn visit_stmts(&mut self, node: &[Stmt]) {
        Visit::visit_stmts(&mut **self, node)
    }

    fn visit_str(&mut self, node: &Str) {
        Visit::visit_str(&mut **self, node)
    }

    fn visit_super(&mut self, node: &Super) {
        Visit::visit_super(&mut **self, node)
    }

    fn visit_super_prop(&mut self, node: &SuperProp) {
        Visit::visit_super_prop(&mut **self, node)
    }

    fn visit_super_prop_expr(&mut self, node: &SuperPropExpr) {
        Visit::visit_super_prop_expr(&mut **self, node)
    }

    fn visit_switch_case(&mut self, node: &SwitchCase) {
        Visit::visit_switch_case(&mut **self, node)
    }

    fn visit_switch_cases(&mut self, node: &[SwitchCase]) {
        Visit::visit_switch_cases(&mut **self, node)
    }

    fn visit_switch_stmt(&mut self, node: &SwitchStmt) {
        Visit::visit_switch_stmt(&mut **self, node)
    }

    fn visit_syntax_context(&mut self, node: &swc_common::SyntaxContext) {
        Visit::visit_syntax_context(&mut **self, node)
    }

    fn visit_tagged_tpl(&mut self, node: &TaggedTpl) {
        Visit::visit_tagged_tpl(&mut **self, node)
    }

    fn visit_this_expr(&mut self, node: &ThisExpr) {
        Visit::visit_this_expr(&mut **self, node)
    }

    fn visit_throw_stmt(&mut self, node: &ThrowStmt) {
        Visit::visit_throw_stmt(&mut **self, node)
    }

    fn visit_tpl(&mut self, node: &Tpl) {
        Visit::visit_tpl(&mut **self, node)
    }

    fn visit_tpl_element(&mut self, node: &TplElement) {
        Visit::visit_tpl_element(&mut **self, node)
    }

    fn visit_tpl_elements(&mut self, node: &[TplElement]) {
        Visit::visit_tpl_elements(&mut **self, node)
    }

    fn visit_true_plus_minus(&mut self, node: &TruePlusMinus) {
        Visit::visit_true_plus_minus(&mut **self, node)
    }

    fn visit_try_stmt(&mut self, node: &TryStmt) {
        Visit::visit_try_stmt(&mut **self, node)
    }

    fn visit_ts_array_type(&mut self, node: &TsArrayType) {
        Visit::visit_ts_array_type(&mut **self, node)
    }

    fn visit_ts_as_expr(&mut self, node: &TsAsExpr) {
        Visit::visit_ts_as_expr(&mut **self, node)
    }

    fn visit_ts_call_signature_decl(&mut self, node: &TsCallSignatureDecl) {
        Visit::visit_ts_call_signature_decl(&mut **self, node)
    }

    fn visit_ts_conditional_type(&mut self, node: &TsConditionalType) {
        Visit::visit_ts_conditional_type(&mut **self, node)
    }

    fn visit_ts_const_assertion(&mut self, node: &TsConstAssertion) {
        Visit::visit_ts_const_assertion(&mut **self, node)
    }

    fn visit_ts_construct_signature_decl(&mut self, node: &TsConstructSignatureDecl) {
        Visit::visit_ts_construct_signature_decl(&mut **self, node)
    }

    fn visit_ts_constructor_type(&mut self, node: &TsConstructorType) {
        Visit::visit_ts_constructor_type(&mut **self, node)
    }

    fn visit_ts_entity_name(&mut self, node: &TsEntityName) {
        Visit::visit_ts_entity_name(&mut **self, node)
    }

    fn visit_ts_enum_decl(&mut self, node: &TsEnumDecl) {
        Visit::visit_ts_enum_decl(&mut **self, node)
    }

    fn visit_ts_enum_member(&mut self, node: &TsEnumMember) {
        Visit::visit_ts_enum_member(&mut **self, node)
    }

    fn visit_ts_enum_member_id(&mut self, node: &TsEnumMemberId) {
        Visit::visit_ts_enum_member_id(&mut **self, node)
    }

    fn visit_ts_enum_members(&mut self, node: &[TsEnumMember]) {
        Visit::visit_ts_enum_members(&mut **self, node)
    }

    fn visit_ts_export_assignment(&mut self, node: &TsExportAssignment) {
        Visit::visit_ts_export_assignment(&mut **self, node)
    }

    fn visit_ts_expr_with_type_args(&mut self, node: &TsExprWithTypeArgs) {
        Visit::visit_ts_expr_with_type_args(&mut **self, node)
    }

    fn visit_ts_expr_with_type_argss(&mut self, node: &[TsExprWithTypeArgs]) {
        Visit::visit_ts_expr_with_type_argss(&mut **self, node)
    }

    fn visit_ts_external_module_ref(&mut self, node: &TsExternalModuleRef) {
        Visit::visit_ts_external_module_ref(&mut **self, node)
    }

    fn visit_ts_fn_or_constructor_type(&mut self, node: &TsFnOrConstructorType) {
        Visit::visit_ts_fn_or_constructor_type(&mut **self, node)
    }

    fn visit_ts_fn_param(&mut self, node: &TsFnParam) {
        Visit::visit_ts_fn_param(&mut **self, node)
    }

    fn visit_ts_fn_params(&mut self, node: &[TsFnParam]) {
        Visit::visit_ts_fn_params(&mut **self, node)
    }

    fn visit_ts_fn_type(&mut self, node: &TsFnType) {
        Visit::visit_ts_fn_type(&mut **self, node)
    }

    fn visit_ts_getter_signature(&mut self, node: &TsGetterSignature) {
        Visit::visit_ts_getter_signature(&mut **self, node)
    }

    fn visit_ts_import_equals_decl(&mut self, node: &TsImportEqualsDecl) {
        Visit::visit_ts_import_equals_decl(&mut **self, node)
    }

    fn visit_ts_import_type(&mut self, node: &TsImportType) {
        Visit::visit_ts_import_type(&mut **self, node)
    }

    fn visit_ts_index_signature(&mut self, node: &TsIndexSignature) {
        Visit::visit_ts_index_signature(&mut **self, node)
    }

    fn visit_ts_indexed_access_type(&mut self, node: &TsIndexedAccessType) {
        Visit::visit_ts_indexed_access_type(&mut **self, node)
    }

    fn visit_ts_infer_type(&mut self, node: &TsInferType) {
        Visit::visit_ts_infer_type(&mut **self, node)
    }

    fn visit_ts_instantiation(&mut self, node: &TsInstantiation) {
        Visit::visit_ts_instantiation(&mut **self, node)
    }

    fn visit_ts_interface_body(&mut self, node: &TsInterfaceBody) {
        Visit::visit_ts_interface_body(&mut **self, node)
    }

    fn visit_ts_interface_decl(&mut self, node: &TsInterfaceDecl) {
        Visit::visit_ts_interface_decl(&mut **self, node)
    }

    fn visit_ts_intersection_type(&mut self, node: &TsIntersectionType) {
        Visit::visit_ts_intersection_type(&mut **self, node)
    }

    fn visit_ts_keyword_type(&mut self, node: &TsKeywordType) {
        Visit::visit_ts_keyword_type(&mut **self, node)
    }

    fn visit_ts_keyword_type_kind(&mut self, node: &TsKeywordTypeKind) {
        Visit::visit_ts_keyword_type_kind(&mut **self, node)
    }

    fn visit_ts_lit(&mut self, node: &TsLit) {
        Visit::visit_ts_lit(&mut **self, node)
    }

    fn visit_ts_lit_type(&mut self, node: &TsLitType) {
        Visit::visit_ts_lit_type(&mut **self, node)
    }

    fn visit_ts_mapped_type(&mut self, node: &TsMappedType) {
        Visit::visit_ts_mapped_type(&mut **self, node)
    }

    fn visit_ts_method_signature(&mut self, node: &TsMethodSignature) {
        Visit::visit_ts_method_signature(&mut **self, node)
    }

    fn visit_ts_module_block(&mut self, node: &TsModuleBlock) {
        Visit::visit_ts_module_block(&mut **self, node)
    }

    fn visit_ts_module_decl(&mut self, node: &TsModuleDecl) {
        Visit::visit_ts_module_decl(&mut **self, node)
    }

    fn visit_ts_module_name(&mut self, node: &TsModuleName) {
        Visit::visit_ts_module_name(&mut **self, node)
    }

    fn visit_ts_module_ref(&mut self, node: &TsModuleRef) {
        Visit::visit_ts_module_ref(&mut **self, node)
    }

    fn visit_ts_namespace_body(&mut self, node: &TsNamespaceBody) {
        Visit::visit_ts_namespace_body(&mut **self, node)
    }

    fn visit_ts_namespace_decl(&mut self, node: &TsNamespaceDecl) {
        Visit::visit_ts_namespace_decl(&mut **self, node)
    }

    fn visit_ts_namespace_export_decl(&mut self, node: &TsNamespaceExportDecl) {
        Visit::visit_ts_namespace_export_decl(&mut **self, node)
    }

    fn visit_ts_non_null_expr(&mut self, node: &TsNonNullExpr) {
        Visit::visit_ts_non_null_expr(&mut **self, node)
    }

    fn visit_ts_optional_type(&mut self, node: &TsOptionalType) {
        Visit::visit_ts_optional_type(&mut **self, node)
    }

    fn visit_ts_param_prop(&mut self, node: &TsParamProp) {
        Visit::visit_ts_param_prop(&mut **self, node)
    }

    fn visit_ts_param_prop_param(&mut self, node: &TsParamPropParam) {
        Visit::visit_ts_param_prop_param(&mut **self, node)
    }

    fn visit_ts_parenthesized_type(&mut self, node: &TsParenthesizedType) {
        Visit::visit_ts_parenthesized_type(&mut **self, node)
    }

    fn visit_ts_property_signature(&mut self, node: &TsPropertySignature) {
        Visit::visit_ts_property_signature(&mut **self, node)
    }

    fn visit_ts_qualified_name(&mut self, node: &TsQualifiedName) {
        Visit::visit_ts_qualified_name(&mut **self, node)
    }

    fn visit_ts_rest_type(&mut self, node: &TsRestType) {
        Visit::visit_ts_rest_type(&mut **self, node)
    }

    fn visit_ts_satisfies_expr(&mut self, node: &TsSatisfiesExpr) {
        Visit::visit_ts_satisfies_expr(&mut **self, node)
    }

    fn visit_ts_setter_signature(&mut self, node: &TsSetterSignature) {
        Visit::visit_ts_setter_signature(&mut **self, node)
    }

    fn visit_ts_this_type(&mut self, node: &TsThisType) {
        Visit::visit_ts_this_type(&mut **self, node)
    }

    fn visit_ts_this_type_or_ident(&mut self, node: &TsThisTypeOrIdent) {
        Visit::visit_ts_this_type_or_ident(&mut **self, node)
    }

    fn visit_ts_tpl_lit_type(&mut self, node: &TsTplLitType) {
        Visit::visit_ts_tpl_lit_type(&mut **self, node)
    }

    fn visit_ts_tuple_element(&mut self, node: &TsTupleElement) {
        Visit::visit_ts_tuple_element(&mut **self, node)
    }

    fn visit_ts_tuple_elements(&mut self, node: &[TsTupleElement]) {
        Visit::visit_ts_tuple_elements(&mut **self, node)
    }

    fn visit_ts_tuple_type(&mut self, node: &TsTupleType) {
        Visit::visit_ts_tuple_type(&mut **self, node)
    }

    fn visit_ts_type(&mut self, node: &TsType) {
        Visit::visit_ts_type(&mut **self, node)
    }

    fn visit_ts_type_alias_decl(&mut self, node: &TsTypeAliasDecl) {
        Visit::visit_ts_type_alias_decl(&mut **self, node)
    }

    fn visit_ts_type_ann(&mut self, node: &TsTypeAnn) {
        Visit::visit_ts_type_ann(&mut **self, node)
    }

    fn visit_ts_type_assertion(&mut self, node: &TsTypeAssertion) {
        Visit::visit_ts_type_assertion(&mut **self, node)
    }

    fn visit_ts_type_element(&mut self, node: &TsTypeElement) {
        Visit::visit_ts_type_element(&mut **self, node)
    }

    fn visit_ts_type_elements(&mut self, node: &[TsTypeElement]) {
        Visit::visit_ts_type_elements(&mut **self, node)
    }

    fn visit_ts_type_lit(&mut self, node: &TsTypeLit) {
        Visit::visit_ts_type_lit(&mut **self, node)
    }

    fn visit_ts_type_operator(&mut self, node: &TsTypeOperator) {
        Visit::visit_ts_type_operator(&mut **self, node)
    }

    fn visit_ts_type_operator_op(&mut self, node: &TsTypeOperatorOp) {
        Visit::visit_ts_type_operator_op(&mut **self, node)
    }

    fn visit_ts_type_param(&mut self, node: &TsTypeParam) {
        Visit::visit_ts_type_param(&mut **self, node)
    }

    fn visit_ts_type_param_decl(&mut self, node: &TsTypeParamDecl) {
        Visit::visit_ts_type_param_decl(&mut **self, node)
    }

    fn visit_ts_type_param_instantiation(&mut self, node: &TsTypeParamInstantiation) {
        Visit::visit_ts_type_param_instantiation(&mut **self, node)
    }

    fn visit_ts_type_params(&mut self, node: &[TsTypeParam]) {
        Visit::visit_ts_type_params(&mut **self, node)
    }

    fn visit_ts_type_predicate(&mut self, node: &TsTypePredicate) {
        Visit::visit_ts_type_predicate(&mut **self, node)
    }

    fn visit_ts_type_query(&mut self, node: &TsTypeQuery) {
        Visit::visit_ts_type_query(&mut **self, node)
    }

    fn visit_ts_type_query_expr(&mut self, node: &TsTypeQueryExpr) {
        Visit::visit_ts_type_query_expr(&mut **self, node)
    }

    fn visit_ts_type_ref(&mut self, node: &TsTypeRef) {
        Visit::visit_ts_type_ref(&mut **self, node)
    }

    fn visit_ts_types(&mut self, node: &[Box<TsType>]) {
        Visit::visit_ts_types(&mut **self, node)
    }

    fn visit_ts_union_or_intersection_type(&mut self, node: &TsUnionOrIntersectionType) {
        Visit::visit_ts_union_or_intersection_type(&mut **self, node)
    }

    fn visit_ts_union_type(&mut self, node: &TsUnionType) {
        Visit::visit_ts_union_type(&mut **self, node)
    }

    fn visit_unary_expr(&mut self, node: &UnaryExpr) {
        Visit::visit_unary_expr(&mut **self, node)
    }

    fn visit_unary_op(&mut self, node: &UnaryOp) {
        Visit::visit_unary_op(&mut **self, node)
    }

    fn visit_update_expr(&mut self, node: &UpdateExpr) {
        Visit::visit_update_expr(&mut **self, node)
    }

    fn visit_update_op(&mut self, node: &UpdateOp) {
        Visit::visit_update_op(&mut **self, node)
    }

    fn visit_using_decl(&mut self, node: &UsingDecl) {
        Visit::visit_using_decl(&mut **self, node)
    }

    fn visit_var_decl(&mut self, node: &VarDecl) {
        Visit::visit_var_decl(&mut **self, node)
    }

    fn visit_var_decl_kind(&mut self, node: &VarDeclKind) {
        Visit::visit_var_decl_kind(&mut **self, node)
    }

    fn visit_var_decl_or_expr(&mut self, node: &VarDeclOrExpr) {
        Visit::visit_var_decl_or_expr(&mut **self, node)
    }

    fn visit_var_declarator(&mut self, node: &VarDeclarator) {
        Visit::visit_var_declarator(&mut **self, node)
    }

    fn visit_var_declarators(&mut self, node: &[VarDeclarator]) {
        Visit::visit_var_declarators(&mut **self, node)
    }

    fn visit_while_stmt(&mut self, node: &WhileStmt) {
        Visit::visit_while_stmt(&mut **self, node)
    }

    fn visit_with_stmt(&mut self, node: &WithStmt) {
        Visit::visit_with_stmt(&mut **self, node)
    }

    fn visit_yield_expr(&mut self, node: &YieldExpr) {
        Visit::visit_yield_expr(&mut **self, node)
    }
}
impl<V> Visit for Box<V>
where
    V: ?Sized + Visit,
{
    fn visit_accessibility(&mut self, node: &Accessibility) {
        Visit::visit_accessibility(&mut **self, node)
    }

    fn visit_array_lit(&mut self, node: &ArrayLit) {
        Visit::visit_array_lit(&mut **self, node)
    }

    fn visit_array_pat(&mut self, node: &ArrayPat) {
        Visit::visit_array_pat(&mut **self, node)
    }

    fn visit_arrow_expr(&mut self, node: &ArrowExpr) {
        Visit::visit_arrow_expr(&mut **self, node)
    }

    fn visit_assign_expr(&mut self, node: &AssignExpr) {
        Visit::visit_assign_expr(&mut **self, node)
    }

    fn visit_assign_op(&mut self, node: &AssignOp) {
        Visit::visit_assign_op(&mut **self, node)
    }

    fn visit_assign_pat(&mut self, node: &AssignPat) {
        Visit::visit_assign_pat(&mut **self, node)
    }

    fn visit_assign_pat_prop(&mut self, node: &AssignPatProp) {
        Visit::visit_assign_pat_prop(&mut **self, node)
    }

    fn visit_assign_prop(&mut self, node: &AssignProp) {
        Visit::visit_assign_prop(&mut **self, node)
    }

    fn visit_assign_target(&mut self, node: &AssignTarget) {
        Visit::visit_assign_target(&mut **self, node)
    }

    fn visit_assign_target_pat(&mut self, node: &AssignTargetPat) {
        Visit::visit_assign_target_pat(&mut **self, node)
    }

    fn visit_atom(&mut self, node: &swc_atoms::Atom) {
        Visit::visit_atom(&mut **self, node)
    }

    fn visit_auto_accessor(&mut self, node: &AutoAccessor) {
        Visit::visit_auto_accessor(&mut **self, node)
    }

    fn visit_await_expr(&mut self, node: &AwaitExpr) {
        Visit::visit_await_expr(&mut **self, node)
    }

    fn visit_big_int(&mut self, node: &BigInt) {
        Visit::visit_big_int(&mut **self, node)
    }

    fn visit_big_int_value(&mut self, node: &BigIntValue) {
        Visit::visit_big_int_value(&mut **self, node)
    }

    fn visit_bin_expr(&mut self, node: &BinExpr) {
        Visit::visit_bin_expr(&mut **self, node)
    }

    fn visit_binary_op(&mut self, node: &BinaryOp) {
        Visit::visit_binary_op(&mut **self, node)
    }

    fn visit_binding_ident(&mut self, node: &BindingIdent) {
        Visit::visit_binding_ident(&mut **self, node)
    }

    fn visit_block_stmt(&mut self, node: &BlockStmt) {
        Visit::visit_block_stmt(&mut **self, node)
    }

    fn visit_block_stmt_or_expr(&mut self, node: &BlockStmtOrExpr) {
        Visit::visit_block_stmt_or_expr(&mut **self, node)
    }

    fn visit_bool(&mut self, node: &Bool) {
        Visit::visit_bool(&mut **self, node)
    }

    fn visit_break_stmt(&mut self, node: &BreakStmt) {
        Visit::visit_break_stmt(&mut **self, node)
    }

    fn visit_call_expr(&mut self, node: &CallExpr) {
        Visit::visit_call_expr(&mut **self, node)
    }

    fn visit_callee(&mut self, node: &Callee) {
        Visit::visit_callee(&mut **self, node)
    }

    fn visit_catch_clause(&mut self, node: &CatchClause) {
        Visit::visit_catch_clause(&mut **self, node)
    }

    fn visit_class(&mut self, node: &Class) {
        Visit::visit_class(&mut **self, node)
    }

    fn visit_class_decl(&mut self, node: &ClassDecl) {
        Visit::visit_class_decl(&mut **self, node)
    }

    fn visit_class_expr(&mut self, node: &ClassExpr) {
        Visit::visit_class_expr(&mut **self, node)
    }

    fn visit_class_member(&mut self, node: &ClassMember) {
        Visit::visit_class_member(&mut **self, node)
    }

    fn visit_class_members(&mut self, node: &[ClassMember]) {
        Visit::visit_class_members(&mut **self, node)
    }

    fn visit_class_method(&mut self, node: &ClassMethod) {
        Visit::visit_class_method(&mut **self, node)
    }

    fn visit_class_prop(&mut self, node: &ClassProp) {
        Visit::visit_class_prop(&mut **self, node)
    }

    fn visit_computed_prop_name(&mut self, node: &ComputedPropName) {
        Visit::visit_computed_prop_name(&mut **self, node)
    }

    fn visit_cond_expr(&mut self, node: &CondExpr) {
        Visit::visit_cond_expr(&mut **self, node)
    }

    fn visit_constructor(&mut self, node: &Constructor) {
        Visit::visit_constructor(&mut **self, node)
    }

    fn visit_continue_stmt(&mut self, node: &ContinueStmt) {
        Visit::visit_continue_stmt(&mut **self, node)
    }

    fn visit_debugger_stmt(&mut self, node: &DebuggerStmt) {
        Visit::visit_debugger_stmt(&mut **self, node)
    }

    fn visit_decl(&mut self, node: &Decl) {
        Visit::visit_decl(&mut **self, node)
    }

    fn visit_decorator(&mut self, node: &Decorator) {
        Visit::visit_decorator(&mut **self, node)
    }

    fn visit_decorators(&mut self, node: &[Decorator]) {
        Visit::visit_decorators(&mut **self, node)
    }

    fn visit_default_decl(&mut self, node: &DefaultDecl) {
        Visit::visit_default_decl(&mut **self, node)
    }

    fn visit_do_while_stmt(&mut self, node: &DoWhileStmt) {
        Visit::visit_do_while_stmt(&mut **self, node)
    }

    fn visit_empty_stmt(&mut self, node: &EmptyStmt) {
        Visit::visit_empty_stmt(&mut **self, node)
    }

    fn visit_es_version(&mut self, node: &EsVersion) {
        Visit::visit_es_version(&mut **self, node)
    }

    fn visit_export_all(&mut self, node: &ExportAll) {
        Visit::visit_export_all(&mut **self, node)
    }

    fn visit_export_decl(&mut self, node: &ExportDecl) {
        Visit::visit_export_decl(&mut **self, node)
    }

    fn visit_export_default_decl(&mut self, node: &ExportDefaultDecl) {
        Visit::visit_export_default_decl(&mut **self, node)
    }

    fn visit_export_default_expr(&mut self, node: &ExportDefaultExpr) {
        Visit::visit_export_default_expr(&mut **self, node)
    }

    fn visit_export_default_specifier(&mut self, node: &ExportDefaultSpecifier) {
        Visit::visit_export_default_specifier(&mut **self, node)
    }

    fn visit_export_named_specifier(&mut self, node: &ExportNamedSpecifier) {
        Visit::visit_export_named_specifier(&mut **self, node)
    }

    fn visit_export_namespace_specifier(&mut self, node: &ExportNamespaceSpecifier) {
        Visit::visit_export_namespace_specifier(&mut **self, node)
    }

    fn visit_export_specifier(&mut self, node: &ExportSpecifier) {
        Visit::visit_export_specifier(&mut **self, node)
    }

    fn visit_export_specifiers(&mut self, node: &[ExportSpecifier]) {
        Visit::visit_export_specifiers(&mut **self, node)
    }

    fn visit_expr(&mut self, node: &Expr) {
        Visit::visit_expr(&mut **self, node)
    }

    fn visit_expr_or_spread(&mut self, node: &ExprOrSpread) {
        Visit::visit_expr_or_spread(&mut **self, node)
    }

    fn visit_expr_or_spreads(&mut self, node: &[ExprOrSpread]) {
        Visit::visit_expr_or_spreads(&mut **self, node)
    }

    fn visit_expr_stmt(&mut self, node: &ExprStmt) {
        Visit::visit_expr_stmt(&mut **self, node)
    }

    fn visit_exprs(&mut self, node: &[Box<Expr>]) {
        Visit::visit_exprs(&mut **self, node)
    }

    fn visit_fn_decl(&mut self, node: &FnDecl) {
        Visit::visit_fn_decl(&mut **self, node)
    }

    fn visit_fn_expr(&mut self, node: &FnExpr) {
        Visit::visit_fn_expr(&mut **self, node)
    }

    fn visit_for_head(&mut self, node: &ForHead) {
        Visit::visit_for_head(&mut **self, node)
    }

    fn visit_for_in_stmt(&mut self, node: &ForInStmt) {
        Visit::visit_for_in_stmt(&mut **self, node)
    }

    fn visit_for_of_stmt(&mut self, node: &ForOfStmt) {
        Visit::visit_for_of_stmt(&mut **self, node)
    }

    fn visit_for_stmt(&mut self, node: &ForStmt) {
        Visit::visit_for_stmt(&mut **self, node)
    }

    fn visit_function(&mut self, node: &Function) {
        Visit::visit_function(&mut **self, node)
    }

    fn visit_getter_prop(&mut self, node: &GetterProp) {
        Visit::visit_getter_prop(&mut **self, node)
    }

    fn visit_ident(&mut self, node: &Ident) {
        Visit::visit_ident(&mut **self, node)
    }

    fn visit_ident_name(&mut self, node: &IdentName) {
        Visit::visit_ident_name(&mut **self, node)
    }

    fn visit_if_stmt(&mut self, node: &IfStmt) {
        Visit::visit_if_stmt(&mut **self, node)
    }

    fn visit_import(&mut self, node: &Import) {
        Visit::visit_import(&mut **self, node)
    }

    fn visit_import_decl(&mut self, node: &ImportDecl) {
        Visit::visit_import_decl(&mut **self, node)
    }

    fn visit_import_default_specifier(&mut self, node: &ImportDefaultSpecifier) {
        Visit::visit_import_default_specifier(&mut **self, node)
    }

    fn visit_import_named_specifier(&mut self, node: &ImportNamedSpecifier) {
        Visit::visit_import_named_specifier(&mut **self, node)
    }

    fn visit_import_phase(&mut self, node: &ImportPhase) {
        Visit::visit_import_phase(&mut **self, node)
    }

    fn visit_import_specifier(&mut self, node: &ImportSpecifier) {
        Visit::visit_import_specifier(&mut **self, node)
    }

    fn visit_import_specifiers(&mut self, node: &[ImportSpecifier]) {
        Visit::visit_import_specifiers(&mut **self, node)
    }

    fn visit_import_star_as_specifier(&mut self, node: &ImportStarAsSpecifier) {
        Visit::visit_import_star_as_specifier(&mut **self, node)
    }

    fn visit_import_with(&mut self, node: &ImportWith) {
        Visit::visit_import_with(&mut **self, node)
    }

    fn visit_import_with_item(&mut self, node: &ImportWithItem) {
        Visit::visit_import_with_item(&mut **self, node)
    }

    fn visit_import_with_items(&mut self, node: &[ImportWithItem]) {
        Visit::visit_import_with_items(&mut **self, node)
    }

    fn visit_invalid(&mut self, node: &Invalid) {
        Visit::visit_invalid(&mut **self, node)
    }

    fn visit_jsx_attr(&mut self, node: &JSXAttr) {
        Visit::visit_jsx_attr(&mut **self, node)
    }

    fn visit_jsx_attr_name(&mut self, node: &JSXAttrName) {
        Visit::visit_jsx_attr_name(&mut **self, node)
    }

    fn visit_jsx_attr_or_spread(&mut self, node: &JSXAttrOrSpread) {
        Visit::visit_jsx_attr_or_spread(&mut **self, node)
    }

    fn visit_jsx_attr_or_spreads(&mut self, node: &[JSXAttrOrSpread]) {
        Visit::visit_jsx_attr_or_spreads(&mut **self, node)
    }

    fn visit_jsx_attr_value(&mut self, node: &JSXAttrValue) {
        Visit::visit_jsx_attr_value(&mut **self, node)
    }

    fn visit_jsx_closing_element(&mut self, node: &JSXClosingElement) {
        Visit::visit_jsx_closing_element(&mut **self, node)
    }

    fn visit_jsx_closing_fragment(&mut self, node: &JSXClosingFragment) {
        Visit::visit_jsx_closing_fragment(&mut **self, node)
    }

    fn visit_jsx_element(&mut self, node: &JSXElement) {
        Visit::visit_jsx_element(&mut **self, node)
    }

    fn visit_jsx_element_child(&mut self, node: &JSXElementChild) {
        Visit::visit_jsx_element_child(&mut **self, node)
    }

    fn visit_jsx_element_childs(&mut self, node: &[JSXElementChild]) {
        Visit::visit_jsx_element_childs(&mut **self, node)
    }

    fn visit_jsx_element_name(&mut self, node: &JSXElementName) {
        Visit::visit_jsx_element_name(&mut **self, node)
    }

    fn visit_jsx_empty_expr(&mut self, node: &JSXEmptyExpr) {
        Visit::visit_jsx_empty_expr(&mut **self, node)
    }

    fn visit_jsx_expr(&mut self, node: &JSXExpr) {
        Visit::visit_jsx_expr(&mut **self, node)
    }

    fn visit_jsx_expr_container(&mut self, node: &JSXExprContainer) {
        Visit::visit_jsx_expr_container(&mut **self, node)
    }

    fn visit_jsx_fragment(&mut self, node: &JSXFragment) {
        Visit::visit_jsx_fragment(&mut **self, node)
    }

    fn visit_jsx_member_expr(&mut self, node: &JSXMemberExpr) {
        Visit::visit_jsx_member_expr(&mut **self, node)
    }

    fn visit_jsx_namespaced_name(&mut self, node: &JSXNamespacedName) {
        Visit::visit_jsx_namespaced_name(&mut **self, node)
    }

    fn visit_jsx_object(&mut self, node: &JSXObject) {
        Visit::visit_jsx_object(&mut **self, node)
    }

    fn visit_jsx_opening_element(&mut self, node: &JSXOpeningElement) {
        Visit::visit_jsx_opening_element(&mut **self, node)
    }

    fn visit_jsx_opening_fragment(&mut self, node: &JSXOpeningFragment) {
        Visit::visit_jsx_opening_fragment(&mut **self, node)
    }

    fn visit_jsx_spread_child(&mut self, node: &JSXSpreadChild) {
        Visit::visit_jsx_spread_child(&mut **self, node)
    }

    fn visit_jsx_text(&mut self, node: &JSXText) {
        Visit::visit_jsx_text(&mut **self, node)
    }

    fn visit_key(&mut self, node: &Key) {
        Visit::visit_key(&mut **self, node)
    }

    fn visit_key_value_pat_prop(&mut self, node: &KeyValuePatProp) {
        Visit::visit_key_value_pat_prop(&mut **self, node)
    }

    fn visit_key_value_prop(&mut self, node: &KeyValueProp) {
        Visit::visit_key_value_prop(&mut **self, node)
    }

    fn visit_labeled_stmt(&mut self, node: &LabeledStmt) {
        Visit::visit_labeled_stmt(&mut **self, node)
    }

    fn visit_lit(&mut self, node: &Lit) {
        Visit::visit_lit(&mut **self, node)
    }

    fn visit_member_expr(&mut self, node: &MemberExpr) {
        Visit::visit_member_expr(&mut **self, node)
    }

    fn visit_member_prop(&mut self, node: &MemberProp) {
        Visit::visit_member_prop(&mut **self, node)
    }

    fn visit_meta_prop_expr(&mut self, node: &MetaPropExpr) {
        Visit::visit_meta_prop_expr(&mut **self, node)
    }

    fn visit_meta_prop_kind(&mut self, node: &MetaPropKind) {
        Visit::visit_meta_prop_kind(&mut **self, node)
    }

    fn visit_method_kind(&mut self, node: &MethodKind) {
        Visit::visit_method_kind(&mut **self, node)
    }

    fn visit_method_prop(&mut self, node: &MethodProp) {
        Visit::visit_method_prop(&mut **self, node)
    }

    fn visit_module(&mut self, node: &Module) {
        Visit::visit_module(&mut **self, node)
    }

    fn visit_module_decl(&mut self, node: &ModuleDecl) {
        Visit::visit_module_decl(&mut **self, node)
    }

    fn visit_module_export_name(&mut self, node: &ModuleExportName) {
        Visit::visit_module_export_name(&mut **self, node)
    }

    fn visit_module_item(&mut self, node: &ModuleItem) {
        Visit::visit_module_item(&mut **self, node)
    }

    fn visit_module_items(&mut self, node: &[ModuleItem]) {
        Visit::visit_module_items(&mut **self, node)
    }

    fn visit_named_export(&mut self, node: &NamedExport) {
        Visit::visit_named_export(&mut **self, node)
    }

    fn visit_new_expr(&mut self, node: &NewExpr) {
        Visit::visit_new_expr(&mut **self, node)
    }

    fn visit_null(&mut self, node: &Null) {
        Visit::visit_null(&mut **self, node)
    }

    fn visit_number(&mut self, node: &Number) {
        Visit::visit_number(&mut **self, node)
    }

    fn visit_object_lit(&mut self, node: &ObjectLit) {
        Visit::visit_object_lit(&mut **self, node)
    }

    fn visit_object_pat(&mut self, node: &ObjectPat) {
        Visit::visit_object_pat(&mut **self, node)
    }

    fn visit_object_pat_prop(&mut self, node: &ObjectPatProp) {
        Visit::visit_object_pat_prop(&mut **self, node)
    }

    fn visit_object_pat_props(&mut self, node: &[ObjectPatProp]) {
        Visit::visit_object_pat_props(&mut **self, node)
    }

    fn visit_opt_accessibility(&mut self, node: &Option<Accessibility>) {
        Visit::visit_opt_accessibility(&mut **self, node)
    }

    fn visit_opt_atom(&mut self, node: &Option<swc_atoms::Atom>) {
        Visit::visit_opt_atom(&mut **self, node)
    }

    fn visit_opt_block_stmt(&mut self, node: &Option<BlockStmt>) {
        Visit::visit_opt_block_stmt(&mut **self, node)
    }

    fn visit_opt_call(&mut self, node: &OptCall) {
        Visit::visit_opt_call(&mut **self, node)
    }

    fn visit_opt_catch_clause(&mut self, node: &Option<CatchClause>) {
        Visit::visit_opt_catch_clause(&mut **self, node)
    }

    fn visit_opt_chain_base(&mut self, node: &OptChainBase) {
        Visit::visit_opt_chain_base(&mut **self, node)
    }

    fn visit_opt_chain_expr(&mut self, node: &OptChainExpr) {
        Visit::visit_opt_chain_expr(&mut **self, node)
    }

    fn visit_opt_expr(&mut self, node: &Option<Box<Expr>>) {
        Visit::visit_opt_expr(&mut **self, node)
    }

    fn visit_opt_expr_or_spread(&mut self, node: &Option<ExprOrSpread>) {
        Visit::visit_opt_expr_or_spread(&mut **self, node)
    }

    fn visit_opt_expr_or_spreads(&mut self, node: &Option<Vec<ExprOrSpread>>) {
        Visit::visit_opt_expr_or_spreads(&mut **self, node)
    }

    fn visit_opt_ident(&mut self, node: &Option<Ident>) {
        Visit::visit_opt_ident(&mut **self, node)
    }

    fn visit_opt_jsx_attr_value(&mut self, node: &Option<JSXAttrValue>) {
        Visit::visit_opt_jsx_attr_value(&mut **self, node)
    }

    fn visit_opt_jsx_closing_element(&mut self, node: &Option<JSXClosingElement>) {
        Visit::visit_opt_jsx_closing_element(&mut **self, node)
    }

    fn visit_opt_module_export_name(&mut self, node: &Option<ModuleExportName>) {
        Visit::visit_opt_module_export_name(&mut **self, node)
    }

    fn visit_opt_module_items(&mut self, node: &Option<Vec<ModuleItem>>) {
        Visit::visit_opt_module_items(&mut **self, node)
    }

    fn visit_opt_object_lit(&mut self, node: &Option<Box<ObjectLit>>) {
        Visit::visit_opt_object_lit(&mut **self, node)
    }

    fn visit_opt_pat(&mut self, node: &Option<Pat>) {
        Visit::visit_opt_pat(&mut **self, node)
    }

    fn visit_opt_span(&mut self, node: &Option<swc_common::Span>) {
        Visit::visit_opt_span(&mut **self, node)
    }

    fn visit_opt_stmt(&mut self, node: &Option<Box<Stmt>>) {
        Visit::visit_opt_stmt(&mut **self, node)
    }

    fn visit_opt_str(&mut self, node: &Option<Box<Str>>) {
        Visit::visit_opt_str(&mut **self, node)
    }

    fn visit_opt_true_plus_minus(&mut self, node: &Option<TruePlusMinus>) {
        Visit::visit_opt_true_plus_minus(&mut **self, node)
    }

    fn visit_opt_ts_entity_name(&mut self, node: &Option<TsEntityName>) {
        Visit::visit_opt_ts_entity_name(&mut **self, node)
    }

    fn visit_opt_ts_namespace_body(&mut self, node: &Option<TsNamespaceBody>) {
        Visit::visit_opt_ts_namespace_body(&mut **self, node)
    }

    fn visit_opt_ts_type(&mut self, node: &Option<Box<TsType>>) {
        Visit::visit_opt_ts_type(&mut **self, node)
    }

    fn visit_opt_ts_type_ann(&mut self, node: &Option<Box<TsTypeAnn>>) {
        Visit::visit_opt_ts_type_ann(&mut **self, node)
    }

    fn visit_opt_ts_type_param_decl(&mut self, node: &Option<Box<TsTypeParamDecl>>) {
        Visit::visit_opt_ts_type_param_decl(&mut **self, node)
    }

    fn visit_opt_ts_type_param_instantiation(
        &mut self,
        node: &Option<Box<TsTypeParamInstantiation>>,
    ) {
        Visit::visit_opt_ts_type_param_instantiation(&mut **self, node)
    }

    fn visit_opt_var_decl_or_expr(&mut self, node: &Option<VarDeclOrExpr>) {
        Visit::visit_opt_var_decl_or_expr(&mut **self, node)
    }

    fn visit_opt_vec_expr_or_spreads(&mut self, node: &[Option<ExprOrSpread>]) {
        Visit::visit_opt_vec_expr_or_spreads(&mut **self, node)
    }

    fn visit_opt_vec_pats(&mut self, node: &[Option<Pat>]) {
        Visit::visit_opt_vec_pats(&mut **self, node)
    }

    fn visit_param(&mut self, node: &Param) {
        Visit::visit_param(&mut **self, node)
    }

    fn visit_param_or_ts_param_prop(&mut self, node: &ParamOrTsParamProp) {
        Visit::visit_param_or_ts_param_prop(&mut **self, node)
    }

    fn visit_param_or_ts_param_props(&mut self, node: &[ParamOrTsParamProp]) {
        Visit::visit_param_or_ts_param_props(&mut **self, node)
    }

    fn visit_params(&mut self, node: &[Param]) {
        Visit::visit_params(&mut **self, node)
    }

    fn visit_paren_expr(&mut self, node: &ParenExpr) {
        Visit::visit_paren_expr(&mut **self, node)
    }

    fn visit_pat(&mut self, node: &Pat) {
        Visit::visit_pat(&mut **self, node)
    }

    fn visit_pats(&mut self, node: &[Pat]) {
        Visit::visit_pats(&mut **self, node)
    }

    fn visit_private_method(&mut self, node: &PrivateMethod) {
        Visit::visit_private_method(&mut **self, node)
    }

    fn visit_private_name(&mut self, node: &PrivateName) {
        Visit::visit_private_name(&mut **self, node)
    }

    fn visit_private_prop(&mut self, node: &PrivateProp) {
        Visit::visit_private_prop(&mut **self, node)
    }

    fn visit_program(&mut self, node: &Program) {
        Visit::visit_program(&mut **self, node)
    }

    fn visit_prop(&mut self, node: &Prop) {
        Visit::visit_prop(&mut **self, node)
    }

    fn visit_prop_name(&mut self, node: &PropName) {
        Visit::visit_prop_name(&mut **self, node)
    }

    fn visit_prop_or_spread(&mut self, node: &PropOrSpread) {
        Visit::visit_prop_or_spread(&mut **self, node)
    }

    fn visit_prop_or_spreads(&mut self, node: &[PropOrSpread]) {
        Visit::visit_prop_or_spreads(&mut **self, node)
    }

    fn visit_regex(&mut self, node: &Regex) {
        Visit::visit_regex(&mut **self, node)
    }

    fn visit_reserved_unused(&mut self, node: &ReservedUnused) {
        Visit::visit_reserved_unused(&mut **self, node)
    }

    fn visit_rest_pat(&mut self, node: &RestPat) {
        Visit::visit_rest_pat(&mut **self, node)
    }

    fn visit_return_stmt(&mut self, node: &ReturnStmt) {
        Visit::visit_return_stmt(&mut **self, node)
    }

    fn visit_script(&mut self, node: &Script) {
        Visit::visit_script(&mut **self, node)
    }

    fn visit_seq_expr(&mut self, node: &SeqExpr) {
        Visit::visit_seq_expr(&mut **self, node)
    }

    fn visit_setter_prop(&mut self, node: &SetterProp) {
        Visit::visit_setter_prop(&mut **self, node)
    }

    fn visit_simple_assign_target(&mut self, node: &SimpleAssignTarget) {
        Visit::visit_simple_assign_target(&mut **self, node)
    }

    fn visit_span(&mut self, node: &swc_common::Span) {
        Visit::visit_span(&mut **self, node)
    }

    fn visit_spread_element(&mut self, node: &SpreadElement) {
        Visit::visit_spread_element(&mut **self, node)
    }

    fn visit_static_block(&mut self, node: &StaticBlock) {
        Visit::visit_static_block(&mut **self, node)
    }

    fn visit_stmt(&mut self, node: &Stmt) {
        Visit::visit_stmt(&mut **self, node)
    }

    fn visit_stmts(&mut self, node: &[Stmt]) {
        Visit::visit_stmts(&mut **self, node)
    }

    fn visit_str(&mut self, node: &Str) {
        Visit::visit_str(&mut **self, node)
    }

    fn visit_super(&mut self, node: &Super) {
        Visit::visit_super(&mut **self, node)
    }

    fn visit_super_prop(&mut self, node: &SuperProp) {
        Visit::visit_super_prop(&mut **self, node)
    }

    fn visit_super_prop_expr(&mut self, node: &SuperPropExpr) {
        Visit::visit_super_prop_expr(&mut **self, node)
    }

    fn visit_switch_case(&mut self, node: &SwitchCase) {
        Visit::visit_switch_case(&mut **self, node)
    }

    fn visit_switch_cases(&mut self, node: &[SwitchCase]) {
        Visit::visit_switch_cases(&mut **self, node)
    }

    fn visit_switch_stmt(&mut self, node: &SwitchStmt) {
        Visit::visit_switch_stmt(&mut **self, node)
    }

    fn visit_syntax_context(&mut self, node: &swc_common::SyntaxContext) {
        Visit::visit_syntax_context(&mut **self, node)
    }

    fn visit_tagged_tpl(&mut self, node: &TaggedTpl) {
        Visit::visit_tagged_tpl(&mut **self, node)
    }

    fn visit_this_expr(&mut self, node: &ThisExpr) {
        Visit::visit_this_expr(&mut **self, node)
    }

    fn visit_throw_stmt(&mut self, node: &ThrowStmt) {
        Visit::visit_throw_stmt(&mut **self, node)
    }

    fn visit_tpl(&mut self, node: &Tpl) {
        Visit::visit_tpl(&mut **self, node)
    }

    fn visit_tpl_element(&mut self, node: &TplElement) {
        Visit::visit_tpl_element(&mut **self, node)
    }

    fn visit_tpl_elements(&mut self, node: &[TplElement]) {
        Visit::visit_tpl_elements(&mut **self, node)
    }

    fn visit_true_plus_minus(&mut self, node: &TruePlusMinus) {
        Visit::visit_true_plus_minus(&mut **self, node)
    }

    fn visit_try_stmt(&mut self, node: &TryStmt) {
        Visit::visit_try_stmt(&mut **self, node)
    }

    fn visit_ts_array_type(&mut self, node: &TsArrayType) {
        Visit::visit_ts_array_type(&mut **self, node)
    }

    fn visit_ts_as_expr(&mut self, node: &TsAsExpr) {
        Visit::visit_ts_as_expr(&mut **self, node)
    }

    fn visit_ts_call_signature_decl(&mut self, node: &TsCallSignatureDecl) {
        Visit::visit_ts_call_signature_decl(&mut **self, node)
    }

    fn visit_ts_conditional_type(&mut self, node: &TsConditionalType) {
        Visit::visit_ts_conditional_type(&mut **self, node)
    }

    fn visit_ts_const_assertion(&mut self, node: &TsConstAssertion) {
        Visit::visit_ts_const_assertion(&mut **self, node)
    }

    fn visit_ts_construct_signature_decl(&mut self, node: &TsConstructSignatureDecl) {
        Visit::visit_ts_construct_signature_decl(&mut **self, node)
    }

    fn visit_ts_constructor_type(&mut self, node: &TsConstructorType) {
        Visit::visit_ts_constructor_type(&mut **self, node)
    }

    fn visit_ts_entity_name(&mut self, node: &TsEntityName) {
        Visit::visit_ts_entity_name(&mut **self, node)
    }

    fn visit_ts_enum_decl(&mut self, node: &TsEnumDecl) {
        Visit::visit_ts_enum_decl(&mut **self, node)
    }

    fn visit_ts_enum_member(&mut self, node: &TsEnumMember) {
        Visit::visit_ts_enum_member(&mut **self, node)
    }

    fn visit_ts_enum_member_id(&mut self, node: &TsEnumMemberId) {
        Visit::visit_ts_enum_member_id(&mut **self, node)
    }

    fn visit_ts_enum_members(&mut self, node: &[TsEnumMember]) {
        Visit::visit_ts_enum_members(&mut **self, node)
    }

    fn visit_ts_export_assignment(&mut self, node: &TsExportAssignment) {
        Visit::visit_ts_export_assignment(&mut **self, node)
    }

    fn visit_ts_expr_with_type_args(&mut self, node: &TsExprWithTypeArgs) {
        Visit::visit_ts_expr_with_type_args(&mut **self, node)
    }

    fn visit_ts_expr_with_type_argss(&mut self, node: &[TsExprWithTypeArgs]) {
        Visit::visit_ts_expr_with_type_argss(&mut **self, node)
    }

    fn visit_ts_external_module_ref(&mut self, node: &TsExternalModuleRef) {
        Visit::visit_ts_external_module_ref(&mut **self, node)
    }

    fn visit_ts_fn_or_constructor_type(&mut self, node: &TsFnOrConstructorType) {
        Visit::visit_ts_fn_or_constructor_type(&mut **self, node)
    }

    fn visit_ts_fn_param(&mut self, node: &TsFnParam) {
        Visit::visit_ts_fn_param(&mut **self, node)
    }

    fn visit_ts_fn_params(&mut self, node: &[TsFnParam]) {
        Visit::visit_ts_fn_params(&mut **self, node)
    }

    fn visit_ts_fn_type(&mut self, node: &TsFnType) {
        Visit::visit_ts_fn_type(&mut **self, node)
    }

    fn visit_ts_getter_signature(&mut self, node: &TsGetterSignature) {
        Visit::visit_ts_getter_signature(&mut **self, node)
    }

    fn visit_ts_import_equals_decl(&mut self, node: &TsImportEqualsDecl) {
        Visit::visit_ts_import_equals_decl(&mut **self, node)
    }

    fn visit_ts_import_type(&mut self, node: &TsImportType) {
        Visit::visit_ts_import_type(&mut **self, node)
    }

    fn visit_ts_index_signature(&mut self, node: &TsIndexSignature) {
        Visit::visit_ts_index_signature(&mut **self, node)
    }

    fn visit_ts_indexed_access_type(&mut self, node: &TsIndexedAccessType) {
        Visit::visit_ts_indexed_access_type(&mut **self, node)
    }

    fn visit_ts_infer_type(&mut self, node: &TsInferType) {
        Visit::visit_ts_infer_type(&mut **self, node)
    }

    fn visit_ts_instantiation(&mut self, node: &TsInstantiation) {
        Visit::visit_ts_instantiation(&mut **self, node)
    }

    fn visit_ts_interface_body(&mut self, node: &TsInterfaceBody) {
        Visit::visit_ts_interface_body(&mut **self, node)
    }

    fn visit_ts_interface_decl(&mut self, node: &TsInterfaceDecl) {
        Visit::visit_ts_interface_decl(&mut **self, node)
    }

    fn visit_ts_intersection_type(&mut self, node: &TsIntersectionType) {
        Visit::visit_ts_intersection_type(&mut **self, node)
    }

    fn visit_ts_keyword_type(&mut self, node: &TsKeywordType) {
        Visit::visit_ts_keyword_type(&mut **self, node)
    }

    fn visit_ts_keyword_type_kind(&mut self, node: &TsKeywordTypeKind) {
        Visit::visit_ts_keyword_type_kind(&mut **self, node)
    }

    fn visit_ts_lit(&mut self, node: &TsLit) {
        Visit::visit_ts_lit(&mut **self, node)
    }

    fn visit_ts_lit_type(&mut self, node: &TsLitType) {
        Visit::visit_ts_lit_type(&mut **self, node)
    }

    fn visit_ts_mapped_type(&mut self, node: &TsMappedType) {
        Visit::visit_ts_mapped_type(&mut **self, node)
    }

    fn visit_ts_method_signature(&mut self, node: &TsMethodSignature) {
        Visit::visit_ts_method_signature(&mut **self, node)
    }

    fn visit_ts_module_block(&mut self, node: &TsModuleBlock) {
        Visit::visit_ts_module_block(&mut **self, node)
    }

    fn visit_ts_module_decl(&mut self, node: &TsModuleDecl) {
        Visit::visit_ts_module_decl(&mut **self, node)
    }

    fn visit_ts_module_name(&mut self, node: &TsModuleName) {
        Visit::visit_ts_module_name(&mut **self, node)
    }

    fn visit_ts_module_ref(&mut self, node: &TsModuleRef) {
        Visit::visit_ts_module_ref(&mut **self, node)
    }

    fn visit_ts_namespace_body(&mut self, node: &TsNamespaceBody) {
        Visit::visit_ts_namespace_body(&mut **self, node)
    }

    fn visit_ts_namespace_decl(&mut self, node: &TsNamespaceDecl) {
        Visit::visit_ts_namespace_decl(&mut **self, node)
    }

    fn visit_ts_namespace_export_decl(&mut self, node: &TsNamespaceExportDecl) {
        Visit::visit_ts_namespace_export_decl(&mut **self, node)
    }

    fn visit_ts_non_null_expr(&mut self, node: &TsNonNullExpr) {
        Visit::visit_ts_non_null_expr(&mut **self, node)
    }

    fn visit_ts_optional_type(&mut self, node: &TsOptionalType) {
        Visit::visit_ts_optional_type(&mut **self, node)
    }

    fn visit_ts_param_prop(&mut self, node: &TsParamProp) {
        Visit::visit_ts_param_prop(&mut **self, node)
    }

    fn visit_ts_param_prop_param(&mut self, node: &TsParamPropParam) {
        Visit::visit_ts_param_prop_param(&mut **self, node)
    }

    fn visit_ts_parenthesized_type(&mut self, node: &TsParenthesizedType) {
        Visit::visit_ts_parenthesized_type(&mut **self, node)
    }

    fn visit_ts_property_signature(&mut self, node: &TsPropertySignature) {
        Visit::visit_ts_property_signature(&mut **self, node)
    }

    fn visit_ts_qualified_name(&mut self, node: &TsQualifiedName) {
        Visit::visit_ts_qualified_name(&mut **self, node)
    }

    fn visit_ts_rest_type(&mut self, node: &TsRestType) {
        Visit::visit_ts_rest_type(&mut **self, node)
    }

    fn visit_ts_satisfies_expr(&mut self, node: &TsSatisfiesExpr) {
        Visit::visit_ts_satisfies_expr(&mut **self, node)
    }

    fn visit_ts_setter_signature(&mut self, node: &TsSetterSignature) {
        Visit::visit_ts_setter_signature(&mut **self, node)
    }

    fn visit_ts_this_type(&mut self, node: &TsThisType) {
        Visit::visit_ts_this_type(&mut **self, node)
    }

    fn visit_ts_this_type_or_ident(&mut self, node: &TsThisTypeOrIdent) {
        Visit::visit_ts_this_type_or_ident(&mut **self, node)
    }

    fn visit_ts_tpl_lit_type(&mut self, node: &TsTplLitType) {
        Visit::visit_ts_tpl_lit_type(&mut **self, node)
    }

    fn visit_ts_tuple_element(&mut self, node: &TsTupleElement) {
        Visit::visit_ts_tuple_element(&mut **self, node)
    }

    fn visit_ts_tuple_elements(&mut self, node: &[TsTupleElement]) {
        Visit::visit_ts_tuple_elements(&mut **self, node)
    }

    fn visit_ts_tuple_type(&mut self, node: &TsTupleType) {
        Visit::visit_ts_tuple_type(&mut **self, node)
    }

    fn visit_ts_type(&mut self, node: &TsType) {
        Visit::visit_ts_type(&mut **self, node)
    }

    fn visit_ts_type_alias_decl(&mut self, node: &TsTypeAliasDecl) {
        Visit::visit_ts_type_alias_decl(&mut **self, node)
    }

    fn visit_ts_type_ann(&mut self, node: &TsTypeAnn) {
        Visit::visit_ts_type_ann(&mut **self, node)
    }

    fn visit_ts_type_assertion(&mut self, node: &TsTypeAssertion) {
        Visit::visit_ts_type_assertion(&mut **self, node)
    }

    fn visit_ts_type_element(&mut self, node: &TsTypeElement) {
        Visit::visit_ts_type_element(&mut **self, node)
    }

    fn visit_ts_type_elements(&mut self, node: &[TsTypeElement]) {
        Visit::visit_ts_type_elements(&mut **self, node)
    }

    fn visit_ts_type_lit(&mut self, node: &TsTypeLit) {
        Visit::visit_ts_type_lit(&mut **self, node)
    }

    fn visit_ts_type_operator(&mut self, node: &TsTypeOperator) {
        Visit::visit_ts_type_operator(&mut **self, node)
    }

    fn visit_ts_type_operator_op(&mut self, node: &TsTypeOperatorOp) {
        Visit::visit_ts_type_operator_op(&mut **self, node)
    }

    fn visit_ts_type_param(&mut self, node: &TsTypeParam) {
        Visit::visit_ts_type_param(&mut **self, node)
    }

    fn visit_ts_type_param_decl(&mut self, node: &TsTypeParamDecl) {
        Visit::visit_ts_type_param_decl(&mut **self, node)
    }

    fn visit_ts_type_param_instantiation(&mut self, node: &TsTypeParamInstantiation) {
        Visit::visit_ts_type_param_instantiation(&mut **self, node)
    }

    fn visit_ts_type_params(&mut self, node: &[TsTypeParam]) {
        Visit::visit_ts_type_params(&mut **self, node)
    }

    fn visit_ts_type_predicate(&mut self, node: &TsTypePredicate) {
        Visit::visit_ts_type_predicate(&mut **self, node)
    }

    fn visit_ts_type_query(&mut self, node: &TsTypeQuery) {
        Visit::visit_ts_type_query(&mut **self, node)
    }

    fn visit_ts_type_query_expr(&mut self, node: &TsTypeQueryExpr) {
        Visit::visit_ts_type_query_expr(&mut **self, node)
    }

    fn visit_ts_type_ref(&mut self, node: &TsTypeRef) {
        Visit::visit_ts_type_ref(&mut **self, node)
    }

    fn visit_ts_types(&mut self, node: &[Box<TsType>]) {
        Visit::visit_ts_types(&mut **self, node)
    }

    fn visit_ts_union_or_intersection_type(&mut self, node: &TsUnionOrIntersectionType) {
        Visit::visit_ts_union_or_intersection_type(&mut **self, node)
    }

    fn visit_ts_union_type(&mut self, node: &TsUnionType) {
        Visit::visit_ts_union_type(&mut **self, node)
    }

    fn visit_unary_expr(&mut self, node: &UnaryExpr) {
        Visit::visit_unary_expr(&mut **self, node)
    }

    fn visit_unary_op(&mut self, node: &UnaryOp) {
        Visit::visit_unary_op(&mut **self, node)
    }

    fn visit_update_expr(&mut self, node: &UpdateExpr) {
        Visit::visit_update_expr(&mut **self, node)
    }

    fn visit_update_op(&mut self, node: &UpdateOp) {
        Visit::visit_update_op(&mut **self, node)
    }

    fn visit_using_decl(&mut self, node: &UsingDecl) {
        Visit::visit_using_decl(&mut **self, node)
    }

    fn visit_var_decl(&mut self, node: &VarDecl) {
        Visit::visit_var_decl(&mut **self, node)
    }

    fn visit_var_decl_kind(&mut self, node: &VarDeclKind) {
        Visit::visit_var_decl_kind(&mut **self, node)
    }

    fn visit_var_decl_or_expr(&mut self, node: &VarDeclOrExpr) {
        Visit::visit_var_decl_or_expr(&mut **self, node)
    }

    fn visit_var_declarator(&mut self, node: &VarDeclarator) {
        Visit::visit_var_declarator(&mut **self, node)
    }

    fn visit_var_declarators(&mut self, node: &[VarDeclarator]) {
        Visit::visit_var_declarators(&mut **self, node)
    }

    fn visit_while_stmt(&mut self, node: &WhileStmt) {
        Visit::visit_while_stmt(&mut **self, node)
    }

    fn visit_with_stmt(&mut self, node: &WithStmt) {
        Visit::visit_with_stmt(&mut **self, node)
    }

    fn visit_yield_expr(&mut self, node: &YieldExpr) {
        Visit::visit_yield_expr(&mut **self, node)
    }
}
impl<A, B> Visit for ::swc_visit::Either<A, B>
where
    A: Visit,
    B: Visit,
{
    fn visit_accessibility(&mut self, node: &Accessibility) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_accessibility(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_accessibility(self, node),
        }
    }

    fn visit_array_lit(&mut self, node: &ArrayLit) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_array_lit(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_array_lit(self, node),
        }
    }

    fn visit_array_pat(&mut self, node: &ArrayPat) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_array_pat(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_array_pat(self, node),
        }
    }

    fn visit_arrow_expr(&mut self, node: &ArrowExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_arrow_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_arrow_expr(self, node),
        }
    }

    fn visit_assign_expr(&mut self, node: &AssignExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_assign_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_assign_expr(self, node),
        }
    }

    fn visit_assign_op(&mut self, node: &AssignOp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_assign_op(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_assign_op(self, node),
        }
    }

    fn visit_assign_pat(&mut self, node: &AssignPat) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_assign_pat(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_assign_pat(self, node),
        }
    }

    fn visit_assign_pat_prop(&mut self, node: &AssignPatProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_assign_pat_prop(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_assign_pat_prop(self, node),
        }
    }

    fn visit_assign_prop(&mut self, node: &AssignProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_assign_prop(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_assign_prop(self, node),
        }
    }

    fn visit_assign_target(&mut self, node: &AssignTarget) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_assign_target(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_assign_target(self, node),
        }
    }

    fn visit_assign_target_pat(&mut self, node: &AssignTargetPat) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_assign_target_pat(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_assign_target_pat(self, node),
        }
    }

    fn visit_atom(&mut self, node: &swc_atoms::Atom) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_atom(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_atom(self, node),
        }
    }

    fn visit_auto_accessor(&mut self, node: &AutoAccessor) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_auto_accessor(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_auto_accessor(self, node),
        }
    }

    fn visit_await_expr(&mut self, node: &AwaitExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_await_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_await_expr(self, node),
        }
    }

    fn visit_big_int(&mut self, node: &BigInt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_big_int(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_big_int(self, node),
        }
    }

    fn visit_big_int_value(&mut self, node: &BigIntValue) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_big_int_value(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_big_int_value(self, node),
        }
    }

    fn visit_bin_expr(&mut self, node: &BinExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_bin_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_bin_expr(self, node),
        }
    }

    fn visit_binary_op(&mut self, node: &BinaryOp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_binary_op(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_binary_op(self, node),
        }
    }

    fn visit_binding_ident(&mut self, node: &BindingIdent) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_binding_ident(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_binding_ident(self, node),
        }
    }

    fn visit_block_stmt(&mut self, node: &BlockStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_block_stmt(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_block_stmt(self, node),
        }
    }

    fn visit_block_stmt_or_expr(&mut self, node: &BlockStmtOrExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_block_stmt_or_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_block_stmt_or_expr(self, node),
        }
    }

    fn visit_bool(&mut self, node: &Bool) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_bool(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_bool(self, node),
        }
    }

    fn visit_break_stmt(&mut self, node: &BreakStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_break_stmt(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_break_stmt(self, node),
        }
    }

    fn visit_call_expr(&mut self, node: &CallExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_call_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_call_expr(self, node),
        }
    }

    fn visit_callee(&mut self, node: &Callee) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_callee(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_callee(self, node),
        }
    }

    fn visit_catch_clause(&mut self, node: &CatchClause) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_catch_clause(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_catch_clause(self, node),
        }
    }

    fn visit_class(&mut self, node: &Class) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_class(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_class(self, node),
        }
    }

    fn visit_class_decl(&mut self, node: &ClassDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_class_decl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_class_decl(self, node),
        }
    }

    fn visit_class_expr(&mut self, node: &ClassExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_class_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_class_expr(self, node),
        }
    }

    fn visit_class_member(&mut self, node: &ClassMember) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_class_member(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_class_member(self, node),
        }
    }

    fn visit_class_members(&mut self, node: &[ClassMember]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_class_members(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_class_members(self, node),
        }
    }

    fn visit_class_method(&mut self, node: &ClassMethod) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_class_method(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_class_method(self, node),
        }
    }

    fn visit_class_prop(&mut self, node: &ClassProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_class_prop(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_class_prop(self, node),
        }
    }

    fn visit_computed_prop_name(&mut self, node: &ComputedPropName) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_computed_prop_name(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_computed_prop_name(self, node),
        }
    }

    fn visit_cond_expr(&mut self, node: &CondExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_cond_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_cond_expr(self, node),
        }
    }

    fn visit_constructor(&mut self, node: &Constructor) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_constructor(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_constructor(self, node),
        }
    }

    fn visit_continue_stmt(&mut self, node: &ContinueStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_continue_stmt(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_continue_stmt(self, node),
        }
    }

    fn visit_debugger_stmt(&mut self, node: &DebuggerStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_debugger_stmt(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_debugger_stmt(self, node),
        }
    }

    fn visit_decl(&mut self, node: &Decl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_decl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_decl(self, node),
        }
    }

    fn visit_decorator(&mut self, node: &Decorator) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_decorator(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_decorator(self, node),
        }
    }

    fn visit_decorators(&mut self, node: &[Decorator]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_decorators(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_decorators(self, node),
        }
    }

    fn visit_default_decl(&mut self, node: &DefaultDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_default_decl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_default_decl(self, node),
        }
    }

    fn visit_do_while_stmt(&mut self, node: &DoWhileStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_do_while_stmt(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_do_while_stmt(self, node),
        }
    }

    fn visit_empty_stmt(&mut self, node: &EmptyStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_empty_stmt(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_empty_stmt(self, node),
        }
    }

    fn visit_es_version(&mut self, node: &EsVersion) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_es_version(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_es_version(self, node),
        }
    }

    fn visit_export_all(&mut self, node: &ExportAll) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_export_all(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_export_all(self, node),
        }
    }

    fn visit_export_decl(&mut self, node: &ExportDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_export_decl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_export_decl(self, node),
        }
    }

    fn visit_export_default_decl(&mut self, node: &ExportDefaultDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_export_default_decl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_export_default_decl(self, node),
        }
    }

    fn visit_export_default_expr(&mut self, node: &ExportDefaultExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_export_default_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_export_default_expr(self, node),
        }
    }

    fn visit_export_default_specifier(&mut self, node: &ExportDefaultSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_export_default_specifier(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_export_default_specifier(self, node),
        }
    }

    fn visit_export_named_specifier(&mut self, node: &ExportNamedSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_export_named_specifier(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_export_named_specifier(self, node),
        }
    }

    fn visit_export_namespace_specifier(&mut self, node: &ExportNamespaceSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_export_namespace_specifier(self, node),
            swc_visit::Either::Right(visitor) => {
                Visit::visit_export_namespace_specifier(self, node)
            }
        }
    }

    fn visit_export_specifier(&mut self, node: &ExportSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_export_specifier(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_export_specifier(self, node),
        }
    }

    fn visit_export_specifiers(&mut self, node: &[ExportSpecifier]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_export_specifiers(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_export_specifiers(self, node),
        }
    }

    fn visit_expr(&mut self, node: &Expr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_expr(self, node),
        }
    }

    fn visit_expr_or_spread(&mut self, node: &ExprOrSpread) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_expr_or_spread(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_expr_or_spread(self, node),
        }
    }

    fn visit_expr_or_spreads(&mut self, node: &[ExprOrSpread]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_expr_or_spreads(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_expr_or_spreads(self, node),
        }
    }

    fn visit_expr_stmt(&mut self, node: &ExprStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_expr_stmt(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_expr_stmt(self, node),
        }
    }

    fn visit_exprs(&mut self, node: &[Box<Expr>]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_exprs(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_exprs(self, node),
        }
    }

    fn visit_fn_decl(&mut self, node: &FnDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_fn_decl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_fn_decl(self, node),
        }
    }

    fn visit_fn_expr(&mut self, node: &FnExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_fn_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_fn_expr(self, node),
        }
    }

    fn visit_for_head(&mut self, node: &ForHead) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_for_head(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_for_head(self, node),
        }
    }

    fn visit_for_in_stmt(&mut self, node: &ForInStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_for_in_stmt(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_for_in_stmt(self, node),
        }
    }

    fn visit_for_of_stmt(&mut self, node: &ForOfStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_for_of_stmt(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_for_of_stmt(self, node),
        }
    }

    fn visit_for_stmt(&mut self, node: &ForStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_for_stmt(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_for_stmt(self, node),
        }
    }

    fn visit_function(&mut self, node: &Function) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_function(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_function(self, node),
        }
    }

    fn visit_getter_prop(&mut self, node: &GetterProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_getter_prop(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_getter_prop(self, node),
        }
    }

    fn visit_ident(&mut self, node: &Ident) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ident(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ident(self, node),
        }
    }

    fn visit_ident_name(&mut self, node: &IdentName) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ident_name(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ident_name(self, node),
        }
    }

    fn visit_if_stmt(&mut self, node: &IfStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_if_stmt(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_if_stmt(self, node),
        }
    }

    fn visit_import(&mut self, node: &Import) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_import(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_import(self, node),
        }
    }

    fn visit_import_decl(&mut self, node: &ImportDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_import_decl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_import_decl(self, node),
        }
    }

    fn visit_import_default_specifier(&mut self, node: &ImportDefaultSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_import_default_specifier(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_import_default_specifier(self, node),
        }
    }

    fn visit_import_named_specifier(&mut self, node: &ImportNamedSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_import_named_specifier(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_import_named_specifier(self, node),
        }
    }

    fn visit_import_phase(&mut self, node: &ImportPhase) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_import_phase(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_import_phase(self, node),
        }
    }

    fn visit_import_specifier(&mut self, node: &ImportSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_import_specifier(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_import_specifier(self, node),
        }
    }

    fn visit_import_specifiers(&mut self, node: &[ImportSpecifier]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_import_specifiers(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_import_specifiers(self, node),
        }
    }

    fn visit_import_star_as_specifier(&mut self, node: &ImportStarAsSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_import_star_as_specifier(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_import_star_as_specifier(self, node),
        }
    }

    fn visit_import_with(&mut self, node: &ImportWith) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_import_with(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_import_with(self, node),
        }
    }

    fn visit_import_with_item(&mut self, node: &ImportWithItem) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_import_with_item(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_import_with_item(self, node),
        }
    }

    fn visit_import_with_items(&mut self, node: &[ImportWithItem]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_import_with_items(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_import_with_items(self, node),
        }
    }

    fn visit_invalid(&mut self, node: &Invalid) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_invalid(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_invalid(self, node),
        }
    }

    fn visit_jsx_attr(&mut self, node: &JSXAttr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_attr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_attr(self, node),
        }
    }

    fn visit_jsx_attr_name(&mut self, node: &JSXAttrName) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_attr_name(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_attr_name(self, node),
        }
    }

    fn visit_jsx_attr_or_spread(&mut self, node: &JSXAttrOrSpread) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_attr_or_spread(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_attr_or_spread(self, node),
        }
    }

    fn visit_jsx_attr_or_spreads(&mut self, node: &[JSXAttrOrSpread]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_attr_or_spreads(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_attr_or_spreads(self, node),
        }
    }

    fn visit_jsx_attr_value(&mut self, node: &JSXAttrValue) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_attr_value(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_attr_value(self, node),
        }
    }

    fn visit_jsx_closing_element(&mut self, node: &JSXClosingElement) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_closing_element(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_closing_element(self, node),
        }
    }

    fn visit_jsx_closing_fragment(&mut self, node: &JSXClosingFragment) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_closing_fragment(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_closing_fragment(self, node),
        }
    }

    fn visit_jsx_element(&mut self, node: &JSXElement) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_element(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_element(self, node),
        }
    }

    fn visit_jsx_element_child(&mut self, node: &JSXElementChild) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_element_child(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_element_child(self, node),
        }
    }

    fn visit_jsx_element_childs(&mut self, node: &[JSXElementChild]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_element_childs(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_element_childs(self, node),
        }
    }

    fn visit_jsx_element_name(&mut self, node: &JSXElementName) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_element_name(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_element_name(self, node),
        }
    }

    fn visit_jsx_empty_expr(&mut self, node: &JSXEmptyExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_empty_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_empty_expr(self, node),
        }
    }

    fn visit_jsx_expr(&mut self, node: &JSXExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_expr(self, node),
        }
    }

    fn visit_jsx_expr_container(&mut self, node: &JSXExprContainer) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_expr_container(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_expr_container(self, node),
        }
    }

    fn visit_jsx_fragment(&mut self, node: &JSXFragment) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_fragment(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_fragment(self, node),
        }
    }

    fn visit_jsx_member_expr(&mut self, node: &JSXMemberExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_member_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_member_expr(self, node),
        }
    }

    fn visit_jsx_namespaced_name(&mut self, node: &JSXNamespacedName) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_namespaced_name(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_namespaced_name(self, node),
        }
    }

    fn visit_jsx_object(&mut self, node: &JSXObject) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_object(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_object(self, node),
        }
    }

    fn visit_jsx_opening_element(&mut self, node: &JSXOpeningElement) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_opening_element(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_opening_element(self, node),
        }
    }

    fn visit_jsx_opening_fragment(&mut self, node: &JSXOpeningFragment) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_opening_fragment(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_opening_fragment(self, node),
        }
    }

    fn visit_jsx_spread_child(&mut self, node: &JSXSpreadChild) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_spread_child(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_spread_child(self, node),
        }
    }

    fn visit_jsx_text(&mut self, node: &JSXText) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_jsx_text(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_jsx_text(self, node),
        }
    }

    fn visit_key(&mut self, node: &Key) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_key(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_key(self, node),
        }
    }

    fn visit_key_value_pat_prop(&mut self, node: &KeyValuePatProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_key_value_pat_prop(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_key_value_pat_prop(self, node),
        }
    }

    fn visit_key_value_prop(&mut self, node: &KeyValueProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_key_value_prop(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_key_value_prop(self, node),
        }
    }

    fn visit_labeled_stmt(&mut self, node: &LabeledStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_labeled_stmt(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_labeled_stmt(self, node),
        }
    }

    fn visit_lit(&mut self, node: &Lit) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_lit(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_lit(self, node),
        }
    }

    fn visit_member_expr(&mut self, node: &MemberExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_member_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_member_expr(self, node),
        }
    }

    fn visit_member_prop(&mut self, node: &MemberProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_member_prop(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_member_prop(self, node),
        }
    }

    fn visit_meta_prop_expr(&mut self, node: &MetaPropExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_meta_prop_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_meta_prop_expr(self, node),
        }
    }

    fn visit_meta_prop_kind(&mut self, node: &MetaPropKind) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_meta_prop_kind(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_meta_prop_kind(self, node),
        }
    }

    fn visit_method_kind(&mut self, node: &MethodKind) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_method_kind(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_method_kind(self, node),
        }
    }

    fn visit_method_prop(&mut self, node: &MethodProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_method_prop(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_method_prop(self, node),
        }
    }

    fn visit_module(&mut self, node: &Module) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_module(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_module(self, node),
        }
    }

    fn visit_module_decl(&mut self, node: &ModuleDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_module_decl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_module_decl(self, node),
        }
    }

    fn visit_module_export_name(&mut self, node: &ModuleExportName) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_module_export_name(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_module_export_name(self, node),
        }
    }

    fn visit_module_item(&mut self, node: &ModuleItem) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_module_item(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_module_item(self, node),
        }
    }

    fn visit_module_items(&mut self, node: &[ModuleItem]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_module_items(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_module_items(self, node),
        }
    }

    fn visit_named_export(&mut self, node: &NamedExport) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_named_export(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_named_export(self, node),
        }
    }

    fn visit_new_expr(&mut self, node: &NewExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_new_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_new_expr(self, node),
        }
    }

    fn visit_null(&mut self, node: &Null) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_null(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_null(self, node),
        }
    }

    fn visit_number(&mut self, node: &Number) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_number(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_number(self, node),
        }
    }

    fn visit_object_lit(&mut self, node: &ObjectLit) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_object_lit(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_object_lit(self, node),
        }
    }

    fn visit_object_pat(&mut self, node: &ObjectPat) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_object_pat(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_object_pat(self, node),
        }
    }

    fn visit_object_pat_prop(&mut self, node: &ObjectPatProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_object_pat_prop(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_object_pat_prop(self, node),
        }
    }

    fn visit_object_pat_props(&mut self, node: &[ObjectPatProp]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_object_pat_props(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_object_pat_props(self, node),
        }
    }

    fn visit_opt_accessibility(&mut self, node: &Option<Accessibility>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_accessibility(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_accessibility(self, node),
        }
    }

    fn visit_opt_atom(&mut self, node: &Option<swc_atoms::Atom>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_atom(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_atom(self, node),
        }
    }

    fn visit_opt_block_stmt(&mut self, node: &Option<BlockStmt>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_block_stmt(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_block_stmt(self, node),
        }
    }

    fn visit_opt_call(&mut self, node: &OptCall) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_call(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_call(self, node),
        }
    }

    fn visit_opt_catch_clause(&mut self, node: &Option<CatchClause>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_catch_clause(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_catch_clause(self, node),
        }
    }

    fn visit_opt_chain_base(&mut self, node: &OptChainBase) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_chain_base(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_chain_base(self, node),
        }
    }

    fn visit_opt_chain_expr(&mut self, node: &OptChainExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_chain_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_chain_expr(self, node),
        }
    }

    fn visit_opt_expr(&mut self, node: &Option<Box<Expr>>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_expr(self, node),
        }
    }

    fn visit_opt_expr_or_spread(&mut self, node: &Option<ExprOrSpread>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_expr_or_spread(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_expr_or_spread(self, node),
        }
    }

    fn visit_opt_expr_or_spreads(&mut self, node: &Option<Vec<ExprOrSpread>>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_expr_or_spreads(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_expr_or_spreads(self, node),
        }
    }

    fn visit_opt_ident(&mut self, node: &Option<Ident>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_ident(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_ident(self, node),
        }
    }

    fn visit_opt_jsx_attr_value(&mut self, node: &Option<JSXAttrValue>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_jsx_attr_value(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_jsx_attr_value(self, node),
        }
    }

    fn visit_opt_jsx_closing_element(&mut self, node: &Option<JSXClosingElement>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_jsx_closing_element(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_jsx_closing_element(self, node),
        }
    }

    fn visit_opt_module_export_name(&mut self, node: &Option<ModuleExportName>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_module_export_name(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_module_export_name(self, node),
        }
    }

    fn visit_opt_module_items(&mut self, node: &Option<Vec<ModuleItem>>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_module_items(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_module_items(self, node),
        }
    }

    fn visit_opt_object_lit(&mut self, node: &Option<Box<ObjectLit>>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_object_lit(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_object_lit(self, node),
        }
    }

    fn visit_opt_pat(&mut self, node: &Option<Pat>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_pat(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_pat(self, node),
        }
    }

    fn visit_opt_span(&mut self, node: &Option<swc_common::Span>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_span(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_span(self, node),
        }
    }

    fn visit_opt_stmt(&mut self, node: &Option<Box<Stmt>>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_stmt(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_stmt(self, node),
        }
    }

    fn visit_opt_str(&mut self, node: &Option<Box<Str>>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_str(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_str(self, node),
        }
    }

    fn visit_opt_true_plus_minus(&mut self, node: &Option<TruePlusMinus>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_true_plus_minus(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_true_plus_minus(self, node),
        }
    }

    fn visit_opt_ts_entity_name(&mut self, node: &Option<TsEntityName>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_ts_entity_name(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_ts_entity_name(self, node),
        }
    }

    fn visit_opt_ts_namespace_body(&mut self, node: &Option<TsNamespaceBody>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_ts_namespace_body(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_ts_namespace_body(self, node),
        }
    }

    fn visit_opt_ts_type(&mut self, node: &Option<Box<TsType>>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_ts_type(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_ts_type(self, node),
        }
    }

    fn visit_opt_ts_type_ann(&mut self, node: &Option<Box<TsTypeAnn>>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_ts_type_ann(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_ts_type_ann(self, node),
        }
    }

    fn visit_opt_ts_type_param_decl(&mut self, node: &Option<Box<TsTypeParamDecl>>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_ts_type_param_decl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_ts_type_param_decl(self, node),
        }
    }

    fn visit_opt_ts_type_param_instantiation(
        &mut self,
        node: &Option<Box<TsTypeParamInstantiation>>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                Visit::visit_opt_ts_type_param_instantiation(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                Visit::visit_opt_ts_type_param_instantiation(self, node)
            }
        }
    }

    fn visit_opt_var_decl_or_expr(&mut self, node: &Option<VarDeclOrExpr>) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_var_decl_or_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_var_decl_or_expr(self, node),
        }
    }

    fn visit_opt_vec_expr_or_spreads(&mut self, node: &[Option<ExprOrSpread>]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_vec_expr_or_spreads(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_vec_expr_or_spreads(self, node),
        }
    }

    fn visit_opt_vec_pats(&mut self, node: &[Option<Pat>]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_opt_vec_pats(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_opt_vec_pats(self, node),
        }
    }

    fn visit_param(&mut self, node: &Param) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_param(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_param(self, node),
        }
    }

    fn visit_param_or_ts_param_prop(&mut self, node: &ParamOrTsParamProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_param_or_ts_param_prop(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_param_or_ts_param_prop(self, node),
        }
    }

    fn visit_param_or_ts_param_props(&mut self, node: &[ParamOrTsParamProp]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_param_or_ts_param_props(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_param_or_ts_param_props(self, node),
        }
    }

    fn visit_params(&mut self, node: &[Param]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_params(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_params(self, node),
        }
    }

    fn visit_paren_expr(&mut self, node: &ParenExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_paren_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_paren_expr(self, node),
        }
    }

    fn visit_pat(&mut self, node: &Pat) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_pat(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_pat(self, node),
        }
    }

    fn visit_pats(&mut self, node: &[Pat]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_pats(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_pats(self, node),
        }
    }

    fn visit_private_method(&mut self, node: &PrivateMethod) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_private_method(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_private_method(self, node),
        }
    }

    fn visit_private_name(&mut self, node: &PrivateName) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_private_name(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_private_name(self, node),
        }
    }

    fn visit_private_prop(&mut self, node: &PrivateProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_private_prop(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_private_prop(self, node),
        }
    }

    fn visit_program(&mut self, node: &Program) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_program(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_program(self, node),
        }
    }

    fn visit_prop(&mut self, node: &Prop) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_prop(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_prop(self, node),
        }
    }

    fn visit_prop_name(&mut self, node: &PropName) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_prop_name(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_prop_name(self, node),
        }
    }

    fn visit_prop_or_spread(&mut self, node: &PropOrSpread) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_prop_or_spread(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_prop_or_spread(self, node),
        }
    }

    fn visit_prop_or_spreads(&mut self, node: &[PropOrSpread]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_prop_or_spreads(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_prop_or_spreads(self, node),
        }
    }

    fn visit_regex(&mut self, node: &Regex) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_regex(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_regex(self, node),
        }
    }

    fn visit_reserved_unused(&mut self, node: &ReservedUnused) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_reserved_unused(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_reserved_unused(self, node),
        }
    }

    fn visit_rest_pat(&mut self, node: &RestPat) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_rest_pat(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_rest_pat(self, node),
        }
    }

    fn visit_return_stmt(&mut self, node: &ReturnStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_return_stmt(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_return_stmt(self, node),
        }
    }

    fn visit_script(&mut self, node: &Script) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_script(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_script(self, node),
        }
    }

    fn visit_seq_expr(&mut self, node: &SeqExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_seq_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_seq_expr(self, node),
        }
    }

    fn visit_setter_prop(&mut self, node: &SetterProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_setter_prop(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_setter_prop(self, node),
        }
    }

    fn visit_simple_assign_target(&mut self, node: &SimpleAssignTarget) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_simple_assign_target(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_simple_assign_target(self, node),
        }
    }

    fn visit_span(&mut self, node: &swc_common::Span) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_span(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_span(self, node),
        }
    }

    fn visit_spread_element(&mut self, node: &SpreadElement) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_spread_element(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_spread_element(self, node),
        }
    }

    fn visit_static_block(&mut self, node: &StaticBlock) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_static_block(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_static_block(self, node),
        }
    }

    fn visit_stmt(&mut self, node: &Stmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_stmt(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_stmt(self, node),
        }
    }

    fn visit_stmts(&mut self, node: &[Stmt]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_stmts(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_stmts(self, node),
        }
    }

    fn visit_str(&mut self, node: &Str) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_str(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_str(self, node),
        }
    }

    fn visit_super(&mut self, node: &Super) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_super(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_super(self, node),
        }
    }

    fn visit_super_prop(&mut self, node: &SuperProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_super_prop(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_super_prop(self, node),
        }
    }

    fn visit_super_prop_expr(&mut self, node: &SuperPropExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_super_prop_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_super_prop_expr(self, node),
        }
    }

    fn visit_switch_case(&mut self, node: &SwitchCase) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_switch_case(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_switch_case(self, node),
        }
    }

    fn visit_switch_cases(&mut self, node: &[SwitchCase]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_switch_cases(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_switch_cases(self, node),
        }
    }

    fn visit_switch_stmt(&mut self, node: &SwitchStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_switch_stmt(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_switch_stmt(self, node),
        }
    }

    fn visit_syntax_context(&mut self, node: &swc_common::SyntaxContext) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_syntax_context(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_syntax_context(self, node),
        }
    }

    fn visit_tagged_tpl(&mut self, node: &TaggedTpl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_tagged_tpl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_tagged_tpl(self, node),
        }
    }

    fn visit_this_expr(&mut self, node: &ThisExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_this_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_this_expr(self, node),
        }
    }

    fn visit_throw_stmt(&mut self, node: &ThrowStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_throw_stmt(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_throw_stmt(self, node),
        }
    }

    fn visit_tpl(&mut self, node: &Tpl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_tpl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_tpl(self, node),
        }
    }

    fn visit_tpl_element(&mut self, node: &TplElement) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_tpl_element(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_tpl_element(self, node),
        }
    }

    fn visit_tpl_elements(&mut self, node: &[TplElement]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_tpl_elements(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_tpl_elements(self, node),
        }
    }

    fn visit_true_plus_minus(&mut self, node: &TruePlusMinus) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_true_plus_minus(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_true_plus_minus(self, node),
        }
    }

    fn visit_try_stmt(&mut self, node: &TryStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_try_stmt(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_try_stmt(self, node),
        }
    }

    fn visit_ts_array_type(&mut self, node: &TsArrayType) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_array_type(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_array_type(self, node),
        }
    }

    fn visit_ts_as_expr(&mut self, node: &TsAsExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_as_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_as_expr(self, node),
        }
    }

    fn visit_ts_call_signature_decl(&mut self, node: &TsCallSignatureDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_call_signature_decl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_call_signature_decl(self, node),
        }
    }

    fn visit_ts_conditional_type(&mut self, node: &TsConditionalType) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_conditional_type(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_conditional_type(self, node),
        }
    }

    fn visit_ts_const_assertion(&mut self, node: &TsConstAssertion) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_const_assertion(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_const_assertion(self, node),
        }
    }

    fn visit_ts_construct_signature_decl(&mut self, node: &TsConstructSignatureDecl) {
        match self {
            swc_visit::Either::Left(visitor) => {
                Visit::visit_ts_construct_signature_decl(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                Visit::visit_ts_construct_signature_decl(self, node)
            }
        }
    }

    fn visit_ts_constructor_type(&mut self, node: &TsConstructorType) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_constructor_type(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_constructor_type(self, node),
        }
    }

    fn visit_ts_entity_name(&mut self, node: &TsEntityName) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_entity_name(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_entity_name(self, node),
        }
    }

    fn visit_ts_enum_decl(&mut self, node: &TsEnumDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_enum_decl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_enum_decl(self, node),
        }
    }

    fn visit_ts_enum_member(&mut self, node: &TsEnumMember) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_enum_member(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_enum_member(self, node),
        }
    }

    fn visit_ts_enum_member_id(&mut self, node: &TsEnumMemberId) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_enum_member_id(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_enum_member_id(self, node),
        }
    }

    fn visit_ts_enum_members(&mut self, node: &[TsEnumMember]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_enum_members(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_enum_members(self, node),
        }
    }

    fn visit_ts_export_assignment(&mut self, node: &TsExportAssignment) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_export_assignment(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_export_assignment(self, node),
        }
    }

    fn visit_ts_expr_with_type_args(&mut self, node: &TsExprWithTypeArgs) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_expr_with_type_args(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_expr_with_type_args(self, node),
        }
    }

    fn visit_ts_expr_with_type_argss(&mut self, node: &[TsExprWithTypeArgs]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_expr_with_type_argss(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_expr_with_type_argss(self, node),
        }
    }

    fn visit_ts_external_module_ref(&mut self, node: &TsExternalModuleRef) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_external_module_ref(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_external_module_ref(self, node),
        }
    }

    fn visit_ts_fn_or_constructor_type(&mut self, node: &TsFnOrConstructorType) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_fn_or_constructor_type(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_fn_or_constructor_type(self, node),
        }
    }

    fn visit_ts_fn_param(&mut self, node: &TsFnParam) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_fn_param(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_fn_param(self, node),
        }
    }

    fn visit_ts_fn_params(&mut self, node: &[TsFnParam]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_fn_params(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_fn_params(self, node),
        }
    }

    fn visit_ts_fn_type(&mut self, node: &TsFnType) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_fn_type(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_fn_type(self, node),
        }
    }

    fn visit_ts_getter_signature(&mut self, node: &TsGetterSignature) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_getter_signature(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_getter_signature(self, node),
        }
    }

    fn visit_ts_import_equals_decl(&mut self, node: &TsImportEqualsDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_import_equals_decl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_import_equals_decl(self, node),
        }
    }

    fn visit_ts_import_type(&mut self, node: &TsImportType) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_import_type(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_import_type(self, node),
        }
    }

    fn visit_ts_index_signature(&mut self, node: &TsIndexSignature) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_index_signature(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_index_signature(self, node),
        }
    }

    fn visit_ts_indexed_access_type(&mut self, node: &TsIndexedAccessType) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_indexed_access_type(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_indexed_access_type(self, node),
        }
    }

    fn visit_ts_infer_type(&mut self, node: &TsInferType) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_infer_type(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_infer_type(self, node),
        }
    }

    fn visit_ts_instantiation(&mut self, node: &TsInstantiation) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_instantiation(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_instantiation(self, node),
        }
    }

    fn visit_ts_interface_body(&mut self, node: &TsInterfaceBody) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_interface_body(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_interface_body(self, node),
        }
    }

    fn visit_ts_interface_decl(&mut self, node: &TsInterfaceDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_interface_decl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_interface_decl(self, node),
        }
    }

    fn visit_ts_intersection_type(&mut self, node: &TsIntersectionType) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_intersection_type(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_intersection_type(self, node),
        }
    }

    fn visit_ts_keyword_type(&mut self, node: &TsKeywordType) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_keyword_type(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_keyword_type(self, node),
        }
    }

    fn visit_ts_keyword_type_kind(&mut self, node: &TsKeywordTypeKind) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_keyword_type_kind(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_keyword_type_kind(self, node),
        }
    }

    fn visit_ts_lit(&mut self, node: &TsLit) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_lit(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_lit(self, node),
        }
    }

    fn visit_ts_lit_type(&mut self, node: &TsLitType) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_lit_type(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_lit_type(self, node),
        }
    }

    fn visit_ts_mapped_type(&mut self, node: &TsMappedType) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_mapped_type(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_mapped_type(self, node),
        }
    }

    fn visit_ts_method_signature(&mut self, node: &TsMethodSignature) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_method_signature(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_method_signature(self, node),
        }
    }

    fn visit_ts_module_block(&mut self, node: &TsModuleBlock) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_module_block(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_module_block(self, node),
        }
    }

    fn visit_ts_module_decl(&mut self, node: &TsModuleDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_module_decl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_module_decl(self, node),
        }
    }

    fn visit_ts_module_name(&mut self, node: &TsModuleName) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_module_name(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_module_name(self, node),
        }
    }

    fn visit_ts_module_ref(&mut self, node: &TsModuleRef) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_module_ref(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_module_ref(self, node),
        }
    }

    fn visit_ts_namespace_body(&mut self, node: &TsNamespaceBody) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_namespace_body(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_namespace_body(self, node),
        }
    }

    fn visit_ts_namespace_decl(&mut self, node: &TsNamespaceDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_namespace_decl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_namespace_decl(self, node),
        }
    }

    fn visit_ts_namespace_export_decl(&mut self, node: &TsNamespaceExportDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_namespace_export_decl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_namespace_export_decl(self, node),
        }
    }

    fn visit_ts_non_null_expr(&mut self, node: &TsNonNullExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_non_null_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_non_null_expr(self, node),
        }
    }

    fn visit_ts_optional_type(&mut self, node: &TsOptionalType) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_optional_type(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_optional_type(self, node),
        }
    }

    fn visit_ts_param_prop(&mut self, node: &TsParamProp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_param_prop(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_param_prop(self, node),
        }
    }

    fn visit_ts_param_prop_param(&mut self, node: &TsParamPropParam) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_param_prop_param(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_param_prop_param(self, node),
        }
    }

    fn visit_ts_parenthesized_type(&mut self, node: &TsParenthesizedType) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_parenthesized_type(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_parenthesized_type(self, node),
        }
    }

    fn visit_ts_property_signature(&mut self, node: &TsPropertySignature) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_property_signature(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_property_signature(self, node),
        }
    }

    fn visit_ts_qualified_name(&mut self, node: &TsQualifiedName) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_qualified_name(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_qualified_name(self, node),
        }
    }

    fn visit_ts_rest_type(&mut self, node: &TsRestType) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_rest_type(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_rest_type(self, node),
        }
    }

    fn visit_ts_satisfies_expr(&mut self, node: &TsSatisfiesExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_satisfies_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_satisfies_expr(self, node),
        }
    }

    fn visit_ts_setter_signature(&mut self, node: &TsSetterSignature) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_setter_signature(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_setter_signature(self, node),
        }
    }

    fn visit_ts_this_type(&mut self, node: &TsThisType) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_this_type(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_this_type(self, node),
        }
    }

    fn visit_ts_this_type_or_ident(&mut self, node: &TsThisTypeOrIdent) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_this_type_or_ident(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_this_type_or_ident(self, node),
        }
    }

    fn visit_ts_tpl_lit_type(&mut self, node: &TsTplLitType) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_tpl_lit_type(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_tpl_lit_type(self, node),
        }
    }

    fn visit_ts_tuple_element(&mut self, node: &TsTupleElement) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_tuple_element(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_tuple_element(self, node),
        }
    }

    fn visit_ts_tuple_elements(&mut self, node: &[TsTupleElement]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_tuple_elements(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_tuple_elements(self, node),
        }
    }

    fn visit_ts_tuple_type(&mut self, node: &TsTupleType) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_tuple_type(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_tuple_type(self, node),
        }
    }

    fn visit_ts_type(&mut self, node: &TsType) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_type(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_type(self, node),
        }
    }

    fn visit_ts_type_alias_decl(&mut self, node: &TsTypeAliasDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_type_alias_decl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_type_alias_decl(self, node),
        }
    }

    fn visit_ts_type_ann(&mut self, node: &TsTypeAnn) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_type_ann(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_type_ann(self, node),
        }
    }

    fn visit_ts_type_assertion(&mut self, node: &TsTypeAssertion) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_type_assertion(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_type_assertion(self, node),
        }
    }

    fn visit_ts_type_element(&mut self, node: &TsTypeElement) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_type_element(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_type_element(self, node),
        }
    }

    fn visit_ts_type_elements(&mut self, node: &[TsTypeElement]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_type_elements(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_type_elements(self, node),
        }
    }

    fn visit_ts_type_lit(&mut self, node: &TsTypeLit) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_type_lit(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_type_lit(self, node),
        }
    }

    fn visit_ts_type_operator(&mut self, node: &TsTypeOperator) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_type_operator(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_type_operator(self, node),
        }
    }

    fn visit_ts_type_operator_op(&mut self, node: &TsTypeOperatorOp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_type_operator_op(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_type_operator_op(self, node),
        }
    }

    fn visit_ts_type_param(&mut self, node: &TsTypeParam) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_type_param(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_type_param(self, node),
        }
    }

    fn visit_ts_type_param_decl(&mut self, node: &TsTypeParamDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_type_param_decl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_type_param_decl(self, node),
        }
    }

    fn visit_ts_type_param_instantiation(&mut self, node: &TsTypeParamInstantiation) {
        match self {
            swc_visit::Either::Left(visitor) => {
                Visit::visit_ts_type_param_instantiation(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                Visit::visit_ts_type_param_instantiation(self, node)
            }
        }
    }

    fn visit_ts_type_params(&mut self, node: &[TsTypeParam]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_type_params(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_type_params(self, node),
        }
    }

    fn visit_ts_type_predicate(&mut self, node: &TsTypePredicate) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_type_predicate(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_type_predicate(self, node),
        }
    }

    fn visit_ts_type_query(&mut self, node: &TsTypeQuery) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_type_query(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_type_query(self, node),
        }
    }

    fn visit_ts_type_query_expr(&mut self, node: &TsTypeQueryExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_type_query_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_type_query_expr(self, node),
        }
    }

    fn visit_ts_type_ref(&mut self, node: &TsTypeRef) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_type_ref(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_type_ref(self, node),
        }
    }

    fn visit_ts_types(&mut self, node: &[Box<TsType>]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_types(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_types(self, node),
        }
    }

    fn visit_ts_union_or_intersection_type(&mut self, node: &TsUnionOrIntersectionType) {
        match self {
            swc_visit::Either::Left(visitor) => {
                Visit::visit_ts_union_or_intersection_type(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                Visit::visit_ts_union_or_intersection_type(self, node)
            }
        }
    }

    fn visit_ts_union_type(&mut self, node: &TsUnionType) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_ts_union_type(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_ts_union_type(self, node),
        }
    }

    fn visit_unary_expr(&mut self, node: &UnaryExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_unary_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_unary_expr(self, node),
        }
    }

    fn visit_unary_op(&mut self, node: &UnaryOp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_unary_op(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_unary_op(self, node),
        }
    }

    fn visit_update_expr(&mut self, node: &UpdateExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_update_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_update_expr(self, node),
        }
    }

    fn visit_update_op(&mut self, node: &UpdateOp) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_update_op(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_update_op(self, node),
        }
    }

    fn visit_using_decl(&mut self, node: &UsingDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_using_decl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_using_decl(self, node),
        }
    }

    fn visit_var_decl(&mut self, node: &VarDecl) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_var_decl(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_var_decl(self, node),
        }
    }

    fn visit_var_decl_kind(&mut self, node: &VarDeclKind) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_var_decl_kind(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_var_decl_kind(self, node),
        }
    }

    fn visit_var_decl_or_expr(&mut self, node: &VarDeclOrExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_var_decl_or_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_var_decl_or_expr(self, node),
        }
    }

    fn visit_var_declarator(&mut self, node: &VarDeclarator) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_var_declarator(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_var_declarator(self, node),
        }
    }

    fn visit_var_declarators(&mut self, node: &[VarDeclarator]) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_var_declarators(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_var_declarators(self, node),
        }
    }

    fn visit_while_stmt(&mut self, node: &WhileStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_while_stmt(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_while_stmt(self, node),
        }
    }

    fn visit_with_stmt(&mut self, node: &WithStmt) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_with_stmt(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_with_stmt(self, node),
        }
    }

    fn visit_yield_expr(&mut self, node: &YieldExpr) {
        match self {
            swc_visit::Either::Left(visitor) => Visit::visit_yield_expr(self, node),
            swc_visit::Either::Right(visitor) => Visit::visit_yield_expr(self, node),
        }
    }
}
impl<V> Visit for ::swc_visit::Optional<V>
where
    V: Visit,
{
    fn visit_accessibility(&mut self, node: &Accessibility) {
        if self.enabled {
            Visit::visit_accessibility(self, node)
        } else {
        }
    }

    fn visit_array_lit(&mut self, node: &ArrayLit) {
        if self.enabled {
            Visit::visit_array_lit(self, node)
        } else {
        }
    }

    fn visit_array_pat(&mut self, node: &ArrayPat) {
        if self.enabled {
            Visit::visit_array_pat(self, node)
        } else {
        }
    }

    fn visit_arrow_expr(&mut self, node: &ArrowExpr) {
        if self.enabled {
            Visit::visit_arrow_expr(self, node)
        } else {
        }
    }

    fn visit_assign_expr(&mut self, node: &AssignExpr) {
        if self.enabled {
            Visit::visit_assign_expr(self, node)
        } else {
        }
    }

    fn visit_assign_op(&mut self, node: &AssignOp) {
        if self.enabled {
            Visit::visit_assign_op(self, node)
        } else {
        }
    }

    fn visit_assign_pat(&mut self, node: &AssignPat) {
        if self.enabled {
            Visit::visit_assign_pat(self, node)
        } else {
        }
    }

    fn visit_assign_pat_prop(&mut self, node: &AssignPatProp) {
        if self.enabled {
            Visit::visit_assign_pat_prop(self, node)
        } else {
        }
    }

    fn visit_assign_prop(&mut self, node: &AssignProp) {
        if self.enabled {
            Visit::visit_assign_prop(self, node)
        } else {
        }
    }

    fn visit_assign_target(&mut self, node: &AssignTarget) {
        if self.enabled {
            Visit::visit_assign_target(self, node)
        } else {
        }
    }

    fn visit_assign_target_pat(&mut self, node: &AssignTargetPat) {
        if self.enabled {
            Visit::visit_assign_target_pat(self, node)
        } else {
        }
    }

    fn visit_atom(&mut self, node: &swc_atoms::Atom) {
        if self.enabled {
            Visit::visit_atom(self, node)
        } else {
        }
    }

    fn visit_auto_accessor(&mut self, node: &AutoAccessor) {
        if self.enabled {
            Visit::visit_auto_accessor(self, node)
        } else {
        }
    }

    fn visit_await_expr(&mut self, node: &AwaitExpr) {
        if self.enabled {
            Visit::visit_await_expr(self, node)
        } else {
        }
    }

    fn visit_big_int(&mut self, node: &BigInt) {
        if self.enabled {
            Visit::visit_big_int(self, node)
        } else {
        }
    }

    fn visit_big_int_value(&mut self, node: &BigIntValue) {
        if self.enabled {
            Visit::visit_big_int_value(self, node)
        } else {
        }
    }

    fn visit_bin_expr(&mut self, node: &BinExpr) {
        if self.enabled {
            Visit::visit_bin_expr(self, node)
        } else {
        }
    }

    fn visit_binary_op(&mut self, node: &BinaryOp) {
        if self.enabled {
            Visit::visit_binary_op(self, node)
        } else {
        }
    }

    fn visit_binding_ident(&mut self, node: &BindingIdent) {
        if self.enabled {
            Visit::visit_binding_ident(self, node)
        } else {
        }
    }

    fn visit_block_stmt(&mut self, node: &BlockStmt) {
        if self.enabled {
            Visit::visit_block_stmt(self, node)
        } else {
        }
    }

    fn visit_block_stmt_or_expr(&mut self, node: &BlockStmtOrExpr) {
        if self.enabled {
            Visit::visit_block_stmt_or_expr(self, node)
        } else {
        }
    }

    fn visit_bool(&mut self, node: &Bool) {
        if self.enabled {
            Visit::visit_bool(self, node)
        } else {
        }
    }

    fn visit_break_stmt(&mut self, node: &BreakStmt) {
        if self.enabled {
            Visit::visit_break_stmt(self, node)
        } else {
        }
    }

    fn visit_call_expr(&mut self, node: &CallExpr) {
        if self.enabled {
            Visit::visit_call_expr(self, node)
        } else {
        }
    }

    fn visit_callee(&mut self, node: &Callee) {
        if self.enabled {
            Visit::visit_callee(self, node)
        } else {
        }
    }

    fn visit_catch_clause(&mut self, node: &CatchClause) {
        if self.enabled {
            Visit::visit_catch_clause(self, node)
        } else {
        }
    }

    fn visit_class(&mut self, node: &Class) {
        if self.enabled {
            Visit::visit_class(self, node)
        } else {
        }
    }

    fn visit_class_decl(&mut self, node: &ClassDecl) {
        if self.enabled {
            Visit::visit_class_decl(self, node)
        } else {
        }
    }

    fn visit_class_expr(&mut self, node: &ClassExpr) {
        if self.enabled {
            Visit::visit_class_expr(self, node)
        } else {
        }
    }

    fn visit_class_member(&mut self, node: &ClassMember) {
        if self.enabled {
            Visit::visit_class_member(self, node)
        } else {
        }
    }

    fn visit_class_members(&mut self, node: &[ClassMember]) {
        if self.enabled {
            Visit::visit_class_members(self, node)
        } else {
        }
    }

    fn visit_class_method(&mut self, node: &ClassMethod) {
        if self.enabled {
            Visit::visit_class_method(self, node)
        } else {
        }
    }

    fn visit_class_prop(&mut self, node: &ClassProp) {
        if self.enabled {
            Visit::visit_class_prop(self, node)
        } else {
        }
    }

    fn visit_computed_prop_name(&mut self, node: &ComputedPropName) {
        if self.enabled {
            Visit::visit_computed_prop_name(self, node)
        } else {
        }
    }

    fn visit_cond_expr(&mut self, node: &CondExpr) {
        if self.enabled {
            Visit::visit_cond_expr(self, node)
        } else {
        }
    }

    fn visit_constructor(&mut self, node: &Constructor) {
        if self.enabled {
            Visit::visit_constructor(self, node)
        } else {
        }
    }

    fn visit_continue_stmt(&mut self, node: &ContinueStmt) {
        if self.enabled {
            Visit::visit_continue_stmt(self, node)
        } else {
        }
    }

    fn visit_debugger_stmt(&mut self, node: &DebuggerStmt) {
        if self.enabled {
            Visit::visit_debugger_stmt(self, node)
        } else {
        }
    }

    fn visit_decl(&mut self, node: &Decl) {
        if self.enabled {
            Visit::visit_decl(self, node)
        } else {
        }
    }

    fn visit_decorator(&mut self, node: &Decorator) {
        if self.enabled {
            Visit::visit_decorator(self, node)
        } else {
        }
    }

    fn visit_decorators(&mut self, node: &[Decorator]) {
        if self.enabled {
            Visit::visit_decorators(self, node)
        } else {
        }
    }

    fn visit_default_decl(&mut self, node: &DefaultDecl) {
        if self.enabled {
            Visit::visit_default_decl(self, node)
        } else {
        }
    }

    fn visit_do_while_stmt(&mut self, node: &DoWhileStmt) {
        if self.enabled {
            Visit::visit_do_while_stmt(self, node)
        } else {
        }
    }

    fn visit_empty_stmt(&mut self, node: &EmptyStmt) {
        if self.enabled {
            Visit::visit_empty_stmt(self, node)
        } else {
        }
    }

    fn visit_es_version(&mut self, node: &EsVersion) {
        if self.enabled {
            Visit::visit_es_version(self, node)
        } else {
        }
    }

    fn visit_export_all(&mut self, node: &ExportAll) {
        if self.enabled {
            Visit::visit_export_all(self, node)
        } else {
        }
    }

    fn visit_export_decl(&mut self, node: &ExportDecl) {
        if self.enabled {
            Visit::visit_export_decl(self, node)
        } else {
        }
    }

    fn visit_export_default_decl(&mut self, node: &ExportDefaultDecl) {
        if self.enabled {
            Visit::visit_export_default_decl(self, node)
        } else {
        }
    }

    fn visit_export_default_expr(&mut self, node: &ExportDefaultExpr) {
        if self.enabled {
            Visit::visit_export_default_expr(self, node)
        } else {
        }
    }

    fn visit_export_default_specifier(&mut self, node: &ExportDefaultSpecifier) {
        if self.enabled {
            Visit::visit_export_default_specifier(self, node)
        } else {
        }
    }

    fn visit_export_named_specifier(&mut self, node: &ExportNamedSpecifier) {
        if self.enabled {
            Visit::visit_export_named_specifier(self, node)
        } else {
        }
    }

    fn visit_export_namespace_specifier(&mut self, node: &ExportNamespaceSpecifier) {
        if self.enabled {
            Visit::visit_export_namespace_specifier(self, node)
        } else {
        }
    }

    fn visit_export_specifier(&mut self, node: &ExportSpecifier) {
        if self.enabled {
            Visit::visit_export_specifier(self, node)
        } else {
        }
    }

    fn visit_export_specifiers(&mut self, node: &[ExportSpecifier]) {
        if self.enabled {
            Visit::visit_export_specifiers(self, node)
        } else {
        }
    }

    fn visit_expr(&mut self, node: &Expr) {
        if self.enabled {
            Visit::visit_expr(self, node)
        } else {
        }
    }

    fn visit_expr_or_spread(&mut self, node: &ExprOrSpread) {
        if self.enabled {
            Visit::visit_expr_or_spread(self, node)
        } else {
        }
    }

    fn visit_expr_or_spreads(&mut self, node: &[ExprOrSpread]) {
        if self.enabled {
            Visit::visit_expr_or_spreads(self, node)
        } else {
        }
    }

    fn visit_expr_stmt(&mut self, node: &ExprStmt) {
        if self.enabled {
            Visit::visit_expr_stmt(self, node)
        } else {
        }
    }

    fn visit_exprs(&mut self, node: &[Box<Expr>]) {
        if self.enabled {
            Visit::visit_exprs(self, node)
        } else {
        }
    }

    fn visit_fn_decl(&mut self, node: &FnDecl) {
        if self.enabled {
            Visit::visit_fn_decl(self, node)
        } else {
        }
    }

    fn visit_fn_expr(&mut self, node: &FnExpr) {
        if self.enabled {
            Visit::visit_fn_expr(self, node)
        } else {
        }
    }

    fn visit_for_head(&mut self, node: &ForHead) {
        if self.enabled {
            Visit::visit_for_head(self, node)
        } else {
        }
    }

    fn visit_for_in_stmt(&mut self, node: &ForInStmt) {
        if self.enabled {
            Visit::visit_for_in_stmt(self, node)
        } else {
        }
    }

    fn visit_for_of_stmt(&mut self, node: &ForOfStmt) {
        if self.enabled {
            Visit::visit_for_of_stmt(self, node)
        } else {
        }
    }

    fn visit_for_stmt(&mut self, node: &ForStmt) {
        if self.enabled {
            Visit::visit_for_stmt(self, node)
        } else {
        }
    }

    fn visit_function(&mut self, node: &Function) {
        if self.enabled {
            Visit::visit_function(self, node)
        } else {
        }
    }

    fn visit_getter_prop(&mut self, node: &GetterProp) {
        if self.enabled {
            Visit::visit_getter_prop(self, node)
        } else {
        }
    }

    fn visit_ident(&mut self, node: &Ident) {
        if self.enabled {
            Visit::visit_ident(self, node)
        } else {
        }
    }

    fn visit_ident_name(&mut self, node: &IdentName) {
        if self.enabled {
            Visit::visit_ident_name(self, node)
        } else {
        }
    }

    fn visit_if_stmt(&mut self, node: &IfStmt) {
        if self.enabled {
            Visit::visit_if_stmt(self, node)
        } else {
        }
    }

    fn visit_import(&mut self, node: &Import) {
        if self.enabled {
            Visit::visit_import(self, node)
        } else {
        }
    }

    fn visit_import_decl(&mut self, node: &ImportDecl) {
        if self.enabled {
            Visit::visit_import_decl(self, node)
        } else {
        }
    }

    fn visit_import_default_specifier(&mut self, node: &ImportDefaultSpecifier) {
        if self.enabled {
            Visit::visit_import_default_specifier(self, node)
        } else {
        }
    }

    fn visit_import_named_specifier(&mut self, node: &ImportNamedSpecifier) {
        if self.enabled {
            Visit::visit_import_named_specifier(self, node)
        } else {
        }
    }

    fn visit_import_phase(&mut self, node: &ImportPhase) {
        if self.enabled {
            Visit::visit_import_phase(self, node)
        } else {
        }
    }

    fn visit_import_specifier(&mut self, node: &ImportSpecifier) {
        if self.enabled {
            Visit::visit_import_specifier(self, node)
        } else {
        }
    }

    fn visit_import_specifiers(&mut self, node: &[ImportSpecifier]) {
        if self.enabled {
            Visit::visit_import_specifiers(self, node)
        } else {
        }
    }

    fn visit_import_star_as_specifier(&mut self, node: &ImportStarAsSpecifier) {
        if self.enabled {
            Visit::visit_import_star_as_specifier(self, node)
        } else {
        }
    }

    fn visit_import_with(&mut self, node: &ImportWith) {
        if self.enabled {
            Visit::visit_import_with(self, node)
        } else {
        }
    }

    fn visit_import_with_item(&mut self, node: &ImportWithItem) {
        if self.enabled {
            Visit::visit_import_with_item(self, node)
        } else {
        }
    }

    fn visit_import_with_items(&mut self, node: &[ImportWithItem]) {
        if self.enabled {
            Visit::visit_import_with_items(self, node)
        } else {
        }
    }

    fn visit_invalid(&mut self, node: &Invalid) {
        if self.enabled {
            Visit::visit_invalid(self, node)
        } else {
        }
    }

    fn visit_jsx_attr(&mut self, node: &JSXAttr) {
        if self.enabled {
            Visit::visit_jsx_attr(self, node)
        } else {
        }
    }

    fn visit_jsx_attr_name(&mut self, node: &JSXAttrName) {
        if self.enabled {
            Visit::visit_jsx_attr_name(self, node)
        } else {
        }
    }

    fn visit_jsx_attr_or_spread(&mut self, node: &JSXAttrOrSpread) {
        if self.enabled {
            Visit::visit_jsx_attr_or_spread(self, node)
        } else {
        }
    }

    fn visit_jsx_attr_or_spreads(&mut self, node: &[JSXAttrOrSpread]) {
        if self.enabled {
            Visit::visit_jsx_attr_or_spreads(self, node)
        } else {
        }
    }

    fn visit_jsx_attr_value(&mut self, node: &JSXAttrValue) {
        if self.enabled {
            Visit::visit_jsx_attr_value(self, node)
        } else {
        }
    }

    fn visit_jsx_closing_element(&mut self, node: &JSXClosingElement) {
        if self.enabled {
            Visit::visit_jsx_closing_element(self, node)
        } else {
        }
    }

    fn visit_jsx_closing_fragment(&mut self, node: &JSXClosingFragment) {
        if self.enabled {
            Visit::visit_jsx_closing_fragment(self, node)
        } else {
        }
    }

    fn visit_jsx_element(&mut self, node: &JSXElement) {
        if self.enabled {
            Visit::visit_jsx_element(self, node)
        } else {
        }
    }

    fn visit_jsx_element_child(&mut self, node: &JSXElementChild) {
        if self.enabled {
            Visit::visit_jsx_element_child(self, node)
        } else {
        }
    }

    fn visit_jsx_element_childs(&mut self, node: &[JSXElementChild]) {
        if self.enabled {
            Visit::visit_jsx_element_childs(self, node)
        } else {
        }
    }

    fn visit_jsx_element_name(&mut self, node: &JSXElementName) {
        if self.enabled {
            Visit::visit_jsx_element_name(self, node)
        } else {
        }
    }

    fn visit_jsx_empty_expr(&mut self, node: &JSXEmptyExpr) {
        if self.enabled {
            Visit::visit_jsx_empty_expr(self, node)
        } else {
        }
    }

    fn visit_jsx_expr(&mut self, node: &JSXExpr) {
        if self.enabled {
            Visit::visit_jsx_expr(self, node)
        } else {
        }
    }

    fn visit_jsx_expr_container(&mut self, node: &JSXExprContainer) {
        if self.enabled {
            Visit::visit_jsx_expr_container(self, node)
        } else {
        }
    }

    fn visit_jsx_fragment(&mut self, node: &JSXFragment) {
        if self.enabled {
            Visit::visit_jsx_fragment(self, node)
        } else {
        }
    }

    fn visit_jsx_member_expr(&mut self, node: &JSXMemberExpr) {
        if self.enabled {
            Visit::visit_jsx_member_expr(self, node)
        } else {
        }
    }

    fn visit_jsx_namespaced_name(&mut self, node: &JSXNamespacedName) {
        if self.enabled {
            Visit::visit_jsx_namespaced_name(self, node)
        } else {
        }
    }

    fn visit_jsx_object(&mut self, node: &JSXObject) {
        if self.enabled {
            Visit::visit_jsx_object(self, node)
        } else {
        }
    }

    fn visit_jsx_opening_element(&mut self, node: &JSXOpeningElement) {
        if self.enabled {
            Visit::visit_jsx_opening_element(self, node)
        } else {
        }
    }

    fn visit_jsx_opening_fragment(&mut self, node: &JSXOpeningFragment) {
        if self.enabled {
            Visit::visit_jsx_opening_fragment(self, node)
        } else {
        }
    }

    fn visit_jsx_spread_child(&mut self, node: &JSXSpreadChild) {
        if self.enabled {
            Visit::visit_jsx_spread_child(self, node)
        } else {
        }
    }

    fn visit_jsx_text(&mut self, node: &JSXText) {
        if self.enabled {
            Visit::visit_jsx_text(self, node)
        } else {
        }
    }

    fn visit_key(&mut self, node: &Key) {
        if self.enabled {
            Visit::visit_key(self, node)
        } else {
        }
    }

    fn visit_key_value_pat_prop(&mut self, node: &KeyValuePatProp) {
        if self.enabled {
            Visit::visit_key_value_pat_prop(self, node)
        } else {
        }
    }

    fn visit_key_value_prop(&mut self, node: &KeyValueProp) {
        if self.enabled {
            Visit::visit_key_value_prop(self, node)
        } else {
        }
    }

    fn visit_labeled_stmt(&mut self, node: &LabeledStmt) {
        if self.enabled {
            Visit::visit_labeled_stmt(self, node)
        } else {
        }
    }

    fn visit_lit(&mut self, node: &Lit) {
        if self.enabled {
            Visit::visit_lit(self, node)
        } else {
        }
    }

    fn visit_member_expr(&mut self, node: &MemberExpr) {
        if self.enabled {
            Visit::visit_member_expr(self, node)
        } else {
        }
    }

    fn visit_member_prop(&mut self, node: &MemberProp) {
        if self.enabled {
            Visit::visit_member_prop(self, node)
        } else {
        }
    }

    fn visit_meta_prop_expr(&mut self, node: &MetaPropExpr) {
        if self.enabled {
            Visit::visit_meta_prop_expr(self, node)
        } else {
        }
    }

    fn visit_meta_prop_kind(&mut self, node: &MetaPropKind) {
        if self.enabled {
            Visit::visit_meta_prop_kind(self, node)
        } else {
        }
    }

    fn visit_method_kind(&mut self, node: &MethodKind) {
        if self.enabled {
            Visit::visit_method_kind(self, node)
        } else {
        }
    }

    fn visit_method_prop(&mut self, node: &MethodProp) {
        if self.enabled {
            Visit::visit_method_prop(self, node)
        } else {
        }
    }

    fn visit_module(&mut self, node: &Module) {
        if self.enabled {
            Visit::visit_module(self, node)
        } else {
        }
    }

    fn visit_module_decl(&mut self, node: &ModuleDecl) {
        if self.enabled {
            Visit::visit_module_decl(self, node)
        } else {
        }
    }

    fn visit_module_export_name(&mut self, node: &ModuleExportName) {
        if self.enabled {
            Visit::visit_module_export_name(self, node)
        } else {
        }
    }

    fn visit_module_item(&mut self, node: &ModuleItem) {
        if self.enabled {
            Visit::visit_module_item(self, node)
        } else {
        }
    }

    fn visit_module_items(&mut self, node: &[ModuleItem]) {
        if self.enabled {
            Visit::visit_module_items(self, node)
        } else {
        }
    }

    fn visit_named_export(&mut self, node: &NamedExport) {
        if self.enabled {
            Visit::visit_named_export(self, node)
        } else {
        }
    }

    fn visit_new_expr(&mut self, node: &NewExpr) {
        if self.enabled {
            Visit::visit_new_expr(self, node)
        } else {
        }
    }

    fn visit_null(&mut self, node: &Null) {
        if self.enabled {
            Visit::visit_null(self, node)
        } else {
        }
    }

    fn visit_number(&mut self, node: &Number) {
        if self.enabled {
            Visit::visit_number(self, node)
        } else {
        }
    }

    fn visit_object_lit(&mut self, node: &ObjectLit) {
        if self.enabled {
            Visit::visit_object_lit(self, node)
        } else {
        }
    }

    fn visit_object_pat(&mut self, node: &ObjectPat) {
        if self.enabled {
            Visit::visit_object_pat(self, node)
        } else {
        }
    }

    fn visit_object_pat_prop(&mut self, node: &ObjectPatProp) {
        if self.enabled {
            Visit::visit_object_pat_prop(self, node)
        } else {
        }
    }

    fn visit_object_pat_props(&mut self, node: &[ObjectPatProp]) {
        if self.enabled {
            Visit::visit_object_pat_props(self, node)
        } else {
        }
    }

    fn visit_opt_accessibility(&mut self, node: &Option<Accessibility>) {
        if self.enabled {
            Visit::visit_opt_accessibility(self, node)
        } else {
        }
    }

    fn visit_opt_atom(&mut self, node: &Option<swc_atoms::Atom>) {
        if self.enabled {
            Visit::visit_opt_atom(self, node)
        } else {
        }
    }

    fn visit_opt_block_stmt(&mut self, node: &Option<BlockStmt>) {
        if self.enabled {
            Visit::visit_opt_block_stmt(self, node)
        } else {
        }
    }

    fn visit_opt_call(&mut self, node: &OptCall) {
        if self.enabled {
            Visit::visit_opt_call(self, node)
        } else {
        }
    }

    fn visit_opt_catch_clause(&mut self, node: &Option<CatchClause>) {
        if self.enabled {
            Visit::visit_opt_catch_clause(self, node)
        } else {
        }
    }

    fn visit_opt_chain_base(&mut self, node: &OptChainBase) {
        if self.enabled {
            Visit::visit_opt_chain_base(self, node)
        } else {
        }
    }

    fn visit_opt_chain_expr(&mut self, node: &OptChainExpr) {
        if self.enabled {
            Visit::visit_opt_chain_expr(self, node)
        } else {
        }
    }

    fn visit_opt_expr(&mut self, node: &Option<Box<Expr>>) {
        if self.enabled {
            Visit::visit_opt_expr(self, node)
        } else {
        }
    }

    fn visit_opt_expr_or_spread(&mut self, node: &Option<ExprOrSpread>) {
        if self.enabled {
            Visit::visit_opt_expr_or_spread(self, node)
        } else {
        }
    }

    fn visit_opt_expr_or_spreads(&mut self, node: &Option<Vec<ExprOrSpread>>) {
        if self.enabled {
            Visit::visit_opt_expr_or_spreads(self, node)
        } else {
        }
    }

    fn visit_opt_ident(&mut self, node: &Option<Ident>) {
        if self.enabled {
            Visit::visit_opt_ident(self, node)
        } else {
        }
    }

    fn visit_opt_jsx_attr_value(&mut self, node: &Option<JSXAttrValue>) {
        if self.enabled {
            Visit::visit_opt_jsx_attr_value(self, node)
        } else {
        }
    }

    fn visit_opt_jsx_closing_element(&mut self, node: &Option<JSXClosingElement>) {
        if self.enabled {
            Visit::visit_opt_jsx_closing_element(self, node)
        } else {
        }
    }

    fn visit_opt_module_export_name(&mut self, node: &Option<ModuleExportName>) {
        if self.enabled {
            Visit::visit_opt_module_export_name(self, node)
        } else {
        }
    }

    fn visit_opt_module_items(&mut self, node: &Option<Vec<ModuleItem>>) {
        if self.enabled {
            Visit::visit_opt_module_items(self, node)
        } else {
        }
    }

    fn visit_opt_object_lit(&mut self, node: &Option<Box<ObjectLit>>) {
        if self.enabled {
            Visit::visit_opt_object_lit(self, node)
        } else {
        }
    }

    fn visit_opt_pat(&mut self, node: &Option<Pat>) {
        if self.enabled {
            Visit::visit_opt_pat(self, node)
        } else {
        }
    }

    fn visit_opt_span(&mut self, node: &Option<swc_common::Span>) {
        if self.enabled {
            Visit::visit_opt_span(self, node)
        } else {
        }
    }

    fn visit_opt_stmt(&mut self, node: &Option<Box<Stmt>>) {
        if self.enabled {
            Visit::visit_opt_stmt(self, node)
        } else {
        }
    }

    fn visit_opt_str(&mut self, node: &Option<Box<Str>>) {
        if self.enabled {
            Visit::visit_opt_str(self, node)
        } else {
        }
    }

    fn visit_opt_true_plus_minus(&mut self, node: &Option<TruePlusMinus>) {
        if self.enabled {
            Visit::visit_opt_true_plus_minus(self, node)
        } else {
        }
    }

    fn visit_opt_ts_entity_name(&mut self, node: &Option<TsEntityName>) {
        if self.enabled {
            Visit::visit_opt_ts_entity_name(self, node)
        } else {
        }
    }

    fn visit_opt_ts_namespace_body(&mut self, node: &Option<TsNamespaceBody>) {
        if self.enabled {
            Visit::visit_opt_ts_namespace_body(self, node)
        } else {
        }
    }

    fn visit_opt_ts_type(&mut self, node: &Option<Box<TsType>>) {
        if self.enabled {
            Visit::visit_opt_ts_type(self, node)
        } else {
        }
    }

    fn visit_opt_ts_type_ann(&mut self, node: &Option<Box<TsTypeAnn>>) {
        if self.enabled {
            Visit::visit_opt_ts_type_ann(self, node)
        } else {
        }
    }

    fn visit_opt_ts_type_param_decl(&mut self, node: &Option<Box<TsTypeParamDecl>>) {
        if self.enabled {
            Visit::visit_opt_ts_type_param_decl(self, node)
        } else {
        }
    }

    fn visit_opt_ts_type_param_instantiation(
        &mut self,
        node: &Option<Box<TsTypeParamInstantiation>>,
    ) {
        if self.enabled {
            Visit::visit_opt_ts_type_param_instantiation(self, node)
        } else {
        }
    }

    fn visit_opt_var_decl_or_expr(&mut self, node: &Option<VarDeclOrExpr>) {
        if self.enabled {
            Visit::visit_opt_var_decl_or_expr(self, node)
        } else {
        }
    }

    fn visit_opt_vec_expr_or_spreads(&mut self, node: &[Option<ExprOrSpread>]) {
        if self.enabled {
            Visit::visit_opt_vec_expr_or_spreads(self, node)
        } else {
        }
    }

    fn visit_opt_vec_pats(&mut self, node: &[Option<Pat>]) {
        if self.enabled {
            Visit::visit_opt_vec_pats(self, node)
        } else {
        }
    }

    fn visit_param(&mut self, node: &Param) {
        if self.enabled {
            Visit::visit_param(self, node)
        } else {
        }
    }

    fn visit_param_or_ts_param_prop(&mut self, node: &ParamOrTsParamProp) {
        if self.enabled {
            Visit::visit_param_or_ts_param_prop(self, node)
        } else {
        }
    }

    fn visit_param_or_ts_param_props(&mut self, node: &[ParamOrTsParamProp]) {
        if self.enabled {
            Visit::visit_param_or_ts_param_props(self, node)
        } else {
        }
    }

    fn visit_params(&mut self, node: &[Param]) {
        if self.enabled {
            Visit::visit_params(self, node)
        } else {
        }
    }

    fn visit_paren_expr(&mut self, node: &ParenExpr) {
        if self.enabled {
            Visit::visit_paren_expr(self, node)
        } else {
        }
    }

    fn visit_pat(&mut self, node: &Pat) {
        if self.enabled {
            Visit::visit_pat(self, node)
        } else {
        }
    }

    fn visit_pats(&mut self, node: &[Pat]) {
        if self.enabled {
            Visit::visit_pats(self, node)
        } else {
        }
    }

    fn visit_private_method(&mut self, node: &PrivateMethod) {
        if self.enabled {
            Visit::visit_private_method(self, node)
        } else {
        }
    }

    fn visit_private_name(&mut self, node: &PrivateName) {
        if self.enabled {
            Visit::visit_private_name(self, node)
        } else {
        }
    }

    fn visit_private_prop(&mut self, node: &PrivateProp) {
        if self.enabled {
            Visit::visit_private_prop(self, node)
        } else {
        }
    }

    fn visit_program(&mut self, node: &Program) {
        if self.enabled {
            Visit::visit_program(self, node)
        } else {
        }
    }

    fn visit_prop(&mut self, node: &Prop) {
        if self.enabled {
            Visit::visit_prop(self, node)
        } else {
        }
    }

    fn visit_prop_name(&mut self, node: &PropName) {
        if self.enabled {
            Visit::visit_prop_name(self, node)
        } else {
        }
    }

    fn visit_prop_or_spread(&mut self, node: &PropOrSpread) {
        if self.enabled {
            Visit::visit_prop_or_spread(self, node)
        } else {
        }
    }

    fn visit_prop_or_spreads(&mut self, node: &[PropOrSpread]) {
        if self.enabled {
            Visit::visit_prop_or_spreads(self, node)
        } else {
        }
    }

    fn visit_regex(&mut self, node: &Regex) {
        if self.enabled {
            Visit::visit_regex(self, node)
        } else {
        }
    }

    fn visit_reserved_unused(&mut self, node: &ReservedUnused) {
        if self.enabled {
            Visit::visit_reserved_unused(self, node)
        } else {
        }
    }

    fn visit_rest_pat(&mut self, node: &RestPat) {
        if self.enabled {
            Visit::visit_rest_pat(self, node)
        } else {
        }
    }

    fn visit_return_stmt(&mut self, node: &ReturnStmt) {
        if self.enabled {
            Visit::visit_return_stmt(self, node)
        } else {
        }
    }

    fn visit_script(&mut self, node: &Script) {
        if self.enabled {
            Visit::visit_script(self, node)
        } else {
        }
    }

    fn visit_seq_expr(&mut self, node: &SeqExpr) {
        if self.enabled {
            Visit::visit_seq_expr(self, node)
        } else {
        }
    }

    fn visit_setter_prop(&mut self, node: &SetterProp) {
        if self.enabled {
            Visit::visit_setter_prop(self, node)
        } else {
        }
    }

    fn visit_simple_assign_target(&mut self, node: &SimpleAssignTarget) {
        if self.enabled {
            Visit::visit_simple_assign_target(self, node)
        } else {
        }
    }

    fn visit_span(&mut self, node: &swc_common::Span) {
        if self.enabled {
            Visit::visit_span(self, node)
        } else {
        }
    }

    fn visit_spread_element(&mut self, node: &SpreadElement) {
        if self.enabled {
            Visit::visit_spread_element(self, node)
        } else {
        }
    }

    fn visit_static_block(&mut self, node: &StaticBlock) {
        if self.enabled {
            Visit::visit_static_block(self, node)
        } else {
        }
    }

    fn visit_stmt(&mut self, node: &Stmt) {
        if self.enabled {
            Visit::visit_stmt(self, node)
        } else {
        }
    }

    fn visit_stmts(&mut self, node: &[Stmt]) {
        if self.enabled {
            Visit::visit_stmts(self, node)
        } else {
        }
    }

    fn visit_str(&mut self, node: &Str) {
        if self.enabled {
            Visit::visit_str(self, node)
        } else {
        }
    }

    fn visit_super(&mut self, node: &Super) {
        if self.enabled {
            Visit::visit_super(self, node)
        } else {
        }
    }

    fn visit_super_prop(&mut self, node: &SuperProp) {
        if self.enabled {
            Visit::visit_super_prop(self, node)
        } else {
        }
    }

    fn visit_super_prop_expr(&mut self, node: &SuperPropExpr) {
        if self.enabled {
            Visit::visit_super_prop_expr(self, node)
        } else {
        }
    }

    fn visit_switch_case(&mut self, node: &SwitchCase) {
        if self.enabled {
            Visit::visit_switch_case(self, node)
        } else {
        }
    }

    fn visit_switch_cases(&mut self, node: &[SwitchCase]) {
        if self.enabled {
            Visit::visit_switch_cases(self, node)
        } else {
        }
    }

    fn visit_switch_stmt(&mut self, node: &SwitchStmt) {
        if self.enabled {
            Visit::visit_switch_stmt(self, node)
        } else {
        }
    }

    fn visit_syntax_context(&mut self, node: &swc_common::SyntaxContext) {
        if self.enabled {
            Visit::visit_syntax_context(self, node)
        } else {
        }
    }

    fn visit_tagged_tpl(&mut self, node: &TaggedTpl) {
        if self.enabled {
            Visit::visit_tagged_tpl(self, node)
        } else {
        }
    }

    fn visit_this_expr(&mut self, node: &ThisExpr) {
        if self.enabled {
            Visit::visit_this_expr(self, node)
        } else {
        }
    }

    fn visit_throw_stmt(&mut self, node: &ThrowStmt) {
        if self.enabled {
            Visit::visit_throw_stmt(self, node)
        } else {
        }
    }

    fn visit_tpl(&mut self, node: &Tpl) {
        if self.enabled {
            Visit::visit_tpl(self, node)
        } else {
        }
    }

    fn visit_tpl_element(&mut self, node: &TplElement) {
        if self.enabled {
            Visit::visit_tpl_element(self, node)
        } else {
        }
    }

    fn visit_tpl_elements(&mut self, node: &[TplElement]) {
        if self.enabled {
            Visit::visit_tpl_elements(self, node)
        } else {
        }
    }

    fn visit_true_plus_minus(&mut self, node: &TruePlusMinus) {
        if self.enabled {
            Visit::visit_true_plus_minus(self, node)
        } else {
        }
    }

    fn visit_try_stmt(&mut self, node: &TryStmt) {
        if self.enabled {
            Visit::visit_try_stmt(self, node)
        } else {
        }
    }

    fn visit_ts_array_type(&mut self, node: &TsArrayType) {
        if self.enabled {
            Visit::visit_ts_array_type(self, node)
        } else {
        }
    }

    fn visit_ts_as_expr(&mut self, node: &TsAsExpr) {
        if self.enabled {
            Visit::visit_ts_as_expr(self, node)
        } else {
        }
    }

    fn visit_ts_call_signature_decl(&mut self, node: &TsCallSignatureDecl) {
        if self.enabled {
            Visit::visit_ts_call_signature_decl(self, node)
        } else {
        }
    }

    fn visit_ts_conditional_type(&mut self, node: &TsConditionalType) {
        if self.enabled {
            Visit::visit_ts_conditional_type(self, node)
        } else {
        }
    }

    fn visit_ts_const_assertion(&mut self, node: &TsConstAssertion) {
        if self.enabled {
            Visit::visit_ts_const_assertion(self, node)
        } else {
        }
    }

    fn visit_ts_construct_signature_decl(&mut self, node: &TsConstructSignatureDecl) {
        if self.enabled {
            Visit::visit_ts_construct_signature_decl(self, node)
        } else {
        }
    }

    fn visit_ts_constructor_type(&mut self, node: &TsConstructorType) {
        if self.enabled {
            Visit::visit_ts_constructor_type(self, node)
        } else {
        }
    }

    fn visit_ts_entity_name(&mut self, node: &TsEntityName) {
        if self.enabled {
            Visit::visit_ts_entity_name(self, node)
        } else {
        }
    }

    fn visit_ts_enum_decl(&mut self, node: &TsEnumDecl) {
        if self.enabled {
            Visit::visit_ts_enum_decl(self, node)
        } else {
        }
    }

    fn visit_ts_enum_member(&mut self, node: &TsEnumMember) {
        if self.enabled {
            Visit::visit_ts_enum_member(self, node)
        } else {
        }
    }

    fn visit_ts_enum_member_id(&mut self, node: &TsEnumMemberId) {
        if self.enabled {
            Visit::visit_ts_enum_member_id(self, node)
        } else {
        }
    }

    fn visit_ts_enum_members(&mut self, node: &[TsEnumMember]) {
        if self.enabled {
            Visit::visit_ts_enum_members(self, node)
        } else {
        }
    }

    fn visit_ts_export_assignment(&mut self, node: &TsExportAssignment) {
        if self.enabled {
            Visit::visit_ts_export_assignment(self, node)
        } else {
        }
    }

    fn visit_ts_expr_with_type_args(&mut self, node: &TsExprWithTypeArgs) {
        if self.enabled {
            Visit::visit_ts_expr_with_type_args(self, node)
        } else {
        }
    }

    fn visit_ts_expr_with_type_argss(&mut self, node: &[TsExprWithTypeArgs]) {
        if self.enabled {
            Visit::visit_ts_expr_with_type_argss(self, node)
        } else {
        }
    }

    fn visit_ts_external_module_ref(&mut self, node: &TsExternalModuleRef) {
        if self.enabled {
            Visit::visit_ts_external_module_ref(self, node)
        } else {
        }
    }

    fn visit_ts_fn_or_constructor_type(&mut self, node: &TsFnOrConstructorType) {
        if self.enabled {
            Visit::visit_ts_fn_or_constructor_type(self, node)
        } else {
        }
    }

    fn visit_ts_fn_param(&mut self, node: &TsFnParam) {
        if self.enabled {
            Visit::visit_ts_fn_param(self, node)
        } else {
        }
    }

    fn visit_ts_fn_params(&mut self, node: &[TsFnParam]) {
        if self.enabled {
            Visit::visit_ts_fn_params(self, node)
        } else {
        }
    }

    fn visit_ts_fn_type(&mut self, node: &TsFnType) {
        if self.enabled {
            Visit::visit_ts_fn_type(self, node)
        } else {
        }
    }

    fn visit_ts_getter_signature(&mut self, node: &TsGetterSignature) {
        if self.enabled {
            Visit::visit_ts_getter_signature(self, node)
        } else {
        }
    }

    fn visit_ts_import_equals_decl(&mut self, node: &TsImportEqualsDecl) {
        if self.enabled {
            Visit::visit_ts_import_equals_decl(self, node)
        } else {
        }
    }

    fn visit_ts_import_type(&mut self, node: &TsImportType) {
        if self.enabled {
            Visit::visit_ts_import_type(self, node)
        } else {
        }
    }

    fn visit_ts_index_signature(&mut self, node: &TsIndexSignature) {
        if self.enabled {
            Visit::visit_ts_index_signature(self, node)
        } else {
        }
    }

    fn visit_ts_indexed_access_type(&mut self, node: &TsIndexedAccessType) {
        if self.enabled {
            Visit::visit_ts_indexed_access_type(self, node)
        } else {
        }
    }

    fn visit_ts_infer_type(&mut self, node: &TsInferType) {
        if self.enabled {
            Visit::visit_ts_infer_type(self, node)
        } else {
        }
    }

    fn visit_ts_instantiation(&mut self, node: &TsInstantiation) {
        if self.enabled {
            Visit::visit_ts_instantiation(self, node)
        } else {
        }
    }

    fn visit_ts_interface_body(&mut self, node: &TsInterfaceBody) {
        if self.enabled {
            Visit::visit_ts_interface_body(self, node)
        } else {
        }
    }

    fn visit_ts_interface_decl(&mut self, node: &TsInterfaceDecl) {
        if self.enabled {
            Visit::visit_ts_interface_decl(self, node)
        } else {
        }
    }

    fn visit_ts_intersection_type(&mut self, node: &TsIntersectionType) {
        if self.enabled {
            Visit::visit_ts_intersection_type(self, node)
        } else {
        }
    }

    fn visit_ts_keyword_type(&mut self, node: &TsKeywordType) {
        if self.enabled {
            Visit::visit_ts_keyword_type(self, node)
        } else {
        }
    }

    fn visit_ts_keyword_type_kind(&mut self, node: &TsKeywordTypeKind) {
        if self.enabled {
            Visit::visit_ts_keyword_type_kind(self, node)
        } else {
        }
    }

    fn visit_ts_lit(&mut self, node: &TsLit) {
        if self.enabled {
            Visit::visit_ts_lit(self, node)
        } else {
        }
    }

    fn visit_ts_lit_type(&mut self, node: &TsLitType) {
        if self.enabled {
            Visit::visit_ts_lit_type(self, node)
        } else {
        }
    }

    fn visit_ts_mapped_type(&mut self, node: &TsMappedType) {
        if self.enabled {
            Visit::visit_ts_mapped_type(self, node)
        } else {
        }
    }

    fn visit_ts_method_signature(&mut self, node: &TsMethodSignature) {
        if self.enabled {
            Visit::visit_ts_method_signature(self, node)
        } else {
        }
    }

    fn visit_ts_module_block(&mut self, node: &TsModuleBlock) {
        if self.enabled {
            Visit::visit_ts_module_block(self, node)
        } else {
        }
    }

    fn visit_ts_module_decl(&mut self, node: &TsModuleDecl) {
        if self.enabled {
            Visit::visit_ts_module_decl(self, node)
        } else {
        }
    }

    fn visit_ts_module_name(&mut self, node: &TsModuleName) {
        if self.enabled {
            Visit::visit_ts_module_name(self, node)
        } else {
        }
    }

    fn visit_ts_module_ref(&mut self, node: &TsModuleRef) {
        if self.enabled {
            Visit::visit_ts_module_ref(self, node)
        } else {
        }
    }

    fn visit_ts_namespace_body(&mut self, node: &TsNamespaceBody) {
        if self.enabled {
            Visit::visit_ts_namespace_body(self, node)
        } else {
        }
    }

    fn visit_ts_namespace_decl(&mut self, node: &TsNamespaceDecl) {
        if self.enabled {
            Visit::visit_ts_namespace_decl(self, node)
        } else {
        }
    }

    fn visit_ts_namespace_export_decl(&mut self, node: &TsNamespaceExportDecl) {
        if self.enabled {
            Visit::visit_ts_namespace_export_decl(self, node)
        } else {
        }
    }

    fn visit_ts_non_null_expr(&mut self, node: &TsNonNullExpr) {
        if self.enabled {
            Visit::visit_ts_non_null_expr(self, node)
        } else {
        }
    }

    fn visit_ts_optional_type(&mut self, node: &TsOptionalType) {
        if self.enabled {
            Visit::visit_ts_optional_type(self, node)
        } else {
        }
    }

    fn visit_ts_param_prop(&mut self, node: &TsParamProp) {
        if self.enabled {
            Visit::visit_ts_param_prop(self, node)
        } else {
        }
    }

    fn visit_ts_param_prop_param(&mut self, node: &TsParamPropParam) {
        if self.enabled {
            Visit::visit_ts_param_prop_param(self, node)
        } else {
        }
    }

    fn visit_ts_parenthesized_type(&mut self, node: &TsParenthesizedType) {
        if self.enabled {
            Visit::visit_ts_parenthesized_type(self, node)
        } else {
        }
    }

    fn visit_ts_property_signature(&mut self, node: &TsPropertySignature) {
        if self.enabled {
            Visit::visit_ts_property_signature(self, node)
        } else {
        }
    }

    fn visit_ts_qualified_name(&mut self, node: &TsQualifiedName) {
        if self.enabled {
            Visit::visit_ts_qualified_name(self, node)
        } else {
        }
    }

    fn visit_ts_rest_type(&mut self, node: &TsRestType) {
        if self.enabled {
            Visit::visit_ts_rest_type(self, node)
        } else {
        }
    }

    fn visit_ts_satisfies_expr(&mut self, node: &TsSatisfiesExpr) {
        if self.enabled {
            Visit::visit_ts_satisfies_expr(self, node)
        } else {
        }
    }

    fn visit_ts_setter_signature(&mut self, node: &TsSetterSignature) {
        if self.enabled {
            Visit::visit_ts_setter_signature(self, node)
        } else {
        }
    }

    fn visit_ts_this_type(&mut self, node: &TsThisType) {
        if self.enabled {
            Visit::visit_ts_this_type(self, node)
        } else {
        }
    }

    fn visit_ts_this_type_or_ident(&mut self, node: &TsThisTypeOrIdent) {
        if self.enabled {
            Visit::visit_ts_this_type_or_ident(self, node)
        } else {
        }
    }

    fn visit_ts_tpl_lit_type(&mut self, node: &TsTplLitType) {
        if self.enabled {
            Visit::visit_ts_tpl_lit_type(self, node)
        } else {
        }
    }

    fn visit_ts_tuple_element(&mut self, node: &TsTupleElement) {
        if self.enabled {
            Visit::visit_ts_tuple_element(self, node)
        } else {
        }
    }

    fn visit_ts_tuple_elements(&mut self, node: &[TsTupleElement]) {
        if self.enabled {
            Visit::visit_ts_tuple_elements(self, node)
        } else {
        }
    }

    fn visit_ts_tuple_type(&mut self, node: &TsTupleType) {
        if self.enabled {
            Visit::visit_ts_tuple_type(self, node)
        } else {
        }
    }

    fn visit_ts_type(&mut self, node: &TsType) {
        if self.enabled {
            Visit::visit_ts_type(self, node)
        } else {
        }
    }

    fn visit_ts_type_alias_decl(&mut self, node: &TsTypeAliasDecl) {
        if self.enabled {
            Visit::visit_ts_type_alias_decl(self, node)
        } else {
        }
    }

    fn visit_ts_type_ann(&mut self, node: &TsTypeAnn) {
        if self.enabled {
            Visit::visit_ts_type_ann(self, node)
        } else {
        }
    }

    fn visit_ts_type_assertion(&mut self, node: &TsTypeAssertion) {
        if self.enabled {
            Visit::visit_ts_type_assertion(self, node)
        } else {
        }
    }

    fn visit_ts_type_element(&mut self, node: &TsTypeElement) {
        if self.enabled {
            Visit::visit_ts_type_element(self, node)
        } else {
        }
    }

    fn visit_ts_type_elements(&mut self, node: &[TsTypeElement]) {
        if self.enabled {
            Visit::visit_ts_type_elements(self, node)
        } else {
        }
    }

    fn visit_ts_type_lit(&mut self, node: &TsTypeLit) {
        if self.enabled {
            Visit::visit_ts_type_lit(self, node)
        } else {
        }
    }

    fn visit_ts_type_operator(&mut self, node: &TsTypeOperator) {
        if self.enabled {
            Visit::visit_ts_type_operator(self, node)
        } else {
        }
    }

    fn visit_ts_type_operator_op(&mut self, node: &TsTypeOperatorOp) {
        if self.enabled {
            Visit::visit_ts_type_operator_op(self, node)
        } else {
        }
    }

    fn visit_ts_type_param(&mut self, node: &TsTypeParam) {
        if self.enabled {
            Visit::visit_ts_type_param(self, node)
        } else {
        }
    }

    fn visit_ts_type_param_decl(&mut self, node: &TsTypeParamDecl) {
        if self.enabled {
            Visit::visit_ts_type_param_decl(self, node)
        } else {
        }
    }

    fn visit_ts_type_param_instantiation(&mut self, node: &TsTypeParamInstantiation) {
        if self.enabled {
            Visit::visit_ts_type_param_instantiation(self, node)
        } else {
        }
    }

    fn visit_ts_type_params(&mut self, node: &[TsTypeParam]) {
        if self.enabled {
            Visit::visit_ts_type_params(self, node)
        } else {
        }
    }

    fn visit_ts_type_predicate(&mut self, node: &TsTypePredicate) {
        if self.enabled {
            Visit::visit_ts_type_predicate(self, node)
        } else {
        }
    }

    fn visit_ts_type_query(&mut self, node: &TsTypeQuery) {
        if self.enabled {
            Visit::visit_ts_type_query(self, node)
        } else {
        }
    }

    fn visit_ts_type_query_expr(&mut self, node: &TsTypeQueryExpr) {
        if self.enabled {
            Visit::visit_ts_type_query_expr(self, node)
        } else {
        }
    }

    fn visit_ts_type_ref(&mut self, node: &TsTypeRef) {
        if self.enabled {
            Visit::visit_ts_type_ref(self, node)
        } else {
        }
    }

    fn visit_ts_types(&mut self, node: &[Box<TsType>]) {
        if self.enabled {
            Visit::visit_ts_types(self, node)
        } else {
        }
    }

    fn visit_ts_union_or_intersection_type(&mut self, node: &TsUnionOrIntersectionType) {
        if self.enabled {
            Visit::visit_ts_union_or_intersection_type(self, node)
        } else {
        }
    }

    fn visit_ts_union_type(&mut self, node: &TsUnionType) {
        if self.enabled {
            Visit::visit_ts_union_type(self, node)
        } else {
        }
    }

    fn visit_unary_expr(&mut self, node: &UnaryExpr) {
        if self.enabled {
            Visit::visit_unary_expr(self, node)
        } else {
        }
    }

    fn visit_unary_op(&mut self, node: &UnaryOp) {
        if self.enabled {
            Visit::visit_unary_op(self, node)
        } else {
        }
    }

    fn visit_update_expr(&mut self, node: &UpdateExpr) {
        if self.enabled {
            Visit::visit_update_expr(self, node)
        } else {
        }
    }

    fn visit_update_op(&mut self, node: &UpdateOp) {
        if self.enabled {
            Visit::visit_update_op(self, node)
        } else {
        }
    }

    fn visit_using_decl(&mut self, node: &UsingDecl) {
        if self.enabled {
            Visit::visit_using_decl(self, node)
        } else {
        }
    }

    fn visit_var_decl(&mut self, node: &VarDecl) {
        if self.enabled {
            Visit::visit_var_decl(self, node)
        } else {
        }
    }

    fn visit_var_decl_kind(&mut self, node: &VarDeclKind) {
        if self.enabled {
            Visit::visit_var_decl_kind(self, node)
        } else {
        }
    }

    fn visit_var_decl_or_expr(&mut self, node: &VarDeclOrExpr) {
        if self.enabled {
            Visit::visit_var_decl_or_expr(self, node)
        } else {
        }
    }

    fn visit_var_declarator(&mut self, node: &VarDeclarator) {
        if self.enabled {
            Visit::visit_var_declarator(self, node)
        } else {
        }
    }

    fn visit_var_declarators(&mut self, node: &[VarDeclarator]) {
        if self.enabled {
            Visit::visit_var_declarators(self, node)
        } else {
        }
    }

    fn visit_while_stmt(&mut self, node: &WhileStmt) {
        if self.enabled {
            Visit::visit_while_stmt(self, node)
        } else {
        }
    }

    fn visit_with_stmt(&mut self, node: &WithStmt) {
        if self.enabled {
            Visit::visit_with_stmt(self, node)
        } else {
        }
    }

    fn visit_yield_expr(&mut self, node: &YieldExpr) {
        if self.enabled {
            Visit::visit_yield_expr(self, node)
        } else {
        }
    }
}
#[doc = r" A trait implemented for types that can be visited using a visitor."]
pub trait VisitWith<V: ?Sized + Visit> {
    #[doc = r" Calls a visitor method (visitor.fold_xxx) with self."]
    fn visit_with(&self, visitor: &mut V);
    #[doc = r" Visit children nodes of `self`` with `visitor`."]
    fn visit_children_with(&self, visitor: &mut V);
}
impl<V: ?Sized + Visit> VisitWith<V> for Accessibility {
    #[doc = "Calls [Visit`::visit_accessibility`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_accessibility(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Accessibility::Public => {}
            Accessibility::Protected => {}
            Accessibility::Private => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ArrayLit {
    #[doc = "Calls [Visit`::visit_array_lit`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_array_lit(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ArrayLit { span, elems } => {
                <Vec<Option<ExprOrSpread>> as VisitWith<V>>::visit_with(elems, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ArrayPat {
    #[doc = "Calls [Visit`::visit_array_pat`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_array_pat(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ArrayPat {
                span,
                elems,
                optional,
                type_ann,
            } => {
                <Vec<Option<Pat>> as VisitWith<V>>::visit_with(elems, visitor);
                <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ArrowExpr {
    #[doc = "Calls [Visit`::visit_arrow_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_arrow_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ArrowExpr {
                span,
                ctxt,
                params,
                body,
                is_async,
                is_generator,
                type_params,
                return_type,
            } => {
                <Vec<Pat> as VisitWith<V>>::visit_with(params, visitor);
                <Box<BlockStmtOrExpr> as VisitWith<V>>::visit_with(body, visitor);
                <Option<Box<TsTypeParamDecl>> as VisitWith<V>>::visit_with(type_params, visitor);
                <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(return_type, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for AssignExpr {
    #[doc = "Calls [Visit`::visit_assign_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_assign_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            AssignExpr {
                span,
                op,
                left,
                right,
            } => {
                <AssignOp as VisitWith<V>>::visit_with(op, visitor);
                <AssignTarget as VisitWith<V>>::visit_with(left, visitor);
                <Box<Expr> as VisitWith<V>>::visit_with(right, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for AssignOp {
    #[doc = "Calls [Visit`::visit_assign_op`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_assign_op(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            AssignOp::Assign => {}
            AssignOp::AddAssign => {}
            AssignOp::SubAssign => {}
            AssignOp::MulAssign => {}
            AssignOp::DivAssign => {}
            AssignOp::ModAssign => {}
            AssignOp::LShiftAssign => {}
            AssignOp::RShiftAssign => {}
            AssignOp::ZeroFillRShiftAssign => {}
            AssignOp::BitOrAssign => {}
            AssignOp::BitXorAssign => {}
            AssignOp::BitAndAssign => {}
            AssignOp::ExpAssign => {}
            AssignOp::AndAssign => {}
            AssignOp::OrAssign => {}
            AssignOp::NullishAssign => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for AssignPat {
    #[doc = "Calls [Visit`::visit_assign_pat`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_assign_pat(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            AssignPat { span, left, right } => {
                <Box<Pat> as VisitWith<V>>::visit_with(left, visitor);
                <Box<Expr> as VisitWith<V>>::visit_with(right, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for AssignPatProp {
    #[doc = "Calls [Visit`::visit_assign_pat_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_assign_pat_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            AssignPatProp { span, key, value } => {
                <BindingIdent as VisitWith<V>>::visit_with(key, visitor);
                <Option<Box<Expr>> as VisitWith<V>>::visit_with(value, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for AssignProp {
    #[doc = "Calls [Visit`::visit_assign_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_assign_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            AssignProp { span, key, value } => {
                <Ident as VisitWith<V>>::visit_with(key, visitor);
                <Box<Expr> as VisitWith<V>>::visit_with(value, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for AssignTarget {
    #[doc = "Calls [Visit`::visit_assign_target`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_assign_target(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            AssignTarget::Simple { 0: _field_0 } => {
                <SimpleAssignTarget as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            AssignTarget::Pat { 0: _field_0 } => {
                <AssignTargetPat as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for AssignTargetPat {
    #[doc = "Calls [Visit`::visit_assign_target_pat`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_assign_target_pat(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            AssignTargetPat::Array { 0: _field_0 } => {
                <ArrayPat as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            AssignTargetPat::Object { 0: _field_0 } => {
                <ObjectPat as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            AssignTargetPat::Invalid { 0: _field_0 } => {
                <Invalid as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for AutoAccessor {
    #[doc = "Calls [Visit`::visit_auto_accessor`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_auto_accessor(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            AutoAccessor {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_override,
                definite,
            } => {
                <Key as VisitWith<V>>::visit_with(key, visitor);
                <Option<Box<Expr>> as VisitWith<V>>::visit_with(value, visitor);
                <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor);
                <Vec<Decorator> as VisitWith<V>>::visit_with(decorators, visitor);
                <Option<Accessibility> as VisitWith<V>>::visit_with(accessibility, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for AwaitExpr {
    #[doc = "Calls [Visit`::visit_await_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_await_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            AwaitExpr { span, arg } => {
                <Box<Expr> as VisitWith<V>>::visit_with(arg, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for BigInt {
    #[doc = "Calls [Visit`::visit_big_int`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_big_int(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            BigInt { span, value, raw } => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for BinExpr {
    #[doc = "Calls [Visit`::visit_bin_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_bin_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            BinExpr {
                span,
                op,
                left,
                right,
            } => {
                <BinaryOp as VisitWith<V>>::visit_with(op, visitor);
                <Box<Expr> as VisitWith<V>>::visit_with(left, visitor);
                <Box<Expr> as VisitWith<V>>::visit_with(right, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for BinaryOp {
    #[doc = "Calls [Visit`::visit_binary_op`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_binary_op(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            BinaryOp::EqEq => {}
            BinaryOp::NotEq => {}
            BinaryOp::EqEqEq => {}
            BinaryOp::NotEqEq => {}
            BinaryOp::Lt => {}
            BinaryOp::LtEq => {}
            BinaryOp::Gt => {}
            BinaryOp::GtEq => {}
            BinaryOp::LShift => {}
            BinaryOp::RShift => {}
            BinaryOp::ZeroFillRShift => {}
            BinaryOp::Add => {}
            BinaryOp::Sub => {}
            BinaryOp::Mul => {}
            BinaryOp::Div => {}
            BinaryOp::Mod => {}
            BinaryOp::BitOr => {}
            BinaryOp::BitXor => {}
            BinaryOp::BitAnd => {}
            BinaryOp::LogicalOr => {}
            BinaryOp::LogicalAnd => {}
            BinaryOp::In => {}
            BinaryOp::InstanceOf => {}
            BinaryOp::Exp => {}
            BinaryOp::NullishCoalescing => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for BindingIdent {
    #[doc = "Calls [Visit`::visit_binding_ident`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_binding_ident(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            BindingIdent { id, type_ann } => {
                <Ident as VisitWith<V>>::visit_with(id, visitor);
                <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for BlockStmt {
    #[doc = "Calls [Visit`::visit_block_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_block_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            BlockStmt { span, ctxt, stmts } => {
                <Vec<Stmt> as VisitWith<V>>::visit_with(stmts, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for BlockStmtOrExpr {
    #[doc = "Calls [Visit`::visit_block_stmt_or_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_block_stmt_or_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            BlockStmtOrExpr::BlockStmt { 0: _field_0 } => {
                <BlockStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            BlockStmtOrExpr::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Bool {
    #[doc = "Calls [Visit`::visit_bool`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_bool(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Bool { span, value } => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for BreakStmt {
    #[doc = "Calls [Visit`::visit_break_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_break_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            BreakStmt { span, label } => {
                <Option<Ident> as VisitWith<V>>::visit_with(label, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for CallExpr {
    #[doc = "Calls [Visit`::visit_call_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_call_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            CallExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                <Callee as VisitWith<V>>::visit_with(callee, visitor);
                <Vec<ExprOrSpread> as VisitWith<V>>::visit_with(args, visitor);
                <Option<Box<TsTypeParamInstantiation>> as VisitWith<V>>::visit_with(
                    type_args, visitor,
                );
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Callee {
    #[doc = "Calls [Visit`::visit_callee`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_callee(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Callee::Super { 0: _field_0 } => {
                <Super as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Callee::Import { 0: _field_0 } => {
                <Import as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Callee::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for CatchClause {
    #[doc = "Calls [Visit`::visit_catch_clause`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_catch_clause(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            CatchClause { span, param, body } => {
                <Option<Pat> as VisitWith<V>>::visit_with(param, visitor);
                <BlockStmt as VisitWith<V>>::visit_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Class {
    #[doc = "Calls [Visit`::visit_class`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_class(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Class {
                span,
                ctxt,
                decorators,
                body,
                super_class,
                is_abstract,
                type_params,
                super_type_params,
                implements,
            } => {
                <Vec<Decorator> as VisitWith<V>>::visit_with(decorators, visitor);
                <Vec<ClassMember> as VisitWith<V>>::visit_with(body, visitor);
                <Option<Box<Expr>> as VisitWith<V>>::visit_with(super_class, visitor);
                <Option<Box<TsTypeParamDecl>> as VisitWith<V>>::visit_with(type_params, visitor);
                <Option<Box<TsTypeParamInstantiation>> as VisitWith<V>>::visit_with(
                    super_type_params,
                    visitor,
                );
                <Vec<TsExprWithTypeArgs> as VisitWith<V>>::visit_with(implements, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ClassDecl {
    #[doc = "Calls [Visit`::visit_class_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_class_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ClassDecl {
                ident,
                declare,
                class,
            } => {
                <Ident as VisitWith<V>>::visit_with(ident, visitor);
                <Box<Class> as VisitWith<V>>::visit_with(class, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ClassExpr {
    #[doc = "Calls [Visit`::visit_class_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_class_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ClassExpr { ident, class } => {
                <Option<Ident> as VisitWith<V>>::visit_with(ident, visitor);
                <Box<Class> as VisitWith<V>>::visit_with(class, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ClassMember {
    #[doc = "Calls [Visit`::visit_class_member`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_class_member(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ClassMember::Constructor { 0: _field_0 } => {
                <Constructor as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ClassMember::Method { 0: _field_0 } => {}
            ClassMember::PrivateMethod { 0: _field_0 } => {}
            ClassMember::ClassProp { 0: _field_0 } => {
                <ClassProp as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ClassMember::PrivateProp { 0: _field_0 } => {
                <PrivateProp as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ClassMember::TsIndexSignature { 0: _field_0 } => {
                <TsIndexSignature as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ClassMember::Empty { 0: _field_0 } => {
                <EmptyStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ClassMember::StaticBlock { 0: _field_0 } => {
                <StaticBlock as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ClassMember::AutoAccessor { 0: _field_0 } => {
                <AutoAccessor as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ClassProp {
    #[doc = "Calls [Visit`::visit_class_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_class_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ClassProp {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
                readonly,
                declare,
                definite,
            } => {
                <PropName as VisitWith<V>>::visit_with(key, visitor);
                <Option<Box<Expr>> as VisitWith<V>>::visit_with(value, visitor);
                <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor);
                <Vec<Decorator> as VisitWith<V>>::visit_with(decorators, visitor);
                <Option<Accessibility> as VisitWith<V>>::visit_with(accessibility, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ComputedPropName {
    #[doc = "Calls [Visit`::visit_computed_prop_name`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_computed_prop_name(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ComputedPropName { span, expr } => {
                <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for CondExpr {
    #[doc = "Calls [Visit`::visit_cond_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_cond_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            CondExpr {
                span,
                test,
                cons,
                alt,
            } => {
                <Box<Expr> as VisitWith<V>>::visit_with(test, visitor);
                <Box<Expr> as VisitWith<V>>::visit_with(cons, visitor);
                <Box<Expr> as VisitWith<V>>::visit_with(alt, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Constructor {
    #[doc = "Calls [Visit`::visit_constructor`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_constructor(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Constructor {
                span,
                ctxt,
                key,
                params,
                body,
                accessibility,
                is_optional,
            } => {
                <PropName as VisitWith<V>>::visit_with(key, visitor);
                <Vec<ParamOrTsParamProp> as VisitWith<V>>::visit_with(params, visitor);
                <Option<BlockStmt> as VisitWith<V>>::visit_with(body, visitor);
                <Option<Accessibility> as VisitWith<V>>::visit_with(accessibility, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ContinueStmt {
    #[doc = "Calls [Visit`::visit_continue_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_continue_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ContinueStmt { span, label } => {
                <Option<Ident> as VisitWith<V>>::visit_with(label, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for DebuggerStmt {
    #[doc = "Calls [Visit`::visit_debugger_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_debugger_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            DebuggerStmt { span } => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Decl {
    #[doc = "Calls [Visit`::visit_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Decl::Class { 0: _field_0 } => {
                <ClassDecl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Decl::Fn { 0: _field_0 } => {
                <FnDecl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Decl::Var { 0: _field_0 } => {
                <Box<VarDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Decl::Using { 0: _field_0 } => {
                <Box<UsingDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Decl::TsInterface { 0: _field_0 } => {
                <Box<TsInterfaceDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Decl::TsTypeAlias { 0: _field_0 } => {
                <Box<TsTypeAliasDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Decl::TsEnum { 0: _field_0 } => {
                <Box<TsEnumDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Decl::TsModule { 0: _field_0 } => {
                <Box<TsModuleDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Decorator {
    #[doc = "Calls [Visit`::visit_decorator`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_decorator(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Decorator { span, expr } => {
                <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for DefaultDecl {
    #[doc = "Calls [Visit`::visit_default_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_default_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            DefaultDecl::Class { 0: _field_0 } => {
                <ClassExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            DefaultDecl::Fn { 0: _field_0 } => {
                <FnExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            DefaultDecl::TsInterfaceDecl { 0: _field_0 } => {
                <Box<TsInterfaceDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for DoWhileStmt {
    #[doc = "Calls [Visit`::visit_do_while_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_do_while_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            DoWhileStmt { span, test, body } => {
                <Box<Expr> as VisitWith<V>>::visit_with(test, visitor);
                <Box<Stmt> as VisitWith<V>>::visit_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for EmptyStmt {
    #[doc = "Calls [Visit`::visit_empty_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_empty_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            EmptyStmt { span } => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for EsVersion {
    #[doc = "Calls [Visit`::visit_es_version`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_es_version(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            EsVersion::Es3 => {}
            EsVersion::Es5 => {}
            EsVersion::Es2015 => {}
            EsVersion::Es2016 => {}
            EsVersion::Es2017 => {}
            EsVersion::Es2018 => {}
            EsVersion::Es2019 => {}
            EsVersion::Es2020 => {}
            EsVersion::Es2021 => {}
            EsVersion::Es2022 => {}
            EsVersion::EsNext => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ExportAll {
    #[doc = "Calls [Visit`::visit_export_all`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_export_all(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ExportAll {
                span,
                src,
                type_only,
                with,
            } => {
                <Box<Str> as VisitWith<V>>::visit_with(src, visitor);
                <Option<Box<ObjectLit>> as VisitWith<V>>::visit_with(with, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ExportDecl {
    #[doc = "Calls [Visit`::visit_export_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_export_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ExportDecl { span, decl } => {
                <Decl as VisitWith<V>>::visit_with(decl, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ExportDefaultDecl {
    #[doc = "Calls [Visit`::visit_export_default_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_export_default_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ExportDefaultDecl { span, decl } => {
                <DefaultDecl as VisitWith<V>>::visit_with(decl, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ExportDefaultExpr {
    #[doc = "Calls [Visit`::visit_export_default_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_export_default_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ExportDefaultExpr { span, expr } => {
                <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ExportDefaultSpecifier {
    #[doc = "Calls [Visit`::visit_export_default_specifier`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_export_default_specifier(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ExportDefaultSpecifier { exported } => {
                <Ident as VisitWith<V>>::visit_with(exported, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ExportNamedSpecifier {
    #[doc = "Calls [Visit`::visit_export_named_specifier`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_export_named_specifier(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ExportNamedSpecifier {
                span,
                orig,
                exported,
                is_type_only,
            } => {
                <ModuleExportName as VisitWith<V>>::visit_with(orig, visitor);
                <Option<ModuleExportName> as VisitWith<V>>::visit_with(exported, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ExportNamespaceSpecifier {
    #[doc = "Calls [Visit`::visit_export_namespace_specifier`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_export_namespace_specifier(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ExportNamespaceSpecifier { span, name } => {
                <ModuleExportName as VisitWith<V>>::visit_with(name, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ExportSpecifier {
    #[doc = "Calls [Visit`::visit_export_specifier`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_export_specifier(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ExportSpecifier::Namespace { 0: _field_0 } => {
                <ExportNamespaceSpecifier as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ExportSpecifier::Default { 0: _field_0 } => {
                <ExportDefaultSpecifier as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ExportSpecifier::Named { 0: _field_0 } => {
                <ExportNamedSpecifier as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Expr {
    #[doc = "Calls [Visit`::visit_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Expr::This { 0: _field_0 } => {
                <ThisExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Array { 0: _field_0 } => {
                <ArrayLit as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Object { 0: _field_0 } => {
                <ObjectLit as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Fn { 0: _field_0 } => {
                <FnExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Unary { 0: _field_0 } => {
                <UnaryExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Update { 0: _field_0 } => {
                <UpdateExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Bin { 0: _field_0 } => {
                <BinExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Assign { 0: _field_0 } => {
                <AssignExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Member { 0: _field_0 } => {
                <MemberExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::SuperProp { 0: _field_0 } => {
                <SuperPropExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Cond { 0: _field_0 } => {
                <CondExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Call { 0: _field_0 } => {
                <CallExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::New { 0: _field_0 } => {
                <NewExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Seq { 0: _field_0 } => {
                <SeqExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Ident { 0: _field_0 } => {
                <Ident as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Lit { 0: _field_0 } => {
                <Lit as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Tpl { 0: _field_0 } => {
                <Tpl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::TaggedTpl { 0: _field_0 } => {
                <TaggedTpl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Arrow { 0: _field_0 } => {
                <ArrowExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Class { 0: _field_0 } => {
                <ClassExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Yield { 0: _field_0 } => {
                <YieldExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::MetaProp { 0: _field_0 } => {
                <MetaPropExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Await { 0: _field_0 } => {
                <AwaitExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Paren { 0: _field_0 } => {
                <ParenExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::JSXMember { 0: _field_0 } => {
                <JSXMemberExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::JSXNamespacedName { 0: _field_0 } => {
                <JSXNamespacedName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::JSXEmpty { 0: _field_0 } => {
                <JSXEmptyExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::JSXElement { 0: _field_0 } => {
                <Box<JSXElement> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::JSXFragment { 0: _field_0 } => {
                <JSXFragment as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::TsTypeAssertion { 0: _field_0 } => {
                <TsTypeAssertion as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::TsConstAssertion { 0: _field_0 } => {
                <TsConstAssertion as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::TsNonNull { 0: _field_0 } => {
                <TsNonNullExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::TsAs { 0: _field_0 } => {
                <TsAsExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::TsInstantiation { 0: _field_0 } => {
                <TsInstantiation as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::TsSatisfies { 0: _field_0 } => {
                <TsSatisfiesExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::PrivateName { 0: _field_0 } => {
                <PrivateName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::OptChain { 0: _field_0 } => {
                <OptChainExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Expr::Invalid { 0: _field_0 } => {
                <Invalid as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ExprOrSpread {
    #[doc = "Calls [Visit`::visit_expr_or_spread`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_expr_or_spread(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ExprOrSpread { spread, expr } => {
                <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ExprStmt {
    #[doc = "Calls [Visit`::visit_expr_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_expr_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ExprStmt { span, expr } => {
                <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for FnDecl {
    #[doc = "Calls [Visit`::visit_fn_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_fn_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            FnDecl {
                ident,
                declare,
                function,
            } => {
                <Ident as VisitWith<V>>::visit_with(ident, visitor);
                <Box<Function> as VisitWith<V>>::visit_with(function, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for FnExpr {
    #[doc = "Calls [Visit`::visit_fn_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_fn_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            FnExpr { ident, function } => {
                <Option<Ident> as VisitWith<V>>::visit_with(ident, visitor);
                <Box<Function> as VisitWith<V>>::visit_with(function, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ForHead {
    #[doc = "Calls [Visit`::visit_for_head`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_for_head(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ForHead::VarDecl { 0: _field_0 } => {
                <Box<VarDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ForHead::UsingDecl { 0: _field_0 } => {
                <Box<UsingDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ForHead::Pat { 0: _field_0 } => {
                <Box<Pat> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ForInStmt {
    #[doc = "Calls [Visit`::visit_for_in_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_for_in_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ForInStmt {
                span,
                left,
                right,
                body,
            } => {
                <ForHead as VisitWith<V>>::visit_with(left, visitor);
                <Box<Expr> as VisitWith<V>>::visit_with(right, visitor);
                <Box<Stmt> as VisitWith<V>>::visit_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ForOfStmt {
    #[doc = "Calls [Visit`::visit_for_of_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_for_of_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ForOfStmt {
                span,
                is_await,
                left,
                right,
                body,
            } => {
                <ForHead as VisitWith<V>>::visit_with(left, visitor);
                <Box<Expr> as VisitWith<V>>::visit_with(right, visitor);
                <Box<Stmt> as VisitWith<V>>::visit_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ForStmt {
    #[doc = "Calls [Visit`::visit_for_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_for_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ForStmt {
                span,
                init,
                test,
                update,
                body,
            } => {
                <Option<VarDeclOrExpr> as VisitWith<V>>::visit_with(init, visitor);
                <Option<Box<Expr>> as VisitWith<V>>::visit_with(test, visitor);
                <Option<Box<Expr>> as VisitWith<V>>::visit_with(update, visitor);
                <Box<Stmt> as VisitWith<V>>::visit_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Function {
    #[doc = "Calls [Visit`::visit_function`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_function(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Function {
                params,
                decorators,
                span,
                ctxt,
                body,
                is_generator,
                is_async,
                type_params,
                return_type,
            } => {
                <Vec<Param> as VisitWith<V>>::visit_with(params, visitor);
                <Vec<Decorator> as VisitWith<V>>::visit_with(decorators, visitor);
                <Option<BlockStmt> as VisitWith<V>>::visit_with(body, visitor);
                <Option<Box<TsTypeParamDecl>> as VisitWith<V>>::visit_with(type_params, visitor);
                <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(return_type, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for GetterProp {
    #[doc = "Calls [Visit`::visit_getter_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_getter_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            GetterProp {
                span,
                key,
                type_ann,
                body,
            } => {
                <PropName as VisitWith<V>>::visit_with(key, visitor);
                <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor);
                <Option<BlockStmt> as VisitWith<V>>::visit_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Ident {
    #[doc = "Calls [Visit`::visit_ident`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ident(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Ident {
                span,
                ctxt,
                sym,
                optional,
            } => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for IdentName {
    #[doc = "Calls [Visit`::visit_ident_name`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ident_name(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            IdentName { span, sym } => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for IfStmt {
    #[doc = "Calls [Visit`::visit_if_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_if_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            IfStmt {
                span,
                test,
                cons,
                alt,
            } => {
                <Box<Expr> as VisitWith<V>>::visit_with(test, visitor);
                <Box<Stmt> as VisitWith<V>>::visit_with(cons, visitor);
                <Option<Box<Stmt>> as VisitWith<V>>::visit_with(alt, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Import {
    #[doc = "Calls [Visit`::visit_import`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Import { span, phase } => {
                <ImportPhase as VisitWith<V>>::visit_with(phase, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ImportDecl {
    #[doc = "Calls [Visit`::visit_import_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ImportDecl {
                span,
                specifiers,
                src,
                type_only,
                with,
                phase,
            } => {
                <Vec<ImportSpecifier> as VisitWith<V>>::visit_with(specifiers, visitor);
                <Box<Str> as VisitWith<V>>::visit_with(src, visitor);
                <Option<Box<ObjectLit>> as VisitWith<V>>::visit_with(with, visitor);
                <ImportPhase as VisitWith<V>>::visit_with(phase, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ImportDefaultSpecifier {
    #[doc = "Calls [Visit`::visit_import_default_specifier`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import_default_specifier(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ImportDefaultSpecifier { span, local } => {
                <Ident as VisitWith<V>>::visit_with(local, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ImportNamedSpecifier {
    #[doc = "Calls [Visit`::visit_import_named_specifier`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import_named_specifier(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ImportNamedSpecifier {
                span,
                local,
                imported,
                is_type_only,
            } => {
                <Ident as VisitWith<V>>::visit_with(local, visitor);
                <Option<ModuleExportName> as VisitWith<V>>::visit_with(imported, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ImportPhase {
    #[doc = "Calls [Visit`::visit_import_phase`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import_phase(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ImportPhase::Evaluation => {}
            ImportPhase::Source => {}
            ImportPhase::Defer => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ImportSpecifier {
    #[doc = "Calls [Visit`::visit_import_specifier`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import_specifier(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ImportSpecifier::Named { 0: _field_0 } => {
                <ImportNamedSpecifier as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ImportSpecifier::Default { 0: _field_0 } => {
                <ImportDefaultSpecifier as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ImportSpecifier::Namespace { 0: _field_0 } => {
                <ImportStarAsSpecifier as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ImportStarAsSpecifier {
    #[doc = "Calls [Visit`::visit_import_star_as_specifier`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import_star_as_specifier(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ImportStarAsSpecifier { span, local } => {
                <Ident as VisitWith<V>>::visit_with(local, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ImportWith {
    #[doc = "Calls [Visit`::visit_import_with`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import_with(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ImportWith { span, values } => {
                <Vec<ImportWithItem> as VisitWith<V>>::visit_with(values, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ImportWithItem {
    #[doc = "Calls [Visit`::visit_import_with_item`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import_with_item(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ImportWithItem { key, value } => {
                <IdentName as VisitWith<V>>::visit_with(key, visitor);
                <Str as VisitWith<V>>::visit_with(value, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Invalid {
    #[doc = "Calls [Visit`::visit_invalid`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_invalid(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Invalid { span } => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXAttr {
    #[doc = "Calls [Visit`::visit_jsx_attr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_attr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXAttr { span, name, value } => {
                <JSXAttrName as VisitWith<V>>::visit_with(name, visitor);
                <Option<JSXAttrValue> as VisitWith<V>>::visit_with(value, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXAttrName {
    #[doc = "Calls [Visit`::visit_jsx_attr_name`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_attr_name(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXAttrName::Ident { 0: _field_0 } => {
                <IdentName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXAttrName::JSXNamespacedName { 0: _field_0 } => {
                <JSXNamespacedName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXAttrOrSpread {
    #[doc = "Calls [Visit`::visit_jsx_attr_or_spread`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_attr_or_spread(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXAttrOrSpread::JSXAttr { 0: _field_0 } => {
                <JSXAttr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXAttrOrSpread::SpreadElement { 0: _field_0 } => {
                <SpreadElement as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXAttrValue {
    #[doc = "Calls [Visit`::visit_jsx_attr_value`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_attr_value(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXAttrValue::Lit { 0: _field_0 } => {
                <Lit as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXAttrValue::JSXExprContainer { 0: _field_0 } => {
                <JSXExprContainer as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXAttrValue::JSXElement { 0: _field_0 } => {
                <Box<JSXElement> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXAttrValue::JSXFragment { 0: _field_0 } => {
                <JSXFragment as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXClosingElement {
    #[doc = "Calls [Visit`::visit_jsx_closing_element`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_closing_element(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXClosingElement { span, name } => {
                <JSXElementName as VisitWith<V>>::visit_with(name, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXClosingFragment {
    #[doc = "Calls [Visit`::visit_jsx_closing_fragment`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_closing_fragment(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXClosingFragment { span } => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXElement {
    #[doc = "Calls [Visit`::visit_jsx_element`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_element(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXElement {
                span,
                opening,
                children,
                closing,
            } => {
                <JSXOpeningElement as VisitWith<V>>::visit_with(opening, visitor);
                <Vec<JSXElementChild> as VisitWith<V>>::visit_with(children, visitor);
                <Option<JSXClosingElement> as VisitWith<V>>::visit_with(closing, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXElementChild {
    #[doc = "Calls [Visit`::visit_jsx_element_child`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_element_child(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXElementChild::JSXText { 0: _field_0 } => {
                <JSXText as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXElementChild::JSXExprContainer { 0: _field_0 } => {
                <JSXExprContainer as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXElementChild::JSXSpreadChild { 0: _field_0 } => {
                <JSXSpreadChild as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXElementChild::JSXElement { 0: _field_0 } => {
                <Box<JSXElement> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXElementChild::JSXFragment { 0: _field_0 } => {
                <JSXFragment as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXElementName {
    #[doc = "Calls [Visit`::visit_jsx_element_name`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_element_name(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXElementName::Ident { 0: _field_0 } => {
                <Ident as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXElementName::JSXMemberExpr { 0: _field_0 } => {
                <JSXMemberExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXElementName::JSXNamespacedName { 0: _field_0 } => {
                <JSXNamespacedName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXEmptyExpr {
    #[doc = "Calls [Visit`::visit_jsx_empty_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_empty_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXEmptyExpr { span } => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXExpr {
    #[doc = "Calls [Visit`::visit_jsx_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXExpr::JSXEmptyExpr { 0: _field_0 } => {
                <JSXEmptyExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXExpr::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXExprContainer {
    #[doc = "Calls [Visit`::visit_jsx_expr_container`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_expr_container(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXExprContainer { span, expr } => {
                <JSXExpr as VisitWith<V>>::visit_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXFragment {
    #[doc = "Calls [Visit`::visit_jsx_fragment`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_fragment(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXFragment {
                span,
                opening,
                children,
                closing,
            } => {
                <JSXOpeningFragment as VisitWith<V>>::visit_with(opening, visitor);
                <Vec<JSXElementChild> as VisitWith<V>>::visit_with(children, visitor);
                <JSXClosingFragment as VisitWith<V>>::visit_with(closing, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXMemberExpr {
    #[doc = "Calls [Visit`::visit_jsx_member_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_member_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXMemberExpr { span, obj, prop } => {
                <JSXObject as VisitWith<V>>::visit_with(obj, visitor);
                <IdentName as VisitWith<V>>::visit_with(prop, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXNamespacedName {
    #[doc = "Calls [Visit`::visit_jsx_namespaced_name`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_namespaced_name(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXNamespacedName { span, ns, name } => {
                <IdentName as VisitWith<V>>::visit_with(ns, visitor);
                <IdentName as VisitWith<V>>::visit_with(name, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXObject {
    #[doc = "Calls [Visit`::visit_jsx_object`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_object(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXObject::JSXMemberExpr { 0: _field_0 } => {
                <Box<JSXMemberExpr> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            JSXObject::Ident { 0: _field_0 } => {
                <Ident as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXOpeningElement {
    #[doc = "Calls [Visit`::visit_jsx_opening_element`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_opening_element(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXOpeningElement {
                name,
                span,
                attrs,
                self_closing,
                type_args,
            } => {
                <JSXElementName as VisitWith<V>>::visit_with(name, visitor);
                <Vec<JSXAttrOrSpread> as VisitWith<V>>::visit_with(attrs, visitor);
                <Option<Box<TsTypeParamInstantiation>> as VisitWith<V>>::visit_with(
                    type_args, visitor,
                );
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXOpeningFragment {
    #[doc = "Calls [Visit`::visit_jsx_opening_fragment`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_opening_fragment(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXOpeningFragment { span } => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXSpreadChild {
    #[doc = "Calls [Visit`::visit_jsx_spread_child`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_spread_child(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXSpreadChild { span, expr } => {
                <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for JSXText {
    #[doc = "Calls [Visit`::visit_jsx_text`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_text(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            JSXText { span, value, raw } => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Key {
    #[doc = "Calls [Visit`::visit_key`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_key(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Key::Private { 0: _field_0 } => {
                <PrivateName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Key::Public { 0: _field_0 } => {
                <PropName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for KeyValuePatProp {
    #[doc = "Calls [Visit`::visit_key_value_pat_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_key_value_pat_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            KeyValuePatProp { key, value } => {
                <PropName as VisitWith<V>>::visit_with(key, visitor);
                <Box<Pat> as VisitWith<V>>::visit_with(value, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for KeyValueProp {
    #[doc = "Calls [Visit`::visit_key_value_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_key_value_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            KeyValueProp { key, value } => {
                <PropName as VisitWith<V>>::visit_with(key, visitor);
                <Box<Expr> as VisitWith<V>>::visit_with(value, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for LabeledStmt {
    #[doc = "Calls [Visit`::visit_labeled_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_labeled_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            LabeledStmt { span, label, body } => {
                <Ident as VisitWith<V>>::visit_with(label, visitor);
                <Box<Stmt> as VisitWith<V>>::visit_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Lit {
    #[doc = "Calls [Visit`::visit_lit`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_lit(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Lit::Str { 0: _field_0 } => {
                <Str as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Lit::Bool { 0: _field_0 } => {
                <Bool as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Lit::Null { 0: _field_0 } => {
                <Null as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Lit::Num { 0: _field_0 } => {
                <Number as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Lit::BigInt { 0: _field_0 } => {
                <BigInt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Lit::Regex { 0: _field_0 } => {
                <Regex as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Lit::JSXText { 0: _field_0 } => {
                <JSXText as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for MemberExpr {
    #[doc = "Calls [Visit`::visit_member_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_member_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            MemberExpr { span, obj, prop } => {
                <Box<Expr> as VisitWith<V>>::visit_with(obj, visitor);
                <MemberProp as VisitWith<V>>::visit_with(prop, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for MemberProp {
    #[doc = "Calls [Visit`::visit_member_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_member_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            MemberProp::Ident { 0: _field_0 } => {
                <IdentName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            MemberProp::PrivateName { 0: _field_0 } => {
                <PrivateName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            MemberProp::Computed { 0: _field_0 } => {
                <ComputedPropName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for MetaPropExpr {
    #[doc = "Calls [Visit`::visit_meta_prop_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_meta_prop_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            MetaPropExpr { span, kind } => {
                <MetaPropKind as VisitWith<V>>::visit_with(kind, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for MetaPropKind {
    #[doc = "Calls [Visit`::visit_meta_prop_kind`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_meta_prop_kind(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            MetaPropKind::NewTarget => {}
            MetaPropKind::ImportMeta => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for MethodKind {
    #[doc = "Calls [Visit`::visit_method_kind`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_method_kind(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            MethodKind::Method => {}
            MethodKind::Getter => {}
            MethodKind::Setter => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for MethodProp {
    #[doc = "Calls [Visit`::visit_method_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_method_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            MethodProp { key, function } => {
                <PropName as VisitWith<V>>::visit_with(key, visitor);
                <Box<Function> as VisitWith<V>>::visit_with(function, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Module {
    #[doc = "Calls [Visit`::visit_module`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_module(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Module {
                span,
                body,
                shebang,
            } => {
                <Vec<ModuleItem> as VisitWith<V>>::visit_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ModuleDecl {
    #[doc = "Calls [Visit`::visit_module_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_module_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ModuleDecl::Import { 0: _field_0 } => {
                <ImportDecl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ModuleDecl::ExportDecl { 0: _field_0 } => {
                <ExportDecl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ModuleDecl::ExportNamed { 0: _field_0 } => {
                <NamedExport as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ModuleDecl::ExportDefaultDecl { 0: _field_0 } => {
                <ExportDefaultDecl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ModuleDecl::ExportDefaultExpr { 0: _field_0 } => {
                <ExportDefaultExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ModuleDecl::ExportAll { 0: _field_0 } => {
                <ExportAll as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ModuleDecl::TsImportEquals { 0: _field_0 } => {
                <Box<TsImportEqualsDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ModuleDecl::TsExportAssignment { 0: _field_0 } => {
                <TsExportAssignment as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ModuleDecl::TsNamespaceExport { 0: _field_0 } => {
                <TsNamespaceExportDecl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ModuleExportName {
    #[doc = "Calls [Visit`::visit_module_export_name`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_module_export_name(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ModuleExportName::Ident { 0: _field_0 } => {
                <Ident as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ModuleExportName::Str { 0: _field_0 } => {
                <Str as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ModuleItem {
    #[doc = "Calls [Visit`::visit_module_item`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_module_item(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ModuleItem::ModuleDecl { 0: _field_0 } => {
                <ModuleDecl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ModuleItem::Stmt { 0: _field_0 } => {
                <Stmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for NamedExport {
    #[doc = "Calls [Visit`::visit_named_export`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_named_export(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            NamedExport {
                span,
                specifiers,
                src,
                type_only,
                with,
            } => {
                <Vec<ExportSpecifier> as VisitWith<V>>::visit_with(specifiers, visitor);
                <Option<Box<Str>> as VisitWith<V>>::visit_with(src, visitor);
                <Option<Box<ObjectLit>> as VisitWith<V>>::visit_with(with, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for NewExpr {
    #[doc = "Calls [Visit`::visit_new_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_new_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            NewExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                <Box<Expr> as VisitWith<V>>::visit_with(callee, visitor);
                <Option<Vec<ExprOrSpread>> as VisitWith<V>>::visit_with(args, visitor);
                <Option<Box<TsTypeParamInstantiation>> as VisitWith<V>>::visit_with(
                    type_args, visitor,
                );
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Null {
    #[doc = "Calls [Visit`::visit_null`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_null(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Null { span } => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Number {
    #[doc = "Calls [Visit`::visit_number`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_number(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Number { span, value, raw } => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ObjectLit {
    #[doc = "Calls [Visit`::visit_object_lit`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_object_lit(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ObjectLit { span, props } => {
                <Vec<PropOrSpread> as VisitWith<V>>::visit_with(props, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ObjectPat {
    #[doc = "Calls [Visit`::visit_object_pat`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_object_pat(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ObjectPat {
                span,
                props,
                optional,
                type_ann,
            } => {
                <Vec<ObjectPatProp> as VisitWith<V>>::visit_with(props, visitor);
                <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ObjectPatProp {
    #[doc = "Calls [Visit`::visit_object_pat_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_object_pat_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ObjectPatProp::KeyValue { 0: _field_0 } => {
                <KeyValuePatProp as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ObjectPatProp::Assign { 0: _field_0 } => {
                <AssignPatProp as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ObjectPatProp::Rest { 0: _field_0 } => {
                <RestPat as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for OptCall {
    #[doc = "Calls [Visit`::visit_opt_call`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_call(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            OptCall {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                <Box<Expr> as VisitWith<V>>::visit_with(callee, visitor);
                <Vec<ExprOrSpread> as VisitWith<V>>::visit_with(args, visitor);
                <Option<Box<TsTypeParamInstantiation>> as VisitWith<V>>::visit_with(
                    type_args, visitor,
                );
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for OptChainBase {
    #[doc = "Calls [Visit`::visit_opt_chain_base`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_chain_base(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            OptChainBase::Member { 0: _field_0 } => {
                <MemberExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            OptChainBase::Call { 0: _field_0 } => {
                <OptCall as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for OptChainExpr {
    #[doc = "Calls [Visit`::visit_opt_chain_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_chain_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            OptChainExpr {
                span,
                optional,
                base,
            } => {
                <Box<OptChainBase> as VisitWith<V>>::visit_with(base, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Param {
    #[doc = "Calls [Visit`::visit_param`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_param(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Param {
                span,
                decorators,
                pat,
            } => {
                <Vec<Decorator> as VisitWith<V>>::visit_with(decorators, visitor);
                <Pat as VisitWith<V>>::visit_with(pat, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ParamOrTsParamProp {
    #[doc = "Calls [Visit`::visit_param_or_ts_param_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_param_or_ts_param_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ParamOrTsParamProp::TsParamProp { 0: _field_0 } => {
                <TsParamProp as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            ParamOrTsParamProp::Param { 0: _field_0 } => {
                <Param as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ParenExpr {
    #[doc = "Calls [Visit`::visit_paren_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_paren_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ParenExpr { span, expr } => {
                <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Pat {
    #[doc = "Calls [Visit`::visit_pat`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_pat(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Pat::Ident { 0: _field_0 } => {
                <BindingIdent as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Pat::Array { 0: _field_0 } => {
                <ArrayPat as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Pat::Rest { 0: _field_0 } => {
                <RestPat as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Pat::Object { 0: _field_0 } => {
                <ObjectPat as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Pat::Assign { 0: _field_0 } => {
                <AssignPat as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Pat::Invalid { 0: _field_0 } => {
                <Invalid as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Pat::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for PrivateName {
    #[doc = "Calls [Visit`::visit_private_name`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_private_name(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            PrivateName { span, name } => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for PrivateProp {
    #[doc = "Calls [Visit`::visit_private_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_private_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            PrivateProp {
                span,
                ctxt,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_optional,
                is_override,
                readonly,
                definite,
            } => {
                <PrivateName as VisitWith<V>>::visit_with(key, visitor);
                <Option<Box<Expr>> as VisitWith<V>>::visit_with(value, visitor);
                <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor);
                <Vec<Decorator> as VisitWith<V>>::visit_with(decorators, visitor);
                <Option<Accessibility> as VisitWith<V>>::visit_with(accessibility, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Program {
    #[doc = "Calls [Visit`::visit_program`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_program(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Program::Module { 0: _field_0 } => {
                <Module as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Program::Script { 0: _field_0 } => {
                <Script as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Prop {
    #[doc = "Calls [Visit`::visit_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Prop::Shorthand { 0: _field_0 } => {
                <Ident as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Prop::KeyValue { 0: _field_0 } => {
                <KeyValueProp as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Prop::Assign { 0: _field_0 } => {
                <AssignProp as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Prop::Getter { 0: _field_0 } => {
                <GetterProp as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Prop::Setter { 0: _field_0 } => {
                <SetterProp as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Prop::Method { 0: _field_0 } => {
                <MethodProp as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for PropName {
    #[doc = "Calls [Visit`::visit_prop_name`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_prop_name(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            PropName::Ident { 0: _field_0 } => {
                <IdentName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            PropName::Str { 0: _field_0 } => {
                <Str as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            PropName::Num { 0: _field_0 } => {
                <Number as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            PropName::Computed { 0: _field_0 } => {
                <ComputedPropName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            PropName::BigInt { 0: _field_0 } => {
                <BigInt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for PropOrSpread {
    #[doc = "Calls [Visit`::visit_prop_or_spread`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_prop_or_spread(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            PropOrSpread::Spread { 0: _field_0 } => {
                <SpreadElement as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            PropOrSpread::Prop { 0: _field_0 } => {
                <Box<Prop> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Regex {
    #[doc = "Calls [Visit`::visit_regex`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_regex(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Regex { span, exp, flags } => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ReservedUnused {
    #[doc = "Calls [Visit`::visit_reserved_unused`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_reserved_unused(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ReservedUnused { span, body } => {
                <Option<Vec<ModuleItem>> as VisitWith<V>>::visit_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for RestPat {
    #[doc = "Calls [Visit`::visit_rest_pat`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_rest_pat(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            RestPat {
                span,
                dot3_token,
                arg,
                type_ann,
            } => {
                <Box<Pat> as VisitWith<V>>::visit_with(arg, visitor);
                <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ReturnStmt {
    #[doc = "Calls [Visit`::visit_return_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_return_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ReturnStmt { span, arg } => {
                <Option<Box<Expr>> as VisitWith<V>>::visit_with(arg, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Script {
    #[doc = "Calls [Visit`::visit_script`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_script(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Script {
                span,
                body,
                shebang,
            } => {
                <Vec<Stmt> as VisitWith<V>>::visit_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for SeqExpr {
    #[doc = "Calls [Visit`::visit_seq_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_seq_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            SeqExpr { span, exprs } => {
                <Vec<Box<Expr>> as VisitWith<V>>::visit_with(exprs, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for SetterProp {
    #[doc = "Calls [Visit`::visit_setter_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_setter_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            SetterProp {
                span,
                key,
                this_param,
                param,
                body,
            } => {
                <PropName as VisitWith<V>>::visit_with(key, visitor);
                <Option<Pat> as VisitWith<V>>::visit_with(this_param, visitor);
                <Box<Pat> as VisitWith<V>>::visit_with(param, visitor);
                <Option<BlockStmt> as VisitWith<V>>::visit_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for SimpleAssignTarget {
    #[doc = "Calls [Visit`::visit_simple_assign_target`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_simple_assign_target(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            SimpleAssignTarget::Ident { 0: _field_0 } => {
                <BindingIdent as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SimpleAssignTarget::Member { 0: _field_0 } => {
                <MemberExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SimpleAssignTarget::SuperProp { 0: _field_0 } => {
                <SuperPropExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SimpleAssignTarget::Paren { 0: _field_0 } => {
                <ParenExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SimpleAssignTarget::OptChain { 0: _field_0 } => {
                <OptChainExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SimpleAssignTarget::TsAs { 0: _field_0 } => {
                <TsAsExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SimpleAssignTarget::TsSatisfies { 0: _field_0 } => {
                <TsSatisfiesExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SimpleAssignTarget::TsNonNull { 0: _field_0 } => {
                <TsNonNullExpr as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SimpleAssignTarget::TsTypeAssertion { 0: _field_0 } => {
                <TsTypeAssertion as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SimpleAssignTarget::TsInstantiation { 0: _field_0 } => {
                <TsInstantiation as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SimpleAssignTarget::Invalid { 0: _field_0 } => {
                <Invalid as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for SpreadElement {
    #[doc = "Calls [Visit`::visit_spread_element`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_spread_element(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            SpreadElement { dot3_token, expr } => {
                <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for StaticBlock {
    #[doc = "Calls [Visit`::visit_static_block`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_static_block(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            StaticBlock { span, body } => {
                <BlockStmt as VisitWith<V>>::visit_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Stmt {
    #[doc = "Calls [Visit`::visit_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Stmt::Block { 0: _field_0 } => {
                <BlockStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Empty { 0: _field_0 } => {
                <EmptyStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Debugger { 0: _field_0 } => {
                <DebuggerStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::With { 0: _field_0 } => {
                <WithStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Return { 0: _field_0 } => {
                <ReturnStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Labeled { 0: _field_0 } => {
                <LabeledStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Break { 0: _field_0 } => {
                <BreakStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Continue { 0: _field_0 } => {
                <ContinueStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::If { 0: _field_0 } => {
                <IfStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Switch { 0: _field_0 } => {
                <SwitchStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Throw { 0: _field_0 } => {
                <ThrowStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Try { 0: _field_0 } => {
                <Box<TryStmt> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::While { 0: _field_0 } => {
                <WhileStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::DoWhile { 0: _field_0 } => {
                <DoWhileStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::For { 0: _field_0 } => {
                <ForStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::ForIn { 0: _field_0 } => {
                <ForInStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::ForOf { 0: _field_0 } => {
                <ForOfStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Decl { 0: _field_0 } => {
                <Decl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            Stmt::Expr { 0: _field_0 } => {
                <ExprStmt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Str {
    #[doc = "Calls [Visit`::visit_str`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_str(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Str { span, value, raw } => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Super {
    #[doc = "Calls [Visit`::visit_super`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_super(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Super { span } => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for SuperProp {
    #[doc = "Calls [Visit`::visit_super_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_super_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            SuperProp::Ident { 0: _field_0 } => {
                <IdentName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            SuperProp::Computed { 0: _field_0 } => {
                <ComputedPropName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for SuperPropExpr {
    #[doc = "Calls [Visit`::visit_super_prop_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_super_prop_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            SuperPropExpr { span, obj, prop } => {
                <Super as VisitWith<V>>::visit_with(obj, visitor);
                <SuperProp as VisitWith<V>>::visit_with(prop, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for SwitchCase {
    #[doc = "Calls [Visit`::visit_switch_case`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_switch_case(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            SwitchCase { span, test, cons } => {
                <Option<Box<Expr>> as VisitWith<V>>::visit_with(test, visitor);
                <Vec<Stmt> as VisitWith<V>>::visit_with(cons, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for SwitchStmt {
    #[doc = "Calls [Visit`::visit_switch_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_switch_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            SwitchStmt {
                span,
                discriminant,
                cases,
            } => {
                <Box<Expr> as VisitWith<V>>::visit_with(discriminant, visitor);
                <Vec<SwitchCase> as VisitWith<V>>::visit_with(cases, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TaggedTpl {
    #[doc = "Calls [Visit`::visit_tagged_tpl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_tagged_tpl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TaggedTpl {
                span,
                ctxt,
                tag,
                type_params,
                tpl,
            } => {
                <Box<Expr> as VisitWith<V>>::visit_with(tag, visitor);
                <Option<Box<TsTypeParamInstantiation>> as VisitWith<V>>::visit_with(
                    type_params,
                    visitor,
                );
                <Box<Tpl> as VisitWith<V>>::visit_with(tpl, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ThisExpr {
    #[doc = "Calls [Visit`::visit_this_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_this_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ThisExpr { span } => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ThrowStmt {
    #[doc = "Calls [Visit`::visit_throw_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_throw_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            ThrowStmt { span, arg } => {
                <Box<Expr> as VisitWith<V>>::visit_with(arg, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Tpl {
    #[doc = "Calls [Visit`::visit_tpl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_tpl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Tpl {
                span,
                exprs,
                quasis,
            } => {
                <Vec<Box<Expr>> as VisitWith<V>>::visit_with(exprs, visitor);
                <Vec<TplElement> as VisitWith<V>>::visit_with(quasis, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TplElement {
    #[doc = "Calls [Visit`::visit_tpl_element`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_tpl_element(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TplElement {
                span,
                tail,
                cooked,
                raw,
            } => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TruePlusMinus {
    #[doc = "Calls [Visit`::visit_true_plus_minus`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_true_plus_minus(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TruePlusMinus::True => {}
            TruePlusMinus::Plus => {}
            TruePlusMinus::Minus => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TryStmt {
    #[doc = "Calls [Visit`::visit_try_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_try_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TryStmt {
                span,
                block,
                handler,
                finalizer,
            } => {
                <BlockStmt as VisitWith<V>>::visit_with(block, visitor);
                <Option<CatchClause> as VisitWith<V>>::visit_with(handler, visitor);
                <Option<BlockStmt> as VisitWith<V>>::visit_with(finalizer, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsArrayType {
    #[doc = "Calls [Visit`::visit_ts_array_type`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_array_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsArrayType { span, elem_type } => {
                <Box<TsType> as VisitWith<V>>::visit_with(elem_type, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsAsExpr {
    #[doc = "Calls [Visit`::visit_ts_as_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_as_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsAsExpr {
                span,
                expr,
                type_ann,
            } => {
                <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor);
                <Box<TsType> as VisitWith<V>>::visit_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsCallSignatureDecl {
    #[doc = "Calls [Visit`::visit_ts_call_signature_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_call_signature_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsCallSignatureDecl {
                span,
                params,
                type_ann,
                type_params,
            } => {
                <Vec<TsFnParam> as VisitWith<V>>::visit_with(params, visitor);
                <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor);
                <Option<Box<TsTypeParamDecl>> as VisitWith<V>>::visit_with(type_params, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsConditionalType {
    #[doc = "Calls [Visit`::visit_ts_conditional_type`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_conditional_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsConditionalType {
                span,
                check_type,
                extends_type,
                true_type,
                false_type,
            } => {
                <Box<TsType> as VisitWith<V>>::visit_with(check_type, visitor);
                <Box<TsType> as VisitWith<V>>::visit_with(extends_type, visitor);
                <Box<TsType> as VisitWith<V>>::visit_with(true_type, visitor);
                <Box<TsType> as VisitWith<V>>::visit_with(false_type, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsConstAssertion {
    #[doc = "Calls [Visit`::visit_ts_const_assertion`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_const_assertion(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsConstAssertion { span, expr } => {
                <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsConstructSignatureDecl {
    #[doc = "Calls [Visit`::visit_ts_construct_signature_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_construct_signature_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsConstructSignatureDecl {
                span,
                params,
                type_ann,
                type_params,
            } => {
                <Vec<TsFnParam> as VisitWith<V>>::visit_with(params, visitor);
                <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor);
                <Option<Box<TsTypeParamDecl>> as VisitWith<V>>::visit_with(type_params, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsConstructorType {
    #[doc = "Calls [Visit`::visit_ts_constructor_type`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_constructor_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsConstructorType {
                span,
                params,
                type_params,
                type_ann,
                is_abstract,
            } => {
                <Vec<TsFnParam> as VisitWith<V>>::visit_with(params, visitor);
                <Option<Box<TsTypeParamDecl>> as VisitWith<V>>::visit_with(type_params, visitor);
                <Box<TsTypeAnn> as VisitWith<V>>::visit_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsEntityName {
    #[doc = "Calls [Visit`::visit_ts_entity_name`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_entity_name(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsEntityName::TsQualifiedName { 0: _field_0 } => {
                <Box<TsQualifiedName> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsEntityName::Ident { 0: _field_0 } => {
                <Ident as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsEnumDecl {
    #[doc = "Calls [Visit`::visit_ts_enum_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_enum_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsEnumDecl {
                span,
                declare,
                is_const,
                id,
                members,
            } => {
                <Ident as VisitWith<V>>::visit_with(id, visitor);
                <Vec<TsEnumMember> as VisitWith<V>>::visit_with(members, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsEnumMember {
    #[doc = "Calls [Visit`::visit_ts_enum_member`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_enum_member(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsEnumMember { span, id, init } => {
                <TsEnumMemberId as VisitWith<V>>::visit_with(id, visitor);
                <Option<Box<Expr>> as VisitWith<V>>::visit_with(init, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsEnumMemberId {
    #[doc = "Calls [Visit`::visit_ts_enum_member_id`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_enum_member_id(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsEnumMemberId::Ident { 0: _field_0 } => {
                <Ident as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsEnumMemberId::Str { 0: _field_0 } => {
                <Str as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsExportAssignment {
    #[doc = "Calls [Visit`::visit_ts_export_assignment`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_export_assignment(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsExportAssignment { span, expr } => {
                <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsExprWithTypeArgs {
    #[doc = "Calls [Visit`::visit_ts_expr_with_type_args`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_expr_with_type_args(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsExprWithTypeArgs {
                span,
                expr,
                type_args,
            } => {
                <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor);
                <Option<Box<TsTypeParamInstantiation>> as VisitWith<V>>::visit_with(
                    type_args, visitor,
                );
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsExternalModuleRef {
    #[doc = "Calls [Visit`::visit_ts_external_module_ref`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_external_module_ref(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsExternalModuleRef { span, expr } => {
                <Str as VisitWith<V>>::visit_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsFnOrConstructorType {
    #[doc = "Calls [Visit`::visit_ts_fn_or_constructor_type`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_fn_or_constructor_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsFnOrConstructorType::TsFnType { 0: _field_0 } => {
                <TsFnType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsFnOrConstructorType::TsConstructorType { 0: _field_0 } => {
                <TsConstructorType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsFnParam {
    #[doc = "Calls [Visit`::visit_ts_fn_param`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_fn_param(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsFnParam::Ident { 0: _field_0 } => {
                <BindingIdent as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsFnParam::Array { 0: _field_0 } => {
                <ArrayPat as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsFnParam::Rest { 0: _field_0 } => {
                <RestPat as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsFnParam::Object { 0: _field_0 } => {
                <ObjectPat as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsFnType {
    #[doc = "Calls [Visit`::visit_ts_fn_type`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_fn_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsFnType {
                span,
                params,
                type_params,
                type_ann,
            } => {
                <Vec<TsFnParam> as VisitWith<V>>::visit_with(params, visitor);
                <Option<Box<TsTypeParamDecl>> as VisitWith<V>>::visit_with(type_params, visitor);
                <Box<TsTypeAnn> as VisitWith<V>>::visit_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsGetterSignature {
    #[doc = "Calls [Visit`::visit_ts_getter_signature`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_getter_signature(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsGetterSignature {
                span,
                key,
                computed,
                type_ann,
            } => {
                <Box<Expr> as VisitWith<V>>::visit_with(key, visitor);
                <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsImportEqualsDecl {
    #[doc = "Calls [Visit`::visit_ts_import_equals_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_import_equals_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsImportEqualsDecl {
                span,
                is_export,
                is_type_only,
                id,
                module_ref,
            } => {
                <Ident as VisitWith<V>>::visit_with(id, visitor);
                <TsModuleRef as VisitWith<V>>::visit_with(module_ref, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsImportType {
    #[doc = "Calls [Visit`::visit_ts_import_type`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_import_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsImportType {
                span,
                arg,
                qualifier,
                type_args,
            } => {
                <Str as VisitWith<V>>::visit_with(arg, visitor);
                <Option<TsEntityName> as VisitWith<V>>::visit_with(qualifier, visitor);
                <Option<Box<TsTypeParamInstantiation>> as VisitWith<V>>::visit_with(
                    type_args, visitor,
                );
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsIndexSignature {
    #[doc = "Calls [Visit`::visit_ts_index_signature`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_index_signature(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsIndexSignature {
                params,
                type_ann,
                readonly,
                is_static,
                span,
            } => {
                <Vec<TsFnParam> as VisitWith<V>>::visit_with(params, visitor);
                <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsIndexedAccessType {
    #[doc = "Calls [Visit`::visit_ts_indexed_access_type`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_indexed_access_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsIndexedAccessType {
                span,
                readonly,
                obj_type,
                index_type,
            } => {
                <Box<TsType> as VisitWith<V>>::visit_with(obj_type, visitor);
                <Box<TsType> as VisitWith<V>>::visit_with(index_type, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsInferType {
    #[doc = "Calls [Visit`::visit_ts_infer_type`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_infer_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsInferType { span, type_param } => {
                <TsTypeParam as VisitWith<V>>::visit_with(type_param, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsInstantiation {
    #[doc = "Calls [Visit`::visit_ts_instantiation`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_instantiation(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsInstantiation {
                span,
                expr,
                type_args,
            } => {
                <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor);
                <Box<TsTypeParamInstantiation> as VisitWith<V>>::visit_with(type_args, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsInterfaceBody {
    #[doc = "Calls [Visit`::visit_ts_interface_body`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_interface_body(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsInterfaceBody { span, body } => {
                <Vec<TsTypeElement> as VisitWith<V>>::visit_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsInterfaceDecl {
    #[doc = "Calls [Visit`::visit_ts_interface_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_interface_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsInterfaceDecl {
                span,
                id,
                declare,
                type_params,
                extends,
                body,
            } => {
                <Ident as VisitWith<V>>::visit_with(id, visitor);
                <Option<Box<TsTypeParamDecl>> as VisitWith<V>>::visit_with(type_params, visitor);
                <Vec<TsExprWithTypeArgs> as VisitWith<V>>::visit_with(extends, visitor);
                <TsInterfaceBody as VisitWith<V>>::visit_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsIntersectionType {
    #[doc = "Calls [Visit`::visit_ts_intersection_type`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_intersection_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsIntersectionType { span, types } => {
                <Vec<Box<TsType>> as VisitWith<V>>::visit_with(types, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsKeywordType {
    #[doc = "Calls [Visit`::visit_ts_keyword_type`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_keyword_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsKeywordType { span, kind } => {
                <TsKeywordTypeKind as VisitWith<V>>::visit_with(kind, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsKeywordTypeKind {
    #[doc = "Calls [Visit`::visit_ts_keyword_type_kind`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_keyword_type_kind(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsKeywordTypeKind::TsAnyKeyword => {}
            TsKeywordTypeKind::TsUnknownKeyword => {}
            TsKeywordTypeKind::TsNumberKeyword => {}
            TsKeywordTypeKind::TsObjectKeyword => {}
            TsKeywordTypeKind::TsBooleanKeyword => {}
            TsKeywordTypeKind::TsBigIntKeyword => {}
            TsKeywordTypeKind::TsStringKeyword => {}
            TsKeywordTypeKind::TsSymbolKeyword => {}
            TsKeywordTypeKind::TsVoidKeyword => {}
            TsKeywordTypeKind::TsUndefinedKeyword => {}
            TsKeywordTypeKind::TsNullKeyword => {}
            TsKeywordTypeKind::TsNeverKeyword => {}
            TsKeywordTypeKind::TsIntrinsicKeyword => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsLit {
    #[doc = "Calls [Visit`::visit_ts_lit`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_lit(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsLit::Number { 0: _field_0 } => {
                <Number as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsLit::Str { 0: _field_0 } => {
                <Str as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsLit::Bool { 0: _field_0 } => {
                <Bool as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsLit::BigInt { 0: _field_0 } => {
                <BigInt as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsLit::Tpl { 0: _field_0 } => {
                <TsTplLitType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsLitType {
    #[doc = "Calls [Visit`::visit_ts_lit_type`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_lit_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsLitType { span, lit } => {
                <TsLit as VisitWith<V>>::visit_with(lit, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsMappedType {
    #[doc = "Calls [Visit`::visit_ts_mapped_type`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_mapped_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsMappedType {
                span,
                readonly,
                type_param,
                name_type,
                optional,
                type_ann,
            } => {
                <Option<TruePlusMinus> as VisitWith<V>>::visit_with(readonly, visitor);
                <TsTypeParam as VisitWith<V>>::visit_with(type_param, visitor);
                <Option<Box<TsType>> as VisitWith<V>>::visit_with(name_type, visitor);
                <Option<TruePlusMinus> as VisitWith<V>>::visit_with(optional, visitor);
                <Option<Box<TsType>> as VisitWith<V>>::visit_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsMethodSignature {
    #[doc = "Calls [Visit`::visit_ts_method_signature`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_method_signature(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsMethodSignature {
                span,
                key,
                computed,
                optional,
                params,
                type_ann,
                type_params,
            } => {
                <Box<Expr> as VisitWith<V>>::visit_with(key, visitor);
                <Vec<TsFnParam> as VisitWith<V>>::visit_with(params, visitor);
                <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor);
                <Option<Box<TsTypeParamDecl>> as VisitWith<V>>::visit_with(type_params, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsModuleBlock {
    #[doc = "Calls [Visit`::visit_ts_module_block`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_module_block(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsModuleBlock { span, body } => {
                <Vec<ModuleItem> as VisitWith<V>>::visit_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsModuleDecl {
    #[doc = "Calls [Visit`::visit_ts_module_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_module_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsModuleDecl {
                span,
                declare,
                global,
                id,
                body,
            } => {
                <TsModuleName as VisitWith<V>>::visit_with(id, visitor);
                <Option<TsNamespaceBody> as VisitWith<V>>::visit_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsModuleName {
    #[doc = "Calls [Visit`::visit_ts_module_name`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_module_name(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsModuleName::Ident { 0: _field_0 } => {
                <Ident as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsModuleName::Str { 0: _field_0 } => {
                <Str as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsModuleRef {
    #[doc = "Calls [Visit`::visit_ts_module_ref`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_module_ref(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsModuleRef::TsEntityName { 0: _field_0 } => {
                <TsEntityName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsModuleRef::TsExternalModuleRef { 0: _field_0 } => {
                <TsExternalModuleRef as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsNamespaceBody {
    #[doc = "Calls [Visit`::visit_ts_namespace_body`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_namespace_body(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsNamespaceBody::TsModuleBlock { 0: _field_0 } => {
                <TsModuleBlock as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsNamespaceBody::TsNamespaceDecl { 0: _field_0 } => {
                <TsNamespaceDecl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsNamespaceDecl {
    #[doc = "Calls [Visit`::visit_ts_namespace_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_namespace_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsNamespaceDecl {
                span,
                declare,
                global,
                id,
                body,
            } => {
                <Ident as VisitWith<V>>::visit_with(id, visitor);
                <Box<TsNamespaceBody> as VisitWith<V>>::visit_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsNamespaceExportDecl {
    #[doc = "Calls [Visit`::visit_ts_namespace_export_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_namespace_export_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsNamespaceExportDecl { span, id } => {
                <Ident as VisitWith<V>>::visit_with(id, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsNonNullExpr {
    #[doc = "Calls [Visit`::visit_ts_non_null_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_non_null_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsNonNullExpr { span, expr } => {
                <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsOptionalType {
    #[doc = "Calls [Visit`::visit_ts_optional_type`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_optional_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsOptionalType { span, type_ann } => {
                <Box<TsType> as VisitWith<V>>::visit_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsParamProp {
    #[doc = "Calls [Visit`::visit_ts_param_prop`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_param_prop(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsParamProp {
                span,
                decorators,
                accessibility,
                is_override,
                readonly,
                param,
            } => {
                <Vec<Decorator> as VisitWith<V>>::visit_with(decorators, visitor);
                <Option<Accessibility> as VisitWith<V>>::visit_with(accessibility, visitor);
                <TsParamPropParam as VisitWith<V>>::visit_with(param, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsParamPropParam {
    #[doc = "Calls [Visit`::visit_ts_param_prop_param`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_param_prop_param(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsParamPropParam::Ident { 0: _field_0 } => {
                <BindingIdent as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsParamPropParam::Assign { 0: _field_0 } => {
                <AssignPat as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsParenthesizedType {
    #[doc = "Calls [Visit`::visit_ts_parenthesized_type`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_parenthesized_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsParenthesizedType { span, type_ann } => {
                <Box<TsType> as VisitWith<V>>::visit_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsPropertySignature {
    #[doc = "Calls [Visit`::visit_ts_property_signature`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_property_signature(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsPropertySignature {
                span,
                readonly,
                key,
                computed,
                optional,
                type_ann,
            } => {
                <Box<Expr> as VisitWith<V>>::visit_with(key, visitor);
                <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsQualifiedName {
    #[doc = "Calls [Visit`::visit_ts_qualified_name`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_qualified_name(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsQualifiedName { span, left, right } => {
                <TsEntityName as VisitWith<V>>::visit_with(left, visitor);
                <IdentName as VisitWith<V>>::visit_with(right, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsRestType {
    #[doc = "Calls [Visit`::visit_ts_rest_type`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_rest_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsRestType { span, type_ann } => {
                <Box<TsType> as VisitWith<V>>::visit_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsSatisfiesExpr {
    #[doc = "Calls [Visit`::visit_ts_satisfies_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_satisfies_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsSatisfiesExpr {
                span,
                expr,
                type_ann,
            } => {
                <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor);
                <Box<TsType> as VisitWith<V>>::visit_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsSetterSignature {
    #[doc = "Calls [Visit`::visit_ts_setter_signature`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_setter_signature(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsSetterSignature {
                span,
                key,
                computed,
                param,
            } => {
                <Box<Expr> as VisitWith<V>>::visit_with(key, visitor);
                <TsFnParam as VisitWith<V>>::visit_with(param, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsThisType {
    #[doc = "Calls [Visit`::visit_ts_this_type`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_this_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsThisType { span } => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsThisTypeOrIdent {
    #[doc = "Calls [Visit`::visit_ts_this_type_or_ident`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_this_type_or_ident(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsThisTypeOrIdent::TsThisType { 0: _field_0 } => {
                <TsThisType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsThisTypeOrIdent::Ident { 0: _field_0 } => {
                <Ident as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsTplLitType {
    #[doc = "Calls [Visit`::visit_ts_tpl_lit_type`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_tpl_lit_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsTplLitType {
                span,
                types,
                quasis,
            } => {
                <Vec<Box<TsType>> as VisitWith<V>>::visit_with(types, visitor);
                <Vec<TplElement> as VisitWith<V>>::visit_with(quasis, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsTupleElement {
    #[doc = "Calls [Visit`::visit_ts_tuple_element`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_tuple_element(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsTupleElement { span, label, ty } => {
                <Option<Pat> as VisitWith<V>>::visit_with(label, visitor);
                <Box<TsType> as VisitWith<V>>::visit_with(ty, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsTupleType {
    #[doc = "Calls [Visit`::visit_ts_tuple_type`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_tuple_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsTupleType { span, elem_types } => {
                <Vec<TsTupleElement> as VisitWith<V>>::visit_with(elem_types, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsType {
    #[doc = "Calls [Visit`::visit_ts_type`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsType::TsKeywordType { 0: _field_0 } => {
                <TsKeywordType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsType::TsThisType { 0: _field_0 } => {
                <TsThisType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsType::TsFnOrConstructorType { 0: _field_0 } => {
                <TsFnOrConstructorType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsType::TsTypeRef { 0: _field_0 } => {
                <TsTypeRef as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsType::TsTypeQuery { 0: _field_0 } => {
                <TsTypeQuery as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsType::TsTypeLit { 0: _field_0 } => {
                <TsTypeLit as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsType::TsArrayType { 0: _field_0 } => {
                <TsArrayType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsType::TsTupleType { 0: _field_0 } => {
                <TsTupleType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsType::TsOptionalType { 0: _field_0 } => {
                <TsOptionalType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsType::TsRestType { 0: _field_0 } => {
                <TsRestType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsType::TsUnionOrIntersectionType { 0: _field_0 } => {
                <TsUnionOrIntersectionType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsType::TsConditionalType { 0: _field_0 } => {
                <TsConditionalType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsType::TsInferType { 0: _field_0 } => {
                <TsInferType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsType::TsParenthesizedType { 0: _field_0 } => {
                <TsParenthesizedType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsType::TsTypeOperator { 0: _field_0 } => {
                <TsTypeOperator as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsType::TsIndexedAccessType { 0: _field_0 } => {
                <TsIndexedAccessType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsType::TsMappedType { 0: _field_0 } => {
                <TsMappedType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsType::TsLitType { 0: _field_0 } => {
                <TsLitType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsType::TsTypePredicate { 0: _field_0 } => {
                <TsTypePredicate as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsType::TsImportType { 0: _field_0 } => {
                <TsImportType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsTypeAliasDecl {
    #[doc = "Calls [Visit`::visit_ts_type_alias_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_type_alias_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsTypeAliasDecl {
                span,
                declare,
                id,
                type_params,
                type_ann,
            } => {
                <Ident as VisitWith<V>>::visit_with(id, visitor);
                <Option<Box<TsTypeParamDecl>> as VisitWith<V>>::visit_with(type_params, visitor);
                <Box<TsType> as VisitWith<V>>::visit_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsTypeAnn {
    #[doc = "Calls [Visit`::visit_ts_type_ann`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_type_ann(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsTypeAnn { span, type_ann } => {
                <Box<TsType> as VisitWith<V>>::visit_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsTypeAssertion {
    #[doc = "Calls [Visit`::visit_ts_type_assertion`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_type_assertion(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsTypeAssertion {
                span,
                expr,
                type_ann,
            } => {
                <Box<Expr> as VisitWith<V>>::visit_with(expr, visitor);
                <Box<TsType> as VisitWith<V>>::visit_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsTypeElement {
    #[doc = "Calls [Visit`::visit_ts_type_element`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_type_element(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsTypeElement::TsCallSignatureDecl { 0: _field_0 } => {
                <TsCallSignatureDecl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsTypeElement::TsConstructSignatureDecl { 0: _field_0 } => {
                <TsConstructSignatureDecl as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsTypeElement::TsPropertySignature { 0: _field_0 } => {
                <TsPropertySignature as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsTypeElement::TsGetterSignature { 0: _field_0 } => {
                <TsGetterSignature as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsTypeElement::TsSetterSignature { 0: _field_0 } => {
                <TsSetterSignature as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsTypeElement::TsMethodSignature { 0: _field_0 } => {
                <TsMethodSignature as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsTypeElement::TsIndexSignature { 0: _field_0 } => {
                <TsIndexSignature as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsTypeLit {
    #[doc = "Calls [Visit`::visit_ts_type_lit`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_type_lit(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsTypeLit { span, members } => {
                <Vec<TsTypeElement> as VisitWith<V>>::visit_with(members, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsTypeOperator {
    #[doc = "Calls [Visit`::visit_ts_type_operator`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_type_operator(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsTypeOperator { span, op, type_ann } => {
                <TsTypeOperatorOp as VisitWith<V>>::visit_with(op, visitor);
                <Box<TsType> as VisitWith<V>>::visit_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsTypeOperatorOp {
    #[doc = "Calls [Visit`::visit_ts_type_operator_op`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_type_operator_op(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsTypeOperatorOp::KeyOf => {}
            TsTypeOperatorOp::Unique => {}
            TsTypeOperatorOp::ReadOnly => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsTypeParam {
    #[doc = "Calls [Visit`::visit_ts_type_param`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_type_param(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsTypeParam {
                span,
                name,
                is_in,
                is_out,
                is_const,
                constraint,
                default,
            } => {
                <Ident as VisitWith<V>>::visit_with(name, visitor);
                <Option<Box<TsType>> as VisitWith<V>>::visit_with(constraint, visitor);
                <Option<Box<TsType>> as VisitWith<V>>::visit_with(default, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsTypeParamDecl {
    #[doc = "Calls [Visit`::visit_ts_type_param_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_type_param_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsTypeParamDecl { span, params } => {
                <Vec<TsTypeParam> as VisitWith<V>>::visit_with(params, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsTypeParamInstantiation {
    #[doc = "Calls [Visit`::visit_ts_type_param_instantiation`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_type_param_instantiation(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsTypeParamInstantiation { span, params } => {
                <Vec<Box<TsType>> as VisitWith<V>>::visit_with(params, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsTypePredicate {
    #[doc = "Calls [Visit`::visit_ts_type_predicate`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_type_predicate(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsTypePredicate {
                span,
                asserts,
                param_name,
                type_ann,
            } => {
                <TsThisTypeOrIdent as VisitWith<V>>::visit_with(param_name, visitor);
                <Option<Box<TsTypeAnn>> as VisitWith<V>>::visit_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsTypeQuery {
    #[doc = "Calls [Visit`::visit_ts_type_query`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_type_query(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsTypeQuery {
                span,
                expr_name,
                type_args,
            } => {
                <TsTypeQueryExpr as VisitWith<V>>::visit_with(expr_name, visitor);
                <Option<Box<TsTypeParamInstantiation>> as VisitWith<V>>::visit_with(
                    type_args, visitor,
                );
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsTypeQueryExpr {
    #[doc = "Calls [Visit`::visit_ts_type_query_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_type_query_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsTypeQueryExpr::TsEntityName { 0: _field_0 } => {
                <TsEntityName as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsTypeQueryExpr::Import { 0: _field_0 } => {
                <TsImportType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsTypeRef {
    #[doc = "Calls [Visit`::visit_ts_type_ref`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_type_ref(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsTypeRef {
                span,
                type_name,
                type_params,
            } => {
                <TsEntityName as VisitWith<V>>::visit_with(type_name, visitor);
                <Option<Box<TsTypeParamInstantiation>> as VisitWith<V>>::visit_with(
                    type_params,
                    visitor,
                );
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsUnionOrIntersectionType {
    #[doc = "Calls [Visit`::visit_ts_union_or_intersection_type`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_union_or_intersection_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsUnionOrIntersectionType::TsUnionType { 0: _field_0 } => {
                <TsUnionType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            TsUnionOrIntersectionType::TsIntersectionType { 0: _field_0 } => {
                <TsIntersectionType as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for TsUnionType {
    #[doc = "Calls [Visit`::visit_ts_union_type`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_union_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            TsUnionType { span, types } => {
                <Vec<Box<TsType>> as VisitWith<V>>::visit_with(types, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for UnaryExpr {
    #[doc = "Calls [Visit`::visit_unary_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_unary_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            UnaryExpr { span, op, arg } => {
                <UnaryOp as VisitWith<V>>::visit_with(op, visitor);
                <Box<Expr> as VisitWith<V>>::visit_with(arg, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for UnaryOp {
    #[doc = "Calls [Visit`::visit_unary_op`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_unary_op(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            UnaryOp::Minus => {}
            UnaryOp::Plus => {}
            UnaryOp::Bang => {}
            UnaryOp::Tilde => {}
            UnaryOp::TypeOf => {}
            UnaryOp::Void => {}
            UnaryOp::Delete => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for UpdateExpr {
    #[doc = "Calls [Visit`::visit_update_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_update_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            UpdateExpr {
                span,
                op,
                prefix,
                arg,
            } => {
                <UpdateOp as VisitWith<V>>::visit_with(op, visitor);
                <Box<Expr> as VisitWith<V>>::visit_with(arg, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for UpdateOp {
    #[doc = "Calls [Visit`::visit_update_op`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_update_op(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            UpdateOp::PlusPlus => {}
            UpdateOp::MinusMinus => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for UsingDecl {
    #[doc = "Calls [Visit`::visit_using_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_using_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            UsingDecl {
                span,
                is_await,
                decls,
            } => {
                <Vec<VarDeclarator> as VisitWith<V>>::visit_with(decls, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for VarDecl {
    #[doc = "Calls [Visit`::visit_var_decl`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_var_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            VarDecl {
                span,
                ctxt,
                kind,
                declare,
                decls,
            } => {
                <VarDeclKind as VisitWith<V>>::visit_with(kind, visitor);
                <Vec<VarDeclarator> as VisitWith<V>>::visit_with(decls, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for VarDeclKind {
    #[doc = "Calls [Visit`::visit_var_decl_kind`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_var_decl_kind(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            VarDeclKind::Var => {}
            VarDeclKind::Let => {}
            VarDeclKind::Const => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for VarDeclOrExpr {
    #[doc = "Calls [Visit`::visit_var_decl_or_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_var_decl_or_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            VarDeclOrExpr::VarDecl { 0: _field_0 } => {
                <Box<VarDecl> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
            VarDeclOrExpr::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitWith<V>>::visit_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for VarDeclarator {
    #[doc = "Calls [Visit`::visit_var_declarator`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_var_declarator(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            VarDeclarator {
                span,
                name,
                init,
                definite,
            } => {
                <Pat as VisitWith<V>>::visit_with(name, visitor);
                <Option<Box<Expr>> as VisitWith<V>>::visit_with(init, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for WhileStmt {
    #[doc = "Calls [Visit`::visit_while_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_while_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            WhileStmt { span, test, body } => {
                <Box<Expr> as VisitWith<V>>::visit_with(test, visitor);
                <Box<Stmt> as VisitWith<V>>::visit_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for WithStmt {
    #[doc = "Calls [Visit`::visit_with_stmt`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_with_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            WithStmt { span, obj, body } => {
                <Box<Expr> as VisitWith<V>>::visit_with(obj, visitor);
                <Box<Stmt> as VisitWith<V>>::visit_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for YieldExpr {
    #[doc = "Calls [Visit`::visit_yield_expr`] with `self`."]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_yield_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            YieldExpr {
                span,
                arg,
                delegate,
            } => {
                <Option<Box<Expr>> as VisitWith<V>>::visit_with(arg, visitor);
            }
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for swc_atoms::Atom {
    #[doc = "Calls [Visit`::visit_atom`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_atom(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for BigIntValue {
    #[doc = "Calls [Visit`::visit_big_int_value`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_big_int_value(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [ClassMember] {
    #[doc = "Calls [Visit`::visit_class_members`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_class_members(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <ClassMember as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for ClassMethod {
    #[doc = "Calls [Visit`::visit_class_method`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_class_method(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [Decorator] {
    #[doc = "Calls [Visit`::visit_decorators`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_decorators(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <Decorator as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [ExportSpecifier] {
    #[doc = "Calls [Visit`::visit_export_specifiers`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_export_specifiers(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <ExportSpecifier as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [ExprOrSpread] {
    #[doc = "Calls [Visit`::visit_expr_or_spreads`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_expr_or_spreads(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <ExprOrSpread as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [Box<Expr>] {
    #[doc = "Calls [Visit`::visit_exprs`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_exprs(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <Box<Expr> as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [ImportSpecifier] {
    #[doc = "Calls [Visit`::visit_import_specifiers`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import_specifiers(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <ImportSpecifier as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [ImportWithItem] {
    #[doc = "Calls [Visit`::visit_import_with_items`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_import_with_items(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <ImportWithItem as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [JSXAttrOrSpread] {
    #[doc = "Calls [Visit`::visit_jsx_attr_or_spreads`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_attr_or_spreads(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <JSXAttrOrSpread as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [JSXElementChild] {
    #[doc = "Calls [Visit`::visit_jsx_element_childs`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_jsx_element_childs(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <JSXElementChild as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [ModuleItem] {
    #[doc = "Calls [Visit`::visit_module_items`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_module_items(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <ModuleItem as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [ObjectPatProp] {
    #[doc = "Calls [Visit`::visit_object_pat_props`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_object_pat_props(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <ObjectPatProp as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<Accessibility> {
    #[doc = "Calls [Visit`::visit_opt_accessibility`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_accessibility(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <Accessibility as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<swc_atoms::Atom> {
    #[doc = "Calls [Visit`::visit_opt_atom`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_atom(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <swc_atoms::Atom as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<BlockStmt> {
    #[doc = "Calls [Visit`::visit_opt_block_stmt`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_block_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <BlockStmt as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<CatchClause> {
    #[doc = "Calls [Visit`::visit_opt_catch_clause`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_catch_clause(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <CatchClause as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<Box<Expr>> {
    #[doc = "Calls [Visit`::visit_opt_expr`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <Box<Expr> as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<ExprOrSpread> {
    #[doc = "Calls [Visit`::visit_opt_expr_or_spread`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_expr_or_spread(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <ExprOrSpread as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<Vec<ExprOrSpread>> {
    #[doc = "Calls [Visit`::visit_opt_expr_or_spreads`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_expr_or_spreads(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <Vec<ExprOrSpread> as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<Ident> {
    #[doc = "Calls [Visit`::visit_opt_ident`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_ident(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <Ident as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<JSXAttrValue> {
    #[doc = "Calls [Visit`::visit_opt_jsx_attr_value`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_jsx_attr_value(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <JSXAttrValue as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<JSXClosingElement> {
    #[doc = "Calls [Visit`::visit_opt_jsx_closing_element`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_jsx_closing_element(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <JSXClosingElement as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<ModuleExportName> {
    #[doc = "Calls [Visit`::visit_opt_module_export_name`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_module_export_name(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <ModuleExportName as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<Vec<ModuleItem>> {
    #[doc = "Calls [Visit`::visit_opt_module_items`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_module_items(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <Vec<ModuleItem> as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<Box<ObjectLit>> {
    #[doc = "Calls [Visit`::visit_opt_object_lit`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_object_lit(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <Box<ObjectLit> as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<Pat> {
    #[doc = "Calls [Visit`::visit_opt_pat`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_pat(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <Pat as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<swc_common::Span> {
    #[doc = "Calls [Visit`::visit_opt_span`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_span(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <swc_common::Span as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<Box<Stmt>> {
    #[doc = "Calls [Visit`::visit_opt_stmt`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_stmt(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <Box<Stmt> as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<Box<Str>> {
    #[doc = "Calls [Visit`::visit_opt_str`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_str(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <Box<Str> as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<TruePlusMinus> {
    #[doc = "Calls [Visit`::visit_opt_true_plus_minus`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_true_plus_minus(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <TruePlusMinus as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<TsEntityName> {
    #[doc = "Calls [Visit`::visit_opt_ts_entity_name`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_ts_entity_name(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <TsEntityName as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<TsNamespaceBody> {
    #[doc = "Calls [Visit`::visit_opt_ts_namespace_body`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_ts_namespace_body(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <TsNamespaceBody as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<Box<TsType>> {
    #[doc = "Calls [Visit`::visit_opt_ts_type`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_ts_type(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <Box<TsType> as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<Box<TsTypeAnn>> {
    #[doc = "Calls [Visit`::visit_opt_ts_type_ann`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_ts_type_ann(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <Box<TsTypeAnn> as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<Box<TsTypeParamDecl>> {
    #[doc = "Calls [Visit`::visit_opt_ts_type_param_decl`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_ts_type_param_decl(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <Box<TsTypeParamDecl> as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<Box<TsTypeParamInstantiation>> {
    #[doc = "Calls [Visit`::visit_opt_ts_type_param_instantiation`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_ts_type_param_instantiation(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => {
                <Box<TsTypeParamInstantiation> as VisitWith<V>>::visit_with(inner, visitor)
            }
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for Option<VarDeclOrExpr> {
    #[doc = "Calls [Visit`::visit_opt_var_decl_or_expr`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_var_decl_or_expr(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        match self {
            Some(inner) => <VarDeclOrExpr as VisitWith<V>>::visit_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [Option<ExprOrSpread>] {
    #[doc = "Calls [Visit`::visit_opt_vec_expr_or_spreads`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_vec_expr_or_spreads(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <Option<ExprOrSpread> as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [Option<Pat>] {
    #[doc = "Calls [Visit`::visit_opt_vec_pats`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_opt_vec_pats(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <Option<Pat> as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [ParamOrTsParamProp] {
    #[doc = "Calls [Visit`::visit_param_or_ts_param_props`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_param_or_ts_param_props(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <ParamOrTsParamProp as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [Param] {
    #[doc = "Calls [Visit`::visit_params`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_params(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <Param as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [Pat] {
    #[doc = "Calls [Visit`::visit_pats`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_pats(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <Pat as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for PrivateMethod {
    #[doc = "Calls [Visit`::visit_private_method`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_private_method(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [PropOrSpread] {
    #[doc = "Calls [Visit`::visit_prop_or_spreads`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_prop_or_spreads(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <PropOrSpread as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for swc_common::Span {
    #[doc = "Calls [Visit`::visit_span`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_span(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [Stmt] {
    #[doc = "Calls [Visit`::visit_stmts`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_stmts(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <Stmt as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [SwitchCase] {
    #[doc = "Calls [Visit`::visit_switch_cases`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_switch_cases(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <SwitchCase as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for swc_common::SyntaxContext {
    #[doc = "Calls [Visit`::visit_syntax_context`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_syntax_context(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [TplElement] {
    #[doc = "Calls [Visit`::visit_tpl_elements`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_tpl_elements(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <TplElement as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [TsEnumMember] {
    #[doc = "Calls [Visit`::visit_ts_enum_members`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_enum_members(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <TsEnumMember as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [TsExprWithTypeArgs] {
    #[doc = "Calls [Visit`::visit_ts_expr_with_type_argss`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_expr_with_type_argss(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <TsExprWithTypeArgs as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [TsFnParam] {
    #[doc = "Calls [Visit`::visit_ts_fn_params`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_fn_params(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <TsFnParam as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [TsTupleElement] {
    #[doc = "Calls [Visit`::visit_ts_tuple_elements`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_tuple_elements(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <TsTupleElement as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [TsTypeElement] {
    #[doc = "Calls [Visit`::visit_ts_type_elements`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_type_elements(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <TsTypeElement as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [TsTypeParam] {
    #[doc = "Calls [Visit`::visit_ts_type_params`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_type_params(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <TsTypeParam as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [Box<TsType>] {
    #[doc = "Calls [Visit`::visit_ts_types`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_ts_types(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <Box<TsType> as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V: ?Sized + Visit> VisitWith<V> for [VarDeclarator] {
    #[doc = "Calls [Visit`::visit_var_declarators`] with `self`. (Extra impl)"]
    fn visit_with(&self, visitor: &mut V) {
        <V as Visit>::visit_var_declarators(visitor, self)
    }

    fn visit_children_with(&self, visitor: &mut V) {
        self.iter()
            .for_each(|item| <VarDeclarator as VisitWith<V>>::visit_with(item, visitor))
    }
}
impl<V, T> VisitWith<V> for std::boxed::Box<T>
where
    V: ?Sized + Visit,
    T: VisitWith<V>,
{
    fn visit_with(&self, visitor: &mut V) {
        let v = <T as VisitWith<V>>::visit_with(&**self, visitor);
        v
    }

    fn visit_children_with(&self, visitor: &mut V) {
        let v = <T as VisitWith<V>>::visit_children_with(&**self, visitor);
        v
    }
}
impl<V, T> VisitWith<V> for std::vec::Vec<T>
where
    V: ?Sized + Visit,
    [T]: VisitWith<V>,
{
    fn visit_with(&self, visitor: &mut V) {
        let v = <[T] as VisitWith<V>>::visit_with(self, visitor);
        v
    }

    fn visit_children_with(&self, visitor: &mut V) {
        let v = <[T] as VisitWith<V>>::visit_children_with(self, visitor);
        v
    }
}
#[doc = r" A visitor trait for traversing the AST."]
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
pub trait VisitAstPath {
    #[doc = "Visit a node of type `Accessibility`.\n\nBy default, this method calls \
             [`Accessibility::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_accessibility<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Accessibility,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Accessibility as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ArrayLit`.\n\nBy default, this method calls \
             [`ArrayLit::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_array_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrayLit,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ArrayLit as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ArrayPat`.\n\nBy default, this method calls \
             [`ArrayPat::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_array_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrayPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ArrayPat as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ArrowExpr`.\n\nBy default, this method calls \
             [`ArrowExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_arrow_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrowExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ArrowExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `AssignExpr`.\n\nBy default, this method calls \
             [`AssignExpr::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_assign_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <AssignExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `AssignOp`.\n\nBy default, this method calls \
             [`AssignOp::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_assign_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <AssignOp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `AssignPat`.\n\nBy default, this method calls \
             [`AssignPat::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_assign_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <AssignPat as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `AssignPatProp`.\n\nBy default, this method calls \
             [`AssignPatProp::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_assign_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignPatProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <AssignPatProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `AssignProp`.\n\nBy default, this method calls \
             [`AssignProp::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_assign_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <AssignProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `AssignTarget`.\n\nBy default, this method calls \
             [`AssignTarget::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_assign_target<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignTarget,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <AssignTarget as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `AssignTargetPat`.\n\nBy default, this method calls \
             [`AssignTargetPat::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_assign_target_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignTargetPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <AssignTargetPat as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `swc_atoms :: Atom`.\n\nBy default, this method calls \
             [`swc_atoms :: Atom::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_atoms::Atom,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <swc_atoms::Atom as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `AutoAccessor`.\n\nBy default, this method calls \
             [`AutoAccessor::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_auto_accessor<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AutoAccessor,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <AutoAccessor as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `AwaitExpr`.\n\nBy default, this method calls \
             [`AwaitExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_await_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AwaitExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <AwaitExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `BigInt`.\n\nBy default, this method calls \
             [`BigInt::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_big_int<'ast: 'r, 'r>(&mut self, node: &'ast BigInt, ast_path: &mut AstNodePath<'r>) {
        <BigInt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `BigIntValue`.\n\nBy default, this method calls \
             [`BigIntValue::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_big_int_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BigIntValue,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <BigIntValue as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `BinExpr`.\n\nBy default, this method calls \
             [`BinExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_bin_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BinExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <BinExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `BinaryOp`.\n\nBy default, this method calls \
             [`BinaryOp::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_binary_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BinaryOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <BinaryOp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `BindingIdent`.\n\nBy default, this method calls \
             [`BindingIdent::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_binding_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BindingIdent,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <BindingIdent as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `BlockStmt`.\n\nBy default, this method calls \
             [`BlockStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_block_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BlockStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <BlockStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `BlockStmtOrExpr`.\n\nBy default, this method calls \
             [`BlockStmtOrExpr::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_block_stmt_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BlockStmtOrExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <BlockStmtOrExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Bool`.\n\nBy default, this method calls \
             [`Bool::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_bool<'ast: 'r, 'r>(&mut self, node: &'ast Bool, ast_path: &mut AstNodePath<'r>) {
        <Bool as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `BreakStmt`.\n\nBy default, this method calls \
             [`BreakStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_break_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BreakStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <BreakStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `CallExpr`.\n\nBy default, this method calls \
             [`CallExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_call_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CallExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <CallExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Callee`.\n\nBy default, this method calls \
             [`Callee::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_callee<'ast: 'r, 'r>(&mut self, node: &'ast Callee, ast_path: &mut AstNodePath<'r>) {
        <Callee as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `CatchClause`.\n\nBy default, this method calls \
             [`CatchClause::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_catch_clause<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CatchClause,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <CatchClause as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Class`.\n\nBy default, this method calls \
             [`Class::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_class<'ast: 'r, 'r>(&mut self, node: &'ast Class, ast_path: &mut AstNodePath<'r>) {
        <Class as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ClassDecl`.\n\nBy default, this method calls \
             [`ClassDecl::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_class_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ClassDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ClassExpr`.\n\nBy default, this method calls \
             [`ClassExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_class_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ClassExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ClassMember`.\n\nBy default, this method calls \
             [`ClassMember::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_class_member<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassMember,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ClassMember as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < ClassMember >`.\n\nBy default, this method calls [`Vec < \
             ClassMember >::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_class_members<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ClassMember],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[ClassMember] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ClassMethod`.\n\nBy default, this method calls \
             [`ClassMethod::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_class_method<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassMethod,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ClassMethod as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ClassProp`.\n\nBy default, this method calls \
             [`ClassProp::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_class_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ClassProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ComputedPropName`.\n\nBy default, this method calls \
             [`ComputedPropName::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_computed_prop_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ComputedPropName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ComputedPropName as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `CondExpr`.\n\nBy default, this method calls \
             [`CondExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_cond_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CondExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <CondExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Constructor`.\n\nBy default, this method calls \
             [`Constructor::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_constructor<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Constructor,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Constructor as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ContinueStmt`.\n\nBy default, this method calls \
             [`ContinueStmt::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_continue_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ContinueStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ContinueStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `DebuggerStmt`.\n\nBy default, this method calls \
             [`DebuggerStmt::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_debugger_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DebuggerStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <DebuggerStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Decl`.\n\nBy default, this method calls \
             [`Decl::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_decl<'ast: 'r, 'r>(&mut self, node: &'ast Decl, ast_path: &mut AstNodePath<'r>) {
        <Decl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Decorator`.\n\nBy default, this method calls \
             [`Decorator::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_decorator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Decorator,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Decorator as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < Decorator >`.\n\nBy default, this method calls [`Vec < \
             Decorator >::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_decorators<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Decorator],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[Decorator] as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `DefaultDecl`.\n\nBy default, this method calls \
             [`DefaultDecl::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_default_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DefaultDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <DefaultDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `DoWhileStmt`.\n\nBy default, this method calls \
             [`DoWhileStmt::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_do_while_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DoWhileStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <DoWhileStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `EmptyStmt`.\n\nBy default, this method calls \
             [`EmptyStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_empty_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast EmptyStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <EmptyStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `EsVersion`.\n\nBy default, this method calls \
             [`EsVersion::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_es_version<'ast: 'r, 'r>(
        &mut self,
        node: &'ast EsVersion,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <EsVersion as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ExportAll`.\n\nBy default, this method calls \
             [`ExportAll::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_export_all<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportAll,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ExportAll as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ExportDecl`.\n\nBy default, this method calls \
             [`ExportDecl::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_export_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ExportDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ExportDefaultDecl`.\n\nBy default, this method calls \
             [`ExportDefaultDecl::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_export_default_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ExportDefaultDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportDefaultExpr`.\n\nBy default, this method calls \
             [`ExportDefaultExpr::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_export_default_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ExportDefaultExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ExportDefaultSpecifier::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_export_default_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ExportDefaultSpecifier as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportNamedSpecifier`.\n\nBy default, this method calls \
             [`ExportNamedSpecifier::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_export_named_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportNamedSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ExportNamedSpecifier as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportNamespaceSpecifier`.\n\nBy default, this method calls \
             [`ExportNamespaceSpecifier::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_export_namespace_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportNamespaceSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ExportNamespaceSpecifier as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportSpecifier`.\n\nBy default, this method calls \
             [`ExportSpecifier::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_export_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ExportSpecifier as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ExportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ExportSpecifier >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_export_specifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ExportSpecifier],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[ExportSpecifier] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Expr`.\n\nBy default, this method calls \
             [`Expr::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_expr<'ast: 'r, 'r>(&mut self, node: &'ast Expr, ast_path: &mut AstNodePath<'r>) {
        <Expr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ExprOrSpread`.\n\nBy default, this method calls \
             [`ExprOrSpread::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_expr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExprOrSpread,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ExprOrSpread as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < ExprOrSpread >`.\n\nBy default, this method calls [`Vec < \
             ExprOrSpread >::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ExprOrSpread],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[ExprOrSpread] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ExprStmt`.\n\nBy default, this method calls \
             [`ExprStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_expr_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExprStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ExprStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < Box < Expr > >`.\n\nBy default, this method calls [`Vec < \
             Box < Expr > >::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_exprs<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Box<Expr>],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[Box<Expr>] as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `FnDecl`.\n\nBy default, this method calls \
             [`FnDecl::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_fn_decl<'ast: 'r, 'r>(&mut self, node: &'ast FnDecl, ast_path: &mut AstNodePath<'r>) {
        <FnDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `FnExpr`.\n\nBy default, this method calls \
             [`FnExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_fn_expr<'ast: 'r, 'r>(&mut self, node: &'ast FnExpr, ast_path: &mut AstNodePath<'r>) {
        <FnExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ForHead`.\n\nBy default, this method calls \
             [`ForHead::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_for_head<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForHead,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ForHead as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ForInStmt`.\n\nBy default, this method calls \
             [`ForInStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_for_in_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForInStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ForInStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ForOfStmt`.\n\nBy default, this method calls \
             [`ForOfStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_for_of_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForOfStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ForOfStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ForStmt`.\n\nBy default, this method calls \
             [`ForStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_for_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ForStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Function`.\n\nBy default, this method calls \
             [`Function::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_function<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Function,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Function as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `GetterProp`.\n\nBy default, this method calls \
             [`GetterProp::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_getter_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast GetterProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <GetterProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Ident`.\n\nBy default, this method calls \
             [`Ident::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ident<'ast: 'r, 'r>(&mut self, node: &'ast Ident, ast_path: &mut AstNodePath<'r>) {
        <Ident as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `IdentName`.\n\nBy default, this method calls \
             [`IdentName::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ident_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IdentName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <IdentName as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `IfStmt`.\n\nBy default, this method calls \
             [`IfStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_if_stmt<'ast: 'r, 'r>(&mut self, node: &'ast IfStmt, ast_path: &mut AstNodePath<'r>) {
        <IfStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Import`.\n\nBy default, this method calls \
             [`Import::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_import<'ast: 'r, 'r>(&mut self, node: &'ast Import, ast_path: &mut AstNodePath<'r>) {
        <Import as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ImportDecl`.\n\nBy default, this method calls \
             [`ImportDecl::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_import_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ImportDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ImportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ImportDefaultSpecifier::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_import_default_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportDefaultSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ImportDefaultSpecifier as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportNamedSpecifier`.\n\nBy default, this method calls \
             [`ImportNamedSpecifier::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_import_named_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportNamedSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ImportNamedSpecifier as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportPhase`.\n\nBy default, this method calls \
             [`ImportPhase::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_import_phase<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportPhase,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ImportPhase as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ImportSpecifier`.\n\nBy default, this method calls \
             [`ImportSpecifier::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_import_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ImportSpecifier as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ImportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ImportSpecifier >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_import_specifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ImportSpecifier],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[ImportSpecifier] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportStarAsSpecifier`.\n\nBy default, this method calls \
             [`ImportStarAsSpecifier::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_import_star_as_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportStarAsSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ImportStarAsSpecifier as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportWith`.\n\nBy default, this method calls \
             [`ImportWith::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_import_with<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportWith,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ImportWith as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ImportWithItem`.\n\nBy default, this method calls \
             [`ImportWithItem::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_import_with_item<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportWithItem,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ImportWithItem as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ImportWithItem >`.\n\nBy default, this method calls [`Vec \
             < ImportWithItem >::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_import_with_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ImportWithItem],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[ImportWithItem] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Invalid`.\n\nBy default, this method calls \
             [`Invalid::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_invalid<'ast: 'r, 'r>(&mut self, node: &'ast Invalid, ast_path: &mut AstNodePath<'r>) {
        <Invalid as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `JSXAttr`.\n\nBy default, this method calls \
             [`JSXAttr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_jsx_attr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXAttr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `JSXAttrName`.\n\nBy default, this method calls \
             [`JSXAttrName::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_jsx_attr_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXAttrName as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `JSXAttrOrSpread`.\n\nBy default, this method calls \
             [`JSXAttrOrSpread::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_jsx_attr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrOrSpread,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXAttrOrSpread as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < JSXAttrOrSpread >`.\n\nBy default, this method calls \
             [`Vec < JSXAttrOrSpread >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_jsx_attr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [JSXAttrOrSpread],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[JSXAttrOrSpread] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXAttrValue`.\n\nBy default, this method calls \
             [`JSXAttrValue::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_jsx_attr_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrValue,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXAttrValue as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `JSXClosingElement`.\n\nBy default, this method calls \
             [`JSXClosingElement::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_jsx_closing_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXClosingElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXClosingElement as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXClosingFragment`.\n\nBy default, this method calls \
             [`JSXClosingFragment::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_jsx_closing_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXClosingFragment,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXClosingFragment as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXElement`.\n\nBy default, this method calls \
             [`JSXElement::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_jsx_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXElement as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `JSXElementChild`.\n\nBy default, this method calls \
             [`JSXElementChild::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_jsx_element_child<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElementChild,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXElementChild as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < JSXElementChild >`.\n\nBy default, this method calls \
             [`Vec < JSXElementChild >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_jsx_element_childs<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [JSXElementChild],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[JSXElementChild] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXElementName`.\n\nBy default, this method calls \
             [`JSXElementName::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_jsx_element_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElementName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXElementName as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXEmptyExpr`.\n\nBy default, this method calls \
             [`JSXEmptyExpr::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_jsx_empty_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXEmptyExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXEmptyExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `JSXExpr`.\n\nBy default, this method calls \
             [`JSXExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_jsx_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `JSXExprContainer`.\n\nBy default, this method calls \
             [`JSXExprContainer::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_jsx_expr_container<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXExprContainer,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXExprContainer as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXFragment`.\n\nBy default, this method calls \
             [`JSXFragment::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_jsx_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXFragment,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXFragment as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `JSXMemberExpr`.\n\nBy default, this method calls \
             [`JSXMemberExpr::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_jsx_member_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXMemberExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXMemberExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXNamespacedName`.\n\nBy default, this method calls \
             [`JSXNamespacedName::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_jsx_namespaced_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXNamespacedName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXNamespacedName as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXObject`.\n\nBy default, this method calls \
             [`JSXObject::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_jsx_object<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXObject,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXObject as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `JSXOpeningElement`.\n\nBy default, this method calls \
             [`JSXOpeningElement::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_jsx_opening_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXOpeningElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXOpeningElement as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXOpeningFragment`.\n\nBy default, this method calls \
             [`JSXOpeningFragment::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_jsx_opening_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXOpeningFragment,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXOpeningFragment as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXSpreadChild`.\n\nBy default, this method calls \
             [`JSXSpreadChild::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_jsx_spread_child<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXSpreadChild,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXSpreadChild as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXText`.\n\nBy default, this method calls \
             [`JSXText::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_jsx_text<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXText,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <JSXText as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Key`.\n\nBy default, this method calls \
             [`Key::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_key<'ast: 'r, 'r>(&mut self, node: &'ast Key, ast_path: &mut AstNodePath<'r>) {
        <Key as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `KeyValuePatProp`.\n\nBy default, this method calls \
             [`KeyValuePatProp::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_key_value_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast KeyValuePatProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <KeyValuePatProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `KeyValueProp`.\n\nBy default, this method calls \
             [`KeyValueProp::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_key_value_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast KeyValueProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <KeyValueProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `LabeledStmt`.\n\nBy default, this method calls \
             [`LabeledStmt::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_labeled_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast LabeledStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <LabeledStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Lit`.\n\nBy default, this method calls \
             [`Lit::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_lit<'ast: 'r, 'r>(&mut self, node: &'ast Lit, ast_path: &mut AstNodePath<'r>) {
        <Lit as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `MemberExpr`.\n\nBy default, this method calls \
             [`MemberExpr::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_member_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MemberExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <MemberExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `MemberProp`.\n\nBy default, this method calls \
             [`MemberProp::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_member_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MemberProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <MemberProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `MetaPropExpr`.\n\nBy default, this method calls \
             [`MetaPropExpr::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_meta_prop_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MetaPropExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <MetaPropExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `MetaPropKind`.\n\nBy default, this method calls \
             [`MetaPropKind::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_meta_prop_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MetaPropKind,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <MetaPropKind as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `MethodKind`.\n\nBy default, this method calls \
             [`MethodKind::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_method_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MethodKind,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <MethodKind as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `MethodProp`.\n\nBy default, this method calls \
             [`MethodProp::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_method_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MethodProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <MethodProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Module`.\n\nBy default, this method calls \
             [`Module::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_module<'ast: 'r, 'r>(&mut self, node: &'ast Module, ast_path: &mut AstNodePath<'r>) {
        <Module as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ModuleDecl`.\n\nBy default, this method calls \
             [`ModuleDecl::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_module_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ModuleDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ModuleExportName`.\n\nBy default, this method calls \
             [`ModuleExportName::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_module_export_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleExportName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ModuleExportName as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ModuleItem`.\n\nBy default, this method calls \
             [`ModuleItem::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_module_item<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleItem,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ModuleItem as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < ModuleItem >`.\n\nBy default, this method calls [`Vec < \
             ModuleItem >::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_module_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ModuleItem],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[ModuleItem] as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `NamedExport`.\n\nBy default, this method calls \
             [`NamedExport::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_named_export<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NamedExport,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <NamedExport as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `NewExpr`.\n\nBy default, this method calls \
             [`NewExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_new_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NewExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <NewExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Null`.\n\nBy default, this method calls \
             [`Null::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_null<'ast: 'r, 'r>(&mut self, node: &'ast Null, ast_path: &mut AstNodePath<'r>) {
        <Null as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Number`.\n\nBy default, this method calls \
             [`Number::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_number<'ast: 'r, 'r>(&mut self, node: &'ast Number, ast_path: &mut AstNodePath<'r>) {
        <Number as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ObjectLit`.\n\nBy default, this method calls \
             [`ObjectLit::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_object_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectLit,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ObjectLit as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ObjectPat`.\n\nBy default, this method calls \
             [`ObjectPat::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_object_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ObjectPat as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ObjectPatProp`.\n\nBy default, this method calls \
             [`ObjectPatProp::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_object_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectPatProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ObjectPatProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ObjectPatProp >`.\n\nBy default, this method calls [`Vec \
             < ObjectPatProp >::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_object_pat_props<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ObjectPatProp],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[ObjectPatProp] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Accessibility >`.\n\nBy default, this method calls \
             [`Option < Accessibility >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_opt_accessibility<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Accessibility>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<Accessibility> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < swc_atoms :: Atom >`.\n\nBy default, this method calls \
             [`Option < swc_atoms :: Atom >::visit_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_opt_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_atoms::Atom>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<swc_atoms::Atom> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < BlockStmt >`.\n\nBy default, this method calls \
             [`Option < BlockStmt >::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_opt_block_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<BlockStmt>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<BlockStmt> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `OptCall`.\n\nBy default, this method calls \
             [`OptCall::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_opt_call<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptCall,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <OptCall as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Option < CatchClause >`.\n\nBy default, this method calls \
             [`Option < CatchClause >::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_opt_catch_clause<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<CatchClause>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<CatchClause> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `OptChainBase`.\n\nBy default, this method calls \
             [`OptChainBase::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_opt_chain_base<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptChainBase,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <OptChainBase as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `OptChainExpr`.\n\nBy default, this method calls \
             [`OptChainExpr::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_opt_chain_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptChainExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <OptChainExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Option < Box < Expr > >`.\n\nBy default, this method calls \
             [`Option < Box < Expr > >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_opt_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Expr>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<Box<Expr>> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < ExprOrSpread >`.\n\nBy default, this method calls \
             [`Option < ExprOrSpread >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_opt_expr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<ExprOrSpread>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<ExprOrSpread> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Vec < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Option < Vec < ExprOrSpread > >::visit_children_with_ast_path`]. If you want \
             to recurse, you need to call it manually."]
    fn visit_opt_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Vec<ExprOrSpread>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<Vec<ExprOrSpread>> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Ident >`.\n\nBy default, this method calls [`Option < \
             Ident >::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_opt_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Ident>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<Ident> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < JSXAttrValue >`.\n\nBy default, this method calls \
             [`Option < JSXAttrValue >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_opt_jsx_attr_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<JSXAttrValue>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<JSXAttrValue> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < JSXClosingElement >`.\n\nBy default, this method calls \
             [`Option < JSXClosingElement >::visit_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_opt_jsx_closing_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<JSXClosingElement>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<JSXClosingElement> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < ModuleExportName >`.\n\nBy default, this method calls \
             [`Option < ModuleExportName >::visit_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_opt_module_export_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<ModuleExportName>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<ModuleExportName> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Vec < ModuleItem > >`.\n\nBy default, this method \
             calls [`Option < Vec < ModuleItem > >::visit_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_opt_module_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Vec<ModuleItem>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<Vec<ModuleItem>> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < ObjectLit > >`.\n\nBy default, this method calls \
             [`Option < Box < ObjectLit > >::visit_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_opt_object_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<ObjectLit>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<Box<ObjectLit>> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Pat >`.\n\nBy default, this method calls [`Option < \
             Pat >::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_opt_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Pat>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<Pat> as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Option < swc_common :: Span >`.\n\nBy default, this method \
             calls [`Option < swc_common :: Span >::visit_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_opt_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_common::Span>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<swc_common::Span> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < Stmt > >`.\n\nBy default, this method calls \
             [`Option < Box < Stmt > >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_opt_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Stmt>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<Box<Stmt>> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < Str > >`.\n\nBy default, this method calls \
             [`Option < Box < Str > >::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_opt_str<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Str>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<Box<Str>> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < TruePlusMinus >`.\n\nBy default, this method calls \
             [`Option < TruePlusMinus >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_opt_true_plus_minus<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<TruePlusMinus>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<TruePlusMinus> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < TsEntityName >`.\n\nBy default, this method calls \
             [`Option < TsEntityName >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_opt_ts_entity_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<TsEntityName>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<TsEntityName> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < TsNamespaceBody >`.\n\nBy default, this method calls \
             [`Option < TsNamespaceBody >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_opt_ts_namespace_body<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<TsNamespaceBody>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<TsNamespaceBody> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < TsType > >`.\n\nBy default, this method calls \
             [`Option < Box < TsType > >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_opt_ts_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<TsType>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<Box<TsType>> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < TsTypeAnn > >`.\n\nBy default, this method calls \
             [`Option < Box < TsTypeAnn > >::visit_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_opt_ts_type_ann<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<TsTypeAnn>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<Box<TsTypeAnn>> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < TsTypeParamDecl > >`.\n\nBy default, this method \
             calls [`Option < Box < TsTypeParamDecl > >::visit_children_with_ast_path`]. If you \
             want to recurse, you need to call it manually."]
    fn visit_opt_ts_type_param_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<TsTypeParamDecl>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<Box<TsTypeParamDecl>> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < TsTypeParamInstantiation > >`.\n\nBy default, \
             this method calls [`Option < Box < TsTypeParamInstantiation > \
             >::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_opt_ts_type_param_instantiation<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<TsTypeParamInstantiation>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        < Option < Box < TsTypeParamInstantiation > > as VisitWithAstPath < Self > > :: visit_children_with_ast_path (node , self , ast_path)
    }
    #[doc = "Visit a node of type `Option < VarDeclOrExpr >`.\n\nBy default, this method calls \
             [`Option < VarDeclOrExpr >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_opt_var_decl_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<VarDeclOrExpr>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <Option<VarDeclOrExpr> as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Option < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Vec < Option < ExprOrSpread > >::visit_children_with_ast_path`]. If you want \
             to recurse, you need to call it manually."]
    fn visit_opt_vec_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Option<ExprOrSpread>],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[Option<ExprOrSpread>] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Option < Pat > >`.\n\nBy default, this method calls [`Vec \
             < Option < Pat > >::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_opt_vec_pats<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Option<Pat>],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[Option<Pat>] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Param`.\n\nBy default, this method calls \
             [`Param::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_param<'ast: 'r, 'r>(&mut self, node: &'ast Param, ast_path: &mut AstNodePath<'r>) {
        <Param as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ParamOrTsParamProp`.\n\nBy default, this method calls \
             [`ParamOrTsParamProp::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_param_or_ts_param_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ParamOrTsParamProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ParamOrTsParamProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ParamOrTsParamProp >`.\n\nBy default, this method calls \
             [`Vec < ParamOrTsParamProp >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_param_or_ts_param_props<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ParamOrTsParamProp],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[ParamOrTsParamProp] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Param >`.\n\nBy default, this method calls [`Vec < Param \
             >::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_params<'ast: 'r, 'r>(&mut self, node: &'ast [Param], ast_path: &mut AstNodePath<'r>) {
        <[Param] as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ParenExpr`.\n\nBy default, this method calls \
             [`ParenExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_paren_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ParenExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ParenExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Pat`.\n\nBy default, this method calls \
             [`Pat::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_pat<'ast: 'r, 'r>(&mut self, node: &'ast Pat, ast_path: &mut AstNodePath<'r>) {
        <Pat as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < Pat >`.\n\nBy default, this method calls [`Vec < Pat \
             >::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_pats<'ast: 'r, 'r>(&mut self, node: &'ast [Pat], ast_path: &mut AstNodePath<'r>) {
        <[Pat] as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `PrivateMethod`.\n\nBy default, this method calls \
             [`PrivateMethod::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_private_method<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateMethod,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <PrivateMethod as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `PrivateName`.\n\nBy default, this method calls \
             [`PrivateName::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_private_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <PrivateName as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `PrivateProp`.\n\nBy default, this method calls \
             [`PrivateProp::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_private_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <PrivateProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Program`.\n\nBy default, this method calls \
             [`Program::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_program<'ast: 'r, 'r>(&mut self, node: &'ast Program, ast_path: &mut AstNodePath<'r>) {
        <Program as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Prop`.\n\nBy default, this method calls \
             [`Prop::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_prop<'ast: 'r, 'r>(&mut self, node: &'ast Prop, ast_path: &mut AstNodePath<'r>) {
        <Prop as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `PropName`.\n\nBy default, this method calls \
             [`PropName::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_prop_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PropName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <PropName as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `PropOrSpread`.\n\nBy default, this method calls \
             [`PropOrSpread::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_prop_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PropOrSpread,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <PropOrSpread as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < PropOrSpread >`.\n\nBy default, this method calls [`Vec < \
             PropOrSpread >::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_prop_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [PropOrSpread],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[PropOrSpread] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Regex`.\n\nBy default, this method calls \
             [`Regex::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_regex<'ast: 'r, 'r>(&mut self, node: &'ast Regex, ast_path: &mut AstNodePath<'r>) {
        <Regex as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ReservedUnused`.\n\nBy default, this method calls \
             [`ReservedUnused::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_reserved_unused<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ReservedUnused,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ReservedUnused as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `RestPat`.\n\nBy default, this method calls \
             [`RestPat::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_rest_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast RestPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <RestPat as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ReturnStmt`.\n\nBy default, this method calls \
             [`ReturnStmt::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_return_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ReturnStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ReturnStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Script`.\n\nBy default, this method calls \
             [`Script::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_script<'ast: 'r, 'r>(&mut self, node: &'ast Script, ast_path: &mut AstNodePath<'r>) {
        <Script as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `SeqExpr`.\n\nBy default, this method calls \
             [`SeqExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_seq_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SeqExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <SeqExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `SetterProp`.\n\nBy default, this method calls \
             [`SetterProp::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_setter_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SetterProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <SetterProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `SimpleAssignTarget`.\n\nBy default, this method calls \
             [`SimpleAssignTarget::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_simple_assign_target<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SimpleAssignTarget,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <SimpleAssignTarget as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `swc_common :: Span`.\n\nBy default, this method calls \
             [`swc_common :: Span::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::Span,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <swc_common::Span as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `SpreadElement`.\n\nBy default, this method calls \
             [`SpreadElement::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_spread_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SpreadElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <SpreadElement as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `StaticBlock`.\n\nBy default, this method calls \
             [`StaticBlock::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_static_block<'ast: 'r, 'r>(
        &mut self,
        node: &'ast StaticBlock,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <StaticBlock as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Stmt`.\n\nBy default, this method calls \
             [`Stmt::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_stmt<'ast: 'r, 'r>(&mut self, node: &'ast Stmt, ast_path: &mut AstNodePath<'r>) {
        <Stmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < Stmt >`.\n\nBy default, this method calls [`Vec < Stmt \
             >::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_stmts<'ast: 'r, 'r>(&mut self, node: &'ast [Stmt], ast_path: &mut AstNodePath<'r>) {
        <[Stmt] as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Str`.\n\nBy default, this method calls \
             [`Str::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_str<'ast: 'r, 'r>(&mut self, node: &'ast Str, ast_path: &mut AstNodePath<'r>) {
        <Str as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Super`.\n\nBy default, this method calls \
             [`Super::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_super<'ast: 'r, 'r>(&mut self, node: &'ast Super, ast_path: &mut AstNodePath<'r>) {
        <Super as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `SuperProp`.\n\nBy default, this method calls \
             [`SuperProp::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_super_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SuperProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <SuperProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `SuperPropExpr`.\n\nBy default, this method calls \
             [`SuperPropExpr::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_super_prop_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SuperPropExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <SuperPropExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `SwitchCase`.\n\nBy default, this method calls \
             [`SwitchCase::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_switch_case<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SwitchCase,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <SwitchCase as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < SwitchCase >`.\n\nBy default, this method calls [`Vec < \
             SwitchCase >::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_switch_cases<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [SwitchCase],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[SwitchCase] as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `SwitchStmt`.\n\nBy default, this method calls \
             [`SwitchStmt::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_switch_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SwitchStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <SwitchStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `swc_common :: SyntaxContext`.\n\nBy default, this method calls \
             [`swc_common :: SyntaxContext::visit_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_syntax_context<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::SyntaxContext,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <swc_common::SyntaxContext as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TaggedTpl`.\n\nBy default, this method calls \
             [`TaggedTpl::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_tagged_tpl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TaggedTpl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TaggedTpl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ThisExpr`.\n\nBy default, this method calls \
             [`ThisExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_this_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ThisExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ThisExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ThrowStmt`.\n\nBy default, this method calls \
             [`ThrowStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_throw_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ThrowStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <ThrowStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Tpl`.\n\nBy default, this method calls \
             [`Tpl::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_tpl<'ast: 'r, 'r>(&mut self, node: &'ast Tpl, ast_path: &mut AstNodePath<'r>) {
        <Tpl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TplElement`.\n\nBy default, this method calls \
             [`TplElement::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_tpl_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TplElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TplElement as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < TplElement >`.\n\nBy default, this method calls [`Vec < \
             TplElement >::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_tpl_elements<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TplElement],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[TplElement] as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TruePlusMinus`.\n\nBy default, this method calls \
             [`TruePlusMinus::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_true_plus_minus<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TruePlusMinus,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TruePlusMinus as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TryStmt`.\n\nBy default, this method calls \
             [`TryStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_try_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TryStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TryStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsArrayType`.\n\nBy default, this method calls \
             [`TsArrayType::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_array_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsArrayType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsArrayType as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsAsExpr`.\n\nBy default, this method calls \
             [`TsAsExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_as_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsAsExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsAsExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsCallSignatureDecl`.\n\nBy default, this method calls \
             [`TsCallSignatureDecl::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_ts_call_signature_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsCallSignatureDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsCallSignatureDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsConditionalType`.\n\nBy default, this method calls \
             [`TsConditionalType::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_conditional_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsConditionalType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsConditionalType as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsConstAssertion`.\n\nBy default, this method calls \
             [`TsConstAssertion::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_const_assertion<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsConstAssertion,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsConstAssertion as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsConstructSignatureDecl`.\n\nBy default, this method calls \
             [`TsConstructSignatureDecl::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_ts_construct_signature_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsConstructSignatureDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsConstructSignatureDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsConstructorType`.\n\nBy default, this method calls \
             [`TsConstructorType::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_constructor_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsConstructorType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsConstructorType as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsEntityName`.\n\nBy default, this method calls \
             [`TsEntityName::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_entity_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsEntityName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsEntityName as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsEnumDecl`.\n\nBy default, this method calls \
             [`TsEnumDecl::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_enum_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsEnumDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsEnumDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsEnumMember`.\n\nBy default, this method calls \
             [`TsEnumMember::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_enum_member<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsEnumMember,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsEnumMember as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsEnumMemberId`.\n\nBy default, this method calls \
             [`TsEnumMemberId::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_enum_member_id<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsEnumMemberId,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsEnumMemberId as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < TsEnumMember >`.\n\nBy default, this method calls [`Vec < \
             TsEnumMember >::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_enum_members<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsEnumMember],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[TsEnumMember] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsExportAssignment`.\n\nBy default, this method calls \
             [`TsExportAssignment::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_ts_export_assignment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsExportAssignment,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsExportAssignment as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsExprWithTypeArgs`.\n\nBy default, this method calls \
             [`TsExprWithTypeArgs::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_ts_expr_with_type_args<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsExprWithTypeArgs,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsExprWithTypeArgs as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < TsExprWithTypeArgs >`.\n\nBy default, this method calls \
             [`Vec < TsExprWithTypeArgs >::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_ts_expr_with_type_argss<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsExprWithTypeArgs],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[TsExprWithTypeArgs] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsExternalModuleRef`.\n\nBy default, this method calls \
             [`TsExternalModuleRef::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_ts_external_module_ref<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsExternalModuleRef,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsExternalModuleRef as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsFnOrConstructorType`.\n\nBy default, this method calls \
             [`TsFnOrConstructorType::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_ts_fn_or_constructor_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsFnOrConstructorType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsFnOrConstructorType as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsFnParam`.\n\nBy default, this method calls \
             [`TsFnParam::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_fn_param<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsFnParam,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsFnParam as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < TsFnParam >`.\n\nBy default, this method calls [`Vec < \
             TsFnParam >::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_fn_params<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsFnParam],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[TsFnParam] as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsFnType`.\n\nBy default, this method calls \
             [`TsFnType::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_fn_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsFnType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsFnType as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsGetterSignature`.\n\nBy default, this method calls \
             [`TsGetterSignature::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_getter_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsGetterSignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsGetterSignature as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsImportEqualsDecl`.\n\nBy default, this method calls \
             [`TsImportEqualsDecl::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_ts_import_equals_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsImportEqualsDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsImportEqualsDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsImportType`.\n\nBy default, this method calls \
             [`TsImportType::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_import_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsImportType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsImportType as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsIndexSignature`.\n\nBy default, this method calls \
             [`TsIndexSignature::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_index_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsIndexSignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsIndexSignature as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsIndexedAccessType`.\n\nBy default, this method calls \
             [`TsIndexedAccessType::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_ts_indexed_access_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsIndexedAccessType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsIndexedAccessType as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsInferType`.\n\nBy default, this method calls \
             [`TsInferType::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_infer_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsInferType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsInferType as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsInstantiation`.\n\nBy default, this method calls \
             [`TsInstantiation::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_instantiation<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsInstantiation,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsInstantiation as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsInterfaceBody`.\n\nBy default, this method calls \
             [`TsInterfaceBody::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_interface_body<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsInterfaceBody,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsInterfaceBody as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsInterfaceDecl`.\n\nBy default, this method calls \
             [`TsInterfaceDecl::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_interface_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsInterfaceDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsInterfaceDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsIntersectionType`.\n\nBy default, this method calls \
             [`TsIntersectionType::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_ts_intersection_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsIntersectionType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsIntersectionType as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsKeywordType`.\n\nBy default, this method calls \
             [`TsKeywordType::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_keyword_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsKeywordType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsKeywordType as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsKeywordTypeKind`.\n\nBy default, this method calls \
             [`TsKeywordTypeKind::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_keyword_type_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsKeywordTypeKind,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsKeywordTypeKind as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsLit`.\n\nBy default, this method calls \
             [`TsLit::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_lit<'ast: 'r, 'r>(&mut self, node: &'ast TsLit, ast_path: &mut AstNodePath<'r>) {
        <TsLit as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsLitType`.\n\nBy default, this method calls \
             [`TsLitType::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_lit_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsLitType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsLitType as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsMappedType`.\n\nBy default, this method calls \
             [`TsMappedType::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_mapped_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsMappedType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsMappedType as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsMethodSignature`.\n\nBy default, this method calls \
             [`TsMethodSignature::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_method_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsMethodSignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsMethodSignature as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsModuleBlock`.\n\nBy default, this method calls \
             [`TsModuleBlock::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_module_block<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsModuleBlock,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsModuleBlock as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsModuleDecl`.\n\nBy default, this method calls \
             [`TsModuleDecl::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_module_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsModuleDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsModuleDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsModuleName`.\n\nBy default, this method calls \
             [`TsModuleName::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_module_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsModuleName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsModuleName as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsModuleRef`.\n\nBy default, this method calls \
             [`TsModuleRef::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_module_ref<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsModuleRef,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsModuleRef as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsNamespaceBody`.\n\nBy default, this method calls \
             [`TsNamespaceBody::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_namespace_body<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsNamespaceBody,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsNamespaceBody as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsNamespaceDecl`.\n\nBy default, this method calls \
             [`TsNamespaceDecl::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_namespace_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsNamespaceDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsNamespaceDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsNamespaceExportDecl`.\n\nBy default, this method calls \
             [`TsNamespaceExportDecl::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_ts_namespace_export_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsNamespaceExportDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsNamespaceExportDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsNonNullExpr`.\n\nBy default, this method calls \
             [`TsNonNullExpr::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_non_null_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsNonNullExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsNonNullExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsOptionalType`.\n\nBy default, this method calls \
             [`TsOptionalType::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_optional_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsOptionalType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsOptionalType as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsParamProp`.\n\nBy default, this method calls \
             [`TsParamProp::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_param_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsParamProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsParamProp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsParamPropParam`.\n\nBy default, this method calls \
             [`TsParamPropParam::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_param_prop_param<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsParamPropParam,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsParamPropParam as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsParenthesizedType`.\n\nBy default, this method calls \
             [`TsParenthesizedType::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_ts_parenthesized_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsParenthesizedType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsParenthesizedType as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsPropertySignature`.\n\nBy default, this method calls \
             [`TsPropertySignature::visit_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_ts_property_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsPropertySignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsPropertySignature as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsQualifiedName`.\n\nBy default, this method calls \
             [`TsQualifiedName::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_qualified_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsQualifiedName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsQualifiedName as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsRestType`.\n\nBy default, this method calls \
             [`TsRestType::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_rest_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsRestType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsRestType as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsSatisfiesExpr`.\n\nBy default, this method calls \
             [`TsSatisfiesExpr::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_satisfies_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsSatisfiesExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsSatisfiesExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsSetterSignature`.\n\nBy default, this method calls \
             [`TsSetterSignature::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_setter_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsSetterSignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsSetterSignature as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsThisType`.\n\nBy default, this method calls \
             [`TsThisType::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_this_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsThisType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsThisType as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsThisTypeOrIdent`.\n\nBy default, this method calls \
             [`TsThisTypeOrIdent::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_this_type_or_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsThisTypeOrIdent,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsThisTypeOrIdent as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTplLitType`.\n\nBy default, this method calls \
             [`TsTplLitType::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_tpl_lit_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTplLitType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsTplLitType as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsTupleElement`.\n\nBy default, this method calls \
             [`TsTupleElement::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_tuple_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTupleElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsTupleElement as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < TsTupleElement >`.\n\nBy default, this method calls [`Vec \
             < TsTupleElement >::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_tuple_elements<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsTupleElement],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[TsTupleElement] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTupleType`.\n\nBy default, this method calls \
             [`TsTupleType::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_tuple_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTupleType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsTupleType as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsType`.\n\nBy default, this method calls \
             [`TsType::visit_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_ts_type<'ast: 'r, 'r>(&mut self, node: &'ast TsType, ast_path: &mut AstNodePath<'r>) {
        <TsType as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsTypeAliasDecl`.\n\nBy default, this method calls \
             [`TsTypeAliasDecl::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_type_alias_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeAliasDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsTypeAliasDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeAnn`.\n\nBy default, this method calls \
             [`TsTypeAnn::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_type_ann<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeAnn,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsTypeAnn as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsTypeAssertion`.\n\nBy default, this method calls \
             [`TsTypeAssertion::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_type_assertion<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeAssertion,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsTypeAssertion as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeElement`.\n\nBy default, this method calls \
             [`TsTypeElement::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_type_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsTypeElement as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < TsTypeElement >`.\n\nBy default, this method calls [`Vec \
             < TsTypeElement >::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_type_elements<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsTypeElement],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[TsTypeElement] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeLit`.\n\nBy default, this method calls \
             [`TsTypeLit::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_type_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeLit,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsTypeLit as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsTypeOperator`.\n\nBy default, this method calls \
             [`TsTypeOperator::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_type_operator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeOperator,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsTypeOperator as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeOperatorOp`.\n\nBy default, this method calls \
             [`TsTypeOperatorOp::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_type_operator_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeOperatorOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsTypeOperatorOp as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeParam`.\n\nBy default, this method calls \
             [`TsTypeParam::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_type_param<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeParam,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsTypeParam as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsTypeParamDecl`.\n\nBy default, this method calls \
             [`TsTypeParamDecl::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_type_param_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeParamDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsTypeParamDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeParamInstantiation`.\n\nBy default, this method calls \
             [`TsTypeParamInstantiation::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_ts_type_param_instantiation<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeParamInstantiation,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsTypeParamInstantiation as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < TsTypeParam >`.\n\nBy default, this method calls [`Vec < \
             TsTypeParam >::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_type_params<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsTypeParam],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[TsTypeParam] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypePredicate`.\n\nBy default, this method calls \
             [`TsTypePredicate::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_type_predicate<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypePredicate,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsTypePredicate as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeQuery`.\n\nBy default, this method calls \
             [`TsTypeQuery::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_type_query<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeQuery,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsTypeQuery as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsTypeQueryExpr`.\n\nBy default, this method calls \
             [`TsTypeQueryExpr::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_type_query_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeQueryExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsTypeQueryExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeRef`.\n\nBy default, this method calls \
             [`TsTypeRef::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_ts_type_ref<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeRef,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsTypeRef as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < Box < TsType > >`.\n\nBy default, this method calls [`Vec \
             < Box < TsType > >::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_ts_types<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Box<TsType>],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[Box<TsType>] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsUnionOrIntersectionType`.\n\nBy default, this method calls \
             [`TsUnionOrIntersectionType::visit_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_ts_union_or_intersection_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsUnionOrIntersectionType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsUnionOrIntersectionType as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsUnionType`.\n\nBy default, this method calls \
             [`TsUnionType::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_ts_union_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsUnionType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <TsUnionType as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `UnaryExpr`.\n\nBy default, this method calls \
             [`UnaryExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_unary_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnaryExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <UnaryExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `UnaryOp`.\n\nBy default, this method calls \
             [`UnaryOp::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_unary_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnaryOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <UnaryOp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `UpdateExpr`.\n\nBy default, this method calls \
             [`UpdateExpr::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_update_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UpdateExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <UpdateExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `UpdateOp`.\n\nBy default, this method calls \
             [`UpdateOp::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_update_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UpdateOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <UpdateOp as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `UsingDecl`.\n\nBy default, this method calls \
             [`UsingDecl::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_using_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UsingDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <UsingDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `VarDecl`.\n\nBy default, this method calls \
             [`VarDecl::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_var_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <VarDecl as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `VarDeclKind`.\n\nBy default, this method calls \
             [`VarDeclKind::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_var_decl_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclKind,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <VarDeclKind as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `VarDeclOrExpr`.\n\nBy default, this method calls \
             [`VarDeclOrExpr::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_var_decl_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclOrExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <VarDeclOrExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `VarDeclarator`.\n\nBy default, this method calls \
             [`VarDeclarator::visit_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_var_declarator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclarator,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <VarDeclarator as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < VarDeclarator >`.\n\nBy default, this method calls [`Vec \
             < VarDeclarator >::visit_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_var_declarators<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [VarDeclarator],
        ast_path: &mut AstNodePath<'r>,
    ) {
        <[VarDeclarator] as VisitWithAstPath<Self>>::visit_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `WhileStmt`.\n\nBy default, this method calls \
             [`WhileStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_while_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast WhileStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <WhileStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `WithStmt`.\n\nBy default, this method calls \
             [`WithStmt::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_with_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast WithStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <WithStmt as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `YieldExpr`.\n\nBy default, this method calls \
             [`YieldExpr::visit_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_yield_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast YieldExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <YieldExpr as VisitWithAstPath<Self>>::visit_children_with_ast_path(node, self, ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> VisitAstPath for &mut V
where
    V: ?Sized + VisitAstPath,
{
    fn visit_accessibility<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Accessibility,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_accessibility(&mut **self, node, ast_path)
    }

    fn visit_array_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrayLit,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_array_lit(&mut **self, node, ast_path)
    }

    fn visit_array_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrayPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_array_pat(&mut **self, node, ast_path)
    }

    fn visit_arrow_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrowExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_arrow_expr(&mut **self, node, ast_path)
    }

    fn visit_assign_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_assign_expr(&mut **self, node, ast_path)
    }

    fn visit_assign_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_assign_op(&mut **self, node, ast_path)
    }

    fn visit_assign_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_assign_pat(&mut **self, node, ast_path)
    }

    fn visit_assign_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignPatProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_assign_pat_prop(&mut **self, node, ast_path)
    }

    fn visit_assign_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_assign_prop(&mut **self, node, ast_path)
    }

    fn visit_assign_target<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignTarget,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_assign_target(&mut **self, node, ast_path)
    }

    fn visit_assign_target_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignTargetPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_assign_target_pat(&mut **self, node, ast_path)
    }

    fn visit_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_atoms::Atom,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_atom(&mut **self, node, ast_path)
    }

    fn visit_auto_accessor<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AutoAccessor,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_auto_accessor(&mut **self, node, ast_path)
    }

    fn visit_await_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AwaitExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_await_expr(&mut **self, node, ast_path)
    }

    fn visit_big_int<'ast: 'r, 'r>(&mut self, node: &'ast BigInt, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_big_int(&mut **self, node, ast_path)
    }

    fn visit_big_int_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BigIntValue,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_big_int_value(&mut **self, node, ast_path)
    }

    fn visit_bin_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BinExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_bin_expr(&mut **self, node, ast_path)
    }

    fn visit_binary_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BinaryOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_binary_op(&mut **self, node, ast_path)
    }

    fn visit_binding_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BindingIdent,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_binding_ident(&mut **self, node, ast_path)
    }

    fn visit_block_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BlockStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_block_stmt(&mut **self, node, ast_path)
    }

    fn visit_block_stmt_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BlockStmtOrExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_block_stmt_or_expr(&mut **self, node, ast_path)
    }

    fn visit_bool<'ast: 'r, 'r>(&mut self, node: &'ast Bool, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_bool(&mut **self, node, ast_path)
    }

    fn visit_break_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BreakStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_break_stmt(&mut **self, node, ast_path)
    }

    fn visit_call_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CallExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_call_expr(&mut **self, node, ast_path)
    }

    fn visit_callee<'ast: 'r, 'r>(&mut self, node: &'ast Callee, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_callee(&mut **self, node, ast_path)
    }

    fn visit_catch_clause<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CatchClause,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_catch_clause(&mut **self, node, ast_path)
    }

    fn visit_class<'ast: 'r, 'r>(&mut self, node: &'ast Class, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_class(&mut **self, node, ast_path)
    }

    fn visit_class_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_class_decl(&mut **self, node, ast_path)
    }

    fn visit_class_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_class_expr(&mut **self, node, ast_path)
    }

    fn visit_class_member<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassMember,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_class_member(&mut **self, node, ast_path)
    }

    fn visit_class_members<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ClassMember],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_class_members(&mut **self, node, ast_path)
    }

    fn visit_class_method<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassMethod,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_class_method(&mut **self, node, ast_path)
    }

    fn visit_class_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_class_prop(&mut **self, node, ast_path)
    }

    fn visit_computed_prop_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ComputedPropName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_computed_prop_name(&mut **self, node, ast_path)
    }

    fn visit_cond_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CondExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_cond_expr(&mut **self, node, ast_path)
    }

    fn visit_constructor<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Constructor,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_constructor(&mut **self, node, ast_path)
    }

    fn visit_continue_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ContinueStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_continue_stmt(&mut **self, node, ast_path)
    }

    fn visit_debugger_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DebuggerStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_debugger_stmt(&mut **self, node, ast_path)
    }

    fn visit_decl<'ast: 'r, 'r>(&mut self, node: &'ast Decl, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_decl(&mut **self, node, ast_path)
    }

    fn visit_decorator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Decorator,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_decorator(&mut **self, node, ast_path)
    }

    fn visit_decorators<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Decorator],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_decorators(&mut **self, node, ast_path)
    }

    fn visit_default_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DefaultDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_default_decl(&mut **self, node, ast_path)
    }

    fn visit_do_while_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DoWhileStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_do_while_stmt(&mut **self, node, ast_path)
    }

    fn visit_empty_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast EmptyStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_empty_stmt(&mut **self, node, ast_path)
    }

    fn visit_es_version<'ast: 'r, 'r>(
        &mut self,
        node: &'ast EsVersion,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_es_version(&mut **self, node, ast_path)
    }

    fn visit_export_all<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportAll,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_export_all(&mut **self, node, ast_path)
    }

    fn visit_export_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_export_decl(&mut **self, node, ast_path)
    }

    fn visit_export_default_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_export_default_decl(&mut **self, node, ast_path)
    }

    fn visit_export_default_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_export_default_expr(&mut **self, node, ast_path)
    }

    fn visit_export_default_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_export_default_specifier(&mut **self, node, ast_path)
    }

    fn visit_export_named_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportNamedSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_export_named_specifier(&mut **self, node, ast_path)
    }

    fn visit_export_namespace_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportNamespaceSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_export_namespace_specifier(&mut **self, node, ast_path)
    }

    fn visit_export_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_export_specifier(&mut **self, node, ast_path)
    }

    fn visit_export_specifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ExportSpecifier],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_export_specifiers(&mut **self, node, ast_path)
    }

    fn visit_expr<'ast: 'r, 'r>(&mut self, node: &'ast Expr, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_expr(&mut **self, node, ast_path)
    }

    fn visit_expr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExprOrSpread,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_expr_or_spread(&mut **self, node, ast_path)
    }

    fn visit_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ExprOrSpread],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_expr_or_spreads(&mut **self, node, ast_path)
    }

    fn visit_expr_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExprStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_expr_stmt(&mut **self, node, ast_path)
    }

    fn visit_exprs<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Box<Expr>],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_exprs(&mut **self, node, ast_path)
    }

    fn visit_fn_decl<'ast: 'r, 'r>(&mut self, node: &'ast FnDecl, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_fn_decl(&mut **self, node, ast_path)
    }

    fn visit_fn_expr<'ast: 'r, 'r>(&mut self, node: &'ast FnExpr, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_fn_expr(&mut **self, node, ast_path)
    }

    fn visit_for_head<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForHead,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_for_head(&mut **self, node, ast_path)
    }

    fn visit_for_in_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForInStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_for_in_stmt(&mut **self, node, ast_path)
    }

    fn visit_for_of_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForOfStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_for_of_stmt(&mut **self, node, ast_path)
    }

    fn visit_for_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_for_stmt(&mut **self, node, ast_path)
    }

    fn visit_function<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Function,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_function(&mut **self, node, ast_path)
    }

    fn visit_getter_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast GetterProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_getter_prop(&mut **self, node, ast_path)
    }

    fn visit_ident<'ast: 'r, 'r>(&mut self, node: &'ast Ident, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_ident(&mut **self, node, ast_path)
    }

    fn visit_ident_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IdentName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ident_name(&mut **self, node, ast_path)
    }

    fn visit_if_stmt<'ast: 'r, 'r>(&mut self, node: &'ast IfStmt, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_if_stmt(&mut **self, node, ast_path)
    }

    fn visit_import<'ast: 'r, 'r>(&mut self, node: &'ast Import, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_import(&mut **self, node, ast_path)
    }

    fn visit_import_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_import_decl(&mut **self, node, ast_path)
    }

    fn visit_import_default_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportDefaultSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_import_default_specifier(&mut **self, node, ast_path)
    }

    fn visit_import_named_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportNamedSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_import_named_specifier(&mut **self, node, ast_path)
    }

    fn visit_import_phase<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportPhase,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_import_phase(&mut **self, node, ast_path)
    }

    fn visit_import_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_import_specifier(&mut **self, node, ast_path)
    }

    fn visit_import_specifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ImportSpecifier],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_import_specifiers(&mut **self, node, ast_path)
    }

    fn visit_import_star_as_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportStarAsSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_import_star_as_specifier(&mut **self, node, ast_path)
    }

    fn visit_import_with<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportWith,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_import_with(&mut **self, node, ast_path)
    }

    fn visit_import_with_item<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportWithItem,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_import_with_item(&mut **self, node, ast_path)
    }

    fn visit_import_with_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ImportWithItem],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_import_with_items(&mut **self, node, ast_path)
    }

    fn visit_invalid<'ast: 'r, 'r>(&mut self, node: &'ast Invalid, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_invalid(&mut **self, node, ast_path)
    }

    fn visit_jsx_attr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_attr(&mut **self, node, ast_path)
    }

    fn visit_jsx_attr_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_attr_name(&mut **self, node, ast_path)
    }

    fn visit_jsx_attr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrOrSpread,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_attr_or_spread(&mut **self, node, ast_path)
    }

    fn visit_jsx_attr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [JSXAttrOrSpread],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_attr_or_spreads(&mut **self, node, ast_path)
    }

    fn visit_jsx_attr_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrValue,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_attr_value(&mut **self, node, ast_path)
    }

    fn visit_jsx_closing_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXClosingElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_closing_element(&mut **self, node, ast_path)
    }

    fn visit_jsx_closing_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXClosingFragment,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_closing_fragment(&mut **self, node, ast_path)
    }

    fn visit_jsx_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_element(&mut **self, node, ast_path)
    }

    fn visit_jsx_element_child<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElementChild,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_element_child(&mut **self, node, ast_path)
    }

    fn visit_jsx_element_childs<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [JSXElementChild],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_element_childs(&mut **self, node, ast_path)
    }

    fn visit_jsx_element_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElementName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_element_name(&mut **self, node, ast_path)
    }

    fn visit_jsx_empty_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXEmptyExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_empty_expr(&mut **self, node, ast_path)
    }

    fn visit_jsx_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_expr(&mut **self, node, ast_path)
    }

    fn visit_jsx_expr_container<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXExprContainer,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_expr_container(&mut **self, node, ast_path)
    }

    fn visit_jsx_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXFragment,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_fragment(&mut **self, node, ast_path)
    }

    fn visit_jsx_member_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXMemberExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_member_expr(&mut **self, node, ast_path)
    }

    fn visit_jsx_namespaced_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXNamespacedName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_namespaced_name(&mut **self, node, ast_path)
    }

    fn visit_jsx_object<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXObject,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_object(&mut **self, node, ast_path)
    }

    fn visit_jsx_opening_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXOpeningElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_opening_element(&mut **self, node, ast_path)
    }

    fn visit_jsx_opening_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXOpeningFragment,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_opening_fragment(&mut **self, node, ast_path)
    }

    fn visit_jsx_spread_child<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXSpreadChild,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_spread_child(&mut **self, node, ast_path)
    }

    fn visit_jsx_text<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXText,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_text(&mut **self, node, ast_path)
    }

    fn visit_key<'ast: 'r, 'r>(&mut self, node: &'ast Key, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_key(&mut **self, node, ast_path)
    }

    fn visit_key_value_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast KeyValuePatProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_key_value_pat_prop(&mut **self, node, ast_path)
    }

    fn visit_key_value_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast KeyValueProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_key_value_prop(&mut **self, node, ast_path)
    }

    fn visit_labeled_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast LabeledStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_labeled_stmt(&mut **self, node, ast_path)
    }

    fn visit_lit<'ast: 'r, 'r>(&mut self, node: &'ast Lit, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_lit(&mut **self, node, ast_path)
    }

    fn visit_member_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MemberExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_member_expr(&mut **self, node, ast_path)
    }

    fn visit_member_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MemberProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_member_prop(&mut **self, node, ast_path)
    }

    fn visit_meta_prop_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MetaPropExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_meta_prop_expr(&mut **self, node, ast_path)
    }

    fn visit_meta_prop_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MetaPropKind,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_meta_prop_kind(&mut **self, node, ast_path)
    }

    fn visit_method_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MethodKind,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_method_kind(&mut **self, node, ast_path)
    }

    fn visit_method_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MethodProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_method_prop(&mut **self, node, ast_path)
    }

    fn visit_module<'ast: 'r, 'r>(&mut self, node: &'ast Module, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_module(&mut **self, node, ast_path)
    }

    fn visit_module_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_module_decl(&mut **self, node, ast_path)
    }

    fn visit_module_export_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleExportName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_module_export_name(&mut **self, node, ast_path)
    }

    fn visit_module_item<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleItem,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_module_item(&mut **self, node, ast_path)
    }

    fn visit_module_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ModuleItem],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_module_items(&mut **self, node, ast_path)
    }

    fn visit_named_export<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NamedExport,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_named_export(&mut **self, node, ast_path)
    }

    fn visit_new_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NewExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_new_expr(&mut **self, node, ast_path)
    }

    fn visit_null<'ast: 'r, 'r>(&mut self, node: &'ast Null, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_null(&mut **self, node, ast_path)
    }

    fn visit_number<'ast: 'r, 'r>(&mut self, node: &'ast Number, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_number(&mut **self, node, ast_path)
    }

    fn visit_object_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectLit,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_object_lit(&mut **self, node, ast_path)
    }

    fn visit_object_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_object_pat(&mut **self, node, ast_path)
    }

    fn visit_object_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectPatProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_object_pat_prop(&mut **self, node, ast_path)
    }

    fn visit_object_pat_props<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ObjectPatProp],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_object_pat_props(&mut **self, node, ast_path)
    }

    fn visit_opt_accessibility<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Accessibility>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_accessibility(&mut **self, node, ast_path)
    }

    fn visit_opt_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_atoms::Atom>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_atom(&mut **self, node, ast_path)
    }

    fn visit_opt_block_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<BlockStmt>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_block_stmt(&mut **self, node, ast_path)
    }

    fn visit_opt_call<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptCall,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_call(&mut **self, node, ast_path)
    }

    fn visit_opt_catch_clause<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<CatchClause>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_catch_clause(&mut **self, node, ast_path)
    }

    fn visit_opt_chain_base<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptChainBase,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_chain_base(&mut **self, node, ast_path)
    }

    fn visit_opt_chain_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptChainExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_chain_expr(&mut **self, node, ast_path)
    }

    fn visit_opt_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Expr>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_expr(&mut **self, node, ast_path)
    }

    fn visit_opt_expr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<ExprOrSpread>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_expr_or_spread(&mut **self, node, ast_path)
    }

    fn visit_opt_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Vec<ExprOrSpread>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_expr_or_spreads(&mut **self, node, ast_path)
    }

    fn visit_opt_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Ident>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_ident(&mut **self, node, ast_path)
    }

    fn visit_opt_jsx_attr_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<JSXAttrValue>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_jsx_attr_value(&mut **self, node, ast_path)
    }

    fn visit_opt_jsx_closing_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<JSXClosingElement>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_jsx_closing_element(&mut **self, node, ast_path)
    }

    fn visit_opt_module_export_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<ModuleExportName>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_module_export_name(&mut **self, node, ast_path)
    }

    fn visit_opt_module_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Vec<ModuleItem>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_module_items(&mut **self, node, ast_path)
    }

    fn visit_opt_object_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<ObjectLit>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_object_lit(&mut **self, node, ast_path)
    }

    fn visit_opt_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Pat>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_pat(&mut **self, node, ast_path)
    }

    fn visit_opt_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_common::Span>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_span(&mut **self, node, ast_path)
    }

    fn visit_opt_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Stmt>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_stmt(&mut **self, node, ast_path)
    }

    fn visit_opt_str<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Str>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_str(&mut **self, node, ast_path)
    }

    fn visit_opt_true_plus_minus<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<TruePlusMinus>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_true_plus_minus(&mut **self, node, ast_path)
    }

    fn visit_opt_ts_entity_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<TsEntityName>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_ts_entity_name(&mut **self, node, ast_path)
    }

    fn visit_opt_ts_namespace_body<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<TsNamespaceBody>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_ts_namespace_body(&mut **self, node, ast_path)
    }

    fn visit_opt_ts_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<TsType>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_ts_type(&mut **self, node, ast_path)
    }

    fn visit_opt_ts_type_ann<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<TsTypeAnn>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_ts_type_ann(&mut **self, node, ast_path)
    }

    fn visit_opt_ts_type_param_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<TsTypeParamDecl>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_ts_type_param_decl(&mut **self, node, ast_path)
    }

    fn visit_opt_ts_type_param_instantiation<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<TsTypeParamInstantiation>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_ts_type_param_instantiation(&mut **self, node, ast_path)
    }

    fn visit_opt_var_decl_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<VarDeclOrExpr>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_var_decl_or_expr(&mut **self, node, ast_path)
    }

    fn visit_opt_vec_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Option<ExprOrSpread>],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_vec_expr_or_spreads(&mut **self, node, ast_path)
    }

    fn visit_opt_vec_pats<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Option<Pat>],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_vec_pats(&mut **self, node, ast_path)
    }

    fn visit_param<'ast: 'r, 'r>(&mut self, node: &'ast Param, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_param(&mut **self, node, ast_path)
    }

    fn visit_param_or_ts_param_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ParamOrTsParamProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_param_or_ts_param_prop(&mut **self, node, ast_path)
    }

    fn visit_param_or_ts_param_props<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ParamOrTsParamProp],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_param_or_ts_param_props(&mut **self, node, ast_path)
    }

    fn visit_params<'ast: 'r, 'r>(&mut self, node: &'ast [Param], ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_params(&mut **self, node, ast_path)
    }

    fn visit_paren_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ParenExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_paren_expr(&mut **self, node, ast_path)
    }

    fn visit_pat<'ast: 'r, 'r>(&mut self, node: &'ast Pat, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_pat(&mut **self, node, ast_path)
    }

    fn visit_pats<'ast: 'r, 'r>(&mut self, node: &'ast [Pat], ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_pats(&mut **self, node, ast_path)
    }

    fn visit_private_method<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateMethod,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_private_method(&mut **self, node, ast_path)
    }

    fn visit_private_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_private_name(&mut **self, node, ast_path)
    }

    fn visit_private_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_private_prop(&mut **self, node, ast_path)
    }

    fn visit_program<'ast: 'r, 'r>(&mut self, node: &'ast Program, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_program(&mut **self, node, ast_path)
    }

    fn visit_prop<'ast: 'r, 'r>(&mut self, node: &'ast Prop, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_prop(&mut **self, node, ast_path)
    }

    fn visit_prop_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PropName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_prop_name(&mut **self, node, ast_path)
    }

    fn visit_prop_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PropOrSpread,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_prop_or_spread(&mut **self, node, ast_path)
    }

    fn visit_prop_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [PropOrSpread],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_prop_or_spreads(&mut **self, node, ast_path)
    }

    fn visit_regex<'ast: 'r, 'r>(&mut self, node: &'ast Regex, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_regex(&mut **self, node, ast_path)
    }

    fn visit_reserved_unused<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ReservedUnused,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_reserved_unused(&mut **self, node, ast_path)
    }

    fn visit_rest_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast RestPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_rest_pat(&mut **self, node, ast_path)
    }

    fn visit_return_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ReturnStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_return_stmt(&mut **self, node, ast_path)
    }

    fn visit_script<'ast: 'r, 'r>(&mut self, node: &'ast Script, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_script(&mut **self, node, ast_path)
    }

    fn visit_seq_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SeqExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_seq_expr(&mut **self, node, ast_path)
    }

    fn visit_setter_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SetterProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_setter_prop(&mut **self, node, ast_path)
    }

    fn visit_simple_assign_target<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SimpleAssignTarget,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_simple_assign_target(&mut **self, node, ast_path)
    }

    fn visit_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::Span,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_span(&mut **self, node, ast_path)
    }

    fn visit_spread_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SpreadElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_spread_element(&mut **self, node, ast_path)
    }

    fn visit_static_block<'ast: 'r, 'r>(
        &mut self,
        node: &'ast StaticBlock,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_static_block(&mut **self, node, ast_path)
    }

    fn visit_stmt<'ast: 'r, 'r>(&mut self, node: &'ast Stmt, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_stmt(&mut **self, node, ast_path)
    }

    fn visit_stmts<'ast: 'r, 'r>(&mut self, node: &'ast [Stmt], ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_stmts(&mut **self, node, ast_path)
    }

    fn visit_str<'ast: 'r, 'r>(&mut self, node: &'ast Str, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_str(&mut **self, node, ast_path)
    }

    fn visit_super<'ast: 'r, 'r>(&mut self, node: &'ast Super, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_super(&mut **self, node, ast_path)
    }

    fn visit_super_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SuperProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_super_prop(&mut **self, node, ast_path)
    }

    fn visit_super_prop_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SuperPropExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_super_prop_expr(&mut **self, node, ast_path)
    }

    fn visit_switch_case<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SwitchCase,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_switch_case(&mut **self, node, ast_path)
    }

    fn visit_switch_cases<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [SwitchCase],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_switch_cases(&mut **self, node, ast_path)
    }

    fn visit_switch_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SwitchStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_switch_stmt(&mut **self, node, ast_path)
    }

    fn visit_syntax_context<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::SyntaxContext,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_syntax_context(&mut **self, node, ast_path)
    }

    fn visit_tagged_tpl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TaggedTpl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_tagged_tpl(&mut **self, node, ast_path)
    }

    fn visit_this_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ThisExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_this_expr(&mut **self, node, ast_path)
    }

    fn visit_throw_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ThrowStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_throw_stmt(&mut **self, node, ast_path)
    }

    fn visit_tpl<'ast: 'r, 'r>(&mut self, node: &'ast Tpl, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_tpl(&mut **self, node, ast_path)
    }

    fn visit_tpl_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TplElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_tpl_element(&mut **self, node, ast_path)
    }

    fn visit_tpl_elements<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TplElement],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_tpl_elements(&mut **self, node, ast_path)
    }

    fn visit_true_plus_minus<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TruePlusMinus,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_true_plus_minus(&mut **self, node, ast_path)
    }

    fn visit_try_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TryStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_try_stmt(&mut **self, node, ast_path)
    }

    fn visit_ts_array_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsArrayType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_array_type(&mut **self, node, ast_path)
    }

    fn visit_ts_as_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsAsExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_as_expr(&mut **self, node, ast_path)
    }

    fn visit_ts_call_signature_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsCallSignatureDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_call_signature_decl(&mut **self, node, ast_path)
    }

    fn visit_ts_conditional_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsConditionalType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_conditional_type(&mut **self, node, ast_path)
    }

    fn visit_ts_const_assertion<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsConstAssertion,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_const_assertion(&mut **self, node, ast_path)
    }

    fn visit_ts_construct_signature_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsConstructSignatureDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_construct_signature_decl(&mut **self, node, ast_path)
    }

    fn visit_ts_constructor_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsConstructorType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_constructor_type(&mut **self, node, ast_path)
    }

    fn visit_ts_entity_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsEntityName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_entity_name(&mut **self, node, ast_path)
    }

    fn visit_ts_enum_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsEnumDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_enum_decl(&mut **self, node, ast_path)
    }

    fn visit_ts_enum_member<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsEnumMember,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_enum_member(&mut **self, node, ast_path)
    }

    fn visit_ts_enum_member_id<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsEnumMemberId,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_enum_member_id(&mut **self, node, ast_path)
    }

    fn visit_ts_enum_members<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsEnumMember],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_enum_members(&mut **self, node, ast_path)
    }

    fn visit_ts_export_assignment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsExportAssignment,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_export_assignment(&mut **self, node, ast_path)
    }

    fn visit_ts_expr_with_type_args<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsExprWithTypeArgs,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_expr_with_type_args(&mut **self, node, ast_path)
    }

    fn visit_ts_expr_with_type_argss<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsExprWithTypeArgs],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_expr_with_type_argss(&mut **self, node, ast_path)
    }

    fn visit_ts_external_module_ref<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsExternalModuleRef,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_external_module_ref(&mut **self, node, ast_path)
    }

    fn visit_ts_fn_or_constructor_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsFnOrConstructorType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_fn_or_constructor_type(&mut **self, node, ast_path)
    }

    fn visit_ts_fn_param<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsFnParam,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_fn_param(&mut **self, node, ast_path)
    }

    fn visit_ts_fn_params<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsFnParam],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_fn_params(&mut **self, node, ast_path)
    }

    fn visit_ts_fn_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsFnType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_fn_type(&mut **self, node, ast_path)
    }

    fn visit_ts_getter_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsGetterSignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_getter_signature(&mut **self, node, ast_path)
    }

    fn visit_ts_import_equals_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsImportEqualsDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_import_equals_decl(&mut **self, node, ast_path)
    }

    fn visit_ts_import_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsImportType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_import_type(&mut **self, node, ast_path)
    }

    fn visit_ts_index_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsIndexSignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_index_signature(&mut **self, node, ast_path)
    }

    fn visit_ts_indexed_access_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsIndexedAccessType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_indexed_access_type(&mut **self, node, ast_path)
    }

    fn visit_ts_infer_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsInferType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_infer_type(&mut **self, node, ast_path)
    }

    fn visit_ts_instantiation<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsInstantiation,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_instantiation(&mut **self, node, ast_path)
    }

    fn visit_ts_interface_body<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsInterfaceBody,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_interface_body(&mut **self, node, ast_path)
    }

    fn visit_ts_interface_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsInterfaceDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_interface_decl(&mut **self, node, ast_path)
    }

    fn visit_ts_intersection_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsIntersectionType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_intersection_type(&mut **self, node, ast_path)
    }

    fn visit_ts_keyword_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsKeywordType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_keyword_type(&mut **self, node, ast_path)
    }

    fn visit_ts_keyword_type_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsKeywordTypeKind,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_keyword_type_kind(&mut **self, node, ast_path)
    }

    fn visit_ts_lit<'ast: 'r, 'r>(&mut self, node: &'ast TsLit, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_ts_lit(&mut **self, node, ast_path)
    }

    fn visit_ts_lit_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsLitType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_lit_type(&mut **self, node, ast_path)
    }

    fn visit_ts_mapped_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsMappedType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_mapped_type(&mut **self, node, ast_path)
    }

    fn visit_ts_method_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsMethodSignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_method_signature(&mut **self, node, ast_path)
    }

    fn visit_ts_module_block<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsModuleBlock,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_module_block(&mut **self, node, ast_path)
    }

    fn visit_ts_module_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsModuleDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_module_decl(&mut **self, node, ast_path)
    }

    fn visit_ts_module_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsModuleName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_module_name(&mut **self, node, ast_path)
    }

    fn visit_ts_module_ref<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsModuleRef,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_module_ref(&mut **self, node, ast_path)
    }

    fn visit_ts_namespace_body<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsNamespaceBody,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_namespace_body(&mut **self, node, ast_path)
    }

    fn visit_ts_namespace_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsNamespaceDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_namespace_decl(&mut **self, node, ast_path)
    }

    fn visit_ts_namespace_export_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsNamespaceExportDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_namespace_export_decl(&mut **self, node, ast_path)
    }

    fn visit_ts_non_null_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsNonNullExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_non_null_expr(&mut **self, node, ast_path)
    }

    fn visit_ts_optional_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsOptionalType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_optional_type(&mut **self, node, ast_path)
    }

    fn visit_ts_param_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsParamProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_param_prop(&mut **self, node, ast_path)
    }

    fn visit_ts_param_prop_param<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsParamPropParam,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_param_prop_param(&mut **self, node, ast_path)
    }

    fn visit_ts_parenthesized_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsParenthesizedType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_parenthesized_type(&mut **self, node, ast_path)
    }

    fn visit_ts_property_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsPropertySignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_property_signature(&mut **self, node, ast_path)
    }

    fn visit_ts_qualified_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsQualifiedName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_qualified_name(&mut **self, node, ast_path)
    }

    fn visit_ts_rest_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsRestType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_rest_type(&mut **self, node, ast_path)
    }

    fn visit_ts_satisfies_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsSatisfiesExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_satisfies_expr(&mut **self, node, ast_path)
    }

    fn visit_ts_setter_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsSetterSignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_setter_signature(&mut **self, node, ast_path)
    }

    fn visit_ts_this_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsThisType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_this_type(&mut **self, node, ast_path)
    }

    fn visit_ts_this_type_or_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsThisTypeOrIdent,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_this_type_or_ident(&mut **self, node, ast_path)
    }

    fn visit_ts_tpl_lit_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTplLitType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_tpl_lit_type(&mut **self, node, ast_path)
    }

    fn visit_ts_tuple_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTupleElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_tuple_element(&mut **self, node, ast_path)
    }

    fn visit_ts_tuple_elements<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsTupleElement],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_tuple_elements(&mut **self, node, ast_path)
    }

    fn visit_ts_tuple_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTupleType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_tuple_type(&mut **self, node, ast_path)
    }

    fn visit_ts_type<'ast: 'r, 'r>(&mut self, node: &'ast TsType, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_ts_type(&mut **self, node, ast_path)
    }

    fn visit_ts_type_alias_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeAliasDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_alias_decl(&mut **self, node, ast_path)
    }

    fn visit_ts_type_ann<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeAnn,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_ann(&mut **self, node, ast_path)
    }

    fn visit_ts_type_assertion<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeAssertion,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_assertion(&mut **self, node, ast_path)
    }

    fn visit_ts_type_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_element(&mut **self, node, ast_path)
    }

    fn visit_ts_type_elements<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsTypeElement],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_elements(&mut **self, node, ast_path)
    }

    fn visit_ts_type_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeLit,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_lit(&mut **self, node, ast_path)
    }

    fn visit_ts_type_operator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeOperator,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_operator(&mut **self, node, ast_path)
    }

    fn visit_ts_type_operator_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeOperatorOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_operator_op(&mut **self, node, ast_path)
    }

    fn visit_ts_type_param<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeParam,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_param(&mut **self, node, ast_path)
    }

    fn visit_ts_type_param_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeParamDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_param_decl(&mut **self, node, ast_path)
    }

    fn visit_ts_type_param_instantiation<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeParamInstantiation,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_param_instantiation(&mut **self, node, ast_path)
    }

    fn visit_ts_type_params<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsTypeParam],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_params(&mut **self, node, ast_path)
    }

    fn visit_ts_type_predicate<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypePredicate,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_predicate(&mut **self, node, ast_path)
    }

    fn visit_ts_type_query<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeQuery,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_query(&mut **self, node, ast_path)
    }

    fn visit_ts_type_query_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeQueryExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_query_expr(&mut **self, node, ast_path)
    }

    fn visit_ts_type_ref<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeRef,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_ref(&mut **self, node, ast_path)
    }

    fn visit_ts_types<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Box<TsType>],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_types(&mut **self, node, ast_path)
    }

    fn visit_ts_union_or_intersection_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsUnionOrIntersectionType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_union_or_intersection_type(&mut **self, node, ast_path)
    }

    fn visit_ts_union_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsUnionType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_union_type(&mut **self, node, ast_path)
    }

    fn visit_unary_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnaryExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_unary_expr(&mut **self, node, ast_path)
    }

    fn visit_unary_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnaryOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_unary_op(&mut **self, node, ast_path)
    }

    fn visit_update_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UpdateExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_update_expr(&mut **self, node, ast_path)
    }

    fn visit_update_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UpdateOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_update_op(&mut **self, node, ast_path)
    }

    fn visit_using_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UsingDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_using_decl(&mut **self, node, ast_path)
    }

    fn visit_var_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_var_decl(&mut **self, node, ast_path)
    }

    fn visit_var_decl_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclKind,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_var_decl_kind(&mut **self, node, ast_path)
    }

    fn visit_var_decl_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclOrExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_var_decl_or_expr(&mut **self, node, ast_path)
    }

    fn visit_var_declarator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclarator,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_var_declarator(&mut **self, node, ast_path)
    }

    fn visit_var_declarators<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [VarDeclarator],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_var_declarators(&mut **self, node, ast_path)
    }

    fn visit_while_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast WhileStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_while_stmt(&mut **self, node, ast_path)
    }

    fn visit_with_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast WithStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_with_stmt(&mut **self, node, ast_path)
    }

    fn visit_yield_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast YieldExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_yield_expr(&mut **self, node, ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> VisitAstPath for Box<V>
where
    V: ?Sized + VisitAstPath,
{
    fn visit_accessibility<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Accessibility,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_accessibility(&mut **self, node, ast_path)
    }

    fn visit_array_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrayLit,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_array_lit(&mut **self, node, ast_path)
    }

    fn visit_array_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrayPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_array_pat(&mut **self, node, ast_path)
    }

    fn visit_arrow_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrowExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_arrow_expr(&mut **self, node, ast_path)
    }

    fn visit_assign_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_assign_expr(&mut **self, node, ast_path)
    }

    fn visit_assign_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_assign_op(&mut **self, node, ast_path)
    }

    fn visit_assign_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_assign_pat(&mut **self, node, ast_path)
    }

    fn visit_assign_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignPatProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_assign_pat_prop(&mut **self, node, ast_path)
    }

    fn visit_assign_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_assign_prop(&mut **self, node, ast_path)
    }

    fn visit_assign_target<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignTarget,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_assign_target(&mut **self, node, ast_path)
    }

    fn visit_assign_target_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignTargetPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_assign_target_pat(&mut **self, node, ast_path)
    }

    fn visit_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_atoms::Atom,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_atom(&mut **self, node, ast_path)
    }

    fn visit_auto_accessor<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AutoAccessor,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_auto_accessor(&mut **self, node, ast_path)
    }

    fn visit_await_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AwaitExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_await_expr(&mut **self, node, ast_path)
    }

    fn visit_big_int<'ast: 'r, 'r>(&mut self, node: &'ast BigInt, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_big_int(&mut **self, node, ast_path)
    }

    fn visit_big_int_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BigIntValue,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_big_int_value(&mut **self, node, ast_path)
    }

    fn visit_bin_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BinExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_bin_expr(&mut **self, node, ast_path)
    }

    fn visit_binary_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BinaryOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_binary_op(&mut **self, node, ast_path)
    }

    fn visit_binding_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BindingIdent,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_binding_ident(&mut **self, node, ast_path)
    }

    fn visit_block_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BlockStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_block_stmt(&mut **self, node, ast_path)
    }

    fn visit_block_stmt_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BlockStmtOrExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_block_stmt_or_expr(&mut **self, node, ast_path)
    }

    fn visit_bool<'ast: 'r, 'r>(&mut self, node: &'ast Bool, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_bool(&mut **self, node, ast_path)
    }

    fn visit_break_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BreakStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_break_stmt(&mut **self, node, ast_path)
    }

    fn visit_call_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CallExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_call_expr(&mut **self, node, ast_path)
    }

    fn visit_callee<'ast: 'r, 'r>(&mut self, node: &'ast Callee, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_callee(&mut **self, node, ast_path)
    }

    fn visit_catch_clause<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CatchClause,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_catch_clause(&mut **self, node, ast_path)
    }

    fn visit_class<'ast: 'r, 'r>(&mut self, node: &'ast Class, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_class(&mut **self, node, ast_path)
    }

    fn visit_class_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_class_decl(&mut **self, node, ast_path)
    }

    fn visit_class_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_class_expr(&mut **self, node, ast_path)
    }

    fn visit_class_member<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassMember,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_class_member(&mut **self, node, ast_path)
    }

    fn visit_class_members<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ClassMember],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_class_members(&mut **self, node, ast_path)
    }

    fn visit_class_method<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassMethod,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_class_method(&mut **self, node, ast_path)
    }

    fn visit_class_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_class_prop(&mut **self, node, ast_path)
    }

    fn visit_computed_prop_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ComputedPropName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_computed_prop_name(&mut **self, node, ast_path)
    }

    fn visit_cond_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CondExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_cond_expr(&mut **self, node, ast_path)
    }

    fn visit_constructor<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Constructor,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_constructor(&mut **self, node, ast_path)
    }

    fn visit_continue_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ContinueStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_continue_stmt(&mut **self, node, ast_path)
    }

    fn visit_debugger_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DebuggerStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_debugger_stmt(&mut **self, node, ast_path)
    }

    fn visit_decl<'ast: 'r, 'r>(&mut self, node: &'ast Decl, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_decl(&mut **self, node, ast_path)
    }

    fn visit_decorator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Decorator,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_decorator(&mut **self, node, ast_path)
    }

    fn visit_decorators<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Decorator],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_decorators(&mut **self, node, ast_path)
    }

    fn visit_default_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DefaultDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_default_decl(&mut **self, node, ast_path)
    }

    fn visit_do_while_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DoWhileStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_do_while_stmt(&mut **self, node, ast_path)
    }

    fn visit_empty_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast EmptyStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_empty_stmt(&mut **self, node, ast_path)
    }

    fn visit_es_version<'ast: 'r, 'r>(
        &mut self,
        node: &'ast EsVersion,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_es_version(&mut **self, node, ast_path)
    }

    fn visit_export_all<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportAll,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_export_all(&mut **self, node, ast_path)
    }

    fn visit_export_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_export_decl(&mut **self, node, ast_path)
    }

    fn visit_export_default_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_export_default_decl(&mut **self, node, ast_path)
    }

    fn visit_export_default_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_export_default_expr(&mut **self, node, ast_path)
    }

    fn visit_export_default_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_export_default_specifier(&mut **self, node, ast_path)
    }

    fn visit_export_named_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportNamedSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_export_named_specifier(&mut **self, node, ast_path)
    }

    fn visit_export_namespace_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportNamespaceSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_export_namespace_specifier(&mut **self, node, ast_path)
    }

    fn visit_export_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_export_specifier(&mut **self, node, ast_path)
    }

    fn visit_export_specifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ExportSpecifier],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_export_specifiers(&mut **self, node, ast_path)
    }

    fn visit_expr<'ast: 'r, 'r>(&mut self, node: &'ast Expr, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_expr(&mut **self, node, ast_path)
    }

    fn visit_expr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExprOrSpread,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_expr_or_spread(&mut **self, node, ast_path)
    }

    fn visit_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ExprOrSpread],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_expr_or_spreads(&mut **self, node, ast_path)
    }

    fn visit_expr_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExprStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_expr_stmt(&mut **self, node, ast_path)
    }

    fn visit_exprs<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Box<Expr>],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_exprs(&mut **self, node, ast_path)
    }

    fn visit_fn_decl<'ast: 'r, 'r>(&mut self, node: &'ast FnDecl, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_fn_decl(&mut **self, node, ast_path)
    }

    fn visit_fn_expr<'ast: 'r, 'r>(&mut self, node: &'ast FnExpr, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_fn_expr(&mut **self, node, ast_path)
    }

    fn visit_for_head<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForHead,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_for_head(&mut **self, node, ast_path)
    }

    fn visit_for_in_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForInStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_for_in_stmt(&mut **self, node, ast_path)
    }

    fn visit_for_of_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForOfStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_for_of_stmt(&mut **self, node, ast_path)
    }

    fn visit_for_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_for_stmt(&mut **self, node, ast_path)
    }

    fn visit_function<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Function,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_function(&mut **self, node, ast_path)
    }

    fn visit_getter_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast GetterProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_getter_prop(&mut **self, node, ast_path)
    }

    fn visit_ident<'ast: 'r, 'r>(&mut self, node: &'ast Ident, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_ident(&mut **self, node, ast_path)
    }

    fn visit_ident_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IdentName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ident_name(&mut **self, node, ast_path)
    }

    fn visit_if_stmt<'ast: 'r, 'r>(&mut self, node: &'ast IfStmt, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_if_stmt(&mut **self, node, ast_path)
    }

    fn visit_import<'ast: 'r, 'r>(&mut self, node: &'ast Import, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_import(&mut **self, node, ast_path)
    }

    fn visit_import_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_import_decl(&mut **self, node, ast_path)
    }

    fn visit_import_default_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportDefaultSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_import_default_specifier(&mut **self, node, ast_path)
    }

    fn visit_import_named_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportNamedSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_import_named_specifier(&mut **self, node, ast_path)
    }

    fn visit_import_phase<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportPhase,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_import_phase(&mut **self, node, ast_path)
    }

    fn visit_import_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_import_specifier(&mut **self, node, ast_path)
    }

    fn visit_import_specifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ImportSpecifier],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_import_specifiers(&mut **self, node, ast_path)
    }

    fn visit_import_star_as_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportStarAsSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_import_star_as_specifier(&mut **self, node, ast_path)
    }

    fn visit_import_with<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportWith,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_import_with(&mut **self, node, ast_path)
    }

    fn visit_import_with_item<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportWithItem,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_import_with_item(&mut **self, node, ast_path)
    }

    fn visit_import_with_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ImportWithItem],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_import_with_items(&mut **self, node, ast_path)
    }

    fn visit_invalid<'ast: 'r, 'r>(&mut self, node: &'ast Invalid, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_invalid(&mut **self, node, ast_path)
    }

    fn visit_jsx_attr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_attr(&mut **self, node, ast_path)
    }

    fn visit_jsx_attr_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_attr_name(&mut **self, node, ast_path)
    }

    fn visit_jsx_attr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrOrSpread,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_attr_or_spread(&mut **self, node, ast_path)
    }

    fn visit_jsx_attr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [JSXAttrOrSpread],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_attr_or_spreads(&mut **self, node, ast_path)
    }

    fn visit_jsx_attr_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrValue,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_attr_value(&mut **self, node, ast_path)
    }

    fn visit_jsx_closing_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXClosingElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_closing_element(&mut **self, node, ast_path)
    }

    fn visit_jsx_closing_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXClosingFragment,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_closing_fragment(&mut **self, node, ast_path)
    }

    fn visit_jsx_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_element(&mut **self, node, ast_path)
    }

    fn visit_jsx_element_child<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElementChild,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_element_child(&mut **self, node, ast_path)
    }

    fn visit_jsx_element_childs<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [JSXElementChild],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_element_childs(&mut **self, node, ast_path)
    }

    fn visit_jsx_element_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElementName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_element_name(&mut **self, node, ast_path)
    }

    fn visit_jsx_empty_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXEmptyExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_empty_expr(&mut **self, node, ast_path)
    }

    fn visit_jsx_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_expr(&mut **self, node, ast_path)
    }

    fn visit_jsx_expr_container<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXExprContainer,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_expr_container(&mut **self, node, ast_path)
    }

    fn visit_jsx_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXFragment,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_fragment(&mut **self, node, ast_path)
    }

    fn visit_jsx_member_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXMemberExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_member_expr(&mut **self, node, ast_path)
    }

    fn visit_jsx_namespaced_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXNamespacedName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_namespaced_name(&mut **self, node, ast_path)
    }

    fn visit_jsx_object<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXObject,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_object(&mut **self, node, ast_path)
    }

    fn visit_jsx_opening_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXOpeningElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_opening_element(&mut **self, node, ast_path)
    }

    fn visit_jsx_opening_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXOpeningFragment,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_opening_fragment(&mut **self, node, ast_path)
    }

    fn visit_jsx_spread_child<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXSpreadChild,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_spread_child(&mut **self, node, ast_path)
    }

    fn visit_jsx_text<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXText,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_jsx_text(&mut **self, node, ast_path)
    }

    fn visit_key<'ast: 'r, 'r>(&mut self, node: &'ast Key, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_key(&mut **self, node, ast_path)
    }

    fn visit_key_value_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast KeyValuePatProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_key_value_pat_prop(&mut **self, node, ast_path)
    }

    fn visit_key_value_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast KeyValueProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_key_value_prop(&mut **self, node, ast_path)
    }

    fn visit_labeled_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast LabeledStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_labeled_stmt(&mut **self, node, ast_path)
    }

    fn visit_lit<'ast: 'r, 'r>(&mut self, node: &'ast Lit, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_lit(&mut **self, node, ast_path)
    }

    fn visit_member_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MemberExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_member_expr(&mut **self, node, ast_path)
    }

    fn visit_member_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MemberProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_member_prop(&mut **self, node, ast_path)
    }

    fn visit_meta_prop_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MetaPropExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_meta_prop_expr(&mut **self, node, ast_path)
    }

    fn visit_meta_prop_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MetaPropKind,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_meta_prop_kind(&mut **self, node, ast_path)
    }

    fn visit_method_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MethodKind,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_method_kind(&mut **self, node, ast_path)
    }

    fn visit_method_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MethodProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_method_prop(&mut **self, node, ast_path)
    }

    fn visit_module<'ast: 'r, 'r>(&mut self, node: &'ast Module, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_module(&mut **self, node, ast_path)
    }

    fn visit_module_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_module_decl(&mut **self, node, ast_path)
    }

    fn visit_module_export_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleExportName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_module_export_name(&mut **self, node, ast_path)
    }

    fn visit_module_item<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleItem,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_module_item(&mut **self, node, ast_path)
    }

    fn visit_module_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ModuleItem],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_module_items(&mut **self, node, ast_path)
    }

    fn visit_named_export<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NamedExport,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_named_export(&mut **self, node, ast_path)
    }

    fn visit_new_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NewExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_new_expr(&mut **self, node, ast_path)
    }

    fn visit_null<'ast: 'r, 'r>(&mut self, node: &'ast Null, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_null(&mut **self, node, ast_path)
    }

    fn visit_number<'ast: 'r, 'r>(&mut self, node: &'ast Number, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_number(&mut **self, node, ast_path)
    }

    fn visit_object_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectLit,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_object_lit(&mut **self, node, ast_path)
    }

    fn visit_object_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_object_pat(&mut **self, node, ast_path)
    }

    fn visit_object_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectPatProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_object_pat_prop(&mut **self, node, ast_path)
    }

    fn visit_object_pat_props<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ObjectPatProp],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_object_pat_props(&mut **self, node, ast_path)
    }

    fn visit_opt_accessibility<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Accessibility>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_accessibility(&mut **self, node, ast_path)
    }

    fn visit_opt_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_atoms::Atom>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_atom(&mut **self, node, ast_path)
    }

    fn visit_opt_block_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<BlockStmt>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_block_stmt(&mut **self, node, ast_path)
    }

    fn visit_opt_call<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptCall,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_call(&mut **self, node, ast_path)
    }

    fn visit_opt_catch_clause<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<CatchClause>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_catch_clause(&mut **self, node, ast_path)
    }

    fn visit_opt_chain_base<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptChainBase,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_chain_base(&mut **self, node, ast_path)
    }

    fn visit_opt_chain_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptChainExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_chain_expr(&mut **self, node, ast_path)
    }

    fn visit_opt_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Expr>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_expr(&mut **self, node, ast_path)
    }

    fn visit_opt_expr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<ExprOrSpread>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_expr_or_spread(&mut **self, node, ast_path)
    }

    fn visit_opt_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Vec<ExprOrSpread>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_expr_or_spreads(&mut **self, node, ast_path)
    }

    fn visit_opt_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Ident>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_ident(&mut **self, node, ast_path)
    }

    fn visit_opt_jsx_attr_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<JSXAttrValue>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_jsx_attr_value(&mut **self, node, ast_path)
    }

    fn visit_opt_jsx_closing_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<JSXClosingElement>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_jsx_closing_element(&mut **self, node, ast_path)
    }

    fn visit_opt_module_export_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<ModuleExportName>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_module_export_name(&mut **self, node, ast_path)
    }

    fn visit_opt_module_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Vec<ModuleItem>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_module_items(&mut **self, node, ast_path)
    }

    fn visit_opt_object_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<ObjectLit>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_object_lit(&mut **self, node, ast_path)
    }

    fn visit_opt_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Pat>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_pat(&mut **self, node, ast_path)
    }

    fn visit_opt_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_common::Span>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_span(&mut **self, node, ast_path)
    }

    fn visit_opt_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Stmt>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_stmt(&mut **self, node, ast_path)
    }

    fn visit_opt_str<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Str>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_str(&mut **self, node, ast_path)
    }

    fn visit_opt_true_plus_minus<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<TruePlusMinus>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_true_plus_minus(&mut **self, node, ast_path)
    }

    fn visit_opt_ts_entity_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<TsEntityName>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_ts_entity_name(&mut **self, node, ast_path)
    }

    fn visit_opt_ts_namespace_body<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<TsNamespaceBody>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_ts_namespace_body(&mut **self, node, ast_path)
    }

    fn visit_opt_ts_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<TsType>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_ts_type(&mut **self, node, ast_path)
    }

    fn visit_opt_ts_type_ann<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<TsTypeAnn>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_ts_type_ann(&mut **self, node, ast_path)
    }

    fn visit_opt_ts_type_param_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<TsTypeParamDecl>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_ts_type_param_decl(&mut **self, node, ast_path)
    }

    fn visit_opt_ts_type_param_instantiation<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<TsTypeParamInstantiation>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_ts_type_param_instantiation(&mut **self, node, ast_path)
    }

    fn visit_opt_var_decl_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<VarDeclOrExpr>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_var_decl_or_expr(&mut **self, node, ast_path)
    }

    fn visit_opt_vec_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Option<ExprOrSpread>],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_vec_expr_or_spreads(&mut **self, node, ast_path)
    }

    fn visit_opt_vec_pats<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Option<Pat>],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_opt_vec_pats(&mut **self, node, ast_path)
    }

    fn visit_param<'ast: 'r, 'r>(&mut self, node: &'ast Param, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_param(&mut **self, node, ast_path)
    }

    fn visit_param_or_ts_param_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ParamOrTsParamProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_param_or_ts_param_prop(&mut **self, node, ast_path)
    }

    fn visit_param_or_ts_param_props<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ParamOrTsParamProp],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_param_or_ts_param_props(&mut **self, node, ast_path)
    }

    fn visit_params<'ast: 'r, 'r>(&mut self, node: &'ast [Param], ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_params(&mut **self, node, ast_path)
    }

    fn visit_paren_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ParenExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_paren_expr(&mut **self, node, ast_path)
    }

    fn visit_pat<'ast: 'r, 'r>(&mut self, node: &'ast Pat, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_pat(&mut **self, node, ast_path)
    }

    fn visit_pats<'ast: 'r, 'r>(&mut self, node: &'ast [Pat], ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_pats(&mut **self, node, ast_path)
    }

    fn visit_private_method<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateMethod,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_private_method(&mut **self, node, ast_path)
    }

    fn visit_private_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_private_name(&mut **self, node, ast_path)
    }

    fn visit_private_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_private_prop(&mut **self, node, ast_path)
    }

    fn visit_program<'ast: 'r, 'r>(&mut self, node: &'ast Program, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_program(&mut **self, node, ast_path)
    }

    fn visit_prop<'ast: 'r, 'r>(&mut self, node: &'ast Prop, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_prop(&mut **self, node, ast_path)
    }

    fn visit_prop_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PropName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_prop_name(&mut **self, node, ast_path)
    }

    fn visit_prop_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PropOrSpread,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_prop_or_spread(&mut **self, node, ast_path)
    }

    fn visit_prop_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [PropOrSpread],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_prop_or_spreads(&mut **self, node, ast_path)
    }

    fn visit_regex<'ast: 'r, 'r>(&mut self, node: &'ast Regex, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_regex(&mut **self, node, ast_path)
    }

    fn visit_reserved_unused<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ReservedUnused,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_reserved_unused(&mut **self, node, ast_path)
    }

    fn visit_rest_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast RestPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_rest_pat(&mut **self, node, ast_path)
    }

    fn visit_return_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ReturnStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_return_stmt(&mut **self, node, ast_path)
    }

    fn visit_script<'ast: 'r, 'r>(&mut self, node: &'ast Script, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_script(&mut **self, node, ast_path)
    }

    fn visit_seq_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SeqExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_seq_expr(&mut **self, node, ast_path)
    }

    fn visit_setter_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SetterProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_setter_prop(&mut **self, node, ast_path)
    }

    fn visit_simple_assign_target<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SimpleAssignTarget,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_simple_assign_target(&mut **self, node, ast_path)
    }

    fn visit_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::Span,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_span(&mut **self, node, ast_path)
    }

    fn visit_spread_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SpreadElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_spread_element(&mut **self, node, ast_path)
    }

    fn visit_static_block<'ast: 'r, 'r>(
        &mut self,
        node: &'ast StaticBlock,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_static_block(&mut **self, node, ast_path)
    }

    fn visit_stmt<'ast: 'r, 'r>(&mut self, node: &'ast Stmt, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_stmt(&mut **self, node, ast_path)
    }

    fn visit_stmts<'ast: 'r, 'r>(&mut self, node: &'ast [Stmt], ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_stmts(&mut **self, node, ast_path)
    }

    fn visit_str<'ast: 'r, 'r>(&mut self, node: &'ast Str, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_str(&mut **self, node, ast_path)
    }

    fn visit_super<'ast: 'r, 'r>(&mut self, node: &'ast Super, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_super(&mut **self, node, ast_path)
    }

    fn visit_super_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SuperProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_super_prop(&mut **self, node, ast_path)
    }

    fn visit_super_prop_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SuperPropExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_super_prop_expr(&mut **self, node, ast_path)
    }

    fn visit_switch_case<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SwitchCase,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_switch_case(&mut **self, node, ast_path)
    }

    fn visit_switch_cases<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [SwitchCase],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_switch_cases(&mut **self, node, ast_path)
    }

    fn visit_switch_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SwitchStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_switch_stmt(&mut **self, node, ast_path)
    }

    fn visit_syntax_context<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::SyntaxContext,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_syntax_context(&mut **self, node, ast_path)
    }

    fn visit_tagged_tpl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TaggedTpl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_tagged_tpl(&mut **self, node, ast_path)
    }

    fn visit_this_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ThisExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_this_expr(&mut **self, node, ast_path)
    }

    fn visit_throw_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ThrowStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_throw_stmt(&mut **self, node, ast_path)
    }

    fn visit_tpl<'ast: 'r, 'r>(&mut self, node: &'ast Tpl, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_tpl(&mut **self, node, ast_path)
    }

    fn visit_tpl_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TplElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_tpl_element(&mut **self, node, ast_path)
    }

    fn visit_tpl_elements<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TplElement],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_tpl_elements(&mut **self, node, ast_path)
    }

    fn visit_true_plus_minus<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TruePlusMinus,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_true_plus_minus(&mut **self, node, ast_path)
    }

    fn visit_try_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TryStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_try_stmt(&mut **self, node, ast_path)
    }

    fn visit_ts_array_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsArrayType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_array_type(&mut **self, node, ast_path)
    }

    fn visit_ts_as_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsAsExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_as_expr(&mut **self, node, ast_path)
    }

    fn visit_ts_call_signature_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsCallSignatureDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_call_signature_decl(&mut **self, node, ast_path)
    }

    fn visit_ts_conditional_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsConditionalType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_conditional_type(&mut **self, node, ast_path)
    }

    fn visit_ts_const_assertion<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsConstAssertion,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_const_assertion(&mut **self, node, ast_path)
    }

    fn visit_ts_construct_signature_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsConstructSignatureDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_construct_signature_decl(&mut **self, node, ast_path)
    }

    fn visit_ts_constructor_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsConstructorType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_constructor_type(&mut **self, node, ast_path)
    }

    fn visit_ts_entity_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsEntityName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_entity_name(&mut **self, node, ast_path)
    }

    fn visit_ts_enum_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsEnumDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_enum_decl(&mut **self, node, ast_path)
    }

    fn visit_ts_enum_member<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsEnumMember,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_enum_member(&mut **self, node, ast_path)
    }

    fn visit_ts_enum_member_id<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsEnumMemberId,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_enum_member_id(&mut **self, node, ast_path)
    }

    fn visit_ts_enum_members<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsEnumMember],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_enum_members(&mut **self, node, ast_path)
    }

    fn visit_ts_export_assignment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsExportAssignment,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_export_assignment(&mut **self, node, ast_path)
    }

    fn visit_ts_expr_with_type_args<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsExprWithTypeArgs,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_expr_with_type_args(&mut **self, node, ast_path)
    }

    fn visit_ts_expr_with_type_argss<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsExprWithTypeArgs],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_expr_with_type_argss(&mut **self, node, ast_path)
    }

    fn visit_ts_external_module_ref<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsExternalModuleRef,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_external_module_ref(&mut **self, node, ast_path)
    }

    fn visit_ts_fn_or_constructor_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsFnOrConstructorType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_fn_or_constructor_type(&mut **self, node, ast_path)
    }

    fn visit_ts_fn_param<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsFnParam,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_fn_param(&mut **self, node, ast_path)
    }

    fn visit_ts_fn_params<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsFnParam],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_fn_params(&mut **self, node, ast_path)
    }

    fn visit_ts_fn_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsFnType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_fn_type(&mut **self, node, ast_path)
    }

    fn visit_ts_getter_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsGetterSignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_getter_signature(&mut **self, node, ast_path)
    }

    fn visit_ts_import_equals_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsImportEqualsDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_import_equals_decl(&mut **self, node, ast_path)
    }

    fn visit_ts_import_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsImportType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_import_type(&mut **self, node, ast_path)
    }

    fn visit_ts_index_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsIndexSignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_index_signature(&mut **self, node, ast_path)
    }

    fn visit_ts_indexed_access_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsIndexedAccessType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_indexed_access_type(&mut **self, node, ast_path)
    }

    fn visit_ts_infer_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsInferType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_infer_type(&mut **self, node, ast_path)
    }

    fn visit_ts_instantiation<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsInstantiation,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_instantiation(&mut **self, node, ast_path)
    }

    fn visit_ts_interface_body<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsInterfaceBody,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_interface_body(&mut **self, node, ast_path)
    }

    fn visit_ts_interface_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsInterfaceDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_interface_decl(&mut **self, node, ast_path)
    }

    fn visit_ts_intersection_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsIntersectionType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_intersection_type(&mut **self, node, ast_path)
    }

    fn visit_ts_keyword_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsKeywordType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_keyword_type(&mut **self, node, ast_path)
    }

    fn visit_ts_keyword_type_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsKeywordTypeKind,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_keyword_type_kind(&mut **self, node, ast_path)
    }

    fn visit_ts_lit<'ast: 'r, 'r>(&mut self, node: &'ast TsLit, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_ts_lit(&mut **self, node, ast_path)
    }

    fn visit_ts_lit_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsLitType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_lit_type(&mut **self, node, ast_path)
    }

    fn visit_ts_mapped_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsMappedType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_mapped_type(&mut **self, node, ast_path)
    }

    fn visit_ts_method_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsMethodSignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_method_signature(&mut **self, node, ast_path)
    }

    fn visit_ts_module_block<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsModuleBlock,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_module_block(&mut **self, node, ast_path)
    }

    fn visit_ts_module_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsModuleDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_module_decl(&mut **self, node, ast_path)
    }

    fn visit_ts_module_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsModuleName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_module_name(&mut **self, node, ast_path)
    }

    fn visit_ts_module_ref<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsModuleRef,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_module_ref(&mut **self, node, ast_path)
    }

    fn visit_ts_namespace_body<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsNamespaceBody,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_namespace_body(&mut **self, node, ast_path)
    }

    fn visit_ts_namespace_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsNamespaceDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_namespace_decl(&mut **self, node, ast_path)
    }

    fn visit_ts_namespace_export_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsNamespaceExportDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_namespace_export_decl(&mut **self, node, ast_path)
    }

    fn visit_ts_non_null_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsNonNullExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_non_null_expr(&mut **self, node, ast_path)
    }

    fn visit_ts_optional_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsOptionalType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_optional_type(&mut **self, node, ast_path)
    }

    fn visit_ts_param_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsParamProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_param_prop(&mut **self, node, ast_path)
    }

    fn visit_ts_param_prop_param<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsParamPropParam,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_param_prop_param(&mut **self, node, ast_path)
    }

    fn visit_ts_parenthesized_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsParenthesizedType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_parenthesized_type(&mut **self, node, ast_path)
    }

    fn visit_ts_property_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsPropertySignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_property_signature(&mut **self, node, ast_path)
    }

    fn visit_ts_qualified_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsQualifiedName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_qualified_name(&mut **self, node, ast_path)
    }

    fn visit_ts_rest_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsRestType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_rest_type(&mut **self, node, ast_path)
    }

    fn visit_ts_satisfies_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsSatisfiesExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_satisfies_expr(&mut **self, node, ast_path)
    }

    fn visit_ts_setter_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsSetterSignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_setter_signature(&mut **self, node, ast_path)
    }

    fn visit_ts_this_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsThisType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_this_type(&mut **self, node, ast_path)
    }

    fn visit_ts_this_type_or_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsThisTypeOrIdent,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_this_type_or_ident(&mut **self, node, ast_path)
    }

    fn visit_ts_tpl_lit_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTplLitType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_tpl_lit_type(&mut **self, node, ast_path)
    }

    fn visit_ts_tuple_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTupleElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_tuple_element(&mut **self, node, ast_path)
    }

    fn visit_ts_tuple_elements<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsTupleElement],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_tuple_elements(&mut **self, node, ast_path)
    }

    fn visit_ts_tuple_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTupleType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_tuple_type(&mut **self, node, ast_path)
    }

    fn visit_ts_type<'ast: 'r, 'r>(&mut self, node: &'ast TsType, ast_path: &mut AstNodePath<'r>) {
        VisitAstPath::visit_ts_type(&mut **self, node, ast_path)
    }

    fn visit_ts_type_alias_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeAliasDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_alias_decl(&mut **self, node, ast_path)
    }

    fn visit_ts_type_ann<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeAnn,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_ann(&mut **self, node, ast_path)
    }

    fn visit_ts_type_assertion<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeAssertion,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_assertion(&mut **self, node, ast_path)
    }

    fn visit_ts_type_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_element(&mut **self, node, ast_path)
    }

    fn visit_ts_type_elements<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsTypeElement],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_elements(&mut **self, node, ast_path)
    }

    fn visit_ts_type_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeLit,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_lit(&mut **self, node, ast_path)
    }

    fn visit_ts_type_operator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeOperator,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_operator(&mut **self, node, ast_path)
    }

    fn visit_ts_type_operator_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeOperatorOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_operator_op(&mut **self, node, ast_path)
    }

    fn visit_ts_type_param<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeParam,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_param(&mut **self, node, ast_path)
    }

    fn visit_ts_type_param_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeParamDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_param_decl(&mut **self, node, ast_path)
    }

    fn visit_ts_type_param_instantiation<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeParamInstantiation,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_param_instantiation(&mut **self, node, ast_path)
    }

    fn visit_ts_type_params<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsTypeParam],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_params(&mut **self, node, ast_path)
    }

    fn visit_ts_type_predicate<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypePredicate,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_predicate(&mut **self, node, ast_path)
    }

    fn visit_ts_type_query<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeQuery,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_query(&mut **self, node, ast_path)
    }

    fn visit_ts_type_query_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeQueryExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_query_expr(&mut **self, node, ast_path)
    }

    fn visit_ts_type_ref<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeRef,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_type_ref(&mut **self, node, ast_path)
    }

    fn visit_ts_types<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Box<TsType>],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_types(&mut **self, node, ast_path)
    }

    fn visit_ts_union_or_intersection_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsUnionOrIntersectionType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_union_or_intersection_type(&mut **self, node, ast_path)
    }

    fn visit_ts_union_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsUnionType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_ts_union_type(&mut **self, node, ast_path)
    }

    fn visit_unary_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnaryExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_unary_expr(&mut **self, node, ast_path)
    }

    fn visit_unary_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnaryOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_unary_op(&mut **self, node, ast_path)
    }

    fn visit_update_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UpdateExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_update_expr(&mut **self, node, ast_path)
    }

    fn visit_update_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UpdateOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_update_op(&mut **self, node, ast_path)
    }

    fn visit_using_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UsingDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_using_decl(&mut **self, node, ast_path)
    }

    fn visit_var_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_var_decl(&mut **self, node, ast_path)
    }

    fn visit_var_decl_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclKind,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_var_decl_kind(&mut **self, node, ast_path)
    }

    fn visit_var_decl_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclOrExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_var_decl_or_expr(&mut **self, node, ast_path)
    }

    fn visit_var_declarator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclarator,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_var_declarator(&mut **self, node, ast_path)
    }

    fn visit_var_declarators<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [VarDeclarator],
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_var_declarators(&mut **self, node, ast_path)
    }

    fn visit_while_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast WhileStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_while_stmt(&mut **self, node, ast_path)
    }

    fn visit_with_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast WithStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_with_stmt(&mut **self, node, ast_path)
    }

    fn visit_yield_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast YieldExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        VisitAstPath::visit_yield_expr(&mut **self, node, ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<A, B> VisitAstPath for ::swc_visit::Either<A, B>
where
    A: VisitAstPath,
    B: VisitAstPath,
{
    fn visit_accessibility<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Accessibility,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_accessibility(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_accessibility(self, node, ast_path)
            }
        }
    }

    fn visit_array_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrayLit,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_array_lit(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_array_lit(self, node, ast_path)
            }
        }
    }

    fn visit_array_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrayPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_array_pat(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_array_pat(self, node, ast_path)
            }
        }
    }

    fn visit_arrow_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrowExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_arrow_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_arrow_expr(self, node, ast_path)
            }
        }
    }

    fn visit_assign_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_assign_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_assign_expr(self, node, ast_path)
            }
        }
    }

    fn visit_assign_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_assign_op(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_assign_op(self, node, ast_path)
            }
        }
    }

    fn visit_assign_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_assign_pat(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_assign_pat(self, node, ast_path)
            }
        }
    }

    fn visit_assign_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignPatProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_assign_pat_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_assign_pat_prop(self, node, ast_path)
            }
        }
    }

    fn visit_assign_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_assign_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_assign_prop(self, node, ast_path)
            }
        }
    }

    fn visit_assign_target<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignTarget,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_assign_target(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_assign_target(self, node, ast_path)
            }
        }
    }

    fn visit_assign_target_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignTargetPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_assign_target_pat(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_assign_target_pat(self, node, ast_path)
            }
        }
    }

    fn visit_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_atoms::Atom,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_atom(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_atom(self, node, ast_path),
        }
    }

    fn visit_auto_accessor<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AutoAccessor,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_auto_accessor(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_auto_accessor(self, node, ast_path)
            }
        }
    }

    fn visit_await_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AwaitExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_await_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_await_expr(self, node, ast_path)
            }
        }
    }

    fn visit_big_int<'ast: 'r, 'r>(&mut self, node: &'ast BigInt, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_big_int(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_big_int(self, node, ast_path),
        }
    }

    fn visit_big_int_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BigIntValue,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_big_int_value(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_big_int_value(self, node, ast_path)
            }
        }
    }

    fn visit_bin_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BinExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_bin_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_bin_expr(self, node, ast_path),
        }
    }

    fn visit_binary_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BinaryOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_binary_op(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_binary_op(self, node, ast_path)
            }
        }
    }

    fn visit_binding_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BindingIdent,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_binding_ident(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_binding_ident(self, node, ast_path)
            }
        }
    }

    fn visit_block_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BlockStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_block_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_block_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_block_stmt_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BlockStmtOrExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_block_stmt_or_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_block_stmt_or_expr(self, node, ast_path)
            }
        }
    }

    fn visit_bool<'ast: 'r, 'r>(&mut self, node: &'ast Bool, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_bool(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_bool(self, node, ast_path),
        }
    }

    fn visit_break_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BreakStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_break_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_break_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_call_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CallExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_call_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_call_expr(self, node, ast_path)
            }
        }
    }

    fn visit_callee<'ast: 'r, 'r>(&mut self, node: &'ast Callee, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_callee(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_callee(self, node, ast_path),
        }
    }

    fn visit_catch_clause<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CatchClause,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_catch_clause(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_catch_clause(self, node, ast_path)
            }
        }
    }

    fn visit_class<'ast: 'r, 'r>(&mut self, node: &'ast Class, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_class(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_class(self, node, ast_path),
        }
    }

    fn visit_class_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_class_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_class_decl(self, node, ast_path)
            }
        }
    }

    fn visit_class_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_class_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_class_expr(self, node, ast_path)
            }
        }
    }

    fn visit_class_member<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassMember,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_class_member(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_class_member(self, node, ast_path)
            }
        }
    }

    fn visit_class_members<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ClassMember],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_class_members(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_class_members(self, node, ast_path)
            }
        }
    }

    fn visit_class_method<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassMethod,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_class_method(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_class_method(self, node, ast_path)
            }
        }
    }

    fn visit_class_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_class_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_class_prop(self, node, ast_path)
            }
        }
    }

    fn visit_computed_prop_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ComputedPropName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_computed_prop_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_computed_prop_name(self, node, ast_path)
            }
        }
    }

    fn visit_cond_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CondExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_cond_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_cond_expr(self, node, ast_path)
            }
        }
    }

    fn visit_constructor<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Constructor,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_constructor(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_constructor(self, node, ast_path)
            }
        }
    }

    fn visit_continue_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ContinueStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_continue_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_continue_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_debugger_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DebuggerStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_debugger_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_debugger_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_decl<'ast: 'r, 'r>(&mut self, node: &'ast Decl, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_decl(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_decl(self, node, ast_path),
        }
    }

    fn visit_decorator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Decorator,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_decorator(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_decorator(self, node, ast_path)
            }
        }
    }

    fn visit_decorators<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Decorator],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_decorators(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_decorators(self, node, ast_path)
            }
        }
    }

    fn visit_default_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DefaultDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_default_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_default_decl(self, node, ast_path)
            }
        }
    }

    fn visit_do_while_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DoWhileStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_do_while_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_do_while_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_empty_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast EmptyStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_empty_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_empty_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_es_version<'ast: 'r, 'r>(
        &mut self,
        node: &'ast EsVersion,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_es_version(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_es_version(self, node, ast_path)
            }
        }
    }

    fn visit_export_all<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportAll,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_export_all(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_export_all(self, node, ast_path)
            }
        }
    }

    fn visit_export_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_export_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_export_decl(self, node, ast_path)
            }
        }
    }

    fn visit_export_default_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_export_default_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_export_default_decl(self, node, ast_path)
            }
        }
    }

    fn visit_export_default_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_export_default_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_export_default_expr(self, node, ast_path)
            }
        }
    }

    fn visit_export_default_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_export_default_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_export_default_specifier(self, node, ast_path)
            }
        }
    }

    fn visit_export_named_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportNamedSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_export_named_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_export_named_specifier(self, node, ast_path)
            }
        }
    }

    fn visit_export_namespace_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportNamespaceSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_export_namespace_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_export_namespace_specifier(self, node, ast_path)
            }
        }
    }

    fn visit_export_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_export_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_export_specifier(self, node, ast_path)
            }
        }
    }

    fn visit_export_specifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ExportSpecifier],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_export_specifiers(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_export_specifiers(self, node, ast_path)
            }
        }
    }

    fn visit_expr<'ast: 'r, 'r>(&mut self, node: &'ast Expr, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_expr(self, node, ast_path),
        }
    }

    fn visit_expr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExprOrSpread,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_expr_or_spread(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_expr_or_spread(self, node, ast_path)
            }
        }
    }

    fn visit_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ExprOrSpread],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_expr_or_spreads(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_expr_or_spreads(self, node, ast_path)
            }
        }
    }

    fn visit_expr_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExprStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_expr_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_expr_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_exprs<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Box<Expr>],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_exprs(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_exprs(self, node, ast_path),
        }
    }

    fn visit_fn_decl<'ast: 'r, 'r>(&mut self, node: &'ast FnDecl, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_fn_decl(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_fn_decl(self, node, ast_path),
        }
    }

    fn visit_fn_expr<'ast: 'r, 'r>(&mut self, node: &'ast FnExpr, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_fn_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_fn_expr(self, node, ast_path),
        }
    }

    fn visit_for_head<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForHead,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_for_head(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_for_head(self, node, ast_path),
        }
    }

    fn visit_for_in_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForInStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_for_in_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_for_in_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_for_of_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForOfStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_for_of_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_for_of_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_for_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_for_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_for_stmt(self, node, ast_path),
        }
    }

    fn visit_function<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Function,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_function(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_function(self, node, ast_path),
        }
    }

    fn visit_getter_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast GetterProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_getter_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_getter_prop(self, node, ast_path)
            }
        }
    }

    fn visit_ident<'ast: 'r, 'r>(&mut self, node: &'ast Ident, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_ident(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_ident(self, node, ast_path),
        }
    }

    fn visit_ident_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IdentName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ident_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ident_name(self, node, ast_path)
            }
        }
    }

    fn visit_if_stmt<'ast: 'r, 'r>(&mut self, node: &'ast IfStmt, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_if_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_if_stmt(self, node, ast_path),
        }
    }

    fn visit_import<'ast: 'r, 'r>(&mut self, node: &'ast Import, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_import(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_import(self, node, ast_path),
        }
    }

    fn visit_import_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_import_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_import_decl(self, node, ast_path)
            }
        }
    }

    fn visit_import_default_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportDefaultSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_import_default_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_import_default_specifier(self, node, ast_path)
            }
        }
    }

    fn visit_import_named_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportNamedSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_import_named_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_import_named_specifier(self, node, ast_path)
            }
        }
    }

    fn visit_import_phase<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportPhase,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_import_phase(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_import_phase(self, node, ast_path)
            }
        }
    }

    fn visit_import_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_import_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_import_specifier(self, node, ast_path)
            }
        }
    }

    fn visit_import_specifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ImportSpecifier],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_import_specifiers(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_import_specifiers(self, node, ast_path)
            }
        }
    }

    fn visit_import_star_as_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportStarAsSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_import_star_as_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_import_star_as_specifier(self, node, ast_path)
            }
        }
    }

    fn visit_import_with<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportWith,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_import_with(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_import_with(self, node, ast_path)
            }
        }
    }

    fn visit_import_with_item<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportWithItem,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_import_with_item(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_import_with_item(self, node, ast_path)
            }
        }
    }

    fn visit_import_with_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ImportWithItem],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_import_with_items(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_import_with_items(self, node, ast_path)
            }
        }
    }

    fn visit_invalid<'ast: 'r, 'r>(&mut self, node: &'ast Invalid, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_invalid(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_invalid(self, node, ast_path),
        }
    }

    fn visit_jsx_attr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_jsx_attr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_jsx_attr(self, node, ast_path),
        }
    }

    fn visit_jsx_attr_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_attr_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_attr_name(self, node, ast_path)
            }
        }
    }

    fn visit_jsx_attr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrOrSpread,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_attr_or_spread(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_attr_or_spread(self, node, ast_path)
            }
        }
    }

    fn visit_jsx_attr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [JSXAttrOrSpread],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_attr_or_spreads(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_attr_or_spreads(self, node, ast_path)
            }
        }
    }

    fn visit_jsx_attr_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrValue,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_attr_value(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_attr_value(self, node, ast_path)
            }
        }
    }

    fn visit_jsx_closing_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXClosingElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_closing_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_closing_element(self, node, ast_path)
            }
        }
    }

    fn visit_jsx_closing_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXClosingFragment,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_closing_fragment(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_closing_fragment(self, node, ast_path)
            }
        }
    }

    fn visit_jsx_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_element(self, node, ast_path)
            }
        }
    }

    fn visit_jsx_element_child<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElementChild,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_element_child(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_element_child(self, node, ast_path)
            }
        }
    }

    fn visit_jsx_element_childs<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [JSXElementChild],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_element_childs(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_element_childs(self, node, ast_path)
            }
        }
    }

    fn visit_jsx_element_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElementName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_element_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_element_name(self, node, ast_path)
            }
        }
    }

    fn visit_jsx_empty_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXEmptyExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_empty_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_empty_expr(self, node, ast_path)
            }
        }
    }

    fn visit_jsx_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_jsx_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_jsx_expr(self, node, ast_path),
        }
    }

    fn visit_jsx_expr_container<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXExprContainer,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_expr_container(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_expr_container(self, node, ast_path)
            }
        }
    }

    fn visit_jsx_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXFragment,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_fragment(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_fragment(self, node, ast_path)
            }
        }
    }

    fn visit_jsx_member_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXMemberExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_member_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_member_expr(self, node, ast_path)
            }
        }
    }

    fn visit_jsx_namespaced_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXNamespacedName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_namespaced_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_namespaced_name(self, node, ast_path)
            }
        }
    }

    fn visit_jsx_object<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXObject,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_object(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_object(self, node, ast_path)
            }
        }
    }

    fn visit_jsx_opening_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXOpeningElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_opening_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_opening_element(self, node, ast_path)
            }
        }
    }

    fn visit_jsx_opening_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXOpeningFragment,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_opening_fragment(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_opening_fragment(self, node, ast_path)
            }
        }
    }

    fn visit_jsx_spread_child<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXSpreadChild,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_jsx_spread_child(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_jsx_spread_child(self, node, ast_path)
            }
        }
    }

    fn visit_jsx_text<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXText,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_jsx_text(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_jsx_text(self, node, ast_path),
        }
    }

    fn visit_key<'ast: 'r, 'r>(&mut self, node: &'ast Key, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_key(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_key(self, node, ast_path),
        }
    }

    fn visit_key_value_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast KeyValuePatProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_key_value_pat_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_key_value_pat_prop(self, node, ast_path)
            }
        }
    }

    fn visit_key_value_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast KeyValueProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_key_value_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_key_value_prop(self, node, ast_path)
            }
        }
    }

    fn visit_labeled_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast LabeledStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_labeled_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_labeled_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_lit<'ast: 'r, 'r>(&mut self, node: &'ast Lit, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_lit(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_lit(self, node, ast_path),
        }
    }

    fn visit_member_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MemberExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_member_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_member_expr(self, node, ast_path)
            }
        }
    }

    fn visit_member_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MemberProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_member_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_member_prop(self, node, ast_path)
            }
        }
    }

    fn visit_meta_prop_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MetaPropExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_meta_prop_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_meta_prop_expr(self, node, ast_path)
            }
        }
    }

    fn visit_meta_prop_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MetaPropKind,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_meta_prop_kind(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_meta_prop_kind(self, node, ast_path)
            }
        }
    }

    fn visit_method_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MethodKind,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_method_kind(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_method_kind(self, node, ast_path)
            }
        }
    }

    fn visit_method_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MethodProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_method_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_method_prop(self, node, ast_path)
            }
        }
    }

    fn visit_module<'ast: 'r, 'r>(&mut self, node: &'ast Module, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_module(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_module(self, node, ast_path),
        }
    }

    fn visit_module_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_module_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_module_decl(self, node, ast_path)
            }
        }
    }

    fn visit_module_export_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleExportName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_module_export_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_module_export_name(self, node, ast_path)
            }
        }
    }

    fn visit_module_item<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleItem,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_module_item(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_module_item(self, node, ast_path)
            }
        }
    }

    fn visit_module_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ModuleItem],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_module_items(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_module_items(self, node, ast_path)
            }
        }
    }

    fn visit_named_export<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NamedExport,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_named_export(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_named_export(self, node, ast_path)
            }
        }
    }

    fn visit_new_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NewExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_new_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_new_expr(self, node, ast_path),
        }
    }

    fn visit_null<'ast: 'r, 'r>(&mut self, node: &'ast Null, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_null(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_null(self, node, ast_path),
        }
    }

    fn visit_number<'ast: 'r, 'r>(&mut self, node: &'ast Number, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_number(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_number(self, node, ast_path),
        }
    }

    fn visit_object_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectLit,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_object_lit(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_object_lit(self, node, ast_path)
            }
        }
    }

    fn visit_object_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_object_pat(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_object_pat(self, node, ast_path)
            }
        }
    }

    fn visit_object_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectPatProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_object_pat_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_object_pat_prop(self, node, ast_path)
            }
        }
    }

    fn visit_object_pat_props<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ObjectPatProp],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_object_pat_props(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_object_pat_props(self, node, ast_path)
            }
        }
    }

    fn visit_opt_accessibility<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Accessibility>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_accessibility(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_accessibility(self, node, ast_path)
            }
        }
    }

    fn visit_opt_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_atoms::Atom>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_opt_atom(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_opt_atom(self, node, ast_path),
        }
    }

    fn visit_opt_block_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<BlockStmt>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_block_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_block_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_opt_call<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptCall,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_opt_call(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_opt_call(self, node, ast_path),
        }
    }

    fn visit_opt_catch_clause<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<CatchClause>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_catch_clause(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_catch_clause(self, node, ast_path)
            }
        }
    }

    fn visit_opt_chain_base<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptChainBase,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_chain_base(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_chain_base(self, node, ast_path)
            }
        }
    }

    fn visit_opt_chain_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptChainExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_chain_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_chain_expr(self, node, ast_path)
            }
        }
    }

    fn visit_opt_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Expr>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_opt_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_opt_expr(self, node, ast_path),
        }
    }

    fn visit_opt_expr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<ExprOrSpread>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_expr_or_spread(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_expr_or_spread(self, node, ast_path)
            }
        }
    }

    fn visit_opt_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Vec<ExprOrSpread>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_expr_or_spreads(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_expr_or_spreads(self, node, ast_path)
            }
        }
    }

    fn visit_opt_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Ident>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_opt_ident(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_ident(self, node, ast_path)
            }
        }
    }

    fn visit_opt_jsx_attr_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<JSXAttrValue>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_jsx_attr_value(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_jsx_attr_value(self, node, ast_path)
            }
        }
    }

    fn visit_opt_jsx_closing_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<JSXClosingElement>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_jsx_closing_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_jsx_closing_element(self, node, ast_path)
            }
        }
    }

    fn visit_opt_module_export_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<ModuleExportName>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_module_export_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_module_export_name(self, node, ast_path)
            }
        }
    }

    fn visit_opt_module_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Vec<ModuleItem>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_module_items(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_module_items(self, node, ast_path)
            }
        }
    }

    fn visit_opt_object_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<ObjectLit>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_object_lit(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_object_lit(self, node, ast_path)
            }
        }
    }

    fn visit_opt_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Pat>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_opt_pat(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_opt_pat(self, node, ast_path),
        }
    }

    fn visit_opt_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_common::Span>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_opt_span(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_opt_span(self, node, ast_path),
        }
    }

    fn visit_opt_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Stmt>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_opt_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_opt_stmt(self, node, ast_path),
        }
    }

    fn visit_opt_str<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Str>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_opt_str(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_opt_str(self, node, ast_path),
        }
    }

    fn visit_opt_true_plus_minus<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<TruePlusMinus>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_true_plus_minus(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_true_plus_minus(self, node, ast_path)
            }
        }
    }

    fn visit_opt_ts_entity_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<TsEntityName>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_ts_entity_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_ts_entity_name(self, node, ast_path)
            }
        }
    }

    fn visit_opt_ts_namespace_body<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<TsNamespaceBody>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_ts_namespace_body(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_ts_namespace_body(self, node, ast_path)
            }
        }
    }

    fn visit_opt_ts_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<TsType>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_ts_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_ts_type(self, node, ast_path)
            }
        }
    }

    fn visit_opt_ts_type_ann<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<TsTypeAnn>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_ts_type_ann(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_ts_type_ann(self, node, ast_path)
            }
        }
    }

    fn visit_opt_ts_type_param_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<TsTypeParamDecl>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_ts_type_param_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_ts_type_param_decl(self, node, ast_path)
            }
        }
    }

    fn visit_opt_ts_type_param_instantiation<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<TsTypeParamInstantiation>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_ts_type_param_instantiation(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_ts_type_param_instantiation(self, node, ast_path)
            }
        }
    }

    fn visit_opt_var_decl_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<VarDeclOrExpr>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_var_decl_or_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_var_decl_or_expr(self, node, ast_path)
            }
        }
    }

    fn visit_opt_vec_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Option<ExprOrSpread>],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_vec_expr_or_spreads(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_vec_expr_or_spreads(self, node, ast_path)
            }
        }
    }

    fn visit_opt_vec_pats<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Option<Pat>],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_opt_vec_pats(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_opt_vec_pats(self, node, ast_path)
            }
        }
    }

    fn visit_param<'ast: 'r, 'r>(&mut self, node: &'ast Param, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_param(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_param(self, node, ast_path),
        }
    }

    fn visit_param_or_ts_param_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ParamOrTsParamProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_param_or_ts_param_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_param_or_ts_param_prop(self, node, ast_path)
            }
        }
    }

    fn visit_param_or_ts_param_props<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ParamOrTsParamProp],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_param_or_ts_param_props(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_param_or_ts_param_props(self, node, ast_path)
            }
        }
    }

    fn visit_params<'ast: 'r, 'r>(&mut self, node: &'ast [Param], ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_params(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_params(self, node, ast_path),
        }
    }

    fn visit_paren_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ParenExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_paren_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_paren_expr(self, node, ast_path)
            }
        }
    }

    fn visit_pat<'ast: 'r, 'r>(&mut self, node: &'ast Pat, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_pat(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_pat(self, node, ast_path),
        }
    }

    fn visit_pats<'ast: 'r, 'r>(&mut self, node: &'ast [Pat], ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_pats(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_pats(self, node, ast_path),
        }
    }

    fn visit_private_method<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateMethod,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_private_method(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_private_method(self, node, ast_path)
            }
        }
    }

    fn visit_private_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_private_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_private_name(self, node, ast_path)
            }
        }
    }

    fn visit_private_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_private_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_private_prop(self, node, ast_path)
            }
        }
    }

    fn visit_program<'ast: 'r, 'r>(&mut self, node: &'ast Program, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_program(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_program(self, node, ast_path),
        }
    }

    fn visit_prop<'ast: 'r, 'r>(&mut self, node: &'ast Prop, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_prop(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_prop(self, node, ast_path),
        }
    }

    fn visit_prop_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PropName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_prop_name(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_prop_name(self, node, ast_path)
            }
        }
    }

    fn visit_prop_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PropOrSpread,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_prop_or_spread(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_prop_or_spread(self, node, ast_path)
            }
        }
    }

    fn visit_prop_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [PropOrSpread],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_prop_or_spreads(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_prop_or_spreads(self, node, ast_path)
            }
        }
    }

    fn visit_regex<'ast: 'r, 'r>(&mut self, node: &'ast Regex, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_regex(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_regex(self, node, ast_path),
        }
    }

    fn visit_reserved_unused<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ReservedUnused,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_reserved_unused(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_reserved_unused(self, node, ast_path)
            }
        }
    }

    fn visit_rest_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast RestPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_rest_pat(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_rest_pat(self, node, ast_path),
        }
    }

    fn visit_return_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ReturnStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_return_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_return_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_script<'ast: 'r, 'r>(&mut self, node: &'ast Script, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_script(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_script(self, node, ast_path),
        }
    }

    fn visit_seq_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SeqExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_seq_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_seq_expr(self, node, ast_path),
        }
    }

    fn visit_setter_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SetterProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_setter_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_setter_prop(self, node, ast_path)
            }
        }
    }

    fn visit_simple_assign_target<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SimpleAssignTarget,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_simple_assign_target(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_simple_assign_target(self, node, ast_path)
            }
        }
    }

    fn visit_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::Span,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_span(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_span(self, node, ast_path),
        }
    }

    fn visit_spread_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SpreadElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_spread_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_spread_element(self, node, ast_path)
            }
        }
    }

    fn visit_static_block<'ast: 'r, 'r>(
        &mut self,
        node: &'ast StaticBlock,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_static_block(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_static_block(self, node, ast_path)
            }
        }
    }

    fn visit_stmt<'ast: 'r, 'r>(&mut self, node: &'ast Stmt, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_stmt(self, node, ast_path),
        }
    }

    fn visit_stmts<'ast: 'r, 'r>(&mut self, node: &'ast [Stmt], ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_stmts(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_stmts(self, node, ast_path),
        }
    }

    fn visit_str<'ast: 'r, 'r>(&mut self, node: &'ast Str, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_str(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_str(self, node, ast_path),
        }
    }

    fn visit_super<'ast: 'r, 'r>(&mut self, node: &'ast Super, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_super(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_super(self, node, ast_path),
        }
    }

    fn visit_super_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SuperProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_super_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_super_prop(self, node, ast_path)
            }
        }
    }

    fn visit_super_prop_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SuperPropExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_super_prop_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_super_prop_expr(self, node, ast_path)
            }
        }
    }

    fn visit_switch_case<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SwitchCase,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_switch_case(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_switch_case(self, node, ast_path)
            }
        }
    }

    fn visit_switch_cases<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [SwitchCase],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_switch_cases(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_switch_cases(self, node, ast_path)
            }
        }
    }

    fn visit_switch_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SwitchStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_switch_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_switch_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_syntax_context<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::SyntaxContext,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_syntax_context(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_syntax_context(self, node, ast_path)
            }
        }
    }

    fn visit_tagged_tpl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TaggedTpl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_tagged_tpl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_tagged_tpl(self, node, ast_path)
            }
        }
    }

    fn visit_this_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ThisExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_this_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_this_expr(self, node, ast_path)
            }
        }
    }

    fn visit_throw_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ThrowStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_throw_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_throw_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_tpl<'ast: 'r, 'r>(&mut self, node: &'ast Tpl, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_tpl(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_tpl(self, node, ast_path),
        }
    }

    fn visit_tpl_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TplElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_tpl_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_tpl_element(self, node, ast_path)
            }
        }
    }

    fn visit_tpl_elements<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TplElement],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_tpl_elements(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_tpl_elements(self, node, ast_path)
            }
        }
    }

    fn visit_true_plus_minus<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TruePlusMinus,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_true_plus_minus(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_true_plus_minus(self, node, ast_path)
            }
        }
    }

    fn visit_try_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TryStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_try_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_try_stmt(self, node, ast_path),
        }
    }

    fn visit_ts_array_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsArrayType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_array_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_array_type(self, node, ast_path)
            }
        }
    }

    fn visit_ts_as_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsAsExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_as_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_as_expr(self, node, ast_path)
            }
        }
    }

    fn visit_ts_call_signature_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsCallSignatureDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_call_signature_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_call_signature_decl(self, node, ast_path)
            }
        }
    }

    fn visit_ts_conditional_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsConditionalType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_conditional_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_conditional_type(self, node, ast_path)
            }
        }
    }

    fn visit_ts_const_assertion<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsConstAssertion,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_const_assertion(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_const_assertion(self, node, ast_path)
            }
        }
    }

    fn visit_ts_construct_signature_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsConstructSignatureDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_construct_signature_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_construct_signature_decl(self, node, ast_path)
            }
        }
    }

    fn visit_ts_constructor_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsConstructorType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_constructor_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_constructor_type(self, node, ast_path)
            }
        }
    }

    fn visit_ts_entity_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsEntityName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_entity_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_entity_name(self, node, ast_path)
            }
        }
    }

    fn visit_ts_enum_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsEnumDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_enum_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_enum_decl(self, node, ast_path)
            }
        }
    }

    fn visit_ts_enum_member<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsEnumMember,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_enum_member(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_enum_member(self, node, ast_path)
            }
        }
    }

    fn visit_ts_enum_member_id<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsEnumMemberId,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_enum_member_id(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_enum_member_id(self, node, ast_path)
            }
        }
    }

    fn visit_ts_enum_members<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsEnumMember],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_enum_members(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_enum_members(self, node, ast_path)
            }
        }
    }

    fn visit_ts_export_assignment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsExportAssignment,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_export_assignment(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_export_assignment(self, node, ast_path)
            }
        }
    }

    fn visit_ts_expr_with_type_args<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsExprWithTypeArgs,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_expr_with_type_args(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_expr_with_type_args(self, node, ast_path)
            }
        }
    }

    fn visit_ts_expr_with_type_argss<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsExprWithTypeArgs],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_expr_with_type_argss(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_expr_with_type_argss(self, node, ast_path)
            }
        }
    }

    fn visit_ts_external_module_ref<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsExternalModuleRef,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_external_module_ref(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_external_module_ref(self, node, ast_path)
            }
        }
    }

    fn visit_ts_fn_or_constructor_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsFnOrConstructorType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_fn_or_constructor_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_fn_or_constructor_type(self, node, ast_path)
            }
        }
    }

    fn visit_ts_fn_param<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsFnParam,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_fn_param(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_fn_param(self, node, ast_path)
            }
        }
    }

    fn visit_ts_fn_params<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsFnParam],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_fn_params(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_fn_params(self, node, ast_path)
            }
        }
    }

    fn visit_ts_fn_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsFnType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_fn_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_fn_type(self, node, ast_path)
            }
        }
    }

    fn visit_ts_getter_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsGetterSignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_getter_signature(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_getter_signature(self, node, ast_path)
            }
        }
    }

    fn visit_ts_import_equals_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsImportEqualsDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_import_equals_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_import_equals_decl(self, node, ast_path)
            }
        }
    }

    fn visit_ts_import_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsImportType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_import_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_import_type(self, node, ast_path)
            }
        }
    }

    fn visit_ts_index_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsIndexSignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_index_signature(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_index_signature(self, node, ast_path)
            }
        }
    }

    fn visit_ts_indexed_access_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsIndexedAccessType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_indexed_access_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_indexed_access_type(self, node, ast_path)
            }
        }
    }

    fn visit_ts_infer_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsInferType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_infer_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_infer_type(self, node, ast_path)
            }
        }
    }

    fn visit_ts_instantiation<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsInstantiation,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_instantiation(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_instantiation(self, node, ast_path)
            }
        }
    }

    fn visit_ts_interface_body<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsInterfaceBody,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_interface_body(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_interface_body(self, node, ast_path)
            }
        }
    }

    fn visit_ts_interface_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsInterfaceDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_interface_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_interface_decl(self, node, ast_path)
            }
        }
    }

    fn visit_ts_intersection_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsIntersectionType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_intersection_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_intersection_type(self, node, ast_path)
            }
        }
    }

    fn visit_ts_keyword_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsKeywordType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_keyword_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_keyword_type(self, node, ast_path)
            }
        }
    }

    fn visit_ts_keyword_type_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsKeywordTypeKind,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_keyword_type_kind(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_keyword_type_kind(self, node, ast_path)
            }
        }
    }

    fn visit_ts_lit<'ast: 'r, 'r>(&mut self, node: &'ast TsLit, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_ts_lit(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_ts_lit(self, node, ast_path),
        }
    }

    fn visit_ts_lit_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsLitType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_lit_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_lit_type(self, node, ast_path)
            }
        }
    }

    fn visit_ts_mapped_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsMappedType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_mapped_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_mapped_type(self, node, ast_path)
            }
        }
    }

    fn visit_ts_method_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsMethodSignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_method_signature(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_method_signature(self, node, ast_path)
            }
        }
    }

    fn visit_ts_module_block<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsModuleBlock,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_module_block(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_module_block(self, node, ast_path)
            }
        }
    }

    fn visit_ts_module_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsModuleDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_module_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_module_decl(self, node, ast_path)
            }
        }
    }

    fn visit_ts_module_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsModuleName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_module_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_module_name(self, node, ast_path)
            }
        }
    }

    fn visit_ts_module_ref<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsModuleRef,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_module_ref(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_module_ref(self, node, ast_path)
            }
        }
    }

    fn visit_ts_namespace_body<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsNamespaceBody,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_namespace_body(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_namespace_body(self, node, ast_path)
            }
        }
    }

    fn visit_ts_namespace_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsNamespaceDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_namespace_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_namespace_decl(self, node, ast_path)
            }
        }
    }

    fn visit_ts_namespace_export_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsNamespaceExportDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_namespace_export_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_namespace_export_decl(self, node, ast_path)
            }
        }
    }

    fn visit_ts_non_null_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsNonNullExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_non_null_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_non_null_expr(self, node, ast_path)
            }
        }
    }

    fn visit_ts_optional_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsOptionalType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_optional_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_optional_type(self, node, ast_path)
            }
        }
    }

    fn visit_ts_param_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsParamProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_param_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_param_prop(self, node, ast_path)
            }
        }
    }

    fn visit_ts_param_prop_param<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsParamPropParam,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_param_prop_param(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_param_prop_param(self, node, ast_path)
            }
        }
    }

    fn visit_ts_parenthesized_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsParenthesizedType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_parenthesized_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_parenthesized_type(self, node, ast_path)
            }
        }
    }

    fn visit_ts_property_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsPropertySignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_property_signature(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_property_signature(self, node, ast_path)
            }
        }
    }

    fn visit_ts_qualified_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsQualifiedName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_qualified_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_qualified_name(self, node, ast_path)
            }
        }
    }

    fn visit_ts_rest_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsRestType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_rest_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_rest_type(self, node, ast_path)
            }
        }
    }

    fn visit_ts_satisfies_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsSatisfiesExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_satisfies_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_satisfies_expr(self, node, ast_path)
            }
        }
    }

    fn visit_ts_setter_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsSetterSignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_setter_signature(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_setter_signature(self, node, ast_path)
            }
        }
    }

    fn visit_ts_this_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsThisType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_this_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_this_type(self, node, ast_path)
            }
        }
    }

    fn visit_ts_this_type_or_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsThisTypeOrIdent,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_this_type_or_ident(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_this_type_or_ident(self, node, ast_path)
            }
        }
    }

    fn visit_ts_tpl_lit_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTplLitType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_tpl_lit_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_tpl_lit_type(self, node, ast_path)
            }
        }
    }

    fn visit_ts_tuple_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTupleElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_tuple_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_tuple_element(self, node, ast_path)
            }
        }
    }

    fn visit_ts_tuple_elements<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsTupleElement],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_tuple_elements(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_tuple_elements(self, node, ast_path)
            }
        }
    }

    fn visit_ts_tuple_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTupleType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_tuple_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_tuple_type(self, node, ast_path)
            }
        }
    }

    fn visit_ts_type<'ast: 'r, 'r>(&mut self, node: &'ast TsType, ast_path: &mut AstNodePath<'r>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_ts_type(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_ts_type(self, node, ast_path),
        }
    }

    fn visit_ts_type_alias_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeAliasDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_type_alias_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_type_alias_decl(self, node, ast_path)
            }
        }
    }

    fn visit_ts_type_ann<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeAnn,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_type_ann(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_type_ann(self, node, ast_path)
            }
        }
    }

    fn visit_ts_type_assertion<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeAssertion,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_type_assertion(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_type_assertion(self, node, ast_path)
            }
        }
    }

    fn visit_ts_type_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_type_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_type_element(self, node, ast_path)
            }
        }
    }

    fn visit_ts_type_elements<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsTypeElement],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_type_elements(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_type_elements(self, node, ast_path)
            }
        }
    }

    fn visit_ts_type_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeLit,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_type_lit(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_type_lit(self, node, ast_path)
            }
        }
    }

    fn visit_ts_type_operator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeOperator,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_type_operator(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_type_operator(self, node, ast_path)
            }
        }
    }

    fn visit_ts_type_operator_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeOperatorOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_type_operator_op(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_type_operator_op(self, node, ast_path)
            }
        }
    }

    fn visit_ts_type_param<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeParam,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_type_param(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_type_param(self, node, ast_path)
            }
        }
    }

    fn visit_ts_type_param_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeParamDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_type_param_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_type_param_decl(self, node, ast_path)
            }
        }
    }

    fn visit_ts_type_param_instantiation<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeParamInstantiation,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_type_param_instantiation(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_type_param_instantiation(self, node, ast_path)
            }
        }
    }

    fn visit_ts_type_params<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsTypeParam],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_type_params(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_type_params(self, node, ast_path)
            }
        }
    }

    fn visit_ts_type_predicate<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypePredicate,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_type_predicate(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_type_predicate(self, node, ast_path)
            }
        }
    }

    fn visit_ts_type_query<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeQuery,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_type_query(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_type_query(self, node, ast_path)
            }
        }
    }

    fn visit_ts_type_query_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeQueryExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_type_query_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_type_query_expr(self, node, ast_path)
            }
        }
    }

    fn visit_ts_type_ref<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeRef,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_type_ref(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_type_ref(self, node, ast_path)
            }
        }
    }

    fn visit_ts_types<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Box<TsType>],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_ts_types(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_ts_types(self, node, ast_path),
        }
    }

    fn visit_ts_union_or_intersection_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsUnionOrIntersectionType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_union_or_intersection_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_union_or_intersection_type(self, node, ast_path)
            }
        }
    }

    fn visit_ts_union_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsUnionType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_ts_union_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_ts_union_type(self, node, ast_path)
            }
        }
    }

    fn visit_unary_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnaryExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_unary_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_unary_expr(self, node, ast_path)
            }
        }
    }

    fn visit_unary_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnaryOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_unary_op(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_unary_op(self, node, ast_path),
        }
    }

    fn visit_update_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UpdateExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_update_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_update_expr(self, node, ast_path)
            }
        }
    }

    fn visit_update_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UpdateOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_update_op(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_update_op(self, node, ast_path)
            }
        }
    }

    fn visit_using_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UsingDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_using_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_using_decl(self, node, ast_path)
            }
        }
    }

    fn visit_var_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_var_decl(self, node, ast_path),
            swc_visit::Either::Right(visitor) => VisitAstPath::visit_var_decl(self, node, ast_path),
        }
    }

    fn visit_var_decl_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclKind,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_var_decl_kind(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_var_decl_kind(self, node, ast_path)
            }
        }
    }

    fn visit_var_decl_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclOrExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_var_decl_or_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_var_decl_or_expr(self, node, ast_path)
            }
        }
    }

    fn visit_var_declarator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclarator,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_var_declarator(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_var_declarator(self, node, ast_path)
            }
        }
    }

    fn visit_var_declarators<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [VarDeclarator],
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_var_declarators(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_var_declarators(self, node, ast_path)
            }
        }
    }

    fn visit_while_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast WhileStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_while_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_while_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_with_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast WithStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => VisitAstPath::visit_with_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_with_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_yield_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast YieldExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitAstPath::visit_yield_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitAstPath::visit_yield_expr(self, node, ast_path)
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> VisitAstPath for ::swc_visit::Optional<V>
where
    V: VisitAstPath,
{
    fn visit_accessibility<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Accessibility,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_accessibility(self, node, ast_path)
        } else {
        }
    }

    fn visit_array_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrayLit,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_array_lit(self, node, ast_path)
        } else {
        }
    }

    fn visit_array_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrayPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_array_pat(self, node, ast_path)
        } else {
        }
    }

    fn visit_arrow_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ArrowExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_arrow_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_assign_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_assign_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_assign_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_assign_op(self, node, ast_path)
        } else {
        }
    }

    fn visit_assign_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_assign_pat(self, node, ast_path)
        } else {
        }
    }

    fn visit_assign_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignPatProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_assign_pat_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_assign_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_assign_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_assign_target<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignTarget,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_assign_target(self, node, ast_path)
        } else {
        }
    }

    fn visit_assign_target_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AssignTargetPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_assign_target_pat(self, node, ast_path)
        } else {
        }
    }

    fn visit_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_atoms::Atom,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_atom(self, node, ast_path)
        } else {
        }
    }

    fn visit_auto_accessor<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AutoAccessor,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_auto_accessor(self, node, ast_path)
        } else {
        }
    }

    fn visit_await_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast AwaitExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_await_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_big_int<'ast: 'r, 'r>(&mut self, node: &'ast BigInt, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_big_int(self, node, ast_path)
        } else {
        }
    }

    fn visit_big_int_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BigIntValue,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_big_int_value(self, node, ast_path)
        } else {
        }
    }

    fn visit_bin_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BinExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_bin_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_binary_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BinaryOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_binary_op(self, node, ast_path)
        } else {
        }
    }

    fn visit_binding_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BindingIdent,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_binding_ident(self, node, ast_path)
        } else {
        }
    }

    fn visit_block_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BlockStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_block_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_block_stmt_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BlockStmtOrExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_block_stmt_or_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_bool<'ast: 'r, 'r>(&mut self, node: &'ast Bool, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_bool(self, node, ast_path)
        } else {
        }
    }

    fn visit_break_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast BreakStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_break_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_call_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CallExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_call_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_callee<'ast: 'r, 'r>(&mut self, node: &'ast Callee, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_callee(self, node, ast_path)
        } else {
        }
    }

    fn visit_catch_clause<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CatchClause,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_catch_clause(self, node, ast_path)
        } else {
        }
    }

    fn visit_class<'ast: 'r, 'r>(&mut self, node: &'ast Class, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_class(self, node, ast_path)
        } else {
        }
    }

    fn visit_class_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_class_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_class_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_class_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_class_member<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassMember,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_class_member(self, node, ast_path)
        } else {
        }
    }

    fn visit_class_members<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ClassMember],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_class_members(self, node, ast_path)
        } else {
        }
    }

    fn visit_class_method<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassMethod,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_class_method(self, node, ast_path)
        } else {
        }
    }

    fn visit_class_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ClassProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_class_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_computed_prop_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ComputedPropName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_computed_prop_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_cond_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast CondExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_cond_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_constructor<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Constructor,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_constructor(self, node, ast_path)
        } else {
        }
    }

    fn visit_continue_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ContinueStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_continue_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_debugger_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DebuggerStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_debugger_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_decl<'ast: 'r, 'r>(&mut self, node: &'ast Decl, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_decorator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Decorator,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_decorator(self, node, ast_path)
        } else {
        }
    }

    fn visit_decorators<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Decorator],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_decorators(self, node, ast_path)
        } else {
        }
    }

    fn visit_default_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DefaultDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_default_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_do_while_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast DoWhileStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_do_while_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_empty_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast EmptyStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_empty_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_es_version<'ast: 'r, 'r>(
        &mut self,
        node: &'ast EsVersion,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_es_version(self, node, ast_path)
        } else {
        }
    }

    fn visit_export_all<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportAll,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_export_all(self, node, ast_path)
        } else {
        }
    }

    fn visit_export_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_export_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_export_default_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_export_default_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_export_default_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_export_default_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_export_default_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportDefaultSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_export_default_specifier(self, node, ast_path)
        } else {
        }
    }

    fn visit_export_named_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportNamedSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_export_named_specifier(self, node, ast_path)
        } else {
        }
    }

    fn visit_export_namespace_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportNamespaceSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_export_namespace_specifier(self, node, ast_path)
        } else {
        }
    }

    fn visit_export_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExportSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_export_specifier(self, node, ast_path)
        } else {
        }
    }

    fn visit_export_specifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ExportSpecifier],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_export_specifiers(self, node, ast_path)
        } else {
        }
    }

    fn visit_expr<'ast: 'r, 'r>(&mut self, node: &'ast Expr, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_expr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExprOrSpread,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_expr_or_spread(self, node, ast_path)
        } else {
        }
    }

    fn visit_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ExprOrSpread],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_expr_or_spreads(self, node, ast_path)
        } else {
        }
    }

    fn visit_expr_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ExprStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_expr_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_exprs<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Box<Expr>],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_exprs(self, node, ast_path)
        } else {
        }
    }

    fn visit_fn_decl<'ast: 'r, 'r>(&mut self, node: &'ast FnDecl, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_fn_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_fn_expr<'ast: 'r, 'r>(&mut self, node: &'ast FnExpr, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_fn_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_for_head<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForHead,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_for_head(self, node, ast_path)
        } else {
        }
    }

    fn visit_for_in_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForInStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_for_in_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_for_of_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForOfStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_for_of_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_for_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ForStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_for_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_function<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Function,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_function(self, node, ast_path)
        } else {
        }
    }

    fn visit_getter_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast GetterProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_getter_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_ident<'ast: 'r, 'r>(&mut self, node: &'ast Ident, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_ident(self, node, ast_path)
        } else {
        }
    }

    fn visit_ident_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast IdentName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ident_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_if_stmt<'ast: 'r, 'r>(&mut self, node: &'ast IfStmt, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_if_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_import<'ast: 'r, 'r>(&mut self, node: &'ast Import, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_import(self, node, ast_path)
        } else {
        }
    }

    fn visit_import_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_import_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_import_default_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportDefaultSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_import_default_specifier(self, node, ast_path)
        } else {
        }
    }

    fn visit_import_named_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportNamedSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_import_named_specifier(self, node, ast_path)
        } else {
        }
    }

    fn visit_import_phase<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportPhase,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_import_phase(self, node, ast_path)
        } else {
        }
    }

    fn visit_import_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_import_specifier(self, node, ast_path)
        } else {
        }
    }

    fn visit_import_specifiers<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ImportSpecifier],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_import_specifiers(self, node, ast_path)
        } else {
        }
    }

    fn visit_import_star_as_specifier<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportStarAsSpecifier,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_import_star_as_specifier(self, node, ast_path)
        } else {
        }
    }

    fn visit_import_with<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportWith,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_import_with(self, node, ast_path)
        } else {
        }
    }

    fn visit_import_with_item<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ImportWithItem,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_import_with_item(self, node, ast_path)
        } else {
        }
    }

    fn visit_import_with_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ImportWithItem],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_import_with_items(self, node, ast_path)
        } else {
        }
    }

    fn visit_invalid<'ast: 'r, 'r>(&mut self, node: &'ast Invalid, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_invalid(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_attr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_attr(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_attr_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_attr_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_attr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrOrSpread,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_attr_or_spread(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_attr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [JSXAttrOrSpread],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_attr_or_spreads(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_attr_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXAttrValue,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_attr_value(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_closing_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXClosingElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_closing_element(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_closing_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXClosingFragment,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_closing_fragment(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_element(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_element_child<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElementChild,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_element_child(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_element_childs<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [JSXElementChild],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_element_childs(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_element_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXElementName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_element_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_empty_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXEmptyExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_empty_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_expr_container<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXExprContainer,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_expr_container(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXFragment,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_fragment(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_member_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXMemberExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_member_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_namespaced_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXNamespacedName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_namespaced_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_object<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXObject,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_object(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_opening_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXOpeningElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_opening_element(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_opening_fragment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXOpeningFragment,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_opening_fragment(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_spread_child<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXSpreadChild,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_spread_child(self, node, ast_path)
        } else {
        }
    }

    fn visit_jsx_text<'ast: 'r, 'r>(
        &mut self,
        node: &'ast JSXText,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_jsx_text(self, node, ast_path)
        } else {
        }
    }

    fn visit_key<'ast: 'r, 'r>(&mut self, node: &'ast Key, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_key(self, node, ast_path)
        } else {
        }
    }

    fn visit_key_value_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast KeyValuePatProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_key_value_pat_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_key_value_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast KeyValueProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_key_value_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_labeled_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast LabeledStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_labeled_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_lit<'ast: 'r, 'r>(&mut self, node: &'ast Lit, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_lit(self, node, ast_path)
        } else {
        }
    }

    fn visit_member_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MemberExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_member_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_member_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MemberProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_member_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_meta_prop_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MetaPropExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_meta_prop_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_meta_prop_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MetaPropKind,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_meta_prop_kind(self, node, ast_path)
        } else {
        }
    }

    fn visit_method_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MethodKind,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_method_kind(self, node, ast_path)
        } else {
        }
    }

    fn visit_method_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast MethodProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_method_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_module<'ast: 'r, 'r>(&mut self, node: &'ast Module, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_module(self, node, ast_path)
        } else {
        }
    }

    fn visit_module_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_module_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_module_export_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleExportName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_module_export_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_module_item<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ModuleItem,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_module_item(self, node, ast_path)
        } else {
        }
    }

    fn visit_module_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ModuleItem],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_module_items(self, node, ast_path)
        } else {
        }
    }

    fn visit_named_export<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NamedExport,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_named_export(self, node, ast_path)
        } else {
        }
    }

    fn visit_new_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast NewExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_new_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_null<'ast: 'r, 'r>(&mut self, node: &'ast Null, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_null(self, node, ast_path)
        } else {
        }
    }

    fn visit_number<'ast: 'r, 'r>(&mut self, node: &'ast Number, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_number(self, node, ast_path)
        } else {
        }
    }

    fn visit_object_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectLit,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_object_lit(self, node, ast_path)
        } else {
        }
    }

    fn visit_object_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_object_pat(self, node, ast_path)
        } else {
        }
    }

    fn visit_object_pat_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ObjectPatProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_object_pat_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_object_pat_props<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ObjectPatProp],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_object_pat_props(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_accessibility<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Accessibility>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_accessibility(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_atom<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_atoms::Atom>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_atom(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_block_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<BlockStmt>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_block_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_call<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptCall,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_call(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_catch_clause<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<CatchClause>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_catch_clause(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_chain_base<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptChainBase,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_chain_base(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_chain_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast OptChainExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_chain_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Expr>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_expr_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<ExprOrSpread>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_expr_or_spread(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Vec<ExprOrSpread>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_expr_or_spreads(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Ident>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_ident(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_jsx_attr_value<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<JSXAttrValue>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_jsx_attr_value(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_jsx_closing_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<JSXClosingElement>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_jsx_closing_element(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_module_export_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<ModuleExportName>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_module_export_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_module_items<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Vec<ModuleItem>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_module_items(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_object_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<ObjectLit>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_object_lit(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Pat>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_pat(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<swc_common::Span>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_span(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Stmt>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_str<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<Str>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_str(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_true_plus_minus<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<TruePlusMinus>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_true_plus_minus(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_ts_entity_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<TsEntityName>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_ts_entity_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_ts_namespace_body<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<TsNamespaceBody>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_ts_namespace_body(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_ts_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<TsType>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_ts_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_ts_type_ann<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<TsTypeAnn>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_ts_type_ann(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_ts_type_param_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<TsTypeParamDecl>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_ts_type_param_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_ts_type_param_instantiation<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<Box<TsTypeParamInstantiation>>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_ts_type_param_instantiation(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_var_decl_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast Option<VarDeclOrExpr>,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_var_decl_or_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_vec_expr_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Option<ExprOrSpread>],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_vec_expr_or_spreads(self, node, ast_path)
        } else {
        }
    }

    fn visit_opt_vec_pats<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Option<Pat>],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_opt_vec_pats(self, node, ast_path)
        } else {
        }
    }

    fn visit_param<'ast: 'r, 'r>(&mut self, node: &'ast Param, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_param(self, node, ast_path)
        } else {
        }
    }

    fn visit_param_or_ts_param_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ParamOrTsParamProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_param_or_ts_param_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_param_or_ts_param_props<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [ParamOrTsParamProp],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_param_or_ts_param_props(self, node, ast_path)
        } else {
        }
    }

    fn visit_params<'ast: 'r, 'r>(&mut self, node: &'ast [Param], ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_params(self, node, ast_path)
        } else {
        }
    }

    fn visit_paren_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ParenExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_paren_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_pat<'ast: 'r, 'r>(&mut self, node: &'ast Pat, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_pat(self, node, ast_path)
        } else {
        }
    }

    fn visit_pats<'ast: 'r, 'r>(&mut self, node: &'ast [Pat], ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_pats(self, node, ast_path)
        } else {
        }
    }

    fn visit_private_method<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateMethod,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_private_method(self, node, ast_path)
        } else {
        }
    }

    fn visit_private_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_private_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_private_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PrivateProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_private_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_program<'ast: 'r, 'r>(&mut self, node: &'ast Program, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_program(self, node, ast_path)
        } else {
        }
    }

    fn visit_prop<'ast: 'r, 'r>(&mut self, node: &'ast Prop, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_prop_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PropName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_prop_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_prop_or_spread<'ast: 'r, 'r>(
        &mut self,
        node: &'ast PropOrSpread,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_prop_or_spread(self, node, ast_path)
        } else {
        }
    }

    fn visit_prop_or_spreads<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [PropOrSpread],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_prop_or_spreads(self, node, ast_path)
        } else {
        }
    }

    fn visit_regex<'ast: 'r, 'r>(&mut self, node: &'ast Regex, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_regex(self, node, ast_path)
        } else {
        }
    }

    fn visit_reserved_unused<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ReservedUnused,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_reserved_unused(self, node, ast_path)
        } else {
        }
    }

    fn visit_rest_pat<'ast: 'r, 'r>(
        &mut self,
        node: &'ast RestPat,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_rest_pat(self, node, ast_path)
        } else {
        }
    }

    fn visit_return_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ReturnStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_return_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_script<'ast: 'r, 'r>(&mut self, node: &'ast Script, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_script(self, node, ast_path)
        } else {
        }
    }

    fn visit_seq_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SeqExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_seq_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_setter_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SetterProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_setter_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_simple_assign_target<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SimpleAssignTarget,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_simple_assign_target(self, node, ast_path)
        } else {
        }
    }

    fn visit_span<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::Span,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_span(self, node, ast_path)
        } else {
        }
    }

    fn visit_spread_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SpreadElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_spread_element(self, node, ast_path)
        } else {
        }
    }

    fn visit_static_block<'ast: 'r, 'r>(
        &mut self,
        node: &'ast StaticBlock,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_static_block(self, node, ast_path)
        } else {
        }
    }

    fn visit_stmt<'ast: 'r, 'r>(&mut self, node: &'ast Stmt, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_stmts<'ast: 'r, 'r>(&mut self, node: &'ast [Stmt], ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_stmts(self, node, ast_path)
        } else {
        }
    }

    fn visit_str<'ast: 'r, 'r>(&mut self, node: &'ast Str, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_str(self, node, ast_path)
        } else {
        }
    }

    fn visit_super<'ast: 'r, 'r>(&mut self, node: &'ast Super, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_super(self, node, ast_path)
        } else {
        }
    }

    fn visit_super_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SuperProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_super_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_super_prop_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SuperPropExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_super_prop_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_switch_case<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SwitchCase,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_switch_case(self, node, ast_path)
        } else {
        }
    }

    fn visit_switch_cases<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [SwitchCase],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_switch_cases(self, node, ast_path)
        } else {
        }
    }

    fn visit_switch_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast SwitchStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_switch_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_syntax_context<'ast: 'r, 'r>(
        &mut self,
        node: &'ast swc_common::SyntaxContext,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_syntax_context(self, node, ast_path)
        } else {
        }
    }

    fn visit_tagged_tpl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TaggedTpl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_tagged_tpl(self, node, ast_path)
        } else {
        }
    }

    fn visit_this_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ThisExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_this_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_throw_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast ThrowStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_throw_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_tpl<'ast: 'r, 'r>(&mut self, node: &'ast Tpl, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_tpl(self, node, ast_path)
        } else {
        }
    }

    fn visit_tpl_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TplElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_tpl_element(self, node, ast_path)
        } else {
        }
    }

    fn visit_tpl_elements<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TplElement],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_tpl_elements(self, node, ast_path)
        } else {
        }
    }

    fn visit_true_plus_minus<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TruePlusMinus,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_true_plus_minus(self, node, ast_path)
        } else {
        }
    }

    fn visit_try_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TryStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_try_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_array_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsArrayType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_array_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_as_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsAsExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_as_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_call_signature_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsCallSignatureDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_call_signature_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_conditional_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsConditionalType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_conditional_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_const_assertion<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsConstAssertion,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_const_assertion(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_construct_signature_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsConstructSignatureDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_construct_signature_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_constructor_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsConstructorType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_constructor_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_entity_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsEntityName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_entity_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_enum_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsEnumDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_enum_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_enum_member<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsEnumMember,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_enum_member(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_enum_member_id<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsEnumMemberId,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_enum_member_id(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_enum_members<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsEnumMember],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_enum_members(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_export_assignment<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsExportAssignment,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_export_assignment(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_expr_with_type_args<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsExprWithTypeArgs,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_expr_with_type_args(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_expr_with_type_argss<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsExprWithTypeArgs],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_expr_with_type_argss(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_external_module_ref<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsExternalModuleRef,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_external_module_ref(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_fn_or_constructor_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsFnOrConstructorType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_fn_or_constructor_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_fn_param<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsFnParam,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_fn_param(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_fn_params<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsFnParam],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_fn_params(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_fn_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsFnType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_fn_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_getter_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsGetterSignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_getter_signature(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_import_equals_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsImportEqualsDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_import_equals_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_import_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsImportType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_import_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_index_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsIndexSignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_index_signature(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_indexed_access_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsIndexedAccessType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_indexed_access_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_infer_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsInferType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_infer_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_instantiation<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsInstantiation,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_instantiation(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_interface_body<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsInterfaceBody,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_interface_body(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_interface_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsInterfaceDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_interface_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_intersection_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsIntersectionType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_intersection_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_keyword_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsKeywordType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_keyword_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_keyword_type_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsKeywordTypeKind,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_keyword_type_kind(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_lit<'ast: 'r, 'r>(&mut self, node: &'ast TsLit, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_ts_lit(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_lit_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsLitType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_lit_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_mapped_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsMappedType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_mapped_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_method_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsMethodSignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_method_signature(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_module_block<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsModuleBlock,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_module_block(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_module_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsModuleDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_module_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_module_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsModuleName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_module_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_module_ref<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsModuleRef,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_module_ref(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_namespace_body<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsNamespaceBody,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_namespace_body(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_namespace_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsNamespaceDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_namespace_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_namespace_export_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsNamespaceExportDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_namespace_export_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_non_null_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsNonNullExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_non_null_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_optional_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsOptionalType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_optional_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_param_prop<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsParamProp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_param_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_param_prop_param<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsParamPropParam,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_param_prop_param(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_parenthesized_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsParenthesizedType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_parenthesized_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_property_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsPropertySignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_property_signature(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_qualified_name<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsQualifiedName,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_qualified_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_rest_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsRestType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_rest_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_satisfies_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsSatisfiesExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_satisfies_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_setter_signature<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsSetterSignature,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_setter_signature(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_this_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsThisType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_this_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_this_type_or_ident<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsThisTypeOrIdent,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_this_type_or_ident(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_tpl_lit_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTplLitType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_tpl_lit_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_tuple_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTupleElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_tuple_element(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_tuple_elements<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsTupleElement],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_tuple_elements(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_tuple_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTupleType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_tuple_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_type<'ast: 'r, 'r>(&mut self, node: &'ast TsType, ast_path: &mut AstNodePath<'r>) {
        if self.enabled {
            VisitAstPath::visit_ts_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_type_alias_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeAliasDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_type_alias_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_type_ann<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeAnn,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_type_ann(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_type_assertion<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeAssertion,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_type_assertion(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_type_element<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeElement,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_type_element(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_type_elements<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsTypeElement],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_type_elements(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_type_lit<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeLit,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_type_lit(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_type_operator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeOperator,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_type_operator(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_type_operator_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeOperatorOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_type_operator_op(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_type_param<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeParam,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_type_param(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_type_param_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeParamDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_type_param_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_type_param_instantiation<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeParamInstantiation,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_type_param_instantiation(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_type_params<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [TsTypeParam],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_type_params(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_type_predicate<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypePredicate,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_type_predicate(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_type_query<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeQuery,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_type_query(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_type_query_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeQueryExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_type_query_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_type_ref<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsTypeRef,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_type_ref(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_types<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [Box<TsType>],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_types(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_union_or_intersection_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsUnionOrIntersectionType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_union_or_intersection_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_ts_union_type<'ast: 'r, 'r>(
        &mut self,
        node: &'ast TsUnionType,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_ts_union_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_unary_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnaryExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_unary_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_unary_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UnaryOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_unary_op(self, node, ast_path)
        } else {
        }
    }

    fn visit_update_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UpdateExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_update_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_update_op<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UpdateOp,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_update_op(self, node, ast_path)
        } else {
        }
    }

    fn visit_using_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast UsingDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_using_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_var_decl<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDecl,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_var_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_var_decl_kind<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclKind,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_var_decl_kind(self, node, ast_path)
        } else {
        }
    }

    fn visit_var_decl_or_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclOrExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_var_decl_or_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_var_declarator<'ast: 'r, 'r>(
        &mut self,
        node: &'ast VarDeclarator,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_var_declarator(self, node, ast_path)
        } else {
        }
    }

    fn visit_var_declarators<'ast: 'r, 'r>(
        &mut self,
        node: &'ast [VarDeclarator],
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_var_declarators(self, node, ast_path)
        } else {
        }
    }

    fn visit_while_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast WhileStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_while_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_with_stmt<'ast: 'r, 'r>(
        &mut self,
        node: &'ast WithStmt,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_with_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_yield_expr<'ast: 'r, 'r>(
        &mut self,
        node: &'ast YieldExpr,
        ast_path: &mut AstNodePath<'r>,
    ) {
        if self.enabled {
            VisitAstPath::visit_yield_expr(self, node, ast_path)
        } else {
        }
    }
}
#[doc = r" A trait implemented for types that can be visited using a visitor."]
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
pub trait VisitWithAstPath<V: ?Sized + VisitAstPath> {
    #[doc = r" Calls a visitor method (visitor.fold_xxx) with self."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    );
    #[doc = r" Visit children nodes of `self`` with `visitor`."]
    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    );
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Accessibility {
    #[doc = "Calls [VisitAstPath`::visit_accessibility`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_accessibility(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Accessibility::Public => {}
            Accessibility::Protected => {}
            Accessibility::Private => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ArrayLit {
    #[doc = "Calls [VisitAstPath`::visit_array_lit`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_array_lit(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ArrayLit { span, elems } => {
                <Vec<Option<ExprOrSpread>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    elems, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ArrayPat {
    #[doc = "Calls [VisitAstPath`::visit_array_pat`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_array_pat(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ArrayPat {
                span,
                elems,
                optional,
                type_ann,
            } => {
                <Vec<Option<Pat>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    elems, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ArrowExpr {
    #[doc = "Calls [VisitAstPath`::visit_arrow_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_arrow_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ArrowExpr {
                span,
                ctxt,
                params,
                body,
                is_async,
                is_generator,
                type_params,
                return_type,
            } => {
                <Vec<Pat> as VisitWithAstPath<V>>::visit_with_ast_path(params, visitor, ast_path);
                <Box<BlockStmtOrExpr> as VisitWithAstPath<V>>::visit_with_ast_path(
                    body, visitor, ast_path,
                );
                <Option<Box<TsTypeParamDecl>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    return_type,
                    visitor,
                    ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for AssignExpr {
    #[doc = "Calls [VisitAstPath`::visit_assign_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            AssignExpr {
                span,
                op,
                left,
                right,
            } => {
                <AssignOp as VisitWithAstPath<V>>::visit_with_ast_path(op, visitor, ast_path);
                <AssignTarget as VisitWithAstPath<V>>::visit_with_ast_path(left, visitor, ast_path);
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(right, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for AssignOp {
    #[doc = "Calls [VisitAstPath`::visit_assign_op`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_op(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            AssignOp::Assign => {}
            AssignOp::AddAssign => {}
            AssignOp::SubAssign => {}
            AssignOp::MulAssign => {}
            AssignOp::DivAssign => {}
            AssignOp::ModAssign => {}
            AssignOp::LShiftAssign => {}
            AssignOp::RShiftAssign => {}
            AssignOp::ZeroFillRShiftAssign => {}
            AssignOp::BitOrAssign => {}
            AssignOp::BitXorAssign => {}
            AssignOp::BitAndAssign => {}
            AssignOp::ExpAssign => {}
            AssignOp::AndAssign => {}
            AssignOp::OrAssign => {}
            AssignOp::NullishAssign => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for AssignPat {
    #[doc = "Calls [VisitAstPath`::visit_assign_pat`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_pat(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            AssignPat { span, left, right } => {
                <Box<Pat> as VisitWithAstPath<V>>::visit_with_ast_path(left, visitor, ast_path);
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(right, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for AssignPatProp {
    #[doc = "Calls [VisitAstPath`::visit_assign_pat_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_pat_prop(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            AssignPatProp { span, key, value } => {
                <BindingIdent as VisitWithAstPath<V>>::visit_with_ast_path(key, visitor, ast_path);
                <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    value, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for AssignProp {
    #[doc = "Calls [VisitAstPath`::visit_assign_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_prop(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            AssignProp { span, key, value } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(key, visitor, ast_path);
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(value, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for AssignTarget {
    #[doc = "Calls [VisitAstPath`::visit_assign_target`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_target(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            AssignTarget::Simple { 0: _field_0 } => {
                <SimpleAssignTarget as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            AssignTarget::Pat { 0: _field_0 } => {
                <AssignTargetPat as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for AssignTargetPat {
    #[doc = "Calls [VisitAstPath`::visit_assign_target_pat`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_assign_target_pat(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            AssignTargetPat::Array { 0: _field_0 } => {
                <ArrayPat as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            AssignTargetPat::Object { 0: _field_0 } => {
                <ObjectPat as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            AssignTargetPat::Invalid { 0: _field_0 } => {
                <Invalid as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for AutoAccessor {
    #[doc = "Calls [VisitAstPath`::visit_auto_accessor`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_auto_accessor(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            AutoAccessor {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_override,
                definite,
            } => {
                <Key as VisitWithAstPath<V>>::visit_with_ast_path(key, visitor, ast_path);
                <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    value, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                <Vec<Decorator> as VisitWithAstPath<V>>::visit_with_ast_path(
                    decorators, visitor, ast_path,
                );
                <Option<Accessibility> as VisitWithAstPath<V>>::visit_with_ast_path(
                    accessibility,
                    visitor,
                    ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for AwaitExpr {
    #[doc = "Calls [VisitAstPath`::visit_await_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_await_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            AwaitExpr { span, arg } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(arg, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for BigInt {
    #[doc = "Calls [VisitAstPath`::visit_big_int`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_big_int(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            BigInt { span, value, raw } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for BinExpr {
    #[doc = "Calls [VisitAstPath`::visit_bin_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_bin_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            BinExpr {
                span,
                op,
                left,
                right,
            } => {
                <BinaryOp as VisitWithAstPath<V>>::visit_with_ast_path(op, visitor, ast_path);
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(left, visitor, ast_path);
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(right, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for BinaryOp {
    #[doc = "Calls [VisitAstPath`::visit_binary_op`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_binary_op(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            BinaryOp::EqEq => {}
            BinaryOp::NotEq => {}
            BinaryOp::EqEqEq => {}
            BinaryOp::NotEqEq => {}
            BinaryOp::Lt => {}
            BinaryOp::LtEq => {}
            BinaryOp::Gt => {}
            BinaryOp::GtEq => {}
            BinaryOp::LShift => {}
            BinaryOp::RShift => {}
            BinaryOp::ZeroFillRShift => {}
            BinaryOp::Add => {}
            BinaryOp::Sub => {}
            BinaryOp::Mul => {}
            BinaryOp::Div => {}
            BinaryOp::Mod => {}
            BinaryOp::BitOr => {}
            BinaryOp::BitXor => {}
            BinaryOp::BitAnd => {}
            BinaryOp::LogicalOr => {}
            BinaryOp::LogicalAnd => {}
            BinaryOp::In => {}
            BinaryOp::InstanceOf => {}
            BinaryOp::Exp => {}
            BinaryOp::NullishCoalescing => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for BindingIdent {
    #[doc = "Calls [VisitAstPath`::visit_binding_ident`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_binding_ident(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            BindingIdent { id, type_ann } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(id, visitor, ast_path);
                <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for BlockStmt {
    #[doc = "Calls [VisitAstPath`::visit_block_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_block_stmt(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            BlockStmt { span, ctxt, stmts } => {
                <Vec<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(stmts, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for BlockStmtOrExpr {
    #[doc = "Calls [VisitAstPath`::visit_block_stmt_or_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_block_stmt_or_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            BlockStmtOrExpr::BlockStmt { 0: _field_0 } => {
                <BlockStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            BlockStmtOrExpr::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Bool {
    #[doc = "Calls [VisitAstPath`::visit_bool`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_bool(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Bool { span, value } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for BreakStmt {
    #[doc = "Calls [VisitAstPath`::visit_break_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_break_stmt(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            BreakStmt { span, label } => {
                <Option<Ident> as VisitWithAstPath<V>>::visit_with_ast_path(
                    label, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for CallExpr {
    #[doc = "Calls [VisitAstPath`::visit_call_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_call_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            CallExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                <Callee as VisitWithAstPath<V>>::visit_with_ast_path(callee, visitor, ast_path);
                <Vec<ExprOrSpread> as VisitWithAstPath<V>>::visit_with_ast_path(
                    args, visitor, ast_path,
                );
                <Option<Box<TsTypeParamInstantiation>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_args, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Callee {
    #[doc = "Calls [VisitAstPath`::visit_callee`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_callee(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Callee::Super { 0: _field_0 } => {
                <Super as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Callee::Import { 0: _field_0 } => {
                <Import as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Callee::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for CatchClause {
    #[doc = "Calls [VisitAstPath`::visit_catch_clause`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_catch_clause(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            CatchClause { span, param, body } => {
                <Option<Pat> as VisitWithAstPath<V>>::visit_with_ast_path(param, visitor, ast_path);
                <BlockStmt as VisitWithAstPath<V>>::visit_with_ast_path(body, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Class {
    #[doc = "Calls [VisitAstPath`::visit_class`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Class {
                span,
                ctxt,
                decorators,
                body,
                super_class,
                is_abstract,
                type_params,
                super_type_params,
                implements,
            } => {
                <Vec<Decorator> as VisitWithAstPath<V>>::visit_with_ast_path(
                    decorators, visitor, ast_path,
                );
                <Vec<ClassMember> as VisitWithAstPath<V>>::visit_with_ast_path(
                    body, visitor, ast_path,
                );
                <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    super_class,
                    visitor,
                    ast_path,
                );
                <Option<Box<TsTypeParamDecl>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
                <Option<Box<TsTypeParamInstantiation>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    super_type_params,
                    visitor,
                    ast_path,
                );
                <Vec<TsExprWithTypeArgs> as VisitWithAstPath<V>>::visit_with_ast_path(
                    implements, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ClassDecl {
    #[doc = "Calls [VisitAstPath`::visit_class_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_decl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ClassDecl {
                ident,
                declare,
                class,
            } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(ident, visitor, ast_path);
                <Box<Class> as VisitWithAstPath<V>>::visit_with_ast_path(class, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ClassExpr {
    #[doc = "Calls [VisitAstPath`::visit_class_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ClassExpr { ident, class } => {
                <Option<Ident> as VisitWithAstPath<V>>::visit_with_ast_path(
                    ident, visitor, ast_path,
                );
                <Box<Class> as VisitWithAstPath<V>>::visit_with_ast_path(class, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ClassMember {
    #[doc = "Calls [VisitAstPath`::visit_class_member`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_member(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ClassMember::Constructor { 0: _field_0 } => {
                <Constructor as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ClassMember::Method { 0: _field_0 } => {}
            ClassMember::PrivateMethod { 0: _field_0 } => {}
            ClassMember::ClassProp { 0: _field_0 } => {
                <ClassProp as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ClassMember::PrivateProp { 0: _field_0 } => {
                <PrivateProp as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ClassMember::TsIndexSignature { 0: _field_0 } => {
                <TsIndexSignature as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ClassMember::Empty { 0: _field_0 } => {
                <EmptyStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ClassMember::StaticBlock { 0: _field_0 } => {
                <StaticBlock as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ClassMember::AutoAccessor { 0: _field_0 } => {
                <AutoAccessor as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ClassProp {
    #[doc = "Calls [VisitAstPath`::visit_class_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_prop(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ClassProp {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
                readonly,
                declare,
                definite,
            } => {
                <PropName as VisitWithAstPath<V>>::visit_with_ast_path(key, visitor, ast_path);
                <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    value, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                <Vec<Decorator> as VisitWithAstPath<V>>::visit_with_ast_path(
                    decorators, visitor, ast_path,
                );
                <Option<Accessibility> as VisitWithAstPath<V>>::visit_with_ast_path(
                    accessibility,
                    visitor,
                    ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ComputedPropName {
    #[doc = "Calls [VisitAstPath`::visit_computed_prop_name`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_computed_prop_name(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ComputedPropName { span, expr } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(expr, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for CondExpr {
    #[doc = "Calls [VisitAstPath`::visit_cond_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_cond_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            CondExpr {
                span,
                test,
                cons,
                alt,
            } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(test, visitor, ast_path);
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(cons, visitor, ast_path);
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(alt, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Constructor {
    #[doc = "Calls [VisitAstPath`::visit_constructor`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_constructor(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Constructor {
                span,
                ctxt,
                key,
                params,
                body,
                accessibility,
                is_optional,
            } => {
                <PropName as VisitWithAstPath<V>>::visit_with_ast_path(key, visitor, ast_path);
                <Vec<ParamOrTsParamProp> as VisitWithAstPath<V>>::visit_with_ast_path(
                    params, visitor, ast_path,
                );
                <Option<BlockStmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                    body, visitor, ast_path,
                );
                <Option<Accessibility> as VisitWithAstPath<V>>::visit_with_ast_path(
                    accessibility,
                    visitor,
                    ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ContinueStmt {
    #[doc = "Calls [VisitAstPath`::visit_continue_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_continue_stmt(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ContinueStmt { span, label } => {
                <Option<Ident> as VisitWithAstPath<V>>::visit_with_ast_path(
                    label, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for DebuggerStmt {
    #[doc = "Calls [VisitAstPath`::visit_debugger_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_debugger_stmt(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            DebuggerStmt { span } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Decl {
    #[doc = "Calls [VisitAstPath`::visit_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_decl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Decl::Class { 0: _field_0 } => {
                <ClassDecl as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Decl::Fn { 0: _field_0 } => {
                <FnDecl as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Decl::Var { 0: _field_0 } => {
                <Box<VarDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Decl::Using { 0: _field_0 } => {
                <Box<UsingDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Decl::TsInterface { 0: _field_0 } => {
                <Box<TsInterfaceDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Decl::TsTypeAlias { 0: _field_0 } => {
                <Box<TsTypeAliasDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Decl::TsEnum { 0: _field_0 } => {
                <Box<TsEnumDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Decl::TsModule { 0: _field_0 } => {
                <Box<TsModuleDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Decorator {
    #[doc = "Calls [VisitAstPath`::visit_decorator`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_decorator(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Decorator { span, expr } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(expr, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for DefaultDecl {
    #[doc = "Calls [VisitAstPath`::visit_default_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_default_decl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            DefaultDecl::Class { 0: _field_0 } => {
                <ClassExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            DefaultDecl::Fn { 0: _field_0 } => {
                <FnExpr as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            DefaultDecl::TsInterfaceDecl { 0: _field_0 } => {
                <Box<TsInterfaceDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for DoWhileStmt {
    #[doc = "Calls [VisitAstPath`::visit_do_while_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_do_while_stmt(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            DoWhileStmt { span, test, body } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(test, visitor, ast_path);
                <Box<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(body, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for EmptyStmt {
    #[doc = "Calls [VisitAstPath`::visit_empty_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_empty_stmt(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            EmptyStmt { span } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for EsVersion {
    #[doc = "Calls [VisitAstPath`::visit_es_version`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_es_version(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            EsVersion::Es3 => {}
            EsVersion::Es5 => {}
            EsVersion::Es2015 => {}
            EsVersion::Es2016 => {}
            EsVersion::Es2017 => {}
            EsVersion::Es2018 => {}
            EsVersion::Es2019 => {}
            EsVersion::Es2020 => {}
            EsVersion::Es2021 => {}
            EsVersion::Es2022 => {}
            EsVersion::EsNext => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ExportAll {
    #[doc = "Calls [VisitAstPath`::visit_export_all`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_all(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ExportAll {
                span,
                src,
                type_only,
                with,
            } => {
                <Box<Str> as VisitWithAstPath<V>>::visit_with_ast_path(src, visitor, ast_path);
                <Option<Box<ObjectLit>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    with, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ExportDecl {
    #[doc = "Calls [VisitAstPath`::visit_export_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_decl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ExportDecl { span, decl } => {
                <Decl as VisitWithAstPath<V>>::visit_with_ast_path(decl, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ExportDefaultDecl {
    #[doc = "Calls [VisitAstPath`::visit_export_default_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_default_decl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ExportDefaultDecl { span, decl } => {
                <DefaultDecl as VisitWithAstPath<V>>::visit_with_ast_path(decl, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ExportDefaultExpr {
    #[doc = "Calls [VisitAstPath`::visit_export_default_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_default_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ExportDefaultExpr { span, expr } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(expr, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ExportDefaultSpecifier {
    #[doc = "Calls [VisitAstPath`::visit_export_default_specifier`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_default_specifier(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ExportDefaultSpecifier { exported } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(exported, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ExportNamedSpecifier {
    #[doc = "Calls [VisitAstPath`::visit_export_named_specifier`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_named_specifier(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ExportNamedSpecifier {
                span,
                orig,
                exported,
                is_type_only,
            } => {
                <ModuleExportName as VisitWithAstPath<V>>::visit_with_ast_path(
                    orig, visitor, ast_path,
                );
                <Option<ModuleExportName> as VisitWithAstPath<V>>::visit_with_ast_path(
                    exported, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ExportNamespaceSpecifier {
    #[doc = "Calls [VisitAstPath`::visit_export_namespace_specifier`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_namespace_specifier(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ExportNamespaceSpecifier { span, name } => {
                <ModuleExportName as VisitWithAstPath<V>>::visit_with_ast_path(
                    name, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ExportSpecifier {
    #[doc = "Calls [VisitAstPath`::visit_export_specifier`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_specifier(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ExportSpecifier::Namespace { 0: _field_0 } => {
                <ExportNamespaceSpecifier as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ExportSpecifier::Default { 0: _field_0 } => {
                <ExportDefaultSpecifier as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ExportSpecifier::Named { 0: _field_0 } => {
                <ExportNamedSpecifier as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Expr {
    #[doc = "Calls [VisitAstPath`::visit_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Expr::This { 0: _field_0 } => {
                <ThisExpr as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Expr::Array { 0: _field_0 } => {
                <ArrayLit as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Expr::Object { 0: _field_0 } => {
                <ObjectLit as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Fn { 0: _field_0 } => {
                <FnExpr as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Expr::Unary { 0: _field_0 } => {
                <UnaryExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Update { 0: _field_0 } => {
                <UpdateExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Bin { 0: _field_0 } => {
                <BinExpr as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Expr::Assign { 0: _field_0 } => {
                <AssignExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Member { 0: _field_0 } => {
                <MemberExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::SuperProp { 0: _field_0 } => {
                <SuperPropExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Cond { 0: _field_0 } => {
                <CondExpr as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Expr::Call { 0: _field_0 } => {
                <CallExpr as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Expr::New { 0: _field_0 } => {
                <NewExpr as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Expr::Seq { 0: _field_0 } => {
                <SeqExpr as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Expr::Ident { 0: _field_0 } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Expr::Lit { 0: _field_0 } => {
                <Lit as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Expr::Tpl { 0: _field_0 } => {
                <Tpl as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Expr::TaggedTpl { 0: _field_0 } => {
                <TaggedTpl as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Arrow { 0: _field_0 } => {
                <ArrowExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Class { 0: _field_0 } => {
                <ClassExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Yield { 0: _field_0 } => {
                <YieldExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::MetaProp { 0: _field_0 } => {
                <MetaPropExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Await { 0: _field_0 } => {
                <AwaitExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Paren { 0: _field_0 } => {
                <ParenExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::JSXMember { 0: _field_0 } => {
                <JSXMemberExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::JSXNamespacedName { 0: _field_0 } => {
                <JSXNamespacedName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::JSXEmpty { 0: _field_0 } => {
                <JSXEmptyExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::JSXElement { 0: _field_0 } => {
                <Box<JSXElement> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::JSXFragment { 0: _field_0 } => {
                <JSXFragment as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::TsTypeAssertion { 0: _field_0 } => {
                <TsTypeAssertion as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::TsConstAssertion { 0: _field_0 } => {
                <TsConstAssertion as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::TsNonNull { 0: _field_0 } => {
                <TsNonNullExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::TsAs { 0: _field_0 } => {
                <TsAsExpr as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Expr::TsInstantiation { 0: _field_0 } => {
                <TsInstantiation as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::TsSatisfies { 0: _field_0 } => {
                <TsSatisfiesExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::PrivateName { 0: _field_0 } => {
                <PrivateName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::OptChain { 0: _field_0 } => {
                <OptChainExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Invalid { 0: _field_0 } => {
                <Invalid as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ExprOrSpread {
    #[doc = "Calls [VisitAstPath`::visit_expr_or_spread`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_expr_or_spread(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ExprOrSpread { spread, expr } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(expr, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ExprStmt {
    #[doc = "Calls [VisitAstPath`::visit_expr_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_expr_stmt(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ExprStmt { span, expr } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(expr, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for FnDecl {
    #[doc = "Calls [VisitAstPath`::visit_fn_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_fn_decl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            FnDecl {
                ident,
                declare,
                function,
            } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(ident, visitor, ast_path);
                <Box<Function> as VisitWithAstPath<V>>::visit_with_ast_path(
                    function, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for FnExpr {
    #[doc = "Calls [VisitAstPath`::visit_fn_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_fn_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            FnExpr { ident, function } => {
                <Option<Ident> as VisitWithAstPath<V>>::visit_with_ast_path(
                    ident, visitor, ast_path,
                );
                <Box<Function> as VisitWithAstPath<V>>::visit_with_ast_path(
                    function, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ForHead {
    #[doc = "Calls [VisitAstPath`::visit_for_head`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_for_head(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ForHead::VarDecl { 0: _field_0 } => {
                <Box<VarDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ForHead::UsingDecl { 0: _field_0 } => {
                <Box<UsingDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ForHead::Pat { 0: _field_0 } => {
                <Box<Pat> as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ForInStmt {
    #[doc = "Calls [VisitAstPath`::visit_for_in_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_for_in_stmt(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ForInStmt {
                span,
                left,
                right,
                body,
            } => {
                <ForHead as VisitWithAstPath<V>>::visit_with_ast_path(left, visitor, ast_path);
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(right, visitor, ast_path);
                <Box<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(body, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ForOfStmt {
    #[doc = "Calls [VisitAstPath`::visit_for_of_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_for_of_stmt(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ForOfStmt {
                span,
                is_await,
                left,
                right,
                body,
            } => {
                <ForHead as VisitWithAstPath<V>>::visit_with_ast_path(left, visitor, ast_path);
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(right, visitor, ast_path);
                <Box<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(body, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ForStmt {
    #[doc = "Calls [VisitAstPath`::visit_for_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_for_stmt(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ForStmt {
                span,
                init,
                test,
                update,
                body,
            } => {
                <Option<VarDeclOrExpr> as VisitWithAstPath<V>>::visit_with_ast_path(
                    init, visitor, ast_path,
                );
                <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    test, visitor, ast_path,
                );
                <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    update, visitor, ast_path,
                );
                <Box<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(body, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Function {
    #[doc = "Calls [VisitAstPath`::visit_function`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_function(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Function {
                params,
                decorators,
                span,
                ctxt,
                body,
                is_generator,
                is_async,
                type_params,
                return_type,
            } => {
                <Vec<Param> as VisitWithAstPath<V>>::visit_with_ast_path(params, visitor, ast_path);
                <Vec<Decorator> as VisitWithAstPath<V>>::visit_with_ast_path(
                    decorators, visitor, ast_path,
                );
                <Option<BlockStmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                    body, visitor, ast_path,
                );
                <Option<Box<TsTypeParamDecl>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    return_type,
                    visitor,
                    ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for GetterProp {
    #[doc = "Calls [VisitAstPath`::visit_getter_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_getter_prop(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            GetterProp {
                span,
                key,
                type_ann,
                body,
            } => {
                <PropName as VisitWithAstPath<V>>::visit_with_ast_path(key, visitor, ast_path);
                <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                <Option<BlockStmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Ident {
    #[doc = "Calls [VisitAstPath`::visit_ident`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ident(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Ident {
                span,
                ctxt,
                sym,
                optional,
            } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for IdentName {
    #[doc = "Calls [VisitAstPath`::visit_ident_name`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ident_name(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            IdentName { span, sym } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for IfStmt {
    #[doc = "Calls [VisitAstPath`::visit_if_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_if_stmt(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            IfStmt {
                span,
                test,
                cons,
                alt,
            } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(test, visitor, ast_path);
                <Box<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(cons, visitor, ast_path);
                <Option<Box<Stmt>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    alt, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Import {
    #[doc = "Calls [VisitAstPath`::visit_import`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Import { span, phase } => {
                <ImportPhase as VisitWithAstPath<V>>::visit_with_ast_path(phase, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ImportDecl {
    #[doc = "Calls [VisitAstPath`::visit_import_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_decl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ImportDecl {
                span,
                specifiers,
                src,
                type_only,
                with,
                phase,
            } => {
                <Vec<ImportSpecifier> as VisitWithAstPath<V>>::visit_with_ast_path(
                    specifiers, visitor, ast_path,
                );
                <Box<Str> as VisitWithAstPath<V>>::visit_with_ast_path(src, visitor, ast_path);
                <Option<Box<ObjectLit>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    with, visitor, ast_path,
                );
                <ImportPhase as VisitWithAstPath<V>>::visit_with_ast_path(phase, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ImportDefaultSpecifier {
    #[doc = "Calls [VisitAstPath`::visit_import_default_specifier`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_default_specifier(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ImportDefaultSpecifier { span, local } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(local, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ImportNamedSpecifier {
    #[doc = "Calls [VisitAstPath`::visit_import_named_specifier`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_named_specifier(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ImportNamedSpecifier {
                span,
                local,
                imported,
                is_type_only,
            } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(local, visitor, ast_path);
                <Option<ModuleExportName> as VisitWithAstPath<V>>::visit_with_ast_path(
                    imported, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ImportPhase {
    #[doc = "Calls [VisitAstPath`::visit_import_phase`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_phase(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ImportPhase::Evaluation => {}
            ImportPhase::Source => {}
            ImportPhase::Defer => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ImportSpecifier {
    #[doc = "Calls [VisitAstPath`::visit_import_specifier`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_specifier(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ImportSpecifier::Named { 0: _field_0 } => {
                <ImportNamedSpecifier as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ImportSpecifier::Default { 0: _field_0 } => {
                <ImportDefaultSpecifier as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ImportSpecifier::Namespace { 0: _field_0 } => {
                <ImportStarAsSpecifier as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ImportStarAsSpecifier {
    #[doc = "Calls [VisitAstPath`::visit_import_star_as_specifier`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_star_as_specifier(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ImportStarAsSpecifier { span, local } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(local, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ImportWith {
    #[doc = "Calls [VisitAstPath`::visit_import_with`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_with(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ImportWith { span, values } => {
                <Vec<ImportWithItem> as VisitWithAstPath<V>>::visit_with_ast_path(
                    values, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ImportWithItem {
    #[doc = "Calls [VisitAstPath`::visit_import_with_item`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_with_item(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ImportWithItem { key, value } => {
                <IdentName as VisitWithAstPath<V>>::visit_with_ast_path(key, visitor, ast_path);
                <Str as VisitWithAstPath<V>>::visit_with_ast_path(value, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Invalid {
    #[doc = "Calls [VisitAstPath`::visit_invalid`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_invalid(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Invalid { span } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXAttr {
    #[doc = "Calls [VisitAstPath`::visit_jsx_attr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_attr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXAttr { span, name, value } => {
                <JSXAttrName as VisitWithAstPath<V>>::visit_with_ast_path(name, visitor, ast_path);
                <Option<JSXAttrValue> as VisitWithAstPath<V>>::visit_with_ast_path(
                    value, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXAttrName {
    #[doc = "Calls [VisitAstPath`::visit_jsx_attr_name`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_attr_name(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXAttrName::Ident { 0: _field_0 } => {
                <IdentName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXAttrName::JSXNamespacedName { 0: _field_0 } => {
                <JSXNamespacedName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXAttrOrSpread {
    #[doc = "Calls [VisitAstPath`::visit_jsx_attr_or_spread`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_attr_or_spread(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXAttrOrSpread::JSXAttr { 0: _field_0 } => {
                <JSXAttr as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            JSXAttrOrSpread::SpreadElement { 0: _field_0 } => {
                <SpreadElement as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXAttrValue {
    #[doc = "Calls [VisitAstPath`::visit_jsx_attr_value`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_attr_value(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXAttrValue::Lit { 0: _field_0 } => {
                <Lit as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            JSXAttrValue::JSXExprContainer { 0: _field_0 } => {
                <JSXExprContainer as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXAttrValue::JSXElement { 0: _field_0 } => {
                <Box<JSXElement> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXAttrValue::JSXFragment { 0: _field_0 } => {
                <JSXFragment as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXClosingElement {
    #[doc = "Calls [VisitAstPath`::visit_jsx_closing_element`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_closing_element(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXClosingElement { span, name } => {
                <JSXElementName as VisitWithAstPath<V>>::visit_with_ast_path(
                    name, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXClosingFragment {
    #[doc = "Calls [VisitAstPath`::visit_jsx_closing_fragment`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_closing_fragment(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXClosingFragment { span } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXElement {
    #[doc = "Calls [VisitAstPath`::visit_jsx_element`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_element(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXElement {
                span,
                opening,
                children,
                closing,
            } => {
                <JSXOpeningElement as VisitWithAstPath<V>>::visit_with_ast_path(
                    opening, visitor, ast_path,
                );
                <Vec<JSXElementChild> as VisitWithAstPath<V>>::visit_with_ast_path(
                    children, visitor, ast_path,
                );
                <Option<JSXClosingElement> as VisitWithAstPath<V>>::visit_with_ast_path(
                    closing, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXElementChild {
    #[doc = "Calls [VisitAstPath`::visit_jsx_element_child`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_element_child(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXElementChild::JSXText { 0: _field_0 } => {
                <JSXText as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            JSXElementChild::JSXExprContainer { 0: _field_0 } => {
                <JSXExprContainer as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXElementChild::JSXSpreadChild { 0: _field_0 } => {
                <JSXSpreadChild as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXElementChild::JSXElement { 0: _field_0 } => {
                <Box<JSXElement> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXElementChild::JSXFragment { 0: _field_0 } => {
                <JSXFragment as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXElementName {
    #[doc = "Calls [VisitAstPath`::visit_jsx_element_name`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_element_name(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXElementName::Ident { 0: _field_0 } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            JSXElementName::JSXMemberExpr { 0: _field_0 } => {
                <JSXMemberExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXElementName::JSXNamespacedName { 0: _field_0 } => {
                <JSXNamespacedName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXEmptyExpr {
    #[doc = "Calls [VisitAstPath`::visit_jsx_empty_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_empty_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXEmptyExpr { span } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXExpr {
    #[doc = "Calls [VisitAstPath`::visit_jsx_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXExpr::JSXEmptyExpr { 0: _field_0 } => {
                <JSXEmptyExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXExpr::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXExprContainer {
    #[doc = "Calls [VisitAstPath`::visit_jsx_expr_container`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_expr_container(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXExprContainer { span, expr } => {
                <JSXExpr as VisitWithAstPath<V>>::visit_with_ast_path(expr, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXFragment {
    #[doc = "Calls [VisitAstPath`::visit_jsx_fragment`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_fragment(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXFragment {
                span,
                opening,
                children,
                closing,
            } => {
                <JSXOpeningFragment as VisitWithAstPath<V>>::visit_with_ast_path(
                    opening, visitor, ast_path,
                );
                <Vec<JSXElementChild> as VisitWithAstPath<V>>::visit_with_ast_path(
                    children, visitor, ast_path,
                );
                <JSXClosingFragment as VisitWithAstPath<V>>::visit_with_ast_path(
                    closing, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXMemberExpr {
    #[doc = "Calls [VisitAstPath`::visit_jsx_member_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_member_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXMemberExpr { span, obj, prop } => {
                <JSXObject as VisitWithAstPath<V>>::visit_with_ast_path(obj, visitor, ast_path);
                <IdentName as VisitWithAstPath<V>>::visit_with_ast_path(prop, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXNamespacedName {
    #[doc = "Calls [VisitAstPath`::visit_jsx_namespaced_name`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_namespaced_name(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXNamespacedName { span, ns, name } => {
                <IdentName as VisitWithAstPath<V>>::visit_with_ast_path(ns, visitor, ast_path);
                <IdentName as VisitWithAstPath<V>>::visit_with_ast_path(name, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXObject {
    #[doc = "Calls [VisitAstPath`::visit_jsx_object`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_object(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXObject::JSXMemberExpr { 0: _field_0 } => {
                <Box<JSXMemberExpr> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXObject::Ident { 0: _field_0 } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXOpeningElement {
    #[doc = "Calls [VisitAstPath`::visit_jsx_opening_element`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_opening_element(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXOpeningElement {
                name,
                span,
                attrs,
                self_closing,
                type_args,
            } => {
                <JSXElementName as VisitWithAstPath<V>>::visit_with_ast_path(
                    name, visitor, ast_path,
                );
                <Vec<JSXAttrOrSpread> as VisitWithAstPath<V>>::visit_with_ast_path(
                    attrs, visitor, ast_path,
                );
                <Option<Box<TsTypeParamInstantiation>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_args, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXOpeningFragment {
    #[doc = "Calls [VisitAstPath`::visit_jsx_opening_fragment`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_opening_fragment(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXOpeningFragment { span } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXSpreadChild {
    #[doc = "Calls [VisitAstPath`::visit_jsx_spread_child`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_spread_child(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXSpreadChild { span, expr } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(expr, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for JSXText {
    #[doc = "Calls [VisitAstPath`::visit_jsx_text`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_text(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            JSXText { span, value, raw } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Key {
    #[doc = "Calls [VisitAstPath`::visit_key`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_key(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Key::Private { 0: _field_0 } => {
                <PrivateName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Key::Public { 0: _field_0 } => {
                <PropName as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for KeyValuePatProp {
    #[doc = "Calls [VisitAstPath`::visit_key_value_pat_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_key_value_pat_prop(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            KeyValuePatProp { key, value } => {
                <PropName as VisitWithAstPath<V>>::visit_with_ast_path(key, visitor, ast_path);
                <Box<Pat> as VisitWithAstPath<V>>::visit_with_ast_path(value, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for KeyValueProp {
    #[doc = "Calls [VisitAstPath`::visit_key_value_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_key_value_prop(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            KeyValueProp { key, value } => {
                <PropName as VisitWithAstPath<V>>::visit_with_ast_path(key, visitor, ast_path);
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(value, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for LabeledStmt {
    #[doc = "Calls [VisitAstPath`::visit_labeled_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_labeled_stmt(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            LabeledStmt { span, label, body } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(label, visitor, ast_path);
                <Box<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(body, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Lit {
    #[doc = "Calls [VisitAstPath`::visit_lit`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_lit(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Lit::Str { 0: _field_0 } => {
                <Str as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Lit::Bool { 0: _field_0 } => {
                <Bool as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Lit::Null { 0: _field_0 } => {
                <Null as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Lit::Num { 0: _field_0 } => {
                <Number as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Lit::BigInt { 0: _field_0 } => {
                <BigInt as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Lit::Regex { 0: _field_0 } => {
                <Regex as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Lit::JSXText { 0: _field_0 } => {
                <JSXText as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for MemberExpr {
    #[doc = "Calls [VisitAstPath`::visit_member_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_member_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            MemberExpr { span, obj, prop } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(obj, visitor, ast_path);
                <MemberProp as VisitWithAstPath<V>>::visit_with_ast_path(prop, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for MemberProp {
    #[doc = "Calls [VisitAstPath`::visit_member_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_member_prop(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            MemberProp::Ident { 0: _field_0 } => {
                <IdentName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            MemberProp::PrivateName { 0: _field_0 } => {
                <PrivateName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            MemberProp::Computed { 0: _field_0 } => {
                <ComputedPropName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for MetaPropExpr {
    #[doc = "Calls [VisitAstPath`::visit_meta_prop_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_meta_prop_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            MetaPropExpr { span, kind } => {
                <MetaPropKind as VisitWithAstPath<V>>::visit_with_ast_path(kind, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for MetaPropKind {
    #[doc = "Calls [VisitAstPath`::visit_meta_prop_kind`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_meta_prop_kind(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            MetaPropKind::NewTarget => {}
            MetaPropKind::ImportMeta => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for MethodKind {
    #[doc = "Calls [VisitAstPath`::visit_method_kind`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_method_kind(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            MethodKind::Method => {}
            MethodKind::Getter => {}
            MethodKind::Setter => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for MethodProp {
    #[doc = "Calls [VisitAstPath`::visit_method_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_method_prop(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            MethodProp { key, function } => {
                <PropName as VisitWithAstPath<V>>::visit_with_ast_path(key, visitor, ast_path);
                <Box<Function> as VisitWithAstPath<V>>::visit_with_ast_path(
                    function, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Module {
    #[doc = "Calls [VisitAstPath`::visit_module`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_module(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Module {
                span,
                body,
                shebang,
            } => {
                <Vec<ModuleItem> as VisitWithAstPath<V>>::visit_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ModuleDecl {
    #[doc = "Calls [VisitAstPath`::visit_module_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_module_decl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ModuleDecl::Import { 0: _field_0 } => {
                <ImportDecl as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ModuleDecl::ExportDecl { 0: _field_0 } => {
                <ExportDecl as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ModuleDecl::ExportNamed { 0: _field_0 } => {
                <NamedExport as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ModuleDecl::ExportDefaultDecl { 0: _field_0 } => {
                <ExportDefaultDecl as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ModuleDecl::ExportDefaultExpr { 0: _field_0 } => {
                <ExportDefaultExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ModuleDecl::ExportAll { 0: _field_0 } => {
                <ExportAll as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ModuleDecl::TsImportEquals { 0: _field_0 } => {
                <Box<TsImportEqualsDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ModuleDecl::TsExportAssignment { 0: _field_0 } => {
                <TsExportAssignment as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ModuleDecl::TsNamespaceExport { 0: _field_0 } => {
                <TsNamespaceExportDecl as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ModuleExportName {
    #[doc = "Calls [VisitAstPath`::visit_module_export_name`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_module_export_name(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ModuleExportName::Ident { 0: _field_0 } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            ModuleExportName::Str { 0: _field_0 } => {
                <Str as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ModuleItem {
    #[doc = "Calls [VisitAstPath`::visit_module_item`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_module_item(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ModuleItem::ModuleDecl { 0: _field_0 } => {
                <ModuleDecl as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ModuleItem::Stmt { 0: _field_0 } => {
                <Stmt as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for NamedExport {
    #[doc = "Calls [VisitAstPath`::visit_named_export`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_named_export(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            NamedExport {
                span,
                specifiers,
                src,
                type_only,
                with,
            } => {
                <Vec<ExportSpecifier> as VisitWithAstPath<V>>::visit_with_ast_path(
                    specifiers, visitor, ast_path,
                );
                <Option<Box<Str>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    src, visitor, ast_path,
                );
                <Option<Box<ObjectLit>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    with, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for NewExpr {
    #[doc = "Calls [VisitAstPath`::visit_new_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_new_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            NewExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(callee, visitor, ast_path);
                <Option<Vec<ExprOrSpread>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    args, visitor, ast_path,
                );
                <Option<Box<TsTypeParamInstantiation>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_args, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Null {
    #[doc = "Calls [VisitAstPath`::visit_null`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_null(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Null { span } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Number {
    #[doc = "Calls [VisitAstPath`::visit_number`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_number(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Number { span, value, raw } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ObjectLit {
    #[doc = "Calls [VisitAstPath`::visit_object_lit`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_object_lit(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ObjectLit { span, props } => {
                <Vec<PropOrSpread> as VisitWithAstPath<V>>::visit_with_ast_path(
                    props, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ObjectPat {
    #[doc = "Calls [VisitAstPath`::visit_object_pat`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_object_pat(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ObjectPat {
                span,
                props,
                optional,
                type_ann,
            } => {
                <Vec<ObjectPatProp> as VisitWithAstPath<V>>::visit_with_ast_path(
                    props, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ObjectPatProp {
    #[doc = "Calls [VisitAstPath`::visit_object_pat_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_object_pat_prop(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ObjectPatProp::KeyValue { 0: _field_0 } => {
                <KeyValuePatProp as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ObjectPatProp::Assign { 0: _field_0 } => {
                <AssignPatProp as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ObjectPatProp::Rest { 0: _field_0 } => {
                <RestPat as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for OptCall {
    #[doc = "Calls [VisitAstPath`::visit_opt_call`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_call(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            OptCall {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(callee, visitor, ast_path);
                <Vec<ExprOrSpread> as VisitWithAstPath<V>>::visit_with_ast_path(
                    args, visitor, ast_path,
                );
                <Option<Box<TsTypeParamInstantiation>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_args, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for OptChainBase {
    #[doc = "Calls [VisitAstPath`::visit_opt_chain_base`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_chain_base(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            OptChainBase::Member { 0: _field_0 } => {
                <MemberExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            OptChainBase::Call { 0: _field_0 } => {
                <OptCall as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for OptChainExpr {
    #[doc = "Calls [VisitAstPath`::visit_opt_chain_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_chain_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            OptChainExpr {
                span,
                optional,
                base,
            } => {
                <Box<OptChainBase> as VisitWithAstPath<V>>::visit_with_ast_path(
                    base, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Param {
    #[doc = "Calls [VisitAstPath`::visit_param`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_param(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Param {
                span,
                decorators,
                pat,
            } => {
                <Vec<Decorator> as VisitWithAstPath<V>>::visit_with_ast_path(
                    decorators, visitor, ast_path,
                );
                <Pat as VisitWithAstPath<V>>::visit_with_ast_path(pat, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ParamOrTsParamProp {
    #[doc = "Calls [VisitAstPath`::visit_param_or_ts_param_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_param_or_ts_param_prop(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ParamOrTsParamProp::TsParamProp { 0: _field_0 } => {
                <TsParamProp as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ParamOrTsParamProp::Param { 0: _field_0 } => {
                <Param as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ParenExpr {
    #[doc = "Calls [VisitAstPath`::visit_paren_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_paren_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ParenExpr { span, expr } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(expr, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Pat {
    #[doc = "Calls [VisitAstPath`::visit_pat`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_pat(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Pat::Ident { 0: _field_0 } => {
                <BindingIdent as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Pat::Array { 0: _field_0 } => {
                <ArrayPat as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Pat::Rest { 0: _field_0 } => {
                <RestPat as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Pat::Object { 0: _field_0 } => {
                <ObjectPat as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Pat::Assign { 0: _field_0 } => {
                <AssignPat as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Pat::Invalid { 0: _field_0 } => {
                <Invalid as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Pat::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for PrivateName {
    #[doc = "Calls [VisitAstPath`::visit_private_name`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_private_name(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            PrivateName { span, name } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for PrivateProp {
    #[doc = "Calls [VisitAstPath`::visit_private_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_private_prop(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            PrivateProp {
                span,
                ctxt,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_optional,
                is_override,
                readonly,
                definite,
            } => {
                <PrivateName as VisitWithAstPath<V>>::visit_with_ast_path(key, visitor, ast_path);
                <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    value, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                <Vec<Decorator> as VisitWithAstPath<V>>::visit_with_ast_path(
                    decorators, visitor, ast_path,
                );
                <Option<Accessibility> as VisitWithAstPath<V>>::visit_with_ast_path(
                    accessibility,
                    visitor,
                    ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Program {
    #[doc = "Calls [VisitAstPath`::visit_program`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_program(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Program::Module { 0: _field_0 } => {
                <Module as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Program::Script { 0: _field_0 } => {
                <Script as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Prop {
    #[doc = "Calls [VisitAstPath`::visit_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_prop(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Prop::Shorthand { 0: _field_0 } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Prop::KeyValue { 0: _field_0 } => {
                <KeyValueProp as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Prop::Assign { 0: _field_0 } => {
                <AssignProp as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Prop::Getter { 0: _field_0 } => {
                <GetterProp as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Prop::Setter { 0: _field_0 } => {
                <SetterProp as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Prop::Method { 0: _field_0 } => {
                <MethodProp as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for PropName {
    #[doc = "Calls [VisitAstPath`::visit_prop_name`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_prop_name(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            PropName::Ident { 0: _field_0 } => {
                <IdentName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            PropName::Str { 0: _field_0 } => {
                <Str as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            PropName::Num { 0: _field_0 } => {
                <Number as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            PropName::Computed { 0: _field_0 } => {
                <ComputedPropName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            PropName::BigInt { 0: _field_0 } => {
                <BigInt as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for PropOrSpread {
    #[doc = "Calls [VisitAstPath`::visit_prop_or_spread`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_prop_or_spread(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            PropOrSpread::Spread { 0: _field_0 } => {
                <SpreadElement as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            PropOrSpread::Prop { 0: _field_0 } => {
                <Box<Prop> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Regex {
    #[doc = "Calls [VisitAstPath`::visit_regex`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_regex(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Regex { span, exp, flags } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ReservedUnused {
    #[doc = "Calls [VisitAstPath`::visit_reserved_unused`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_reserved_unused(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ReservedUnused { span, body } => {
                <Option<Vec<ModuleItem>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for RestPat {
    #[doc = "Calls [VisitAstPath`::visit_rest_pat`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_rest_pat(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            RestPat {
                span,
                dot3_token,
                arg,
                type_ann,
            } => {
                <Box<Pat> as VisitWithAstPath<V>>::visit_with_ast_path(arg, visitor, ast_path);
                <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ReturnStmt {
    #[doc = "Calls [VisitAstPath`::visit_return_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_return_stmt(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ReturnStmt { span, arg } => {
                <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    arg, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Script {
    #[doc = "Calls [VisitAstPath`::visit_script`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_script(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Script {
                span,
                body,
                shebang,
            } => {
                <Vec<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(body, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for SeqExpr {
    #[doc = "Calls [VisitAstPath`::visit_seq_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_seq_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            SeqExpr { span, exprs } => {
                <Vec<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    exprs, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for SetterProp {
    #[doc = "Calls [VisitAstPath`::visit_setter_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_setter_prop(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            SetterProp {
                span,
                key,
                this_param,
                param,
                body,
            } => {
                <PropName as VisitWithAstPath<V>>::visit_with_ast_path(key, visitor, ast_path);
                <Option<Pat> as VisitWithAstPath<V>>::visit_with_ast_path(
                    this_param, visitor, ast_path,
                );
                <Box<Pat> as VisitWithAstPath<V>>::visit_with_ast_path(param, visitor, ast_path);
                <Option<BlockStmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for SimpleAssignTarget {
    #[doc = "Calls [VisitAstPath`::visit_simple_assign_target`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_simple_assign_target(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            SimpleAssignTarget::Ident { 0: _field_0 } => {
                <BindingIdent as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            SimpleAssignTarget::Member { 0: _field_0 } => {
                <MemberExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            SimpleAssignTarget::SuperProp { 0: _field_0 } => {
                <SuperPropExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            SimpleAssignTarget::Paren { 0: _field_0 } => {
                <ParenExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            SimpleAssignTarget::OptChain { 0: _field_0 } => {
                <OptChainExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            SimpleAssignTarget::TsAs { 0: _field_0 } => {
                <TsAsExpr as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            SimpleAssignTarget::TsSatisfies { 0: _field_0 } => {
                <TsSatisfiesExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            SimpleAssignTarget::TsNonNull { 0: _field_0 } => {
                <TsNonNullExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            SimpleAssignTarget::TsTypeAssertion { 0: _field_0 } => {
                <TsTypeAssertion as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            SimpleAssignTarget::TsInstantiation { 0: _field_0 } => {
                <TsInstantiation as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            SimpleAssignTarget::Invalid { 0: _field_0 } => {
                <Invalid as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for SpreadElement {
    #[doc = "Calls [VisitAstPath`::visit_spread_element`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_spread_element(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            SpreadElement { dot3_token, expr } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(expr, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for StaticBlock {
    #[doc = "Calls [VisitAstPath`::visit_static_block`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_static_block(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            StaticBlock { span, body } => {
                <BlockStmt as VisitWithAstPath<V>>::visit_with_ast_path(body, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Stmt {
    #[doc = "Calls [VisitAstPath`::visit_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_stmt(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Stmt::Block { 0: _field_0 } => {
                <BlockStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::Empty { 0: _field_0 } => {
                <EmptyStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::Debugger { 0: _field_0 } => {
                <DebuggerStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::With { 0: _field_0 } => {
                <WithStmt as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Stmt::Return { 0: _field_0 } => {
                <ReturnStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::Labeled { 0: _field_0 } => {
                <LabeledStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::Break { 0: _field_0 } => {
                <BreakStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::Continue { 0: _field_0 } => {
                <ContinueStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::If { 0: _field_0 } => {
                <IfStmt as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Stmt::Switch { 0: _field_0 } => {
                <SwitchStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::Throw { 0: _field_0 } => {
                <ThrowStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::Try { 0: _field_0 } => {
                <Box<TryStmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::While { 0: _field_0 } => {
                <WhileStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::DoWhile { 0: _field_0 } => {
                <DoWhileStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::For { 0: _field_0 } => {
                <ForStmt as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Stmt::ForIn { 0: _field_0 } => {
                <ForInStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::ForOf { 0: _field_0 } => {
                <ForOfStmt as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::Decl { 0: _field_0 } => {
                <Decl as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            Stmt::Expr { 0: _field_0 } => {
                <ExprStmt as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Str {
    #[doc = "Calls [VisitAstPath`::visit_str`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_str(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Str { span, value, raw } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Super {
    #[doc = "Calls [VisitAstPath`::visit_super`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_super(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Super { span } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for SuperProp {
    #[doc = "Calls [VisitAstPath`::visit_super_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_super_prop(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            SuperProp::Ident { 0: _field_0 } => {
                <IdentName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            SuperProp::Computed { 0: _field_0 } => {
                <ComputedPropName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for SuperPropExpr {
    #[doc = "Calls [VisitAstPath`::visit_super_prop_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_super_prop_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            SuperPropExpr { span, obj, prop } => {
                <Super as VisitWithAstPath<V>>::visit_with_ast_path(obj, visitor, ast_path);
                <SuperProp as VisitWithAstPath<V>>::visit_with_ast_path(prop, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for SwitchCase {
    #[doc = "Calls [VisitAstPath`::visit_switch_case`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_switch_case(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            SwitchCase { span, test, cons } => {
                <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    test, visitor, ast_path,
                );
                <Vec<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(cons, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for SwitchStmt {
    #[doc = "Calls [VisitAstPath`::visit_switch_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_switch_stmt(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            SwitchStmt {
                span,
                discriminant,
                cases,
            } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                    discriminant,
                    visitor,
                    ast_path,
                );
                <Vec<SwitchCase> as VisitWithAstPath<V>>::visit_with_ast_path(
                    cases, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TaggedTpl {
    #[doc = "Calls [VisitAstPath`::visit_tagged_tpl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_tagged_tpl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TaggedTpl {
                span,
                ctxt,
                tag,
                type_params,
                tpl,
            } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(tag, visitor, ast_path);
                <Option<Box<TsTypeParamInstantiation>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
                <Box<Tpl> as VisitWithAstPath<V>>::visit_with_ast_path(tpl, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ThisExpr {
    #[doc = "Calls [VisitAstPath`::visit_this_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_this_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ThisExpr { span } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ThrowStmt {
    #[doc = "Calls [VisitAstPath`::visit_throw_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_throw_stmt(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            ThrowStmt { span, arg } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(arg, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Tpl {
    #[doc = "Calls [VisitAstPath`::visit_tpl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_tpl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Tpl {
                span,
                exprs,
                quasis,
            } => {
                <Vec<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    exprs, visitor, ast_path,
                );
                <Vec<TplElement> as VisitWithAstPath<V>>::visit_with_ast_path(
                    quasis, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TplElement {
    #[doc = "Calls [VisitAstPath`::visit_tpl_element`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_tpl_element(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TplElement {
                span,
                tail,
                cooked,
                raw,
            } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TruePlusMinus {
    #[doc = "Calls [VisitAstPath`::visit_true_plus_minus`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_true_plus_minus(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TruePlusMinus::True => {}
            TruePlusMinus::Plus => {}
            TruePlusMinus::Minus => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TryStmt {
    #[doc = "Calls [VisitAstPath`::visit_try_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_try_stmt(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TryStmt {
                span,
                block,
                handler,
                finalizer,
            } => {
                <BlockStmt as VisitWithAstPath<V>>::visit_with_ast_path(block, visitor, ast_path);
                <Option<CatchClause> as VisitWithAstPath<V>>::visit_with_ast_path(
                    handler, visitor, ast_path,
                );
                <Option<BlockStmt> as VisitWithAstPath<V>>::visit_with_ast_path(
                    finalizer, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsArrayType {
    #[doc = "Calls [VisitAstPath`::visit_ts_array_type`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_array_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsArrayType { span, elem_type } => {
                <Box<TsType> as VisitWithAstPath<V>>::visit_with_ast_path(
                    elem_type, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsAsExpr {
    #[doc = "Calls [VisitAstPath`::visit_ts_as_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_as_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsAsExpr {
                span,
                expr,
                type_ann,
            } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(expr, visitor, ast_path);
                <Box<TsType> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsCallSignatureDecl {
    #[doc = "Calls [VisitAstPath`::visit_ts_call_signature_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_call_signature_decl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsCallSignatureDecl {
                span,
                params,
                type_ann,
                type_params,
            } => {
                <Vec<TsFnParam> as VisitWithAstPath<V>>::visit_with_ast_path(
                    params, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                <Option<Box<TsTypeParamDecl>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsConditionalType {
    #[doc = "Calls [VisitAstPath`::visit_ts_conditional_type`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_conditional_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsConditionalType {
                span,
                check_type,
                extends_type,
                true_type,
                false_type,
            } => {
                <Box<TsType> as VisitWithAstPath<V>>::visit_with_ast_path(
                    check_type, visitor, ast_path,
                );
                <Box<TsType> as VisitWithAstPath<V>>::visit_with_ast_path(
                    extends_type,
                    visitor,
                    ast_path,
                );
                <Box<TsType> as VisitWithAstPath<V>>::visit_with_ast_path(
                    true_type, visitor, ast_path,
                );
                <Box<TsType> as VisitWithAstPath<V>>::visit_with_ast_path(
                    false_type, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsConstAssertion {
    #[doc = "Calls [VisitAstPath`::visit_ts_const_assertion`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_const_assertion(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsConstAssertion { span, expr } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(expr, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsConstructSignatureDecl {
    #[doc = "Calls [VisitAstPath`::visit_ts_construct_signature_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_construct_signature_decl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsConstructSignatureDecl {
                span,
                params,
                type_ann,
                type_params,
            } => {
                <Vec<TsFnParam> as VisitWithAstPath<V>>::visit_with_ast_path(
                    params, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                <Option<Box<TsTypeParamDecl>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsConstructorType {
    #[doc = "Calls [VisitAstPath`::visit_ts_constructor_type`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_constructor_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsConstructorType {
                span,
                params,
                type_params,
                type_ann,
                is_abstract,
            } => {
                <Vec<TsFnParam> as VisitWithAstPath<V>>::visit_with_ast_path(
                    params, visitor, ast_path,
                );
                <Option<Box<TsTypeParamDecl>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
                <Box<TsTypeAnn> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsEntityName {
    #[doc = "Calls [VisitAstPath`::visit_ts_entity_name`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_entity_name(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsEntityName::TsQualifiedName { 0: _field_0 } => {
                <Box<TsQualifiedName> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsEntityName::Ident { 0: _field_0 } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsEnumDecl {
    #[doc = "Calls [VisitAstPath`::visit_ts_enum_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_enum_decl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsEnumDecl {
                span,
                declare,
                is_const,
                id,
                members,
            } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(id, visitor, ast_path);
                <Vec<TsEnumMember> as VisitWithAstPath<V>>::visit_with_ast_path(
                    members, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsEnumMember {
    #[doc = "Calls [VisitAstPath`::visit_ts_enum_member`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_enum_member(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsEnumMember { span, id, init } => {
                <TsEnumMemberId as VisitWithAstPath<V>>::visit_with_ast_path(id, visitor, ast_path);
                <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    init, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsEnumMemberId {
    #[doc = "Calls [VisitAstPath`::visit_ts_enum_member_id`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_enum_member_id(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsEnumMemberId::Ident { 0: _field_0 } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            TsEnumMemberId::Str { 0: _field_0 } => {
                <Str as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsExportAssignment {
    #[doc = "Calls [VisitAstPath`::visit_ts_export_assignment`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_export_assignment(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsExportAssignment { span, expr } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(expr, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsExprWithTypeArgs {
    #[doc = "Calls [VisitAstPath`::visit_ts_expr_with_type_args`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_expr_with_type_args(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsExprWithTypeArgs {
                span,
                expr,
                type_args,
            } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(expr, visitor, ast_path);
                <Option<Box<TsTypeParamInstantiation>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_args, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsExternalModuleRef {
    #[doc = "Calls [VisitAstPath`::visit_ts_external_module_ref`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_external_module_ref(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsExternalModuleRef { span, expr } => {
                <Str as VisitWithAstPath<V>>::visit_with_ast_path(expr, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsFnOrConstructorType {
    #[doc = "Calls [VisitAstPath`::visit_ts_fn_or_constructor_type`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_fn_or_constructor_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsFnOrConstructorType::TsFnType { 0: _field_0 } => {
                <TsFnType as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            TsFnOrConstructorType::TsConstructorType { 0: _field_0 } => {
                <TsConstructorType as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsFnParam {
    #[doc = "Calls [VisitAstPath`::visit_ts_fn_param`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_fn_param(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsFnParam::Ident { 0: _field_0 } => {
                <BindingIdent as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsFnParam::Array { 0: _field_0 } => {
                <ArrayPat as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            TsFnParam::Rest { 0: _field_0 } => {
                <RestPat as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            TsFnParam::Object { 0: _field_0 } => {
                <ObjectPat as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsFnType {
    #[doc = "Calls [VisitAstPath`::visit_ts_fn_type`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_fn_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsFnType {
                span,
                params,
                type_params,
                type_ann,
            } => {
                <Vec<TsFnParam> as VisitWithAstPath<V>>::visit_with_ast_path(
                    params, visitor, ast_path,
                );
                <Option<Box<TsTypeParamDecl>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
                <Box<TsTypeAnn> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsGetterSignature {
    #[doc = "Calls [VisitAstPath`::visit_ts_getter_signature`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_getter_signature(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsGetterSignature {
                span,
                key,
                computed,
                type_ann,
            } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(key, visitor, ast_path);
                <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsImportEqualsDecl {
    #[doc = "Calls [VisitAstPath`::visit_ts_import_equals_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_import_equals_decl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsImportEqualsDecl {
                span,
                is_export,
                is_type_only,
                id,
                module_ref,
            } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(id, visitor, ast_path);
                <TsModuleRef as VisitWithAstPath<V>>::visit_with_ast_path(
                    module_ref, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsImportType {
    #[doc = "Calls [VisitAstPath`::visit_ts_import_type`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_import_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsImportType {
                span,
                arg,
                qualifier,
                type_args,
            } => {
                <Str as VisitWithAstPath<V>>::visit_with_ast_path(arg, visitor, ast_path);
                <Option<TsEntityName> as VisitWithAstPath<V>>::visit_with_ast_path(
                    qualifier, visitor, ast_path,
                );
                <Option<Box<TsTypeParamInstantiation>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_args, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsIndexSignature {
    #[doc = "Calls [VisitAstPath`::visit_ts_index_signature`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_index_signature(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsIndexSignature {
                params,
                type_ann,
                readonly,
                is_static,
                span,
            } => {
                <Vec<TsFnParam> as VisitWithAstPath<V>>::visit_with_ast_path(
                    params, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsIndexedAccessType {
    #[doc = "Calls [VisitAstPath`::visit_ts_indexed_access_type`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_indexed_access_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsIndexedAccessType {
                span,
                readonly,
                obj_type,
                index_type,
            } => {
                <Box<TsType> as VisitWithAstPath<V>>::visit_with_ast_path(
                    obj_type, visitor, ast_path,
                );
                <Box<TsType> as VisitWithAstPath<V>>::visit_with_ast_path(
                    index_type, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsInferType {
    #[doc = "Calls [VisitAstPath`::visit_ts_infer_type`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_infer_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsInferType { span, type_param } => {
                <TsTypeParam as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_param, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsInstantiation {
    #[doc = "Calls [VisitAstPath`::visit_ts_instantiation`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_instantiation(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsInstantiation {
                span,
                expr,
                type_args,
            } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(expr, visitor, ast_path);
                <Box<TsTypeParamInstantiation> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_args, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsInterfaceBody {
    #[doc = "Calls [VisitAstPath`::visit_ts_interface_body`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_interface_body(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsInterfaceBody { span, body } => {
                <Vec<TsTypeElement> as VisitWithAstPath<V>>::visit_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsInterfaceDecl {
    #[doc = "Calls [VisitAstPath`::visit_ts_interface_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_interface_decl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsInterfaceDecl {
                span,
                id,
                declare,
                type_params,
                extends,
                body,
            } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(id, visitor, ast_path);
                <Option<Box<TsTypeParamDecl>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
                <Vec<TsExprWithTypeArgs> as VisitWithAstPath<V>>::visit_with_ast_path(
                    extends, visitor, ast_path,
                );
                <TsInterfaceBody as VisitWithAstPath<V>>::visit_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsIntersectionType {
    #[doc = "Calls [VisitAstPath`::visit_ts_intersection_type`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_intersection_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsIntersectionType { span, types } => {
                <Vec<Box<TsType>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    types, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsKeywordType {
    #[doc = "Calls [VisitAstPath`::visit_ts_keyword_type`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_keyword_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsKeywordType { span, kind } => {
                <TsKeywordTypeKind as VisitWithAstPath<V>>::visit_with_ast_path(
                    kind, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsKeywordTypeKind {
    #[doc = "Calls [VisitAstPath`::visit_ts_keyword_type_kind`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_keyword_type_kind(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsKeywordTypeKind::TsAnyKeyword => {}
            TsKeywordTypeKind::TsUnknownKeyword => {}
            TsKeywordTypeKind::TsNumberKeyword => {}
            TsKeywordTypeKind::TsObjectKeyword => {}
            TsKeywordTypeKind::TsBooleanKeyword => {}
            TsKeywordTypeKind::TsBigIntKeyword => {}
            TsKeywordTypeKind::TsStringKeyword => {}
            TsKeywordTypeKind::TsSymbolKeyword => {}
            TsKeywordTypeKind::TsVoidKeyword => {}
            TsKeywordTypeKind::TsUndefinedKeyword => {}
            TsKeywordTypeKind::TsNullKeyword => {}
            TsKeywordTypeKind::TsNeverKeyword => {}
            TsKeywordTypeKind::TsIntrinsicKeyword => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsLit {
    #[doc = "Calls [VisitAstPath`::visit_ts_lit`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_lit(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsLit::Number { 0: _field_0 } => {
                <Number as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            TsLit::Str { 0: _field_0 } => {
                <Str as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            TsLit::Bool { 0: _field_0 } => {
                <Bool as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            TsLit::BigInt { 0: _field_0 } => {
                <BigInt as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            TsLit::Tpl { 0: _field_0 } => {
                <TsTplLitType as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsLitType {
    #[doc = "Calls [VisitAstPath`::visit_ts_lit_type`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_lit_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsLitType { span, lit } => {
                <TsLit as VisitWithAstPath<V>>::visit_with_ast_path(lit, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsMappedType {
    #[doc = "Calls [VisitAstPath`::visit_ts_mapped_type`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_mapped_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsMappedType {
                span,
                readonly,
                type_param,
                name_type,
                optional,
                type_ann,
            } => {
                <Option<TruePlusMinus> as VisitWithAstPath<V>>::visit_with_ast_path(
                    readonly, visitor, ast_path,
                );
                <TsTypeParam as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_param, visitor, ast_path,
                );
                <Option<Box<TsType>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    name_type, visitor, ast_path,
                );
                <Option<TruePlusMinus> as VisitWithAstPath<V>>::visit_with_ast_path(
                    optional, visitor, ast_path,
                );
                <Option<Box<TsType>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsMethodSignature {
    #[doc = "Calls [VisitAstPath`::visit_ts_method_signature`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_method_signature(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsMethodSignature {
                span,
                key,
                computed,
                optional,
                params,
                type_ann,
                type_params,
            } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(key, visitor, ast_path);
                <Vec<TsFnParam> as VisitWithAstPath<V>>::visit_with_ast_path(
                    params, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                <Option<Box<TsTypeParamDecl>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsModuleBlock {
    #[doc = "Calls [VisitAstPath`::visit_ts_module_block`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_module_block(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsModuleBlock { span, body } => {
                <Vec<ModuleItem> as VisitWithAstPath<V>>::visit_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsModuleDecl {
    #[doc = "Calls [VisitAstPath`::visit_ts_module_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_module_decl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsModuleDecl {
                span,
                declare,
                global,
                id,
                body,
            } => {
                <TsModuleName as VisitWithAstPath<V>>::visit_with_ast_path(id, visitor, ast_path);
                <Option<TsNamespaceBody> as VisitWithAstPath<V>>::visit_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsModuleName {
    #[doc = "Calls [VisitAstPath`::visit_ts_module_name`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_module_name(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsModuleName::Ident { 0: _field_0 } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
            TsModuleName::Str { 0: _field_0 } => {
                <Str as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsModuleRef {
    #[doc = "Calls [VisitAstPath`::visit_ts_module_ref`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_module_ref(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsModuleRef::TsEntityName { 0: _field_0 } => {
                <TsEntityName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsModuleRef::TsExternalModuleRef { 0: _field_0 } => {
                <TsExternalModuleRef as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsNamespaceBody {
    #[doc = "Calls [VisitAstPath`::visit_ts_namespace_body`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_namespace_body(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsNamespaceBody::TsModuleBlock { 0: _field_0 } => {
                <TsModuleBlock as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsNamespaceBody::TsNamespaceDecl { 0: _field_0 } => {
                <TsNamespaceDecl as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsNamespaceDecl {
    #[doc = "Calls [VisitAstPath`::visit_ts_namespace_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_namespace_decl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsNamespaceDecl {
                span,
                declare,
                global,
                id,
                body,
            } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(id, visitor, ast_path);
                <Box<TsNamespaceBody> as VisitWithAstPath<V>>::visit_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsNamespaceExportDecl {
    #[doc = "Calls [VisitAstPath`::visit_ts_namespace_export_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_namespace_export_decl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsNamespaceExportDecl { span, id } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(id, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsNonNullExpr {
    #[doc = "Calls [VisitAstPath`::visit_ts_non_null_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_non_null_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsNonNullExpr { span, expr } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(expr, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsOptionalType {
    #[doc = "Calls [VisitAstPath`::visit_ts_optional_type`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_optional_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsOptionalType { span, type_ann } => {
                <Box<TsType> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsParamProp {
    #[doc = "Calls [VisitAstPath`::visit_ts_param_prop`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_param_prop(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsParamProp {
                span,
                decorators,
                accessibility,
                is_override,
                readonly,
                param,
            } => {
                <Vec<Decorator> as VisitWithAstPath<V>>::visit_with_ast_path(
                    decorators, visitor, ast_path,
                );
                <Option<Accessibility> as VisitWithAstPath<V>>::visit_with_ast_path(
                    accessibility,
                    visitor,
                    ast_path,
                );
                <TsParamPropParam as VisitWithAstPath<V>>::visit_with_ast_path(
                    param, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsParamPropParam {
    #[doc = "Calls [VisitAstPath`::visit_ts_param_prop_param`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_param_prop_param(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsParamPropParam::Ident { 0: _field_0 } => {
                <BindingIdent as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsParamPropParam::Assign { 0: _field_0 } => {
                <AssignPat as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsParenthesizedType {
    #[doc = "Calls [VisitAstPath`::visit_ts_parenthesized_type`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_parenthesized_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsParenthesizedType { span, type_ann } => {
                <Box<TsType> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsPropertySignature {
    #[doc = "Calls [VisitAstPath`::visit_ts_property_signature`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_property_signature(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsPropertySignature {
                span,
                readonly,
                key,
                computed,
                optional,
                type_ann,
            } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(key, visitor, ast_path);
                <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsQualifiedName {
    #[doc = "Calls [VisitAstPath`::visit_ts_qualified_name`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_qualified_name(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsQualifiedName { span, left, right } => {
                <TsEntityName as VisitWithAstPath<V>>::visit_with_ast_path(left, visitor, ast_path);
                <IdentName as VisitWithAstPath<V>>::visit_with_ast_path(right, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsRestType {
    #[doc = "Calls [VisitAstPath`::visit_ts_rest_type`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_rest_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsRestType { span, type_ann } => {
                <Box<TsType> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsSatisfiesExpr {
    #[doc = "Calls [VisitAstPath`::visit_ts_satisfies_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_satisfies_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsSatisfiesExpr {
                span,
                expr,
                type_ann,
            } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(expr, visitor, ast_path);
                <Box<TsType> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsSetterSignature {
    #[doc = "Calls [VisitAstPath`::visit_ts_setter_signature`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_setter_signature(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsSetterSignature {
                span,
                key,
                computed,
                param,
            } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(key, visitor, ast_path);
                <TsFnParam as VisitWithAstPath<V>>::visit_with_ast_path(param, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsThisType {
    #[doc = "Calls [VisitAstPath`::visit_ts_this_type`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_this_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsThisType { span } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsThisTypeOrIdent {
    #[doc = "Calls [VisitAstPath`::visit_ts_this_type_or_ident`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_this_type_or_ident(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsThisTypeOrIdent::TsThisType { 0: _field_0 } => {
                <TsThisType as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsThisTypeOrIdent::Ident { 0: _field_0 } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(_field_0, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsTplLitType {
    #[doc = "Calls [VisitAstPath`::visit_ts_tpl_lit_type`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_tpl_lit_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsTplLitType {
                span,
                types,
                quasis,
            } => {
                <Vec<Box<TsType>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    types, visitor, ast_path,
                );
                <Vec<TplElement> as VisitWithAstPath<V>>::visit_with_ast_path(
                    quasis, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsTupleElement {
    #[doc = "Calls [VisitAstPath`::visit_ts_tuple_element`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_tuple_element(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsTupleElement { span, label, ty } => {
                <Option<Pat> as VisitWithAstPath<V>>::visit_with_ast_path(label, visitor, ast_path);
                <Box<TsType> as VisitWithAstPath<V>>::visit_with_ast_path(ty, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsTupleType {
    #[doc = "Calls [VisitAstPath`::visit_ts_tuple_type`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_tuple_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsTupleType { span, elem_types } => {
                <Vec<TsTupleElement> as VisitWithAstPath<V>>::visit_with_ast_path(
                    elem_types, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsType {
    #[doc = "Calls [VisitAstPath`::visit_ts_type`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsType::TsKeywordType { 0: _field_0 } => {
                <TsKeywordType as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsThisType { 0: _field_0 } => {
                <TsThisType as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsFnOrConstructorType { 0: _field_0 } => {
                <TsFnOrConstructorType as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsTypeRef { 0: _field_0 } => {
                <TsTypeRef as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsTypeQuery { 0: _field_0 } => {
                <TsTypeQuery as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsTypeLit { 0: _field_0 } => {
                <TsTypeLit as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsArrayType { 0: _field_0 } => {
                <TsArrayType as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsTupleType { 0: _field_0 } => {
                <TsTupleType as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsOptionalType { 0: _field_0 } => {
                <TsOptionalType as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsRestType { 0: _field_0 } => {
                <TsRestType as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsUnionOrIntersectionType { 0: _field_0 } => {
                <TsUnionOrIntersectionType as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsConditionalType { 0: _field_0 } => {
                <TsConditionalType as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsInferType { 0: _field_0 } => {
                <TsInferType as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsParenthesizedType { 0: _field_0 } => {
                <TsParenthesizedType as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsTypeOperator { 0: _field_0 } => {
                <TsTypeOperator as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsIndexedAccessType { 0: _field_0 } => {
                <TsIndexedAccessType as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsMappedType { 0: _field_0 } => {
                <TsMappedType as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsLitType { 0: _field_0 } => {
                <TsLitType as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsTypePredicate { 0: _field_0 } => {
                <TsTypePredicate as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsImportType { 0: _field_0 } => {
                <TsImportType as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsTypeAliasDecl {
    #[doc = "Calls [VisitAstPath`::visit_ts_type_alias_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_type_alias_decl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsTypeAliasDecl {
                span,
                declare,
                id,
                type_params,
                type_ann,
            } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(id, visitor, ast_path);
                <Option<Box<TsTypeParamDecl>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
                <Box<TsType> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsTypeAnn {
    #[doc = "Calls [VisitAstPath`::visit_ts_type_ann`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_type_ann(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsTypeAnn { span, type_ann } => {
                <Box<TsType> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsTypeAssertion {
    #[doc = "Calls [VisitAstPath`::visit_ts_type_assertion`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_type_assertion(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsTypeAssertion {
                span,
                expr,
                type_ann,
            } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(expr, visitor, ast_path);
                <Box<TsType> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsTypeElement {
    #[doc = "Calls [VisitAstPath`::visit_ts_type_element`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_type_element(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsTypeElement::TsCallSignatureDecl { 0: _field_0 } => {
                <TsCallSignatureDecl as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsTypeElement::TsConstructSignatureDecl { 0: _field_0 } => {
                <TsConstructSignatureDecl as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsTypeElement::TsPropertySignature { 0: _field_0 } => {
                <TsPropertySignature as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsTypeElement::TsGetterSignature { 0: _field_0 } => {
                <TsGetterSignature as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsTypeElement::TsSetterSignature { 0: _field_0 } => {
                <TsSetterSignature as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsTypeElement::TsMethodSignature { 0: _field_0 } => {
                <TsMethodSignature as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsTypeElement::TsIndexSignature { 0: _field_0 } => {
                <TsIndexSignature as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsTypeLit {
    #[doc = "Calls [VisitAstPath`::visit_ts_type_lit`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_type_lit(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsTypeLit { span, members } => {
                <Vec<TsTypeElement> as VisitWithAstPath<V>>::visit_with_ast_path(
                    members, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsTypeOperator {
    #[doc = "Calls [VisitAstPath`::visit_ts_type_operator`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_type_operator(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsTypeOperator { span, op, type_ann } => {
                <TsTypeOperatorOp as VisitWithAstPath<V>>::visit_with_ast_path(
                    op, visitor, ast_path,
                );
                <Box<TsType> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsTypeOperatorOp {
    #[doc = "Calls [VisitAstPath`::visit_ts_type_operator_op`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_type_operator_op(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsTypeOperatorOp::KeyOf => {}
            TsTypeOperatorOp::Unique => {}
            TsTypeOperatorOp::ReadOnly => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsTypeParam {
    #[doc = "Calls [VisitAstPath`::visit_ts_type_param`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_type_param(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsTypeParam {
                span,
                name,
                is_in,
                is_out,
                is_const,
                constraint,
                default,
            } => {
                <Ident as VisitWithAstPath<V>>::visit_with_ast_path(name, visitor, ast_path);
                <Option<Box<TsType>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    constraint, visitor, ast_path,
                );
                <Option<Box<TsType>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    default, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsTypeParamDecl {
    #[doc = "Calls [VisitAstPath`::visit_ts_type_param_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_type_param_decl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsTypeParamDecl { span, params } => {
                <Vec<TsTypeParam> as VisitWithAstPath<V>>::visit_with_ast_path(
                    params, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsTypeParamInstantiation {
    #[doc = "Calls [VisitAstPath`::visit_ts_type_param_instantiation`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_type_param_instantiation(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsTypeParamInstantiation { span, params } => {
                <Vec<Box<TsType>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    params, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsTypePredicate {
    #[doc = "Calls [VisitAstPath`::visit_ts_type_predicate`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_type_predicate(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsTypePredicate {
                span,
                asserts,
                param_name,
                type_ann,
            } => {
                <TsThisTypeOrIdent as VisitWithAstPath<V>>::visit_with_ast_path(
                    param_name, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsTypeQuery {
    #[doc = "Calls [VisitAstPath`::visit_ts_type_query`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_type_query(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsTypeQuery {
                span,
                expr_name,
                type_args,
            } => {
                <TsTypeQueryExpr as VisitWithAstPath<V>>::visit_with_ast_path(
                    expr_name, visitor, ast_path,
                );
                <Option<Box<TsTypeParamInstantiation>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_args, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsTypeQueryExpr {
    #[doc = "Calls [VisitAstPath`::visit_ts_type_query_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_type_query_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsTypeQueryExpr::TsEntityName { 0: _field_0 } => {
                <TsEntityName as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsTypeQueryExpr::Import { 0: _field_0 } => {
                <TsImportType as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsTypeRef {
    #[doc = "Calls [VisitAstPath`::visit_ts_type_ref`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_type_ref(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsTypeRef {
                span,
                type_name,
                type_params,
            } => {
                <TsEntityName as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_name, visitor, ast_path,
                );
                <Option<Box<TsTypeParamInstantiation>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsUnionOrIntersectionType {
    #[doc = "Calls [VisitAstPath`::visit_ts_union_or_intersection_type`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_union_or_intersection_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsUnionOrIntersectionType::TsUnionType { 0: _field_0 } => {
                <TsUnionType as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsUnionOrIntersectionType::TsIntersectionType { 0: _field_0 } => {
                <TsIntersectionType as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for TsUnionType {
    #[doc = "Calls [VisitAstPath`::visit_ts_union_type`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_union_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            TsUnionType { span, types } => {
                <Vec<Box<TsType>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    types, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for UnaryExpr {
    #[doc = "Calls [VisitAstPath`::visit_unary_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_unary_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            UnaryExpr { span, op, arg } => {
                <UnaryOp as VisitWithAstPath<V>>::visit_with_ast_path(op, visitor, ast_path);
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(arg, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for UnaryOp {
    #[doc = "Calls [VisitAstPath`::visit_unary_op`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_unary_op(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            UnaryOp::Minus => {}
            UnaryOp::Plus => {}
            UnaryOp::Bang => {}
            UnaryOp::Tilde => {}
            UnaryOp::TypeOf => {}
            UnaryOp::Void => {}
            UnaryOp::Delete => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for UpdateExpr {
    #[doc = "Calls [VisitAstPath`::visit_update_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_update_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            UpdateExpr {
                span,
                op,
                prefix,
                arg,
            } => {
                <UpdateOp as VisitWithAstPath<V>>::visit_with_ast_path(op, visitor, ast_path);
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(arg, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for UpdateOp {
    #[doc = "Calls [VisitAstPath`::visit_update_op`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_update_op(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            UpdateOp::PlusPlus => {}
            UpdateOp::MinusMinus => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for UsingDecl {
    #[doc = "Calls [VisitAstPath`::visit_using_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_using_decl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            UsingDecl {
                span,
                is_await,
                decls,
            } => {
                <Vec<VarDeclarator> as VisitWithAstPath<V>>::visit_with_ast_path(
                    decls, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for VarDecl {
    #[doc = "Calls [VisitAstPath`::visit_var_decl`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_var_decl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            VarDecl {
                span,
                ctxt,
                kind,
                declare,
                decls,
            } => {
                <VarDeclKind as VisitWithAstPath<V>>::visit_with_ast_path(kind, visitor, ast_path);
                <Vec<VarDeclarator> as VisitWithAstPath<V>>::visit_with_ast_path(
                    decls, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for VarDeclKind {
    #[doc = "Calls [VisitAstPath`::visit_var_decl_kind`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_var_decl_kind(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            VarDeclKind::Var => {}
            VarDeclKind::Let => {}
            VarDeclKind::Const => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for VarDeclOrExpr {
    #[doc = "Calls [VisitAstPath`::visit_var_decl_or_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_var_decl_or_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            VarDeclOrExpr::VarDecl { 0: _field_0 } => {
                <Box<VarDecl> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            VarDeclOrExpr::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for VarDeclarator {
    #[doc = "Calls [VisitAstPath`::visit_var_declarator`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_var_declarator(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            VarDeclarator {
                span,
                name,
                init,
                definite,
            } => {
                <Pat as VisitWithAstPath<V>>::visit_with_ast_path(name, visitor, ast_path);
                <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    init, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for WhileStmt {
    #[doc = "Calls [VisitAstPath`::visit_while_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_while_stmt(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            WhileStmt { span, test, body } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(test, visitor, ast_path);
                <Box<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(body, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for WithStmt {
    #[doc = "Calls [VisitAstPath`::visit_with_stmt`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_with_stmt(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            WithStmt { span, obj, body } => {
                <Box<Expr> as VisitWithAstPath<V>>::visit_with_ast_path(obj, visitor, ast_path);
                <Box<Stmt> as VisitWithAstPath<V>>::visit_with_ast_path(body, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for YieldExpr {
    #[doc = "Calls [VisitAstPath`::visit_yield_expr`] with `self`."]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_yield_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            YieldExpr {
                span,
                arg,
                delegate,
            } => {
                <Option<Box<Expr>> as VisitWithAstPath<V>>::visit_with_ast_path(
                    arg, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for swc_atoms::Atom {
    #[doc = "Calls [VisitAstPath`::visit_atom`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_atom(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for BigIntValue {
    #[doc = "Calls [VisitAstPath`::visit_big_int_value`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_big_int_value(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [ClassMember] {
    #[doc = "Calls [VisitAstPath`::visit_class_members`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_members(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <ClassMember as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for ClassMethod {
    #[doc = "Calls [VisitAstPath`::visit_class_method`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_class_method(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [Decorator] {
    #[doc = "Calls [VisitAstPath`::visit_decorators`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_decorators(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <Decorator as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [ExportSpecifier] {
    #[doc = "Calls [VisitAstPath`::visit_export_specifiers`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_export_specifiers(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <ExportSpecifier as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [ExprOrSpread] {
    #[doc = "Calls [VisitAstPath`::visit_expr_or_spreads`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_expr_or_spreads(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <ExprOrSpread as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [Box<Expr>] {
    #[doc = "Calls [VisitAstPath`::visit_exprs`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_exprs(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <Box<Expr> as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [ImportSpecifier] {
    #[doc = "Calls [VisitAstPath`::visit_import_specifiers`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_specifiers(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <ImportSpecifier as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [ImportWithItem] {
    #[doc = "Calls [VisitAstPath`::visit_import_with_items`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_import_with_items(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <ImportWithItem as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [JSXAttrOrSpread] {
    #[doc = "Calls [VisitAstPath`::visit_jsx_attr_or_spreads`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_attr_or_spreads(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <JSXAttrOrSpread as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [JSXElementChild] {
    #[doc = "Calls [VisitAstPath`::visit_jsx_element_childs`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_jsx_element_childs(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <JSXElementChild as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [ModuleItem] {
    #[doc = "Calls [VisitAstPath`::visit_module_items`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_module_items(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <ModuleItem as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [ObjectPatProp] {
    #[doc = "Calls [VisitAstPath`::visit_object_pat_props`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_object_pat_props(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <ObjectPatProp as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<Accessibility> {
    #[doc = "Calls [VisitAstPath`::visit_opt_accessibility`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_accessibility(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <Accessibility as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<swc_atoms::Atom> {
    #[doc = "Calls [VisitAstPath`::visit_opt_atom`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_atom(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <swc_atoms::Atom as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<BlockStmt> {
    #[doc = "Calls [VisitAstPath`::visit_opt_block_stmt`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_block_stmt(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => <BlockStmt as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<CatchClause> {
    #[doc = "Calls [VisitAstPath`::visit_opt_catch_clause`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_catch_clause(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <CatchClause as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<Box<Expr>> {
    #[doc = "Calls [VisitAstPath`::visit_opt_expr`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => <Box<Expr> as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<ExprOrSpread> {
    #[doc = "Calls [VisitAstPath`::visit_opt_expr_or_spread`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_expr_or_spread(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <ExprOrSpread as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<Vec<ExprOrSpread>> {
    #[doc = "Calls [VisitAstPath`::visit_opt_expr_or_spreads`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_expr_or_spreads(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <Vec<ExprOrSpread> as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<Ident> {
    #[doc = "Calls [VisitAstPath`::visit_opt_ident`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_ident(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => <Ident as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<JSXAttrValue> {
    #[doc = "Calls [VisitAstPath`::visit_opt_jsx_attr_value`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_jsx_attr_value(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <JSXAttrValue as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<JSXClosingElement> {
    #[doc = "Calls [VisitAstPath`::visit_opt_jsx_closing_element`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_jsx_closing_element(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <JSXClosingElement as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<ModuleExportName> {
    #[doc = "Calls [VisitAstPath`::visit_opt_module_export_name`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_module_export_name(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <ModuleExportName as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<Vec<ModuleItem>> {
    #[doc = "Calls [VisitAstPath`::visit_opt_module_items`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_module_items(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <Vec<ModuleItem> as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<Box<ObjectLit>> {
    #[doc = "Calls [VisitAstPath`::visit_opt_object_lit`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_object_lit(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <Box<ObjectLit> as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<Pat> {
    #[doc = "Calls [VisitAstPath`::visit_opt_pat`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_pat(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => <Pat as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<swc_common::Span> {
    #[doc = "Calls [VisitAstPath`::visit_opt_span`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_span(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <swc_common::Span as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<Box<Stmt>> {
    #[doc = "Calls [VisitAstPath`::visit_opt_stmt`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_stmt(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => <Box<Stmt> as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<Box<Str>> {
    #[doc = "Calls [VisitAstPath`::visit_opt_str`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_str(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => <Box<Str> as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<TruePlusMinus> {
    #[doc = "Calls [VisitAstPath`::visit_opt_true_plus_minus`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_true_plus_minus(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <TruePlusMinus as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<TsEntityName> {
    #[doc = "Calls [VisitAstPath`::visit_opt_ts_entity_name`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_ts_entity_name(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <TsEntityName as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<TsNamespaceBody> {
    #[doc = "Calls [VisitAstPath`::visit_opt_ts_namespace_body`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_ts_namespace_body(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <TsNamespaceBody as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<Box<TsType>> {
    #[doc = "Calls [VisitAstPath`::visit_opt_ts_type`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_ts_type(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <Box<TsType> as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<Box<TsTypeAnn>> {
    #[doc = "Calls [VisitAstPath`::visit_opt_ts_type_ann`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_ts_type_ann(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <Box<TsTypeAnn> as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<Box<TsTypeParamDecl>> {
    #[doc = "Calls [VisitAstPath`::visit_opt_ts_type_param_decl`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_ts_type_param_decl(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <Box<TsTypeParamDecl> as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<Box<TsTypeParamInstantiation>> {
    #[doc = "Calls [VisitAstPath`::visit_opt_ts_type_param_instantiation`] with `self`. (Extra \
             impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_ts_type_param_instantiation(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => <Box<TsTypeParamInstantiation> as VisitWithAstPath<V>>::visit_with(
                inner, visitor, ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for Option<VarDeclOrExpr> {
    #[doc = "Calls [VisitAstPath`::visit_opt_var_decl_or_expr`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_var_decl_or_expr(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        match self {
            Some(inner) => {
                <VarDeclOrExpr as VisitWithAstPath<V>>::visit_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [Option<ExprOrSpread>] {
    #[doc = "Calls [VisitAstPath`::visit_opt_vec_expr_or_spreads`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_vec_expr_or_spreads(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <Option<ExprOrSpread> as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [Option<Pat>] {
    #[doc = "Calls [VisitAstPath`::visit_opt_vec_pats`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_opt_vec_pats(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <Option<Pat> as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [ParamOrTsParamProp] {
    #[doc = "Calls [VisitAstPath`::visit_param_or_ts_param_props`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_param_or_ts_param_props(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <ParamOrTsParamProp as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [Param] {
    #[doc = "Calls [VisitAstPath`::visit_params`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_params(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter()
            .for_each(|item| <Param as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path))
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [Pat] {
    #[doc = "Calls [VisitAstPath`::visit_pats`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_pats(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter()
            .for_each(|item| <Pat as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path))
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for PrivateMethod {
    #[doc = "Calls [VisitAstPath`::visit_private_method`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_private_method(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [PropOrSpread] {
    #[doc = "Calls [VisitAstPath`::visit_prop_or_spreads`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_prop_or_spreads(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <PropOrSpread as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for swc_common::Span {
    #[doc = "Calls [VisitAstPath`::visit_span`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_span(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [Stmt] {
    #[doc = "Calls [VisitAstPath`::visit_stmts`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_stmts(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter()
            .for_each(|item| <Stmt as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path))
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [SwitchCase] {
    #[doc = "Calls [VisitAstPath`::visit_switch_cases`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_switch_cases(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <SwitchCase as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for swc_common::SyntaxContext {
    #[doc = "Calls [VisitAstPath`::visit_syntax_context`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_syntax_context(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [TplElement] {
    #[doc = "Calls [VisitAstPath`::visit_tpl_elements`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_tpl_elements(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <TplElement as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [TsEnumMember] {
    #[doc = "Calls [VisitAstPath`::visit_ts_enum_members`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_enum_members(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <TsEnumMember as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [TsExprWithTypeArgs] {
    #[doc = "Calls [VisitAstPath`::visit_ts_expr_with_type_argss`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_expr_with_type_argss(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <TsExprWithTypeArgs as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [TsFnParam] {
    #[doc = "Calls [VisitAstPath`::visit_ts_fn_params`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_fn_params(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <TsFnParam as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [TsTupleElement] {
    #[doc = "Calls [VisitAstPath`::visit_ts_tuple_elements`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_tuple_elements(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <TsTupleElement as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [TsTypeElement] {
    #[doc = "Calls [VisitAstPath`::visit_ts_type_elements`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_type_elements(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <TsTypeElement as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [TsTypeParam] {
    #[doc = "Calls [VisitAstPath`::visit_ts_type_params`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_type_params(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <TsTypeParam as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [Box<TsType>] {
    #[doc = "Calls [VisitAstPath`::visit_ts_types`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_ts_types(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <Box<TsType> as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitAstPath> VisitWithAstPath<V> for [VarDeclarator] {
    #[doc = "Calls [VisitAstPath`::visit_var_declarators`] with `self`. (Extra impl)"]
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        <V as VisitAstPath>::visit_var_declarators(visitor, self, ast_path)
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        self.iter().for_each(|item| {
            <VarDeclarator as VisitWithAstPath<V>>::visit_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V, T> VisitWithAstPath<V> for std::boxed::Box<T>
where
    V: ?Sized + VisitAstPath,
    T: VisitWithAstPath<V>,
{
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        let v = <T as VisitWithAstPath<V>>::visit_with_ast_path(&**self, visitor, ast_path);
        v
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        let v =
            <T as VisitWithAstPath<V>>::visit_children_with_ast_path(&**self, visitor, ast_path);
        v
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V, T> VisitWithAstPath<V> for std::vec::Vec<T>
where
    V: ?Sized + VisitAstPath,
    [T]: VisitWithAstPath<V>,
{
    fn visit_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        let v = <[T] as VisitWithAstPath<V>>::visit_with_ast_path(self, visitor, ast_path);
        v
    }

    fn visit_children_with_ast_path<'ast: 'r, 'r>(
        &'ast self,
        visitor: &mut V,
        ast_path: &mut AstNodePath<'r>,
    ) {
        let v = <[T] as VisitWithAstPath<V>>::visit_children_with_ast_path(self, visitor, ast_path);
        v
    }
}
#[doc = r" A visitor trait for traversing the AST."]
pub trait VisitMut {
    #[doc = "Visit a node of type `Accessibility`.\n\nBy default, this method calls \
             [`Accessibility::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_accessibility(&mut self, node: &mut Accessibility) {
        <Accessibility as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ArrayLit`.\n\nBy default, this method calls \
             [`ArrayLit::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_array_lit(&mut self, node: &mut ArrayLit) {
        <ArrayLit as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ArrayPat`.\n\nBy default, this method calls \
             [`ArrayPat::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_array_pat(&mut self, node: &mut ArrayPat) {
        <ArrayPat as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ArrowExpr`.\n\nBy default, this method calls \
             [`ArrowExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_arrow_expr(&mut self, node: &mut ArrowExpr) {
        <ArrowExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignExpr`.\n\nBy default, this method calls \
             [`AssignExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_assign_expr(&mut self, node: &mut AssignExpr) {
        <AssignExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignOp`.\n\nBy default, this method calls \
             [`AssignOp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_assign_op(&mut self, node: &mut AssignOp) {
        <AssignOp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignPat`.\n\nBy default, this method calls \
             [`AssignPat::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_assign_pat(&mut self, node: &mut AssignPat) {
        <AssignPat as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignPatProp`.\n\nBy default, this method calls \
             [`AssignPatProp::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_assign_pat_prop(&mut self, node: &mut AssignPatProp) {
        <AssignPatProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignProp`.\n\nBy default, this method calls \
             [`AssignProp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_assign_prop(&mut self, node: &mut AssignProp) {
        <AssignProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignTarget`.\n\nBy default, this method calls \
             [`AssignTarget::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_assign_target(&mut self, node: &mut AssignTarget) {
        <AssignTarget as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignTargetPat`.\n\nBy default, this method calls \
             [`AssignTargetPat::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_assign_target_pat(&mut self, node: &mut AssignTargetPat) {
        <AssignTargetPat as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_atoms :: Atom`.\n\nBy default, this method calls \
             [`swc_atoms :: Atom::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom) {
        <swc_atoms::Atom as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `AutoAccessor`.\n\nBy default, this method calls \
             [`AutoAccessor::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_auto_accessor(&mut self, node: &mut AutoAccessor) {
        <AutoAccessor as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `AwaitExpr`.\n\nBy default, this method calls \
             [`AwaitExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_await_expr(&mut self, node: &mut AwaitExpr) {
        <AwaitExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `BigInt`.\n\nBy default, this method calls \
             [`BigInt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_big_int(&mut self, node: &mut BigInt) {
        <BigInt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `BigIntValue`.\n\nBy default, this method calls \
             [`BigIntValue::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_big_int_value(&mut self, node: &mut BigIntValue) {
        <BigIntValue as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `BinExpr`.\n\nBy default, this method calls \
             [`BinExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_bin_expr(&mut self, node: &mut BinExpr) {
        <BinExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `BinaryOp`.\n\nBy default, this method calls \
             [`BinaryOp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_binary_op(&mut self, node: &mut BinaryOp) {
        <BinaryOp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `BindingIdent`.\n\nBy default, this method calls \
             [`BindingIdent::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_binding_ident(&mut self, node: &mut BindingIdent) {
        <BindingIdent as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `BlockStmt`.\n\nBy default, this method calls \
             [`BlockStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_block_stmt(&mut self, node: &mut BlockStmt) {
        <BlockStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `BlockStmtOrExpr`.\n\nBy default, this method calls \
             [`BlockStmtOrExpr::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_block_stmt_or_expr(&mut self, node: &mut BlockStmtOrExpr) {
        <BlockStmtOrExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Bool`.\n\nBy default, this method calls \
             [`Bool::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_bool(&mut self, node: &mut Bool) {
        <Bool as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `BreakStmt`.\n\nBy default, this method calls \
             [`BreakStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_break_stmt(&mut self, node: &mut BreakStmt) {
        <BreakStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `CallExpr`.\n\nBy default, this method calls \
             [`CallExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_call_expr(&mut self, node: &mut CallExpr) {
        <CallExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Callee`.\n\nBy default, this method calls \
             [`Callee::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_callee(&mut self, node: &mut Callee) {
        <Callee as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `CatchClause`.\n\nBy default, this method calls \
             [`CatchClause::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_catch_clause(&mut self, node: &mut CatchClause) {
        <CatchClause as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Class`.\n\nBy default, this method calls \
             [`Class::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_class(&mut self, node: &mut Class) {
        <Class as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassDecl`.\n\nBy default, this method calls \
             [`ClassDecl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_class_decl(&mut self, node: &mut ClassDecl) {
        <ClassDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassExpr`.\n\nBy default, this method calls \
             [`ClassExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_class_expr(&mut self, node: &mut ClassExpr) {
        <ClassExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassMember`.\n\nBy default, this method calls \
             [`ClassMember::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_class_member(&mut self, node: &mut ClassMember) {
        <ClassMember as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ClassMember >`.\n\nBy default, this method calls [`Vec < \
             ClassMember >::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_class_members(&mut self, node: &mut Vec<ClassMember>) {
        <Vec<ClassMember> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassMethod`.\n\nBy default, this method calls \
             [`ClassMethod::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_class_method(&mut self, node: &mut ClassMethod) {
        <ClassMethod as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassProp`.\n\nBy default, this method calls \
             [`ClassProp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_class_prop(&mut self, node: &mut ClassProp) {
        <ClassProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ComputedPropName`.\n\nBy default, this method calls \
             [`ComputedPropName::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_computed_prop_name(&mut self, node: &mut ComputedPropName) {
        <ComputedPropName as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `CondExpr`.\n\nBy default, this method calls \
             [`CondExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_cond_expr(&mut self, node: &mut CondExpr) {
        <CondExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Constructor`.\n\nBy default, this method calls \
             [`Constructor::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_constructor(&mut self, node: &mut Constructor) {
        <Constructor as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ContinueStmt`.\n\nBy default, this method calls \
             [`ContinueStmt::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_continue_stmt(&mut self, node: &mut ContinueStmt) {
        <ContinueStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `DebuggerStmt`.\n\nBy default, this method calls \
             [`DebuggerStmt::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_debugger_stmt(&mut self, node: &mut DebuggerStmt) {
        <DebuggerStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Decl`.\n\nBy default, this method calls \
             [`Decl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_decl(&mut self, node: &mut Decl) {
        <Decl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Decorator`.\n\nBy default, this method calls \
             [`Decorator::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_decorator(&mut self, node: &mut Decorator) {
        <Decorator as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Decorator >`.\n\nBy default, this method calls [`Vec < \
             Decorator >::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_decorators(&mut self, node: &mut Vec<Decorator>) {
        <Vec<Decorator> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `DefaultDecl`.\n\nBy default, this method calls \
             [`DefaultDecl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_default_decl(&mut self, node: &mut DefaultDecl) {
        <DefaultDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `DoWhileStmt`.\n\nBy default, this method calls \
             [`DoWhileStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_do_while_stmt(&mut self, node: &mut DoWhileStmt) {
        <DoWhileStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `EmptyStmt`.\n\nBy default, this method calls \
             [`EmptyStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_empty_stmt(&mut self, node: &mut EmptyStmt) {
        <EmptyStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `EsVersion`.\n\nBy default, this method calls \
             [`EsVersion::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_es_version(&mut self, node: &mut EsVersion) {
        <EsVersion as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportAll`.\n\nBy default, this method calls \
             [`ExportAll::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_export_all(&mut self, node: &mut ExportAll) {
        <ExportAll as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDecl`.\n\nBy default, this method calls \
             [`ExportDecl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_export_decl(&mut self, node: &mut ExportDecl) {
        <ExportDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDefaultDecl`.\n\nBy default, this method calls \
             [`ExportDefaultDecl::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_export_default_decl(&mut self, node: &mut ExportDefaultDecl) {
        <ExportDefaultDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDefaultExpr`.\n\nBy default, this method calls \
             [`ExportDefaultExpr::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_export_default_expr(&mut self, node: &mut ExportDefaultExpr) {
        <ExportDefaultExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ExportDefaultSpecifier::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_export_default_specifier(&mut self, node: &mut ExportDefaultSpecifier) {
        <ExportDefaultSpecifier as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportNamedSpecifier`.\n\nBy default, this method calls \
             [`ExportNamedSpecifier::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_export_named_specifier(&mut self, node: &mut ExportNamedSpecifier) {
        <ExportNamedSpecifier as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportNamespaceSpecifier`.\n\nBy default, this method calls \
             [`ExportNamespaceSpecifier::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_export_namespace_specifier(&mut self, node: &mut ExportNamespaceSpecifier) {
        <ExportNamespaceSpecifier as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportSpecifier`.\n\nBy default, this method calls \
             [`ExportSpecifier::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_export_specifier(&mut self, node: &mut ExportSpecifier) {
        <ExportSpecifier as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ExportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ExportSpecifier >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_export_specifiers(&mut self, node: &mut Vec<ExportSpecifier>) {
        <Vec<ExportSpecifier> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Expr`.\n\nBy default, this method calls \
             [`Expr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_expr(&mut self, node: &mut Expr) {
        <Expr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExprOrSpread`.\n\nBy default, this method calls \
             [`ExprOrSpread::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_expr_or_spread(&mut self, node: &mut ExprOrSpread) {
        <ExprOrSpread as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ExprOrSpread >`.\n\nBy default, this method calls [`Vec < \
             ExprOrSpread >::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_expr_or_spreads(&mut self, node: &mut Vec<ExprOrSpread>) {
        <Vec<ExprOrSpread> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExprStmt`.\n\nBy default, this method calls \
             [`ExprStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_expr_stmt(&mut self, node: &mut ExprStmt) {
        <ExprStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Box < Expr > >`.\n\nBy default, this method calls [`Vec < \
             Box < Expr > >::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_exprs(&mut self, node: &mut Vec<Box<Expr>>) {
        <Vec<Box<Expr>> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `FnDecl`.\n\nBy default, this method calls \
             [`FnDecl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_fn_decl(&mut self, node: &mut FnDecl) {
        <FnDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `FnExpr`.\n\nBy default, this method calls \
             [`FnExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_fn_expr(&mut self, node: &mut FnExpr) {
        <FnExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForHead`.\n\nBy default, this method calls \
             [`ForHead::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_for_head(&mut self, node: &mut ForHead) {
        <ForHead as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForInStmt`.\n\nBy default, this method calls \
             [`ForInStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_for_in_stmt(&mut self, node: &mut ForInStmt) {
        <ForInStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForOfStmt`.\n\nBy default, this method calls \
             [`ForOfStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_for_of_stmt(&mut self, node: &mut ForOfStmt) {
        <ForOfStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForStmt`.\n\nBy default, this method calls \
             [`ForStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_for_stmt(&mut self, node: &mut ForStmt) {
        <ForStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Function`.\n\nBy default, this method calls \
             [`Function::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_function(&mut self, node: &mut Function) {
        <Function as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `GetterProp`.\n\nBy default, this method calls \
             [`GetterProp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_getter_prop(&mut self, node: &mut GetterProp) {
        <GetterProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Ident`.\n\nBy default, this method calls \
             [`Ident::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ident(&mut self, node: &mut Ident) {
        <Ident as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `IdentName`.\n\nBy default, this method calls \
             [`IdentName::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ident_name(&mut self, node: &mut IdentName) {
        <IdentName as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `IfStmt`.\n\nBy default, this method calls \
             [`IfStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_if_stmt(&mut self, node: &mut IfStmt) {
        <IfStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Import`.\n\nBy default, this method calls \
             [`Import::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_import(&mut self, node: &mut Import) {
        <Import as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportDecl`.\n\nBy default, this method calls \
             [`ImportDecl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_import_decl(&mut self, node: &mut ImportDecl) {
        <ImportDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ImportDefaultSpecifier::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_import_default_specifier(&mut self, node: &mut ImportDefaultSpecifier) {
        <ImportDefaultSpecifier as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportNamedSpecifier`.\n\nBy default, this method calls \
             [`ImportNamedSpecifier::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_import_named_specifier(&mut self, node: &mut ImportNamedSpecifier) {
        <ImportNamedSpecifier as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportPhase`.\n\nBy default, this method calls \
             [`ImportPhase::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_import_phase(&mut self, node: &mut ImportPhase) {
        <ImportPhase as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportSpecifier`.\n\nBy default, this method calls \
             [`ImportSpecifier::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_import_specifier(&mut self, node: &mut ImportSpecifier) {
        <ImportSpecifier as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ImportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ImportSpecifier >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_import_specifiers(&mut self, node: &mut Vec<ImportSpecifier>) {
        <Vec<ImportSpecifier> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportStarAsSpecifier`.\n\nBy default, this method calls \
             [`ImportStarAsSpecifier::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_import_star_as_specifier(&mut self, node: &mut ImportStarAsSpecifier) {
        <ImportStarAsSpecifier as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportWith`.\n\nBy default, this method calls \
             [`ImportWith::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_import_with(&mut self, node: &mut ImportWith) {
        <ImportWith as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportWithItem`.\n\nBy default, this method calls \
             [`ImportWithItem::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_import_with_item(&mut self, node: &mut ImportWithItem) {
        <ImportWithItem as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ImportWithItem >`.\n\nBy default, this method calls [`Vec \
             < ImportWithItem >::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_import_with_items(&mut self, node: &mut Vec<ImportWithItem>) {
        <Vec<ImportWithItem> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Invalid`.\n\nBy default, this method calls \
             [`Invalid::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_invalid(&mut self, node: &mut Invalid) {
        <Invalid as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttr`.\n\nBy default, this method calls \
             [`JSXAttr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_jsx_attr(&mut self, node: &mut JSXAttr) {
        <JSXAttr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttrName`.\n\nBy default, this method calls \
             [`JSXAttrName::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_jsx_attr_name(&mut self, node: &mut JSXAttrName) {
        <JSXAttrName as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttrOrSpread`.\n\nBy default, this method calls \
             [`JSXAttrOrSpread::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_jsx_attr_or_spread(&mut self, node: &mut JSXAttrOrSpread) {
        <JSXAttrOrSpread as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < JSXAttrOrSpread >`.\n\nBy default, this method calls \
             [`Vec < JSXAttrOrSpread >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_jsx_attr_or_spreads(&mut self, node: &mut Vec<JSXAttrOrSpread>) {
        <Vec<JSXAttrOrSpread> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttrValue`.\n\nBy default, this method calls \
             [`JSXAttrValue::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_jsx_attr_value(&mut self, node: &mut JSXAttrValue) {
        <JSXAttrValue as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXClosingElement`.\n\nBy default, this method calls \
             [`JSXClosingElement::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_jsx_closing_element(&mut self, node: &mut JSXClosingElement) {
        <JSXClosingElement as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXClosingFragment`.\n\nBy default, this method calls \
             [`JSXClosingFragment::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_jsx_closing_fragment(&mut self, node: &mut JSXClosingFragment) {
        <JSXClosingFragment as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXElement`.\n\nBy default, this method calls \
             [`JSXElement::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_jsx_element(&mut self, node: &mut JSXElement) {
        <JSXElement as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXElementChild`.\n\nBy default, this method calls \
             [`JSXElementChild::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_jsx_element_child(&mut self, node: &mut JSXElementChild) {
        <JSXElementChild as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < JSXElementChild >`.\n\nBy default, this method calls \
             [`Vec < JSXElementChild >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_jsx_element_childs(&mut self, node: &mut Vec<JSXElementChild>) {
        <Vec<JSXElementChild> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXElementName`.\n\nBy default, this method calls \
             [`JSXElementName::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_jsx_element_name(&mut self, node: &mut JSXElementName) {
        <JSXElementName as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXEmptyExpr`.\n\nBy default, this method calls \
             [`JSXEmptyExpr::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_jsx_empty_expr(&mut self, node: &mut JSXEmptyExpr) {
        <JSXEmptyExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXExpr`.\n\nBy default, this method calls \
             [`JSXExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_jsx_expr(&mut self, node: &mut JSXExpr) {
        <JSXExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXExprContainer`.\n\nBy default, this method calls \
             [`JSXExprContainer::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_jsx_expr_container(&mut self, node: &mut JSXExprContainer) {
        <JSXExprContainer as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXFragment`.\n\nBy default, this method calls \
             [`JSXFragment::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_jsx_fragment(&mut self, node: &mut JSXFragment) {
        <JSXFragment as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXMemberExpr`.\n\nBy default, this method calls \
             [`JSXMemberExpr::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_jsx_member_expr(&mut self, node: &mut JSXMemberExpr) {
        <JSXMemberExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXNamespacedName`.\n\nBy default, this method calls \
             [`JSXNamespacedName::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_jsx_namespaced_name(&mut self, node: &mut JSXNamespacedName) {
        <JSXNamespacedName as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXObject`.\n\nBy default, this method calls \
             [`JSXObject::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_jsx_object(&mut self, node: &mut JSXObject) {
        <JSXObject as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXOpeningElement`.\n\nBy default, this method calls \
             [`JSXOpeningElement::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_jsx_opening_element(&mut self, node: &mut JSXOpeningElement) {
        <JSXOpeningElement as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXOpeningFragment`.\n\nBy default, this method calls \
             [`JSXOpeningFragment::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_jsx_opening_fragment(&mut self, node: &mut JSXOpeningFragment) {
        <JSXOpeningFragment as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXSpreadChild`.\n\nBy default, this method calls \
             [`JSXSpreadChild::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_jsx_spread_child(&mut self, node: &mut JSXSpreadChild) {
        <JSXSpreadChild as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXText`.\n\nBy default, this method calls \
             [`JSXText::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_jsx_text(&mut self, node: &mut JSXText) {
        <JSXText as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Key`.\n\nBy default, this method calls \
             [`Key::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_key(&mut self, node: &mut Key) {
        <Key as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `KeyValuePatProp`.\n\nBy default, this method calls \
             [`KeyValuePatProp::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_key_value_pat_prop(&mut self, node: &mut KeyValuePatProp) {
        <KeyValuePatProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `KeyValueProp`.\n\nBy default, this method calls \
             [`KeyValueProp::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_key_value_prop(&mut self, node: &mut KeyValueProp) {
        <KeyValueProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `LabeledStmt`.\n\nBy default, this method calls \
             [`LabeledStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_labeled_stmt(&mut self, node: &mut LabeledStmt) {
        <LabeledStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Lit`.\n\nBy default, this method calls \
             [`Lit::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_lit(&mut self, node: &mut Lit) {
        <Lit as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `MemberExpr`.\n\nBy default, this method calls \
             [`MemberExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_member_expr(&mut self, node: &mut MemberExpr) {
        <MemberExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `MemberProp`.\n\nBy default, this method calls \
             [`MemberProp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_member_prop(&mut self, node: &mut MemberProp) {
        <MemberProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `MetaPropExpr`.\n\nBy default, this method calls \
             [`MetaPropExpr::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_meta_prop_expr(&mut self, node: &mut MetaPropExpr) {
        <MetaPropExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `MetaPropKind`.\n\nBy default, this method calls \
             [`MetaPropKind::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_meta_prop_kind(&mut self, node: &mut MetaPropKind) {
        <MetaPropKind as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `MethodKind`.\n\nBy default, this method calls \
             [`MethodKind::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_method_kind(&mut self, node: &mut MethodKind) {
        <MethodKind as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `MethodProp`.\n\nBy default, this method calls \
             [`MethodProp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_method_prop(&mut self, node: &mut MethodProp) {
        <MethodProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Module`.\n\nBy default, this method calls \
             [`Module::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_module(&mut self, node: &mut Module) {
        <Module as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ModuleDecl`.\n\nBy default, this method calls \
             [`ModuleDecl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_module_decl(&mut self, node: &mut ModuleDecl) {
        <ModuleDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ModuleExportName`.\n\nBy default, this method calls \
             [`ModuleExportName::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_module_export_name(&mut self, node: &mut ModuleExportName) {
        <ModuleExportName as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ModuleItem`.\n\nBy default, this method calls \
             [`ModuleItem::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_module_item(&mut self, node: &mut ModuleItem) {
        <ModuleItem as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ModuleItem >`.\n\nBy default, this method calls [`Vec < \
             ModuleItem >::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_module_items(&mut self, node: &mut Vec<ModuleItem>) {
        <Vec<ModuleItem> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `NamedExport`.\n\nBy default, this method calls \
             [`NamedExport::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_named_export(&mut self, node: &mut NamedExport) {
        <NamedExport as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `NewExpr`.\n\nBy default, this method calls \
             [`NewExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_new_expr(&mut self, node: &mut NewExpr) {
        <NewExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Null`.\n\nBy default, this method calls \
             [`Null::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_null(&mut self, node: &mut Null) {
        <Null as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Number`.\n\nBy default, this method calls \
             [`Number::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_number(&mut self, node: &mut Number) {
        <Number as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ObjectLit`.\n\nBy default, this method calls \
             [`ObjectLit::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_object_lit(&mut self, node: &mut ObjectLit) {
        <ObjectLit as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ObjectPat`.\n\nBy default, this method calls \
             [`ObjectPat::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_object_pat(&mut self, node: &mut ObjectPat) {
        <ObjectPat as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ObjectPatProp`.\n\nBy default, this method calls \
             [`ObjectPatProp::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_object_pat_prop(&mut self, node: &mut ObjectPatProp) {
        <ObjectPatProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ObjectPatProp >`.\n\nBy default, this method calls [`Vec \
             < ObjectPatProp >::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_object_pat_props(&mut self, node: &mut Vec<ObjectPatProp>) {
        <Vec<ObjectPatProp> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Accessibility >`.\n\nBy default, this method calls \
             [`Option < Accessibility >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_opt_accessibility(&mut self, node: &mut Option<Accessibility>) {
        <Option<Accessibility> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < swc_atoms :: Atom >`.\n\nBy default, this method calls \
             [`Option < swc_atoms :: Atom >::visit_mut_children_with`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_mut_opt_atom(&mut self, node: &mut Option<swc_atoms::Atom>) {
        <Option<swc_atoms::Atom> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < BlockStmt >`.\n\nBy default, this method calls \
             [`Option < BlockStmt >::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_opt_block_stmt(&mut self, node: &mut Option<BlockStmt>) {
        <Option<BlockStmt> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `OptCall`.\n\nBy default, this method calls \
             [`OptCall::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_opt_call(&mut self, node: &mut OptCall) {
        <OptCall as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < CatchClause >`.\n\nBy default, this method calls \
             [`Option < CatchClause >::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_opt_catch_clause(&mut self, node: &mut Option<CatchClause>) {
        <Option<CatchClause> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `OptChainBase`.\n\nBy default, this method calls \
             [`OptChainBase::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_opt_chain_base(&mut self, node: &mut OptChainBase) {
        <OptChainBase as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `OptChainExpr`.\n\nBy default, this method calls \
             [`OptChainExpr::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_opt_chain_expr(&mut self, node: &mut OptChainExpr) {
        <OptChainExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < Expr > >`.\n\nBy default, this method calls \
             [`Option < Box < Expr > >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_opt_expr(&mut self, node: &mut Option<Box<Expr>>) {
        <Option<Box<Expr>> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < ExprOrSpread >`.\n\nBy default, this method calls \
             [`Option < ExprOrSpread >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_opt_expr_or_spread(&mut self, node: &mut Option<ExprOrSpread>) {
        <Option<ExprOrSpread> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Vec < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Option < Vec < ExprOrSpread > >::visit_mut_children_with`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_opt_expr_or_spreads(&mut self, node: &mut Option<Vec<ExprOrSpread>>) {
        <Option<Vec<ExprOrSpread>> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Ident >`.\n\nBy default, this method calls [`Option < \
             Ident >::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_opt_ident(&mut self, node: &mut Option<Ident>) {
        <Option<Ident> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < JSXAttrValue >`.\n\nBy default, this method calls \
             [`Option < JSXAttrValue >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_opt_jsx_attr_value(&mut self, node: &mut Option<JSXAttrValue>) {
        <Option<JSXAttrValue> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < JSXClosingElement >`.\n\nBy default, this method calls \
             [`Option < JSXClosingElement >::visit_mut_children_with`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_mut_opt_jsx_closing_element(&mut self, node: &mut Option<JSXClosingElement>) {
        <Option<JSXClosingElement> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < ModuleExportName >`.\n\nBy default, this method calls \
             [`Option < ModuleExportName >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_opt_module_export_name(&mut self, node: &mut Option<ModuleExportName>) {
        <Option<ModuleExportName> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Vec < ModuleItem > >`.\n\nBy default, this method \
             calls [`Option < Vec < ModuleItem > >::visit_mut_children_with`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_opt_module_items(&mut self, node: &mut Option<Vec<ModuleItem>>) {
        <Option<Vec<ModuleItem>> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < ObjectLit > >`.\n\nBy default, this method calls \
             [`Option < Box < ObjectLit > >::visit_mut_children_with`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_mut_opt_object_lit(&mut self, node: &mut Option<Box<ObjectLit>>) {
        <Option<Box<ObjectLit>> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Pat >`.\n\nBy default, this method calls [`Option < \
             Pat >::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_opt_pat(&mut self, node: &mut Option<Pat>) {
        <Option<Pat> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < swc_common :: Span >`.\n\nBy default, this method \
             calls [`Option < swc_common :: Span >::visit_mut_children_with`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_opt_span(&mut self, node: &mut Option<swc_common::Span>) {
        <Option<swc_common::Span> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < Stmt > >`.\n\nBy default, this method calls \
             [`Option < Box < Stmt > >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_opt_stmt(&mut self, node: &mut Option<Box<Stmt>>) {
        <Option<Box<Stmt>> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < Str > >`.\n\nBy default, this method calls \
             [`Option < Box < Str > >::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_opt_str(&mut self, node: &mut Option<Box<Str>>) {
        <Option<Box<Str>> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < TruePlusMinus >`.\n\nBy default, this method calls \
             [`Option < TruePlusMinus >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_opt_true_plus_minus(&mut self, node: &mut Option<TruePlusMinus>) {
        <Option<TruePlusMinus> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < TsEntityName >`.\n\nBy default, this method calls \
             [`Option < TsEntityName >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_opt_ts_entity_name(&mut self, node: &mut Option<TsEntityName>) {
        <Option<TsEntityName> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < TsNamespaceBody >`.\n\nBy default, this method calls \
             [`Option < TsNamespaceBody >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_opt_ts_namespace_body(&mut self, node: &mut Option<TsNamespaceBody>) {
        <Option<TsNamespaceBody> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < TsType > >`.\n\nBy default, this method calls \
             [`Option < Box < TsType > >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_opt_ts_type(&mut self, node: &mut Option<Box<TsType>>) {
        <Option<Box<TsType>> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < TsTypeAnn > >`.\n\nBy default, this method calls \
             [`Option < Box < TsTypeAnn > >::visit_mut_children_with`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_mut_opt_ts_type_ann(&mut self, node: &mut Option<Box<TsTypeAnn>>) {
        <Option<Box<TsTypeAnn>> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < TsTypeParamDecl > >`.\n\nBy default, this method \
             calls [`Option < Box < TsTypeParamDecl > >::visit_mut_children_with`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_opt_ts_type_param_decl(&mut self, node: &mut Option<Box<TsTypeParamDecl>>) {
        <Option<Box<TsTypeParamDecl>> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < TsTypeParamInstantiation > >`.\n\nBy default, \
             this method calls [`Option < Box < TsTypeParamInstantiation > \
             >::visit_mut_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_mut_opt_ts_type_param_instantiation(
        &mut self,
        node: &mut Option<Box<TsTypeParamInstantiation>>,
    ) {
        <Option<Box<TsTypeParamInstantiation>> as VisitMutWith<Self>>::visit_mut_children_with(
            node, self,
        )
    }
    #[doc = "Visit a node of type `Option < VarDeclOrExpr >`.\n\nBy default, this method calls \
             [`Option < VarDeclOrExpr >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_opt_var_decl_or_expr(&mut self, node: &mut Option<VarDeclOrExpr>) {
        <Option<VarDeclOrExpr> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Option < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Vec < Option < ExprOrSpread > >::visit_mut_children_with`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_opt_vec_expr_or_spreads(&mut self, node: &mut Vec<Option<ExprOrSpread>>) {
        <Vec<Option<ExprOrSpread>> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Option < Pat > >`.\n\nBy default, this method calls [`Vec \
             < Option < Pat > >::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_opt_vec_pats(&mut self, node: &mut Vec<Option<Pat>>) {
        <Vec<Option<Pat>> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Param`.\n\nBy default, this method calls \
             [`Param::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_param(&mut self, node: &mut Param) {
        <Param as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ParamOrTsParamProp`.\n\nBy default, this method calls \
             [`ParamOrTsParamProp::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_param_or_ts_param_prop(&mut self, node: &mut ParamOrTsParamProp) {
        <ParamOrTsParamProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ParamOrTsParamProp >`.\n\nBy default, this method calls \
             [`Vec < ParamOrTsParamProp >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_param_or_ts_param_props(&mut self, node: &mut Vec<ParamOrTsParamProp>) {
        <Vec<ParamOrTsParamProp> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Param >`.\n\nBy default, this method calls [`Vec < Param \
             >::visit_mut_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_mut_params(&mut self, node: &mut Vec<Param>) {
        <Vec<Param> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ParenExpr`.\n\nBy default, this method calls \
             [`ParenExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_paren_expr(&mut self, node: &mut ParenExpr) {
        <ParenExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Pat`.\n\nBy default, this method calls \
             [`Pat::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_pat(&mut self, node: &mut Pat) {
        <Pat as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Pat >`.\n\nBy default, this method calls [`Vec < Pat \
             >::visit_mut_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_mut_pats(&mut self, node: &mut Vec<Pat>) {
        <Vec<Pat> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `PrivateMethod`.\n\nBy default, this method calls \
             [`PrivateMethod::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_private_method(&mut self, node: &mut PrivateMethod) {
        <PrivateMethod as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `PrivateName`.\n\nBy default, this method calls \
             [`PrivateName::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_private_name(&mut self, node: &mut PrivateName) {
        <PrivateName as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `PrivateProp`.\n\nBy default, this method calls \
             [`PrivateProp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_private_prop(&mut self, node: &mut PrivateProp) {
        <PrivateProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Program`.\n\nBy default, this method calls \
             [`Program::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_program(&mut self, node: &mut Program) {
        <Program as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Prop`.\n\nBy default, this method calls \
             [`Prop::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_prop(&mut self, node: &mut Prop) {
        <Prop as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `PropName`.\n\nBy default, this method calls \
             [`PropName::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_prop_name(&mut self, node: &mut PropName) {
        <PropName as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `PropOrSpread`.\n\nBy default, this method calls \
             [`PropOrSpread::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_prop_or_spread(&mut self, node: &mut PropOrSpread) {
        <PropOrSpread as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < PropOrSpread >`.\n\nBy default, this method calls [`Vec < \
             PropOrSpread >::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_prop_or_spreads(&mut self, node: &mut Vec<PropOrSpread>) {
        <Vec<PropOrSpread> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Regex`.\n\nBy default, this method calls \
             [`Regex::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_regex(&mut self, node: &mut Regex) {
        <Regex as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ReservedUnused`.\n\nBy default, this method calls \
             [`ReservedUnused::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_reserved_unused(&mut self, node: &mut ReservedUnused) {
        <ReservedUnused as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `RestPat`.\n\nBy default, this method calls \
             [`RestPat::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_rest_pat(&mut self, node: &mut RestPat) {
        <RestPat as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ReturnStmt`.\n\nBy default, this method calls \
             [`ReturnStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_return_stmt(&mut self, node: &mut ReturnStmt) {
        <ReturnStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Script`.\n\nBy default, this method calls \
             [`Script::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_script(&mut self, node: &mut Script) {
        <Script as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `SeqExpr`.\n\nBy default, this method calls \
             [`SeqExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_seq_expr(&mut self, node: &mut SeqExpr) {
        <SeqExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `SetterProp`.\n\nBy default, this method calls \
             [`SetterProp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_setter_prop(&mut self, node: &mut SetterProp) {
        <SetterProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `SimpleAssignTarget`.\n\nBy default, this method calls \
             [`SimpleAssignTarget::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_simple_assign_target(&mut self, node: &mut SimpleAssignTarget) {
        <SimpleAssignTarget as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_common :: Span`.\n\nBy default, this method calls \
             [`swc_common :: Span::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span) {
        <swc_common::Span as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `SpreadElement`.\n\nBy default, this method calls \
             [`SpreadElement::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_spread_element(&mut self, node: &mut SpreadElement) {
        <SpreadElement as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `StaticBlock`.\n\nBy default, this method calls \
             [`StaticBlock::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_static_block(&mut self, node: &mut StaticBlock) {
        <StaticBlock as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Stmt`.\n\nBy default, this method calls \
             [`Stmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_stmt(&mut self, node: &mut Stmt) {
        <Stmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Stmt >`.\n\nBy default, this method calls [`Vec < Stmt \
             >::visit_mut_children_with`]. If you want to recurse, you need to call it manually."]
    fn visit_mut_stmts(&mut self, node: &mut Vec<Stmt>) {
        <Vec<Stmt> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Str`.\n\nBy default, this method calls \
             [`Str::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_str(&mut self, node: &mut Str) {
        <Str as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Super`.\n\nBy default, this method calls \
             [`Super::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_super(&mut self, node: &mut Super) {
        <Super as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `SuperProp`.\n\nBy default, this method calls \
             [`SuperProp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_super_prop(&mut self, node: &mut SuperProp) {
        <SuperProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `SuperPropExpr`.\n\nBy default, this method calls \
             [`SuperPropExpr::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_super_prop_expr(&mut self, node: &mut SuperPropExpr) {
        <SuperPropExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `SwitchCase`.\n\nBy default, this method calls \
             [`SwitchCase::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_switch_case(&mut self, node: &mut SwitchCase) {
        <SwitchCase as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < SwitchCase >`.\n\nBy default, this method calls [`Vec < \
             SwitchCase >::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_switch_cases(&mut self, node: &mut Vec<SwitchCase>) {
        <Vec<SwitchCase> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `SwitchStmt`.\n\nBy default, this method calls \
             [`SwitchStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_switch_stmt(&mut self, node: &mut SwitchStmt) {
        <SwitchStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_common :: SyntaxContext`.\n\nBy default, this method calls \
             [`swc_common :: SyntaxContext::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_syntax_context(&mut self, node: &mut swc_common::SyntaxContext) {
        <swc_common::SyntaxContext as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TaggedTpl`.\n\nBy default, this method calls \
             [`TaggedTpl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_tagged_tpl(&mut self, node: &mut TaggedTpl) {
        <TaggedTpl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ThisExpr`.\n\nBy default, this method calls \
             [`ThisExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_this_expr(&mut self, node: &mut ThisExpr) {
        <ThisExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `ThrowStmt`.\n\nBy default, this method calls \
             [`ThrowStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_throw_stmt(&mut self, node: &mut ThrowStmt) {
        <ThrowStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Tpl`.\n\nBy default, this method calls \
             [`Tpl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_tpl(&mut self, node: &mut Tpl) {
        <Tpl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TplElement`.\n\nBy default, this method calls \
             [`TplElement::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_tpl_element(&mut self, node: &mut TplElement) {
        <TplElement as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TplElement >`.\n\nBy default, this method calls [`Vec < \
             TplElement >::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_tpl_elements(&mut self, node: &mut Vec<TplElement>) {
        <Vec<TplElement> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TruePlusMinus`.\n\nBy default, this method calls \
             [`TruePlusMinus::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_true_plus_minus(&mut self, node: &mut TruePlusMinus) {
        <TruePlusMinus as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TryStmt`.\n\nBy default, this method calls \
             [`TryStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_try_stmt(&mut self, node: &mut TryStmt) {
        <TryStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsArrayType`.\n\nBy default, this method calls \
             [`TsArrayType::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_array_type(&mut self, node: &mut TsArrayType) {
        <TsArrayType as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsAsExpr`.\n\nBy default, this method calls \
             [`TsAsExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_as_expr(&mut self, node: &mut TsAsExpr) {
        <TsAsExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsCallSignatureDecl`.\n\nBy default, this method calls \
             [`TsCallSignatureDecl::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_call_signature_decl(&mut self, node: &mut TsCallSignatureDecl) {
        <TsCallSignatureDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsConditionalType`.\n\nBy default, this method calls \
             [`TsConditionalType::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_conditional_type(&mut self, node: &mut TsConditionalType) {
        <TsConditionalType as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsConstAssertion`.\n\nBy default, this method calls \
             [`TsConstAssertion::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_const_assertion(&mut self, node: &mut TsConstAssertion) {
        <TsConstAssertion as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsConstructSignatureDecl`.\n\nBy default, this method calls \
             [`TsConstructSignatureDecl::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_construct_signature_decl(&mut self, node: &mut TsConstructSignatureDecl) {
        <TsConstructSignatureDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsConstructorType`.\n\nBy default, this method calls \
             [`TsConstructorType::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_constructor_type(&mut self, node: &mut TsConstructorType) {
        <TsConstructorType as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsEntityName`.\n\nBy default, this method calls \
             [`TsEntityName::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_ts_entity_name(&mut self, node: &mut TsEntityName) {
        <TsEntityName as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsEnumDecl`.\n\nBy default, this method calls \
             [`TsEnumDecl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_enum_decl(&mut self, node: &mut TsEnumDecl) {
        <TsEnumDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsEnumMember`.\n\nBy default, this method calls \
             [`TsEnumMember::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_ts_enum_member(&mut self, node: &mut TsEnumMember) {
        <TsEnumMember as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsEnumMemberId`.\n\nBy default, this method calls \
             [`TsEnumMemberId::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_ts_enum_member_id(&mut self, node: &mut TsEnumMemberId) {
        <TsEnumMemberId as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TsEnumMember >`.\n\nBy default, this method calls [`Vec < \
             TsEnumMember >::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_ts_enum_members(&mut self, node: &mut Vec<TsEnumMember>) {
        <Vec<TsEnumMember> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsExportAssignment`.\n\nBy default, this method calls \
             [`TsExportAssignment::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_export_assignment(&mut self, node: &mut TsExportAssignment) {
        <TsExportAssignment as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsExprWithTypeArgs`.\n\nBy default, this method calls \
             [`TsExprWithTypeArgs::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_expr_with_type_args(&mut self, node: &mut TsExprWithTypeArgs) {
        <TsExprWithTypeArgs as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TsExprWithTypeArgs >`.\n\nBy default, this method calls \
             [`Vec < TsExprWithTypeArgs >::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_expr_with_type_argss(&mut self, node: &mut Vec<TsExprWithTypeArgs>) {
        <Vec<TsExprWithTypeArgs> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsExternalModuleRef`.\n\nBy default, this method calls \
             [`TsExternalModuleRef::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_external_module_ref(&mut self, node: &mut TsExternalModuleRef) {
        <TsExternalModuleRef as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsFnOrConstructorType`.\n\nBy default, this method calls \
             [`TsFnOrConstructorType::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_fn_or_constructor_type(&mut self, node: &mut TsFnOrConstructorType) {
        <TsFnOrConstructorType as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsFnParam`.\n\nBy default, this method calls \
             [`TsFnParam::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_fn_param(&mut self, node: &mut TsFnParam) {
        <TsFnParam as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TsFnParam >`.\n\nBy default, this method calls [`Vec < \
             TsFnParam >::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_fn_params(&mut self, node: &mut Vec<TsFnParam>) {
        <Vec<TsFnParam> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsFnType`.\n\nBy default, this method calls \
             [`TsFnType::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_fn_type(&mut self, node: &mut TsFnType) {
        <TsFnType as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsGetterSignature`.\n\nBy default, this method calls \
             [`TsGetterSignature::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_getter_signature(&mut self, node: &mut TsGetterSignature) {
        <TsGetterSignature as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsImportEqualsDecl`.\n\nBy default, this method calls \
             [`TsImportEqualsDecl::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_import_equals_decl(&mut self, node: &mut TsImportEqualsDecl) {
        <TsImportEqualsDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsImportType`.\n\nBy default, this method calls \
             [`TsImportType::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_ts_import_type(&mut self, node: &mut TsImportType) {
        <TsImportType as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsIndexSignature`.\n\nBy default, this method calls \
             [`TsIndexSignature::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_index_signature(&mut self, node: &mut TsIndexSignature) {
        <TsIndexSignature as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsIndexedAccessType`.\n\nBy default, this method calls \
             [`TsIndexedAccessType::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_indexed_access_type(&mut self, node: &mut TsIndexedAccessType) {
        <TsIndexedAccessType as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsInferType`.\n\nBy default, this method calls \
             [`TsInferType::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_infer_type(&mut self, node: &mut TsInferType) {
        <TsInferType as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsInstantiation`.\n\nBy default, this method calls \
             [`TsInstantiation::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_instantiation(&mut self, node: &mut TsInstantiation) {
        <TsInstantiation as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsInterfaceBody`.\n\nBy default, this method calls \
             [`TsInterfaceBody::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_interface_body(&mut self, node: &mut TsInterfaceBody) {
        <TsInterfaceBody as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsInterfaceDecl`.\n\nBy default, this method calls \
             [`TsInterfaceDecl::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_interface_decl(&mut self, node: &mut TsInterfaceDecl) {
        <TsInterfaceDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsIntersectionType`.\n\nBy default, this method calls \
             [`TsIntersectionType::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_intersection_type(&mut self, node: &mut TsIntersectionType) {
        <TsIntersectionType as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsKeywordType`.\n\nBy default, this method calls \
             [`TsKeywordType::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_ts_keyword_type(&mut self, node: &mut TsKeywordType) {
        <TsKeywordType as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsKeywordTypeKind`.\n\nBy default, this method calls \
             [`TsKeywordTypeKind::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_keyword_type_kind(&mut self, node: &mut TsKeywordTypeKind) {
        <TsKeywordTypeKind as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsLit`.\n\nBy default, this method calls \
             [`TsLit::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_lit(&mut self, node: &mut TsLit) {
        <TsLit as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsLitType`.\n\nBy default, this method calls \
             [`TsLitType::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_lit_type(&mut self, node: &mut TsLitType) {
        <TsLitType as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsMappedType`.\n\nBy default, this method calls \
             [`TsMappedType::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_ts_mapped_type(&mut self, node: &mut TsMappedType) {
        <TsMappedType as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsMethodSignature`.\n\nBy default, this method calls \
             [`TsMethodSignature::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_method_signature(&mut self, node: &mut TsMethodSignature) {
        <TsMethodSignature as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsModuleBlock`.\n\nBy default, this method calls \
             [`TsModuleBlock::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_ts_module_block(&mut self, node: &mut TsModuleBlock) {
        <TsModuleBlock as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsModuleDecl`.\n\nBy default, this method calls \
             [`TsModuleDecl::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_ts_module_decl(&mut self, node: &mut TsModuleDecl) {
        <TsModuleDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsModuleName`.\n\nBy default, this method calls \
             [`TsModuleName::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_ts_module_name(&mut self, node: &mut TsModuleName) {
        <TsModuleName as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsModuleRef`.\n\nBy default, this method calls \
             [`TsModuleRef::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_module_ref(&mut self, node: &mut TsModuleRef) {
        <TsModuleRef as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsNamespaceBody`.\n\nBy default, this method calls \
             [`TsNamespaceBody::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_namespace_body(&mut self, node: &mut TsNamespaceBody) {
        <TsNamespaceBody as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsNamespaceDecl`.\n\nBy default, this method calls \
             [`TsNamespaceDecl::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_namespace_decl(&mut self, node: &mut TsNamespaceDecl) {
        <TsNamespaceDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsNamespaceExportDecl`.\n\nBy default, this method calls \
             [`TsNamespaceExportDecl::visit_mut_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_namespace_export_decl(&mut self, node: &mut TsNamespaceExportDecl) {
        <TsNamespaceExportDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsNonNullExpr`.\n\nBy default, this method calls \
             [`TsNonNullExpr::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_ts_non_null_expr(&mut self, node: &mut TsNonNullExpr) {
        <TsNonNullExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsOptionalType`.\n\nBy default, this method calls \
             [`TsOptionalType::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_ts_optional_type(&mut self, node: &mut TsOptionalType) {
        <TsOptionalType as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsParamProp`.\n\nBy default, this method calls \
             [`TsParamProp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_param_prop(&mut self, node: &mut TsParamProp) {
        <TsParamProp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsParamPropParam`.\n\nBy default, this method calls \
             [`TsParamPropParam::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_param_prop_param(&mut self, node: &mut TsParamPropParam) {
        <TsParamPropParam as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsParenthesizedType`.\n\nBy default, this method calls \
             [`TsParenthesizedType::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_parenthesized_type(&mut self, node: &mut TsParenthesizedType) {
        <TsParenthesizedType as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsPropertySignature`.\n\nBy default, this method calls \
             [`TsPropertySignature::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_property_signature(&mut self, node: &mut TsPropertySignature) {
        <TsPropertySignature as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsQualifiedName`.\n\nBy default, this method calls \
             [`TsQualifiedName::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_qualified_name(&mut self, node: &mut TsQualifiedName) {
        <TsQualifiedName as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsRestType`.\n\nBy default, this method calls \
             [`TsRestType::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_rest_type(&mut self, node: &mut TsRestType) {
        <TsRestType as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsSatisfiesExpr`.\n\nBy default, this method calls \
             [`TsSatisfiesExpr::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_satisfies_expr(&mut self, node: &mut TsSatisfiesExpr) {
        <TsSatisfiesExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsSetterSignature`.\n\nBy default, this method calls \
             [`TsSetterSignature::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_setter_signature(&mut self, node: &mut TsSetterSignature) {
        <TsSetterSignature as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsThisType`.\n\nBy default, this method calls \
             [`TsThisType::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_this_type(&mut self, node: &mut TsThisType) {
        <TsThisType as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsThisTypeOrIdent`.\n\nBy default, this method calls \
             [`TsThisTypeOrIdent::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_this_type_or_ident(&mut self, node: &mut TsThisTypeOrIdent) {
        <TsThisTypeOrIdent as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTplLitType`.\n\nBy default, this method calls \
             [`TsTplLitType::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_ts_tpl_lit_type(&mut self, node: &mut TsTplLitType) {
        <TsTplLitType as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTupleElement`.\n\nBy default, this method calls \
             [`TsTupleElement::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_ts_tuple_element(&mut self, node: &mut TsTupleElement) {
        <TsTupleElement as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TsTupleElement >`.\n\nBy default, this method calls [`Vec \
             < TsTupleElement >::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_tuple_elements(&mut self, node: &mut Vec<TsTupleElement>) {
        <Vec<TsTupleElement> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTupleType`.\n\nBy default, this method calls \
             [`TsTupleType::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_tuple_type(&mut self, node: &mut TsTupleType) {
        <TsTupleType as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsType`.\n\nBy default, this method calls \
             [`TsType::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_type(&mut self, node: &mut TsType) {
        <TsType as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeAliasDecl`.\n\nBy default, this method calls \
             [`TsTypeAliasDecl::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_type_alias_decl(&mut self, node: &mut TsTypeAliasDecl) {
        <TsTypeAliasDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeAnn`.\n\nBy default, this method calls \
             [`TsTypeAnn::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_type_ann(&mut self, node: &mut TsTypeAnn) {
        <TsTypeAnn as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeAssertion`.\n\nBy default, this method calls \
             [`TsTypeAssertion::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_type_assertion(&mut self, node: &mut TsTypeAssertion) {
        <TsTypeAssertion as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeElement`.\n\nBy default, this method calls \
             [`TsTypeElement::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_ts_type_element(&mut self, node: &mut TsTypeElement) {
        <TsTypeElement as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TsTypeElement >`.\n\nBy default, this method calls [`Vec \
             < TsTypeElement >::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_type_elements(&mut self, node: &mut Vec<TsTypeElement>) {
        <Vec<TsTypeElement> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeLit`.\n\nBy default, this method calls \
             [`TsTypeLit::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_type_lit(&mut self, node: &mut TsTypeLit) {
        <TsTypeLit as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeOperator`.\n\nBy default, this method calls \
             [`TsTypeOperator::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_ts_type_operator(&mut self, node: &mut TsTypeOperator) {
        <TsTypeOperator as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeOperatorOp`.\n\nBy default, this method calls \
             [`TsTypeOperatorOp::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_type_operator_op(&mut self, node: &mut TsTypeOperatorOp) {
        <TsTypeOperatorOp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeParam`.\n\nBy default, this method calls \
             [`TsTypeParam::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_type_param(&mut self, node: &mut TsTypeParam) {
        <TsTypeParam as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeParamDecl`.\n\nBy default, this method calls \
             [`TsTypeParamDecl::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_type_param_decl(&mut self, node: &mut TsTypeParamDecl) {
        <TsTypeParamDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeParamInstantiation`.\n\nBy default, this method calls \
             [`TsTypeParamInstantiation::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_type_param_instantiation(&mut self, node: &mut TsTypeParamInstantiation) {
        <TsTypeParamInstantiation as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TsTypeParam >`.\n\nBy default, this method calls [`Vec < \
             TsTypeParam >::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_type_params(&mut self, node: &mut Vec<TsTypeParam>) {
        <Vec<TsTypeParam> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypePredicate`.\n\nBy default, this method calls \
             [`TsTypePredicate::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_type_predicate(&mut self, node: &mut TsTypePredicate) {
        <TsTypePredicate as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeQuery`.\n\nBy default, this method calls \
             [`TsTypeQuery::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_type_query(&mut self, node: &mut TsTypeQuery) {
        <TsTypeQuery as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeQueryExpr`.\n\nBy default, this method calls \
             [`TsTypeQueryExpr::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_type_query_expr(&mut self, node: &mut TsTypeQueryExpr) {
        <TsTypeQueryExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeRef`.\n\nBy default, this method calls \
             [`TsTypeRef::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_type_ref(&mut self, node: &mut TsTypeRef) {
        <TsTypeRef as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Box < TsType > >`.\n\nBy default, this method calls [`Vec \
             < Box < TsType > >::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_types(&mut self, node: &mut Vec<Box<TsType>>) {
        <Vec<Box<TsType>> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsUnionOrIntersectionType`.\n\nBy default, this method calls \
             [`TsUnionOrIntersectionType::visit_mut_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_union_or_intersection_type(&mut self, node: &mut TsUnionOrIntersectionType) {
        <TsUnionOrIntersectionType as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsUnionType`.\n\nBy default, this method calls \
             [`TsUnionType::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_ts_union_type(&mut self, node: &mut TsUnionType) {
        <TsUnionType as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `UnaryExpr`.\n\nBy default, this method calls \
             [`UnaryExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_unary_expr(&mut self, node: &mut UnaryExpr) {
        <UnaryExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `UnaryOp`.\n\nBy default, this method calls \
             [`UnaryOp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_unary_op(&mut self, node: &mut UnaryOp) {
        <UnaryOp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `UpdateExpr`.\n\nBy default, this method calls \
             [`UpdateExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_update_expr(&mut self, node: &mut UpdateExpr) {
        <UpdateExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `UpdateOp`.\n\nBy default, this method calls \
             [`UpdateOp::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_update_op(&mut self, node: &mut UpdateOp) {
        <UpdateOp as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `UsingDecl`.\n\nBy default, this method calls \
             [`UsingDecl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_using_decl(&mut self, node: &mut UsingDecl) {
        <UsingDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDecl`.\n\nBy default, this method calls \
             [`VarDecl::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_var_decl(&mut self, node: &mut VarDecl) {
        <VarDecl as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDeclKind`.\n\nBy default, this method calls \
             [`VarDeclKind::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_var_decl_kind(&mut self, node: &mut VarDeclKind) {
        <VarDeclKind as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDeclOrExpr`.\n\nBy default, this method calls \
             [`VarDeclOrExpr::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_var_decl_or_expr(&mut self, node: &mut VarDeclOrExpr) {
        <VarDeclOrExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDeclarator`.\n\nBy default, this method calls \
             [`VarDeclarator::visit_mut_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_var_declarator(&mut self, node: &mut VarDeclarator) {
        <VarDeclarator as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < VarDeclarator >`.\n\nBy default, this method calls [`Vec \
             < VarDeclarator >::visit_mut_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_var_declarators(&mut self, node: &mut Vec<VarDeclarator>) {
        <Vec<VarDeclarator> as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `WhileStmt`.\n\nBy default, this method calls \
             [`WhileStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_while_stmt(&mut self, node: &mut WhileStmt) {
        <WhileStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `WithStmt`.\n\nBy default, this method calls \
             [`WithStmt::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_with_stmt(&mut self, node: &mut WithStmt) {
        <WithStmt as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
    #[doc = "Visit a node of type `YieldExpr`.\n\nBy default, this method calls \
             [`YieldExpr::visit_mut_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_yield_expr(&mut self, node: &mut YieldExpr) {
        <YieldExpr as VisitMutWith<Self>>::visit_mut_children_with(node, self)
    }
}
impl<V> VisitMut for &mut V
where
    V: ?Sized + VisitMut,
{
    fn visit_mut_accessibility(&mut self, node: &mut Accessibility) {
        VisitMut::visit_mut_accessibility(&mut **self, node)
    }

    fn visit_mut_array_lit(&mut self, node: &mut ArrayLit) {
        VisitMut::visit_mut_array_lit(&mut **self, node)
    }

    fn visit_mut_array_pat(&mut self, node: &mut ArrayPat) {
        VisitMut::visit_mut_array_pat(&mut **self, node)
    }

    fn visit_mut_arrow_expr(&mut self, node: &mut ArrowExpr) {
        VisitMut::visit_mut_arrow_expr(&mut **self, node)
    }

    fn visit_mut_assign_expr(&mut self, node: &mut AssignExpr) {
        VisitMut::visit_mut_assign_expr(&mut **self, node)
    }

    fn visit_mut_assign_op(&mut self, node: &mut AssignOp) {
        VisitMut::visit_mut_assign_op(&mut **self, node)
    }

    fn visit_mut_assign_pat(&mut self, node: &mut AssignPat) {
        VisitMut::visit_mut_assign_pat(&mut **self, node)
    }

    fn visit_mut_assign_pat_prop(&mut self, node: &mut AssignPatProp) {
        VisitMut::visit_mut_assign_pat_prop(&mut **self, node)
    }

    fn visit_mut_assign_prop(&mut self, node: &mut AssignProp) {
        VisitMut::visit_mut_assign_prop(&mut **self, node)
    }

    fn visit_mut_assign_target(&mut self, node: &mut AssignTarget) {
        VisitMut::visit_mut_assign_target(&mut **self, node)
    }

    fn visit_mut_assign_target_pat(&mut self, node: &mut AssignTargetPat) {
        VisitMut::visit_mut_assign_target_pat(&mut **self, node)
    }

    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom) {
        VisitMut::visit_mut_atom(&mut **self, node)
    }

    fn visit_mut_auto_accessor(&mut self, node: &mut AutoAccessor) {
        VisitMut::visit_mut_auto_accessor(&mut **self, node)
    }

    fn visit_mut_await_expr(&mut self, node: &mut AwaitExpr) {
        VisitMut::visit_mut_await_expr(&mut **self, node)
    }

    fn visit_mut_big_int(&mut self, node: &mut BigInt) {
        VisitMut::visit_mut_big_int(&mut **self, node)
    }

    fn visit_mut_big_int_value(&mut self, node: &mut BigIntValue) {
        VisitMut::visit_mut_big_int_value(&mut **self, node)
    }

    fn visit_mut_bin_expr(&mut self, node: &mut BinExpr) {
        VisitMut::visit_mut_bin_expr(&mut **self, node)
    }

    fn visit_mut_binary_op(&mut self, node: &mut BinaryOp) {
        VisitMut::visit_mut_binary_op(&mut **self, node)
    }

    fn visit_mut_binding_ident(&mut self, node: &mut BindingIdent) {
        VisitMut::visit_mut_binding_ident(&mut **self, node)
    }

    fn visit_mut_block_stmt(&mut self, node: &mut BlockStmt) {
        VisitMut::visit_mut_block_stmt(&mut **self, node)
    }

    fn visit_mut_block_stmt_or_expr(&mut self, node: &mut BlockStmtOrExpr) {
        VisitMut::visit_mut_block_stmt_or_expr(&mut **self, node)
    }

    fn visit_mut_bool(&mut self, node: &mut Bool) {
        VisitMut::visit_mut_bool(&mut **self, node)
    }

    fn visit_mut_break_stmt(&mut self, node: &mut BreakStmt) {
        VisitMut::visit_mut_break_stmt(&mut **self, node)
    }

    fn visit_mut_call_expr(&mut self, node: &mut CallExpr) {
        VisitMut::visit_mut_call_expr(&mut **self, node)
    }

    fn visit_mut_callee(&mut self, node: &mut Callee) {
        VisitMut::visit_mut_callee(&mut **self, node)
    }

    fn visit_mut_catch_clause(&mut self, node: &mut CatchClause) {
        VisitMut::visit_mut_catch_clause(&mut **self, node)
    }

    fn visit_mut_class(&mut self, node: &mut Class) {
        VisitMut::visit_mut_class(&mut **self, node)
    }

    fn visit_mut_class_decl(&mut self, node: &mut ClassDecl) {
        VisitMut::visit_mut_class_decl(&mut **self, node)
    }

    fn visit_mut_class_expr(&mut self, node: &mut ClassExpr) {
        VisitMut::visit_mut_class_expr(&mut **self, node)
    }

    fn visit_mut_class_member(&mut self, node: &mut ClassMember) {
        VisitMut::visit_mut_class_member(&mut **self, node)
    }

    fn visit_mut_class_members(&mut self, node: &mut Vec<ClassMember>) {
        VisitMut::visit_mut_class_members(&mut **self, node)
    }

    fn visit_mut_class_method(&mut self, node: &mut ClassMethod) {
        VisitMut::visit_mut_class_method(&mut **self, node)
    }

    fn visit_mut_class_prop(&mut self, node: &mut ClassProp) {
        VisitMut::visit_mut_class_prop(&mut **self, node)
    }

    fn visit_mut_computed_prop_name(&mut self, node: &mut ComputedPropName) {
        VisitMut::visit_mut_computed_prop_name(&mut **self, node)
    }

    fn visit_mut_cond_expr(&mut self, node: &mut CondExpr) {
        VisitMut::visit_mut_cond_expr(&mut **self, node)
    }

    fn visit_mut_constructor(&mut self, node: &mut Constructor) {
        VisitMut::visit_mut_constructor(&mut **self, node)
    }

    fn visit_mut_continue_stmt(&mut self, node: &mut ContinueStmt) {
        VisitMut::visit_mut_continue_stmt(&mut **self, node)
    }

    fn visit_mut_debugger_stmt(&mut self, node: &mut DebuggerStmt) {
        VisitMut::visit_mut_debugger_stmt(&mut **self, node)
    }

    fn visit_mut_decl(&mut self, node: &mut Decl) {
        VisitMut::visit_mut_decl(&mut **self, node)
    }

    fn visit_mut_decorator(&mut self, node: &mut Decorator) {
        VisitMut::visit_mut_decorator(&mut **self, node)
    }

    fn visit_mut_decorators(&mut self, node: &mut Vec<Decorator>) {
        VisitMut::visit_mut_decorators(&mut **self, node)
    }

    fn visit_mut_default_decl(&mut self, node: &mut DefaultDecl) {
        VisitMut::visit_mut_default_decl(&mut **self, node)
    }

    fn visit_mut_do_while_stmt(&mut self, node: &mut DoWhileStmt) {
        VisitMut::visit_mut_do_while_stmt(&mut **self, node)
    }

    fn visit_mut_empty_stmt(&mut self, node: &mut EmptyStmt) {
        VisitMut::visit_mut_empty_stmt(&mut **self, node)
    }

    fn visit_mut_es_version(&mut self, node: &mut EsVersion) {
        VisitMut::visit_mut_es_version(&mut **self, node)
    }

    fn visit_mut_export_all(&mut self, node: &mut ExportAll) {
        VisitMut::visit_mut_export_all(&mut **self, node)
    }

    fn visit_mut_export_decl(&mut self, node: &mut ExportDecl) {
        VisitMut::visit_mut_export_decl(&mut **self, node)
    }

    fn visit_mut_export_default_decl(&mut self, node: &mut ExportDefaultDecl) {
        VisitMut::visit_mut_export_default_decl(&mut **self, node)
    }

    fn visit_mut_export_default_expr(&mut self, node: &mut ExportDefaultExpr) {
        VisitMut::visit_mut_export_default_expr(&mut **self, node)
    }

    fn visit_mut_export_default_specifier(&mut self, node: &mut ExportDefaultSpecifier) {
        VisitMut::visit_mut_export_default_specifier(&mut **self, node)
    }

    fn visit_mut_export_named_specifier(&mut self, node: &mut ExportNamedSpecifier) {
        VisitMut::visit_mut_export_named_specifier(&mut **self, node)
    }

    fn visit_mut_export_namespace_specifier(&mut self, node: &mut ExportNamespaceSpecifier) {
        VisitMut::visit_mut_export_namespace_specifier(&mut **self, node)
    }

    fn visit_mut_export_specifier(&mut self, node: &mut ExportSpecifier) {
        VisitMut::visit_mut_export_specifier(&mut **self, node)
    }

    fn visit_mut_export_specifiers(&mut self, node: &mut Vec<ExportSpecifier>) {
        VisitMut::visit_mut_export_specifiers(&mut **self, node)
    }

    fn visit_mut_expr(&mut self, node: &mut Expr) {
        VisitMut::visit_mut_expr(&mut **self, node)
    }

    fn visit_mut_expr_or_spread(&mut self, node: &mut ExprOrSpread) {
        VisitMut::visit_mut_expr_or_spread(&mut **self, node)
    }

    fn visit_mut_expr_or_spreads(&mut self, node: &mut Vec<ExprOrSpread>) {
        VisitMut::visit_mut_expr_or_spreads(&mut **self, node)
    }

    fn visit_mut_expr_stmt(&mut self, node: &mut ExprStmt) {
        VisitMut::visit_mut_expr_stmt(&mut **self, node)
    }

    fn visit_mut_exprs(&mut self, node: &mut Vec<Box<Expr>>) {
        VisitMut::visit_mut_exprs(&mut **self, node)
    }

    fn visit_mut_fn_decl(&mut self, node: &mut FnDecl) {
        VisitMut::visit_mut_fn_decl(&mut **self, node)
    }

    fn visit_mut_fn_expr(&mut self, node: &mut FnExpr) {
        VisitMut::visit_mut_fn_expr(&mut **self, node)
    }

    fn visit_mut_for_head(&mut self, node: &mut ForHead) {
        VisitMut::visit_mut_for_head(&mut **self, node)
    }

    fn visit_mut_for_in_stmt(&mut self, node: &mut ForInStmt) {
        VisitMut::visit_mut_for_in_stmt(&mut **self, node)
    }

    fn visit_mut_for_of_stmt(&mut self, node: &mut ForOfStmt) {
        VisitMut::visit_mut_for_of_stmt(&mut **self, node)
    }

    fn visit_mut_for_stmt(&mut self, node: &mut ForStmt) {
        VisitMut::visit_mut_for_stmt(&mut **self, node)
    }

    fn visit_mut_function(&mut self, node: &mut Function) {
        VisitMut::visit_mut_function(&mut **self, node)
    }

    fn visit_mut_getter_prop(&mut self, node: &mut GetterProp) {
        VisitMut::visit_mut_getter_prop(&mut **self, node)
    }

    fn visit_mut_ident(&mut self, node: &mut Ident) {
        VisitMut::visit_mut_ident(&mut **self, node)
    }

    fn visit_mut_ident_name(&mut self, node: &mut IdentName) {
        VisitMut::visit_mut_ident_name(&mut **self, node)
    }

    fn visit_mut_if_stmt(&mut self, node: &mut IfStmt) {
        VisitMut::visit_mut_if_stmt(&mut **self, node)
    }

    fn visit_mut_import(&mut self, node: &mut Import) {
        VisitMut::visit_mut_import(&mut **self, node)
    }

    fn visit_mut_import_decl(&mut self, node: &mut ImportDecl) {
        VisitMut::visit_mut_import_decl(&mut **self, node)
    }

    fn visit_mut_import_default_specifier(&mut self, node: &mut ImportDefaultSpecifier) {
        VisitMut::visit_mut_import_default_specifier(&mut **self, node)
    }

    fn visit_mut_import_named_specifier(&mut self, node: &mut ImportNamedSpecifier) {
        VisitMut::visit_mut_import_named_specifier(&mut **self, node)
    }

    fn visit_mut_import_phase(&mut self, node: &mut ImportPhase) {
        VisitMut::visit_mut_import_phase(&mut **self, node)
    }

    fn visit_mut_import_specifier(&mut self, node: &mut ImportSpecifier) {
        VisitMut::visit_mut_import_specifier(&mut **self, node)
    }

    fn visit_mut_import_specifiers(&mut self, node: &mut Vec<ImportSpecifier>) {
        VisitMut::visit_mut_import_specifiers(&mut **self, node)
    }

    fn visit_mut_import_star_as_specifier(&mut self, node: &mut ImportStarAsSpecifier) {
        VisitMut::visit_mut_import_star_as_specifier(&mut **self, node)
    }

    fn visit_mut_import_with(&mut self, node: &mut ImportWith) {
        VisitMut::visit_mut_import_with(&mut **self, node)
    }

    fn visit_mut_import_with_item(&mut self, node: &mut ImportWithItem) {
        VisitMut::visit_mut_import_with_item(&mut **self, node)
    }

    fn visit_mut_import_with_items(&mut self, node: &mut Vec<ImportWithItem>) {
        VisitMut::visit_mut_import_with_items(&mut **self, node)
    }

    fn visit_mut_invalid(&mut self, node: &mut Invalid) {
        VisitMut::visit_mut_invalid(&mut **self, node)
    }

    fn visit_mut_jsx_attr(&mut self, node: &mut JSXAttr) {
        VisitMut::visit_mut_jsx_attr(&mut **self, node)
    }

    fn visit_mut_jsx_attr_name(&mut self, node: &mut JSXAttrName) {
        VisitMut::visit_mut_jsx_attr_name(&mut **self, node)
    }

    fn visit_mut_jsx_attr_or_spread(&mut self, node: &mut JSXAttrOrSpread) {
        VisitMut::visit_mut_jsx_attr_or_spread(&mut **self, node)
    }

    fn visit_mut_jsx_attr_or_spreads(&mut self, node: &mut Vec<JSXAttrOrSpread>) {
        VisitMut::visit_mut_jsx_attr_or_spreads(&mut **self, node)
    }

    fn visit_mut_jsx_attr_value(&mut self, node: &mut JSXAttrValue) {
        VisitMut::visit_mut_jsx_attr_value(&mut **self, node)
    }

    fn visit_mut_jsx_closing_element(&mut self, node: &mut JSXClosingElement) {
        VisitMut::visit_mut_jsx_closing_element(&mut **self, node)
    }

    fn visit_mut_jsx_closing_fragment(&mut self, node: &mut JSXClosingFragment) {
        VisitMut::visit_mut_jsx_closing_fragment(&mut **self, node)
    }

    fn visit_mut_jsx_element(&mut self, node: &mut JSXElement) {
        VisitMut::visit_mut_jsx_element(&mut **self, node)
    }

    fn visit_mut_jsx_element_child(&mut self, node: &mut JSXElementChild) {
        VisitMut::visit_mut_jsx_element_child(&mut **self, node)
    }

    fn visit_mut_jsx_element_childs(&mut self, node: &mut Vec<JSXElementChild>) {
        VisitMut::visit_mut_jsx_element_childs(&mut **self, node)
    }

    fn visit_mut_jsx_element_name(&mut self, node: &mut JSXElementName) {
        VisitMut::visit_mut_jsx_element_name(&mut **self, node)
    }

    fn visit_mut_jsx_empty_expr(&mut self, node: &mut JSXEmptyExpr) {
        VisitMut::visit_mut_jsx_empty_expr(&mut **self, node)
    }

    fn visit_mut_jsx_expr(&mut self, node: &mut JSXExpr) {
        VisitMut::visit_mut_jsx_expr(&mut **self, node)
    }

    fn visit_mut_jsx_expr_container(&mut self, node: &mut JSXExprContainer) {
        VisitMut::visit_mut_jsx_expr_container(&mut **self, node)
    }

    fn visit_mut_jsx_fragment(&mut self, node: &mut JSXFragment) {
        VisitMut::visit_mut_jsx_fragment(&mut **self, node)
    }

    fn visit_mut_jsx_member_expr(&mut self, node: &mut JSXMemberExpr) {
        VisitMut::visit_mut_jsx_member_expr(&mut **self, node)
    }

    fn visit_mut_jsx_namespaced_name(&mut self, node: &mut JSXNamespacedName) {
        VisitMut::visit_mut_jsx_namespaced_name(&mut **self, node)
    }

    fn visit_mut_jsx_object(&mut self, node: &mut JSXObject) {
        VisitMut::visit_mut_jsx_object(&mut **self, node)
    }

    fn visit_mut_jsx_opening_element(&mut self, node: &mut JSXOpeningElement) {
        VisitMut::visit_mut_jsx_opening_element(&mut **self, node)
    }

    fn visit_mut_jsx_opening_fragment(&mut self, node: &mut JSXOpeningFragment) {
        VisitMut::visit_mut_jsx_opening_fragment(&mut **self, node)
    }

    fn visit_mut_jsx_spread_child(&mut self, node: &mut JSXSpreadChild) {
        VisitMut::visit_mut_jsx_spread_child(&mut **self, node)
    }

    fn visit_mut_jsx_text(&mut self, node: &mut JSXText) {
        VisitMut::visit_mut_jsx_text(&mut **self, node)
    }

    fn visit_mut_key(&mut self, node: &mut Key) {
        VisitMut::visit_mut_key(&mut **self, node)
    }

    fn visit_mut_key_value_pat_prop(&mut self, node: &mut KeyValuePatProp) {
        VisitMut::visit_mut_key_value_pat_prop(&mut **self, node)
    }

    fn visit_mut_key_value_prop(&mut self, node: &mut KeyValueProp) {
        VisitMut::visit_mut_key_value_prop(&mut **self, node)
    }

    fn visit_mut_labeled_stmt(&mut self, node: &mut LabeledStmt) {
        VisitMut::visit_mut_labeled_stmt(&mut **self, node)
    }

    fn visit_mut_lit(&mut self, node: &mut Lit) {
        VisitMut::visit_mut_lit(&mut **self, node)
    }

    fn visit_mut_member_expr(&mut self, node: &mut MemberExpr) {
        VisitMut::visit_mut_member_expr(&mut **self, node)
    }

    fn visit_mut_member_prop(&mut self, node: &mut MemberProp) {
        VisitMut::visit_mut_member_prop(&mut **self, node)
    }

    fn visit_mut_meta_prop_expr(&mut self, node: &mut MetaPropExpr) {
        VisitMut::visit_mut_meta_prop_expr(&mut **self, node)
    }

    fn visit_mut_meta_prop_kind(&mut self, node: &mut MetaPropKind) {
        VisitMut::visit_mut_meta_prop_kind(&mut **self, node)
    }

    fn visit_mut_method_kind(&mut self, node: &mut MethodKind) {
        VisitMut::visit_mut_method_kind(&mut **self, node)
    }

    fn visit_mut_method_prop(&mut self, node: &mut MethodProp) {
        VisitMut::visit_mut_method_prop(&mut **self, node)
    }

    fn visit_mut_module(&mut self, node: &mut Module) {
        VisitMut::visit_mut_module(&mut **self, node)
    }

    fn visit_mut_module_decl(&mut self, node: &mut ModuleDecl) {
        VisitMut::visit_mut_module_decl(&mut **self, node)
    }

    fn visit_mut_module_export_name(&mut self, node: &mut ModuleExportName) {
        VisitMut::visit_mut_module_export_name(&mut **self, node)
    }

    fn visit_mut_module_item(&mut self, node: &mut ModuleItem) {
        VisitMut::visit_mut_module_item(&mut **self, node)
    }

    fn visit_mut_module_items(&mut self, node: &mut Vec<ModuleItem>) {
        VisitMut::visit_mut_module_items(&mut **self, node)
    }

    fn visit_mut_named_export(&mut self, node: &mut NamedExport) {
        VisitMut::visit_mut_named_export(&mut **self, node)
    }

    fn visit_mut_new_expr(&mut self, node: &mut NewExpr) {
        VisitMut::visit_mut_new_expr(&mut **self, node)
    }

    fn visit_mut_null(&mut self, node: &mut Null) {
        VisitMut::visit_mut_null(&mut **self, node)
    }

    fn visit_mut_number(&mut self, node: &mut Number) {
        VisitMut::visit_mut_number(&mut **self, node)
    }

    fn visit_mut_object_lit(&mut self, node: &mut ObjectLit) {
        VisitMut::visit_mut_object_lit(&mut **self, node)
    }

    fn visit_mut_object_pat(&mut self, node: &mut ObjectPat) {
        VisitMut::visit_mut_object_pat(&mut **self, node)
    }

    fn visit_mut_object_pat_prop(&mut self, node: &mut ObjectPatProp) {
        VisitMut::visit_mut_object_pat_prop(&mut **self, node)
    }

    fn visit_mut_object_pat_props(&mut self, node: &mut Vec<ObjectPatProp>) {
        VisitMut::visit_mut_object_pat_props(&mut **self, node)
    }

    fn visit_mut_opt_accessibility(&mut self, node: &mut Option<Accessibility>) {
        VisitMut::visit_mut_opt_accessibility(&mut **self, node)
    }

    fn visit_mut_opt_atom(&mut self, node: &mut Option<swc_atoms::Atom>) {
        VisitMut::visit_mut_opt_atom(&mut **self, node)
    }

    fn visit_mut_opt_block_stmt(&mut self, node: &mut Option<BlockStmt>) {
        VisitMut::visit_mut_opt_block_stmt(&mut **self, node)
    }

    fn visit_mut_opt_call(&mut self, node: &mut OptCall) {
        VisitMut::visit_mut_opt_call(&mut **self, node)
    }

    fn visit_mut_opt_catch_clause(&mut self, node: &mut Option<CatchClause>) {
        VisitMut::visit_mut_opt_catch_clause(&mut **self, node)
    }

    fn visit_mut_opt_chain_base(&mut self, node: &mut OptChainBase) {
        VisitMut::visit_mut_opt_chain_base(&mut **self, node)
    }

    fn visit_mut_opt_chain_expr(&mut self, node: &mut OptChainExpr) {
        VisitMut::visit_mut_opt_chain_expr(&mut **self, node)
    }

    fn visit_mut_opt_expr(&mut self, node: &mut Option<Box<Expr>>) {
        VisitMut::visit_mut_opt_expr(&mut **self, node)
    }

    fn visit_mut_opt_expr_or_spread(&mut self, node: &mut Option<ExprOrSpread>) {
        VisitMut::visit_mut_opt_expr_or_spread(&mut **self, node)
    }

    fn visit_mut_opt_expr_or_spreads(&mut self, node: &mut Option<Vec<ExprOrSpread>>) {
        VisitMut::visit_mut_opt_expr_or_spreads(&mut **self, node)
    }

    fn visit_mut_opt_ident(&mut self, node: &mut Option<Ident>) {
        VisitMut::visit_mut_opt_ident(&mut **self, node)
    }

    fn visit_mut_opt_jsx_attr_value(&mut self, node: &mut Option<JSXAttrValue>) {
        VisitMut::visit_mut_opt_jsx_attr_value(&mut **self, node)
    }

    fn visit_mut_opt_jsx_closing_element(&mut self, node: &mut Option<JSXClosingElement>) {
        VisitMut::visit_mut_opt_jsx_closing_element(&mut **self, node)
    }

    fn visit_mut_opt_module_export_name(&mut self, node: &mut Option<ModuleExportName>) {
        VisitMut::visit_mut_opt_module_export_name(&mut **self, node)
    }

    fn visit_mut_opt_module_items(&mut self, node: &mut Option<Vec<ModuleItem>>) {
        VisitMut::visit_mut_opt_module_items(&mut **self, node)
    }

    fn visit_mut_opt_object_lit(&mut self, node: &mut Option<Box<ObjectLit>>) {
        VisitMut::visit_mut_opt_object_lit(&mut **self, node)
    }

    fn visit_mut_opt_pat(&mut self, node: &mut Option<Pat>) {
        VisitMut::visit_mut_opt_pat(&mut **self, node)
    }

    fn visit_mut_opt_span(&mut self, node: &mut Option<swc_common::Span>) {
        VisitMut::visit_mut_opt_span(&mut **self, node)
    }

    fn visit_mut_opt_stmt(&mut self, node: &mut Option<Box<Stmt>>) {
        VisitMut::visit_mut_opt_stmt(&mut **self, node)
    }

    fn visit_mut_opt_str(&mut self, node: &mut Option<Box<Str>>) {
        VisitMut::visit_mut_opt_str(&mut **self, node)
    }

    fn visit_mut_opt_true_plus_minus(&mut self, node: &mut Option<TruePlusMinus>) {
        VisitMut::visit_mut_opt_true_plus_minus(&mut **self, node)
    }

    fn visit_mut_opt_ts_entity_name(&mut self, node: &mut Option<TsEntityName>) {
        VisitMut::visit_mut_opt_ts_entity_name(&mut **self, node)
    }

    fn visit_mut_opt_ts_namespace_body(&mut self, node: &mut Option<TsNamespaceBody>) {
        VisitMut::visit_mut_opt_ts_namespace_body(&mut **self, node)
    }

    fn visit_mut_opt_ts_type(&mut self, node: &mut Option<Box<TsType>>) {
        VisitMut::visit_mut_opt_ts_type(&mut **self, node)
    }

    fn visit_mut_opt_ts_type_ann(&mut self, node: &mut Option<Box<TsTypeAnn>>) {
        VisitMut::visit_mut_opt_ts_type_ann(&mut **self, node)
    }

    fn visit_mut_opt_ts_type_param_decl(&mut self, node: &mut Option<Box<TsTypeParamDecl>>) {
        VisitMut::visit_mut_opt_ts_type_param_decl(&mut **self, node)
    }

    fn visit_mut_opt_ts_type_param_instantiation(
        &mut self,
        node: &mut Option<Box<TsTypeParamInstantiation>>,
    ) {
        VisitMut::visit_mut_opt_ts_type_param_instantiation(&mut **self, node)
    }

    fn visit_mut_opt_var_decl_or_expr(&mut self, node: &mut Option<VarDeclOrExpr>) {
        VisitMut::visit_mut_opt_var_decl_or_expr(&mut **self, node)
    }

    fn visit_mut_opt_vec_expr_or_spreads(&mut self, node: &mut Vec<Option<ExprOrSpread>>) {
        VisitMut::visit_mut_opt_vec_expr_or_spreads(&mut **self, node)
    }

    fn visit_mut_opt_vec_pats(&mut self, node: &mut Vec<Option<Pat>>) {
        VisitMut::visit_mut_opt_vec_pats(&mut **self, node)
    }

    fn visit_mut_param(&mut self, node: &mut Param) {
        VisitMut::visit_mut_param(&mut **self, node)
    }

    fn visit_mut_param_or_ts_param_prop(&mut self, node: &mut ParamOrTsParamProp) {
        VisitMut::visit_mut_param_or_ts_param_prop(&mut **self, node)
    }

    fn visit_mut_param_or_ts_param_props(&mut self, node: &mut Vec<ParamOrTsParamProp>) {
        VisitMut::visit_mut_param_or_ts_param_props(&mut **self, node)
    }

    fn visit_mut_params(&mut self, node: &mut Vec<Param>) {
        VisitMut::visit_mut_params(&mut **self, node)
    }

    fn visit_mut_paren_expr(&mut self, node: &mut ParenExpr) {
        VisitMut::visit_mut_paren_expr(&mut **self, node)
    }

    fn visit_mut_pat(&mut self, node: &mut Pat) {
        VisitMut::visit_mut_pat(&mut **self, node)
    }

    fn visit_mut_pats(&mut self, node: &mut Vec<Pat>) {
        VisitMut::visit_mut_pats(&mut **self, node)
    }

    fn visit_mut_private_method(&mut self, node: &mut PrivateMethod) {
        VisitMut::visit_mut_private_method(&mut **self, node)
    }

    fn visit_mut_private_name(&mut self, node: &mut PrivateName) {
        VisitMut::visit_mut_private_name(&mut **self, node)
    }

    fn visit_mut_private_prop(&mut self, node: &mut PrivateProp) {
        VisitMut::visit_mut_private_prop(&mut **self, node)
    }

    fn visit_mut_program(&mut self, node: &mut Program) {
        VisitMut::visit_mut_program(&mut **self, node)
    }

    fn visit_mut_prop(&mut self, node: &mut Prop) {
        VisitMut::visit_mut_prop(&mut **self, node)
    }

    fn visit_mut_prop_name(&mut self, node: &mut PropName) {
        VisitMut::visit_mut_prop_name(&mut **self, node)
    }

    fn visit_mut_prop_or_spread(&mut self, node: &mut PropOrSpread) {
        VisitMut::visit_mut_prop_or_spread(&mut **self, node)
    }

    fn visit_mut_prop_or_spreads(&mut self, node: &mut Vec<PropOrSpread>) {
        VisitMut::visit_mut_prop_or_spreads(&mut **self, node)
    }

    fn visit_mut_regex(&mut self, node: &mut Regex) {
        VisitMut::visit_mut_regex(&mut **self, node)
    }

    fn visit_mut_reserved_unused(&mut self, node: &mut ReservedUnused) {
        VisitMut::visit_mut_reserved_unused(&mut **self, node)
    }

    fn visit_mut_rest_pat(&mut self, node: &mut RestPat) {
        VisitMut::visit_mut_rest_pat(&mut **self, node)
    }

    fn visit_mut_return_stmt(&mut self, node: &mut ReturnStmt) {
        VisitMut::visit_mut_return_stmt(&mut **self, node)
    }

    fn visit_mut_script(&mut self, node: &mut Script) {
        VisitMut::visit_mut_script(&mut **self, node)
    }

    fn visit_mut_seq_expr(&mut self, node: &mut SeqExpr) {
        VisitMut::visit_mut_seq_expr(&mut **self, node)
    }

    fn visit_mut_setter_prop(&mut self, node: &mut SetterProp) {
        VisitMut::visit_mut_setter_prop(&mut **self, node)
    }

    fn visit_mut_simple_assign_target(&mut self, node: &mut SimpleAssignTarget) {
        VisitMut::visit_mut_simple_assign_target(&mut **self, node)
    }

    fn visit_mut_span(&mut self, node: &mut swc_common::Span) {
        VisitMut::visit_mut_span(&mut **self, node)
    }

    fn visit_mut_spread_element(&mut self, node: &mut SpreadElement) {
        VisitMut::visit_mut_spread_element(&mut **self, node)
    }

    fn visit_mut_static_block(&mut self, node: &mut StaticBlock) {
        VisitMut::visit_mut_static_block(&mut **self, node)
    }

    fn visit_mut_stmt(&mut self, node: &mut Stmt) {
        VisitMut::visit_mut_stmt(&mut **self, node)
    }

    fn visit_mut_stmts(&mut self, node: &mut Vec<Stmt>) {
        VisitMut::visit_mut_stmts(&mut **self, node)
    }

    fn visit_mut_str(&mut self, node: &mut Str) {
        VisitMut::visit_mut_str(&mut **self, node)
    }

    fn visit_mut_super(&mut self, node: &mut Super) {
        VisitMut::visit_mut_super(&mut **self, node)
    }

    fn visit_mut_super_prop(&mut self, node: &mut SuperProp) {
        VisitMut::visit_mut_super_prop(&mut **self, node)
    }

    fn visit_mut_super_prop_expr(&mut self, node: &mut SuperPropExpr) {
        VisitMut::visit_mut_super_prop_expr(&mut **self, node)
    }

    fn visit_mut_switch_case(&mut self, node: &mut SwitchCase) {
        VisitMut::visit_mut_switch_case(&mut **self, node)
    }

    fn visit_mut_switch_cases(&mut self, node: &mut Vec<SwitchCase>) {
        VisitMut::visit_mut_switch_cases(&mut **self, node)
    }

    fn visit_mut_switch_stmt(&mut self, node: &mut SwitchStmt) {
        VisitMut::visit_mut_switch_stmt(&mut **self, node)
    }

    fn visit_mut_syntax_context(&mut self, node: &mut swc_common::SyntaxContext) {
        VisitMut::visit_mut_syntax_context(&mut **self, node)
    }

    fn visit_mut_tagged_tpl(&mut self, node: &mut TaggedTpl) {
        VisitMut::visit_mut_tagged_tpl(&mut **self, node)
    }

    fn visit_mut_this_expr(&mut self, node: &mut ThisExpr) {
        VisitMut::visit_mut_this_expr(&mut **self, node)
    }

    fn visit_mut_throw_stmt(&mut self, node: &mut ThrowStmt) {
        VisitMut::visit_mut_throw_stmt(&mut **self, node)
    }

    fn visit_mut_tpl(&mut self, node: &mut Tpl) {
        VisitMut::visit_mut_tpl(&mut **self, node)
    }

    fn visit_mut_tpl_element(&mut self, node: &mut TplElement) {
        VisitMut::visit_mut_tpl_element(&mut **self, node)
    }

    fn visit_mut_tpl_elements(&mut self, node: &mut Vec<TplElement>) {
        VisitMut::visit_mut_tpl_elements(&mut **self, node)
    }

    fn visit_mut_true_plus_minus(&mut self, node: &mut TruePlusMinus) {
        VisitMut::visit_mut_true_plus_minus(&mut **self, node)
    }

    fn visit_mut_try_stmt(&mut self, node: &mut TryStmt) {
        VisitMut::visit_mut_try_stmt(&mut **self, node)
    }

    fn visit_mut_ts_array_type(&mut self, node: &mut TsArrayType) {
        VisitMut::visit_mut_ts_array_type(&mut **self, node)
    }

    fn visit_mut_ts_as_expr(&mut self, node: &mut TsAsExpr) {
        VisitMut::visit_mut_ts_as_expr(&mut **self, node)
    }

    fn visit_mut_ts_call_signature_decl(&mut self, node: &mut TsCallSignatureDecl) {
        VisitMut::visit_mut_ts_call_signature_decl(&mut **self, node)
    }

    fn visit_mut_ts_conditional_type(&mut self, node: &mut TsConditionalType) {
        VisitMut::visit_mut_ts_conditional_type(&mut **self, node)
    }

    fn visit_mut_ts_const_assertion(&mut self, node: &mut TsConstAssertion) {
        VisitMut::visit_mut_ts_const_assertion(&mut **self, node)
    }

    fn visit_mut_ts_construct_signature_decl(&mut self, node: &mut TsConstructSignatureDecl) {
        VisitMut::visit_mut_ts_construct_signature_decl(&mut **self, node)
    }

    fn visit_mut_ts_constructor_type(&mut self, node: &mut TsConstructorType) {
        VisitMut::visit_mut_ts_constructor_type(&mut **self, node)
    }

    fn visit_mut_ts_entity_name(&mut self, node: &mut TsEntityName) {
        VisitMut::visit_mut_ts_entity_name(&mut **self, node)
    }

    fn visit_mut_ts_enum_decl(&mut self, node: &mut TsEnumDecl) {
        VisitMut::visit_mut_ts_enum_decl(&mut **self, node)
    }

    fn visit_mut_ts_enum_member(&mut self, node: &mut TsEnumMember) {
        VisitMut::visit_mut_ts_enum_member(&mut **self, node)
    }

    fn visit_mut_ts_enum_member_id(&mut self, node: &mut TsEnumMemberId) {
        VisitMut::visit_mut_ts_enum_member_id(&mut **self, node)
    }

    fn visit_mut_ts_enum_members(&mut self, node: &mut Vec<TsEnumMember>) {
        VisitMut::visit_mut_ts_enum_members(&mut **self, node)
    }

    fn visit_mut_ts_export_assignment(&mut self, node: &mut TsExportAssignment) {
        VisitMut::visit_mut_ts_export_assignment(&mut **self, node)
    }

    fn visit_mut_ts_expr_with_type_args(&mut self, node: &mut TsExprWithTypeArgs) {
        VisitMut::visit_mut_ts_expr_with_type_args(&mut **self, node)
    }

    fn visit_mut_ts_expr_with_type_argss(&mut self, node: &mut Vec<TsExprWithTypeArgs>) {
        VisitMut::visit_mut_ts_expr_with_type_argss(&mut **self, node)
    }

    fn visit_mut_ts_external_module_ref(&mut self, node: &mut TsExternalModuleRef) {
        VisitMut::visit_mut_ts_external_module_ref(&mut **self, node)
    }

    fn visit_mut_ts_fn_or_constructor_type(&mut self, node: &mut TsFnOrConstructorType) {
        VisitMut::visit_mut_ts_fn_or_constructor_type(&mut **self, node)
    }

    fn visit_mut_ts_fn_param(&mut self, node: &mut TsFnParam) {
        VisitMut::visit_mut_ts_fn_param(&mut **self, node)
    }

    fn visit_mut_ts_fn_params(&mut self, node: &mut Vec<TsFnParam>) {
        VisitMut::visit_mut_ts_fn_params(&mut **self, node)
    }

    fn visit_mut_ts_fn_type(&mut self, node: &mut TsFnType) {
        VisitMut::visit_mut_ts_fn_type(&mut **self, node)
    }

    fn visit_mut_ts_getter_signature(&mut self, node: &mut TsGetterSignature) {
        VisitMut::visit_mut_ts_getter_signature(&mut **self, node)
    }

    fn visit_mut_ts_import_equals_decl(&mut self, node: &mut TsImportEqualsDecl) {
        VisitMut::visit_mut_ts_import_equals_decl(&mut **self, node)
    }

    fn visit_mut_ts_import_type(&mut self, node: &mut TsImportType) {
        VisitMut::visit_mut_ts_import_type(&mut **self, node)
    }

    fn visit_mut_ts_index_signature(&mut self, node: &mut TsIndexSignature) {
        VisitMut::visit_mut_ts_index_signature(&mut **self, node)
    }

    fn visit_mut_ts_indexed_access_type(&mut self, node: &mut TsIndexedAccessType) {
        VisitMut::visit_mut_ts_indexed_access_type(&mut **self, node)
    }

    fn visit_mut_ts_infer_type(&mut self, node: &mut TsInferType) {
        VisitMut::visit_mut_ts_infer_type(&mut **self, node)
    }

    fn visit_mut_ts_instantiation(&mut self, node: &mut TsInstantiation) {
        VisitMut::visit_mut_ts_instantiation(&mut **self, node)
    }

    fn visit_mut_ts_interface_body(&mut self, node: &mut TsInterfaceBody) {
        VisitMut::visit_mut_ts_interface_body(&mut **self, node)
    }

    fn visit_mut_ts_interface_decl(&mut self, node: &mut TsInterfaceDecl) {
        VisitMut::visit_mut_ts_interface_decl(&mut **self, node)
    }

    fn visit_mut_ts_intersection_type(&mut self, node: &mut TsIntersectionType) {
        VisitMut::visit_mut_ts_intersection_type(&mut **self, node)
    }

    fn visit_mut_ts_keyword_type(&mut self, node: &mut TsKeywordType) {
        VisitMut::visit_mut_ts_keyword_type(&mut **self, node)
    }

    fn visit_mut_ts_keyword_type_kind(&mut self, node: &mut TsKeywordTypeKind) {
        VisitMut::visit_mut_ts_keyword_type_kind(&mut **self, node)
    }

    fn visit_mut_ts_lit(&mut self, node: &mut TsLit) {
        VisitMut::visit_mut_ts_lit(&mut **self, node)
    }

    fn visit_mut_ts_lit_type(&mut self, node: &mut TsLitType) {
        VisitMut::visit_mut_ts_lit_type(&mut **self, node)
    }

    fn visit_mut_ts_mapped_type(&mut self, node: &mut TsMappedType) {
        VisitMut::visit_mut_ts_mapped_type(&mut **self, node)
    }

    fn visit_mut_ts_method_signature(&mut self, node: &mut TsMethodSignature) {
        VisitMut::visit_mut_ts_method_signature(&mut **self, node)
    }

    fn visit_mut_ts_module_block(&mut self, node: &mut TsModuleBlock) {
        VisitMut::visit_mut_ts_module_block(&mut **self, node)
    }

    fn visit_mut_ts_module_decl(&mut self, node: &mut TsModuleDecl) {
        VisitMut::visit_mut_ts_module_decl(&mut **self, node)
    }

    fn visit_mut_ts_module_name(&mut self, node: &mut TsModuleName) {
        VisitMut::visit_mut_ts_module_name(&mut **self, node)
    }

    fn visit_mut_ts_module_ref(&mut self, node: &mut TsModuleRef) {
        VisitMut::visit_mut_ts_module_ref(&mut **self, node)
    }

    fn visit_mut_ts_namespace_body(&mut self, node: &mut TsNamespaceBody) {
        VisitMut::visit_mut_ts_namespace_body(&mut **self, node)
    }

    fn visit_mut_ts_namespace_decl(&mut self, node: &mut TsNamespaceDecl) {
        VisitMut::visit_mut_ts_namespace_decl(&mut **self, node)
    }

    fn visit_mut_ts_namespace_export_decl(&mut self, node: &mut TsNamespaceExportDecl) {
        VisitMut::visit_mut_ts_namespace_export_decl(&mut **self, node)
    }

    fn visit_mut_ts_non_null_expr(&mut self, node: &mut TsNonNullExpr) {
        VisitMut::visit_mut_ts_non_null_expr(&mut **self, node)
    }

    fn visit_mut_ts_optional_type(&mut self, node: &mut TsOptionalType) {
        VisitMut::visit_mut_ts_optional_type(&mut **self, node)
    }

    fn visit_mut_ts_param_prop(&mut self, node: &mut TsParamProp) {
        VisitMut::visit_mut_ts_param_prop(&mut **self, node)
    }

    fn visit_mut_ts_param_prop_param(&mut self, node: &mut TsParamPropParam) {
        VisitMut::visit_mut_ts_param_prop_param(&mut **self, node)
    }

    fn visit_mut_ts_parenthesized_type(&mut self, node: &mut TsParenthesizedType) {
        VisitMut::visit_mut_ts_parenthesized_type(&mut **self, node)
    }

    fn visit_mut_ts_property_signature(&mut self, node: &mut TsPropertySignature) {
        VisitMut::visit_mut_ts_property_signature(&mut **self, node)
    }

    fn visit_mut_ts_qualified_name(&mut self, node: &mut TsQualifiedName) {
        VisitMut::visit_mut_ts_qualified_name(&mut **self, node)
    }

    fn visit_mut_ts_rest_type(&mut self, node: &mut TsRestType) {
        VisitMut::visit_mut_ts_rest_type(&mut **self, node)
    }

    fn visit_mut_ts_satisfies_expr(&mut self, node: &mut TsSatisfiesExpr) {
        VisitMut::visit_mut_ts_satisfies_expr(&mut **self, node)
    }

    fn visit_mut_ts_setter_signature(&mut self, node: &mut TsSetterSignature) {
        VisitMut::visit_mut_ts_setter_signature(&mut **self, node)
    }

    fn visit_mut_ts_this_type(&mut self, node: &mut TsThisType) {
        VisitMut::visit_mut_ts_this_type(&mut **self, node)
    }

    fn visit_mut_ts_this_type_or_ident(&mut self, node: &mut TsThisTypeOrIdent) {
        VisitMut::visit_mut_ts_this_type_or_ident(&mut **self, node)
    }

    fn visit_mut_ts_tpl_lit_type(&mut self, node: &mut TsTplLitType) {
        VisitMut::visit_mut_ts_tpl_lit_type(&mut **self, node)
    }

    fn visit_mut_ts_tuple_element(&mut self, node: &mut TsTupleElement) {
        VisitMut::visit_mut_ts_tuple_element(&mut **self, node)
    }

    fn visit_mut_ts_tuple_elements(&mut self, node: &mut Vec<TsTupleElement>) {
        VisitMut::visit_mut_ts_tuple_elements(&mut **self, node)
    }

    fn visit_mut_ts_tuple_type(&mut self, node: &mut TsTupleType) {
        VisitMut::visit_mut_ts_tuple_type(&mut **self, node)
    }

    fn visit_mut_ts_type(&mut self, node: &mut TsType) {
        VisitMut::visit_mut_ts_type(&mut **self, node)
    }

    fn visit_mut_ts_type_alias_decl(&mut self, node: &mut TsTypeAliasDecl) {
        VisitMut::visit_mut_ts_type_alias_decl(&mut **self, node)
    }

    fn visit_mut_ts_type_ann(&mut self, node: &mut TsTypeAnn) {
        VisitMut::visit_mut_ts_type_ann(&mut **self, node)
    }

    fn visit_mut_ts_type_assertion(&mut self, node: &mut TsTypeAssertion) {
        VisitMut::visit_mut_ts_type_assertion(&mut **self, node)
    }

    fn visit_mut_ts_type_element(&mut self, node: &mut TsTypeElement) {
        VisitMut::visit_mut_ts_type_element(&mut **self, node)
    }

    fn visit_mut_ts_type_elements(&mut self, node: &mut Vec<TsTypeElement>) {
        VisitMut::visit_mut_ts_type_elements(&mut **self, node)
    }

    fn visit_mut_ts_type_lit(&mut self, node: &mut TsTypeLit) {
        VisitMut::visit_mut_ts_type_lit(&mut **self, node)
    }

    fn visit_mut_ts_type_operator(&mut self, node: &mut TsTypeOperator) {
        VisitMut::visit_mut_ts_type_operator(&mut **self, node)
    }

    fn visit_mut_ts_type_operator_op(&mut self, node: &mut TsTypeOperatorOp) {
        VisitMut::visit_mut_ts_type_operator_op(&mut **self, node)
    }

    fn visit_mut_ts_type_param(&mut self, node: &mut TsTypeParam) {
        VisitMut::visit_mut_ts_type_param(&mut **self, node)
    }

    fn visit_mut_ts_type_param_decl(&mut self, node: &mut TsTypeParamDecl) {
        VisitMut::visit_mut_ts_type_param_decl(&mut **self, node)
    }

    fn visit_mut_ts_type_param_instantiation(&mut self, node: &mut TsTypeParamInstantiation) {
        VisitMut::visit_mut_ts_type_param_instantiation(&mut **self, node)
    }

    fn visit_mut_ts_type_params(&mut self, node: &mut Vec<TsTypeParam>) {
        VisitMut::visit_mut_ts_type_params(&mut **self, node)
    }

    fn visit_mut_ts_type_predicate(&mut self, node: &mut TsTypePredicate) {
        VisitMut::visit_mut_ts_type_predicate(&mut **self, node)
    }

    fn visit_mut_ts_type_query(&mut self, node: &mut TsTypeQuery) {
        VisitMut::visit_mut_ts_type_query(&mut **self, node)
    }

    fn visit_mut_ts_type_query_expr(&mut self, node: &mut TsTypeQueryExpr) {
        VisitMut::visit_mut_ts_type_query_expr(&mut **self, node)
    }

    fn visit_mut_ts_type_ref(&mut self, node: &mut TsTypeRef) {
        VisitMut::visit_mut_ts_type_ref(&mut **self, node)
    }

    fn visit_mut_ts_types(&mut self, node: &mut Vec<Box<TsType>>) {
        VisitMut::visit_mut_ts_types(&mut **self, node)
    }

    fn visit_mut_ts_union_or_intersection_type(&mut self, node: &mut TsUnionOrIntersectionType) {
        VisitMut::visit_mut_ts_union_or_intersection_type(&mut **self, node)
    }

    fn visit_mut_ts_union_type(&mut self, node: &mut TsUnionType) {
        VisitMut::visit_mut_ts_union_type(&mut **self, node)
    }

    fn visit_mut_unary_expr(&mut self, node: &mut UnaryExpr) {
        VisitMut::visit_mut_unary_expr(&mut **self, node)
    }

    fn visit_mut_unary_op(&mut self, node: &mut UnaryOp) {
        VisitMut::visit_mut_unary_op(&mut **self, node)
    }

    fn visit_mut_update_expr(&mut self, node: &mut UpdateExpr) {
        VisitMut::visit_mut_update_expr(&mut **self, node)
    }

    fn visit_mut_update_op(&mut self, node: &mut UpdateOp) {
        VisitMut::visit_mut_update_op(&mut **self, node)
    }

    fn visit_mut_using_decl(&mut self, node: &mut UsingDecl) {
        VisitMut::visit_mut_using_decl(&mut **self, node)
    }

    fn visit_mut_var_decl(&mut self, node: &mut VarDecl) {
        VisitMut::visit_mut_var_decl(&mut **self, node)
    }

    fn visit_mut_var_decl_kind(&mut self, node: &mut VarDeclKind) {
        VisitMut::visit_mut_var_decl_kind(&mut **self, node)
    }

    fn visit_mut_var_decl_or_expr(&mut self, node: &mut VarDeclOrExpr) {
        VisitMut::visit_mut_var_decl_or_expr(&mut **self, node)
    }

    fn visit_mut_var_declarator(&mut self, node: &mut VarDeclarator) {
        VisitMut::visit_mut_var_declarator(&mut **self, node)
    }

    fn visit_mut_var_declarators(&mut self, node: &mut Vec<VarDeclarator>) {
        VisitMut::visit_mut_var_declarators(&mut **self, node)
    }

    fn visit_mut_while_stmt(&mut self, node: &mut WhileStmt) {
        VisitMut::visit_mut_while_stmt(&mut **self, node)
    }

    fn visit_mut_with_stmt(&mut self, node: &mut WithStmt) {
        VisitMut::visit_mut_with_stmt(&mut **self, node)
    }

    fn visit_mut_yield_expr(&mut self, node: &mut YieldExpr) {
        VisitMut::visit_mut_yield_expr(&mut **self, node)
    }
}
impl<V> VisitMut for Box<V>
where
    V: ?Sized + VisitMut,
{
    fn visit_mut_accessibility(&mut self, node: &mut Accessibility) {
        VisitMut::visit_mut_accessibility(&mut **self, node)
    }

    fn visit_mut_array_lit(&mut self, node: &mut ArrayLit) {
        VisitMut::visit_mut_array_lit(&mut **self, node)
    }

    fn visit_mut_array_pat(&mut self, node: &mut ArrayPat) {
        VisitMut::visit_mut_array_pat(&mut **self, node)
    }

    fn visit_mut_arrow_expr(&mut self, node: &mut ArrowExpr) {
        VisitMut::visit_mut_arrow_expr(&mut **self, node)
    }

    fn visit_mut_assign_expr(&mut self, node: &mut AssignExpr) {
        VisitMut::visit_mut_assign_expr(&mut **self, node)
    }

    fn visit_mut_assign_op(&mut self, node: &mut AssignOp) {
        VisitMut::visit_mut_assign_op(&mut **self, node)
    }

    fn visit_mut_assign_pat(&mut self, node: &mut AssignPat) {
        VisitMut::visit_mut_assign_pat(&mut **self, node)
    }

    fn visit_mut_assign_pat_prop(&mut self, node: &mut AssignPatProp) {
        VisitMut::visit_mut_assign_pat_prop(&mut **self, node)
    }

    fn visit_mut_assign_prop(&mut self, node: &mut AssignProp) {
        VisitMut::visit_mut_assign_prop(&mut **self, node)
    }

    fn visit_mut_assign_target(&mut self, node: &mut AssignTarget) {
        VisitMut::visit_mut_assign_target(&mut **self, node)
    }

    fn visit_mut_assign_target_pat(&mut self, node: &mut AssignTargetPat) {
        VisitMut::visit_mut_assign_target_pat(&mut **self, node)
    }

    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom) {
        VisitMut::visit_mut_atom(&mut **self, node)
    }

    fn visit_mut_auto_accessor(&mut self, node: &mut AutoAccessor) {
        VisitMut::visit_mut_auto_accessor(&mut **self, node)
    }

    fn visit_mut_await_expr(&mut self, node: &mut AwaitExpr) {
        VisitMut::visit_mut_await_expr(&mut **self, node)
    }

    fn visit_mut_big_int(&mut self, node: &mut BigInt) {
        VisitMut::visit_mut_big_int(&mut **self, node)
    }

    fn visit_mut_big_int_value(&mut self, node: &mut BigIntValue) {
        VisitMut::visit_mut_big_int_value(&mut **self, node)
    }

    fn visit_mut_bin_expr(&mut self, node: &mut BinExpr) {
        VisitMut::visit_mut_bin_expr(&mut **self, node)
    }

    fn visit_mut_binary_op(&mut self, node: &mut BinaryOp) {
        VisitMut::visit_mut_binary_op(&mut **self, node)
    }

    fn visit_mut_binding_ident(&mut self, node: &mut BindingIdent) {
        VisitMut::visit_mut_binding_ident(&mut **self, node)
    }

    fn visit_mut_block_stmt(&mut self, node: &mut BlockStmt) {
        VisitMut::visit_mut_block_stmt(&mut **self, node)
    }

    fn visit_mut_block_stmt_or_expr(&mut self, node: &mut BlockStmtOrExpr) {
        VisitMut::visit_mut_block_stmt_or_expr(&mut **self, node)
    }

    fn visit_mut_bool(&mut self, node: &mut Bool) {
        VisitMut::visit_mut_bool(&mut **self, node)
    }

    fn visit_mut_break_stmt(&mut self, node: &mut BreakStmt) {
        VisitMut::visit_mut_break_stmt(&mut **self, node)
    }

    fn visit_mut_call_expr(&mut self, node: &mut CallExpr) {
        VisitMut::visit_mut_call_expr(&mut **self, node)
    }

    fn visit_mut_callee(&mut self, node: &mut Callee) {
        VisitMut::visit_mut_callee(&mut **self, node)
    }

    fn visit_mut_catch_clause(&mut self, node: &mut CatchClause) {
        VisitMut::visit_mut_catch_clause(&mut **self, node)
    }

    fn visit_mut_class(&mut self, node: &mut Class) {
        VisitMut::visit_mut_class(&mut **self, node)
    }

    fn visit_mut_class_decl(&mut self, node: &mut ClassDecl) {
        VisitMut::visit_mut_class_decl(&mut **self, node)
    }

    fn visit_mut_class_expr(&mut self, node: &mut ClassExpr) {
        VisitMut::visit_mut_class_expr(&mut **self, node)
    }

    fn visit_mut_class_member(&mut self, node: &mut ClassMember) {
        VisitMut::visit_mut_class_member(&mut **self, node)
    }

    fn visit_mut_class_members(&mut self, node: &mut Vec<ClassMember>) {
        VisitMut::visit_mut_class_members(&mut **self, node)
    }

    fn visit_mut_class_method(&mut self, node: &mut ClassMethod) {
        VisitMut::visit_mut_class_method(&mut **self, node)
    }

    fn visit_mut_class_prop(&mut self, node: &mut ClassProp) {
        VisitMut::visit_mut_class_prop(&mut **self, node)
    }

    fn visit_mut_computed_prop_name(&mut self, node: &mut ComputedPropName) {
        VisitMut::visit_mut_computed_prop_name(&mut **self, node)
    }

    fn visit_mut_cond_expr(&mut self, node: &mut CondExpr) {
        VisitMut::visit_mut_cond_expr(&mut **self, node)
    }

    fn visit_mut_constructor(&mut self, node: &mut Constructor) {
        VisitMut::visit_mut_constructor(&mut **self, node)
    }

    fn visit_mut_continue_stmt(&mut self, node: &mut ContinueStmt) {
        VisitMut::visit_mut_continue_stmt(&mut **self, node)
    }

    fn visit_mut_debugger_stmt(&mut self, node: &mut DebuggerStmt) {
        VisitMut::visit_mut_debugger_stmt(&mut **self, node)
    }

    fn visit_mut_decl(&mut self, node: &mut Decl) {
        VisitMut::visit_mut_decl(&mut **self, node)
    }

    fn visit_mut_decorator(&mut self, node: &mut Decorator) {
        VisitMut::visit_mut_decorator(&mut **self, node)
    }

    fn visit_mut_decorators(&mut self, node: &mut Vec<Decorator>) {
        VisitMut::visit_mut_decorators(&mut **self, node)
    }

    fn visit_mut_default_decl(&mut self, node: &mut DefaultDecl) {
        VisitMut::visit_mut_default_decl(&mut **self, node)
    }

    fn visit_mut_do_while_stmt(&mut self, node: &mut DoWhileStmt) {
        VisitMut::visit_mut_do_while_stmt(&mut **self, node)
    }

    fn visit_mut_empty_stmt(&mut self, node: &mut EmptyStmt) {
        VisitMut::visit_mut_empty_stmt(&mut **self, node)
    }

    fn visit_mut_es_version(&mut self, node: &mut EsVersion) {
        VisitMut::visit_mut_es_version(&mut **self, node)
    }

    fn visit_mut_export_all(&mut self, node: &mut ExportAll) {
        VisitMut::visit_mut_export_all(&mut **self, node)
    }

    fn visit_mut_export_decl(&mut self, node: &mut ExportDecl) {
        VisitMut::visit_mut_export_decl(&mut **self, node)
    }

    fn visit_mut_export_default_decl(&mut self, node: &mut ExportDefaultDecl) {
        VisitMut::visit_mut_export_default_decl(&mut **self, node)
    }

    fn visit_mut_export_default_expr(&mut self, node: &mut ExportDefaultExpr) {
        VisitMut::visit_mut_export_default_expr(&mut **self, node)
    }

    fn visit_mut_export_default_specifier(&mut self, node: &mut ExportDefaultSpecifier) {
        VisitMut::visit_mut_export_default_specifier(&mut **self, node)
    }

    fn visit_mut_export_named_specifier(&mut self, node: &mut ExportNamedSpecifier) {
        VisitMut::visit_mut_export_named_specifier(&mut **self, node)
    }

    fn visit_mut_export_namespace_specifier(&mut self, node: &mut ExportNamespaceSpecifier) {
        VisitMut::visit_mut_export_namespace_specifier(&mut **self, node)
    }

    fn visit_mut_export_specifier(&mut self, node: &mut ExportSpecifier) {
        VisitMut::visit_mut_export_specifier(&mut **self, node)
    }

    fn visit_mut_export_specifiers(&mut self, node: &mut Vec<ExportSpecifier>) {
        VisitMut::visit_mut_export_specifiers(&mut **self, node)
    }

    fn visit_mut_expr(&mut self, node: &mut Expr) {
        VisitMut::visit_mut_expr(&mut **self, node)
    }

    fn visit_mut_expr_or_spread(&mut self, node: &mut ExprOrSpread) {
        VisitMut::visit_mut_expr_or_spread(&mut **self, node)
    }

    fn visit_mut_expr_or_spreads(&mut self, node: &mut Vec<ExprOrSpread>) {
        VisitMut::visit_mut_expr_or_spreads(&mut **self, node)
    }

    fn visit_mut_expr_stmt(&mut self, node: &mut ExprStmt) {
        VisitMut::visit_mut_expr_stmt(&mut **self, node)
    }

    fn visit_mut_exprs(&mut self, node: &mut Vec<Box<Expr>>) {
        VisitMut::visit_mut_exprs(&mut **self, node)
    }

    fn visit_mut_fn_decl(&mut self, node: &mut FnDecl) {
        VisitMut::visit_mut_fn_decl(&mut **self, node)
    }

    fn visit_mut_fn_expr(&mut self, node: &mut FnExpr) {
        VisitMut::visit_mut_fn_expr(&mut **self, node)
    }

    fn visit_mut_for_head(&mut self, node: &mut ForHead) {
        VisitMut::visit_mut_for_head(&mut **self, node)
    }

    fn visit_mut_for_in_stmt(&mut self, node: &mut ForInStmt) {
        VisitMut::visit_mut_for_in_stmt(&mut **self, node)
    }

    fn visit_mut_for_of_stmt(&mut self, node: &mut ForOfStmt) {
        VisitMut::visit_mut_for_of_stmt(&mut **self, node)
    }

    fn visit_mut_for_stmt(&mut self, node: &mut ForStmt) {
        VisitMut::visit_mut_for_stmt(&mut **self, node)
    }

    fn visit_mut_function(&mut self, node: &mut Function) {
        VisitMut::visit_mut_function(&mut **self, node)
    }

    fn visit_mut_getter_prop(&mut self, node: &mut GetterProp) {
        VisitMut::visit_mut_getter_prop(&mut **self, node)
    }

    fn visit_mut_ident(&mut self, node: &mut Ident) {
        VisitMut::visit_mut_ident(&mut **self, node)
    }

    fn visit_mut_ident_name(&mut self, node: &mut IdentName) {
        VisitMut::visit_mut_ident_name(&mut **self, node)
    }

    fn visit_mut_if_stmt(&mut self, node: &mut IfStmt) {
        VisitMut::visit_mut_if_stmt(&mut **self, node)
    }

    fn visit_mut_import(&mut self, node: &mut Import) {
        VisitMut::visit_mut_import(&mut **self, node)
    }

    fn visit_mut_import_decl(&mut self, node: &mut ImportDecl) {
        VisitMut::visit_mut_import_decl(&mut **self, node)
    }

    fn visit_mut_import_default_specifier(&mut self, node: &mut ImportDefaultSpecifier) {
        VisitMut::visit_mut_import_default_specifier(&mut **self, node)
    }

    fn visit_mut_import_named_specifier(&mut self, node: &mut ImportNamedSpecifier) {
        VisitMut::visit_mut_import_named_specifier(&mut **self, node)
    }

    fn visit_mut_import_phase(&mut self, node: &mut ImportPhase) {
        VisitMut::visit_mut_import_phase(&mut **self, node)
    }

    fn visit_mut_import_specifier(&mut self, node: &mut ImportSpecifier) {
        VisitMut::visit_mut_import_specifier(&mut **self, node)
    }

    fn visit_mut_import_specifiers(&mut self, node: &mut Vec<ImportSpecifier>) {
        VisitMut::visit_mut_import_specifiers(&mut **self, node)
    }

    fn visit_mut_import_star_as_specifier(&mut self, node: &mut ImportStarAsSpecifier) {
        VisitMut::visit_mut_import_star_as_specifier(&mut **self, node)
    }

    fn visit_mut_import_with(&mut self, node: &mut ImportWith) {
        VisitMut::visit_mut_import_with(&mut **self, node)
    }

    fn visit_mut_import_with_item(&mut self, node: &mut ImportWithItem) {
        VisitMut::visit_mut_import_with_item(&mut **self, node)
    }

    fn visit_mut_import_with_items(&mut self, node: &mut Vec<ImportWithItem>) {
        VisitMut::visit_mut_import_with_items(&mut **self, node)
    }

    fn visit_mut_invalid(&mut self, node: &mut Invalid) {
        VisitMut::visit_mut_invalid(&mut **self, node)
    }

    fn visit_mut_jsx_attr(&mut self, node: &mut JSXAttr) {
        VisitMut::visit_mut_jsx_attr(&mut **self, node)
    }

    fn visit_mut_jsx_attr_name(&mut self, node: &mut JSXAttrName) {
        VisitMut::visit_mut_jsx_attr_name(&mut **self, node)
    }

    fn visit_mut_jsx_attr_or_spread(&mut self, node: &mut JSXAttrOrSpread) {
        VisitMut::visit_mut_jsx_attr_or_spread(&mut **self, node)
    }

    fn visit_mut_jsx_attr_or_spreads(&mut self, node: &mut Vec<JSXAttrOrSpread>) {
        VisitMut::visit_mut_jsx_attr_or_spreads(&mut **self, node)
    }

    fn visit_mut_jsx_attr_value(&mut self, node: &mut JSXAttrValue) {
        VisitMut::visit_mut_jsx_attr_value(&mut **self, node)
    }

    fn visit_mut_jsx_closing_element(&mut self, node: &mut JSXClosingElement) {
        VisitMut::visit_mut_jsx_closing_element(&mut **self, node)
    }

    fn visit_mut_jsx_closing_fragment(&mut self, node: &mut JSXClosingFragment) {
        VisitMut::visit_mut_jsx_closing_fragment(&mut **self, node)
    }

    fn visit_mut_jsx_element(&mut self, node: &mut JSXElement) {
        VisitMut::visit_mut_jsx_element(&mut **self, node)
    }

    fn visit_mut_jsx_element_child(&mut self, node: &mut JSXElementChild) {
        VisitMut::visit_mut_jsx_element_child(&mut **self, node)
    }

    fn visit_mut_jsx_element_childs(&mut self, node: &mut Vec<JSXElementChild>) {
        VisitMut::visit_mut_jsx_element_childs(&mut **self, node)
    }

    fn visit_mut_jsx_element_name(&mut self, node: &mut JSXElementName) {
        VisitMut::visit_mut_jsx_element_name(&mut **self, node)
    }

    fn visit_mut_jsx_empty_expr(&mut self, node: &mut JSXEmptyExpr) {
        VisitMut::visit_mut_jsx_empty_expr(&mut **self, node)
    }

    fn visit_mut_jsx_expr(&mut self, node: &mut JSXExpr) {
        VisitMut::visit_mut_jsx_expr(&mut **self, node)
    }

    fn visit_mut_jsx_expr_container(&mut self, node: &mut JSXExprContainer) {
        VisitMut::visit_mut_jsx_expr_container(&mut **self, node)
    }

    fn visit_mut_jsx_fragment(&mut self, node: &mut JSXFragment) {
        VisitMut::visit_mut_jsx_fragment(&mut **self, node)
    }

    fn visit_mut_jsx_member_expr(&mut self, node: &mut JSXMemberExpr) {
        VisitMut::visit_mut_jsx_member_expr(&mut **self, node)
    }

    fn visit_mut_jsx_namespaced_name(&mut self, node: &mut JSXNamespacedName) {
        VisitMut::visit_mut_jsx_namespaced_name(&mut **self, node)
    }

    fn visit_mut_jsx_object(&mut self, node: &mut JSXObject) {
        VisitMut::visit_mut_jsx_object(&mut **self, node)
    }

    fn visit_mut_jsx_opening_element(&mut self, node: &mut JSXOpeningElement) {
        VisitMut::visit_mut_jsx_opening_element(&mut **self, node)
    }

    fn visit_mut_jsx_opening_fragment(&mut self, node: &mut JSXOpeningFragment) {
        VisitMut::visit_mut_jsx_opening_fragment(&mut **self, node)
    }

    fn visit_mut_jsx_spread_child(&mut self, node: &mut JSXSpreadChild) {
        VisitMut::visit_mut_jsx_spread_child(&mut **self, node)
    }

    fn visit_mut_jsx_text(&mut self, node: &mut JSXText) {
        VisitMut::visit_mut_jsx_text(&mut **self, node)
    }

    fn visit_mut_key(&mut self, node: &mut Key) {
        VisitMut::visit_mut_key(&mut **self, node)
    }

    fn visit_mut_key_value_pat_prop(&mut self, node: &mut KeyValuePatProp) {
        VisitMut::visit_mut_key_value_pat_prop(&mut **self, node)
    }

    fn visit_mut_key_value_prop(&mut self, node: &mut KeyValueProp) {
        VisitMut::visit_mut_key_value_prop(&mut **self, node)
    }

    fn visit_mut_labeled_stmt(&mut self, node: &mut LabeledStmt) {
        VisitMut::visit_mut_labeled_stmt(&mut **self, node)
    }

    fn visit_mut_lit(&mut self, node: &mut Lit) {
        VisitMut::visit_mut_lit(&mut **self, node)
    }

    fn visit_mut_member_expr(&mut self, node: &mut MemberExpr) {
        VisitMut::visit_mut_member_expr(&mut **self, node)
    }

    fn visit_mut_member_prop(&mut self, node: &mut MemberProp) {
        VisitMut::visit_mut_member_prop(&mut **self, node)
    }

    fn visit_mut_meta_prop_expr(&mut self, node: &mut MetaPropExpr) {
        VisitMut::visit_mut_meta_prop_expr(&mut **self, node)
    }

    fn visit_mut_meta_prop_kind(&mut self, node: &mut MetaPropKind) {
        VisitMut::visit_mut_meta_prop_kind(&mut **self, node)
    }

    fn visit_mut_method_kind(&mut self, node: &mut MethodKind) {
        VisitMut::visit_mut_method_kind(&mut **self, node)
    }

    fn visit_mut_method_prop(&mut self, node: &mut MethodProp) {
        VisitMut::visit_mut_method_prop(&mut **self, node)
    }

    fn visit_mut_module(&mut self, node: &mut Module) {
        VisitMut::visit_mut_module(&mut **self, node)
    }

    fn visit_mut_module_decl(&mut self, node: &mut ModuleDecl) {
        VisitMut::visit_mut_module_decl(&mut **self, node)
    }

    fn visit_mut_module_export_name(&mut self, node: &mut ModuleExportName) {
        VisitMut::visit_mut_module_export_name(&mut **self, node)
    }

    fn visit_mut_module_item(&mut self, node: &mut ModuleItem) {
        VisitMut::visit_mut_module_item(&mut **self, node)
    }

    fn visit_mut_module_items(&mut self, node: &mut Vec<ModuleItem>) {
        VisitMut::visit_mut_module_items(&mut **self, node)
    }

    fn visit_mut_named_export(&mut self, node: &mut NamedExport) {
        VisitMut::visit_mut_named_export(&mut **self, node)
    }

    fn visit_mut_new_expr(&mut self, node: &mut NewExpr) {
        VisitMut::visit_mut_new_expr(&mut **self, node)
    }

    fn visit_mut_null(&mut self, node: &mut Null) {
        VisitMut::visit_mut_null(&mut **self, node)
    }

    fn visit_mut_number(&mut self, node: &mut Number) {
        VisitMut::visit_mut_number(&mut **self, node)
    }

    fn visit_mut_object_lit(&mut self, node: &mut ObjectLit) {
        VisitMut::visit_mut_object_lit(&mut **self, node)
    }

    fn visit_mut_object_pat(&mut self, node: &mut ObjectPat) {
        VisitMut::visit_mut_object_pat(&mut **self, node)
    }

    fn visit_mut_object_pat_prop(&mut self, node: &mut ObjectPatProp) {
        VisitMut::visit_mut_object_pat_prop(&mut **self, node)
    }

    fn visit_mut_object_pat_props(&mut self, node: &mut Vec<ObjectPatProp>) {
        VisitMut::visit_mut_object_pat_props(&mut **self, node)
    }

    fn visit_mut_opt_accessibility(&mut self, node: &mut Option<Accessibility>) {
        VisitMut::visit_mut_opt_accessibility(&mut **self, node)
    }

    fn visit_mut_opt_atom(&mut self, node: &mut Option<swc_atoms::Atom>) {
        VisitMut::visit_mut_opt_atom(&mut **self, node)
    }

    fn visit_mut_opt_block_stmt(&mut self, node: &mut Option<BlockStmt>) {
        VisitMut::visit_mut_opt_block_stmt(&mut **self, node)
    }

    fn visit_mut_opt_call(&mut self, node: &mut OptCall) {
        VisitMut::visit_mut_opt_call(&mut **self, node)
    }

    fn visit_mut_opt_catch_clause(&mut self, node: &mut Option<CatchClause>) {
        VisitMut::visit_mut_opt_catch_clause(&mut **self, node)
    }

    fn visit_mut_opt_chain_base(&mut self, node: &mut OptChainBase) {
        VisitMut::visit_mut_opt_chain_base(&mut **self, node)
    }

    fn visit_mut_opt_chain_expr(&mut self, node: &mut OptChainExpr) {
        VisitMut::visit_mut_opt_chain_expr(&mut **self, node)
    }

    fn visit_mut_opt_expr(&mut self, node: &mut Option<Box<Expr>>) {
        VisitMut::visit_mut_opt_expr(&mut **self, node)
    }

    fn visit_mut_opt_expr_or_spread(&mut self, node: &mut Option<ExprOrSpread>) {
        VisitMut::visit_mut_opt_expr_or_spread(&mut **self, node)
    }

    fn visit_mut_opt_expr_or_spreads(&mut self, node: &mut Option<Vec<ExprOrSpread>>) {
        VisitMut::visit_mut_opt_expr_or_spreads(&mut **self, node)
    }

    fn visit_mut_opt_ident(&mut self, node: &mut Option<Ident>) {
        VisitMut::visit_mut_opt_ident(&mut **self, node)
    }

    fn visit_mut_opt_jsx_attr_value(&mut self, node: &mut Option<JSXAttrValue>) {
        VisitMut::visit_mut_opt_jsx_attr_value(&mut **self, node)
    }

    fn visit_mut_opt_jsx_closing_element(&mut self, node: &mut Option<JSXClosingElement>) {
        VisitMut::visit_mut_opt_jsx_closing_element(&mut **self, node)
    }

    fn visit_mut_opt_module_export_name(&mut self, node: &mut Option<ModuleExportName>) {
        VisitMut::visit_mut_opt_module_export_name(&mut **self, node)
    }

    fn visit_mut_opt_module_items(&mut self, node: &mut Option<Vec<ModuleItem>>) {
        VisitMut::visit_mut_opt_module_items(&mut **self, node)
    }

    fn visit_mut_opt_object_lit(&mut self, node: &mut Option<Box<ObjectLit>>) {
        VisitMut::visit_mut_opt_object_lit(&mut **self, node)
    }

    fn visit_mut_opt_pat(&mut self, node: &mut Option<Pat>) {
        VisitMut::visit_mut_opt_pat(&mut **self, node)
    }

    fn visit_mut_opt_span(&mut self, node: &mut Option<swc_common::Span>) {
        VisitMut::visit_mut_opt_span(&mut **self, node)
    }

    fn visit_mut_opt_stmt(&mut self, node: &mut Option<Box<Stmt>>) {
        VisitMut::visit_mut_opt_stmt(&mut **self, node)
    }

    fn visit_mut_opt_str(&mut self, node: &mut Option<Box<Str>>) {
        VisitMut::visit_mut_opt_str(&mut **self, node)
    }

    fn visit_mut_opt_true_plus_minus(&mut self, node: &mut Option<TruePlusMinus>) {
        VisitMut::visit_mut_opt_true_plus_minus(&mut **self, node)
    }

    fn visit_mut_opt_ts_entity_name(&mut self, node: &mut Option<TsEntityName>) {
        VisitMut::visit_mut_opt_ts_entity_name(&mut **self, node)
    }

    fn visit_mut_opt_ts_namespace_body(&mut self, node: &mut Option<TsNamespaceBody>) {
        VisitMut::visit_mut_opt_ts_namespace_body(&mut **self, node)
    }

    fn visit_mut_opt_ts_type(&mut self, node: &mut Option<Box<TsType>>) {
        VisitMut::visit_mut_opt_ts_type(&mut **self, node)
    }

    fn visit_mut_opt_ts_type_ann(&mut self, node: &mut Option<Box<TsTypeAnn>>) {
        VisitMut::visit_mut_opt_ts_type_ann(&mut **self, node)
    }

    fn visit_mut_opt_ts_type_param_decl(&mut self, node: &mut Option<Box<TsTypeParamDecl>>) {
        VisitMut::visit_mut_opt_ts_type_param_decl(&mut **self, node)
    }

    fn visit_mut_opt_ts_type_param_instantiation(
        &mut self,
        node: &mut Option<Box<TsTypeParamInstantiation>>,
    ) {
        VisitMut::visit_mut_opt_ts_type_param_instantiation(&mut **self, node)
    }

    fn visit_mut_opt_var_decl_or_expr(&mut self, node: &mut Option<VarDeclOrExpr>) {
        VisitMut::visit_mut_opt_var_decl_or_expr(&mut **self, node)
    }

    fn visit_mut_opt_vec_expr_or_spreads(&mut self, node: &mut Vec<Option<ExprOrSpread>>) {
        VisitMut::visit_mut_opt_vec_expr_or_spreads(&mut **self, node)
    }

    fn visit_mut_opt_vec_pats(&mut self, node: &mut Vec<Option<Pat>>) {
        VisitMut::visit_mut_opt_vec_pats(&mut **self, node)
    }

    fn visit_mut_param(&mut self, node: &mut Param) {
        VisitMut::visit_mut_param(&mut **self, node)
    }

    fn visit_mut_param_or_ts_param_prop(&mut self, node: &mut ParamOrTsParamProp) {
        VisitMut::visit_mut_param_or_ts_param_prop(&mut **self, node)
    }

    fn visit_mut_param_or_ts_param_props(&mut self, node: &mut Vec<ParamOrTsParamProp>) {
        VisitMut::visit_mut_param_or_ts_param_props(&mut **self, node)
    }

    fn visit_mut_params(&mut self, node: &mut Vec<Param>) {
        VisitMut::visit_mut_params(&mut **self, node)
    }

    fn visit_mut_paren_expr(&mut self, node: &mut ParenExpr) {
        VisitMut::visit_mut_paren_expr(&mut **self, node)
    }

    fn visit_mut_pat(&mut self, node: &mut Pat) {
        VisitMut::visit_mut_pat(&mut **self, node)
    }

    fn visit_mut_pats(&mut self, node: &mut Vec<Pat>) {
        VisitMut::visit_mut_pats(&mut **self, node)
    }

    fn visit_mut_private_method(&mut self, node: &mut PrivateMethod) {
        VisitMut::visit_mut_private_method(&mut **self, node)
    }

    fn visit_mut_private_name(&mut self, node: &mut PrivateName) {
        VisitMut::visit_mut_private_name(&mut **self, node)
    }

    fn visit_mut_private_prop(&mut self, node: &mut PrivateProp) {
        VisitMut::visit_mut_private_prop(&mut **self, node)
    }

    fn visit_mut_program(&mut self, node: &mut Program) {
        VisitMut::visit_mut_program(&mut **self, node)
    }

    fn visit_mut_prop(&mut self, node: &mut Prop) {
        VisitMut::visit_mut_prop(&mut **self, node)
    }

    fn visit_mut_prop_name(&mut self, node: &mut PropName) {
        VisitMut::visit_mut_prop_name(&mut **self, node)
    }

    fn visit_mut_prop_or_spread(&mut self, node: &mut PropOrSpread) {
        VisitMut::visit_mut_prop_or_spread(&mut **self, node)
    }

    fn visit_mut_prop_or_spreads(&mut self, node: &mut Vec<PropOrSpread>) {
        VisitMut::visit_mut_prop_or_spreads(&mut **self, node)
    }

    fn visit_mut_regex(&mut self, node: &mut Regex) {
        VisitMut::visit_mut_regex(&mut **self, node)
    }

    fn visit_mut_reserved_unused(&mut self, node: &mut ReservedUnused) {
        VisitMut::visit_mut_reserved_unused(&mut **self, node)
    }

    fn visit_mut_rest_pat(&mut self, node: &mut RestPat) {
        VisitMut::visit_mut_rest_pat(&mut **self, node)
    }

    fn visit_mut_return_stmt(&mut self, node: &mut ReturnStmt) {
        VisitMut::visit_mut_return_stmt(&mut **self, node)
    }

    fn visit_mut_script(&mut self, node: &mut Script) {
        VisitMut::visit_mut_script(&mut **self, node)
    }

    fn visit_mut_seq_expr(&mut self, node: &mut SeqExpr) {
        VisitMut::visit_mut_seq_expr(&mut **self, node)
    }

    fn visit_mut_setter_prop(&mut self, node: &mut SetterProp) {
        VisitMut::visit_mut_setter_prop(&mut **self, node)
    }

    fn visit_mut_simple_assign_target(&mut self, node: &mut SimpleAssignTarget) {
        VisitMut::visit_mut_simple_assign_target(&mut **self, node)
    }

    fn visit_mut_span(&mut self, node: &mut swc_common::Span) {
        VisitMut::visit_mut_span(&mut **self, node)
    }

    fn visit_mut_spread_element(&mut self, node: &mut SpreadElement) {
        VisitMut::visit_mut_spread_element(&mut **self, node)
    }

    fn visit_mut_static_block(&mut self, node: &mut StaticBlock) {
        VisitMut::visit_mut_static_block(&mut **self, node)
    }

    fn visit_mut_stmt(&mut self, node: &mut Stmt) {
        VisitMut::visit_mut_stmt(&mut **self, node)
    }

    fn visit_mut_stmts(&mut self, node: &mut Vec<Stmt>) {
        VisitMut::visit_mut_stmts(&mut **self, node)
    }

    fn visit_mut_str(&mut self, node: &mut Str) {
        VisitMut::visit_mut_str(&mut **self, node)
    }

    fn visit_mut_super(&mut self, node: &mut Super) {
        VisitMut::visit_mut_super(&mut **self, node)
    }

    fn visit_mut_super_prop(&mut self, node: &mut SuperProp) {
        VisitMut::visit_mut_super_prop(&mut **self, node)
    }

    fn visit_mut_super_prop_expr(&mut self, node: &mut SuperPropExpr) {
        VisitMut::visit_mut_super_prop_expr(&mut **self, node)
    }

    fn visit_mut_switch_case(&mut self, node: &mut SwitchCase) {
        VisitMut::visit_mut_switch_case(&mut **self, node)
    }

    fn visit_mut_switch_cases(&mut self, node: &mut Vec<SwitchCase>) {
        VisitMut::visit_mut_switch_cases(&mut **self, node)
    }

    fn visit_mut_switch_stmt(&mut self, node: &mut SwitchStmt) {
        VisitMut::visit_mut_switch_stmt(&mut **self, node)
    }

    fn visit_mut_syntax_context(&mut self, node: &mut swc_common::SyntaxContext) {
        VisitMut::visit_mut_syntax_context(&mut **self, node)
    }

    fn visit_mut_tagged_tpl(&mut self, node: &mut TaggedTpl) {
        VisitMut::visit_mut_tagged_tpl(&mut **self, node)
    }

    fn visit_mut_this_expr(&mut self, node: &mut ThisExpr) {
        VisitMut::visit_mut_this_expr(&mut **self, node)
    }

    fn visit_mut_throw_stmt(&mut self, node: &mut ThrowStmt) {
        VisitMut::visit_mut_throw_stmt(&mut **self, node)
    }

    fn visit_mut_tpl(&mut self, node: &mut Tpl) {
        VisitMut::visit_mut_tpl(&mut **self, node)
    }

    fn visit_mut_tpl_element(&mut self, node: &mut TplElement) {
        VisitMut::visit_mut_tpl_element(&mut **self, node)
    }

    fn visit_mut_tpl_elements(&mut self, node: &mut Vec<TplElement>) {
        VisitMut::visit_mut_tpl_elements(&mut **self, node)
    }

    fn visit_mut_true_plus_minus(&mut self, node: &mut TruePlusMinus) {
        VisitMut::visit_mut_true_plus_minus(&mut **self, node)
    }

    fn visit_mut_try_stmt(&mut self, node: &mut TryStmt) {
        VisitMut::visit_mut_try_stmt(&mut **self, node)
    }

    fn visit_mut_ts_array_type(&mut self, node: &mut TsArrayType) {
        VisitMut::visit_mut_ts_array_type(&mut **self, node)
    }

    fn visit_mut_ts_as_expr(&mut self, node: &mut TsAsExpr) {
        VisitMut::visit_mut_ts_as_expr(&mut **self, node)
    }

    fn visit_mut_ts_call_signature_decl(&mut self, node: &mut TsCallSignatureDecl) {
        VisitMut::visit_mut_ts_call_signature_decl(&mut **self, node)
    }

    fn visit_mut_ts_conditional_type(&mut self, node: &mut TsConditionalType) {
        VisitMut::visit_mut_ts_conditional_type(&mut **self, node)
    }

    fn visit_mut_ts_const_assertion(&mut self, node: &mut TsConstAssertion) {
        VisitMut::visit_mut_ts_const_assertion(&mut **self, node)
    }

    fn visit_mut_ts_construct_signature_decl(&mut self, node: &mut TsConstructSignatureDecl) {
        VisitMut::visit_mut_ts_construct_signature_decl(&mut **self, node)
    }

    fn visit_mut_ts_constructor_type(&mut self, node: &mut TsConstructorType) {
        VisitMut::visit_mut_ts_constructor_type(&mut **self, node)
    }

    fn visit_mut_ts_entity_name(&mut self, node: &mut TsEntityName) {
        VisitMut::visit_mut_ts_entity_name(&mut **self, node)
    }

    fn visit_mut_ts_enum_decl(&mut self, node: &mut TsEnumDecl) {
        VisitMut::visit_mut_ts_enum_decl(&mut **self, node)
    }

    fn visit_mut_ts_enum_member(&mut self, node: &mut TsEnumMember) {
        VisitMut::visit_mut_ts_enum_member(&mut **self, node)
    }

    fn visit_mut_ts_enum_member_id(&mut self, node: &mut TsEnumMemberId) {
        VisitMut::visit_mut_ts_enum_member_id(&mut **self, node)
    }

    fn visit_mut_ts_enum_members(&mut self, node: &mut Vec<TsEnumMember>) {
        VisitMut::visit_mut_ts_enum_members(&mut **self, node)
    }

    fn visit_mut_ts_export_assignment(&mut self, node: &mut TsExportAssignment) {
        VisitMut::visit_mut_ts_export_assignment(&mut **self, node)
    }

    fn visit_mut_ts_expr_with_type_args(&mut self, node: &mut TsExprWithTypeArgs) {
        VisitMut::visit_mut_ts_expr_with_type_args(&mut **self, node)
    }

    fn visit_mut_ts_expr_with_type_argss(&mut self, node: &mut Vec<TsExprWithTypeArgs>) {
        VisitMut::visit_mut_ts_expr_with_type_argss(&mut **self, node)
    }

    fn visit_mut_ts_external_module_ref(&mut self, node: &mut TsExternalModuleRef) {
        VisitMut::visit_mut_ts_external_module_ref(&mut **self, node)
    }

    fn visit_mut_ts_fn_or_constructor_type(&mut self, node: &mut TsFnOrConstructorType) {
        VisitMut::visit_mut_ts_fn_or_constructor_type(&mut **self, node)
    }

    fn visit_mut_ts_fn_param(&mut self, node: &mut TsFnParam) {
        VisitMut::visit_mut_ts_fn_param(&mut **self, node)
    }

    fn visit_mut_ts_fn_params(&mut self, node: &mut Vec<TsFnParam>) {
        VisitMut::visit_mut_ts_fn_params(&mut **self, node)
    }

    fn visit_mut_ts_fn_type(&mut self, node: &mut TsFnType) {
        VisitMut::visit_mut_ts_fn_type(&mut **self, node)
    }

    fn visit_mut_ts_getter_signature(&mut self, node: &mut TsGetterSignature) {
        VisitMut::visit_mut_ts_getter_signature(&mut **self, node)
    }

    fn visit_mut_ts_import_equals_decl(&mut self, node: &mut TsImportEqualsDecl) {
        VisitMut::visit_mut_ts_import_equals_decl(&mut **self, node)
    }

    fn visit_mut_ts_import_type(&mut self, node: &mut TsImportType) {
        VisitMut::visit_mut_ts_import_type(&mut **self, node)
    }

    fn visit_mut_ts_index_signature(&mut self, node: &mut TsIndexSignature) {
        VisitMut::visit_mut_ts_index_signature(&mut **self, node)
    }

    fn visit_mut_ts_indexed_access_type(&mut self, node: &mut TsIndexedAccessType) {
        VisitMut::visit_mut_ts_indexed_access_type(&mut **self, node)
    }

    fn visit_mut_ts_infer_type(&mut self, node: &mut TsInferType) {
        VisitMut::visit_mut_ts_infer_type(&mut **self, node)
    }

    fn visit_mut_ts_instantiation(&mut self, node: &mut TsInstantiation) {
        VisitMut::visit_mut_ts_instantiation(&mut **self, node)
    }

    fn visit_mut_ts_interface_body(&mut self, node: &mut TsInterfaceBody) {
        VisitMut::visit_mut_ts_interface_body(&mut **self, node)
    }

    fn visit_mut_ts_interface_decl(&mut self, node: &mut TsInterfaceDecl) {
        VisitMut::visit_mut_ts_interface_decl(&mut **self, node)
    }

    fn visit_mut_ts_intersection_type(&mut self, node: &mut TsIntersectionType) {
        VisitMut::visit_mut_ts_intersection_type(&mut **self, node)
    }

    fn visit_mut_ts_keyword_type(&mut self, node: &mut TsKeywordType) {
        VisitMut::visit_mut_ts_keyword_type(&mut **self, node)
    }

    fn visit_mut_ts_keyword_type_kind(&mut self, node: &mut TsKeywordTypeKind) {
        VisitMut::visit_mut_ts_keyword_type_kind(&mut **self, node)
    }

    fn visit_mut_ts_lit(&mut self, node: &mut TsLit) {
        VisitMut::visit_mut_ts_lit(&mut **self, node)
    }

    fn visit_mut_ts_lit_type(&mut self, node: &mut TsLitType) {
        VisitMut::visit_mut_ts_lit_type(&mut **self, node)
    }

    fn visit_mut_ts_mapped_type(&mut self, node: &mut TsMappedType) {
        VisitMut::visit_mut_ts_mapped_type(&mut **self, node)
    }

    fn visit_mut_ts_method_signature(&mut self, node: &mut TsMethodSignature) {
        VisitMut::visit_mut_ts_method_signature(&mut **self, node)
    }

    fn visit_mut_ts_module_block(&mut self, node: &mut TsModuleBlock) {
        VisitMut::visit_mut_ts_module_block(&mut **self, node)
    }

    fn visit_mut_ts_module_decl(&mut self, node: &mut TsModuleDecl) {
        VisitMut::visit_mut_ts_module_decl(&mut **self, node)
    }

    fn visit_mut_ts_module_name(&mut self, node: &mut TsModuleName) {
        VisitMut::visit_mut_ts_module_name(&mut **self, node)
    }

    fn visit_mut_ts_module_ref(&mut self, node: &mut TsModuleRef) {
        VisitMut::visit_mut_ts_module_ref(&mut **self, node)
    }

    fn visit_mut_ts_namespace_body(&mut self, node: &mut TsNamespaceBody) {
        VisitMut::visit_mut_ts_namespace_body(&mut **self, node)
    }

    fn visit_mut_ts_namespace_decl(&mut self, node: &mut TsNamespaceDecl) {
        VisitMut::visit_mut_ts_namespace_decl(&mut **self, node)
    }

    fn visit_mut_ts_namespace_export_decl(&mut self, node: &mut TsNamespaceExportDecl) {
        VisitMut::visit_mut_ts_namespace_export_decl(&mut **self, node)
    }

    fn visit_mut_ts_non_null_expr(&mut self, node: &mut TsNonNullExpr) {
        VisitMut::visit_mut_ts_non_null_expr(&mut **self, node)
    }

    fn visit_mut_ts_optional_type(&mut self, node: &mut TsOptionalType) {
        VisitMut::visit_mut_ts_optional_type(&mut **self, node)
    }

    fn visit_mut_ts_param_prop(&mut self, node: &mut TsParamProp) {
        VisitMut::visit_mut_ts_param_prop(&mut **self, node)
    }

    fn visit_mut_ts_param_prop_param(&mut self, node: &mut TsParamPropParam) {
        VisitMut::visit_mut_ts_param_prop_param(&mut **self, node)
    }

    fn visit_mut_ts_parenthesized_type(&mut self, node: &mut TsParenthesizedType) {
        VisitMut::visit_mut_ts_parenthesized_type(&mut **self, node)
    }

    fn visit_mut_ts_property_signature(&mut self, node: &mut TsPropertySignature) {
        VisitMut::visit_mut_ts_property_signature(&mut **self, node)
    }

    fn visit_mut_ts_qualified_name(&mut self, node: &mut TsQualifiedName) {
        VisitMut::visit_mut_ts_qualified_name(&mut **self, node)
    }

    fn visit_mut_ts_rest_type(&mut self, node: &mut TsRestType) {
        VisitMut::visit_mut_ts_rest_type(&mut **self, node)
    }

    fn visit_mut_ts_satisfies_expr(&mut self, node: &mut TsSatisfiesExpr) {
        VisitMut::visit_mut_ts_satisfies_expr(&mut **self, node)
    }

    fn visit_mut_ts_setter_signature(&mut self, node: &mut TsSetterSignature) {
        VisitMut::visit_mut_ts_setter_signature(&mut **self, node)
    }

    fn visit_mut_ts_this_type(&mut self, node: &mut TsThisType) {
        VisitMut::visit_mut_ts_this_type(&mut **self, node)
    }

    fn visit_mut_ts_this_type_or_ident(&mut self, node: &mut TsThisTypeOrIdent) {
        VisitMut::visit_mut_ts_this_type_or_ident(&mut **self, node)
    }

    fn visit_mut_ts_tpl_lit_type(&mut self, node: &mut TsTplLitType) {
        VisitMut::visit_mut_ts_tpl_lit_type(&mut **self, node)
    }

    fn visit_mut_ts_tuple_element(&mut self, node: &mut TsTupleElement) {
        VisitMut::visit_mut_ts_tuple_element(&mut **self, node)
    }

    fn visit_mut_ts_tuple_elements(&mut self, node: &mut Vec<TsTupleElement>) {
        VisitMut::visit_mut_ts_tuple_elements(&mut **self, node)
    }

    fn visit_mut_ts_tuple_type(&mut self, node: &mut TsTupleType) {
        VisitMut::visit_mut_ts_tuple_type(&mut **self, node)
    }

    fn visit_mut_ts_type(&mut self, node: &mut TsType) {
        VisitMut::visit_mut_ts_type(&mut **self, node)
    }

    fn visit_mut_ts_type_alias_decl(&mut self, node: &mut TsTypeAliasDecl) {
        VisitMut::visit_mut_ts_type_alias_decl(&mut **self, node)
    }

    fn visit_mut_ts_type_ann(&mut self, node: &mut TsTypeAnn) {
        VisitMut::visit_mut_ts_type_ann(&mut **self, node)
    }

    fn visit_mut_ts_type_assertion(&mut self, node: &mut TsTypeAssertion) {
        VisitMut::visit_mut_ts_type_assertion(&mut **self, node)
    }

    fn visit_mut_ts_type_element(&mut self, node: &mut TsTypeElement) {
        VisitMut::visit_mut_ts_type_element(&mut **self, node)
    }

    fn visit_mut_ts_type_elements(&mut self, node: &mut Vec<TsTypeElement>) {
        VisitMut::visit_mut_ts_type_elements(&mut **self, node)
    }

    fn visit_mut_ts_type_lit(&mut self, node: &mut TsTypeLit) {
        VisitMut::visit_mut_ts_type_lit(&mut **self, node)
    }

    fn visit_mut_ts_type_operator(&mut self, node: &mut TsTypeOperator) {
        VisitMut::visit_mut_ts_type_operator(&mut **self, node)
    }

    fn visit_mut_ts_type_operator_op(&mut self, node: &mut TsTypeOperatorOp) {
        VisitMut::visit_mut_ts_type_operator_op(&mut **self, node)
    }

    fn visit_mut_ts_type_param(&mut self, node: &mut TsTypeParam) {
        VisitMut::visit_mut_ts_type_param(&mut **self, node)
    }

    fn visit_mut_ts_type_param_decl(&mut self, node: &mut TsTypeParamDecl) {
        VisitMut::visit_mut_ts_type_param_decl(&mut **self, node)
    }

    fn visit_mut_ts_type_param_instantiation(&mut self, node: &mut TsTypeParamInstantiation) {
        VisitMut::visit_mut_ts_type_param_instantiation(&mut **self, node)
    }

    fn visit_mut_ts_type_params(&mut self, node: &mut Vec<TsTypeParam>) {
        VisitMut::visit_mut_ts_type_params(&mut **self, node)
    }

    fn visit_mut_ts_type_predicate(&mut self, node: &mut TsTypePredicate) {
        VisitMut::visit_mut_ts_type_predicate(&mut **self, node)
    }

    fn visit_mut_ts_type_query(&mut self, node: &mut TsTypeQuery) {
        VisitMut::visit_mut_ts_type_query(&mut **self, node)
    }

    fn visit_mut_ts_type_query_expr(&mut self, node: &mut TsTypeQueryExpr) {
        VisitMut::visit_mut_ts_type_query_expr(&mut **self, node)
    }

    fn visit_mut_ts_type_ref(&mut self, node: &mut TsTypeRef) {
        VisitMut::visit_mut_ts_type_ref(&mut **self, node)
    }

    fn visit_mut_ts_types(&mut self, node: &mut Vec<Box<TsType>>) {
        VisitMut::visit_mut_ts_types(&mut **self, node)
    }

    fn visit_mut_ts_union_or_intersection_type(&mut self, node: &mut TsUnionOrIntersectionType) {
        VisitMut::visit_mut_ts_union_or_intersection_type(&mut **self, node)
    }

    fn visit_mut_ts_union_type(&mut self, node: &mut TsUnionType) {
        VisitMut::visit_mut_ts_union_type(&mut **self, node)
    }

    fn visit_mut_unary_expr(&mut self, node: &mut UnaryExpr) {
        VisitMut::visit_mut_unary_expr(&mut **self, node)
    }

    fn visit_mut_unary_op(&mut self, node: &mut UnaryOp) {
        VisitMut::visit_mut_unary_op(&mut **self, node)
    }

    fn visit_mut_update_expr(&mut self, node: &mut UpdateExpr) {
        VisitMut::visit_mut_update_expr(&mut **self, node)
    }

    fn visit_mut_update_op(&mut self, node: &mut UpdateOp) {
        VisitMut::visit_mut_update_op(&mut **self, node)
    }

    fn visit_mut_using_decl(&mut self, node: &mut UsingDecl) {
        VisitMut::visit_mut_using_decl(&mut **self, node)
    }

    fn visit_mut_var_decl(&mut self, node: &mut VarDecl) {
        VisitMut::visit_mut_var_decl(&mut **self, node)
    }

    fn visit_mut_var_decl_kind(&mut self, node: &mut VarDeclKind) {
        VisitMut::visit_mut_var_decl_kind(&mut **self, node)
    }

    fn visit_mut_var_decl_or_expr(&mut self, node: &mut VarDeclOrExpr) {
        VisitMut::visit_mut_var_decl_or_expr(&mut **self, node)
    }

    fn visit_mut_var_declarator(&mut self, node: &mut VarDeclarator) {
        VisitMut::visit_mut_var_declarator(&mut **self, node)
    }

    fn visit_mut_var_declarators(&mut self, node: &mut Vec<VarDeclarator>) {
        VisitMut::visit_mut_var_declarators(&mut **self, node)
    }

    fn visit_mut_while_stmt(&mut self, node: &mut WhileStmt) {
        VisitMut::visit_mut_while_stmt(&mut **self, node)
    }

    fn visit_mut_with_stmt(&mut self, node: &mut WithStmt) {
        VisitMut::visit_mut_with_stmt(&mut **self, node)
    }

    fn visit_mut_yield_expr(&mut self, node: &mut YieldExpr) {
        VisitMut::visit_mut_yield_expr(&mut **self, node)
    }
}
impl<A, B> VisitMut for ::swc_visit::Either<A, B>
where
    A: VisitMut,
    B: VisitMut,
{
    fn visit_mut_accessibility(&mut self, node: &mut Accessibility) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_accessibility(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_accessibility(self, node),
        }
    }

    fn visit_mut_array_lit(&mut self, node: &mut ArrayLit) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_array_lit(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_array_lit(self, node),
        }
    }

    fn visit_mut_array_pat(&mut self, node: &mut ArrayPat) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_array_pat(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_array_pat(self, node),
        }
    }

    fn visit_mut_arrow_expr(&mut self, node: &mut ArrowExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_arrow_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_arrow_expr(self, node),
        }
    }

    fn visit_mut_assign_expr(&mut self, node: &mut AssignExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_assign_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_assign_expr(self, node),
        }
    }

    fn visit_mut_assign_op(&mut self, node: &mut AssignOp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_assign_op(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_assign_op(self, node),
        }
    }

    fn visit_mut_assign_pat(&mut self, node: &mut AssignPat) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_assign_pat(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_assign_pat(self, node),
        }
    }

    fn visit_mut_assign_pat_prop(&mut self, node: &mut AssignPatProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_assign_pat_prop(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_assign_pat_prop(self, node),
        }
    }

    fn visit_mut_assign_prop(&mut self, node: &mut AssignProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_assign_prop(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_assign_prop(self, node),
        }
    }

    fn visit_mut_assign_target(&mut self, node: &mut AssignTarget) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_assign_target(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_assign_target(self, node),
        }
    }

    fn visit_mut_assign_target_pat(&mut self, node: &mut AssignTargetPat) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_assign_target_pat(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_assign_target_pat(self, node),
        }
    }

    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_atom(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_atom(self, node),
        }
    }

    fn visit_mut_auto_accessor(&mut self, node: &mut AutoAccessor) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_auto_accessor(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_auto_accessor(self, node),
        }
    }

    fn visit_mut_await_expr(&mut self, node: &mut AwaitExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_await_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_await_expr(self, node),
        }
    }

    fn visit_mut_big_int(&mut self, node: &mut BigInt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_big_int(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_big_int(self, node),
        }
    }

    fn visit_mut_big_int_value(&mut self, node: &mut BigIntValue) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_big_int_value(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_big_int_value(self, node),
        }
    }

    fn visit_mut_bin_expr(&mut self, node: &mut BinExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_bin_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_bin_expr(self, node),
        }
    }

    fn visit_mut_binary_op(&mut self, node: &mut BinaryOp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_binary_op(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_binary_op(self, node),
        }
    }

    fn visit_mut_binding_ident(&mut self, node: &mut BindingIdent) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_binding_ident(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_binding_ident(self, node),
        }
    }

    fn visit_mut_block_stmt(&mut self, node: &mut BlockStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_block_stmt(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_block_stmt(self, node),
        }
    }

    fn visit_mut_block_stmt_or_expr(&mut self, node: &mut BlockStmtOrExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_block_stmt_or_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_block_stmt_or_expr(self, node),
        }
    }

    fn visit_mut_bool(&mut self, node: &mut Bool) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_bool(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_bool(self, node),
        }
    }

    fn visit_mut_break_stmt(&mut self, node: &mut BreakStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_break_stmt(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_break_stmt(self, node),
        }
    }

    fn visit_mut_call_expr(&mut self, node: &mut CallExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_call_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_call_expr(self, node),
        }
    }

    fn visit_mut_callee(&mut self, node: &mut Callee) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_callee(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_callee(self, node),
        }
    }

    fn visit_mut_catch_clause(&mut self, node: &mut CatchClause) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_catch_clause(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_catch_clause(self, node),
        }
    }

    fn visit_mut_class(&mut self, node: &mut Class) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_class(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_class(self, node),
        }
    }

    fn visit_mut_class_decl(&mut self, node: &mut ClassDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_class_decl(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_class_decl(self, node),
        }
    }

    fn visit_mut_class_expr(&mut self, node: &mut ClassExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_class_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_class_expr(self, node),
        }
    }

    fn visit_mut_class_member(&mut self, node: &mut ClassMember) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_class_member(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_class_member(self, node),
        }
    }

    fn visit_mut_class_members(&mut self, node: &mut Vec<ClassMember>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_class_members(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_class_members(self, node),
        }
    }

    fn visit_mut_class_method(&mut self, node: &mut ClassMethod) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_class_method(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_class_method(self, node),
        }
    }

    fn visit_mut_class_prop(&mut self, node: &mut ClassProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_class_prop(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_class_prop(self, node),
        }
    }

    fn visit_mut_computed_prop_name(&mut self, node: &mut ComputedPropName) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_computed_prop_name(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_computed_prop_name(self, node),
        }
    }

    fn visit_mut_cond_expr(&mut self, node: &mut CondExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_cond_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_cond_expr(self, node),
        }
    }

    fn visit_mut_constructor(&mut self, node: &mut Constructor) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_constructor(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_constructor(self, node),
        }
    }

    fn visit_mut_continue_stmt(&mut self, node: &mut ContinueStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_continue_stmt(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_continue_stmt(self, node),
        }
    }

    fn visit_mut_debugger_stmt(&mut self, node: &mut DebuggerStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_debugger_stmt(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_debugger_stmt(self, node),
        }
    }

    fn visit_mut_decl(&mut self, node: &mut Decl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_decl(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_decl(self, node),
        }
    }

    fn visit_mut_decorator(&mut self, node: &mut Decorator) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_decorator(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_decorator(self, node),
        }
    }

    fn visit_mut_decorators(&mut self, node: &mut Vec<Decorator>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_decorators(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_decorators(self, node),
        }
    }

    fn visit_mut_default_decl(&mut self, node: &mut DefaultDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_default_decl(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_default_decl(self, node),
        }
    }

    fn visit_mut_do_while_stmt(&mut self, node: &mut DoWhileStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_do_while_stmt(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_do_while_stmt(self, node),
        }
    }

    fn visit_mut_empty_stmt(&mut self, node: &mut EmptyStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_empty_stmt(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_empty_stmt(self, node),
        }
    }

    fn visit_mut_es_version(&mut self, node: &mut EsVersion) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_es_version(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_es_version(self, node),
        }
    }

    fn visit_mut_export_all(&mut self, node: &mut ExportAll) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_export_all(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_export_all(self, node),
        }
    }

    fn visit_mut_export_decl(&mut self, node: &mut ExportDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_export_decl(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_export_decl(self, node),
        }
    }

    fn visit_mut_export_default_decl(&mut self, node: &mut ExportDefaultDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_export_default_decl(self, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_export_default_decl(self, node)
            }
        }
    }

    fn visit_mut_export_default_expr(&mut self, node: &mut ExportDefaultExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_export_default_expr(self, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_export_default_expr(self, node)
            }
        }
    }

    fn visit_mut_export_default_specifier(&mut self, node: &mut ExportDefaultSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_export_default_specifier(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_export_default_specifier(self, node)
            }
        }
    }

    fn visit_mut_export_named_specifier(&mut self, node: &mut ExportNamedSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_export_named_specifier(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_export_named_specifier(self, node)
            }
        }
    }

    fn visit_mut_export_namespace_specifier(&mut self, node: &mut ExportNamespaceSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_export_namespace_specifier(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_export_namespace_specifier(self, node)
            }
        }
    }

    fn visit_mut_export_specifier(&mut self, node: &mut ExportSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_export_specifier(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_export_specifier(self, node),
        }
    }

    fn visit_mut_export_specifiers(&mut self, node: &mut Vec<ExportSpecifier>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_export_specifiers(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_export_specifiers(self, node),
        }
    }

    fn visit_mut_expr(&mut self, node: &mut Expr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_expr(self, node),
        }
    }

    fn visit_mut_expr_or_spread(&mut self, node: &mut ExprOrSpread) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_expr_or_spread(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_expr_or_spread(self, node),
        }
    }

    fn visit_mut_expr_or_spreads(&mut self, node: &mut Vec<ExprOrSpread>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_expr_or_spreads(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_expr_or_spreads(self, node),
        }
    }

    fn visit_mut_expr_stmt(&mut self, node: &mut ExprStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_expr_stmt(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_expr_stmt(self, node),
        }
    }

    fn visit_mut_exprs(&mut self, node: &mut Vec<Box<Expr>>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_exprs(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_exprs(self, node),
        }
    }

    fn visit_mut_fn_decl(&mut self, node: &mut FnDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_fn_decl(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_fn_decl(self, node),
        }
    }

    fn visit_mut_fn_expr(&mut self, node: &mut FnExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_fn_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_fn_expr(self, node),
        }
    }

    fn visit_mut_for_head(&mut self, node: &mut ForHead) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_for_head(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_for_head(self, node),
        }
    }

    fn visit_mut_for_in_stmt(&mut self, node: &mut ForInStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_for_in_stmt(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_for_in_stmt(self, node),
        }
    }

    fn visit_mut_for_of_stmt(&mut self, node: &mut ForOfStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_for_of_stmt(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_for_of_stmt(self, node),
        }
    }

    fn visit_mut_for_stmt(&mut self, node: &mut ForStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_for_stmt(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_for_stmt(self, node),
        }
    }

    fn visit_mut_function(&mut self, node: &mut Function) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_function(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_function(self, node),
        }
    }

    fn visit_mut_getter_prop(&mut self, node: &mut GetterProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_getter_prop(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_getter_prop(self, node),
        }
    }

    fn visit_mut_ident(&mut self, node: &mut Ident) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ident(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ident(self, node),
        }
    }

    fn visit_mut_ident_name(&mut self, node: &mut IdentName) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ident_name(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ident_name(self, node),
        }
    }

    fn visit_mut_if_stmt(&mut self, node: &mut IfStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_if_stmt(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_if_stmt(self, node),
        }
    }

    fn visit_mut_import(&mut self, node: &mut Import) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_import(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_import(self, node),
        }
    }

    fn visit_mut_import_decl(&mut self, node: &mut ImportDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_import_decl(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_import_decl(self, node),
        }
    }

    fn visit_mut_import_default_specifier(&mut self, node: &mut ImportDefaultSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_import_default_specifier(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_import_default_specifier(self, node)
            }
        }
    }

    fn visit_mut_import_named_specifier(&mut self, node: &mut ImportNamedSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_import_named_specifier(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_import_named_specifier(self, node)
            }
        }
    }

    fn visit_mut_import_phase(&mut self, node: &mut ImportPhase) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_import_phase(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_import_phase(self, node),
        }
    }

    fn visit_mut_import_specifier(&mut self, node: &mut ImportSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_import_specifier(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_import_specifier(self, node),
        }
    }

    fn visit_mut_import_specifiers(&mut self, node: &mut Vec<ImportSpecifier>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_import_specifiers(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_import_specifiers(self, node),
        }
    }

    fn visit_mut_import_star_as_specifier(&mut self, node: &mut ImportStarAsSpecifier) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_import_star_as_specifier(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_import_star_as_specifier(self, node)
            }
        }
    }

    fn visit_mut_import_with(&mut self, node: &mut ImportWith) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_import_with(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_import_with(self, node),
        }
    }

    fn visit_mut_import_with_item(&mut self, node: &mut ImportWithItem) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_import_with_item(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_import_with_item(self, node),
        }
    }

    fn visit_mut_import_with_items(&mut self, node: &mut Vec<ImportWithItem>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_import_with_items(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_import_with_items(self, node),
        }
    }

    fn visit_mut_invalid(&mut self, node: &mut Invalid) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_invalid(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_invalid(self, node),
        }
    }

    fn visit_mut_jsx_attr(&mut self, node: &mut JSXAttr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_attr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_attr(self, node),
        }
    }

    fn visit_mut_jsx_attr_name(&mut self, node: &mut JSXAttrName) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_attr_name(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_attr_name(self, node),
        }
    }

    fn visit_mut_jsx_attr_or_spread(&mut self, node: &mut JSXAttrOrSpread) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_attr_or_spread(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_attr_or_spread(self, node),
        }
    }

    fn visit_mut_jsx_attr_or_spreads(&mut self, node: &mut Vec<JSXAttrOrSpread>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_attr_or_spreads(self, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_jsx_attr_or_spreads(self, node)
            }
        }
    }

    fn visit_mut_jsx_attr_value(&mut self, node: &mut JSXAttrValue) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_attr_value(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_attr_value(self, node),
        }
    }

    fn visit_mut_jsx_closing_element(&mut self, node: &mut JSXClosingElement) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_closing_element(self, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_jsx_closing_element(self, node)
            }
        }
    }

    fn visit_mut_jsx_closing_fragment(&mut self, node: &mut JSXClosingFragment) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_jsx_closing_fragment(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_jsx_closing_fragment(self, node)
            }
        }
    }

    fn visit_mut_jsx_element(&mut self, node: &mut JSXElement) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_element(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_element(self, node),
        }
    }

    fn visit_mut_jsx_element_child(&mut self, node: &mut JSXElementChild) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_element_child(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_element_child(self, node),
        }
    }

    fn visit_mut_jsx_element_childs(&mut self, node: &mut Vec<JSXElementChild>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_element_childs(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_element_childs(self, node),
        }
    }

    fn visit_mut_jsx_element_name(&mut self, node: &mut JSXElementName) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_element_name(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_element_name(self, node),
        }
    }

    fn visit_mut_jsx_empty_expr(&mut self, node: &mut JSXEmptyExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_empty_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_empty_expr(self, node),
        }
    }

    fn visit_mut_jsx_expr(&mut self, node: &mut JSXExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_expr(self, node),
        }
    }

    fn visit_mut_jsx_expr_container(&mut self, node: &mut JSXExprContainer) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_expr_container(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_expr_container(self, node),
        }
    }

    fn visit_mut_jsx_fragment(&mut self, node: &mut JSXFragment) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_fragment(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_fragment(self, node),
        }
    }

    fn visit_mut_jsx_member_expr(&mut self, node: &mut JSXMemberExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_member_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_member_expr(self, node),
        }
    }

    fn visit_mut_jsx_namespaced_name(&mut self, node: &mut JSXNamespacedName) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_namespaced_name(self, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_jsx_namespaced_name(self, node)
            }
        }
    }

    fn visit_mut_jsx_object(&mut self, node: &mut JSXObject) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_object(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_object(self, node),
        }
    }

    fn visit_mut_jsx_opening_element(&mut self, node: &mut JSXOpeningElement) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_opening_element(self, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_jsx_opening_element(self, node)
            }
        }
    }

    fn visit_mut_jsx_opening_fragment(&mut self, node: &mut JSXOpeningFragment) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_jsx_opening_fragment(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_jsx_opening_fragment(self, node)
            }
        }
    }

    fn visit_mut_jsx_spread_child(&mut self, node: &mut JSXSpreadChild) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_spread_child(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_spread_child(self, node),
        }
    }

    fn visit_mut_jsx_text(&mut self, node: &mut JSXText) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_jsx_text(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_jsx_text(self, node),
        }
    }

    fn visit_mut_key(&mut self, node: &mut Key) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_key(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_key(self, node),
        }
    }

    fn visit_mut_key_value_pat_prop(&mut self, node: &mut KeyValuePatProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_key_value_pat_prop(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_key_value_pat_prop(self, node),
        }
    }

    fn visit_mut_key_value_prop(&mut self, node: &mut KeyValueProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_key_value_prop(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_key_value_prop(self, node),
        }
    }

    fn visit_mut_labeled_stmt(&mut self, node: &mut LabeledStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_labeled_stmt(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_labeled_stmt(self, node),
        }
    }

    fn visit_mut_lit(&mut self, node: &mut Lit) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_lit(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_lit(self, node),
        }
    }

    fn visit_mut_member_expr(&mut self, node: &mut MemberExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_member_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_member_expr(self, node),
        }
    }

    fn visit_mut_member_prop(&mut self, node: &mut MemberProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_member_prop(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_member_prop(self, node),
        }
    }

    fn visit_mut_meta_prop_expr(&mut self, node: &mut MetaPropExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_meta_prop_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_meta_prop_expr(self, node),
        }
    }

    fn visit_mut_meta_prop_kind(&mut self, node: &mut MetaPropKind) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_meta_prop_kind(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_meta_prop_kind(self, node),
        }
    }

    fn visit_mut_method_kind(&mut self, node: &mut MethodKind) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_method_kind(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_method_kind(self, node),
        }
    }

    fn visit_mut_method_prop(&mut self, node: &mut MethodProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_method_prop(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_method_prop(self, node),
        }
    }

    fn visit_mut_module(&mut self, node: &mut Module) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_module(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_module(self, node),
        }
    }

    fn visit_mut_module_decl(&mut self, node: &mut ModuleDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_module_decl(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_module_decl(self, node),
        }
    }

    fn visit_mut_module_export_name(&mut self, node: &mut ModuleExportName) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_module_export_name(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_module_export_name(self, node),
        }
    }

    fn visit_mut_module_item(&mut self, node: &mut ModuleItem) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_module_item(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_module_item(self, node),
        }
    }

    fn visit_mut_module_items(&mut self, node: &mut Vec<ModuleItem>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_module_items(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_module_items(self, node),
        }
    }

    fn visit_mut_named_export(&mut self, node: &mut NamedExport) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_named_export(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_named_export(self, node),
        }
    }

    fn visit_mut_new_expr(&mut self, node: &mut NewExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_new_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_new_expr(self, node),
        }
    }

    fn visit_mut_null(&mut self, node: &mut Null) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_null(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_null(self, node),
        }
    }

    fn visit_mut_number(&mut self, node: &mut Number) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_number(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_number(self, node),
        }
    }

    fn visit_mut_object_lit(&mut self, node: &mut ObjectLit) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_object_lit(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_object_lit(self, node),
        }
    }

    fn visit_mut_object_pat(&mut self, node: &mut ObjectPat) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_object_pat(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_object_pat(self, node),
        }
    }

    fn visit_mut_object_pat_prop(&mut self, node: &mut ObjectPatProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_object_pat_prop(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_object_pat_prop(self, node),
        }
    }

    fn visit_mut_object_pat_props(&mut self, node: &mut Vec<ObjectPatProp>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_object_pat_props(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_object_pat_props(self, node),
        }
    }

    fn visit_mut_opt_accessibility(&mut self, node: &mut Option<Accessibility>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_accessibility(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_accessibility(self, node),
        }
    }

    fn visit_mut_opt_atom(&mut self, node: &mut Option<swc_atoms::Atom>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_atom(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_atom(self, node),
        }
    }

    fn visit_mut_opt_block_stmt(&mut self, node: &mut Option<BlockStmt>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_block_stmt(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_block_stmt(self, node),
        }
    }

    fn visit_mut_opt_call(&mut self, node: &mut OptCall) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_call(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_call(self, node),
        }
    }

    fn visit_mut_opt_catch_clause(&mut self, node: &mut Option<CatchClause>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_catch_clause(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_catch_clause(self, node),
        }
    }

    fn visit_mut_opt_chain_base(&mut self, node: &mut OptChainBase) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_chain_base(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_chain_base(self, node),
        }
    }

    fn visit_mut_opt_chain_expr(&mut self, node: &mut OptChainExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_chain_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_chain_expr(self, node),
        }
    }

    fn visit_mut_opt_expr(&mut self, node: &mut Option<Box<Expr>>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_expr(self, node),
        }
    }

    fn visit_mut_opt_expr_or_spread(&mut self, node: &mut Option<ExprOrSpread>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_expr_or_spread(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_expr_or_spread(self, node),
        }
    }

    fn visit_mut_opt_expr_or_spreads(&mut self, node: &mut Option<Vec<ExprOrSpread>>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_expr_or_spreads(self, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_opt_expr_or_spreads(self, node)
            }
        }
    }

    fn visit_mut_opt_ident(&mut self, node: &mut Option<Ident>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_ident(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_ident(self, node),
        }
    }

    fn visit_mut_opt_jsx_attr_value(&mut self, node: &mut Option<JSXAttrValue>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_jsx_attr_value(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_jsx_attr_value(self, node),
        }
    }

    fn visit_mut_opt_jsx_closing_element(&mut self, node: &mut Option<JSXClosingElement>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_opt_jsx_closing_element(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_opt_jsx_closing_element(self, node)
            }
        }
    }

    fn visit_mut_opt_module_export_name(&mut self, node: &mut Option<ModuleExportName>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_opt_module_export_name(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_opt_module_export_name(self, node)
            }
        }
    }

    fn visit_mut_opt_module_items(&mut self, node: &mut Option<Vec<ModuleItem>>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_module_items(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_module_items(self, node),
        }
    }

    fn visit_mut_opt_object_lit(&mut self, node: &mut Option<Box<ObjectLit>>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_object_lit(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_object_lit(self, node),
        }
    }

    fn visit_mut_opt_pat(&mut self, node: &mut Option<Pat>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_pat(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_pat(self, node),
        }
    }

    fn visit_mut_opt_span(&mut self, node: &mut Option<swc_common::Span>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_span(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_span(self, node),
        }
    }

    fn visit_mut_opt_stmt(&mut self, node: &mut Option<Box<Stmt>>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_stmt(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_stmt(self, node),
        }
    }

    fn visit_mut_opt_str(&mut self, node: &mut Option<Box<Str>>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_str(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_str(self, node),
        }
    }

    fn visit_mut_opt_true_plus_minus(&mut self, node: &mut Option<TruePlusMinus>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_true_plus_minus(self, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_opt_true_plus_minus(self, node)
            }
        }
    }

    fn visit_mut_opt_ts_entity_name(&mut self, node: &mut Option<TsEntityName>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_ts_entity_name(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_ts_entity_name(self, node),
        }
    }

    fn visit_mut_opt_ts_namespace_body(&mut self, node: &mut Option<TsNamespaceBody>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_opt_ts_namespace_body(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_opt_ts_namespace_body(self, node)
            }
        }
    }

    fn visit_mut_opt_ts_type(&mut self, node: &mut Option<Box<TsType>>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_ts_type(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_ts_type(self, node),
        }
    }

    fn visit_mut_opt_ts_type_ann(&mut self, node: &mut Option<Box<TsTypeAnn>>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_ts_type_ann(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_ts_type_ann(self, node),
        }
    }

    fn visit_mut_opt_ts_type_param_decl(&mut self, node: &mut Option<Box<TsTypeParamDecl>>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_opt_ts_type_param_decl(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_opt_ts_type_param_decl(self, node)
            }
        }
    }

    fn visit_mut_opt_ts_type_param_instantiation(
        &mut self,
        node: &mut Option<Box<TsTypeParamInstantiation>>,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_opt_ts_type_param_instantiation(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_opt_ts_type_param_instantiation(self, node)
            }
        }
    }

    fn visit_mut_opt_var_decl_or_expr(&mut self, node: &mut Option<VarDeclOrExpr>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_opt_var_decl_or_expr(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_opt_var_decl_or_expr(self, node)
            }
        }
    }

    fn visit_mut_opt_vec_expr_or_spreads(&mut self, node: &mut Vec<Option<ExprOrSpread>>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_opt_vec_expr_or_spreads(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_opt_vec_expr_or_spreads(self, node)
            }
        }
    }

    fn visit_mut_opt_vec_pats(&mut self, node: &mut Vec<Option<Pat>>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_opt_vec_pats(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_opt_vec_pats(self, node),
        }
    }

    fn visit_mut_param(&mut self, node: &mut Param) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_param(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_param(self, node),
        }
    }

    fn visit_mut_param_or_ts_param_prop(&mut self, node: &mut ParamOrTsParamProp) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_param_or_ts_param_prop(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_param_or_ts_param_prop(self, node)
            }
        }
    }

    fn visit_mut_param_or_ts_param_props(&mut self, node: &mut Vec<ParamOrTsParamProp>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_param_or_ts_param_props(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_param_or_ts_param_props(self, node)
            }
        }
    }

    fn visit_mut_params(&mut self, node: &mut Vec<Param>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_params(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_params(self, node),
        }
    }

    fn visit_mut_paren_expr(&mut self, node: &mut ParenExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_paren_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_paren_expr(self, node),
        }
    }

    fn visit_mut_pat(&mut self, node: &mut Pat) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_pat(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_pat(self, node),
        }
    }

    fn visit_mut_pats(&mut self, node: &mut Vec<Pat>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_pats(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_pats(self, node),
        }
    }

    fn visit_mut_private_method(&mut self, node: &mut PrivateMethod) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_private_method(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_private_method(self, node),
        }
    }

    fn visit_mut_private_name(&mut self, node: &mut PrivateName) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_private_name(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_private_name(self, node),
        }
    }

    fn visit_mut_private_prop(&mut self, node: &mut PrivateProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_private_prop(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_private_prop(self, node),
        }
    }

    fn visit_mut_program(&mut self, node: &mut Program) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_program(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_program(self, node),
        }
    }

    fn visit_mut_prop(&mut self, node: &mut Prop) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_prop(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_prop(self, node),
        }
    }

    fn visit_mut_prop_name(&mut self, node: &mut PropName) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_prop_name(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_prop_name(self, node),
        }
    }

    fn visit_mut_prop_or_spread(&mut self, node: &mut PropOrSpread) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_prop_or_spread(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_prop_or_spread(self, node),
        }
    }

    fn visit_mut_prop_or_spreads(&mut self, node: &mut Vec<PropOrSpread>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_prop_or_spreads(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_prop_or_spreads(self, node),
        }
    }

    fn visit_mut_regex(&mut self, node: &mut Regex) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_regex(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_regex(self, node),
        }
    }

    fn visit_mut_reserved_unused(&mut self, node: &mut ReservedUnused) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_reserved_unused(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_reserved_unused(self, node),
        }
    }

    fn visit_mut_rest_pat(&mut self, node: &mut RestPat) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_rest_pat(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_rest_pat(self, node),
        }
    }

    fn visit_mut_return_stmt(&mut self, node: &mut ReturnStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_return_stmt(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_return_stmt(self, node),
        }
    }

    fn visit_mut_script(&mut self, node: &mut Script) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_script(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_script(self, node),
        }
    }

    fn visit_mut_seq_expr(&mut self, node: &mut SeqExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_seq_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_seq_expr(self, node),
        }
    }

    fn visit_mut_setter_prop(&mut self, node: &mut SetterProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_setter_prop(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_setter_prop(self, node),
        }
    }

    fn visit_mut_simple_assign_target(&mut self, node: &mut SimpleAssignTarget) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_simple_assign_target(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_simple_assign_target(self, node)
            }
        }
    }

    fn visit_mut_span(&mut self, node: &mut swc_common::Span) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_span(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_span(self, node),
        }
    }

    fn visit_mut_spread_element(&mut self, node: &mut SpreadElement) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_spread_element(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_spread_element(self, node),
        }
    }

    fn visit_mut_static_block(&mut self, node: &mut StaticBlock) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_static_block(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_static_block(self, node),
        }
    }

    fn visit_mut_stmt(&mut self, node: &mut Stmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_stmt(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_stmt(self, node),
        }
    }

    fn visit_mut_stmts(&mut self, node: &mut Vec<Stmt>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_stmts(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_stmts(self, node),
        }
    }

    fn visit_mut_str(&mut self, node: &mut Str) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_str(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_str(self, node),
        }
    }

    fn visit_mut_super(&mut self, node: &mut Super) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_super(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_super(self, node),
        }
    }

    fn visit_mut_super_prop(&mut self, node: &mut SuperProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_super_prop(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_super_prop(self, node),
        }
    }

    fn visit_mut_super_prop_expr(&mut self, node: &mut SuperPropExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_super_prop_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_super_prop_expr(self, node),
        }
    }

    fn visit_mut_switch_case(&mut self, node: &mut SwitchCase) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_switch_case(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_switch_case(self, node),
        }
    }

    fn visit_mut_switch_cases(&mut self, node: &mut Vec<SwitchCase>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_switch_cases(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_switch_cases(self, node),
        }
    }

    fn visit_mut_switch_stmt(&mut self, node: &mut SwitchStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_switch_stmt(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_switch_stmt(self, node),
        }
    }

    fn visit_mut_syntax_context(&mut self, node: &mut swc_common::SyntaxContext) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_syntax_context(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_syntax_context(self, node),
        }
    }

    fn visit_mut_tagged_tpl(&mut self, node: &mut TaggedTpl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_tagged_tpl(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_tagged_tpl(self, node),
        }
    }

    fn visit_mut_this_expr(&mut self, node: &mut ThisExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_this_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_this_expr(self, node),
        }
    }

    fn visit_mut_throw_stmt(&mut self, node: &mut ThrowStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_throw_stmt(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_throw_stmt(self, node),
        }
    }

    fn visit_mut_tpl(&mut self, node: &mut Tpl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_tpl(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_tpl(self, node),
        }
    }

    fn visit_mut_tpl_element(&mut self, node: &mut TplElement) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_tpl_element(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_tpl_element(self, node),
        }
    }

    fn visit_mut_tpl_elements(&mut self, node: &mut Vec<TplElement>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_tpl_elements(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_tpl_elements(self, node),
        }
    }

    fn visit_mut_true_plus_minus(&mut self, node: &mut TruePlusMinus) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_true_plus_minus(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_true_plus_minus(self, node),
        }
    }

    fn visit_mut_try_stmt(&mut self, node: &mut TryStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_try_stmt(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_try_stmt(self, node),
        }
    }

    fn visit_mut_ts_array_type(&mut self, node: &mut TsArrayType) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_array_type(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_array_type(self, node),
        }
    }

    fn visit_mut_ts_as_expr(&mut self, node: &mut TsAsExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_as_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_as_expr(self, node),
        }
    }

    fn visit_mut_ts_call_signature_decl(&mut self, node: &mut TsCallSignatureDecl) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_ts_call_signature_decl(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_call_signature_decl(self, node)
            }
        }
    }

    fn visit_mut_ts_conditional_type(&mut self, node: &mut TsConditionalType) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_conditional_type(self, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_conditional_type(self, node)
            }
        }
    }

    fn visit_mut_ts_const_assertion(&mut self, node: &mut TsConstAssertion) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_const_assertion(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_const_assertion(self, node),
        }
    }

    fn visit_mut_ts_construct_signature_decl(&mut self, node: &mut TsConstructSignatureDecl) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_ts_construct_signature_decl(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_construct_signature_decl(self, node)
            }
        }
    }

    fn visit_mut_ts_constructor_type(&mut self, node: &mut TsConstructorType) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_constructor_type(self, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_constructor_type(self, node)
            }
        }
    }

    fn visit_mut_ts_entity_name(&mut self, node: &mut TsEntityName) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_entity_name(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_entity_name(self, node),
        }
    }

    fn visit_mut_ts_enum_decl(&mut self, node: &mut TsEnumDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_enum_decl(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_enum_decl(self, node),
        }
    }

    fn visit_mut_ts_enum_member(&mut self, node: &mut TsEnumMember) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_enum_member(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_enum_member(self, node),
        }
    }

    fn visit_mut_ts_enum_member_id(&mut self, node: &mut TsEnumMemberId) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_enum_member_id(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_enum_member_id(self, node),
        }
    }

    fn visit_mut_ts_enum_members(&mut self, node: &mut Vec<TsEnumMember>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_enum_members(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_enum_members(self, node),
        }
    }

    fn visit_mut_ts_export_assignment(&mut self, node: &mut TsExportAssignment) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_ts_export_assignment(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_export_assignment(self, node)
            }
        }
    }

    fn visit_mut_ts_expr_with_type_args(&mut self, node: &mut TsExprWithTypeArgs) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_ts_expr_with_type_args(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_expr_with_type_args(self, node)
            }
        }
    }

    fn visit_mut_ts_expr_with_type_argss(&mut self, node: &mut Vec<TsExprWithTypeArgs>) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_ts_expr_with_type_argss(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_expr_with_type_argss(self, node)
            }
        }
    }

    fn visit_mut_ts_external_module_ref(&mut self, node: &mut TsExternalModuleRef) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_ts_external_module_ref(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_external_module_ref(self, node)
            }
        }
    }

    fn visit_mut_ts_fn_or_constructor_type(&mut self, node: &mut TsFnOrConstructorType) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_ts_fn_or_constructor_type(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_fn_or_constructor_type(self, node)
            }
        }
    }

    fn visit_mut_ts_fn_param(&mut self, node: &mut TsFnParam) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_fn_param(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_fn_param(self, node),
        }
    }

    fn visit_mut_ts_fn_params(&mut self, node: &mut Vec<TsFnParam>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_fn_params(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_fn_params(self, node),
        }
    }

    fn visit_mut_ts_fn_type(&mut self, node: &mut TsFnType) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_fn_type(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_fn_type(self, node),
        }
    }

    fn visit_mut_ts_getter_signature(&mut self, node: &mut TsGetterSignature) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_getter_signature(self, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_getter_signature(self, node)
            }
        }
    }

    fn visit_mut_ts_import_equals_decl(&mut self, node: &mut TsImportEqualsDecl) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_ts_import_equals_decl(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_import_equals_decl(self, node)
            }
        }
    }

    fn visit_mut_ts_import_type(&mut self, node: &mut TsImportType) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_import_type(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_import_type(self, node),
        }
    }

    fn visit_mut_ts_index_signature(&mut self, node: &mut TsIndexSignature) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_index_signature(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_index_signature(self, node),
        }
    }

    fn visit_mut_ts_indexed_access_type(&mut self, node: &mut TsIndexedAccessType) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_ts_indexed_access_type(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_indexed_access_type(self, node)
            }
        }
    }

    fn visit_mut_ts_infer_type(&mut self, node: &mut TsInferType) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_infer_type(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_infer_type(self, node),
        }
    }

    fn visit_mut_ts_instantiation(&mut self, node: &mut TsInstantiation) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_instantiation(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_instantiation(self, node),
        }
    }

    fn visit_mut_ts_interface_body(&mut self, node: &mut TsInterfaceBody) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_interface_body(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_interface_body(self, node),
        }
    }

    fn visit_mut_ts_interface_decl(&mut self, node: &mut TsInterfaceDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_interface_decl(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_interface_decl(self, node),
        }
    }

    fn visit_mut_ts_intersection_type(&mut self, node: &mut TsIntersectionType) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_ts_intersection_type(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_intersection_type(self, node)
            }
        }
    }

    fn visit_mut_ts_keyword_type(&mut self, node: &mut TsKeywordType) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_keyword_type(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_keyword_type(self, node),
        }
    }

    fn visit_mut_ts_keyword_type_kind(&mut self, node: &mut TsKeywordTypeKind) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_ts_keyword_type_kind(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_keyword_type_kind(self, node)
            }
        }
    }

    fn visit_mut_ts_lit(&mut self, node: &mut TsLit) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_lit(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_lit(self, node),
        }
    }

    fn visit_mut_ts_lit_type(&mut self, node: &mut TsLitType) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_lit_type(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_lit_type(self, node),
        }
    }

    fn visit_mut_ts_mapped_type(&mut self, node: &mut TsMappedType) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_mapped_type(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_mapped_type(self, node),
        }
    }

    fn visit_mut_ts_method_signature(&mut self, node: &mut TsMethodSignature) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_method_signature(self, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_method_signature(self, node)
            }
        }
    }

    fn visit_mut_ts_module_block(&mut self, node: &mut TsModuleBlock) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_module_block(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_module_block(self, node),
        }
    }

    fn visit_mut_ts_module_decl(&mut self, node: &mut TsModuleDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_module_decl(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_module_decl(self, node),
        }
    }

    fn visit_mut_ts_module_name(&mut self, node: &mut TsModuleName) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_module_name(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_module_name(self, node),
        }
    }

    fn visit_mut_ts_module_ref(&mut self, node: &mut TsModuleRef) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_module_ref(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_module_ref(self, node),
        }
    }

    fn visit_mut_ts_namespace_body(&mut self, node: &mut TsNamespaceBody) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_namespace_body(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_namespace_body(self, node),
        }
    }

    fn visit_mut_ts_namespace_decl(&mut self, node: &mut TsNamespaceDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_namespace_decl(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_namespace_decl(self, node),
        }
    }

    fn visit_mut_ts_namespace_export_decl(&mut self, node: &mut TsNamespaceExportDecl) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_ts_namespace_export_decl(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_namespace_export_decl(self, node)
            }
        }
    }

    fn visit_mut_ts_non_null_expr(&mut self, node: &mut TsNonNullExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_non_null_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_non_null_expr(self, node),
        }
    }

    fn visit_mut_ts_optional_type(&mut self, node: &mut TsOptionalType) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_optional_type(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_optional_type(self, node),
        }
    }

    fn visit_mut_ts_param_prop(&mut self, node: &mut TsParamProp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_param_prop(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_param_prop(self, node),
        }
    }

    fn visit_mut_ts_param_prop_param(&mut self, node: &mut TsParamPropParam) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_param_prop_param(self, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_param_prop_param(self, node)
            }
        }
    }

    fn visit_mut_ts_parenthesized_type(&mut self, node: &mut TsParenthesizedType) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_ts_parenthesized_type(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_parenthesized_type(self, node)
            }
        }
    }

    fn visit_mut_ts_property_signature(&mut self, node: &mut TsPropertySignature) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_ts_property_signature(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_property_signature(self, node)
            }
        }
    }

    fn visit_mut_ts_qualified_name(&mut self, node: &mut TsQualifiedName) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_qualified_name(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_qualified_name(self, node),
        }
    }

    fn visit_mut_ts_rest_type(&mut self, node: &mut TsRestType) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_rest_type(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_rest_type(self, node),
        }
    }

    fn visit_mut_ts_satisfies_expr(&mut self, node: &mut TsSatisfiesExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_satisfies_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_satisfies_expr(self, node),
        }
    }

    fn visit_mut_ts_setter_signature(&mut self, node: &mut TsSetterSignature) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_setter_signature(self, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_setter_signature(self, node)
            }
        }
    }

    fn visit_mut_ts_this_type(&mut self, node: &mut TsThisType) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_this_type(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_this_type(self, node),
        }
    }

    fn visit_mut_ts_this_type_or_ident(&mut self, node: &mut TsThisTypeOrIdent) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_ts_this_type_or_ident(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_this_type_or_ident(self, node)
            }
        }
    }

    fn visit_mut_ts_tpl_lit_type(&mut self, node: &mut TsTplLitType) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_tpl_lit_type(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_tpl_lit_type(self, node),
        }
    }

    fn visit_mut_ts_tuple_element(&mut self, node: &mut TsTupleElement) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_tuple_element(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_tuple_element(self, node),
        }
    }

    fn visit_mut_ts_tuple_elements(&mut self, node: &mut Vec<TsTupleElement>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_tuple_elements(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_tuple_elements(self, node),
        }
    }

    fn visit_mut_ts_tuple_type(&mut self, node: &mut TsTupleType) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_tuple_type(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_tuple_type(self, node),
        }
    }

    fn visit_mut_ts_type(&mut self, node: &mut TsType) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_type(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_type(self, node),
        }
    }

    fn visit_mut_ts_type_alias_decl(&mut self, node: &mut TsTypeAliasDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_type_alias_decl(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_type_alias_decl(self, node),
        }
    }

    fn visit_mut_ts_type_ann(&mut self, node: &mut TsTypeAnn) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_type_ann(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_type_ann(self, node),
        }
    }

    fn visit_mut_ts_type_assertion(&mut self, node: &mut TsTypeAssertion) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_type_assertion(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_type_assertion(self, node),
        }
    }

    fn visit_mut_ts_type_element(&mut self, node: &mut TsTypeElement) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_type_element(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_type_element(self, node),
        }
    }

    fn visit_mut_ts_type_elements(&mut self, node: &mut Vec<TsTypeElement>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_type_elements(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_type_elements(self, node),
        }
    }

    fn visit_mut_ts_type_lit(&mut self, node: &mut TsTypeLit) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_type_lit(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_type_lit(self, node),
        }
    }

    fn visit_mut_ts_type_operator(&mut self, node: &mut TsTypeOperator) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_type_operator(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_type_operator(self, node),
        }
    }

    fn visit_mut_ts_type_operator_op(&mut self, node: &mut TsTypeOperatorOp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_type_operator_op(self, node),
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_type_operator_op(self, node)
            }
        }
    }

    fn visit_mut_ts_type_param(&mut self, node: &mut TsTypeParam) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_type_param(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_type_param(self, node),
        }
    }

    fn visit_mut_ts_type_param_decl(&mut self, node: &mut TsTypeParamDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_type_param_decl(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_type_param_decl(self, node),
        }
    }

    fn visit_mut_ts_type_param_instantiation(&mut self, node: &mut TsTypeParamInstantiation) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_ts_type_param_instantiation(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_type_param_instantiation(self, node)
            }
        }
    }

    fn visit_mut_ts_type_params(&mut self, node: &mut Vec<TsTypeParam>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_type_params(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_type_params(self, node),
        }
    }

    fn visit_mut_ts_type_predicate(&mut self, node: &mut TsTypePredicate) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_type_predicate(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_type_predicate(self, node),
        }
    }

    fn visit_mut_ts_type_query(&mut self, node: &mut TsTypeQuery) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_type_query(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_type_query(self, node),
        }
    }

    fn visit_mut_ts_type_query_expr(&mut self, node: &mut TsTypeQueryExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_type_query_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_type_query_expr(self, node),
        }
    }

    fn visit_mut_ts_type_ref(&mut self, node: &mut TsTypeRef) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_type_ref(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_type_ref(self, node),
        }
    }

    fn visit_mut_ts_types(&mut self, node: &mut Vec<Box<TsType>>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_types(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_types(self, node),
        }
    }

    fn visit_mut_ts_union_or_intersection_type(&mut self, node: &mut TsUnionOrIntersectionType) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMut::visit_mut_ts_union_or_intersection_type(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMut::visit_mut_ts_union_or_intersection_type(self, node)
            }
        }
    }

    fn visit_mut_ts_union_type(&mut self, node: &mut TsUnionType) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_ts_union_type(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_ts_union_type(self, node),
        }
    }

    fn visit_mut_unary_expr(&mut self, node: &mut UnaryExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_unary_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_unary_expr(self, node),
        }
    }

    fn visit_mut_unary_op(&mut self, node: &mut UnaryOp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_unary_op(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_unary_op(self, node),
        }
    }

    fn visit_mut_update_expr(&mut self, node: &mut UpdateExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_update_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_update_expr(self, node),
        }
    }

    fn visit_mut_update_op(&mut self, node: &mut UpdateOp) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_update_op(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_update_op(self, node),
        }
    }

    fn visit_mut_using_decl(&mut self, node: &mut UsingDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_using_decl(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_using_decl(self, node),
        }
    }

    fn visit_mut_var_decl(&mut self, node: &mut VarDecl) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_var_decl(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_var_decl(self, node),
        }
    }

    fn visit_mut_var_decl_kind(&mut self, node: &mut VarDeclKind) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_var_decl_kind(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_var_decl_kind(self, node),
        }
    }

    fn visit_mut_var_decl_or_expr(&mut self, node: &mut VarDeclOrExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_var_decl_or_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_var_decl_or_expr(self, node),
        }
    }

    fn visit_mut_var_declarator(&mut self, node: &mut VarDeclarator) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_var_declarator(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_var_declarator(self, node),
        }
    }

    fn visit_mut_var_declarators(&mut self, node: &mut Vec<VarDeclarator>) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_var_declarators(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_var_declarators(self, node),
        }
    }

    fn visit_mut_while_stmt(&mut self, node: &mut WhileStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_while_stmt(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_while_stmt(self, node),
        }
    }

    fn visit_mut_with_stmt(&mut self, node: &mut WithStmt) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_with_stmt(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_with_stmt(self, node),
        }
    }

    fn visit_mut_yield_expr(&mut self, node: &mut YieldExpr) {
        match self {
            swc_visit::Either::Left(visitor) => VisitMut::visit_mut_yield_expr(self, node),
            swc_visit::Either::Right(visitor) => VisitMut::visit_mut_yield_expr(self, node),
        }
    }
}
impl<V> VisitMut for ::swc_visit::Optional<V>
where
    V: VisitMut,
{
    fn visit_mut_accessibility(&mut self, node: &mut Accessibility) {
        if self.enabled {
            VisitMut::visit_mut_accessibility(self, node)
        } else {
        }
    }

    fn visit_mut_array_lit(&mut self, node: &mut ArrayLit) {
        if self.enabled {
            VisitMut::visit_mut_array_lit(self, node)
        } else {
        }
    }

    fn visit_mut_array_pat(&mut self, node: &mut ArrayPat) {
        if self.enabled {
            VisitMut::visit_mut_array_pat(self, node)
        } else {
        }
    }

    fn visit_mut_arrow_expr(&mut self, node: &mut ArrowExpr) {
        if self.enabled {
            VisitMut::visit_mut_arrow_expr(self, node)
        } else {
        }
    }

    fn visit_mut_assign_expr(&mut self, node: &mut AssignExpr) {
        if self.enabled {
            VisitMut::visit_mut_assign_expr(self, node)
        } else {
        }
    }

    fn visit_mut_assign_op(&mut self, node: &mut AssignOp) {
        if self.enabled {
            VisitMut::visit_mut_assign_op(self, node)
        } else {
        }
    }

    fn visit_mut_assign_pat(&mut self, node: &mut AssignPat) {
        if self.enabled {
            VisitMut::visit_mut_assign_pat(self, node)
        } else {
        }
    }

    fn visit_mut_assign_pat_prop(&mut self, node: &mut AssignPatProp) {
        if self.enabled {
            VisitMut::visit_mut_assign_pat_prop(self, node)
        } else {
        }
    }

    fn visit_mut_assign_prop(&mut self, node: &mut AssignProp) {
        if self.enabled {
            VisitMut::visit_mut_assign_prop(self, node)
        } else {
        }
    }

    fn visit_mut_assign_target(&mut self, node: &mut AssignTarget) {
        if self.enabled {
            VisitMut::visit_mut_assign_target(self, node)
        } else {
        }
    }

    fn visit_mut_assign_target_pat(&mut self, node: &mut AssignTargetPat) {
        if self.enabled {
            VisitMut::visit_mut_assign_target_pat(self, node)
        } else {
        }
    }

    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom) {
        if self.enabled {
            VisitMut::visit_mut_atom(self, node)
        } else {
        }
    }

    fn visit_mut_auto_accessor(&mut self, node: &mut AutoAccessor) {
        if self.enabled {
            VisitMut::visit_mut_auto_accessor(self, node)
        } else {
        }
    }

    fn visit_mut_await_expr(&mut self, node: &mut AwaitExpr) {
        if self.enabled {
            VisitMut::visit_mut_await_expr(self, node)
        } else {
        }
    }

    fn visit_mut_big_int(&mut self, node: &mut BigInt) {
        if self.enabled {
            VisitMut::visit_mut_big_int(self, node)
        } else {
        }
    }

    fn visit_mut_big_int_value(&mut self, node: &mut BigIntValue) {
        if self.enabled {
            VisitMut::visit_mut_big_int_value(self, node)
        } else {
        }
    }

    fn visit_mut_bin_expr(&mut self, node: &mut BinExpr) {
        if self.enabled {
            VisitMut::visit_mut_bin_expr(self, node)
        } else {
        }
    }

    fn visit_mut_binary_op(&mut self, node: &mut BinaryOp) {
        if self.enabled {
            VisitMut::visit_mut_binary_op(self, node)
        } else {
        }
    }

    fn visit_mut_binding_ident(&mut self, node: &mut BindingIdent) {
        if self.enabled {
            VisitMut::visit_mut_binding_ident(self, node)
        } else {
        }
    }

    fn visit_mut_block_stmt(&mut self, node: &mut BlockStmt) {
        if self.enabled {
            VisitMut::visit_mut_block_stmt(self, node)
        } else {
        }
    }

    fn visit_mut_block_stmt_or_expr(&mut self, node: &mut BlockStmtOrExpr) {
        if self.enabled {
            VisitMut::visit_mut_block_stmt_or_expr(self, node)
        } else {
        }
    }

    fn visit_mut_bool(&mut self, node: &mut Bool) {
        if self.enabled {
            VisitMut::visit_mut_bool(self, node)
        } else {
        }
    }

    fn visit_mut_break_stmt(&mut self, node: &mut BreakStmt) {
        if self.enabled {
            VisitMut::visit_mut_break_stmt(self, node)
        } else {
        }
    }

    fn visit_mut_call_expr(&mut self, node: &mut CallExpr) {
        if self.enabled {
            VisitMut::visit_mut_call_expr(self, node)
        } else {
        }
    }

    fn visit_mut_callee(&mut self, node: &mut Callee) {
        if self.enabled {
            VisitMut::visit_mut_callee(self, node)
        } else {
        }
    }

    fn visit_mut_catch_clause(&mut self, node: &mut CatchClause) {
        if self.enabled {
            VisitMut::visit_mut_catch_clause(self, node)
        } else {
        }
    }

    fn visit_mut_class(&mut self, node: &mut Class) {
        if self.enabled {
            VisitMut::visit_mut_class(self, node)
        } else {
        }
    }

    fn visit_mut_class_decl(&mut self, node: &mut ClassDecl) {
        if self.enabled {
            VisitMut::visit_mut_class_decl(self, node)
        } else {
        }
    }

    fn visit_mut_class_expr(&mut self, node: &mut ClassExpr) {
        if self.enabled {
            VisitMut::visit_mut_class_expr(self, node)
        } else {
        }
    }

    fn visit_mut_class_member(&mut self, node: &mut ClassMember) {
        if self.enabled {
            VisitMut::visit_mut_class_member(self, node)
        } else {
        }
    }

    fn visit_mut_class_members(&mut self, node: &mut Vec<ClassMember>) {
        if self.enabled {
            VisitMut::visit_mut_class_members(self, node)
        } else {
        }
    }

    fn visit_mut_class_method(&mut self, node: &mut ClassMethod) {
        if self.enabled {
            VisitMut::visit_mut_class_method(self, node)
        } else {
        }
    }

    fn visit_mut_class_prop(&mut self, node: &mut ClassProp) {
        if self.enabled {
            VisitMut::visit_mut_class_prop(self, node)
        } else {
        }
    }

    fn visit_mut_computed_prop_name(&mut self, node: &mut ComputedPropName) {
        if self.enabled {
            VisitMut::visit_mut_computed_prop_name(self, node)
        } else {
        }
    }

    fn visit_mut_cond_expr(&mut self, node: &mut CondExpr) {
        if self.enabled {
            VisitMut::visit_mut_cond_expr(self, node)
        } else {
        }
    }

    fn visit_mut_constructor(&mut self, node: &mut Constructor) {
        if self.enabled {
            VisitMut::visit_mut_constructor(self, node)
        } else {
        }
    }

    fn visit_mut_continue_stmt(&mut self, node: &mut ContinueStmt) {
        if self.enabled {
            VisitMut::visit_mut_continue_stmt(self, node)
        } else {
        }
    }

    fn visit_mut_debugger_stmt(&mut self, node: &mut DebuggerStmt) {
        if self.enabled {
            VisitMut::visit_mut_debugger_stmt(self, node)
        } else {
        }
    }

    fn visit_mut_decl(&mut self, node: &mut Decl) {
        if self.enabled {
            VisitMut::visit_mut_decl(self, node)
        } else {
        }
    }

    fn visit_mut_decorator(&mut self, node: &mut Decorator) {
        if self.enabled {
            VisitMut::visit_mut_decorator(self, node)
        } else {
        }
    }

    fn visit_mut_decorators(&mut self, node: &mut Vec<Decorator>) {
        if self.enabled {
            VisitMut::visit_mut_decorators(self, node)
        } else {
        }
    }

    fn visit_mut_default_decl(&mut self, node: &mut DefaultDecl) {
        if self.enabled {
            VisitMut::visit_mut_default_decl(self, node)
        } else {
        }
    }

    fn visit_mut_do_while_stmt(&mut self, node: &mut DoWhileStmt) {
        if self.enabled {
            VisitMut::visit_mut_do_while_stmt(self, node)
        } else {
        }
    }

    fn visit_mut_empty_stmt(&mut self, node: &mut EmptyStmt) {
        if self.enabled {
            VisitMut::visit_mut_empty_stmt(self, node)
        } else {
        }
    }

    fn visit_mut_es_version(&mut self, node: &mut EsVersion) {
        if self.enabled {
            VisitMut::visit_mut_es_version(self, node)
        } else {
        }
    }

    fn visit_mut_export_all(&mut self, node: &mut ExportAll) {
        if self.enabled {
            VisitMut::visit_mut_export_all(self, node)
        } else {
        }
    }

    fn visit_mut_export_decl(&mut self, node: &mut ExportDecl) {
        if self.enabled {
            VisitMut::visit_mut_export_decl(self, node)
        } else {
        }
    }

    fn visit_mut_export_default_decl(&mut self, node: &mut ExportDefaultDecl) {
        if self.enabled {
            VisitMut::visit_mut_export_default_decl(self, node)
        } else {
        }
    }

    fn visit_mut_export_default_expr(&mut self, node: &mut ExportDefaultExpr) {
        if self.enabled {
            VisitMut::visit_mut_export_default_expr(self, node)
        } else {
        }
    }

    fn visit_mut_export_default_specifier(&mut self, node: &mut ExportDefaultSpecifier) {
        if self.enabled {
            VisitMut::visit_mut_export_default_specifier(self, node)
        } else {
        }
    }

    fn visit_mut_export_named_specifier(&mut self, node: &mut ExportNamedSpecifier) {
        if self.enabled {
            VisitMut::visit_mut_export_named_specifier(self, node)
        } else {
        }
    }

    fn visit_mut_export_namespace_specifier(&mut self, node: &mut ExportNamespaceSpecifier) {
        if self.enabled {
            VisitMut::visit_mut_export_namespace_specifier(self, node)
        } else {
        }
    }

    fn visit_mut_export_specifier(&mut self, node: &mut ExportSpecifier) {
        if self.enabled {
            VisitMut::visit_mut_export_specifier(self, node)
        } else {
        }
    }

    fn visit_mut_export_specifiers(&mut self, node: &mut Vec<ExportSpecifier>) {
        if self.enabled {
            VisitMut::visit_mut_export_specifiers(self, node)
        } else {
        }
    }

    fn visit_mut_expr(&mut self, node: &mut Expr) {
        if self.enabled {
            VisitMut::visit_mut_expr(self, node)
        } else {
        }
    }

    fn visit_mut_expr_or_spread(&mut self, node: &mut ExprOrSpread) {
        if self.enabled {
            VisitMut::visit_mut_expr_or_spread(self, node)
        } else {
        }
    }

    fn visit_mut_expr_or_spreads(&mut self, node: &mut Vec<ExprOrSpread>) {
        if self.enabled {
            VisitMut::visit_mut_expr_or_spreads(self, node)
        } else {
        }
    }

    fn visit_mut_expr_stmt(&mut self, node: &mut ExprStmt) {
        if self.enabled {
            VisitMut::visit_mut_expr_stmt(self, node)
        } else {
        }
    }

    fn visit_mut_exprs(&mut self, node: &mut Vec<Box<Expr>>) {
        if self.enabled {
            VisitMut::visit_mut_exprs(self, node)
        } else {
        }
    }

    fn visit_mut_fn_decl(&mut self, node: &mut FnDecl) {
        if self.enabled {
            VisitMut::visit_mut_fn_decl(self, node)
        } else {
        }
    }

    fn visit_mut_fn_expr(&mut self, node: &mut FnExpr) {
        if self.enabled {
            VisitMut::visit_mut_fn_expr(self, node)
        } else {
        }
    }

    fn visit_mut_for_head(&mut self, node: &mut ForHead) {
        if self.enabled {
            VisitMut::visit_mut_for_head(self, node)
        } else {
        }
    }

    fn visit_mut_for_in_stmt(&mut self, node: &mut ForInStmt) {
        if self.enabled {
            VisitMut::visit_mut_for_in_stmt(self, node)
        } else {
        }
    }

    fn visit_mut_for_of_stmt(&mut self, node: &mut ForOfStmt) {
        if self.enabled {
            VisitMut::visit_mut_for_of_stmt(self, node)
        } else {
        }
    }

    fn visit_mut_for_stmt(&mut self, node: &mut ForStmt) {
        if self.enabled {
            VisitMut::visit_mut_for_stmt(self, node)
        } else {
        }
    }

    fn visit_mut_function(&mut self, node: &mut Function) {
        if self.enabled {
            VisitMut::visit_mut_function(self, node)
        } else {
        }
    }

    fn visit_mut_getter_prop(&mut self, node: &mut GetterProp) {
        if self.enabled {
            VisitMut::visit_mut_getter_prop(self, node)
        } else {
        }
    }

    fn visit_mut_ident(&mut self, node: &mut Ident) {
        if self.enabled {
            VisitMut::visit_mut_ident(self, node)
        } else {
        }
    }

    fn visit_mut_ident_name(&mut self, node: &mut IdentName) {
        if self.enabled {
            VisitMut::visit_mut_ident_name(self, node)
        } else {
        }
    }

    fn visit_mut_if_stmt(&mut self, node: &mut IfStmt) {
        if self.enabled {
            VisitMut::visit_mut_if_stmt(self, node)
        } else {
        }
    }

    fn visit_mut_import(&mut self, node: &mut Import) {
        if self.enabled {
            VisitMut::visit_mut_import(self, node)
        } else {
        }
    }

    fn visit_mut_import_decl(&mut self, node: &mut ImportDecl) {
        if self.enabled {
            VisitMut::visit_mut_import_decl(self, node)
        } else {
        }
    }

    fn visit_mut_import_default_specifier(&mut self, node: &mut ImportDefaultSpecifier) {
        if self.enabled {
            VisitMut::visit_mut_import_default_specifier(self, node)
        } else {
        }
    }

    fn visit_mut_import_named_specifier(&mut self, node: &mut ImportNamedSpecifier) {
        if self.enabled {
            VisitMut::visit_mut_import_named_specifier(self, node)
        } else {
        }
    }

    fn visit_mut_import_phase(&mut self, node: &mut ImportPhase) {
        if self.enabled {
            VisitMut::visit_mut_import_phase(self, node)
        } else {
        }
    }

    fn visit_mut_import_specifier(&mut self, node: &mut ImportSpecifier) {
        if self.enabled {
            VisitMut::visit_mut_import_specifier(self, node)
        } else {
        }
    }

    fn visit_mut_import_specifiers(&mut self, node: &mut Vec<ImportSpecifier>) {
        if self.enabled {
            VisitMut::visit_mut_import_specifiers(self, node)
        } else {
        }
    }

    fn visit_mut_import_star_as_specifier(&mut self, node: &mut ImportStarAsSpecifier) {
        if self.enabled {
            VisitMut::visit_mut_import_star_as_specifier(self, node)
        } else {
        }
    }

    fn visit_mut_import_with(&mut self, node: &mut ImportWith) {
        if self.enabled {
            VisitMut::visit_mut_import_with(self, node)
        } else {
        }
    }

    fn visit_mut_import_with_item(&mut self, node: &mut ImportWithItem) {
        if self.enabled {
            VisitMut::visit_mut_import_with_item(self, node)
        } else {
        }
    }

    fn visit_mut_import_with_items(&mut self, node: &mut Vec<ImportWithItem>) {
        if self.enabled {
            VisitMut::visit_mut_import_with_items(self, node)
        } else {
        }
    }

    fn visit_mut_invalid(&mut self, node: &mut Invalid) {
        if self.enabled {
            VisitMut::visit_mut_invalid(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_attr(&mut self, node: &mut JSXAttr) {
        if self.enabled {
            VisitMut::visit_mut_jsx_attr(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_attr_name(&mut self, node: &mut JSXAttrName) {
        if self.enabled {
            VisitMut::visit_mut_jsx_attr_name(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_attr_or_spread(&mut self, node: &mut JSXAttrOrSpread) {
        if self.enabled {
            VisitMut::visit_mut_jsx_attr_or_spread(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_attr_or_spreads(&mut self, node: &mut Vec<JSXAttrOrSpread>) {
        if self.enabled {
            VisitMut::visit_mut_jsx_attr_or_spreads(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_attr_value(&mut self, node: &mut JSXAttrValue) {
        if self.enabled {
            VisitMut::visit_mut_jsx_attr_value(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_closing_element(&mut self, node: &mut JSXClosingElement) {
        if self.enabled {
            VisitMut::visit_mut_jsx_closing_element(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_closing_fragment(&mut self, node: &mut JSXClosingFragment) {
        if self.enabled {
            VisitMut::visit_mut_jsx_closing_fragment(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_element(&mut self, node: &mut JSXElement) {
        if self.enabled {
            VisitMut::visit_mut_jsx_element(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_element_child(&mut self, node: &mut JSXElementChild) {
        if self.enabled {
            VisitMut::visit_mut_jsx_element_child(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_element_childs(&mut self, node: &mut Vec<JSXElementChild>) {
        if self.enabled {
            VisitMut::visit_mut_jsx_element_childs(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_element_name(&mut self, node: &mut JSXElementName) {
        if self.enabled {
            VisitMut::visit_mut_jsx_element_name(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_empty_expr(&mut self, node: &mut JSXEmptyExpr) {
        if self.enabled {
            VisitMut::visit_mut_jsx_empty_expr(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_expr(&mut self, node: &mut JSXExpr) {
        if self.enabled {
            VisitMut::visit_mut_jsx_expr(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_expr_container(&mut self, node: &mut JSXExprContainer) {
        if self.enabled {
            VisitMut::visit_mut_jsx_expr_container(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_fragment(&mut self, node: &mut JSXFragment) {
        if self.enabled {
            VisitMut::visit_mut_jsx_fragment(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_member_expr(&mut self, node: &mut JSXMemberExpr) {
        if self.enabled {
            VisitMut::visit_mut_jsx_member_expr(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_namespaced_name(&mut self, node: &mut JSXNamespacedName) {
        if self.enabled {
            VisitMut::visit_mut_jsx_namespaced_name(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_object(&mut self, node: &mut JSXObject) {
        if self.enabled {
            VisitMut::visit_mut_jsx_object(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_opening_element(&mut self, node: &mut JSXOpeningElement) {
        if self.enabled {
            VisitMut::visit_mut_jsx_opening_element(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_opening_fragment(&mut self, node: &mut JSXOpeningFragment) {
        if self.enabled {
            VisitMut::visit_mut_jsx_opening_fragment(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_spread_child(&mut self, node: &mut JSXSpreadChild) {
        if self.enabled {
            VisitMut::visit_mut_jsx_spread_child(self, node)
        } else {
        }
    }

    fn visit_mut_jsx_text(&mut self, node: &mut JSXText) {
        if self.enabled {
            VisitMut::visit_mut_jsx_text(self, node)
        } else {
        }
    }

    fn visit_mut_key(&mut self, node: &mut Key) {
        if self.enabled {
            VisitMut::visit_mut_key(self, node)
        } else {
        }
    }

    fn visit_mut_key_value_pat_prop(&mut self, node: &mut KeyValuePatProp) {
        if self.enabled {
            VisitMut::visit_mut_key_value_pat_prop(self, node)
        } else {
        }
    }

    fn visit_mut_key_value_prop(&mut self, node: &mut KeyValueProp) {
        if self.enabled {
            VisitMut::visit_mut_key_value_prop(self, node)
        } else {
        }
    }

    fn visit_mut_labeled_stmt(&mut self, node: &mut LabeledStmt) {
        if self.enabled {
            VisitMut::visit_mut_labeled_stmt(self, node)
        } else {
        }
    }

    fn visit_mut_lit(&mut self, node: &mut Lit) {
        if self.enabled {
            VisitMut::visit_mut_lit(self, node)
        } else {
        }
    }

    fn visit_mut_member_expr(&mut self, node: &mut MemberExpr) {
        if self.enabled {
            VisitMut::visit_mut_member_expr(self, node)
        } else {
        }
    }

    fn visit_mut_member_prop(&mut self, node: &mut MemberProp) {
        if self.enabled {
            VisitMut::visit_mut_member_prop(self, node)
        } else {
        }
    }

    fn visit_mut_meta_prop_expr(&mut self, node: &mut MetaPropExpr) {
        if self.enabled {
            VisitMut::visit_mut_meta_prop_expr(self, node)
        } else {
        }
    }

    fn visit_mut_meta_prop_kind(&mut self, node: &mut MetaPropKind) {
        if self.enabled {
            VisitMut::visit_mut_meta_prop_kind(self, node)
        } else {
        }
    }

    fn visit_mut_method_kind(&mut self, node: &mut MethodKind) {
        if self.enabled {
            VisitMut::visit_mut_method_kind(self, node)
        } else {
        }
    }

    fn visit_mut_method_prop(&mut self, node: &mut MethodProp) {
        if self.enabled {
            VisitMut::visit_mut_method_prop(self, node)
        } else {
        }
    }

    fn visit_mut_module(&mut self, node: &mut Module) {
        if self.enabled {
            VisitMut::visit_mut_module(self, node)
        } else {
        }
    }

    fn visit_mut_module_decl(&mut self, node: &mut ModuleDecl) {
        if self.enabled {
            VisitMut::visit_mut_module_decl(self, node)
        } else {
        }
    }

    fn visit_mut_module_export_name(&mut self, node: &mut ModuleExportName) {
        if self.enabled {
            VisitMut::visit_mut_module_export_name(self, node)
        } else {
        }
    }

    fn visit_mut_module_item(&mut self, node: &mut ModuleItem) {
        if self.enabled {
            VisitMut::visit_mut_module_item(self, node)
        } else {
        }
    }

    fn visit_mut_module_items(&mut self, node: &mut Vec<ModuleItem>) {
        if self.enabled {
            VisitMut::visit_mut_module_items(self, node)
        } else {
        }
    }

    fn visit_mut_named_export(&mut self, node: &mut NamedExport) {
        if self.enabled {
            VisitMut::visit_mut_named_export(self, node)
        } else {
        }
    }

    fn visit_mut_new_expr(&mut self, node: &mut NewExpr) {
        if self.enabled {
            VisitMut::visit_mut_new_expr(self, node)
        } else {
        }
    }

    fn visit_mut_null(&mut self, node: &mut Null) {
        if self.enabled {
            VisitMut::visit_mut_null(self, node)
        } else {
        }
    }

    fn visit_mut_number(&mut self, node: &mut Number) {
        if self.enabled {
            VisitMut::visit_mut_number(self, node)
        } else {
        }
    }

    fn visit_mut_object_lit(&mut self, node: &mut ObjectLit) {
        if self.enabled {
            VisitMut::visit_mut_object_lit(self, node)
        } else {
        }
    }

    fn visit_mut_object_pat(&mut self, node: &mut ObjectPat) {
        if self.enabled {
            VisitMut::visit_mut_object_pat(self, node)
        } else {
        }
    }

    fn visit_mut_object_pat_prop(&mut self, node: &mut ObjectPatProp) {
        if self.enabled {
            VisitMut::visit_mut_object_pat_prop(self, node)
        } else {
        }
    }

    fn visit_mut_object_pat_props(&mut self, node: &mut Vec<ObjectPatProp>) {
        if self.enabled {
            VisitMut::visit_mut_object_pat_props(self, node)
        } else {
        }
    }

    fn visit_mut_opt_accessibility(&mut self, node: &mut Option<Accessibility>) {
        if self.enabled {
            VisitMut::visit_mut_opt_accessibility(self, node)
        } else {
        }
    }

    fn visit_mut_opt_atom(&mut self, node: &mut Option<swc_atoms::Atom>) {
        if self.enabled {
            VisitMut::visit_mut_opt_atom(self, node)
        } else {
        }
    }

    fn visit_mut_opt_block_stmt(&mut self, node: &mut Option<BlockStmt>) {
        if self.enabled {
            VisitMut::visit_mut_opt_block_stmt(self, node)
        } else {
        }
    }

    fn visit_mut_opt_call(&mut self, node: &mut OptCall) {
        if self.enabled {
            VisitMut::visit_mut_opt_call(self, node)
        } else {
        }
    }

    fn visit_mut_opt_catch_clause(&mut self, node: &mut Option<CatchClause>) {
        if self.enabled {
            VisitMut::visit_mut_opt_catch_clause(self, node)
        } else {
        }
    }

    fn visit_mut_opt_chain_base(&mut self, node: &mut OptChainBase) {
        if self.enabled {
            VisitMut::visit_mut_opt_chain_base(self, node)
        } else {
        }
    }

    fn visit_mut_opt_chain_expr(&mut self, node: &mut OptChainExpr) {
        if self.enabled {
            VisitMut::visit_mut_opt_chain_expr(self, node)
        } else {
        }
    }

    fn visit_mut_opt_expr(&mut self, node: &mut Option<Box<Expr>>) {
        if self.enabled {
            VisitMut::visit_mut_opt_expr(self, node)
        } else {
        }
    }

    fn visit_mut_opt_expr_or_spread(&mut self, node: &mut Option<ExprOrSpread>) {
        if self.enabled {
            VisitMut::visit_mut_opt_expr_or_spread(self, node)
        } else {
        }
    }

    fn visit_mut_opt_expr_or_spreads(&mut self, node: &mut Option<Vec<ExprOrSpread>>) {
        if self.enabled {
            VisitMut::visit_mut_opt_expr_or_spreads(self, node)
        } else {
        }
    }

    fn visit_mut_opt_ident(&mut self, node: &mut Option<Ident>) {
        if self.enabled {
            VisitMut::visit_mut_opt_ident(self, node)
        } else {
        }
    }

    fn visit_mut_opt_jsx_attr_value(&mut self, node: &mut Option<JSXAttrValue>) {
        if self.enabled {
            VisitMut::visit_mut_opt_jsx_attr_value(self, node)
        } else {
        }
    }

    fn visit_mut_opt_jsx_closing_element(&mut self, node: &mut Option<JSXClosingElement>) {
        if self.enabled {
            VisitMut::visit_mut_opt_jsx_closing_element(self, node)
        } else {
        }
    }

    fn visit_mut_opt_module_export_name(&mut self, node: &mut Option<ModuleExportName>) {
        if self.enabled {
            VisitMut::visit_mut_opt_module_export_name(self, node)
        } else {
        }
    }

    fn visit_mut_opt_module_items(&mut self, node: &mut Option<Vec<ModuleItem>>) {
        if self.enabled {
            VisitMut::visit_mut_opt_module_items(self, node)
        } else {
        }
    }

    fn visit_mut_opt_object_lit(&mut self, node: &mut Option<Box<ObjectLit>>) {
        if self.enabled {
            VisitMut::visit_mut_opt_object_lit(self, node)
        } else {
        }
    }

    fn visit_mut_opt_pat(&mut self, node: &mut Option<Pat>) {
        if self.enabled {
            VisitMut::visit_mut_opt_pat(self, node)
        } else {
        }
    }

    fn visit_mut_opt_span(&mut self, node: &mut Option<swc_common::Span>) {
        if self.enabled {
            VisitMut::visit_mut_opt_span(self, node)
        } else {
        }
    }

    fn visit_mut_opt_stmt(&mut self, node: &mut Option<Box<Stmt>>) {
        if self.enabled {
            VisitMut::visit_mut_opt_stmt(self, node)
        } else {
        }
    }

    fn visit_mut_opt_str(&mut self, node: &mut Option<Box<Str>>) {
        if self.enabled {
            VisitMut::visit_mut_opt_str(self, node)
        } else {
        }
    }

    fn visit_mut_opt_true_plus_minus(&mut self, node: &mut Option<TruePlusMinus>) {
        if self.enabled {
            VisitMut::visit_mut_opt_true_plus_minus(self, node)
        } else {
        }
    }

    fn visit_mut_opt_ts_entity_name(&mut self, node: &mut Option<TsEntityName>) {
        if self.enabled {
            VisitMut::visit_mut_opt_ts_entity_name(self, node)
        } else {
        }
    }

    fn visit_mut_opt_ts_namespace_body(&mut self, node: &mut Option<TsNamespaceBody>) {
        if self.enabled {
            VisitMut::visit_mut_opt_ts_namespace_body(self, node)
        } else {
        }
    }

    fn visit_mut_opt_ts_type(&mut self, node: &mut Option<Box<TsType>>) {
        if self.enabled {
            VisitMut::visit_mut_opt_ts_type(self, node)
        } else {
        }
    }

    fn visit_mut_opt_ts_type_ann(&mut self, node: &mut Option<Box<TsTypeAnn>>) {
        if self.enabled {
            VisitMut::visit_mut_opt_ts_type_ann(self, node)
        } else {
        }
    }

    fn visit_mut_opt_ts_type_param_decl(&mut self, node: &mut Option<Box<TsTypeParamDecl>>) {
        if self.enabled {
            VisitMut::visit_mut_opt_ts_type_param_decl(self, node)
        } else {
        }
    }

    fn visit_mut_opt_ts_type_param_instantiation(
        &mut self,
        node: &mut Option<Box<TsTypeParamInstantiation>>,
    ) {
        if self.enabled {
            VisitMut::visit_mut_opt_ts_type_param_instantiation(self, node)
        } else {
        }
    }

    fn visit_mut_opt_var_decl_or_expr(&mut self, node: &mut Option<VarDeclOrExpr>) {
        if self.enabled {
            VisitMut::visit_mut_opt_var_decl_or_expr(self, node)
        } else {
        }
    }

    fn visit_mut_opt_vec_expr_or_spreads(&mut self, node: &mut Vec<Option<ExprOrSpread>>) {
        if self.enabled {
            VisitMut::visit_mut_opt_vec_expr_or_spreads(self, node)
        } else {
        }
    }

    fn visit_mut_opt_vec_pats(&mut self, node: &mut Vec<Option<Pat>>) {
        if self.enabled {
            VisitMut::visit_mut_opt_vec_pats(self, node)
        } else {
        }
    }

    fn visit_mut_param(&mut self, node: &mut Param) {
        if self.enabled {
            VisitMut::visit_mut_param(self, node)
        } else {
        }
    }

    fn visit_mut_param_or_ts_param_prop(&mut self, node: &mut ParamOrTsParamProp) {
        if self.enabled {
            VisitMut::visit_mut_param_or_ts_param_prop(self, node)
        } else {
        }
    }

    fn visit_mut_param_or_ts_param_props(&mut self, node: &mut Vec<ParamOrTsParamProp>) {
        if self.enabled {
            VisitMut::visit_mut_param_or_ts_param_props(self, node)
        } else {
        }
    }

    fn visit_mut_params(&mut self, node: &mut Vec<Param>) {
        if self.enabled {
            VisitMut::visit_mut_params(self, node)
        } else {
        }
    }

    fn visit_mut_paren_expr(&mut self, node: &mut ParenExpr) {
        if self.enabled {
            VisitMut::visit_mut_paren_expr(self, node)
        } else {
        }
    }

    fn visit_mut_pat(&mut self, node: &mut Pat) {
        if self.enabled {
            VisitMut::visit_mut_pat(self, node)
        } else {
        }
    }

    fn visit_mut_pats(&mut self, node: &mut Vec<Pat>) {
        if self.enabled {
            VisitMut::visit_mut_pats(self, node)
        } else {
        }
    }

    fn visit_mut_private_method(&mut self, node: &mut PrivateMethod) {
        if self.enabled {
            VisitMut::visit_mut_private_method(self, node)
        } else {
        }
    }

    fn visit_mut_private_name(&mut self, node: &mut PrivateName) {
        if self.enabled {
            VisitMut::visit_mut_private_name(self, node)
        } else {
        }
    }

    fn visit_mut_private_prop(&mut self, node: &mut PrivateProp) {
        if self.enabled {
            VisitMut::visit_mut_private_prop(self, node)
        } else {
        }
    }

    fn visit_mut_program(&mut self, node: &mut Program) {
        if self.enabled {
            VisitMut::visit_mut_program(self, node)
        } else {
        }
    }

    fn visit_mut_prop(&mut self, node: &mut Prop) {
        if self.enabled {
            VisitMut::visit_mut_prop(self, node)
        } else {
        }
    }

    fn visit_mut_prop_name(&mut self, node: &mut PropName) {
        if self.enabled {
            VisitMut::visit_mut_prop_name(self, node)
        } else {
        }
    }

    fn visit_mut_prop_or_spread(&mut self, node: &mut PropOrSpread) {
        if self.enabled {
            VisitMut::visit_mut_prop_or_spread(self, node)
        } else {
        }
    }

    fn visit_mut_prop_or_spreads(&mut self, node: &mut Vec<PropOrSpread>) {
        if self.enabled {
            VisitMut::visit_mut_prop_or_spreads(self, node)
        } else {
        }
    }

    fn visit_mut_regex(&mut self, node: &mut Regex) {
        if self.enabled {
            VisitMut::visit_mut_regex(self, node)
        } else {
        }
    }

    fn visit_mut_reserved_unused(&mut self, node: &mut ReservedUnused) {
        if self.enabled {
            VisitMut::visit_mut_reserved_unused(self, node)
        } else {
        }
    }

    fn visit_mut_rest_pat(&mut self, node: &mut RestPat) {
        if self.enabled {
            VisitMut::visit_mut_rest_pat(self, node)
        } else {
        }
    }

    fn visit_mut_return_stmt(&mut self, node: &mut ReturnStmt) {
        if self.enabled {
            VisitMut::visit_mut_return_stmt(self, node)
        } else {
        }
    }

    fn visit_mut_script(&mut self, node: &mut Script) {
        if self.enabled {
            VisitMut::visit_mut_script(self, node)
        } else {
        }
    }

    fn visit_mut_seq_expr(&mut self, node: &mut SeqExpr) {
        if self.enabled {
            VisitMut::visit_mut_seq_expr(self, node)
        } else {
        }
    }

    fn visit_mut_setter_prop(&mut self, node: &mut SetterProp) {
        if self.enabled {
            VisitMut::visit_mut_setter_prop(self, node)
        } else {
        }
    }

    fn visit_mut_simple_assign_target(&mut self, node: &mut SimpleAssignTarget) {
        if self.enabled {
            VisitMut::visit_mut_simple_assign_target(self, node)
        } else {
        }
    }

    fn visit_mut_span(&mut self, node: &mut swc_common::Span) {
        if self.enabled {
            VisitMut::visit_mut_span(self, node)
        } else {
        }
    }

    fn visit_mut_spread_element(&mut self, node: &mut SpreadElement) {
        if self.enabled {
            VisitMut::visit_mut_spread_element(self, node)
        } else {
        }
    }

    fn visit_mut_static_block(&mut self, node: &mut StaticBlock) {
        if self.enabled {
            VisitMut::visit_mut_static_block(self, node)
        } else {
        }
    }

    fn visit_mut_stmt(&mut self, node: &mut Stmt) {
        if self.enabled {
            VisitMut::visit_mut_stmt(self, node)
        } else {
        }
    }

    fn visit_mut_stmts(&mut self, node: &mut Vec<Stmt>) {
        if self.enabled {
            VisitMut::visit_mut_stmts(self, node)
        } else {
        }
    }

    fn visit_mut_str(&mut self, node: &mut Str) {
        if self.enabled {
            VisitMut::visit_mut_str(self, node)
        } else {
        }
    }

    fn visit_mut_super(&mut self, node: &mut Super) {
        if self.enabled {
            VisitMut::visit_mut_super(self, node)
        } else {
        }
    }

    fn visit_mut_super_prop(&mut self, node: &mut SuperProp) {
        if self.enabled {
            VisitMut::visit_mut_super_prop(self, node)
        } else {
        }
    }

    fn visit_mut_super_prop_expr(&mut self, node: &mut SuperPropExpr) {
        if self.enabled {
            VisitMut::visit_mut_super_prop_expr(self, node)
        } else {
        }
    }

    fn visit_mut_switch_case(&mut self, node: &mut SwitchCase) {
        if self.enabled {
            VisitMut::visit_mut_switch_case(self, node)
        } else {
        }
    }

    fn visit_mut_switch_cases(&mut self, node: &mut Vec<SwitchCase>) {
        if self.enabled {
            VisitMut::visit_mut_switch_cases(self, node)
        } else {
        }
    }

    fn visit_mut_switch_stmt(&mut self, node: &mut SwitchStmt) {
        if self.enabled {
            VisitMut::visit_mut_switch_stmt(self, node)
        } else {
        }
    }

    fn visit_mut_syntax_context(&mut self, node: &mut swc_common::SyntaxContext) {
        if self.enabled {
            VisitMut::visit_mut_syntax_context(self, node)
        } else {
        }
    }

    fn visit_mut_tagged_tpl(&mut self, node: &mut TaggedTpl) {
        if self.enabled {
            VisitMut::visit_mut_tagged_tpl(self, node)
        } else {
        }
    }

    fn visit_mut_this_expr(&mut self, node: &mut ThisExpr) {
        if self.enabled {
            VisitMut::visit_mut_this_expr(self, node)
        } else {
        }
    }

    fn visit_mut_throw_stmt(&mut self, node: &mut ThrowStmt) {
        if self.enabled {
            VisitMut::visit_mut_throw_stmt(self, node)
        } else {
        }
    }

    fn visit_mut_tpl(&mut self, node: &mut Tpl) {
        if self.enabled {
            VisitMut::visit_mut_tpl(self, node)
        } else {
        }
    }

    fn visit_mut_tpl_element(&mut self, node: &mut TplElement) {
        if self.enabled {
            VisitMut::visit_mut_tpl_element(self, node)
        } else {
        }
    }

    fn visit_mut_tpl_elements(&mut self, node: &mut Vec<TplElement>) {
        if self.enabled {
            VisitMut::visit_mut_tpl_elements(self, node)
        } else {
        }
    }

    fn visit_mut_true_plus_minus(&mut self, node: &mut TruePlusMinus) {
        if self.enabled {
            VisitMut::visit_mut_true_plus_minus(self, node)
        } else {
        }
    }

    fn visit_mut_try_stmt(&mut self, node: &mut TryStmt) {
        if self.enabled {
            VisitMut::visit_mut_try_stmt(self, node)
        } else {
        }
    }

    fn visit_mut_ts_array_type(&mut self, node: &mut TsArrayType) {
        if self.enabled {
            VisitMut::visit_mut_ts_array_type(self, node)
        } else {
        }
    }

    fn visit_mut_ts_as_expr(&mut self, node: &mut TsAsExpr) {
        if self.enabled {
            VisitMut::visit_mut_ts_as_expr(self, node)
        } else {
        }
    }

    fn visit_mut_ts_call_signature_decl(&mut self, node: &mut TsCallSignatureDecl) {
        if self.enabled {
            VisitMut::visit_mut_ts_call_signature_decl(self, node)
        } else {
        }
    }

    fn visit_mut_ts_conditional_type(&mut self, node: &mut TsConditionalType) {
        if self.enabled {
            VisitMut::visit_mut_ts_conditional_type(self, node)
        } else {
        }
    }

    fn visit_mut_ts_const_assertion(&mut self, node: &mut TsConstAssertion) {
        if self.enabled {
            VisitMut::visit_mut_ts_const_assertion(self, node)
        } else {
        }
    }

    fn visit_mut_ts_construct_signature_decl(&mut self, node: &mut TsConstructSignatureDecl) {
        if self.enabled {
            VisitMut::visit_mut_ts_construct_signature_decl(self, node)
        } else {
        }
    }

    fn visit_mut_ts_constructor_type(&mut self, node: &mut TsConstructorType) {
        if self.enabled {
            VisitMut::visit_mut_ts_constructor_type(self, node)
        } else {
        }
    }

    fn visit_mut_ts_entity_name(&mut self, node: &mut TsEntityName) {
        if self.enabled {
            VisitMut::visit_mut_ts_entity_name(self, node)
        } else {
        }
    }

    fn visit_mut_ts_enum_decl(&mut self, node: &mut TsEnumDecl) {
        if self.enabled {
            VisitMut::visit_mut_ts_enum_decl(self, node)
        } else {
        }
    }

    fn visit_mut_ts_enum_member(&mut self, node: &mut TsEnumMember) {
        if self.enabled {
            VisitMut::visit_mut_ts_enum_member(self, node)
        } else {
        }
    }

    fn visit_mut_ts_enum_member_id(&mut self, node: &mut TsEnumMemberId) {
        if self.enabled {
            VisitMut::visit_mut_ts_enum_member_id(self, node)
        } else {
        }
    }

    fn visit_mut_ts_enum_members(&mut self, node: &mut Vec<TsEnumMember>) {
        if self.enabled {
            VisitMut::visit_mut_ts_enum_members(self, node)
        } else {
        }
    }

    fn visit_mut_ts_export_assignment(&mut self, node: &mut TsExportAssignment) {
        if self.enabled {
            VisitMut::visit_mut_ts_export_assignment(self, node)
        } else {
        }
    }

    fn visit_mut_ts_expr_with_type_args(&mut self, node: &mut TsExprWithTypeArgs) {
        if self.enabled {
            VisitMut::visit_mut_ts_expr_with_type_args(self, node)
        } else {
        }
    }

    fn visit_mut_ts_expr_with_type_argss(&mut self, node: &mut Vec<TsExprWithTypeArgs>) {
        if self.enabled {
            VisitMut::visit_mut_ts_expr_with_type_argss(self, node)
        } else {
        }
    }

    fn visit_mut_ts_external_module_ref(&mut self, node: &mut TsExternalModuleRef) {
        if self.enabled {
            VisitMut::visit_mut_ts_external_module_ref(self, node)
        } else {
        }
    }

    fn visit_mut_ts_fn_or_constructor_type(&mut self, node: &mut TsFnOrConstructorType) {
        if self.enabled {
            VisitMut::visit_mut_ts_fn_or_constructor_type(self, node)
        } else {
        }
    }

    fn visit_mut_ts_fn_param(&mut self, node: &mut TsFnParam) {
        if self.enabled {
            VisitMut::visit_mut_ts_fn_param(self, node)
        } else {
        }
    }

    fn visit_mut_ts_fn_params(&mut self, node: &mut Vec<TsFnParam>) {
        if self.enabled {
            VisitMut::visit_mut_ts_fn_params(self, node)
        } else {
        }
    }

    fn visit_mut_ts_fn_type(&mut self, node: &mut TsFnType) {
        if self.enabled {
            VisitMut::visit_mut_ts_fn_type(self, node)
        } else {
        }
    }

    fn visit_mut_ts_getter_signature(&mut self, node: &mut TsGetterSignature) {
        if self.enabled {
            VisitMut::visit_mut_ts_getter_signature(self, node)
        } else {
        }
    }

    fn visit_mut_ts_import_equals_decl(&mut self, node: &mut TsImportEqualsDecl) {
        if self.enabled {
            VisitMut::visit_mut_ts_import_equals_decl(self, node)
        } else {
        }
    }

    fn visit_mut_ts_import_type(&mut self, node: &mut TsImportType) {
        if self.enabled {
            VisitMut::visit_mut_ts_import_type(self, node)
        } else {
        }
    }

    fn visit_mut_ts_index_signature(&mut self, node: &mut TsIndexSignature) {
        if self.enabled {
            VisitMut::visit_mut_ts_index_signature(self, node)
        } else {
        }
    }

    fn visit_mut_ts_indexed_access_type(&mut self, node: &mut TsIndexedAccessType) {
        if self.enabled {
            VisitMut::visit_mut_ts_indexed_access_type(self, node)
        } else {
        }
    }

    fn visit_mut_ts_infer_type(&mut self, node: &mut TsInferType) {
        if self.enabled {
            VisitMut::visit_mut_ts_infer_type(self, node)
        } else {
        }
    }

    fn visit_mut_ts_instantiation(&mut self, node: &mut TsInstantiation) {
        if self.enabled {
            VisitMut::visit_mut_ts_instantiation(self, node)
        } else {
        }
    }

    fn visit_mut_ts_interface_body(&mut self, node: &mut TsInterfaceBody) {
        if self.enabled {
            VisitMut::visit_mut_ts_interface_body(self, node)
        } else {
        }
    }

    fn visit_mut_ts_interface_decl(&mut self, node: &mut TsInterfaceDecl) {
        if self.enabled {
            VisitMut::visit_mut_ts_interface_decl(self, node)
        } else {
        }
    }

    fn visit_mut_ts_intersection_type(&mut self, node: &mut TsIntersectionType) {
        if self.enabled {
            VisitMut::visit_mut_ts_intersection_type(self, node)
        } else {
        }
    }

    fn visit_mut_ts_keyword_type(&mut self, node: &mut TsKeywordType) {
        if self.enabled {
            VisitMut::visit_mut_ts_keyword_type(self, node)
        } else {
        }
    }

    fn visit_mut_ts_keyword_type_kind(&mut self, node: &mut TsKeywordTypeKind) {
        if self.enabled {
            VisitMut::visit_mut_ts_keyword_type_kind(self, node)
        } else {
        }
    }

    fn visit_mut_ts_lit(&mut self, node: &mut TsLit) {
        if self.enabled {
            VisitMut::visit_mut_ts_lit(self, node)
        } else {
        }
    }

    fn visit_mut_ts_lit_type(&mut self, node: &mut TsLitType) {
        if self.enabled {
            VisitMut::visit_mut_ts_lit_type(self, node)
        } else {
        }
    }

    fn visit_mut_ts_mapped_type(&mut self, node: &mut TsMappedType) {
        if self.enabled {
            VisitMut::visit_mut_ts_mapped_type(self, node)
        } else {
        }
    }

    fn visit_mut_ts_method_signature(&mut self, node: &mut TsMethodSignature) {
        if self.enabled {
            VisitMut::visit_mut_ts_method_signature(self, node)
        } else {
        }
    }

    fn visit_mut_ts_module_block(&mut self, node: &mut TsModuleBlock) {
        if self.enabled {
            VisitMut::visit_mut_ts_module_block(self, node)
        } else {
        }
    }

    fn visit_mut_ts_module_decl(&mut self, node: &mut TsModuleDecl) {
        if self.enabled {
            VisitMut::visit_mut_ts_module_decl(self, node)
        } else {
        }
    }

    fn visit_mut_ts_module_name(&mut self, node: &mut TsModuleName) {
        if self.enabled {
            VisitMut::visit_mut_ts_module_name(self, node)
        } else {
        }
    }

    fn visit_mut_ts_module_ref(&mut self, node: &mut TsModuleRef) {
        if self.enabled {
            VisitMut::visit_mut_ts_module_ref(self, node)
        } else {
        }
    }

    fn visit_mut_ts_namespace_body(&mut self, node: &mut TsNamespaceBody) {
        if self.enabled {
            VisitMut::visit_mut_ts_namespace_body(self, node)
        } else {
        }
    }

    fn visit_mut_ts_namespace_decl(&mut self, node: &mut TsNamespaceDecl) {
        if self.enabled {
            VisitMut::visit_mut_ts_namespace_decl(self, node)
        } else {
        }
    }

    fn visit_mut_ts_namespace_export_decl(&mut self, node: &mut TsNamespaceExportDecl) {
        if self.enabled {
            VisitMut::visit_mut_ts_namespace_export_decl(self, node)
        } else {
        }
    }

    fn visit_mut_ts_non_null_expr(&mut self, node: &mut TsNonNullExpr) {
        if self.enabled {
            VisitMut::visit_mut_ts_non_null_expr(self, node)
        } else {
        }
    }

    fn visit_mut_ts_optional_type(&mut self, node: &mut TsOptionalType) {
        if self.enabled {
            VisitMut::visit_mut_ts_optional_type(self, node)
        } else {
        }
    }

    fn visit_mut_ts_param_prop(&mut self, node: &mut TsParamProp) {
        if self.enabled {
            VisitMut::visit_mut_ts_param_prop(self, node)
        } else {
        }
    }

    fn visit_mut_ts_param_prop_param(&mut self, node: &mut TsParamPropParam) {
        if self.enabled {
            VisitMut::visit_mut_ts_param_prop_param(self, node)
        } else {
        }
    }

    fn visit_mut_ts_parenthesized_type(&mut self, node: &mut TsParenthesizedType) {
        if self.enabled {
            VisitMut::visit_mut_ts_parenthesized_type(self, node)
        } else {
        }
    }

    fn visit_mut_ts_property_signature(&mut self, node: &mut TsPropertySignature) {
        if self.enabled {
            VisitMut::visit_mut_ts_property_signature(self, node)
        } else {
        }
    }

    fn visit_mut_ts_qualified_name(&mut self, node: &mut TsQualifiedName) {
        if self.enabled {
            VisitMut::visit_mut_ts_qualified_name(self, node)
        } else {
        }
    }

    fn visit_mut_ts_rest_type(&mut self, node: &mut TsRestType) {
        if self.enabled {
            VisitMut::visit_mut_ts_rest_type(self, node)
        } else {
        }
    }

    fn visit_mut_ts_satisfies_expr(&mut self, node: &mut TsSatisfiesExpr) {
        if self.enabled {
            VisitMut::visit_mut_ts_satisfies_expr(self, node)
        } else {
        }
    }

    fn visit_mut_ts_setter_signature(&mut self, node: &mut TsSetterSignature) {
        if self.enabled {
            VisitMut::visit_mut_ts_setter_signature(self, node)
        } else {
        }
    }

    fn visit_mut_ts_this_type(&mut self, node: &mut TsThisType) {
        if self.enabled {
            VisitMut::visit_mut_ts_this_type(self, node)
        } else {
        }
    }

    fn visit_mut_ts_this_type_or_ident(&mut self, node: &mut TsThisTypeOrIdent) {
        if self.enabled {
            VisitMut::visit_mut_ts_this_type_or_ident(self, node)
        } else {
        }
    }

    fn visit_mut_ts_tpl_lit_type(&mut self, node: &mut TsTplLitType) {
        if self.enabled {
            VisitMut::visit_mut_ts_tpl_lit_type(self, node)
        } else {
        }
    }

    fn visit_mut_ts_tuple_element(&mut self, node: &mut TsTupleElement) {
        if self.enabled {
            VisitMut::visit_mut_ts_tuple_element(self, node)
        } else {
        }
    }

    fn visit_mut_ts_tuple_elements(&mut self, node: &mut Vec<TsTupleElement>) {
        if self.enabled {
            VisitMut::visit_mut_ts_tuple_elements(self, node)
        } else {
        }
    }

    fn visit_mut_ts_tuple_type(&mut self, node: &mut TsTupleType) {
        if self.enabled {
            VisitMut::visit_mut_ts_tuple_type(self, node)
        } else {
        }
    }

    fn visit_mut_ts_type(&mut self, node: &mut TsType) {
        if self.enabled {
            VisitMut::visit_mut_ts_type(self, node)
        } else {
        }
    }

    fn visit_mut_ts_type_alias_decl(&mut self, node: &mut TsTypeAliasDecl) {
        if self.enabled {
            VisitMut::visit_mut_ts_type_alias_decl(self, node)
        } else {
        }
    }

    fn visit_mut_ts_type_ann(&mut self, node: &mut TsTypeAnn) {
        if self.enabled {
            VisitMut::visit_mut_ts_type_ann(self, node)
        } else {
        }
    }

    fn visit_mut_ts_type_assertion(&mut self, node: &mut TsTypeAssertion) {
        if self.enabled {
            VisitMut::visit_mut_ts_type_assertion(self, node)
        } else {
        }
    }

    fn visit_mut_ts_type_element(&mut self, node: &mut TsTypeElement) {
        if self.enabled {
            VisitMut::visit_mut_ts_type_element(self, node)
        } else {
        }
    }

    fn visit_mut_ts_type_elements(&mut self, node: &mut Vec<TsTypeElement>) {
        if self.enabled {
            VisitMut::visit_mut_ts_type_elements(self, node)
        } else {
        }
    }

    fn visit_mut_ts_type_lit(&mut self, node: &mut TsTypeLit) {
        if self.enabled {
            VisitMut::visit_mut_ts_type_lit(self, node)
        } else {
        }
    }

    fn visit_mut_ts_type_operator(&mut self, node: &mut TsTypeOperator) {
        if self.enabled {
            VisitMut::visit_mut_ts_type_operator(self, node)
        } else {
        }
    }

    fn visit_mut_ts_type_operator_op(&mut self, node: &mut TsTypeOperatorOp) {
        if self.enabled {
            VisitMut::visit_mut_ts_type_operator_op(self, node)
        } else {
        }
    }

    fn visit_mut_ts_type_param(&mut self, node: &mut TsTypeParam) {
        if self.enabled {
            VisitMut::visit_mut_ts_type_param(self, node)
        } else {
        }
    }

    fn visit_mut_ts_type_param_decl(&mut self, node: &mut TsTypeParamDecl) {
        if self.enabled {
            VisitMut::visit_mut_ts_type_param_decl(self, node)
        } else {
        }
    }

    fn visit_mut_ts_type_param_instantiation(&mut self, node: &mut TsTypeParamInstantiation) {
        if self.enabled {
            VisitMut::visit_mut_ts_type_param_instantiation(self, node)
        } else {
        }
    }

    fn visit_mut_ts_type_params(&mut self, node: &mut Vec<TsTypeParam>) {
        if self.enabled {
            VisitMut::visit_mut_ts_type_params(self, node)
        } else {
        }
    }

    fn visit_mut_ts_type_predicate(&mut self, node: &mut TsTypePredicate) {
        if self.enabled {
            VisitMut::visit_mut_ts_type_predicate(self, node)
        } else {
        }
    }

    fn visit_mut_ts_type_query(&mut self, node: &mut TsTypeQuery) {
        if self.enabled {
            VisitMut::visit_mut_ts_type_query(self, node)
        } else {
        }
    }

    fn visit_mut_ts_type_query_expr(&mut self, node: &mut TsTypeQueryExpr) {
        if self.enabled {
            VisitMut::visit_mut_ts_type_query_expr(self, node)
        } else {
        }
    }

    fn visit_mut_ts_type_ref(&mut self, node: &mut TsTypeRef) {
        if self.enabled {
            VisitMut::visit_mut_ts_type_ref(self, node)
        } else {
        }
    }

    fn visit_mut_ts_types(&mut self, node: &mut Vec<Box<TsType>>) {
        if self.enabled {
            VisitMut::visit_mut_ts_types(self, node)
        } else {
        }
    }

    fn visit_mut_ts_union_or_intersection_type(&mut self, node: &mut TsUnionOrIntersectionType) {
        if self.enabled {
            VisitMut::visit_mut_ts_union_or_intersection_type(self, node)
        } else {
        }
    }

    fn visit_mut_ts_union_type(&mut self, node: &mut TsUnionType) {
        if self.enabled {
            VisitMut::visit_mut_ts_union_type(self, node)
        } else {
        }
    }

    fn visit_mut_unary_expr(&mut self, node: &mut UnaryExpr) {
        if self.enabled {
            VisitMut::visit_mut_unary_expr(self, node)
        } else {
        }
    }

    fn visit_mut_unary_op(&mut self, node: &mut UnaryOp) {
        if self.enabled {
            VisitMut::visit_mut_unary_op(self, node)
        } else {
        }
    }

    fn visit_mut_update_expr(&mut self, node: &mut UpdateExpr) {
        if self.enabled {
            VisitMut::visit_mut_update_expr(self, node)
        } else {
        }
    }

    fn visit_mut_update_op(&mut self, node: &mut UpdateOp) {
        if self.enabled {
            VisitMut::visit_mut_update_op(self, node)
        } else {
        }
    }

    fn visit_mut_using_decl(&mut self, node: &mut UsingDecl) {
        if self.enabled {
            VisitMut::visit_mut_using_decl(self, node)
        } else {
        }
    }

    fn visit_mut_var_decl(&mut self, node: &mut VarDecl) {
        if self.enabled {
            VisitMut::visit_mut_var_decl(self, node)
        } else {
        }
    }

    fn visit_mut_var_decl_kind(&mut self, node: &mut VarDeclKind) {
        if self.enabled {
            VisitMut::visit_mut_var_decl_kind(self, node)
        } else {
        }
    }

    fn visit_mut_var_decl_or_expr(&mut self, node: &mut VarDeclOrExpr) {
        if self.enabled {
            VisitMut::visit_mut_var_decl_or_expr(self, node)
        } else {
        }
    }

    fn visit_mut_var_declarator(&mut self, node: &mut VarDeclarator) {
        if self.enabled {
            VisitMut::visit_mut_var_declarator(self, node)
        } else {
        }
    }

    fn visit_mut_var_declarators(&mut self, node: &mut Vec<VarDeclarator>) {
        if self.enabled {
            VisitMut::visit_mut_var_declarators(self, node)
        } else {
        }
    }

    fn visit_mut_while_stmt(&mut self, node: &mut WhileStmt) {
        if self.enabled {
            VisitMut::visit_mut_while_stmt(self, node)
        } else {
        }
    }

    fn visit_mut_with_stmt(&mut self, node: &mut WithStmt) {
        if self.enabled {
            VisitMut::visit_mut_with_stmt(self, node)
        } else {
        }
    }

    fn visit_mut_yield_expr(&mut self, node: &mut YieldExpr) {
        if self.enabled {
            VisitMut::visit_mut_yield_expr(self, node)
        } else {
        }
    }
}
#[doc = r" A trait implemented for types that can be visited using a visitor."]
pub trait VisitMutWith<V: ?Sized + VisitMut> {
    #[doc = r" Calls a visitor method (visitor.fold_xxx) with self."]
    fn visit_mut_with(&mut self, visitor: &mut V);
    #[doc = r" Visit children nodes of `self`` with `visitor`."]
    fn visit_mut_children_with(&mut self, visitor: &mut V);
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Accessibility {
    #[doc = "Calls [VisitMut`::visit_mut_accessibility`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_accessibility(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Accessibility::Public => {}
            Accessibility::Protected => {}
            Accessibility::Private => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ArrayLit {
    #[doc = "Calls [VisitMut`::visit_mut_array_lit`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_array_lit(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ArrayLit { span, elems } => {
                <Vec<Option<ExprOrSpread>> as VisitMutWith<V>>::visit_mut_with(elems, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ArrayPat {
    #[doc = "Calls [VisitMut`::visit_mut_array_pat`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_array_pat(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ArrayPat {
                span,
                elems,
                optional,
                type_ann,
            } => {
                <Vec<Option<Pat>> as VisitMutWith<V>>::visit_mut_with(elems, visitor);
                <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ArrowExpr {
    #[doc = "Calls [VisitMut`::visit_mut_arrow_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_arrow_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ArrowExpr {
                span,
                ctxt,
                params,
                body,
                is_async,
                is_generator,
                type_params,
                return_type,
            } => {
                <Vec<Pat> as VisitMutWith<V>>::visit_mut_with(params, visitor);
                <Box<BlockStmtOrExpr> as VisitMutWith<V>>::visit_mut_with(body, visitor);
                <Option<Box<TsTypeParamDecl>> as VisitMutWith<V>>::visit_mut_with(
                    type_params,
                    visitor,
                );
                <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(return_type, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for AssignExpr {
    #[doc = "Calls [VisitMut`::visit_mut_assign_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_assign_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            AssignExpr {
                span,
                op,
                left,
                right,
            } => {
                <AssignOp as VisitMutWith<V>>::visit_mut_with(op, visitor);
                <AssignTarget as VisitMutWith<V>>::visit_mut_with(left, visitor);
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(right, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for AssignOp {
    #[doc = "Calls [VisitMut`::visit_mut_assign_op`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_assign_op(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            AssignOp::Assign => {}
            AssignOp::AddAssign => {}
            AssignOp::SubAssign => {}
            AssignOp::MulAssign => {}
            AssignOp::DivAssign => {}
            AssignOp::ModAssign => {}
            AssignOp::LShiftAssign => {}
            AssignOp::RShiftAssign => {}
            AssignOp::ZeroFillRShiftAssign => {}
            AssignOp::BitOrAssign => {}
            AssignOp::BitXorAssign => {}
            AssignOp::BitAndAssign => {}
            AssignOp::ExpAssign => {}
            AssignOp::AndAssign => {}
            AssignOp::OrAssign => {}
            AssignOp::NullishAssign => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for AssignPat {
    #[doc = "Calls [VisitMut`::visit_mut_assign_pat`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_assign_pat(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            AssignPat { span, left, right } => {
                <Box<Pat> as VisitMutWith<V>>::visit_mut_with(left, visitor);
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(right, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for AssignPatProp {
    #[doc = "Calls [VisitMut`::visit_mut_assign_pat_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_assign_pat_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            AssignPatProp { span, key, value } => {
                <BindingIdent as VisitMutWith<V>>::visit_mut_with(key, visitor);
                <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(value, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for AssignProp {
    #[doc = "Calls [VisitMut`::visit_mut_assign_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_assign_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            AssignProp { span, key, value } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(key, visitor);
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(value, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for AssignTarget {
    #[doc = "Calls [VisitMut`::visit_mut_assign_target`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_assign_target(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            AssignTarget::Simple { 0: _field_0 } => {
                <SimpleAssignTarget as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            AssignTarget::Pat { 0: _field_0 } => {
                <AssignTargetPat as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for AssignTargetPat {
    #[doc = "Calls [VisitMut`::visit_mut_assign_target_pat`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_assign_target_pat(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            AssignTargetPat::Array { 0: _field_0 } => {
                <ArrayPat as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            AssignTargetPat::Object { 0: _field_0 } => {
                <ObjectPat as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            AssignTargetPat::Invalid { 0: _field_0 } => {
                <Invalid as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for AutoAccessor {
    #[doc = "Calls [VisitMut`::visit_mut_auto_accessor`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_auto_accessor(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            AutoAccessor {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_override,
                definite,
            } => {
                <Key as VisitMutWith<V>>::visit_mut_with(key, visitor);
                <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(value, visitor);
                <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
                <Vec<Decorator> as VisitMutWith<V>>::visit_mut_with(decorators, visitor);
                <Option<Accessibility> as VisitMutWith<V>>::visit_mut_with(accessibility, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for AwaitExpr {
    #[doc = "Calls [VisitMut`::visit_mut_await_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_await_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            AwaitExpr { span, arg } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(arg, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for BigInt {
    #[doc = "Calls [VisitMut`::visit_mut_big_int`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_big_int(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            BigInt { span, value, raw } => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for BinExpr {
    #[doc = "Calls [VisitMut`::visit_mut_bin_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_bin_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            BinExpr {
                span,
                op,
                left,
                right,
            } => {
                <BinaryOp as VisitMutWith<V>>::visit_mut_with(op, visitor);
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(left, visitor);
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(right, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for BinaryOp {
    #[doc = "Calls [VisitMut`::visit_mut_binary_op`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_binary_op(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            BinaryOp::EqEq => {}
            BinaryOp::NotEq => {}
            BinaryOp::EqEqEq => {}
            BinaryOp::NotEqEq => {}
            BinaryOp::Lt => {}
            BinaryOp::LtEq => {}
            BinaryOp::Gt => {}
            BinaryOp::GtEq => {}
            BinaryOp::LShift => {}
            BinaryOp::RShift => {}
            BinaryOp::ZeroFillRShift => {}
            BinaryOp::Add => {}
            BinaryOp::Sub => {}
            BinaryOp::Mul => {}
            BinaryOp::Div => {}
            BinaryOp::Mod => {}
            BinaryOp::BitOr => {}
            BinaryOp::BitXor => {}
            BinaryOp::BitAnd => {}
            BinaryOp::LogicalOr => {}
            BinaryOp::LogicalAnd => {}
            BinaryOp::In => {}
            BinaryOp::InstanceOf => {}
            BinaryOp::Exp => {}
            BinaryOp::NullishCoalescing => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for BindingIdent {
    #[doc = "Calls [VisitMut`::visit_mut_binding_ident`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_binding_ident(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            BindingIdent { id, type_ann } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(id, visitor);
                <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for BlockStmt {
    #[doc = "Calls [VisitMut`::visit_mut_block_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_block_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            BlockStmt { span, ctxt, stmts } => {
                <Vec<Stmt> as VisitMutWith<V>>::visit_mut_with(stmts, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for BlockStmtOrExpr {
    #[doc = "Calls [VisitMut`::visit_mut_block_stmt_or_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_block_stmt_or_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            BlockStmtOrExpr::BlockStmt { 0: _field_0 } => {
                <BlockStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            BlockStmtOrExpr::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Bool {
    #[doc = "Calls [VisitMut`::visit_mut_bool`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_bool(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Bool { span, value } => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for BreakStmt {
    #[doc = "Calls [VisitMut`::visit_mut_break_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_break_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            BreakStmt { span, label } => {
                <Option<Ident> as VisitMutWith<V>>::visit_mut_with(label, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for CallExpr {
    #[doc = "Calls [VisitMut`::visit_mut_call_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_call_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            CallExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                <Callee as VisitMutWith<V>>::visit_mut_with(callee, visitor);
                <Vec<ExprOrSpread> as VisitMutWith<V>>::visit_mut_with(args, visitor);
                <Option<Box<TsTypeParamInstantiation>> as VisitMutWith<V>>::visit_mut_with(
                    type_args, visitor,
                );
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Callee {
    #[doc = "Calls [VisitMut`::visit_mut_callee`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_callee(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Callee::Super { 0: _field_0 } => {
                <Super as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Callee::Import { 0: _field_0 } => {
                <Import as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Callee::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for CatchClause {
    #[doc = "Calls [VisitMut`::visit_mut_catch_clause`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_catch_clause(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            CatchClause { span, param, body } => {
                <Option<Pat> as VisitMutWith<V>>::visit_mut_with(param, visitor);
                <BlockStmt as VisitMutWith<V>>::visit_mut_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Class {
    #[doc = "Calls [VisitMut`::visit_mut_class`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_class(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Class {
                span,
                ctxt,
                decorators,
                body,
                super_class,
                is_abstract,
                type_params,
                super_type_params,
                implements,
            } => {
                <Vec<Decorator> as VisitMutWith<V>>::visit_mut_with(decorators, visitor);
                <Vec<ClassMember> as VisitMutWith<V>>::visit_mut_with(body, visitor);
                <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(super_class, visitor);
                <Option<Box<TsTypeParamDecl>> as VisitMutWith<V>>::visit_mut_with(
                    type_params,
                    visitor,
                );
                <Option<Box<TsTypeParamInstantiation>> as VisitMutWith<V>>::visit_mut_with(
                    super_type_params,
                    visitor,
                );
                <Vec<TsExprWithTypeArgs> as VisitMutWith<V>>::visit_mut_with(implements, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ClassDecl {
    #[doc = "Calls [VisitMut`::visit_mut_class_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_class_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ClassDecl {
                ident,
                declare,
                class,
            } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(ident, visitor);
                <Box<Class> as VisitMutWith<V>>::visit_mut_with(class, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ClassExpr {
    #[doc = "Calls [VisitMut`::visit_mut_class_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_class_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ClassExpr { ident, class } => {
                <Option<Ident> as VisitMutWith<V>>::visit_mut_with(ident, visitor);
                <Box<Class> as VisitMutWith<V>>::visit_mut_with(class, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ClassMember {
    #[doc = "Calls [VisitMut`::visit_mut_class_member`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_class_member(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ClassMember::Constructor { 0: _field_0 } => {
                <Constructor as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ClassMember::Method { 0: _field_0 } => {}
            ClassMember::PrivateMethod { 0: _field_0 } => {}
            ClassMember::ClassProp { 0: _field_0 } => {
                <ClassProp as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ClassMember::PrivateProp { 0: _field_0 } => {
                <PrivateProp as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ClassMember::TsIndexSignature { 0: _field_0 } => {
                <TsIndexSignature as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ClassMember::Empty { 0: _field_0 } => {
                <EmptyStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ClassMember::StaticBlock { 0: _field_0 } => {
                <StaticBlock as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ClassMember::AutoAccessor { 0: _field_0 } => {
                <AutoAccessor as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ClassProp {
    #[doc = "Calls [VisitMut`::visit_mut_class_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_class_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ClassProp {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
                readonly,
                declare,
                definite,
            } => {
                <PropName as VisitMutWith<V>>::visit_mut_with(key, visitor);
                <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(value, visitor);
                <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
                <Vec<Decorator> as VisitMutWith<V>>::visit_mut_with(decorators, visitor);
                <Option<Accessibility> as VisitMutWith<V>>::visit_mut_with(accessibility, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ComputedPropName {
    #[doc = "Calls [VisitMut`::visit_mut_computed_prop_name`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_computed_prop_name(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ComputedPropName { span, expr } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for CondExpr {
    #[doc = "Calls [VisitMut`::visit_mut_cond_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_cond_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            CondExpr {
                span,
                test,
                cons,
                alt,
            } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(test, visitor);
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(cons, visitor);
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(alt, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Constructor {
    #[doc = "Calls [VisitMut`::visit_mut_constructor`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_constructor(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Constructor {
                span,
                ctxt,
                key,
                params,
                body,
                accessibility,
                is_optional,
            } => {
                <PropName as VisitMutWith<V>>::visit_mut_with(key, visitor);
                <Vec<ParamOrTsParamProp> as VisitMutWith<V>>::visit_mut_with(params, visitor);
                <Option<BlockStmt> as VisitMutWith<V>>::visit_mut_with(body, visitor);
                <Option<Accessibility> as VisitMutWith<V>>::visit_mut_with(accessibility, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ContinueStmt {
    #[doc = "Calls [VisitMut`::visit_mut_continue_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_continue_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ContinueStmt { span, label } => {
                <Option<Ident> as VisitMutWith<V>>::visit_mut_with(label, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for DebuggerStmt {
    #[doc = "Calls [VisitMut`::visit_mut_debugger_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_debugger_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            DebuggerStmt { span } => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Decl {
    #[doc = "Calls [VisitMut`::visit_mut_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Decl::Class { 0: _field_0 } => {
                <ClassDecl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Decl::Fn { 0: _field_0 } => {
                <FnDecl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Decl::Var { 0: _field_0 } => {
                <Box<VarDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Decl::Using { 0: _field_0 } => {
                <Box<UsingDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Decl::TsInterface { 0: _field_0 } => {
                <Box<TsInterfaceDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Decl::TsTypeAlias { 0: _field_0 } => {
                <Box<TsTypeAliasDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Decl::TsEnum { 0: _field_0 } => {
                <Box<TsEnumDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Decl::TsModule { 0: _field_0 } => {
                <Box<TsModuleDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Decorator {
    #[doc = "Calls [VisitMut`::visit_mut_decorator`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_decorator(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Decorator { span, expr } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for DefaultDecl {
    #[doc = "Calls [VisitMut`::visit_mut_default_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_default_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            DefaultDecl::Class { 0: _field_0 } => {
                <ClassExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            DefaultDecl::Fn { 0: _field_0 } => {
                <FnExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            DefaultDecl::TsInterfaceDecl { 0: _field_0 } => {
                <Box<TsInterfaceDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for DoWhileStmt {
    #[doc = "Calls [VisitMut`::visit_mut_do_while_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_do_while_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            DoWhileStmt { span, test, body } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(test, visitor);
                <Box<Stmt> as VisitMutWith<V>>::visit_mut_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for EmptyStmt {
    #[doc = "Calls [VisitMut`::visit_mut_empty_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_empty_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            EmptyStmt { span } => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for EsVersion {
    #[doc = "Calls [VisitMut`::visit_mut_es_version`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_es_version(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            EsVersion::Es3 => {}
            EsVersion::Es5 => {}
            EsVersion::Es2015 => {}
            EsVersion::Es2016 => {}
            EsVersion::Es2017 => {}
            EsVersion::Es2018 => {}
            EsVersion::Es2019 => {}
            EsVersion::Es2020 => {}
            EsVersion::Es2021 => {}
            EsVersion::Es2022 => {}
            EsVersion::EsNext => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ExportAll {
    #[doc = "Calls [VisitMut`::visit_mut_export_all`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_export_all(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ExportAll {
                span,
                src,
                type_only,
                with,
            } => {
                <Box<Str> as VisitMutWith<V>>::visit_mut_with(src, visitor);
                <Option<Box<ObjectLit>> as VisitMutWith<V>>::visit_mut_with(with, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ExportDecl {
    #[doc = "Calls [VisitMut`::visit_mut_export_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_export_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ExportDecl { span, decl } => {
                <Decl as VisitMutWith<V>>::visit_mut_with(decl, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ExportDefaultDecl {
    #[doc = "Calls [VisitMut`::visit_mut_export_default_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_export_default_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ExportDefaultDecl { span, decl } => {
                <DefaultDecl as VisitMutWith<V>>::visit_mut_with(decl, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ExportDefaultExpr {
    #[doc = "Calls [VisitMut`::visit_mut_export_default_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_export_default_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ExportDefaultExpr { span, expr } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ExportDefaultSpecifier {
    #[doc = "Calls [VisitMut`::visit_mut_export_default_specifier`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_export_default_specifier(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ExportDefaultSpecifier { exported } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(exported, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ExportNamedSpecifier {
    #[doc = "Calls [VisitMut`::visit_mut_export_named_specifier`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_export_named_specifier(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ExportNamedSpecifier {
                span,
                orig,
                exported,
                is_type_only,
            } => {
                <ModuleExportName as VisitMutWith<V>>::visit_mut_with(orig, visitor);
                <Option<ModuleExportName> as VisitMutWith<V>>::visit_mut_with(exported, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ExportNamespaceSpecifier {
    #[doc = "Calls [VisitMut`::visit_mut_export_namespace_specifier`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_export_namespace_specifier(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ExportNamespaceSpecifier { span, name } => {
                <ModuleExportName as VisitMutWith<V>>::visit_mut_with(name, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ExportSpecifier {
    #[doc = "Calls [VisitMut`::visit_mut_export_specifier`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_export_specifier(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ExportSpecifier::Namespace { 0: _field_0 } => {
                <ExportNamespaceSpecifier as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ExportSpecifier::Default { 0: _field_0 } => {
                <ExportDefaultSpecifier as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ExportSpecifier::Named { 0: _field_0 } => {
                <ExportNamedSpecifier as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Expr {
    #[doc = "Calls [VisitMut`::visit_mut_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Expr::This { 0: _field_0 } => {
                <ThisExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Array { 0: _field_0 } => {
                <ArrayLit as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Object { 0: _field_0 } => {
                <ObjectLit as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Fn { 0: _field_0 } => {
                <FnExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Unary { 0: _field_0 } => {
                <UnaryExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Update { 0: _field_0 } => {
                <UpdateExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Bin { 0: _field_0 } => {
                <BinExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Assign { 0: _field_0 } => {
                <AssignExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Member { 0: _field_0 } => {
                <MemberExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::SuperProp { 0: _field_0 } => {
                <SuperPropExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Cond { 0: _field_0 } => {
                <CondExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Call { 0: _field_0 } => {
                <CallExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::New { 0: _field_0 } => {
                <NewExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Seq { 0: _field_0 } => {
                <SeqExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Ident { 0: _field_0 } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Lit { 0: _field_0 } => {
                <Lit as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Tpl { 0: _field_0 } => {
                <Tpl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::TaggedTpl { 0: _field_0 } => {
                <TaggedTpl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Arrow { 0: _field_0 } => {
                <ArrowExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Class { 0: _field_0 } => {
                <ClassExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Yield { 0: _field_0 } => {
                <YieldExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::MetaProp { 0: _field_0 } => {
                <MetaPropExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Await { 0: _field_0 } => {
                <AwaitExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Paren { 0: _field_0 } => {
                <ParenExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::JSXMember { 0: _field_0 } => {
                <JSXMemberExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::JSXNamespacedName { 0: _field_0 } => {
                <JSXNamespacedName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::JSXEmpty { 0: _field_0 } => {
                <JSXEmptyExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::JSXElement { 0: _field_0 } => {
                <Box<JSXElement> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::JSXFragment { 0: _field_0 } => {
                <JSXFragment as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::TsTypeAssertion { 0: _field_0 } => {
                <TsTypeAssertion as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::TsConstAssertion { 0: _field_0 } => {
                <TsConstAssertion as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::TsNonNull { 0: _field_0 } => {
                <TsNonNullExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::TsAs { 0: _field_0 } => {
                <TsAsExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::TsInstantiation { 0: _field_0 } => {
                <TsInstantiation as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::TsSatisfies { 0: _field_0 } => {
                <TsSatisfiesExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::PrivateName { 0: _field_0 } => {
                <PrivateName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::OptChain { 0: _field_0 } => {
                <OptChainExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Expr::Invalid { 0: _field_0 } => {
                <Invalid as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ExprOrSpread {
    #[doc = "Calls [VisitMut`::visit_mut_expr_or_spread`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_expr_or_spread(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ExprOrSpread { spread, expr } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ExprStmt {
    #[doc = "Calls [VisitMut`::visit_mut_expr_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_expr_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ExprStmt { span, expr } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for FnDecl {
    #[doc = "Calls [VisitMut`::visit_mut_fn_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_fn_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            FnDecl {
                ident,
                declare,
                function,
            } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(ident, visitor);
                <Box<Function> as VisitMutWith<V>>::visit_mut_with(function, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for FnExpr {
    #[doc = "Calls [VisitMut`::visit_mut_fn_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_fn_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            FnExpr { ident, function } => {
                <Option<Ident> as VisitMutWith<V>>::visit_mut_with(ident, visitor);
                <Box<Function> as VisitMutWith<V>>::visit_mut_with(function, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ForHead {
    #[doc = "Calls [VisitMut`::visit_mut_for_head`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_for_head(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ForHead::VarDecl { 0: _field_0 } => {
                <Box<VarDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ForHead::UsingDecl { 0: _field_0 } => {
                <Box<UsingDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ForHead::Pat { 0: _field_0 } => {
                <Box<Pat> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ForInStmt {
    #[doc = "Calls [VisitMut`::visit_mut_for_in_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_for_in_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ForInStmt {
                span,
                left,
                right,
                body,
            } => {
                <ForHead as VisitMutWith<V>>::visit_mut_with(left, visitor);
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(right, visitor);
                <Box<Stmt> as VisitMutWith<V>>::visit_mut_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ForOfStmt {
    #[doc = "Calls [VisitMut`::visit_mut_for_of_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_for_of_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ForOfStmt {
                span,
                is_await,
                left,
                right,
                body,
            } => {
                <ForHead as VisitMutWith<V>>::visit_mut_with(left, visitor);
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(right, visitor);
                <Box<Stmt> as VisitMutWith<V>>::visit_mut_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ForStmt {
    #[doc = "Calls [VisitMut`::visit_mut_for_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_for_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ForStmt {
                span,
                init,
                test,
                update,
                body,
            } => {
                <Option<VarDeclOrExpr> as VisitMutWith<V>>::visit_mut_with(init, visitor);
                <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(test, visitor);
                <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(update, visitor);
                <Box<Stmt> as VisitMutWith<V>>::visit_mut_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Function {
    #[doc = "Calls [VisitMut`::visit_mut_function`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_function(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Function {
                params,
                decorators,
                span,
                ctxt,
                body,
                is_generator,
                is_async,
                type_params,
                return_type,
            } => {
                <Vec<Param> as VisitMutWith<V>>::visit_mut_with(params, visitor);
                <Vec<Decorator> as VisitMutWith<V>>::visit_mut_with(decorators, visitor);
                <Option<BlockStmt> as VisitMutWith<V>>::visit_mut_with(body, visitor);
                <Option<Box<TsTypeParamDecl>> as VisitMutWith<V>>::visit_mut_with(
                    type_params,
                    visitor,
                );
                <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(return_type, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for GetterProp {
    #[doc = "Calls [VisitMut`::visit_mut_getter_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_getter_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            GetterProp {
                span,
                key,
                type_ann,
                body,
            } => {
                <PropName as VisitMutWith<V>>::visit_mut_with(key, visitor);
                <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
                <Option<BlockStmt> as VisitMutWith<V>>::visit_mut_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Ident {
    #[doc = "Calls [VisitMut`::visit_mut_ident`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ident(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Ident {
                span,
                ctxt,
                sym,
                optional,
            } => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for IdentName {
    #[doc = "Calls [VisitMut`::visit_mut_ident_name`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ident_name(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            IdentName { span, sym } => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for IfStmt {
    #[doc = "Calls [VisitMut`::visit_mut_if_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_if_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            IfStmt {
                span,
                test,
                cons,
                alt,
            } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(test, visitor);
                <Box<Stmt> as VisitMutWith<V>>::visit_mut_with(cons, visitor);
                <Option<Box<Stmt>> as VisitMutWith<V>>::visit_mut_with(alt, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Import {
    #[doc = "Calls [VisitMut`::visit_mut_import`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Import { span, phase } => {
                <ImportPhase as VisitMutWith<V>>::visit_mut_with(phase, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ImportDecl {
    #[doc = "Calls [VisitMut`::visit_mut_import_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ImportDecl {
                span,
                specifiers,
                src,
                type_only,
                with,
                phase,
            } => {
                <Vec<ImportSpecifier> as VisitMutWith<V>>::visit_mut_with(specifiers, visitor);
                <Box<Str> as VisitMutWith<V>>::visit_mut_with(src, visitor);
                <Option<Box<ObjectLit>> as VisitMutWith<V>>::visit_mut_with(with, visitor);
                <ImportPhase as VisitMutWith<V>>::visit_mut_with(phase, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ImportDefaultSpecifier {
    #[doc = "Calls [VisitMut`::visit_mut_import_default_specifier`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import_default_specifier(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ImportDefaultSpecifier { span, local } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(local, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ImportNamedSpecifier {
    #[doc = "Calls [VisitMut`::visit_mut_import_named_specifier`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import_named_specifier(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ImportNamedSpecifier {
                span,
                local,
                imported,
                is_type_only,
            } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(local, visitor);
                <Option<ModuleExportName> as VisitMutWith<V>>::visit_mut_with(imported, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ImportPhase {
    #[doc = "Calls [VisitMut`::visit_mut_import_phase`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import_phase(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ImportPhase::Evaluation => {}
            ImportPhase::Source => {}
            ImportPhase::Defer => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ImportSpecifier {
    #[doc = "Calls [VisitMut`::visit_mut_import_specifier`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import_specifier(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ImportSpecifier::Named { 0: _field_0 } => {
                <ImportNamedSpecifier as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ImportSpecifier::Default { 0: _field_0 } => {
                <ImportDefaultSpecifier as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ImportSpecifier::Namespace { 0: _field_0 } => {
                <ImportStarAsSpecifier as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ImportStarAsSpecifier {
    #[doc = "Calls [VisitMut`::visit_mut_import_star_as_specifier`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import_star_as_specifier(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ImportStarAsSpecifier { span, local } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(local, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ImportWith {
    #[doc = "Calls [VisitMut`::visit_mut_import_with`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import_with(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ImportWith { span, values } => {
                <Vec<ImportWithItem> as VisitMutWith<V>>::visit_mut_with(values, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ImportWithItem {
    #[doc = "Calls [VisitMut`::visit_mut_import_with_item`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import_with_item(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ImportWithItem { key, value } => {
                <IdentName as VisitMutWith<V>>::visit_mut_with(key, visitor);
                <Str as VisitMutWith<V>>::visit_mut_with(value, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Invalid {
    #[doc = "Calls [VisitMut`::visit_mut_invalid`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_invalid(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Invalid { span } => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXAttr {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_attr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_attr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXAttr { span, name, value } => {
                <JSXAttrName as VisitMutWith<V>>::visit_mut_with(name, visitor);
                <Option<JSXAttrValue> as VisitMutWith<V>>::visit_mut_with(value, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXAttrName {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_attr_name`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_attr_name(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXAttrName::Ident { 0: _field_0 } => {
                <IdentName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXAttrName::JSXNamespacedName { 0: _field_0 } => {
                <JSXNamespacedName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXAttrOrSpread {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_attr_or_spread`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_attr_or_spread(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXAttrOrSpread::JSXAttr { 0: _field_0 } => {
                <JSXAttr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXAttrOrSpread::SpreadElement { 0: _field_0 } => {
                <SpreadElement as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXAttrValue {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_attr_value`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_attr_value(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXAttrValue::Lit { 0: _field_0 } => {
                <Lit as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXAttrValue::JSXExprContainer { 0: _field_0 } => {
                <JSXExprContainer as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXAttrValue::JSXElement { 0: _field_0 } => {
                <Box<JSXElement> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXAttrValue::JSXFragment { 0: _field_0 } => {
                <JSXFragment as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXClosingElement {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_closing_element`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_closing_element(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXClosingElement { span, name } => {
                <JSXElementName as VisitMutWith<V>>::visit_mut_with(name, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXClosingFragment {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_closing_fragment`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_closing_fragment(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXClosingFragment { span } => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXElement {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_element`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_element(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXElement {
                span,
                opening,
                children,
                closing,
            } => {
                <JSXOpeningElement as VisitMutWith<V>>::visit_mut_with(opening, visitor);
                <Vec<JSXElementChild> as VisitMutWith<V>>::visit_mut_with(children, visitor);
                <Option<JSXClosingElement> as VisitMutWith<V>>::visit_mut_with(closing, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXElementChild {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_element_child`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_element_child(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXElementChild::JSXText { 0: _field_0 } => {
                <JSXText as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXElementChild::JSXExprContainer { 0: _field_0 } => {
                <JSXExprContainer as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXElementChild::JSXSpreadChild { 0: _field_0 } => {
                <JSXSpreadChild as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXElementChild::JSXElement { 0: _field_0 } => {
                <Box<JSXElement> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXElementChild::JSXFragment { 0: _field_0 } => {
                <JSXFragment as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXElementName {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_element_name`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_element_name(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXElementName::Ident { 0: _field_0 } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXElementName::JSXMemberExpr { 0: _field_0 } => {
                <JSXMemberExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXElementName::JSXNamespacedName { 0: _field_0 } => {
                <JSXNamespacedName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXEmptyExpr {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_empty_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_empty_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXEmptyExpr { span } => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXExpr {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXExpr::JSXEmptyExpr { 0: _field_0 } => {
                <JSXEmptyExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXExpr::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXExprContainer {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_expr_container`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_expr_container(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXExprContainer { span, expr } => {
                <JSXExpr as VisitMutWith<V>>::visit_mut_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXFragment {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_fragment`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_fragment(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXFragment {
                span,
                opening,
                children,
                closing,
            } => {
                <JSXOpeningFragment as VisitMutWith<V>>::visit_mut_with(opening, visitor);
                <Vec<JSXElementChild> as VisitMutWith<V>>::visit_mut_with(children, visitor);
                <JSXClosingFragment as VisitMutWith<V>>::visit_mut_with(closing, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXMemberExpr {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_member_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_member_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXMemberExpr { span, obj, prop } => {
                <JSXObject as VisitMutWith<V>>::visit_mut_with(obj, visitor);
                <IdentName as VisitMutWith<V>>::visit_mut_with(prop, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXNamespacedName {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_namespaced_name`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_namespaced_name(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXNamespacedName { span, ns, name } => {
                <IdentName as VisitMutWith<V>>::visit_mut_with(ns, visitor);
                <IdentName as VisitMutWith<V>>::visit_mut_with(name, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXObject {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_object`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_object(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXObject::JSXMemberExpr { 0: _field_0 } => {
                <Box<JSXMemberExpr> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            JSXObject::Ident { 0: _field_0 } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXOpeningElement {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_opening_element`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_opening_element(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXOpeningElement {
                name,
                span,
                attrs,
                self_closing,
                type_args,
            } => {
                <JSXElementName as VisitMutWith<V>>::visit_mut_with(name, visitor);
                <Vec<JSXAttrOrSpread> as VisitMutWith<V>>::visit_mut_with(attrs, visitor);
                <Option<Box<TsTypeParamInstantiation>> as VisitMutWith<V>>::visit_mut_with(
                    type_args, visitor,
                );
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXOpeningFragment {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_opening_fragment`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_opening_fragment(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXOpeningFragment { span } => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXSpreadChild {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_spread_child`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_spread_child(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXSpreadChild { span, expr } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for JSXText {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_text`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_text(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            JSXText { span, value, raw } => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Key {
    #[doc = "Calls [VisitMut`::visit_mut_key`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_key(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Key::Private { 0: _field_0 } => {
                <PrivateName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Key::Public { 0: _field_0 } => {
                <PropName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for KeyValuePatProp {
    #[doc = "Calls [VisitMut`::visit_mut_key_value_pat_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_key_value_pat_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            KeyValuePatProp { key, value } => {
                <PropName as VisitMutWith<V>>::visit_mut_with(key, visitor);
                <Box<Pat> as VisitMutWith<V>>::visit_mut_with(value, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for KeyValueProp {
    #[doc = "Calls [VisitMut`::visit_mut_key_value_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_key_value_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            KeyValueProp { key, value } => {
                <PropName as VisitMutWith<V>>::visit_mut_with(key, visitor);
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(value, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for LabeledStmt {
    #[doc = "Calls [VisitMut`::visit_mut_labeled_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_labeled_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            LabeledStmt { span, label, body } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(label, visitor);
                <Box<Stmt> as VisitMutWith<V>>::visit_mut_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Lit {
    #[doc = "Calls [VisitMut`::visit_mut_lit`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_lit(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Lit::Str { 0: _field_0 } => {
                <Str as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Lit::Bool { 0: _field_0 } => {
                <Bool as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Lit::Null { 0: _field_0 } => {
                <Null as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Lit::Num { 0: _field_0 } => {
                <Number as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Lit::BigInt { 0: _field_0 } => {
                <BigInt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Lit::Regex { 0: _field_0 } => {
                <Regex as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Lit::JSXText { 0: _field_0 } => {
                <JSXText as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for MemberExpr {
    #[doc = "Calls [VisitMut`::visit_mut_member_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_member_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            MemberExpr { span, obj, prop } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(obj, visitor);
                <MemberProp as VisitMutWith<V>>::visit_mut_with(prop, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for MemberProp {
    #[doc = "Calls [VisitMut`::visit_mut_member_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_member_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            MemberProp::Ident { 0: _field_0 } => {
                <IdentName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            MemberProp::PrivateName { 0: _field_0 } => {
                <PrivateName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            MemberProp::Computed { 0: _field_0 } => {
                <ComputedPropName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for MetaPropExpr {
    #[doc = "Calls [VisitMut`::visit_mut_meta_prop_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_meta_prop_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            MetaPropExpr { span, kind } => {
                <MetaPropKind as VisitMutWith<V>>::visit_mut_with(kind, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for MetaPropKind {
    #[doc = "Calls [VisitMut`::visit_mut_meta_prop_kind`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_meta_prop_kind(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            MetaPropKind::NewTarget => {}
            MetaPropKind::ImportMeta => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for MethodKind {
    #[doc = "Calls [VisitMut`::visit_mut_method_kind`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_method_kind(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            MethodKind::Method => {}
            MethodKind::Getter => {}
            MethodKind::Setter => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for MethodProp {
    #[doc = "Calls [VisitMut`::visit_mut_method_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_method_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            MethodProp { key, function } => {
                <PropName as VisitMutWith<V>>::visit_mut_with(key, visitor);
                <Box<Function> as VisitMutWith<V>>::visit_mut_with(function, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Module {
    #[doc = "Calls [VisitMut`::visit_mut_module`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_module(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Module {
                span,
                body,
                shebang,
            } => {
                <Vec<ModuleItem> as VisitMutWith<V>>::visit_mut_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ModuleDecl {
    #[doc = "Calls [VisitMut`::visit_mut_module_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_module_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ModuleDecl::Import { 0: _field_0 } => {
                <ImportDecl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ModuleDecl::ExportDecl { 0: _field_0 } => {
                <ExportDecl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ModuleDecl::ExportNamed { 0: _field_0 } => {
                <NamedExport as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ModuleDecl::ExportDefaultDecl { 0: _field_0 } => {
                <ExportDefaultDecl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ModuleDecl::ExportDefaultExpr { 0: _field_0 } => {
                <ExportDefaultExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ModuleDecl::ExportAll { 0: _field_0 } => {
                <ExportAll as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ModuleDecl::TsImportEquals { 0: _field_0 } => {
                <Box<TsImportEqualsDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ModuleDecl::TsExportAssignment { 0: _field_0 } => {
                <TsExportAssignment as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ModuleDecl::TsNamespaceExport { 0: _field_0 } => {
                <TsNamespaceExportDecl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ModuleExportName {
    #[doc = "Calls [VisitMut`::visit_mut_module_export_name`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_module_export_name(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ModuleExportName::Ident { 0: _field_0 } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ModuleExportName::Str { 0: _field_0 } => {
                <Str as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ModuleItem {
    #[doc = "Calls [VisitMut`::visit_mut_module_item`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_module_item(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ModuleItem::ModuleDecl { 0: _field_0 } => {
                <ModuleDecl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ModuleItem::Stmt { 0: _field_0 } => {
                <Stmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for NamedExport {
    #[doc = "Calls [VisitMut`::visit_mut_named_export`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_named_export(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            NamedExport {
                span,
                specifiers,
                src,
                type_only,
                with,
            } => {
                <Vec<ExportSpecifier> as VisitMutWith<V>>::visit_mut_with(specifiers, visitor);
                <Option<Box<Str>> as VisitMutWith<V>>::visit_mut_with(src, visitor);
                <Option<Box<ObjectLit>> as VisitMutWith<V>>::visit_mut_with(with, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for NewExpr {
    #[doc = "Calls [VisitMut`::visit_mut_new_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_new_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            NewExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(callee, visitor);
                <Option<Vec<ExprOrSpread>> as VisitMutWith<V>>::visit_mut_with(args, visitor);
                <Option<Box<TsTypeParamInstantiation>> as VisitMutWith<V>>::visit_mut_with(
                    type_args, visitor,
                );
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Null {
    #[doc = "Calls [VisitMut`::visit_mut_null`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_null(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Null { span } => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Number {
    #[doc = "Calls [VisitMut`::visit_mut_number`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_number(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Number { span, value, raw } => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ObjectLit {
    #[doc = "Calls [VisitMut`::visit_mut_object_lit`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_object_lit(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ObjectLit { span, props } => {
                <Vec<PropOrSpread> as VisitMutWith<V>>::visit_mut_with(props, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ObjectPat {
    #[doc = "Calls [VisitMut`::visit_mut_object_pat`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_object_pat(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ObjectPat {
                span,
                props,
                optional,
                type_ann,
            } => {
                <Vec<ObjectPatProp> as VisitMutWith<V>>::visit_mut_with(props, visitor);
                <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ObjectPatProp {
    #[doc = "Calls [VisitMut`::visit_mut_object_pat_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_object_pat_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ObjectPatProp::KeyValue { 0: _field_0 } => {
                <KeyValuePatProp as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ObjectPatProp::Assign { 0: _field_0 } => {
                <AssignPatProp as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ObjectPatProp::Rest { 0: _field_0 } => {
                <RestPat as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for OptCall {
    #[doc = "Calls [VisitMut`::visit_mut_opt_call`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_call(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            OptCall {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(callee, visitor);
                <Vec<ExprOrSpread> as VisitMutWith<V>>::visit_mut_with(args, visitor);
                <Option<Box<TsTypeParamInstantiation>> as VisitMutWith<V>>::visit_mut_with(
                    type_args, visitor,
                );
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for OptChainBase {
    #[doc = "Calls [VisitMut`::visit_mut_opt_chain_base`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_chain_base(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            OptChainBase::Member { 0: _field_0 } => {
                <MemberExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            OptChainBase::Call { 0: _field_0 } => {
                <OptCall as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for OptChainExpr {
    #[doc = "Calls [VisitMut`::visit_mut_opt_chain_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_chain_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            OptChainExpr {
                span,
                optional,
                base,
            } => {
                <Box<OptChainBase> as VisitMutWith<V>>::visit_mut_with(base, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Param {
    #[doc = "Calls [VisitMut`::visit_mut_param`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_param(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Param {
                span,
                decorators,
                pat,
            } => {
                <Vec<Decorator> as VisitMutWith<V>>::visit_mut_with(decorators, visitor);
                <Pat as VisitMutWith<V>>::visit_mut_with(pat, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ParamOrTsParamProp {
    #[doc = "Calls [VisitMut`::visit_mut_param_or_ts_param_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_param_or_ts_param_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ParamOrTsParamProp::TsParamProp { 0: _field_0 } => {
                <TsParamProp as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            ParamOrTsParamProp::Param { 0: _field_0 } => {
                <Param as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ParenExpr {
    #[doc = "Calls [VisitMut`::visit_mut_paren_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_paren_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ParenExpr { span, expr } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Pat {
    #[doc = "Calls [VisitMut`::visit_mut_pat`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_pat(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Pat::Ident { 0: _field_0 } => {
                <BindingIdent as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Pat::Array { 0: _field_0 } => {
                <ArrayPat as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Pat::Rest { 0: _field_0 } => {
                <RestPat as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Pat::Object { 0: _field_0 } => {
                <ObjectPat as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Pat::Assign { 0: _field_0 } => {
                <AssignPat as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Pat::Invalid { 0: _field_0 } => {
                <Invalid as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Pat::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for PrivateName {
    #[doc = "Calls [VisitMut`::visit_mut_private_name`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_private_name(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            PrivateName { span, name } => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for PrivateProp {
    #[doc = "Calls [VisitMut`::visit_mut_private_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_private_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            PrivateProp {
                span,
                ctxt,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_optional,
                is_override,
                readonly,
                definite,
            } => {
                <PrivateName as VisitMutWith<V>>::visit_mut_with(key, visitor);
                <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(value, visitor);
                <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
                <Vec<Decorator> as VisitMutWith<V>>::visit_mut_with(decorators, visitor);
                <Option<Accessibility> as VisitMutWith<V>>::visit_mut_with(accessibility, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Program {
    #[doc = "Calls [VisitMut`::visit_mut_program`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_program(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Program::Module { 0: _field_0 } => {
                <Module as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Program::Script { 0: _field_0 } => {
                <Script as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Prop {
    #[doc = "Calls [VisitMut`::visit_mut_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Prop::Shorthand { 0: _field_0 } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Prop::KeyValue { 0: _field_0 } => {
                <KeyValueProp as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Prop::Assign { 0: _field_0 } => {
                <AssignProp as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Prop::Getter { 0: _field_0 } => {
                <GetterProp as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Prop::Setter { 0: _field_0 } => {
                <SetterProp as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Prop::Method { 0: _field_0 } => {
                <MethodProp as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for PropName {
    #[doc = "Calls [VisitMut`::visit_mut_prop_name`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_prop_name(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            PropName::Ident { 0: _field_0 } => {
                <IdentName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            PropName::Str { 0: _field_0 } => {
                <Str as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            PropName::Num { 0: _field_0 } => {
                <Number as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            PropName::Computed { 0: _field_0 } => {
                <ComputedPropName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            PropName::BigInt { 0: _field_0 } => {
                <BigInt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for PropOrSpread {
    #[doc = "Calls [VisitMut`::visit_mut_prop_or_spread`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_prop_or_spread(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            PropOrSpread::Spread { 0: _field_0 } => {
                <SpreadElement as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            PropOrSpread::Prop { 0: _field_0 } => {
                <Box<Prop> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Regex {
    #[doc = "Calls [VisitMut`::visit_mut_regex`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_regex(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Regex { span, exp, flags } => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ReservedUnused {
    #[doc = "Calls [VisitMut`::visit_mut_reserved_unused`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_reserved_unused(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ReservedUnused { span, body } => {
                <Option<Vec<ModuleItem>> as VisitMutWith<V>>::visit_mut_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for RestPat {
    #[doc = "Calls [VisitMut`::visit_mut_rest_pat`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_rest_pat(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            RestPat {
                span,
                dot3_token,
                arg,
                type_ann,
            } => {
                <Box<Pat> as VisitMutWith<V>>::visit_mut_with(arg, visitor);
                <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ReturnStmt {
    #[doc = "Calls [VisitMut`::visit_mut_return_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_return_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ReturnStmt { span, arg } => {
                <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(arg, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Script {
    #[doc = "Calls [VisitMut`::visit_mut_script`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_script(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Script {
                span,
                body,
                shebang,
            } => {
                <Vec<Stmt> as VisitMutWith<V>>::visit_mut_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for SeqExpr {
    #[doc = "Calls [VisitMut`::visit_mut_seq_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_seq_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            SeqExpr { span, exprs } => {
                <Vec<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(exprs, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for SetterProp {
    #[doc = "Calls [VisitMut`::visit_mut_setter_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_setter_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            SetterProp {
                span,
                key,
                this_param,
                param,
                body,
            } => {
                <PropName as VisitMutWith<V>>::visit_mut_with(key, visitor);
                <Option<Pat> as VisitMutWith<V>>::visit_mut_with(this_param, visitor);
                <Box<Pat> as VisitMutWith<V>>::visit_mut_with(param, visitor);
                <Option<BlockStmt> as VisitMutWith<V>>::visit_mut_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for SimpleAssignTarget {
    #[doc = "Calls [VisitMut`::visit_mut_simple_assign_target`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_simple_assign_target(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            SimpleAssignTarget::Ident { 0: _field_0 } => {
                <BindingIdent as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SimpleAssignTarget::Member { 0: _field_0 } => {
                <MemberExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SimpleAssignTarget::SuperProp { 0: _field_0 } => {
                <SuperPropExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SimpleAssignTarget::Paren { 0: _field_0 } => {
                <ParenExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SimpleAssignTarget::OptChain { 0: _field_0 } => {
                <OptChainExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SimpleAssignTarget::TsAs { 0: _field_0 } => {
                <TsAsExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SimpleAssignTarget::TsSatisfies { 0: _field_0 } => {
                <TsSatisfiesExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SimpleAssignTarget::TsNonNull { 0: _field_0 } => {
                <TsNonNullExpr as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SimpleAssignTarget::TsTypeAssertion { 0: _field_0 } => {
                <TsTypeAssertion as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SimpleAssignTarget::TsInstantiation { 0: _field_0 } => {
                <TsInstantiation as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SimpleAssignTarget::Invalid { 0: _field_0 } => {
                <Invalid as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for SpreadElement {
    #[doc = "Calls [VisitMut`::visit_mut_spread_element`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_spread_element(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            SpreadElement { dot3_token, expr } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for StaticBlock {
    #[doc = "Calls [VisitMut`::visit_mut_static_block`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_static_block(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            StaticBlock { span, body } => {
                <BlockStmt as VisitMutWith<V>>::visit_mut_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Stmt {
    #[doc = "Calls [VisitMut`::visit_mut_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Stmt::Block { 0: _field_0 } => {
                <BlockStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Empty { 0: _field_0 } => {
                <EmptyStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Debugger { 0: _field_0 } => {
                <DebuggerStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::With { 0: _field_0 } => {
                <WithStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Return { 0: _field_0 } => {
                <ReturnStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Labeled { 0: _field_0 } => {
                <LabeledStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Break { 0: _field_0 } => {
                <BreakStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Continue { 0: _field_0 } => {
                <ContinueStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::If { 0: _field_0 } => {
                <IfStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Switch { 0: _field_0 } => {
                <SwitchStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Throw { 0: _field_0 } => {
                <ThrowStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Try { 0: _field_0 } => {
                <Box<TryStmt> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::While { 0: _field_0 } => {
                <WhileStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::DoWhile { 0: _field_0 } => {
                <DoWhileStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::For { 0: _field_0 } => {
                <ForStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::ForIn { 0: _field_0 } => {
                <ForInStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::ForOf { 0: _field_0 } => {
                <ForOfStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Decl { 0: _field_0 } => {
                <Decl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            Stmt::Expr { 0: _field_0 } => {
                <ExprStmt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Str {
    #[doc = "Calls [VisitMut`::visit_mut_str`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_str(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Str { span, value, raw } => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Super {
    #[doc = "Calls [VisitMut`::visit_mut_super`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_super(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Super { span } => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for SuperProp {
    #[doc = "Calls [VisitMut`::visit_mut_super_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_super_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            SuperProp::Ident { 0: _field_0 } => {
                <IdentName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            SuperProp::Computed { 0: _field_0 } => {
                <ComputedPropName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for SuperPropExpr {
    #[doc = "Calls [VisitMut`::visit_mut_super_prop_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_super_prop_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            SuperPropExpr { span, obj, prop } => {
                <Super as VisitMutWith<V>>::visit_mut_with(obj, visitor);
                <SuperProp as VisitMutWith<V>>::visit_mut_with(prop, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for SwitchCase {
    #[doc = "Calls [VisitMut`::visit_mut_switch_case`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_switch_case(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            SwitchCase { span, test, cons } => {
                <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(test, visitor);
                <Vec<Stmt> as VisitMutWith<V>>::visit_mut_with(cons, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for SwitchStmt {
    #[doc = "Calls [VisitMut`::visit_mut_switch_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_switch_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            SwitchStmt {
                span,
                discriminant,
                cases,
            } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(discriminant, visitor);
                <Vec<SwitchCase> as VisitMutWith<V>>::visit_mut_with(cases, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TaggedTpl {
    #[doc = "Calls [VisitMut`::visit_mut_tagged_tpl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_tagged_tpl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TaggedTpl {
                span,
                ctxt,
                tag,
                type_params,
                tpl,
            } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(tag, visitor);
                <Option<Box<TsTypeParamInstantiation>> as VisitMutWith<V>>::visit_mut_with(
                    type_params,
                    visitor,
                );
                <Box<Tpl> as VisitMutWith<V>>::visit_mut_with(tpl, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ThisExpr {
    #[doc = "Calls [VisitMut`::visit_mut_this_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_this_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ThisExpr { span } => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ThrowStmt {
    #[doc = "Calls [VisitMut`::visit_mut_throw_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_throw_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            ThrowStmt { span, arg } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(arg, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Tpl {
    #[doc = "Calls [VisitMut`::visit_mut_tpl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_tpl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Tpl {
                span,
                exprs,
                quasis,
            } => {
                <Vec<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(exprs, visitor);
                <Vec<TplElement> as VisitMutWith<V>>::visit_mut_with(quasis, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TplElement {
    #[doc = "Calls [VisitMut`::visit_mut_tpl_element`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_tpl_element(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TplElement {
                span,
                tail,
                cooked,
                raw,
            } => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TruePlusMinus {
    #[doc = "Calls [VisitMut`::visit_mut_true_plus_minus`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_true_plus_minus(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TruePlusMinus::True => {}
            TruePlusMinus::Plus => {}
            TruePlusMinus::Minus => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TryStmt {
    #[doc = "Calls [VisitMut`::visit_mut_try_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_try_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TryStmt {
                span,
                block,
                handler,
                finalizer,
            } => {
                <BlockStmt as VisitMutWith<V>>::visit_mut_with(block, visitor);
                <Option<CatchClause> as VisitMutWith<V>>::visit_mut_with(handler, visitor);
                <Option<BlockStmt> as VisitMutWith<V>>::visit_mut_with(finalizer, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsArrayType {
    #[doc = "Calls [VisitMut`::visit_mut_ts_array_type`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_array_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsArrayType { span, elem_type } => {
                <Box<TsType> as VisitMutWith<V>>::visit_mut_with(elem_type, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsAsExpr {
    #[doc = "Calls [VisitMut`::visit_mut_ts_as_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_as_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsAsExpr {
                span,
                expr,
                type_ann,
            } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor);
                <Box<TsType> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsCallSignatureDecl {
    #[doc = "Calls [VisitMut`::visit_mut_ts_call_signature_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_call_signature_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsCallSignatureDecl {
                span,
                params,
                type_ann,
                type_params,
            } => {
                <Vec<TsFnParam> as VisitMutWith<V>>::visit_mut_with(params, visitor);
                <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
                <Option<Box<TsTypeParamDecl>> as VisitMutWith<V>>::visit_mut_with(
                    type_params,
                    visitor,
                );
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsConditionalType {
    #[doc = "Calls [VisitMut`::visit_mut_ts_conditional_type`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_conditional_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsConditionalType {
                span,
                check_type,
                extends_type,
                true_type,
                false_type,
            } => {
                <Box<TsType> as VisitMutWith<V>>::visit_mut_with(check_type, visitor);
                <Box<TsType> as VisitMutWith<V>>::visit_mut_with(extends_type, visitor);
                <Box<TsType> as VisitMutWith<V>>::visit_mut_with(true_type, visitor);
                <Box<TsType> as VisitMutWith<V>>::visit_mut_with(false_type, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsConstAssertion {
    #[doc = "Calls [VisitMut`::visit_mut_ts_const_assertion`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_const_assertion(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsConstAssertion { span, expr } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsConstructSignatureDecl {
    #[doc = "Calls [VisitMut`::visit_mut_ts_construct_signature_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_construct_signature_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsConstructSignatureDecl {
                span,
                params,
                type_ann,
                type_params,
            } => {
                <Vec<TsFnParam> as VisitMutWith<V>>::visit_mut_with(params, visitor);
                <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
                <Option<Box<TsTypeParamDecl>> as VisitMutWith<V>>::visit_mut_with(
                    type_params,
                    visitor,
                );
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsConstructorType {
    #[doc = "Calls [VisitMut`::visit_mut_ts_constructor_type`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_constructor_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsConstructorType {
                span,
                params,
                type_params,
                type_ann,
                is_abstract,
            } => {
                <Vec<TsFnParam> as VisitMutWith<V>>::visit_mut_with(params, visitor);
                <Option<Box<TsTypeParamDecl>> as VisitMutWith<V>>::visit_mut_with(
                    type_params,
                    visitor,
                );
                <Box<TsTypeAnn> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsEntityName {
    #[doc = "Calls [VisitMut`::visit_mut_ts_entity_name`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_entity_name(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsEntityName::TsQualifiedName { 0: _field_0 } => {
                <Box<TsQualifiedName> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsEntityName::Ident { 0: _field_0 } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsEnumDecl {
    #[doc = "Calls [VisitMut`::visit_mut_ts_enum_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_enum_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsEnumDecl {
                span,
                declare,
                is_const,
                id,
                members,
            } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(id, visitor);
                <Vec<TsEnumMember> as VisitMutWith<V>>::visit_mut_with(members, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsEnumMember {
    #[doc = "Calls [VisitMut`::visit_mut_ts_enum_member`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_enum_member(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsEnumMember { span, id, init } => {
                <TsEnumMemberId as VisitMutWith<V>>::visit_mut_with(id, visitor);
                <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(init, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsEnumMemberId {
    #[doc = "Calls [VisitMut`::visit_mut_ts_enum_member_id`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_enum_member_id(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsEnumMemberId::Ident { 0: _field_0 } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsEnumMemberId::Str { 0: _field_0 } => {
                <Str as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsExportAssignment {
    #[doc = "Calls [VisitMut`::visit_mut_ts_export_assignment`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_export_assignment(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsExportAssignment { span, expr } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsExprWithTypeArgs {
    #[doc = "Calls [VisitMut`::visit_mut_ts_expr_with_type_args`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_expr_with_type_args(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsExprWithTypeArgs {
                span,
                expr,
                type_args,
            } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor);
                <Option<Box<TsTypeParamInstantiation>> as VisitMutWith<V>>::visit_mut_with(
                    type_args, visitor,
                );
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsExternalModuleRef {
    #[doc = "Calls [VisitMut`::visit_mut_ts_external_module_ref`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_external_module_ref(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsExternalModuleRef { span, expr } => {
                <Str as VisitMutWith<V>>::visit_mut_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsFnOrConstructorType {
    #[doc = "Calls [VisitMut`::visit_mut_ts_fn_or_constructor_type`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_fn_or_constructor_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsFnOrConstructorType::TsFnType { 0: _field_0 } => {
                <TsFnType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsFnOrConstructorType::TsConstructorType { 0: _field_0 } => {
                <TsConstructorType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsFnParam {
    #[doc = "Calls [VisitMut`::visit_mut_ts_fn_param`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_fn_param(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsFnParam::Ident { 0: _field_0 } => {
                <BindingIdent as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsFnParam::Array { 0: _field_0 } => {
                <ArrayPat as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsFnParam::Rest { 0: _field_0 } => {
                <RestPat as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsFnParam::Object { 0: _field_0 } => {
                <ObjectPat as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsFnType {
    #[doc = "Calls [VisitMut`::visit_mut_ts_fn_type`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_fn_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsFnType {
                span,
                params,
                type_params,
                type_ann,
            } => {
                <Vec<TsFnParam> as VisitMutWith<V>>::visit_mut_with(params, visitor);
                <Option<Box<TsTypeParamDecl>> as VisitMutWith<V>>::visit_mut_with(
                    type_params,
                    visitor,
                );
                <Box<TsTypeAnn> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsGetterSignature {
    #[doc = "Calls [VisitMut`::visit_mut_ts_getter_signature`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_getter_signature(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsGetterSignature {
                span,
                key,
                computed,
                type_ann,
            } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(key, visitor);
                <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsImportEqualsDecl {
    #[doc = "Calls [VisitMut`::visit_mut_ts_import_equals_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_import_equals_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsImportEqualsDecl {
                span,
                is_export,
                is_type_only,
                id,
                module_ref,
            } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(id, visitor);
                <TsModuleRef as VisitMutWith<V>>::visit_mut_with(module_ref, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsImportType {
    #[doc = "Calls [VisitMut`::visit_mut_ts_import_type`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_import_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsImportType {
                span,
                arg,
                qualifier,
                type_args,
            } => {
                <Str as VisitMutWith<V>>::visit_mut_with(arg, visitor);
                <Option<TsEntityName> as VisitMutWith<V>>::visit_mut_with(qualifier, visitor);
                <Option<Box<TsTypeParamInstantiation>> as VisitMutWith<V>>::visit_mut_with(
                    type_args, visitor,
                );
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsIndexSignature {
    #[doc = "Calls [VisitMut`::visit_mut_ts_index_signature`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_index_signature(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsIndexSignature {
                params,
                type_ann,
                readonly,
                is_static,
                span,
            } => {
                <Vec<TsFnParam> as VisitMutWith<V>>::visit_mut_with(params, visitor);
                <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsIndexedAccessType {
    #[doc = "Calls [VisitMut`::visit_mut_ts_indexed_access_type`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_indexed_access_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsIndexedAccessType {
                span,
                readonly,
                obj_type,
                index_type,
            } => {
                <Box<TsType> as VisitMutWith<V>>::visit_mut_with(obj_type, visitor);
                <Box<TsType> as VisitMutWith<V>>::visit_mut_with(index_type, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsInferType {
    #[doc = "Calls [VisitMut`::visit_mut_ts_infer_type`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_infer_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsInferType { span, type_param } => {
                <TsTypeParam as VisitMutWith<V>>::visit_mut_with(type_param, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsInstantiation {
    #[doc = "Calls [VisitMut`::visit_mut_ts_instantiation`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_instantiation(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsInstantiation {
                span,
                expr,
                type_args,
            } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor);
                <Box<TsTypeParamInstantiation> as VisitMutWith<V>>::visit_mut_with(
                    type_args, visitor,
                );
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsInterfaceBody {
    #[doc = "Calls [VisitMut`::visit_mut_ts_interface_body`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_interface_body(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsInterfaceBody { span, body } => {
                <Vec<TsTypeElement> as VisitMutWith<V>>::visit_mut_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsInterfaceDecl {
    #[doc = "Calls [VisitMut`::visit_mut_ts_interface_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_interface_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsInterfaceDecl {
                span,
                id,
                declare,
                type_params,
                extends,
                body,
            } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(id, visitor);
                <Option<Box<TsTypeParamDecl>> as VisitMutWith<V>>::visit_mut_with(
                    type_params,
                    visitor,
                );
                <Vec<TsExprWithTypeArgs> as VisitMutWith<V>>::visit_mut_with(extends, visitor);
                <TsInterfaceBody as VisitMutWith<V>>::visit_mut_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsIntersectionType {
    #[doc = "Calls [VisitMut`::visit_mut_ts_intersection_type`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_intersection_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsIntersectionType { span, types } => {
                <Vec<Box<TsType>> as VisitMutWith<V>>::visit_mut_with(types, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsKeywordType {
    #[doc = "Calls [VisitMut`::visit_mut_ts_keyword_type`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_keyword_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsKeywordType { span, kind } => {
                <TsKeywordTypeKind as VisitMutWith<V>>::visit_mut_with(kind, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsKeywordTypeKind {
    #[doc = "Calls [VisitMut`::visit_mut_ts_keyword_type_kind`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_keyword_type_kind(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsKeywordTypeKind::TsAnyKeyword => {}
            TsKeywordTypeKind::TsUnknownKeyword => {}
            TsKeywordTypeKind::TsNumberKeyword => {}
            TsKeywordTypeKind::TsObjectKeyword => {}
            TsKeywordTypeKind::TsBooleanKeyword => {}
            TsKeywordTypeKind::TsBigIntKeyword => {}
            TsKeywordTypeKind::TsStringKeyword => {}
            TsKeywordTypeKind::TsSymbolKeyword => {}
            TsKeywordTypeKind::TsVoidKeyword => {}
            TsKeywordTypeKind::TsUndefinedKeyword => {}
            TsKeywordTypeKind::TsNullKeyword => {}
            TsKeywordTypeKind::TsNeverKeyword => {}
            TsKeywordTypeKind::TsIntrinsicKeyword => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsLit {
    #[doc = "Calls [VisitMut`::visit_mut_ts_lit`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_lit(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsLit::Number { 0: _field_0 } => {
                <Number as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsLit::Str { 0: _field_0 } => {
                <Str as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsLit::Bool { 0: _field_0 } => {
                <Bool as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsLit::BigInt { 0: _field_0 } => {
                <BigInt as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsLit::Tpl { 0: _field_0 } => {
                <TsTplLitType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsLitType {
    #[doc = "Calls [VisitMut`::visit_mut_ts_lit_type`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_lit_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsLitType { span, lit } => {
                <TsLit as VisitMutWith<V>>::visit_mut_with(lit, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsMappedType {
    #[doc = "Calls [VisitMut`::visit_mut_ts_mapped_type`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_mapped_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsMappedType {
                span,
                readonly,
                type_param,
                name_type,
                optional,
                type_ann,
            } => {
                <Option<TruePlusMinus> as VisitMutWith<V>>::visit_mut_with(readonly, visitor);
                <TsTypeParam as VisitMutWith<V>>::visit_mut_with(type_param, visitor);
                <Option<Box<TsType>> as VisitMutWith<V>>::visit_mut_with(name_type, visitor);
                <Option<TruePlusMinus> as VisitMutWith<V>>::visit_mut_with(optional, visitor);
                <Option<Box<TsType>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsMethodSignature {
    #[doc = "Calls [VisitMut`::visit_mut_ts_method_signature`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_method_signature(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsMethodSignature {
                span,
                key,
                computed,
                optional,
                params,
                type_ann,
                type_params,
            } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(key, visitor);
                <Vec<TsFnParam> as VisitMutWith<V>>::visit_mut_with(params, visitor);
                <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
                <Option<Box<TsTypeParamDecl>> as VisitMutWith<V>>::visit_mut_with(
                    type_params,
                    visitor,
                );
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsModuleBlock {
    #[doc = "Calls [VisitMut`::visit_mut_ts_module_block`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_module_block(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsModuleBlock { span, body } => {
                <Vec<ModuleItem> as VisitMutWith<V>>::visit_mut_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsModuleDecl {
    #[doc = "Calls [VisitMut`::visit_mut_ts_module_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_module_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsModuleDecl {
                span,
                declare,
                global,
                id,
                body,
            } => {
                <TsModuleName as VisitMutWith<V>>::visit_mut_with(id, visitor);
                <Option<TsNamespaceBody> as VisitMutWith<V>>::visit_mut_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsModuleName {
    #[doc = "Calls [VisitMut`::visit_mut_ts_module_name`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_module_name(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsModuleName::Ident { 0: _field_0 } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsModuleName::Str { 0: _field_0 } => {
                <Str as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsModuleRef {
    #[doc = "Calls [VisitMut`::visit_mut_ts_module_ref`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_module_ref(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsModuleRef::TsEntityName { 0: _field_0 } => {
                <TsEntityName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsModuleRef::TsExternalModuleRef { 0: _field_0 } => {
                <TsExternalModuleRef as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsNamespaceBody {
    #[doc = "Calls [VisitMut`::visit_mut_ts_namespace_body`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_namespace_body(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsNamespaceBody::TsModuleBlock { 0: _field_0 } => {
                <TsModuleBlock as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsNamespaceBody::TsNamespaceDecl { 0: _field_0 } => {
                <TsNamespaceDecl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsNamespaceDecl {
    #[doc = "Calls [VisitMut`::visit_mut_ts_namespace_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_namespace_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsNamespaceDecl {
                span,
                declare,
                global,
                id,
                body,
            } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(id, visitor);
                <Box<TsNamespaceBody> as VisitMutWith<V>>::visit_mut_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsNamespaceExportDecl {
    #[doc = "Calls [VisitMut`::visit_mut_ts_namespace_export_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_namespace_export_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsNamespaceExportDecl { span, id } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(id, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsNonNullExpr {
    #[doc = "Calls [VisitMut`::visit_mut_ts_non_null_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_non_null_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsNonNullExpr { span, expr } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsOptionalType {
    #[doc = "Calls [VisitMut`::visit_mut_ts_optional_type`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_optional_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsOptionalType { span, type_ann } => {
                <Box<TsType> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsParamProp {
    #[doc = "Calls [VisitMut`::visit_mut_ts_param_prop`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_param_prop(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsParamProp {
                span,
                decorators,
                accessibility,
                is_override,
                readonly,
                param,
            } => {
                <Vec<Decorator> as VisitMutWith<V>>::visit_mut_with(decorators, visitor);
                <Option<Accessibility> as VisitMutWith<V>>::visit_mut_with(accessibility, visitor);
                <TsParamPropParam as VisitMutWith<V>>::visit_mut_with(param, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsParamPropParam {
    #[doc = "Calls [VisitMut`::visit_mut_ts_param_prop_param`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_param_prop_param(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsParamPropParam::Ident { 0: _field_0 } => {
                <BindingIdent as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsParamPropParam::Assign { 0: _field_0 } => {
                <AssignPat as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsParenthesizedType {
    #[doc = "Calls [VisitMut`::visit_mut_ts_parenthesized_type`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_parenthesized_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsParenthesizedType { span, type_ann } => {
                <Box<TsType> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsPropertySignature {
    #[doc = "Calls [VisitMut`::visit_mut_ts_property_signature`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_property_signature(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsPropertySignature {
                span,
                readonly,
                key,
                computed,
                optional,
                type_ann,
            } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(key, visitor);
                <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsQualifiedName {
    #[doc = "Calls [VisitMut`::visit_mut_ts_qualified_name`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_qualified_name(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsQualifiedName { span, left, right } => {
                <TsEntityName as VisitMutWith<V>>::visit_mut_with(left, visitor);
                <IdentName as VisitMutWith<V>>::visit_mut_with(right, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsRestType {
    #[doc = "Calls [VisitMut`::visit_mut_ts_rest_type`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_rest_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsRestType { span, type_ann } => {
                <Box<TsType> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsSatisfiesExpr {
    #[doc = "Calls [VisitMut`::visit_mut_ts_satisfies_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_satisfies_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsSatisfiesExpr {
                span,
                expr,
                type_ann,
            } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor);
                <Box<TsType> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsSetterSignature {
    #[doc = "Calls [VisitMut`::visit_mut_ts_setter_signature`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_setter_signature(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsSetterSignature {
                span,
                key,
                computed,
                param,
            } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(key, visitor);
                <TsFnParam as VisitMutWith<V>>::visit_mut_with(param, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsThisType {
    #[doc = "Calls [VisitMut`::visit_mut_ts_this_type`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_this_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsThisType { span } => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsThisTypeOrIdent {
    #[doc = "Calls [VisitMut`::visit_mut_ts_this_type_or_ident`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_this_type_or_ident(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsThisTypeOrIdent::TsThisType { 0: _field_0 } => {
                <TsThisType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsThisTypeOrIdent::Ident { 0: _field_0 } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsTplLitType {
    #[doc = "Calls [VisitMut`::visit_mut_ts_tpl_lit_type`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_tpl_lit_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsTplLitType {
                span,
                types,
                quasis,
            } => {
                <Vec<Box<TsType>> as VisitMutWith<V>>::visit_mut_with(types, visitor);
                <Vec<TplElement> as VisitMutWith<V>>::visit_mut_with(quasis, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsTupleElement {
    #[doc = "Calls [VisitMut`::visit_mut_ts_tuple_element`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_tuple_element(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsTupleElement { span, label, ty } => {
                <Option<Pat> as VisitMutWith<V>>::visit_mut_with(label, visitor);
                <Box<TsType> as VisitMutWith<V>>::visit_mut_with(ty, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsTupleType {
    #[doc = "Calls [VisitMut`::visit_mut_ts_tuple_type`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_tuple_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsTupleType { span, elem_types } => {
                <Vec<TsTupleElement> as VisitMutWith<V>>::visit_mut_with(elem_types, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsType {
    #[doc = "Calls [VisitMut`::visit_mut_ts_type`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsType::TsKeywordType { 0: _field_0 } => {
                <TsKeywordType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsType::TsThisType { 0: _field_0 } => {
                <TsThisType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsType::TsFnOrConstructorType { 0: _field_0 } => {
                <TsFnOrConstructorType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsType::TsTypeRef { 0: _field_0 } => {
                <TsTypeRef as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsType::TsTypeQuery { 0: _field_0 } => {
                <TsTypeQuery as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsType::TsTypeLit { 0: _field_0 } => {
                <TsTypeLit as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsType::TsArrayType { 0: _field_0 } => {
                <TsArrayType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsType::TsTupleType { 0: _field_0 } => {
                <TsTupleType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsType::TsOptionalType { 0: _field_0 } => {
                <TsOptionalType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsType::TsRestType { 0: _field_0 } => {
                <TsRestType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsType::TsUnionOrIntersectionType { 0: _field_0 } => {
                <TsUnionOrIntersectionType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsType::TsConditionalType { 0: _field_0 } => {
                <TsConditionalType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsType::TsInferType { 0: _field_0 } => {
                <TsInferType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsType::TsParenthesizedType { 0: _field_0 } => {
                <TsParenthesizedType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsType::TsTypeOperator { 0: _field_0 } => {
                <TsTypeOperator as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsType::TsIndexedAccessType { 0: _field_0 } => {
                <TsIndexedAccessType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsType::TsMappedType { 0: _field_0 } => {
                <TsMappedType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsType::TsLitType { 0: _field_0 } => {
                <TsLitType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsType::TsTypePredicate { 0: _field_0 } => {
                <TsTypePredicate as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsType::TsImportType { 0: _field_0 } => {
                <TsImportType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsTypeAliasDecl {
    #[doc = "Calls [VisitMut`::visit_mut_ts_type_alias_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_type_alias_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsTypeAliasDecl {
                span,
                declare,
                id,
                type_params,
                type_ann,
            } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(id, visitor);
                <Option<Box<TsTypeParamDecl>> as VisitMutWith<V>>::visit_mut_with(
                    type_params,
                    visitor,
                );
                <Box<TsType> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsTypeAnn {
    #[doc = "Calls [VisitMut`::visit_mut_ts_type_ann`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_type_ann(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsTypeAnn { span, type_ann } => {
                <Box<TsType> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsTypeAssertion {
    #[doc = "Calls [VisitMut`::visit_mut_ts_type_assertion`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_type_assertion(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsTypeAssertion {
                span,
                expr,
                type_ann,
            } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(expr, visitor);
                <Box<TsType> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsTypeElement {
    #[doc = "Calls [VisitMut`::visit_mut_ts_type_element`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_type_element(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsTypeElement::TsCallSignatureDecl { 0: _field_0 } => {
                <TsCallSignatureDecl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsTypeElement::TsConstructSignatureDecl { 0: _field_0 } => {
                <TsConstructSignatureDecl as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsTypeElement::TsPropertySignature { 0: _field_0 } => {
                <TsPropertySignature as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsTypeElement::TsGetterSignature { 0: _field_0 } => {
                <TsGetterSignature as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsTypeElement::TsSetterSignature { 0: _field_0 } => {
                <TsSetterSignature as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsTypeElement::TsMethodSignature { 0: _field_0 } => {
                <TsMethodSignature as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsTypeElement::TsIndexSignature { 0: _field_0 } => {
                <TsIndexSignature as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsTypeLit {
    #[doc = "Calls [VisitMut`::visit_mut_ts_type_lit`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_type_lit(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsTypeLit { span, members } => {
                <Vec<TsTypeElement> as VisitMutWith<V>>::visit_mut_with(members, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsTypeOperator {
    #[doc = "Calls [VisitMut`::visit_mut_ts_type_operator`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_type_operator(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsTypeOperator { span, op, type_ann } => {
                <TsTypeOperatorOp as VisitMutWith<V>>::visit_mut_with(op, visitor);
                <Box<TsType> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsTypeOperatorOp {
    #[doc = "Calls [VisitMut`::visit_mut_ts_type_operator_op`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_type_operator_op(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsTypeOperatorOp::KeyOf => {}
            TsTypeOperatorOp::Unique => {}
            TsTypeOperatorOp::ReadOnly => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsTypeParam {
    #[doc = "Calls [VisitMut`::visit_mut_ts_type_param`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_type_param(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsTypeParam {
                span,
                name,
                is_in,
                is_out,
                is_const,
                constraint,
                default,
            } => {
                <Ident as VisitMutWith<V>>::visit_mut_with(name, visitor);
                <Option<Box<TsType>> as VisitMutWith<V>>::visit_mut_with(constraint, visitor);
                <Option<Box<TsType>> as VisitMutWith<V>>::visit_mut_with(default, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsTypeParamDecl {
    #[doc = "Calls [VisitMut`::visit_mut_ts_type_param_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_type_param_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsTypeParamDecl { span, params } => {
                <Vec<TsTypeParam> as VisitMutWith<V>>::visit_mut_with(params, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsTypeParamInstantiation {
    #[doc = "Calls [VisitMut`::visit_mut_ts_type_param_instantiation`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_type_param_instantiation(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsTypeParamInstantiation { span, params } => {
                <Vec<Box<TsType>> as VisitMutWith<V>>::visit_mut_with(params, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsTypePredicate {
    #[doc = "Calls [VisitMut`::visit_mut_ts_type_predicate`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_type_predicate(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsTypePredicate {
                span,
                asserts,
                param_name,
                type_ann,
            } => {
                <TsThisTypeOrIdent as VisitMutWith<V>>::visit_mut_with(param_name, visitor);
                <Option<Box<TsTypeAnn>> as VisitMutWith<V>>::visit_mut_with(type_ann, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsTypeQuery {
    #[doc = "Calls [VisitMut`::visit_mut_ts_type_query`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_type_query(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsTypeQuery {
                span,
                expr_name,
                type_args,
            } => {
                <TsTypeQueryExpr as VisitMutWith<V>>::visit_mut_with(expr_name, visitor);
                <Option<Box<TsTypeParamInstantiation>> as VisitMutWith<V>>::visit_mut_with(
                    type_args, visitor,
                );
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsTypeQueryExpr {
    #[doc = "Calls [VisitMut`::visit_mut_ts_type_query_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_type_query_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsTypeQueryExpr::TsEntityName { 0: _field_0 } => {
                <TsEntityName as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsTypeQueryExpr::Import { 0: _field_0 } => {
                <TsImportType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsTypeRef {
    #[doc = "Calls [VisitMut`::visit_mut_ts_type_ref`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_type_ref(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsTypeRef {
                span,
                type_name,
                type_params,
            } => {
                <TsEntityName as VisitMutWith<V>>::visit_mut_with(type_name, visitor);
                <Option<Box<TsTypeParamInstantiation>> as VisitMutWith<V>>::visit_mut_with(
                    type_params,
                    visitor,
                );
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsUnionOrIntersectionType {
    #[doc = "Calls [VisitMut`::visit_mut_ts_union_or_intersection_type`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_union_or_intersection_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsUnionOrIntersectionType::TsUnionType { 0: _field_0 } => {
                <TsUnionType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            TsUnionOrIntersectionType::TsIntersectionType { 0: _field_0 } => {
                <TsIntersectionType as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for TsUnionType {
    #[doc = "Calls [VisitMut`::visit_mut_ts_union_type`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_union_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            TsUnionType { span, types } => {
                <Vec<Box<TsType>> as VisitMutWith<V>>::visit_mut_with(types, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for UnaryExpr {
    #[doc = "Calls [VisitMut`::visit_mut_unary_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_unary_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            UnaryExpr { span, op, arg } => {
                <UnaryOp as VisitMutWith<V>>::visit_mut_with(op, visitor);
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(arg, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for UnaryOp {
    #[doc = "Calls [VisitMut`::visit_mut_unary_op`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_unary_op(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            UnaryOp::Minus => {}
            UnaryOp::Plus => {}
            UnaryOp::Bang => {}
            UnaryOp::Tilde => {}
            UnaryOp::TypeOf => {}
            UnaryOp::Void => {}
            UnaryOp::Delete => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for UpdateExpr {
    #[doc = "Calls [VisitMut`::visit_mut_update_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_update_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            UpdateExpr {
                span,
                op,
                prefix,
                arg,
            } => {
                <UpdateOp as VisitMutWith<V>>::visit_mut_with(op, visitor);
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(arg, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for UpdateOp {
    #[doc = "Calls [VisitMut`::visit_mut_update_op`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_update_op(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            UpdateOp::PlusPlus => {}
            UpdateOp::MinusMinus => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for UsingDecl {
    #[doc = "Calls [VisitMut`::visit_mut_using_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_using_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            UsingDecl {
                span,
                is_await,
                decls,
            } => {
                <Vec<VarDeclarator> as VisitMutWith<V>>::visit_mut_with(decls, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for VarDecl {
    #[doc = "Calls [VisitMut`::visit_mut_var_decl`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_var_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            VarDecl {
                span,
                ctxt,
                kind,
                declare,
                decls,
            } => {
                <VarDeclKind as VisitMutWith<V>>::visit_mut_with(kind, visitor);
                <Vec<VarDeclarator> as VisitMutWith<V>>::visit_mut_with(decls, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for VarDeclKind {
    #[doc = "Calls [VisitMut`::visit_mut_var_decl_kind`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_var_decl_kind(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            VarDeclKind::Var => {}
            VarDeclKind::Let => {}
            VarDeclKind::Const => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for VarDeclOrExpr {
    #[doc = "Calls [VisitMut`::visit_mut_var_decl_or_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_var_decl_or_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            VarDeclOrExpr::VarDecl { 0: _field_0 } => {
                <Box<VarDecl> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
            VarDeclOrExpr::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(_field_0, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for VarDeclarator {
    #[doc = "Calls [VisitMut`::visit_mut_var_declarator`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_var_declarator(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            VarDeclarator {
                span,
                name,
                init,
                definite,
            } => {
                <Pat as VisitMutWith<V>>::visit_mut_with(name, visitor);
                <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(init, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for WhileStmt {
    #[doc = "Calls [VisitMut`::visit_mut_while_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_while_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            WhileStmt { span, test, body } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(test, visitor);
                <Box<Stmt> as VisitMutWith<V>>::visit_mut_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for WithStmt {
    #[doc = "Calls [VisitMut`::visit_mut_with_stmt`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_with_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            WithStmt { span, obj, body } => {
                <Box<Expr> as VisitMutWith<V>>::visit_mut_with(obj, visitor);
                <Box<Stmt> as VisitMutWith<V>>::visit_mut_with(body, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for YieldExpr {
    #[doc = "Calls [VisitMut`::visit_mut_yield_expr`] with `self`."]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_yield_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            YieldExpr {
                span,
                arg,
                delegate,
            } => {
                <Option<Box<Expr>> as VisitMutWith<V>>::visit_mut_with(arg, visitor);
            }
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for swc_atoms::Atom {
    #[doc = "Calls [VisitMut`::visit_mut_atom`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_atom(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for BigIntValue {
    #[doc = "Calls [VisitMut`::visit_mut_big_int_value`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_big_int_value(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<ClassMember> {
    #[doc = "Calls [VisitMut`::visit_mut_class_members`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_class_members(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <ClassMember as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for ClassMethod {
    #[doc = "Calls [VisitMut`::visit_mut_class_method`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_class_method(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<Decorator> {
    #[doc = "Calls [VisitMut`::visit_mut_decorators`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_decorators(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <Decorator as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<ExportSpecifier> {
    #[doc = "Calls [VisitMut`::visit_mut_export_specifiers`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_export_specifiers(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <ExportSpecifier as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<ExprOrSpread> {
    #[doc = "Calls [VisitMut`::visit_mut_expr_or_spreads`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_expr_or_spreads(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <ExprOrSpread as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<Box<Expr>> {
    #[doc = "Calls [VisitMut`::visit_mut_exprs`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_exprs(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <Box<Expr> as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<ImportSpecifier> {
    #[doc = "Calls [VisitMut`::visit_mut_import_specifiers`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import_specifiers(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <ImportSpecifier as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<ImportWithItem> {
    #[doc = "Calls [VisitMut`::visit_mut_import_with_items`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_import_with_items(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <ImportWithItem as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<JSXAttrOrSpread> {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_attr_or_spreads`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_attr_or_spreads(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <JSXAttrOrSpread as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<JSXElementChild> {
    #[doc = "Calls [VisitMut`::visit_mut_jsx_element_childs`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_jsx_element_childs(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <JSXElementChild as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<ModuleItem> {
    #[doc = "Calls [VisitMut`::visit_mut_module_items`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_module_items(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <ModuleItem as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<ObjectPatProp> {
    #[doc = "Calls [VisitMut`::visit_mut_object_pat_props`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_object_pat_props(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <ObjectPatProp as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<Accessibility> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_accessibility`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_accessibility(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <Accessibility as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<swc_atoms::Atom> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_atom`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_atom(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <swc_atoms::Atom as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<BlockStmt> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_block_stmt`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_block_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <BlockStmt as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<CatchClause> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_catch_clause`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_catch_clause(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <CatchClause as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<Box<Expr>> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_expr`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <Box<Expr> as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<ExprOrSpread> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_expr_or_spread`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_expr_or_spread(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <ExprOrSpread as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<Vec<ExprOrSpread>> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_expr_or_spreads`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_expr_or_spreads(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <Vec<ExprOrSpread> as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<Ident> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_ident`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_ident(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <Ident as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<JSXAttrValue> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_jsx_attr_value`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_jsx_attr_value(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <JSXAttrValue as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<JSXClosingElement> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_jsx_closing_element`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_jsx_closing_element(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <JSXClosingElement as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<ModuleExportName> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_module_export_name`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_module_export_name(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <ModuleExportName as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<Vec<ModuleItem>> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_module_items`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_module_items(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <Vec<ModuleItem> as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<Box<ObjectLit>> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_object_lit`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_object_lit(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <Box<ObjectLit> as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<Pat> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_pat`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_pat(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <Pat as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<swc_common::Span> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_span`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_span(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <swc_common::Span as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<Box<Stmt>> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_stmt`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_stmt(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <Box<Stmt> as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<Box<Str>> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_str`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_str(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <Box<Str> as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<TruePlusMinus> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_true_plus_minus`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_true_plus_minus(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <TruePlusMinus as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<TsEntityName> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_ts_entity_name`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_ts_entity_name(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <TsEntityName as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<TsNamespaceBody> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_ts_namespace_body`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_ts_namespace_body(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <TsNamespaceBody as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<Box<TsType>> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_ts_type`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_ts_type(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <Box<TsType> as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<Box<TsTypeAnn>> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_ts_type_ann`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_ts_type_ann(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <Box<TsTypeAnn> as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<Box<TsTypeParamDecl>> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_ts_type_param_decl`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_ts_type_param_decl(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => {
                <Box<TsTypeParamDecl> as VisitMutWith<V>>::visit_mut_with(inner, visitor)
            }
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<Box<TsTypeParamInstantiation>> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_ts_type_param_instantiation`] with `self`. (Extra \
             impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_ts_type_param_instantiation(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => {
                <Box<TsTypeParamInstantiation> as VisitMutWith<V>>::visit_mut_with(inner, visitor)
            }
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Option<VarDeclOrExpr> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_var_decl_or_expr`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_var_decl_or_expr(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        match self {
            Some(inner) => <VarDeclOrExpr as VisitMutWith<V>>::visit_mut_with(inner, visitor),
            None => {}
        }
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<Option<ExprOrSpread>> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_vec_expr_or_spreads`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_vec_expr_or_spreads(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut().for_each(|item| {
            <Option<ExprOrSpread> as VisitMutWith<V>>::visit_mut_with(item, visitor)
        })
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<Option<Pat>> {
    #[doc = "Calls [VisitMut`::visit_mut_opt_vec_pats`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_opt_vec_pats(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <Option<Pat> as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<ParamOrTsParamProp> {
    #[doc = "Calls [VisitMut`::visit_mut_param_or_ts_param_props`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_param_or_ts_param_props(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <ParamOrTsParamProp as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<Param> {
    #[doc = "Calls [VisitMut`::visit_mut_params`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_params(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <Param as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<Pat> {
    #[doc = "Calls [VisitMut`::visit_mut_pats`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_pats(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <Pat as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for PrivateMethod {
    #[doc = "Calls [VisitMut`::visit_mut_private_method`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_private_method(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<PropOrSpread> {
    #[doc = "Calls [VisitMut`::visit_mut_prop_or_spreads`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_prop_or_spreads(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <PropOrSpread as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for swc_common::Span {
    #[doc = "Calls [VisitMut`::visit_mut_span`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_span(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<Stmt> {
    #[doc = "Calls [VisitMut`::visit_mut_stmts`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_stmts(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <Stmt as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<SwitchCase> {
    #[doc = "Calls [VisitMut`::visit_mut_switch_cases`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_switch_cases(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <SwitchCase as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for swc_common::SyntaxContext {
    #[doc = "Calls [VisitMut`::visit_mut_syntax_context`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_syntax_context(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        {}
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<TplElement> {
    #[doc = "Calls [VisitMut`::visit_mut_tpl_elements`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_tpl_elements(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <TplElement as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<TsEnumMember> {
    #[doc = "Calls [VisitMut`::visit_mut_ts_enum_members`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_enum_members(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <TsEnumMember as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<TsExprWithTypeArgs> {
    #[doc = "Calls [VisitMut`::visit_mut_ts_expr_with_type_argss`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_expr_with_type_argss(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <TsExprWithTypeArgs as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<TsFnParam> {
    #[doc = "Calls [VisitMut`::visit_mut_ts_fn_params`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_fn_params(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <TsFnParam as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<TsTupleElement> {
    #[doc = "Calls [VisitMut`::visit_mut_ts_tuple_elements`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_tuple_elements(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <TsTupleElement as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<TsTypeElement> {
    #[doc = "Calls [VisitMut`::visit_mut_ts_type_elements`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_type_elements(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <TsTypeElement as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<TsTypeParam> {
    #[doc = "Calls [VisitMut`::visit_mut_ts_type_params`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_type_params(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <TsTypeParam as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<Box<TsType>> {
    #[doc = "Calls [VisitMut`::visit_mut_ts_types`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_ts_types(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <Box<TsType> as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V: ?Sized + VisitMut> VisitMutWith<V> for Vec<VarDeclarator> {
    #[doc = "Calls [VisitMut`::visit_mut_var_declarators`] with `self`. (Extra impl)"]
    fn visit_mut_with(&mut self, visitor: &mut V) {
        <V as VisitMut>::visit_mut_var_declarators(visitor, self)
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        self.iter_mut()
            .for_each(|item| <VarDeclarator as VisitMutWith<V>>::visit_mut_with(item, visitor))
    }
}
impl<V, T> VisitMutWith<V> for std::boxed::Box<T>
where
    V: ?Sized + VisitMut,
    T: VisitMutWith<V>,
{
    fn visit_mut_with(&mut self, visitor: &mut V) {
        let v = <T as VisitMutWith<V>>::visit_mut_with(&mut **self, visitor);
        v
    }

    fn visit_mut_children_with(&mut self, visitor: &mut V) {
        let v = <T as VisitMutWith<V>>::visit_mut_children_with(&mut **self, visitor);
        v
    }
}
#[doc = r" A visitor trait for traversing the AST."]
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
pub trait VisitMutAstPath {
    #[doc = "Visit a node of type `Accessibility`.\n\nBy default, this method calls \
             [`Accessibility::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_accessibility(&mut self, node: &mut Accessibility, ast_path: &mut AstKindPath) {
        <Accessibility as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ArrayLit`.\n\nBy default, this method calls \
             [`ArrayLit::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_array_lit(&mut self, node: &mut ArrayLit, ast_path: &mut AstKindPath) {
        <ArrayLit as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ArrayPat`.\n\nBy default, this method calls \
             [`ArrayPat::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_array_pat(&mut self, node: &mut ArrayPat, ast_path: &mut AstKindPath) {
        <ArrayPat as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ArrowExpr`.\n\nBy default, this method calls \
             [`ArrowExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_arrow_expr(&mut self, node: &mut ArrowExpr, ast_path: &mut AstKindPath) {
        <ArrowExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `AssignExpr`.\n\nBy default, this method calls \
             [`AssignExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_assign_expr(&mut self, node: &mut AssignExpr, ast_path: &mut AstKindPath) {
        <AssignExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `AssignOp`.\n\nBy default, this method calls \
             [`AssignOp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_assign_op(&mut self, node: &mut AssignOp, ast_path: &mut AstKindPath) {
        <AssignOp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `AssignPat`.\n\nBy default, this method calls \
             [`AssignPat::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_assign_pat(&mut self, node: &mut AssignPat, ast_path: &mut AstKindPath) {
        <AssignPat as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `AssignPatProp`.\n\nBy default, this method calls \
             [`AssignPatProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_assign_pat_prop(&mut self, node: &mut AssignPatProp, ast_path: &mut AstKindPath) {
        <AssignPatProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `AssignProp`.\n\nBy default, this method calls \
             [`AssignProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_assign_prop(&mut self, node: &mut AssignProp, ast_path: &mut AstKindPath) {
        <AssignProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `AssignTarget`.\n\nBy default, this method calls \
             [`AssignTarget::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_assign_target(&mut self, node: &mut AssignTarget, ast_path: &mut AstKindPath) {
        <AssignTarget as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `AssignTargetPat`.\n\nBy default, this method calls \
             [`AssignTargetPat::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_assign_target_pat(
        &mut self,
        node: &mut AssignTargetPat,
        ast_path: &mut AstKindPath,
    ) {
        <AssignTargetPat as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `swc_atoms :: Atom`.\n\nBy default, this method calls \
             [`swc_atoms :: Atom::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom, ast_path: &mut AstKindPath) {
        <swc_atoms::Atom as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `AutoAccessor`.\n\nBy default, this method calls \
             [`AutoAccessor::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_auto_accessor(&mut self, node: &mut AutoAccessor, ast_path: &mut AstKindPath) {
        <AutoAccessor as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `AwaitExpr`.\n\nBy default, this method calls \
             [`AwaitExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_await_expr(&mut self, node: &mut AwaitExpr, ast_path: &mut AstKindPath) {
        <AwaitExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `BigInt`.\n\nBy default, this method calls \
             [`BigInt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_big_int(&mut self, node: &mut BigInt, ast_path: &mut AstKindPath) {
        <BigInt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `BigIntValue`.\n\nBy default, this method calls \
             [`BigIntValue::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_big_int_value(&mut self, node: &mut BigIntValue, ast_path: &mut AstKindPath) {
        <BigIntValue as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `BinExpr`.\n\nBy default, this method calls \
             [`BinExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_bin_expr(&mut self, node: &mut BinExpr, ast_path: &mut AstKindPath) {
        <BinExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `BinaryOp`.\n\nBy default, this method calls \
             [`BinaryOp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_binary_op(&mut self, node: &mut BinaryOp, ast_path: &mut AstKindPath) {
        <BinaryOp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `BindingIdent`.\n\nBy default, this method calls \
             [`BindingIdent::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_binding_ident(&mut self, node: &mut BindingIdent, ast_path: &mut AstKindPath) {
        <BindingIdent as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `BlockStmt`.\n\nBy default, this method calls \
             [`BlockStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_block_stmt(&mut self, node: &mut BlockStmt, ast_path: &mut AstKindPath) {
        <BlockStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `BlockStmtOrExpr`.\n\nBy default, this method calls \
             [`BlockStmtOrExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_block_stmt_or_expr(
        &mut self,
        node: &mut BlockStmtOrExpr,
        ast_path: &mut AstKindPath,
    ) {
        <BlockStmtOrExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Bool`.\n\nBy default, this method calls \
             [`Bool::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_bool(&mut self, node: &mut Bool, ast_path: &mut AstKindPath) {
        <Bool as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `BreakStmt`.\n\nBy default, this method calls \
             [`BreakStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_break_stmt(&mut self, node: &mut BreakStmt, ast_path: &mut AstKindPath) {
        <BreakStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `CallExpr`.\n\nBy default, this method calls \
             [`CallExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_call_expr(&mut self, node: &mut CallExpr, ast_path: &mut AstKindPath) {
        <CallExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Callee`.\n\nBy default, this method calls \
             [`Callee::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_callee(&mut self, node: &mut Callee, ast_path: &mut AstKindPath) {
        <Callee as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `CatchClause`.\n\nBy default, this method calls \
             [`CatchClause::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_catch_clause(&mut self, node: &mut CatchClause, ast_path: &mut AstKindPath) {
        <CatchClause as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Class`.\n\nBy default, this method calls \
             [`Class::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_class(&mut self, node: &mut Class, ast_path: &mut AstKindPath) {
        <Class as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ClassDecl`.\n\nBy default, this method calls \
             [`ClassDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_class_decl(&mut self, node: &mut ClassDecl, ast_path: &mut AstKindPath) {
        <ClassDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ClassExpr`.\n\nBy default, this method calls \
             [`ClassExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_class_expr(&mut self, node: &mut ClassExpr, ast_path: &mut AstKindPath) {
        <ClassExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ClassMember`.\n\nBy default, this method calls \
             [`ClassMember::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_class_member(&mut self, node: &mut ClassMember, ast_path: &mut AstKindPath) {
        <ClassMember as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ClassMember >`.\n\nBy default, this method calls [`Vec < \
             ClassMember >::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_class_members(&mut self, node: &mut Vec<ClassMember>, ast_path: &mut AstKindPath) {
        <Vec<ClassMember> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ClassMethod`.\n\nBy default, this method calls \
             [`ClassMethod::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_class_method(&mut self, node: &mut ClassMethod, ast_path: &mut AstKindPath) {
        <ClassMethod as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ClassProp`.\n\nBy default, this method calls \
             [`ClassProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_class_prop(&mut self, node: &mut ClassProp, ast_path: &mut AstKindPath) {
        <ClassProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ComputedPropName`.\n\nBy default, this method calls \
             [`ComputedPropName::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_computed_prop_name(
        &mut self,
        node: &mut ComputedPropName,
        ast_path: &mut AstKindPath,
    ) {
        <ComputedPropName as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `CondExpr`.\n\nBy default, this method calls \
             [`CondExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_cond_expr(&mut self, node: &mut CondExpr, ast_path: &mut AstKindPath) {
        <CondExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Constructor`.\n\nBy default, this method calls \
             [`Constructor::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_constructor(&mut self, node: &mut Constructor, ast_path: &mut AstKindPath) {
        <Constructor as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ContinueStmt`.\n\nBy default, this method calls \
             [`ContinueStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_continue_stmt(&mut self, node: &mut ContinueStmt, ast_path: &mut AstKindPath) {
        <ContinueStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `DebuggerStmt`.\n\nBy default, this method calls \
             [`DebuggerStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_debugger_stmt(&mut self, node: &mut DebuggerStmt, ast_path: &mut AstKindPath) {
        <DebuggerStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Decl`.\n\nBy default, this method calls \
             [`Decl::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_decl(&mut self, node: &mut Decl, ast_path: &mut AstKindPath) {
        <Decl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Decorator`.\n\nBy default, this method calls \
             [`Decorator::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_decorator(&mut self, node: &mut Decorator, ast_path: &mut AstKindPath) {
        <Decorator as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Decorator >`.\n\nBy default, this method calls [`Vec < \
             Decorator >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_decorators(&mut self, node: &mut Vec<Decorator>, ast_path: &mut AstKindPath) {
        <Vec<Decorator> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `DefaultDecl`.\n\nBy default, this method calls \
             [`DefaultDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_default_decl(&mut self, node: &mut DefaultDecl, ast_path: &mut AstKindPath) {
        <DefaultDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `DoWhileStmt`.\n\nBy default, this method calls \
             [`DoWhileStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_do_while_stmt(&mut self, node: &mut DoWhileStmt, ast_path: &mut AstKindPath) {
        <DoWhileStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `EmptyStmt`.\n\nBy default, this method calls \
             [`EmptyStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_empty_stmt(&mut self, node: &mut EmptyStmt, ast_path: &mut AstKindPath) {
        <EmptyStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `EsVersion`.\n\nBy default, this method calls \
             [`EsVersion::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_es_version(&mut self, node: &mut EsVersion, ast_path: &mut AstKindPath) {
        <EsVersion as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportAll`.\n\nBy default, this method calls \
             [`ExportAll::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_export_all(&mut self, node: &mut ExportAll, ast_path: &mut AstKindPath) {
        <ExportAll as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportDecl`.\n\nBy default, this method calls \
             [`ExportDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_export_decl(&mut self, node: &mut ExportDecl, ast_path: &mut AstKindPath) {
        <ExportDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportDefaultDecl`.\n\nBy default, this method calls \
             [`ExportDefaultDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_export_default_decl(
        &mut self,
        node: &mut ExportDefaultDecl,
        ast_path: &mut AstKindPath,
    ) {
        <ExportDefaultDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportDefaultExpr`.\n\nBy default, this method calls \
             [`ExportDefaultExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_export_default_expr(
        &mut self,
        node: &mut ExportDefaultExpr,
        ast_path: &mut AstKindPath,
    ) {
        <ExportDefaultExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ExportDefaultSpecifier::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_mut_export_default_specifier(
        &mut self,
        node: &mut ExportDefaultSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        <ExportDefaultSpecifier as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportNamedSpecifier`.\n\nBy default, this method calls \
             [`ExportNamedSpecifier::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_mut_export_named_specifier(
        &mut self,
        node: &mut ExportNamedSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        <ExportNamedSpecifier as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportNamespaceSpecifier`.\n\nBy default, this method calls \
             [`ExportNamespaceSpecifier::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_export_namespace_specifier(
        &mut self,
        node: &mut ExportNamespaceSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        <ExportNamespaceSpecifier as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportSpecifier`.\n\nBy default, this method calls \
             [`ExportSpecifier::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_export_specifier(
        &mut self,
        node: &mut ExportSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        <ExportSpecifier as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ExportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ExportSpecifier >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_export_specifiers(
        &mut self,
        node: &mut Vec<ExportSpecifier>,
        ast_path: &mut AstKindPath,
    ) {
        <Vec<ExportSpecifier> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Expr`.\n\nBy default, this method calls \
             [`Expr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_expr(&mut self, node: &mut Expr, ast_path: &mut AstKindPath) {
        <Expr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ExprOrSpread`.\n\nBy default, this method calls \
             [`ExprOrSpread::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_expr_or_spread(&mut self, node: &mut ExprOrSpread, ast_path: &mut AstKindPath) {
        <ExprOrSpread as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ExprOrSpread >`.\n\nBy default, this method calls [`Vec < \
             ExprOrSpread >::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_expr_or_spreads(
        &mut self,
        node: &mut Vec<ExprOrSpread>,
        ast_path: &mut AstKindPath,
    ) {
        <Vec<ExprOrSpread> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ExprStmt`.\n\nBy default, this method calls \
             [`ExprStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_expr_stmt(&mut self, node: &mut ExprStmt, ast_path: &mut AstKindPath) {
        <ExprStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Box < Expr > >`.\n\nBy default, this method calls [`Vec < \
             Box < Expr > >::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_exprs(&mut self, node: &mut Vec<Box<Expr>>, ast_path: &mut AstKindPath) {
        <Vec<Box<Expr>> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `FnDecl`.\n\nBy default, this method calls \
             [`FnDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_fn_decl(&mut self, node: &mut FnDecl, ast_path: &mut AstKindPath) {
        <FnDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `FnExpr`.\n\nBy default, this method calls \
             [`FnExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_fn_expr(&mut self, node: &mut FnExpr, ast_path: &mut AstKindPath) {
        <FnExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ForHead`.\n\nBy default, this method calls \
             [`ForHead::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_for_head(&mut self, node: &mut ForHead, ast_path: &mut AstKindPath) {
        <ForHead as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ForInStmt`.\n\nBy default, this method calls \
             [`ForInStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_for_in_stmt(&mut self, node: &mut ForInStmt, ast_path: &mut AstKindPath) {
        <ForInStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ForOfStmt`.\n\nBy default, this method calls \
             [`ForOfStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_for_of_stmt(&mut self, node: &mut ForOfStmt, ast_path: &mut AstKindPath) {
        <ForOfStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ForStmt`.\n\nBy default, this method calls \
             [`ForStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_for_stmt(&mut self, node: &mut ForStmt, ast_path: &mut AstKindPath) {
        <ForStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Function`.\n\nBy default, this method calls \
             [`Function::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_function(&mut self, node: &mut Function, ast_path: &mut AstKindPath) {
        <Function as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `GetterProp`.\n\nBy default, this method calls \
             [`GetterProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_getter_prop(&mut self, node: &mut GetterProp, ast_path: &mut AstKindPath) {
        <GetterProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Ident`.\n\nBy default, this method calls \
             [`Ident::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_ident(&mut self, node: &mut Ident, ast_path: &mut AstKindPath) {
        <Ident as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `IdentName`.\n\nBy default, this method calls \
             [`IdentName::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ident_name(&mut self, node: &mut IdentName, ast_path: &mut AstKindPath) {
        <IdentName as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `IfStmt`.\n\nBy default, this method calls \
             [`IfStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_if_stmt(&mut self, node: &mut IfStmt, ast_path: &mut AstKindPath) {
        <IfStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Import`.\n\nBy default, this method calls \
             [`Import::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_import(&mut self, node: &mut Import, ast_path: &mut AstKindPath) {
        <Import as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportDecl`.\n\nBy default, this method calls \
             [`ImportDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_import_decl(&mut self, node: &mut ImportDecl, ast_path: &mut AstKindPath) {
        <ImportDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ImportDefaultSpecifier::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_mut_import_default_specifier(
        &mut self,
        node: &mut ImportDefaultSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        <ImportDefaultSpecifier as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportNamedSpecifier`.\n\nBy default, this method calls \
             [`ImportNamedSpecifier::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_mut_import_named_specifier(
        &mut self,
        node: &mut ImportNamedSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        <ImportNamedSpecifier as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportPhase`.\n\nBy default, this method calls \
             [`ImportPhase::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_import_phase(&mut self, node: &mut ImportPhase, ast_path: &mut AstKindPath) {
        <ImportPhase as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportSpecifier`.\n\nBy default, this method calls \
             [`ImportSpecifier::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_import_specifier(
        &mut self,
        node: &mut ImportSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        <ImportSpecifier as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ImportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ImportSpecifier >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_import_specifiers(
        &mut self,
        node: &mut Vec<ImportSpecifier>,
        ast_path: &mut AstKindPath,
    ) {
        <Vec<ImportSpecifier> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportStarAsSpecifier`.\n\nBy default, this method calls \
             [`ImportStarAsSpecifier::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_mut_import_star_as_specifier(
        &mut self,
        node: &mut ImportStarAsSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        <ImportStarAsSpecifier as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportWith`.\n\nBy default, this method calls \
             [`ImportWith::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_import_with(&mut self, node: &mut ImportWith, ast_path: &mut AstKindPath) {
        <ImportWith as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportWithItem`.\n\nBy default, this method calls \
             [`ImportWithItem::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_import_with_item(
        &mut self,
        node: &mut ImportWithItem,
        ast_path: &mut AstKindPath,
    ) {
        <ImportWithItem as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ImportWithItem >`.\n\nBy default, this method calls [`Vec \
             < ImportWithItem >::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_import_with_items(
        &mut self,
        node: &mut Vec<ImportWithItem>,
        ast_path: &mut AstKindPath,
    ) {
        <Vec<ImportWithItem> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Invalid`.\n\nBy default, this method calls \
             [`Invalid::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_invalid(&mut self, node: &mut Invalid, ast_path: &mut AstKindPath) {
        <Invalid as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXAttr`.\n\nBy default, this method calls \
             [`JSXAttr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_jsx_attr(&mut self, node: &mut JSXAttr, ast_path: &mut AstKindPath) {
        <JSXAttr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXAttrName`.\n\nBy default, this method calls \
             [`JSXAttrName::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_jsx_attr_name(&mut self, node: &mut JSXAttrName, ast_path: &mut AstKindPath) {
        <JSXAttrName as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXAttrOrSpread`.\n\nBy default, this method calls \
             [`JSXAttrOrSpread::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_jsx_attr_or_spread(
        &mut self,
        node: &mut JSXAttrOrSpread,
        ast_path: &mut AstKindPath,
    ) {
        <JSXAttrOrSpread as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < JSXAttrOrSpread >`.\n\nBy default, this method calls \
             [`Vec < JSXAttrOrSpread >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_jsx_attr_or_spreads(
        &mut self,
        node: &mut Vec<JSXAttrOrSpread>,
        ast_path: &mut AstKindPath,
    ) {
        <Vec<JSXAttrOrSpread> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXAttrValue`.\n\nBy default, this method calls \
             [`JSXAttrValue::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_jsx_attr_value(&mut self, node: &mut JSXAttrValue, ast_path: &mut AstKindPath) {
        <JSXAttrValue as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXClosingElement`.\n\nBy default, this method calls \
             [`JSXClosingElement::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_jsx_closing_element(
        &mut self,
        node: &mut JSXClosingElement,
        ast_path: &mut AstKindPath,
    ) {
        <JSXClosingElement as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXClosingFragment`.\n\nBy default, this method calls \
             [`JSXClosingFragment::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_jsx_closing_fragment(
        &mut self,
        node: &mut JSXClosingFragment,
        ast_path: &mut AstKindPath,
    ) {
        <JSXClosingFragment as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXElement`.\n\nBy default, this method calls \
             [`JSXElement::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_jsx_element(&mut self, node: &mut JSXElement, ast_path: &mut AstKindPath) {
        <JSXElement as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXElementChild`.\n\nBy default, this method calls \
             [`JSXElementChild::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_jsx_element_child(
        &mut self,
        node: &mut JSXElementChild,
        ast_path: &mut AstKindPath,
    ) {
        <JSXElementChild as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < JSXElementChild >`.\n\nBy default, this method calls \
             [`Vec < JSXElementChild >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_jsx_element_childs(
        &mut self,
        node: &mut Vec<JSXElementChild>,
        ast_path: &mut AstKindPath,
    ) {
        <Vec<JSXElementChild> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXElementName`.\n\nBy default, this method calls \
             [`JSXElementName::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_jsx_element_name(
        &mut self,
        node: &mut JSXElementName,
        ast_path: &mut AstKindPath,
    ) {
        <JSXElementName as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXEmptyExpr`.\n\nBy default, this method calls \
             [`JSXEmptyExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_jsx_empty_expr(&mut self, node: &mut JSXEmptyExpr, ast_path: &mut AstKindPath) {
        <JSXEmptyExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXExpr`.\n\nBy default, this method calls \
             [`JSXExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_jsx_expr(&mut self, node: &mut JSXExpr, ast_path: &mut AstKindPath) {
        <JSXExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXExprContainer`.\n\nBy default, this method calls \
             [`JSXExprContainer::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_jsx_expr_container(
        &mut self,
        node: &mut JSXExprContainer,
        ast_path: &mut AstKindPath,
    ) {
        <JSXExprContainer as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXFragment`.\n\nBy default, this method calls \
             [`JSXFragment::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_jsx_fragment(&mut self, node: &mut JSXFragment, ast_path: &mut AstKindPath) {
        <JSXFragment as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXMemberExpr`.\n\nBy default, this method calls \
             [`JSXMemberExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_jsx_member_expr(&mut self, node: &mut JSXMemberExpr, ast_path: &mut AstKindPath) {
        <JSXMemberExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXNamespacedName`.\n\nBy default, this method calls \
             [`JSXNamespacedName::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_jsx_namespaced_name(
        &mut self,
        node: &mut JSXNamespacedName,
        ast_path: &mut AstKindPath,
    ) {
        <JSXNamespacedName as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXObject`.\n\nBy default, this method calls \
             [`JSXObject::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_jsx_object(&mut self, node: &mut JSXObject, ast_path: &mut AstKindPath) {
        <JSXObject as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXOpeningElement`.\n\nBy default, this method calls \
             [`JSXOpeningElement::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_jsx_opening_element(
        &mut self,
        node: &mut JSXOpeningElement,
        ast_path: &mut AstKindPath,
    ) {
        <JSXOpeningElement as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXOpeningFragment`.\n\nBy default, this method calls \
             [`JSXOpeningFragment::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_jsx_opening_fragment(
        &mut self,
        node: &mut JSXOpeningFragment,
        ast_path: &mut AstKindPath,
    ) {
        <JSXOpeningFragment as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXSpreadChild`.\n\nBy default, this method calls \
             [`JSXSpreadChild::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_jsx_spread_child(
        &mut self,
        node: &mut JSXSpreadChild,
        ast_path: &mut AstKindPath,
    ) {
        <JSXSpreadChild as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXText`.\n\nBy default, this method calls \
             [`JSXText::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_jsx_text(&mut self, node: &mut JSXText, ast_path: &mut AstKindPath) {
        <JSXText as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Key`.\n\nBy default, this method calls \
             [`Key::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_key(&mut self, node: &mut Key, ast_path: &mut AstKindPath) {
        <Key as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `KeyValuePatProp`.\n\nBy default, this method calls \
             [`KeyValuePatProp::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_key_value_pat_prop(
        &mut self,
        node: &mut KeyValuePatProp,
        ast_path: &mut AstKindPath,
    ) {
        <KeyValuePatProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `KeyValueProp`.\n\nBy default, this method calls \
             [`KeyValueProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_key_value_prop(&mut self, node: &mut KeyValueProp, ast_path: &mut AstKindPath) {
        <KeyValueProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `LabeledStmt`.\n\nBy default, this method calls \
             [`LabeledStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_labeled_stmt(&mut self, node: &mut LabeledStmt, ast_path: &mut AstKindPath) {
        <LabeledStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Lit`.\n\nBy default, this method calls \
             [`Lit::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_lit(&mut self, node: &mut Lit, ast_path: &mut AstKindPath) {
        <Lit as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `MemberExpr`.\n\nBy default, this method calls \
             [`MemberExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_member_expr(&mut self, node: &mut MemberExpr, ast_path: &mut AstKindPath) {
        <MemberExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `MemberProp`.\n\nBy default, this method calls \
             [`MemberProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_member_prop(&mut self, node: &mut MemberProp, ast_path: &mut AstKindPath) {
        <MemberProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `MetaPropExpr`.\n\nBy default, this method calls \
             [`MetaPropExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_meta_prop_expr(&mut self, node: &mut MetaPropExpr, ast_path: &mut AstKindPath) {
        <MetaPropExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `MetaPropKind`.\n\nBy default, this method calls \
             [`MetaPropKind::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_meta_prop_kind(&mut self, node: &mut MetaPropKind, ast_path: &mut AstKindPath) {
        <MetaPropKind as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `MethodKind`.\n\nBy default, this method calls \
             [`MethodKind::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_method_kind(&mut self, node: &mut MethodKind, ast_path: &mut AstKindPath) {
        <MethodKind as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `MethodProp`.\n\nBy default, this method calls \
             [`MethodProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_method_prop(&mut self, node: &mut MethodProp, ast_path: &mut AstKindPath) {
        <MethodProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Module`.\n\nBy default, this method calls \
             [`Module::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_module(&mut self, node: &mut Module, ast_path: &mut AstKindPath) {
        <Module as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ModuleDecl`.\n\nBy default, this method calls \
             [`ModuleDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_module_decl(&mut self, node: &mut ModuleDecl, ast_path: &mut AstKindPath) {
        <ModuleDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ModuleExportName`.\n\nBy default, this method calls \
             [`ModuleExportName::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_module_export_name(
        &mut self,
        node: &mut ModuleExportName,
        ast_path: &mut AstKindPath,
    ) {
        <ModuleExportName as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ModuleItem`.\n\nBy default, this method calls \
             [`ModuleItem::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_module_item(&mut self, node: &mut ModuleItem, ast_path: &mut AstKindPath) {
        <ModuleItem as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ModuleItem >`.\n\nBy default, this method calls [`Vec < \
             ModuleItem >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_module_items(&mut self, node: &mut Vec<ModuleItem>, ast_path: &mut AstKindPath) {
        <Vec<ModuleItem> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `NamedExport`.\n\nBy default, this method calls \
             [`NamedExport::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_named_export(&mut self, node: &mut NamedExport, ast_path: &mut AstKindPath) {
        <NamedExport as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `NewExpr`.\n\nBy default, this method calls \
             [`NewExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_new_expr(&mut self, node: &mut NewExpr, ast_path: &mut AstKindPath) {
        <NewExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Null`.\n\nBy default, this method calls \
             [`Null::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_null(&mut self, node: &mut Null, ast_path: &mut AstKindPath) {
        <Null as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Number`.\n\nBy default, this method calls \
             [`Number::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_number(&mut self, node: &mut Number, ast_path: &mut AstKindPath) {
        <Number as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ObjectLit`.\n\nBy default, this method calls \
             [`ObjectLit::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_object_lit(&mut self, node: &mut ObjectLit, ast_path: &mut AstKindPath) {
        <ObjectLit as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ObjectPat`.\n\nBy default, this method calls \
             [`ObjectPat::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_object_pat(&mut self, node: &mut ObjectPat, ast_path: &mut AstKindPath) {
        <ObjectPat as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ObjectPatProp`.\n\nBy default, this method calls \
             [`ObjectPatProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_object_pat_prop(&mut self, node: &mut ObjectPatProp, ast_path: &mut AstKindPath) {
        <ObjectPatProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ObjectPatProp >`.\n\nBy default, this method calls [`Vec \
             < ObjectPatProp >::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_object_pat_props(
        &mut self,
        node: &mut Vec<ObjectPatProp>,
        ast_path: &mut AstKindPath,
    ) {
        <Vec<ObjectPatProp> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Accessibility >`.\n\nBy default, this method calls \
             [`Option < Accessibility >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_opt_accessibility(
        &mut self,
        node: &mut Option<Accessibility>,
        ast_path: &mut AstKindPath,
    ) {
        <Option<Accessibility> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < swc_atoms :: Atom >`.\n\nBy default, this method calls \
             [`Option < swc_atoms :: Atom >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_opt_atom(
        &mut self,
        node: &mut Option<swc_atoms::Atom>,
        ast_path: &mut AstKindPath,
    ) {
        <Option<swc_atoms::Atom> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < BlockStmt >`.\n\nBy default, this method calls \
             [`Option < BlockStmt >::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_mut_opt_block_stmt(
        &mut self,
        node: &mut Option<BlockStmt>,
        ast_path: &mut AstKindPath,
    ) {
        <Option<BlockStmt> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `OptCall`.\n\nBy default, this method calls \
             [`OptCall::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_opt_call(&mut self, node: &mut OptCall, ast_path: &mut AstKindPath) {
        <OptCall as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < CatchClause >`.\n\nBy default, this method calls \
             [`Option < CatchClause >::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_mut_opt_catch_clause(
        &mut self,
        node: &mut Option<CatchClause>,
        ast_path: &mut AstKindPath,
    ) {
        <Option<CatchClause> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `OptChainBase`.\n\nBy default, this method calls \
             [`OptChainBase::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_opt_chain_base(&mut self, node: &mut OptChainBase, ast_path: &mut AstKindPath) {
        <OptChainBase as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `OptChainExpr`.\n\nBy default, this method calls \
             [`OptChainExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_opt_chain_expr(&mut self, node: &mut OptChainExpr, ast_path: &mut AstKindPath) {
        <OptChainExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < Expr > >`.\n\nBy default, this method calls \
             [`Option < Box < Expr > >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_opt_expr(&mut self, node: &mut Option<Box<Expr>>, ast_path: &mut AstKindPath) {
        <Option<Box<Expr>> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < ExprOrSpread >`.\n\nBy default, this method calls \
             [`Option < ExprOrSpread >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_opt_expr_or_spread(
        &mut self,
        node: &mut Option<ExprOrSpread>,
        ast_path: &mut AstKindPath,
    ) {
        <Option<ExprOrSpread> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Vec < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Option < Vec < ExprOrSpread > >::visit_mut_children_with_ast_path`]. If you \
             want to recurse, you need to call it manually."]
    fn visit_mut_opt_expr_or_spreads(
        &mut self,
        node: &mut Option<Vec<ExprOrSpread>>,
        ast_path: &mut AstKindPath,
    ) {
        <Option<Vec<ExprOrSpread>> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Ident >`.\n\nBy default, this method calls [`Option < \
             Ident >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_opt_ident(&mut self, node: &mut Option<Ident>, ast_path: &mut AstKindPath) {
        <Option<Ident> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < JSXAttrValue >`.\n\nBy default, this method calls \
             [`Option < JSXAttrValue >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_opt_jsx_attr_value(
        &mut self,
        node: &mut Option<JSXAttrValue>,
        ast_path: &mut AstKindPath,
    ) {
        <Option<JSXAttrValue> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < JSXClosingElement >`.\n\nBy default, this method calls \
             [`Option < JSXClosingElement >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_opt_jsx_closing_element(
        &mut self,
        node: &mut Option<JSXClosingElement>,
        ast_path: &mut AstKindPath,
    ) {
        <Option<JSXClosingElement> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < ModuleExportName >`.\n\nBy default, this method calls \
             [`Option < ModuleExportName >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_opt_module_export_name(
        &mut self,
        node: &mut Option<ModuleExportName>,
        ast_path: &mut AstKindPath,
    ) {
        <Option<ModuleExportName> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Vec < ModuleItem > >`.\n\nBy default, this method \
             calls [`Option < Vec < ModuleItem > >::visit_mut_children_with_ast_path`]. If you \
             want to recurse, you need to call it manually."]
    fn visit_mut_opt_module_items(
        &mut self,
        node: &mut Option<Vec<ModuleItem>>,
        ast_path: &mut AstKindPath,
    ) {
        <Option<Vec<ModuleItem>> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < ObjectLit > >`.\n\nBy default, this method calls \
             [`Option < Box < ObjectLit > >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_opt_object_lit(
        &mut self,
        node: &mut Option<Box<ObjectLit>>,
        ast_path: &mut AstKindPath,
    ) {
        <Option<Box<ObjectLit>> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Pat >`.\n\nBy default, this method calls [`Option < \
             Pat >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_opt_pat(&mut self, node: &mut Option<Pat>, ast_path: &mut AstKindPath) {
        <Option<Pat> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < swc_common :: Span >`.\n\nBy default, this method \
             calls [`Option < swc_common :: Span >::visit_mut_children_with_ast_path`]. If you \
             want to recurse, you need to call it manually."]
    fn visit_mut_opt_span(
        &mut self,
        node: &mut Option<swc_common::Span>,
        ast_path: &mut AstKindPath,
    ) {
        <Option<swc_common::Span> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < Stmt > >`.\n\nBy default, this method calls \
             [`Option < Box < Stmt > >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_opt_stmt(&mut self, node: &mut Option<Box<Stmt>>, ast_path: &mut AstKindPath) {
        <Option<Box<Stmt>> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < Str > >`.\n\nBy default, this method calls \
             [`Option < Box < Str > >::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_mut_opt_str(&mut self, node: &mut Option<Box<Str>>, ast_path: &mut AstKindPath) {
        <Option<Box<Str>> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < TruePlusMinus >`.\n\nBy default, this method calls \
             [`Option < TruePlusMinus >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_opt_true_plus_minus(
        &mut self,
        node: &mut Option<TruePlusMinus>,
        ast_path: &mut AstKindPath,
    ) {
        <Option<TruePlusMinus> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < TsEntityName >`.\n\nBy default, this method calls \
             [`Option < TsEntityName >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_opt_ts_entity_name(
        &mut self,
        node: &mut Option<TsEntityName>,
        ast_path: &mut AstKindPath,
    ) {
        <Option<TsEntityName> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < TsNamespaceBody >`.\n\nBy default, this method calls \
             [`Option < TsNamespaceBody >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_opt_ts_namespace_body(
        &mut self,
        node: &mut Option<TsNamespaceBody>,
        ast_path: &mut AstKindPath,
    ) {
        <Option<TsNamespaceBody> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < TsType > >`.\n\nBy default, this method calls \
             [`Option < Box < TsType > >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_opt_ts_type(
        &mut self,
        node: &mut Option<Box<TsType>>,
        ast_path: &mut AstKindPath,
    ) {
        <Option<Box<TsType>> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < TsTypeAnn > >`.\n\nBy default, this method calls \
             [`Option < Box < TsTypeAnn > >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_opt_ts_type_ann(
        &mut self,
        node: &mut Option<Box<TsTypeAnn>>,
        ast_path: &mut AstKindPath,
    ) {
        <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < TsTypeParamDecl > >`.\n\nBy default, this method \
             calls [`Option < Box < TsTypeParamDecl > >::visit_mut_children_with_ast_path`]. If \
             you want to recurse, you need to call it manually."]
    fn visit_mut_opt_ts_type_param_decl(
        &mut self,
        node: &mut Option<Box<TsTypeParamDecl>>,
        ast_path: &mut AstKindPath,
    ) {
        < Option < Box < TsTypeParamDecl > > as VisitMutWithAstPath < Self > > :: visit_mut_children_with_ast_path (node , self , ast_path)
    }
    #[doc = "Visit a node of type `Option < Box < TsTypeParamInstantiation > >`.\n\nBy default, \
             this method calls [`Option < Box < TsTypeParamInstantiation > \
             >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_opt_ts_type_param_instantiation(
        &mut self,
        node: &mut Option<Box<TsTypeParamInstantiation>>,
        ast_path: &mut AstKindPath,
    ) {
        < Option < Box < TsTypeParamInstantiation > > as VisitMutWithAstPath < Self > > :: visit_mut_children_with_ast_path (node , self , ast_path)
    }
    #[doc = "Visit a node of type `Option < VarDeclOrExpr >`.\n\nBy default, this method calls \
             [`Option < VarDeclOrExpr >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_opt_var_decl_or_expr(
        &mut self,
        node: &mut Option<VarDeclOrExpr>,
        ast_path: &mut AstKindPath,
    ) {
        <Option<VarDeclOrExpr> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Option < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Vec < Option < ExprOrSpread > >::visit_mut_children_with_ast_path`]. If you \
             want to recurse, you need to call it manually."]
    fn visit_mut_opt_vec_expr_or_spreads(
        &mut self,
        node: &mut Vec<Option<ExprOrSpread>>,
        ast_path: &mut AstKindPath,
    ) {
        <Vec<Option<ExprOrSpread>> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Option < Pat > >`.\n\nBy default, this method calls [`Vec \
             < Option < Pat > >::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_opt_vec_pats(&mut self, node: &mut Vec<Option<Pat>>, ast_path: &mut AstKindPath) {
        <Vec<Option<Pat>> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Param`.\n\nBy default, this method calls \
             [`Param::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_param(&mut self, node: &mut Param, ast_path: &mut AstKindPath) {
        <Param as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ParamOrTsParamProp`.\n\nBy default, this method calls \
             [`ParamOrTsParamProp::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_param_or_ts_param_prop(
        &mut self,
        node: &mut ParamOrTsParamProp,
        ast_path: &mut AstKindPath,
    ) {
        <ParamOrTsParamProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ParamOrTsParamProp >`.\n\nBy default, this method calls \
             [`Vec < ParamOrTsParamProp >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_param_or_ts_param_props(
        &mut self,
        node: &mut Vec<ParamOrTsParamProp>,
        ast_path: &mut AstKindPath,
    ) {
        <Vec<ParamOrTsParamProp> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Param >`.\n\nBy default, this method calls [`Vec < Param \
             >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_params(&mut self, node: &mut Vec<Param>, ast_path: &mut AstKindPath) {
        <Vec<Param> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ParenExpr`.\n\nBy default, this method calls \
             [`ParenExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_paren_expr(&mut self, node: &mut ParenExpr, ast_path: &mut AstKindPath) {
        <ParenExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Pat`.\n\nBy default, this method calls \
             [`Pat::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_pat(&mut self, node: &mut Pat, ast_path: &mut AstKindPath) {
        <Pat as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < Pat >`.\n\nBy default, this method calls [`Vec < Pat \
             >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_pats(&mut self, node: &mut Vec<Pat>, ast_path: &mut AstKindPath) {
        <Vec<Pat> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `PrivateMethod`.\n\nBy default, this method calls \
             [`PrivateMethod::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_private_method(&mut self, node: &mut PrivateMethod, ast_path: &mut AstKindPath) {
        <PrivateMethod as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `PrivateName`.\n\nBy default, this method calls \
             [`PrivateName::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_private_name(&mut self, node: &mut PrivateName, ast_path: &mut AstKindPath) {
        <PrivateName as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `PrivateProp`.\n\nBy default, this method calls \
             [`PrivateProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_private_prop(&mut self, node: &mut PrivateProp, ast_path: &mut AstKindPath) {
        <PrivateProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Program`.\n\nBy default, this method calls \
             [`Program::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_program(&mut self, node: &mut Program, ast_path: &mut AstKindPath) {
        <Program as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Prop`.\n\nBy default, this method calls \
             [`Prop::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_prop(&mut self, node: &mut Prop, ast_path: &mut AstKindPath) {
        <Prop as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `PropName`.\n\nBy default, this method calls \
             [`PropName::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_prop_name(&mut self, node: &mut PropName, ast_path: &mut AstKindPath) {
        <PropName as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `PropOrSpread`.\n\nBy default, this method calls \
             [`PropOrSpread::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_prop_or_spread(&mut self, node: &mut PropOrSpread, ast_path: &mut AstKindPath) {
        <PropOrSpread as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < PropOrSpread >`.\n\nBy default, this method calls [`Vec < \
             PropOrSpread >::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_prop_or_spreads(
        &mut self,
        node: &mut Vec<PropOrSpread>,
        ast_path: &mut AstKindPath,
    ) {
        <Vec<PropOrSpread> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Regex`.\n\nBy default, this method calls \
             [`Regex::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_regex(&mut self, node: &mut Regex, ast_path: &mut AstKindPath) {
        <Regex as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ReservedUnused`.\n\nBy default, this method calls \
             [`ReservedUnused::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_reserved_unused(&mut self, node: &mut ReservedUnused, ast_path: &mut AstKindPath) {
        <ReservedUnused as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `RestPat`.\n\nBy default, this method calls \
             [`RestPat::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_rest_pat(&mut self, node: &mut RestPat, ast_path: &mut AstKindPath) {
        <RestPat as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ReturnStmt`.\n\nBy default, this method calls \
             [`ReturnStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_return_stmt(&mut self, node: &mut ReturnStmt, ast_path: &mut AstKindPath) {
        <ReturnStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Script`.\n\nBy default, this method calls \
             [`Script::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_script(&mut self, node: &mut Script, ast_path: &mut AstKindPath) {
        <Script as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `SeqExpr`.\n\nBy default, this method calls \
             [`SeqExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_seq_expr(&mut self, node: &mut SeqExpr, ast_path: &mut AstKindPath) {
        <SeqExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `SetterProp`.\n\nBy default, this method calls \
             [`SetterProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_setter_prop(&mut self, node: &mut SetterProp, ast_path: &mut AstKindPath) {
        <SetterProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `SimpleAssignTarget`.\n\nBy default, this method calls \
             [`SimpleAssignTarget::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_simple_assign_target(
        &mut self,
        node: &mut SimpleAssignTarget,
        ast_path: &mut AstKindPath,
    ) {
        <SimpleAssignTarget as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `swc_common :: Span`.\n\nBy default, this method calls \
             [`swc_common :: Span::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_span(&mut self, node: &mut swc_common::Span, ast_path: &mut AstKindPath) {
        <swc_common::Span as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `SpreadElement`.\n\nBy default, this method calls \
             [`SpreadElement::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_spread_element(&mut self, node: &mut SpreadElement, ast_path: &mut AstKindPath) {
        <SpreadElement as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `StaticBlock`.\n\nBy default, this method calls \
             [`StaticBlock::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_static_block(&mut self, node: &mut StaticBlock, ast_path: &mut AstKindPath) {
        <StaticBlock as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Stmt`.\n\nBy default, this method calls \
             [`Stmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_stmt(&mut self, node: &mut Stmt, ast_path: &mut AstKindPath) {
        <Stmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < Stmt >`.\n\nBy default, this method calls [`Vec < Stmt \
             >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn visit_mut_stmts(&mut self, node: &mut Vec<Stmt>, ast_path: &mut AstKindPath) {
        <Vec<Stmt> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Str`.\n\nBy default, this method calls \
             [`Str::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_str(&mut self, node: &mut Str, ast_path: &mut AstKindPath) {
        <Str as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Super`.\n\nBy default, this method calls \
             [`Super::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_super(&mut self, node: &mut Super, ast_path: &mut AstKindPath) {
        <Super as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `SuperProp`.\n\nBy default, this method calls \
             [`SuperProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_super_prop(&mut self, node: &mut SuperProp, ast_path: &mut AstKindPath) {
        <SuperProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `SuperPropExpr`.\n\nBy default, this method calls \
             [`SuperPropExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_super_prop_expr(&mut self, node: &mut SuperPropExpr, ast_path: &mut AstKindPath) {
        <SuperPropExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `SwitchCase`.\n\nBy default, this method calls \
             [`SwitchCase::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_switch_case(&mut self, node: &mut SwitchCase, ast_path: &mut AstKindPath) {
        <SwitchCase as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < SwitchCase >`.\n\nBy default, this method calls [`Vec < \
             SwitchCase >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_switch_cases(&mut self, node: &mut Vec<SwitchCase>, ast_path: &mut AstKindPath) {
        <Vec<SwitchCase> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `SwitchStmt`.\n\nBy default, this method calls \
             [`SwitchStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_switch_stmt(&mut self, node: &mut SwitchStmt, ast_path: &mut AstKindPath) {
        <SwitchStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `swc_common :: SyntaxContext`.\n\nBy default, this method calls \
             [`swc_common :: SyntaxContext::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_syntax_context(
        &mut self,
        node: &mut swc_common::SyntaxContext,
        ast_path: &mut AstKindPath,
    ) {
        <swc_common::SyntaxContext as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TaggedTpl`.\n\nBy default, this method calls \
             [`TaggedTpl::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_tagged_tpl(&mut self, node: &mut TaggedTpl, ast_path: &mut AstKindPath) {
        <TaggedTpl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ThisExpr`.\n\nBy default, this method calls \
             [`ThisExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_this_expr(&mut self, node: &mut ThisExpr, ast_path: &mut AstKindPath) {
        <ThisExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ThrowStmt`.\n\nBy default, this method calls \
             [`ThrowStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_throw_stmt(&mut self, node: &mut ThrowStmt, ast_path: &mut AstKindPath) {
        <ThrowStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Tpl`.\n\nBy default, this method calls \
             [`Tpl::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_tpl(&mut self, node: &mut Tpl, ast_path: &mut AstKindPath) {
        <Tpl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TplElement`.\n\nBy default, this method calls \
             [`TplElement::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_tpl_element(&mut self, node: &mut TplElement, ast_path: &mut AstKindPath) {
        <TplElement as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < TplElement >`.\n\nBy default, this method calls [`Vec < \
             TplElement >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_tpl_elements(&mut self, node: &mut Vec<TplElement>, ast_path: &mut AstKindPath) {
        <Vec<TplElement> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TruePlusMinus`.\n\nBy default, this method calls \
             [`TruePlusMinus::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_true_plus_minus(&mut self, node: &mut TruePlusMinus, ast_path: &mut AstKindPath) {
        <TruePlusMinus as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TryStmt`.\n\nBy default, this method calls \
             [`TryStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_try_stmt(&mut self, node: &mut TryStmt, ast_path: &mut AstKindPath) {
        <TryStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsArrayType`.\n\nBy default, this method calls \
             [`TsArrayType::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_array_type(&mut self, node: &mut TsArrayType, ast_path: &mut AstKindPath) {
        <TsArrayType as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsAsExpr`.\n\nBy default, this method calls \
             [`TsAsExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_as_expr(&mut self, node: &mut TsAsExpr, ast_path: &mut AstKindPath) {
        <TsAsExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsCallSignatureDecl`.\n\nBy default, this method calls \
             [`TsCallSignatureDecl::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_mut_ts_call_signature_decl(
        &mut self,
        node: &mut TsCallSignatureDecl,
        ast_path: &mut AstKindPath,
    ) {
        <TsCallSignatureDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsConditionalType`.\n\nBy default, this method calls \
             [`TsConditionalType::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_conditional_type(
        &mut self,
        node: &mut TsConditionalType,
        ast_path: &mut AstKindPath,
    ) {
        <TsConditionalType as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsConstAssertion`.\n\nBy default, this method calls \
             [`TsConstAssertion::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_const_assertion(
        &mut self,
        node: &mut TsConstAssertion,
        ast_path: &mut AstKindPath,
    ) {
        <TsConstAssertion as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsConstructSignatureDecl`.\n\nBy default, this method calls \
             [`TsConstructSignatureDecl::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_ts_construct_signature_decl(
        &mut self,
        node: &mut TsConstructSignatureDecl,
        ast_path: &mut AstKindPath,
    ) {
        <TsConstructSignatureDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsConstructorType`.\n\nBy default, this method calls \
             [`TsConstructorType::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_constructor_type(
        &mut self,
        node: &mut TsConstructorType,
        ast_path: &mut AstKindPath,
    ) {
        <TsConstructorType as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsEntityName`.\n\nBy default, this method calls \
             [`TsEntityName::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_entity_name(&mut self, node: &mut TsEntityName, ast_path: &mut AstKindPath) {
        <TsEntityName as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsEnumDecl`.\n\nBy default, this method calls \
             [`TsEnumDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_enum_decl(&mut self, node: &mut TsEnumDecl, ast_path: &mut AstKindPath) {
        <TsEnumDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsEnumMember`.\n\nBy default, this method calls \
             [`TsEnumMember::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_enum_member(&mut self, node: &mut TsEnumMember, ast_path: &mut AstKindPath) {
        <TsEnumMember as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsEnumMemberId`.\n\nBy default, this method calls \
             [`TsEnumMemberId::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_enum_member_id(
        &mut self,
        node: &mut TsEnumMemberId,
        ast_path: &mut AstKindPath,
    ) {
        <TsEnumMemberId as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < TsEnumMember >`.\n\nBy default, this method calls [`Vec < \
             TsEnumMember >::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_enum_members(
        &mut self,
        node: &mut Vec<TsEnumMember>,
        ast_path: &mut AstKindPath,
    ) {
        <Vec<TsEnumMember> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsExportAssignment`.\n\nBy default, this method calls \
             [`TsExportAssignment::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_export_assignment(
        &mut self,
        node: &mut TsExportAssignment,
        ast_path: &mut AstKindPath,
    ) {
        <TsExportAssignment as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsExprWithTypeArgs`.\n\nBy default, this method calls \
             [`TsExprWithTypeArgs::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_expr_with_type_args(
        &mut self,
        node: &mut TsExprWithTypeArgs,
        ast_path: &mut AstKindPath,
    ) {
        <TsExprWithTypeArgs as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < TsExprWithTypeArgs >`.\n\nBy default, this method calls \
             [`Vec < TsExprWithTypeArgs >::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_ts_expr_with_type_argss(
        &mut self,
        node: &mut Vec<TsExprWithTypeArgs>,
        ast_path: &mut AstKindPath,
    ) {
        <Vec<TsExprWithTypeArgs> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsExternalModuleRef`.\n\nBy default, this method calls \
             [`TsExternalModuleRef::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_mut_ts_external_module_ref(
        &mut self,
        node: &mut TsExternalModuleRef,
        ast_path: &mut AstKindPath,
    ) {
        <TsExternalModuleRef as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsFnOrConstructorType`.\n\nBy default, this method calls \
             [`TsFnOrConstructorType::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_mut_ts_fn_or_constructor_type(
        &mut self,
        node: &mut TsFnOrConstructorType,
        ast_path: &mut AstKindPath,
    ) {
        <TsFnOrConstructorType as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsFnParam`.\n\nBy default, this method calls \
             [`TsFnParam::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_fn_param(&mut self, node: &mut TsFnParam, ast_path: &mut AstKindPath) {
        <TsFnParam as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < TsFnParam >`.\n\nBy default, this method calls [`Vec < \
             TsFnParam >::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_fn_params(&mut self, node: &mut Vec<TsFnParam>, ast_path: &mut AstKindPath) {
        <Vec<TsFnParam> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsFnType`.\n\nBy default, this method calls \
             [`TsFnType::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_fn_type(&mut self, node: &mut TsFnType, ast_path: &mut AstKindPath) {
        <TsFnType as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsGetterSignature`.\n\nBy default, this method calls \
             [`TsGetterSignature::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_getter_signature(
        &mut self,
        node: &mut TsGetterSignature,
        ast_path: &mut AstKindPath,
    ) {
        <TsGetterSignature as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsImportEqualsDecl`.\n\nBy default, this method calls \
             [`TsImportEqualsDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_import_equals_decl(
        &mut self,
        node: &mut TsImportEqualsDecl,
        ast_path: &mut AstKindPath,
    ) {
        <TsImportEqualsDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsImportType`.\n\nBy default, this method calls \
             [`TsImportType::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_import_type(&mut self, node: &mut TsImportType, ast_path: &mut AstKindPath) {
        <TsImportType as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsIndexSignature`.\n\nBy default, this method calls \
             [`TsIndexSignature::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_index_signature(
        &mut self,
        node: &mut TsIndexSignature,
        ast_path: &mut AstKindPath,
    ) {
        <TsIndexSignature as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsIndexedAccessType`.\n\nBy default, this method calls \
             [`TsIndexedAccessType::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_mut_ts_indexed_access_type(
        &mut self,
        node: &mut TsIndexedAccessType,
        ast_path: &mut AstKindPath,
    ) {
        <TsIndexedAccessType as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsInferType`.\n\nBy default, this method calls \
             [`TsInferType::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_infer_type(&mut self, node: &mut TsInferType, ast_path: &mut AstKindPath) {
        <TsInferType as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsInstantiation`.\n\nBy default, this method calls \
             [`TsInstantiation::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_instantiation(
        &mut self,
        node: &mut TsInstantiation,
        ast_path: &mut AstKindPath,
    ) {
        <TsInstantiation as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsInterfaceBody`.\n\nBy default, this method calls \
             [`TsInterfaceBody::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_interface_body(
        &mut self,
        node: &mut TsInterfaceBody,
        ast_path: &mut AstKindPath,
    ) {
        <TsInterfaceBody as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsInterfaceDecl`.\n\nBy default, this method calls \
             [`TsInterfaceDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_interface_decl(
        &mut self,
        node: &mut TsInterfaceDecl,
        ast_path: &mut AstKindPath,
    ) {
        <TsInterfaceDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsIntersectionType`.\n\nBy default, this method calls \
             [`TsIntersectionType::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_intersection_type(
        &mut self,
        node: &mut TsIntersectionType,
        ast_path: &mut AstKindPath,
    ) {
        <TsIntersectionType as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsKeywordType`.\n\nBy default, this method calls \
             [`TsKeywordType::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_keyword_type(&mut self, node: &mut TsKeywordType, ast_path: &mut AstKindPath) {
        <TsKeywordType as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsKeywordTypeKind`.\n\nBy default, this method calls \
             [`TsKeywordTypeKind::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_keyword_type_kind(
        &mut self,
        node: &mut TsKeywordTypeKind,
        ast_path: &mut AstKindPath,
    ) {
        <TsKeywordTypeKind as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsLit`.\n\nBy default, this method calls \
             [`TsLit::visit_mut_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn visit_mut_ts_lit(&mut self, node: &mut TsLit, ast_path: &mut AstKindPath) {
        <TsLit as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsLitType`.\n\nBy default, this method calls \
             [`TsLitType::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_lit_type(&mut self, node: &mut TsLitType, ast_path: &mut AstKindPath) {
        <TsLitType as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsMappedType`.\n\nBy default, this method calls \
             [`TsMappedType::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_mapped_type(&mut self, node: &mut TsMappedType, ast_path: &mut AstKindPath) {
        <TsMappedType as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsMethodSignature`.\n\nBy default, this method calls \
             [`TsMethodSignature::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_method_signature(
        &mut self,
        node: &mut TsMethodSignature,
        ast_path: &mut AstKindPath,
    ) {
        <TsMethodSignature as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsModuleBlock`.\n\nBy default, this method calls \
             [`TsModuleBlock::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_module_block(&mut self, node: &mut TsModuleBlock, ast_path: &mut AstKindPath) {
        <TsModuleBlock as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsModuleDecl`.\n\nBy default, this method calls \
             [`TsModuleDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_module_decl(&mut self, node: &mut TsModuleDecl, ast_path: &mut AstKindPath) {
        <TsModuleDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsModuleName`.\n\nBy default, this method calls \
             [`TsModuleName::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_module_name(&mut self, node: &mut TsModuleName, ast_path: &mut AstKindPath) {
        <TsModuleName as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsModuleRef`.\n\nBy default, this method calls \
             [`TsModuleRef::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_module_ref(&mut self, node: &mut TsModuleRef, ast_path: &mut AstKindPath) {
        <TsModuleRef as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsNamespaceBody`.\n\nBy default, this method calls \
             [`TsNamespaceBody::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_namespace_body(
        &mut self,
        node: &mut TsNamespaceBody,
        ast_path: &mut AstKindPath,
    ) {
        <TsNamespaceBody as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsNamespaceDecl`.\n\nBy default, this method calls \
             [`TsNamespaceDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_namespace_decl(
        &mut self,
        node: &mut TsNamespaceDecl,
        ast_path: &mut AstKindPath,
    ) {
        <TsNamespaceDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsNamespaceExportDecl`.\n\nBy default, this method calls \
             [`TsNamespaceExportDecl::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_mut_ts_namespace_export_decl(
        &mut self,
        node: &mut TsNamespaceExportDecl,
        ast_path: &mut AstKindPath,
    ) {
        <TsNamespaceExportDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsNonNullExpr`.\n\nBy default, this method calls \
             [`TsNonNullExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_non_null_expr(&mut self, node: &mut TsNonNullExpr, ast_path: &mut AstKindPath) {
        <TsNonNullExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsOptionalType`.\n\nBy default, this method calls \
             [`TsOptionalType::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_optional_type(
        &mut self,
        node: &mut TsOptionalType,
        ast_path: &mut AstKindPath,
    ) {
        <TsOptionalType as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsParamProp`.\n\nBy default, this method calls \
             [`TsParamProp::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_param_prop(&mut self, node: &mut TsParamProp, ast_path: &mut AstKindPath) {
        <TsParamProp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsParamPropParam`.\n\nBy default, this method calls \
             [`TsParamPropParam::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_param_prop_param(
        &mut self,
        node: &mut TsParamPropParam,
        ast_path: &mut AstKindPath,
    ) {
        <TsParamPropParam as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsParenthesizedType`.\n\nBy default, this method calls \
             [`TsParenthesizedType::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_mut_ts_parenthesized_type(
        &mut self,
        node: &mut TsParenthesizedType,
        ast_path: &mut AstKindPath,
    ) {
        <TsParenthesizedType as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsPropertySignature`.\n\nBy default, this method calls \
             [`TsPropertySignature::visit_mut_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn visit_mut_ts_property_signature(
        &mut self,
        node: &mut TsPropertySignature,
        ast_path: &mut AstKindPath,
    ) {
        <TsPropertySignature as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsQualifiedName`.\n\nBy default, this method calls \
             [`TsQualifiedName::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_qualified_name(
        &mut self,
        node: &mut TsQualifiedName,
        ast_path: &mut AstKindPath,
    ) {
        <TsQualifiedName as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsRestType`.\n\nBy default, this method calls \
             [`TsRestType::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_rest_type(&mut self, node: &mut TsRestType, ast_path: &mut AstKindPath) {
        <TsRestType as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsSatisfiesExpr`.\n\nBy default, this method calls \
             [`TsSatisfiesExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_satisfies_expr(
        &mut self,
        node: &mut TsSatisfiesExpr,
        ast_path: &mut AstKindPath,
    ) {
        <TsSatisfiesExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsSetterSignature`.\n\nBy default, this method calls \
             [`TsSetterSignature::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_setter_signature(
        &mut self,
        node: &mut TsSetterSignature,
        ast_path: &mut AstKindPath,
    ) {
        <TsSetterSignature as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsThisType`.\n\nBy default, this method calls \
             [`TsThisType::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_this_type(&mut self, node: &mut TsThisType, ast_path: &mut AstKindPath) {
        <TsThisType as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsThisTypeOrIdent`.\n\nBy default, this method calls \
             [`TsThisTypeOrIdent::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_this_type_or_ident(
        &mut self,
        node: &mut TsThisTypeOrIdent,
        ast_path: &mut AstKindPath,
    ) {
        <TsThisTypeOrIdent as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTplLitType`.\n\nBy default, this method calls \
             [`TsTplLitType::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_tpl_lit_type(&mut self, node: &mut TsTplLitType, ast_path: &mut AstKindPath) {
        <TsTplLitType as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTupleElement`.\n\nBy default, this method calls \
             [`TsTupleElement::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_tuple_element(
        &mut self,
        node: &mut TsTupleElement,
        ast_path: &mut AstKindPath,
    ) {
        <TsTupleElement as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < TsTupleElement >`.\n\nBy default, this method calls [`Vec \
             < TsTupleElement >::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_tuple_elements(
        &mut self,
        node: &mut Vec<TsTupleElement>,
        ast_path: &mut AstKindPath,
    ) {
        <Vec<TsTupleElement> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTupleType`.\n\nBy default, this method calls \
             [`TsTupleType::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_tuple_type(&mut self, node: &mut TsTupleType, ast_path: &mut AstKindPath) {
        <TsTupleType as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsType`.\n\nBy default, this method calls \
             [`TsType::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_type(&mut self, node: &mut TsType, ast_path: &mut AstKindPath) {
        <TsType as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeAliasDecl`.\n\nBy default, this method calls \
             [`TsTypeAliasDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_type_alias_decl(
        &mut self,
        node: &mut TsTypeAliasDecl,
        ast_path: &mut AstKindPath,
    ) {
        <TsTypeAliasDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeAnn`.\n\nBy default, this method calls \
             [`TsTypeAnn::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_type_ann(&mut self, node: &mut TsTypeAnn, ast_path: &mut AstKindPath) {
        <TsTypeAnn as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeAssertion`.\n\nBy default, this method calls \
             [`TsTypeAssertion::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_type_assertion(
        &mut self,
        node: &mut TsTypeAssertion,
        ast_path: &mut AstKindPath,
    ) {
        <TsTypeAssertion as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeElement`.\n\nBy default, this method calls \
             [`TsTypeElement::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_type_element(&mut self, node: &mut TsTypeElement, ast_path: &mut AstKindPath) {
        <TsTypeElement as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < TsTypeElement >`.\n\nBy default, this method calls [`Vec \
             < TsTypeElement >::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_type_elements(
        &mut self,
        node: &mut Vec<TsTypeElement>,
        ast_path: &mut AstKindPath,
    ) {
        <Vec<TsTypeElement> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeLit`.\n\nBy default, this method calls \
             [`TsTypeLit::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_type_lit(&mut self, node: &mut TsTypeLit, ast_path: &mut AstKindPath) {
        <TsTypeLit as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeOperator`.\n\nBy default, this method calls \
             [`TsTypeOperator::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_type_operator(
        &mut self,
        node: &mut TsTypeOperator,
        ast_path: &mut AstKindPath,
    ) {
        <TsTypeOperator as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeOperatorOp`.\n\nBy default, this method calls \
             [`TsTypeOperatorOp::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_type_operator_op(
        &mut self,
        node: &mut TsTypeOperatorOp,
        ast_path: &mut AstKindPath,
    ) {
        <TsTypeOperatorOp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeParam`.\n\nBy default, this method calls \
             [`TsTypeParam::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_type_param(&mut self, node: &mut TsTypeParam, ast_path: &mut AstKindPath) {
        <TsTypeParam as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeParamDecl`.\n\nBy default, this method calls \
             [`TsTypeParamDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_type_param_decl(
        &mut self,
        node: &mut TsTypeParamDecl,
        ast_path: &mut AstKindPath,
    ) {
        <TsTypeParamDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeParamInstantiation`.\n\nBy default, this method calls \
             [`TsTypeParamInstantiation::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_ts_type_param_instantiation(
        &mut self,
        node: &mut TsTypeParamInstantiation,
        ast_path: &mut AstKindPath,
    ) {
        <TsTypeParamInstantiation as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < TsTypeParam >`.\n\nBy default, this method calls [`Vec < \
             TsTypeParam >::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_type_params(
        &mut self,
        node: &mut Vec<TsTypeParam>,
        ast_path: &mut AstKindPath,
    ) {
        <Vec<TsTypeParam> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypePredicate`.\n\nBy default, this method calls \
             [`TsTypePredicate::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_type_predicate(
        &mut self,
        node: &mut TsTypePredicate,
        ast_path: &mut AstKindPath,
    ) {
        <TsTypePredicate as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeQuery`.\n\nBy default, this method calls \
             [`TsTypeQuery::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_type_query(&mut self, node: &mut TsTypeQuery, ast_path: &mut AstKindPath) {
        <TsTypeQuery as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeQueryExpr`.\n\nBy default, this method calls \
             [`TsTypeQueryExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_type_query_expr(
        &mut self,
        node: &mut TsTypeQueryExpr,
        ast_path: &mut AstKindPath,
    ) {
        <TsTypeQueryExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeRef`.\n\nBy default, this method calls \
             [`TsTypeRef::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_ts_type_ref(&mut self, node: &mut TsTypeRef, ast_path: &mut AstKindPath) {
        <TsTypeRef as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Box < TsType > >`.\n\nBy default, this method calls [`Vec \
             < Box < TsType > >::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_ts_types(&mut self, node: &mut Vec<Box<TsType>>, ast_path: &mut AstKindPath) {
        <Vec<Box<TsType>> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsUnionOrIntersectionType`.\n\nBy default, this method calls \
             [`TsUnionOrIntersectionType::visit_mut_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn visit_mut_ts_union_or_intersection_type(
        &mut self,
        node: &mut TsUnionOrIntersectionType,
        ast_path: &mut AstKindPath,
    ) {
        <TsUnionOrIntersectionType as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsUnionType`.\n\nBy default, this method calls \
             [`TsUnionType::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_ts_union_type(&mut self, node: &mut TsUnionType, ast_path: &mut AstKindPath) {
        <TsUnionType as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `UnaryExpr`.\n\nBy default, this method calls \
             [`UnaryExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_unary_expr(&mut self, node: &mut UnaryExpr, ast_path: &mut AstKindPath) {
        <UnaryExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `UnaryOp`.\n\nBy default, this method calls \
             [`UnaryOp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_unary_op(&mut self, node: &mut UnaryOp, ast_path: &mut AstKindPath) {
        <UnaryOp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `UpdateExpr`.\n\nBy default, this method calls \
             [`UpdateExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_update_expr(&mut self, node: &mut UpdateExpr, ast_path: &mut AstKindPath) {
        <UpdateExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `UpdateOp`.\n\nBy default, this method calls \
             [`UpdateOp::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_update_op(&mut self, node: &mut UpdateOp, ast_path: &mut AstKindPath) {
        <UpdateOp as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `UsingDecl`.\n\nBy default, this method calls \
             [`UsingDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_using_decl(&mut self, node: &mut UsingDecl, ast_path: &mut AstKindPath) {
        <UsingDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `VarDecl`.\n\nBy default, this method calls \
             [`VarDecl::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_var_decl(&mut self, node: &mut VarDecl, ast_path: &mut AstKindPath) {
        <VarDecl as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `VarDeclKind`.\n\nBy default, this method calls \
             [`VarDeclKind::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_var_decl_kind(&mut self, node: &mut VarDeclKind, ast_path: &mut AstKindPath) {
        <VarDeclKind as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `VarDeclOrExpr`.\n\nBy default, this method calls \
             [`VarDeclOrExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_var_decl_or_expr(&mut self, node: &mut VarDeclOrExpr, ast_path: &mut AstKindPath) {
        <VarDeclOrExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `VarDeclarator`.\n\nBy default, this method calls \
             [`VarDeclarator::visit_mut_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn visit_mut_var_declarator(&mut self, node: &mut VarDeclarator, ast_path: &mut AstKindPath) {
        <VarDeclarator as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < VarDeclarator >`.\n\nBy default, this method calls [`Vec \
             < VarDeclarator >::visit_mut_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn visit_mut_var_declarators(
        &mut self,
        node: &mut Vec<VarDeclarator>,
        ast_path: &mut AstKindPath,
    ) {
        <Vec<VarDeclarator> as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `WhileStmt`.\n\nBy default, this method calls \
             [`WhileStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_while_stmt(&mut self, node: &mut WhileStmt, ast_path: &mut AstKindPath) {
        <WhileStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `WithStmt`.\n\nBy default, this method calls \
             [`WithStmt::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_with_stmt(&mut self, node: &mut WithStmt, ast_path: &mut AstKindPath) {
        <WithStmt as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `YieldExpr`.\n\nBy default, this method calls \
             [`YieldExpr::visit_mut_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn visit_mut_yield_expr(&mut self, node: &mut YieldExpr, ast_path: &mut AstKindPath) {
        <YieldExpr as VisitMutWithAstPath<Self>>::visit_mut_children_with_ast_path(
            node, self, ast_path,
        )
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> VisitMutAstPath for &mut V
where
    V: ?Sized + VisitMutAstPath,
{
    fn visit_mut_accessibility(&mut self, node: &mut Accessibility, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_accessibility(&mut **self, node, ast_path)
    }

    fn visit_mut_array_lit(&mut self, node: &mut ArrayLit, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_array_lit(&mut **self, node, ast_path)
    }

    fn visit_mut_array_pat(&mut self, node: &mut ArrayPat, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_array_pat(&mut **self, node, ast_path)
    }

    fn visit_mut_arrow_expr(&mut self, node: &mut ArrowExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_arrow_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_assign_expr(&mut self, node: &mut AssignExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_assign_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_assign_op(&mut self, node: &mut AssignOp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_assign_op(&mut **self, node, ast_path)
    }

    fn visit_mut_assign_pat(&mut self, node: &mut AssignPat, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_assign_pat(&mut **self, node, ast_path)
    }

    fn visit_mut_assign_pat_prop(&mut self, node: &mut AssignPatProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_assign_pat_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_assign_prop(&mut self, node: &mut AssignProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_assign_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_assign_target(&mut self, node: &mut AssignTarget, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_assign_target(&mut **self, node, ast_path)
    }

    fn visit_mut_assign_target_pat(
        &mut self,
        node: &mut AssignTargetPat,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_assign_target_pat(&mut **self, node, ast_path)
    }

    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_atom(&mut **self, node, ast_path)
    }

    fn visit_mut_auto_accessor(&mut self, node: &mut AutoAccessor, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_auto_accessor(&mut **self, node, ast_path)
    }

    fn visit_mut_await_expr(&mut self, node: &mut AwaitExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_await_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_big_int(&mut self, node: &mut BigInt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_big_int(&mut **self, node, ast_path)
    }

    fn visit_mut_big_int_value(&mut self, node: &mut BigIntValue, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_big_int_value(&mut **self, node, ast_path)
    }

    fn visit_mut_bin_expr(&mut self, node: &mut BinExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_bin_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_binary_op(&mut self, node: &mut BinaryOp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_binary_op(&mut **self, node, ast_path)
    }

    fn visit_mut_binding_ident(&mut self, node: &mut BindingIdent, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_binding_ident(&mut **self, node, ast_path)
    }

    fn visit_mut_block_stmt(&mut self, node: &mut BlockStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_block_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_block_stmt_or_expr(
        &mut self,
        node: &mut BlockStmtOrExpr,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_block_stmt_or_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_bool(&mut self, node: &mut Bool, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_bool(&mut **self, node, ast_path)
    }

    fn visit_mut_break_stmt(&mut self, node: &mut BreakStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_break_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_call_expr(&mut self, node: &mut CallExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_call_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_callee(&mut self, node: &mut Callee, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_callee(&mut **self, node, ast_path)
    }

    fn visit_mut_catch_clause(&mut self, node: &mut CatchClause, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_catch_clause(&mut **self, node, ast_path)
    }

    fn visit_mut_class(&mut self, node: &mut Class, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_class(&mut **self, node, ast_path)
    }

    fn visit_mut_class_decl(&mut self, node: &mut ClassDecl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_class_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_class_expr(&mut self, node: &mut ClassExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_class_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_class_member(&mut self, node: &mut ClassMember, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_class_member(&mut **self, node, ast_path)
    }

    fn visit_mut_class_members(&mut self, node: &mut Vec<ClassMember>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_class_members(&mut **self, node, ast_path)
    }

    fn visit_mut_class_method(&mut self, node: &mut ClassMethod, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_class_method(&mut **self, node, ast_path)
    }

    fn visit_mut_class_prop(&mut self, node: &mut ClassProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_class_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_computed_prop_name(
        &mut self,
        node: &mut ComputedPropName,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_computed_prop_name(&mut **self, node, ast_path)
    }

    fn visit_mut_cond_expr(&mut self, node: &mut CondExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_cond_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_constructor(&mut self, node: &mut Constructor, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_constructor(&mut **self, node, ast_path)
    }

    fn visit_mut_continue_stmt(&mut self, node: &mut ContinueStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_continue_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_debugger_stmt(&mut self, node: &mut DebuggerStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_debugger_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_decl(&mut self, node: &mut Decl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_decorator(&mut self, node: &mut Decorator, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_decorator(&mut **self, node, ast_path)
    }

    fn visit_mut_decorators(&mut self, node: &mut Vec<Decorator>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_decorators(&mut **self, node, ast_path)
    }

    fn visit_mut_default_decl(&mut self, node: &mut DefaultDecl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_default_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_do_while_stmt(&mut self, node: &mut DoWhileStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_do_while_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_empty_stmt(&mut self, node: &mut EmptyStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_empty_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_es_version(&mut self, node: &mut EsVersion, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_es_version(&mut **self, node, ast_path)
    }

    fn visit_mut_export_all(&mut self, node: &mut ExportAll, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_export_all(&mut **self, node, ast_path)
    }

    fn visit_mut_export_decl(&mut self, node: &mut ExportDecl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_export_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_export_default_decl(
        &mut self,
        node: &mut ExportDefaultDecl,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_export_default_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_export_default_expr(
        &mut self,
        node: &mut ExportDefaultExpr,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_export_default_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_export_default_specifier(
        &mut self,
        node: &mut ExportDefaultSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_export_default_specifier(&mut **self, node, ast_path)
    }

    fn visit_mut_export_named_specifier(
        &mut self,
        node: &mut ExportNamedSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_export_named_specifier(&mut **self, node, ast_path)
    }

    fn visit_mut_export_namespace_specifier(
        &mut self,
        node: &mut ExportNamespaceSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_export_namespace_specifier(&mut **self, node, ast_path)
    }

    fn visit_mut_export_specifier(
        &mut self,
        node: &mut ExportSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_export_specifier(&mut **self, node, ast_path)
    }

    fn visit_mut_export_specifiers(
        &mut self,
        node: &mut Vec<ExportSpecifier>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_export_specifiers(&mut **self, node, ast_path)
    }

    fn visit_mut_expr(&mut self, node: &mut Expr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_expr_or_spread(&mut self, node: &mut ExprOrSpread, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_expr_or_spread(&mut **self, node, ast_path)
    }

    fn visit_mut_expr_or_spreads(
        &mut self,
        node: &mut Vec<ExprOrSpread>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_expr_or_spreads(&mut **self, node, ast_path)
    }

    fn visit_mut_expr_stmt(&mut self, node: &mut ExprStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_expr_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_exprs(&mut self, node: &mut Vec<Box<Expr>>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_exprs(&mut **self, node, ast_path)
    }

    fn visit_mut_fn_decl(&mut self, node: &mut FnDecl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_fn_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_fn_expr(&mut self, node: &mut FnExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_fn_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_for_head(&mut self, node: &mut ForHead, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_for_head(&mut **self, node, ast_path)
    }

    fn visit_mut_for_in_stmt(&mut self, node: &mut ForInStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_for_in_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_for_of_stmt(&mut self, node: &mut ForOfStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_for_of_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_for_stmt(&mut self, node: &mut ForStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_for_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_function(&mut self, node: &mut Function, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_function(&mut **self, node, ast_path)
    }

    fn visit_mut_getter_prop(&mut self, node: &mut GetterProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_getter_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_ident(&mut self, node: &mut Ident, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ident(&mut **self, node, ast_path)
    }

    fn visit_mut_ident_name(&mut self, node: &mut IdentName, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ident_name(&mut **self, node, ast_path)
    }

    fn visit_mut_if_stmt(&mut self, node: &mut IfStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_if_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_import(&mut self, node: &mut Import, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_import(&mut **self, node, ast_path)
    }

    fn visit_mut_import_decl(&mut self, node: &mut ImportDecl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_import_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_import_default_specifier(
        &mut self,
        node: &mut ImportDefaultSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_import_default_specifier(&mut **self, node, ast_path)
    }

    fn visit_mut_import_named_specifier(
        &mut self,
        node: &mut ImportNamedSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_import_named_specifier(&mut **self, node, ast_path)
    }

    fn visit_mut_import_phase(&mut self, node: &mut ImportPhase, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_import_phase(&mut **self, node, ast_path)
    }

    fn visit_mut_import_specifier(
        &mut self,
        node: &mut ImportSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_import_specifier(&mut **self, node, ast_path)
    }

    fn visit_mut_import_specifiers(
        &mut self,
        node: &mut Vec<ImportSpecifier>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_import_specifiers(&mut **self, node, ast_path)
    }

    fn visit_mut_import_star_as_specifier(
        &mut self,
        node: &mut ImportStarAsSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_import_star_as_specifier(&mut **self, node, ast_path)
    }

    fn visit_mut_import_with(&mut self, node: &mut ImportWith, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_import_with(&mut **self, node, ast_path)
    }

    fn visit_mut_import_with_item(
        &mut self,
        node: &mut ImportWithItem,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_import_with_item(&mut **self, node, ast_path)
    }

    fn visit_mut_import_with_items(
        &mut self,
        node: &mut Vec<ImportWithItem>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_import_with_items(&mut **self, node, ast_path)
    }

    fn visit_mut_invalid(&mut self, node: &mut Invalid, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_invalid(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_attr(&mut self, node: &mut JSXAttr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_jsx_attr(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_attr_name(&mut self, node: &mut JSXAttrName, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_jsx_attr_name(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_attr_or_spread(
        &mut self,
        node: &mut JSXAttrOrSpread,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_attr_or_spread(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_attr_or_spreads(
        &mut self,
        node: &mut Vec<JSXAttrOrSpread>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_attr_or_spreads(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_attr_value(&mut self, node: &mut JSXAttrValue, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_jsx_attr_value(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_closing_element(
        &mut self,
        node: &mut JSXClosingElement,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_closing_element(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_closing_fragment(
        &mut self,
        node: &mut JSXClosingFragment,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_closing_fragment(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_element(&mut self, node: &mut JSXElement, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_jsx_element(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_element_child(
        &mut self,
        node: &mut JSXElementChild,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_element_child(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_element_childs(
        &mut self,
        node: &mut Vec<JSXElementChild>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_element_childs(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_element_name(
        &mut self,
        node: &mut JSXElementName,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_element_name(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_empty_expr(&mut self, node: &mut JSXEmptyExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_jsx_empty_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_expr(&mut self, node: &mut JSXExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_jsx_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_expr_container(
        &mut self,
        node: &mut JSXExprContainer,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_expr_container(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_fragment(&mut self, node: &mut JSXFragment, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_jsx_fragment(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_member_expr(&mut self, node: &mut JSXMemberExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_jsx_member_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_namespaced_name(
        &mut self,
        node: &mut JSXNamespacedName,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_namespaced_name(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_object(&mut self, node: &mut JSXObject, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_jsx_object(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_opening_element(
        &mut self,
        node: &mut JSXOpeningElement,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_opening_element(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_opening_fragment(
        &mut self,
        node: &mut JSXOpeningFragment,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_opening_fragment(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_spread_child(
        &mut self,
        node: &mut JSXSpreadChild,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_spread_child(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_text(&mut self, node: &mut JSXText, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_jsx_text(&mut **self, node, ast_path)
    }

    fn visit_mut_key(&mut self, node: &mut Key, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_key(&mut **self, node, ast_path)
    }

    fn visit_mut_key_value_pat_prop(
        &mut self,
        node: &mut KeyValuePatProp,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_key_value_pat_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_key_value_prop(&mut self, node: &mut KeyValueProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_key_value_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_labeled_stmt(&mut self, node: &mut LabeledStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_labeled_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_lit(&mut self, node: &mut Lit, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_lit(&mut **self, node, ast_path)
    }

    fn visit_mut_member_expr(&mut self, node: &mut MemberExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_member_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_member_prop(&mut self, node: &mut MemberProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_member_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_meta_prop_expr(&mut self, node: &mut MetaPropExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_meta_prop_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_meta_prop_kind(&mut self, node: &mut MetaPropKind, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_meta_prop_kind(&mut **self, node, ast_path)
    }

    fn visit_mut_method_kind(&mut self, node: &mut MethodKind, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_method_kind(&mut **self, node, ast_path)
    }

    fn visit_mut_method_prop(&mut self, node: &mut MethodProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_method_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_module(&mut self, node: &mut Module, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_module(&mut **self, node, ast_path)
    }

    fn visit_mut_module_decl(&mut self, node: &mut ModuleDecl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_module_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_module_export_name(
        &mut self,
        node: &mut ModuleExportName,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_module_export_name(&mut **self, node, ast_path)
    }

    fn visit_mut_module_item(&mut self, node: &mut ModuleItem, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_module_item(&mut **self, node, ast_path)
    }

    fn visit_mut_module_items(&mut self, node: &mut Vec<ModuleItem>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_module_items(&mut **self, node, ast_path)
    }

    fn visit_mut_named_export(&mut self, node: &mut NamedExport, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_named_export(&mut **self, node, ast_path)
    }

    fn visit_mut_new_expr(&mut self, node: &mut NewExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_new_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_null(&mut self, node: &mut Null, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_null(&mut **self, node, ast_path)
    }

    fn visit_mut_number(&mut self, node: &mut Number, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_number(&mut **self, node, ast_path)
    }

    fn visit_mut_object_lit(&mut self, node: &mut ObjectLit, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_object_lit(&mut **self, node, ast_path)
    }

    fn visit_mut_object_pat(&mut self, node: &mut ObjectPat, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_object_pat(&mut **self, node, ast_path)
    }

    fn visit_mut_object_pat_prop(&mut self, node: &mut ObjectPatProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_object_pat_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_object_pat_props(
        &mut self,
        node: &mut Vec<ObjectPatProp>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_object_pat_props(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_accessibility(
        &mut self,
        node: &mut Option<Accessibility>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_accessibility(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_atom(
        &mut self,
        node: &mut Option<swc_atoms::Atom>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_atom(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_block_stmt(
        &mut self,
        node: &mut Option<BlockStmt>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_block_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_call(&mut self, node: &mut OptCall, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_opt_call(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_catch_clause(
        &mut self,
        node: &mut Option<CatchClause>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_catch_clause(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_chain_base(&mut self, node: &mut OptChainBase, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_opt_chain_base(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_chain_expr(&mut self, node: &mut OptChainExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_opt_chain_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_expr(&mut self, node: &mut Option<Box<Expr>>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_opt_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_expr_or_spread(
        &mut self,
        node: &mut Option<ExprOrSpread>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_expr_or_spread(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_expr_or_spreads(
        &mut self,
        node: &mut Option<Vec<ExprOrSpread>>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_expr_or_spreads(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_ident(&mut self, node: &mut Option<Ident>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_opt_ident(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_jsx_attr_value(
        &mut self,
        node: &mut Option<JSXAttrValue>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_jsx_attr_value(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_jsx_closing_element(
        &mut self,
        node: &mut Option<JSXClosingElement>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_jsx_closing_element(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_module_export_name(
        &mut self,
        node: &mut Option<ModuleExportName>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_module_export_name(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_module_items(
        &mut self,
        node: &mut Option<Vec<ModuleItem>>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_module_items(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_object_lit(
        &mut self,
        node: &mut Option<Box<ObjectLit>>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_object_lit(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_pat(&mut self, node: &mut Option<Pat>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_opt_pat(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_span(
        &mut self,
        node: &mut Option<swc_common::Span>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_span(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_stmt(&mut self, node: &mut Option<Box<Stmt>>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_opt_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_str(&mut self, node: &mut Option<Box<Str>>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_opt_str(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_true_plus_minus(
        &mut self,
        node: &mut Option<TruePlusMinus>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_true_plus_minus(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_ts_entity_name(
        &mut self,
        node: &mut Option<TsEntityName>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_ts_entity_name(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_ts_namespace_body(
        &mut self,
        node: &mut Option<TsNamespaceBody>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_ts_namespace_body(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_ts_type(
        &mut self,
        node: &mut Option<Box<TsType>>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_ts_type(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_ts_type_ann(
        &mut self,
        node: &mut Option<Box<TsTypeAnn>>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_ts_type_ann(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_ts_type_param_decl(
        &mut self,
        node: &mut Option<Box<TsTypeParamDecl>>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_ts_type_param_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_ts_type_param_instantiation(
        &mut self,
        node: &mut Option<Box<TsTypeParamInstantiation>>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_ts_type_param_instantiation(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_var_decl_or_expr(
        &mut self,
        node: &mut Option<VarDeclOrExpr>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_var_decl_or_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_vec_expr_or_spreads(
        &mut self,
        node: &mut Vec<Option<ExprOrSpread>>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_vec_expr_or_spreads(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_vec_pats(&mut self, node: &mut Vec<Option<Pat>>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_opt_vec_pats(&mut **self, node, ast_path)
    }

    fn visit_mut_param(&mut self, node: &mut Param, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_param(&mut **self, node, ast_path)
    }

    fn visit_mut_param_or_ts_param_prop(
        &mut self,
        node: &mut ParamOrTsParamProp,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_param_or_ts_param_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_param_or_ts_param_props(
        &mut self,
        node: &mut Vec<ParamOrTsParamProp>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_param_or_ts_param_props(&mut **self, node, ast_path)
    }

    fn visit_mut_params(&mut self, node: &mut Vec<Param>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_params(&mut **self, node, ast_path)
    }

    fn visit_mut_paren_expr(&mut self, node: &mut ParenExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_paren_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_pat(&mut self, node: &mut Pat, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_pat(&mut **self, node, ast_path)
    }

    fn visit_mut_pats(&mut self, node: &mut Vec<Pat>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_pats(&mut **self, node, ast_path)
    }

    fn visit_mut_private_method(&mut self, node: &mut PrivateMethod, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_private_method(&mut **self, node, ast_path)
    }

    fn visit_mut_private_name(&mut self, node: &mut PrivateName, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_private_name(&mut **self, node, ast_path)
    }

    fn visit_mut_private_prop(&mut self, node: &mut PrivateProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_private_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_program(&mut self, node: &mut Program, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_program(&mut **self, node, ast_path)
    }

    fn visit_mut_prop(&mut self, node: &mut Prop, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_prop_name(&mut self, node: &mut PropName, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_prop_name(&mut **self, node, ast_path)
    }

    fn visit_mut_prop_or_spread(&mut self, node: &mut PropOrSpread, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_prop_or_spread(&mut **self, node, ast_path)
    }

    fn visit_mut_prop_or_spreads(
        &mut self,
        node: &mut Vec<PropOrSpread>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_prop_or_spreads(&mut **self, node, ast_path)
    }

    fn visit_mut_regex(&mut self, node: &mut Regex, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_regex(&mut **self, node, ast_path)
    }

    fn visit_mut_reserved_unused(&mut self, node: &mut ReservedUnused, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_reserved_unused(&mut **self, node, ast_path)
    }

    fn visit_mut_rest_pat(&mut self, node: &mut RestPat, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_rest_pat(&mut **self, node, ast_path)
    }

    fn visit_mut_return_stmt(&mut self, node: &mut ReturnStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_return_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_script(&mut self, node: &mut Script, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_script(&mut **self, node, ast_path)
    }

    fn visit_mut_seq_expr(&mut self, node: &mut SeqExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_seq_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_setter_prop(&mut self, node: &mut SetterProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_setter_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_simple_assign_target(
        &mut self,
        node: &mut SimpleAssignTarget,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_simple_assign_target(&mut **self, node, ast_path)
    }

    fn visit_mut_span(&mut self, node: &mut swc_common::Span, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_span(&mut **self, node, ast_path)
    }

    fn visit_mut_spread_element(&mut self, node: &mut SpreadElement, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_spread_element(&mut **self, node, ast_path)
    }

    fn visit_mut_static_block(&mut self, node: &mut StaticBlock, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_static_block(&mut **self, node, ast_path)
    }

    fn visit_mut_stmt(&mut self, node: &mut Stmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_stmts(&mut self, node: &mut Vec<Stmt>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_stmts(&mut **self, node, ast_path)
    }

    fn visit_mut_str(&mut self, node: &mut Str, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_str(&mut **self, node, ast_path)
    }

    fn visit_mut_super(&mut self, node: &mut Super, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_super(&mut **self, node, ast_path)
    }

    fn visit_mut_super_prop(&mut self, node: &mut SuperProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_super_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_super_prop_expr(&mut self, node: &mut SuperPropExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_super_prop_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_switch_case(&mut self, node: &mut SwitchCase, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_switch_case(&mut **self, node, ast_path)
    }

    fn visit_mut_switch_cases(&mut self, node: &mut Vec<SwitchCase>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_switch_cases(&mut **self, node, ast_path)
    }

    fn visit_mut_switch_stmt(&mut self, node: &mut SwitchStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_switch_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_syntax_context(
        &mut self,
        node: &mut swc_common::SyntaxContext,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_syntax_context(&mut **self, node, ast_path)
    }

    fn visit_mut_tagged_tpl(&mut self, node: &mut TaggedTpl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_tagged_tpl(&mut **self, node, ast_path)
    }

    fn visit_mut_this_expr(&mut self, node: &mut ThisExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_this_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_throw_stmt(&mut self, node: &mut ThrowStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_throw_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_tpl(&mut self, node: &mut Tpl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_tpl(&mut **self, node, ast_path)
    }

    fn visit_mut_tpl_element(&mut self, node: &mut TplElement, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_tpl_element(&mut **self, node, ast_path)
    }

    fn visit_mut_tpl_elements(&mut self, node: &mut Vec<TplElement>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_tpl_elements(&mut **self, node, ast_path)
    }

    fn visit_mut_true_plus_minus(&mut self, node: &mut TruePlusMinus, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_true_plus_minus(&mut **self, node, ast_path)
    }

    fn visit_mut_try_stmt(&mut self, node: &mut TryStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_try_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_array_type(&mut self, node: &mut TsArrayType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_array_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_as_expr(&mut self, node: &mut TsAsExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_as_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_call_signature_decl(
        &mut self,
        node: &mut TsCallSignatureDecl,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_call_signature_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_conditional_type(
        &mut self,
        node: &mut TsConditionalType,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_conditional_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_const_assertion(
        &mut self,
        node: &mut TsConstAssertion,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_const_assertion(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_construct_signature_decl(
        &mut self,
        node: &mut TsConstructSignatureDecl,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_construct_signature_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_constructor_type(
        &mut self,
        node: &mut TsConstructorType,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_constructor_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_entity_name(&mut self, node: &mut TsEntityName, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_entity_name(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_enum_decl(&mut self, node: &mut TsEnumDecl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_enum_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_enum_member(&mut self, node: &mut TsEnumMember, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_enum_member(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_enum_member_id(
        &mut self,
        node: &mut TsEnumMemberId,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_enum_member_id(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_enum_members(
        &mut self,
        node: &mut Vec<TsEnumMember>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_enum_members(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_export_assignment(
        &mut self,
        node: &mut TsExportAssignment,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_export_assignment(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_expr_with_type_args(
        &mut self,
        node: &mut TsExprWithTypeArgs,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_expr_with_type_args(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_expr_with_type_argss(
        &mut self,
        node: &mut Vec<TsExprWithTypeArgs>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_expr_with_type_argss(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_external_module_ref(
        &mut self,
        node: &mut TsExternalModuleRef,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_external_module_ref(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_fn_or_constructor_type(
        &mut self,
        node: &mut TsFnOrConstructorType,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_fn_or_constructor_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_fn_param(&mut self, node: &mut TsFnParam, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_fn_param(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_fn_params(&mut self, node: &mut Vec<TsFnParam>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_fn_params(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_fn_type(&mut self, node: &mut TsFnType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_fn_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_getter_signature(
        &mut self,
        node: &mut TsGetterSignature,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_getter_signature(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_import_equals_decl(
        &mut self,
        node: &mut TsImportEqualsDecl,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_import_equals_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_import_type(&mut self, node: &mut TsImportType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_import_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_index_signature(
        &mut self,
        node: &mut TsIndexSignature,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_index_signature(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_indexed_access_type(
        &mut self,
        node: &mut TsIndexedAccessType,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_indexed_access_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_infer_type(&mut self, node: &mut TsInferType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_infer_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_instantiation(
        &mut self,
        node: &mut TsInstantiation,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_instantiation(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_interface_body(
        &mut self,
        node: &mut TsInterfaceBody,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_interface_body(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_interface_decl(
        &mut self,
        node: &mut TsInterfaceDecl,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_interface_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_intersection_type(
        &mut self,
        node: &mut TsIntersectionType,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_intersection_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_keyword_type(&mut self, node: &mut TsKeywordType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_keyword_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_keyword_type_kind(
        &mut self,
        node: &mut TsKeywordTypeKind,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_keyword_type_kind(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_lit(&mut self, node: &mut TsLit, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_lit(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_lit_type(&mut self, node: &mut TsLitType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_lit_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_mapped_type(&mut self, node: &mut TsMappedType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_mapped_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_method_signature(
        &mut self,
        node: &mut TsMethodSignature,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_method_signature(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_module_block(&mut self, node: &mut TsModuleBlock, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_module_block(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_module_decl(&mut self, node: &mut TsModuleDecl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_module_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_module_name(&mut self, node: &mut TsModuleName, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_module_name(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_module_ref(&mut self, node: &mut TsModuleRef, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_module_ref(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_namespace_body(
        &mut self,
        node: &mut TsNamespaceBody,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_namespace_body(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_namespace_decl(
        &mut self,
        node: &mut TsNamespaceDecl,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_namespace_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_namespace_export_decl(
        &mut self,
        node: &mut TsNamespaceExportDecl,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_namespace_export_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_non_null_expr(&mut self, node: &mut TsNonNullExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_non_null_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_optional_type(
        &mut self,
        node: &mut TsOptionalType,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_optional_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_param_prop(&mut self, node: &mut TsParamProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_param_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_param_prop_param(
        &mut self,
        node: &mut TsParamPropParam,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_param_prop_param(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_parenthesized_type(
        &mut self,
        node: &mut TsParenthesizedType,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_parenthesized_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_property_signature(
        &mut self,
        node: &mut TsPropertySignature,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_property_signature(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_qualified_name(
        &mut self,
        node: &mut TsQualifiedName,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_qualified_name(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_rest_type(&mut self, node: &mut TsRestType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_rest_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_satisfies_expr(
        &mut self,
        node: &mut TsSatisfiesExpr,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_satisfies_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_setter_signature(
        &mut self,
        node: &mut TsSetterSignature,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_setter_signature(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_this_type(&mut self, node: &mut TsThisType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_this_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_this_type_or_ident(
        &mut self,
        node: &mut TsThisTypeOrIdent,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_this_type_or_ident(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_tpl_lit_type(&mut self, node: &mut TsTplLitType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_tpl_lit_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_tuple_element(
        &mut self,
        node: &mut TsTupleElement,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_tuple_element(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_tuple_elements(
        &mut self,
        node: &mut Vec<TsTupleElement>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_tuple_elements(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_tuple_type(&mut self, node: &mut TsTupleType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_tuple_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type(&mut self, node: &mut TsType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_alias_decl(
        &mut self,
        node: &mut TsTypeAliasDecl,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_type_alias_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_ann(&mut self, node: &mut TsTypeAnn, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_type_ann(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_assertion(
        &mut self,
        node: &mut TsTypeAssertion,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_type_assertion(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_element(&mut self, node: &mut TsTypeElement, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_type_element(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_elements(
        &mut self,
        node: &mut Vec<TsTypeElement>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_type_elements(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_lit(&mut self, node: &mut TsTypeLit, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_type_lit(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_operator(
        &mut self,
        node: &mut TsTypeOperator,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_type_operator(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_operator_op(
        &mut self,
        node: &mut TsTypeOperatorOp,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_type_operator_op(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_param(&mut self, node: &mut TsTypeParam, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_type_param(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_param_decl(
        &mut self,
        node: &mut TsTypeParamDecl,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_type_param_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_param_instantiation(
        &mut self,
        node: &mut TsTypeParamInstantiation,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_type_param_instantiation(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_params(
        &mut self,
        node: &mut Vec<TsTypeParam>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_type_params(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_predicate(
        &mut self,
        node: &mut TsTypePredicate,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_type_predicate(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_query(&mut self, node: &mut TsTypeQuery, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_type_query(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_query_expr(
        &mut self,
        node: &mut TsTypeQueryExpr,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_type_query_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_ref(&mut self, node: &mut TsTypeRef, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_type_ref(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_types(&mut self, node: &mut Vec<Box<TsType>>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_types(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_union_or_intersection_type(
        &mut self,
        node: &mut TsUnionOrIntersectionType,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_union_or_intersection_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_union_type(&mut self, node: &mut TsUnionType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_union_type(&mut **self, node, ast_path)
    }

    fn visit_mut_unary_expr(&mut self, node: &mut UnaryExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_unary_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_unary_op(&mut self, node: &mut UnaryOp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_unary_op(&mut **self, node, ast_path)
    }

    fn visit_mut_update_expr(&mut self, node: &mut UpdateExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_update_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_update_op(&mut self, node: &mut UpdateOp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_update_op(&mut **self, node, ast_path)
    }

    fn visit_mut_using_decl(&mut self, node: &mut UsingDecl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_using_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_var_decl(&mut self, node: &mut VarDecl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_var_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_var_decl_kind(&mut self, node: &mut VarDeclKind, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_var_decl_kind(&mut **self, node, ast_path)
    }

    fn visit_mut_var_decl_or_expr(&mut self, node: &mut VarDeclOrExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_var_decl_or_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_var_declarator(&mut self, node: &mut VarDeclarator, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_var_declarator(&mut **self, node, ast_path)
    }

    fn visit_mut_var_declarators(
        &mut self,
        node: &mut Vec<VarDeclarator>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_var_declarators(&mut **self, node, ast_path)
    }

    fn visit_mut_while_stmt(&mut self, node: &mut WhileStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_while_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_with_stmt(&mut self, node: &mut WithStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_with_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_yield_expr(&mut self, node: &mut YieldExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_yield_expr(&mut **self, node, ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> VisitMutAstPath for Box<V>
where
    V: ?Sized + VisitMutAstPath,
{
    fn visit_mut_accessibility(&mut self, node: &mut Accessibility, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_accessibility(&mut **self, node, ast_path)
    }

    fn visit_mut_array_lit(&mut self, node: &mut ArrayLit, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_array_lit(&mut **self, node, ast_path)
    }

    fn visit_mut_array_pat(&mut self, node: &mut ArrayPat, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_array_pat(&mut **self, node, ast_path)
    }

    fn visit_mut_arrow_expr(&mut self, node: &mut ArrowExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_arrow_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_assign_expr(&mut self, node: &mut AssignExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_assign_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_assign_op(&mut self, node: &mut AssignOp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_assign_op(&mut **self, node, ast_path)
    }

    fn visit_mut_assign_pat(&mut self, node: &mut AssignPat, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_assign_pat(&mut **self, node, ast_path)
    }

    fn visit_mut_assign_pat_prop(&mut self, node: &mut AssignPatProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_assign_pat_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_assign_prop(&mut self, node: &mut AssignProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_assign_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_assign_target(&mut self, node: &mut AssignTarget, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_assign_target(&mut **self, node, ast_path)
    }

    fn visit_mut_assign_target_pat(
        &mut self,
        node: &mut AssignTargetPat,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_assign_target_pat(&mut **self, node, ast_path)
    }

    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_atom(&mut **self, node, ast_path)
    }

    fn visit_mut_auto_accessor(&mut self, node: &mut AutoAccessor, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_auto_accessor(&mut **self, node, ast_path)
    }

    fn visit_mut_await_expr(&mut self, node: &mut AwaitExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_await_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_big_int(&mut self, node: &mut BigInt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_big_int(&mut **self, node, ast_path)
    }

    fn visit_mut_big_int_value(&mut self, node: &mut BigIntValue, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_big_int_value(&mut **self, node, ast_path)
    }

    fn visit_mut_bin_expr(&mut self, node: &mut BinExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_bin_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_binary_op(&mut self, node: &mut BinaryOp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_binary_op(&mut **self, node, ast_path)
    }

    fn visit_mut_binding_ident(&mut self, node: &mut BindingIdent, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_binding_ident(&mut **self, node, ast_path)
    }

    fn visit_mut_block_stmt(&mut self, node: &mut BlockStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_block_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_block_stmt_or_expr(
        &mut self,
        node: &mut BlockStmtOrExpr,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_block_stmt_or_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_bool(&mut self, node: &mut Bool, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_bool(&mut **self, node, ast_path)
    }

    fn visit_mut_break_stmt(&mut self, node: &mut BreakStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_break_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_call_expr(&mut self, node: &mut CallExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_call_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_callee(&mut self, node: &mut Callee, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_callee(&mut **self, node, ast_path)
    }

    fn visit_mut_catch_clause(&mut self, node: &mut CatchClause, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_catch_clause(&mut **self, node, ast_path)
    }

    fn visit_mut_class(&mut self, node: &mut Class, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_class(&mut **self, node, ast_path)
    }

    fn visit_mut_class_decl(&mut self, node: &mut ClassDecl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_class_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_class_expr(&mut self, node: &mut ClassExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_class_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_class_member(&mut self, node: &mut ClassMember, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_class_member(&mut **self, node, ast_path)
    }

    fn visit_mut_class_members(&mut self, node: &mut Vec<ClassMember>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_class_members(&mut **self, node, ast_path)
    }

    fn visit_mut_class_method(&mut self, node: &mut ClassMethod, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_class_method(&mut **self, node, ast_path)
    }

    fn visit_mut_class_prop(&mut self, node: &mut ClassProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_class_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_computed_prop_name(
        &mut self,
        node: &mut ComputedPropName,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_computed_prop_name(&mut **self, node, ast_path)
    }

    fn visit_mut_cond_expr(&mut self, node: &mut CondExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_cond_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_constructor(&mut self, node: &mut Constructor, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_constructor(&mut **self, node, ast_path)
    }

    fn visit_mut_continue_stmt(&mut self, node: &mut ContinueStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_continue_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_debugger_stmt(&mut self, node: &mut DebuggerStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_debugger_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_decl(&mut self, node: &mut Decl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_decorator(&mut self, node: &mut Decorator, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_decorator(&mut **self, node, ast_path)
    }

    fn visit_mut_decorators(&mut self, node: &mut Vec<Decorator>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_decorators(&mut **self, node, ast_path)
    }

    fn visit_mut_default_decl(&mut self, node: &mut DefaultDecl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_default_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_do_while_stmt(&mut self, node: &mut DoWhileStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_do_while_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_empty_stmt(&mut self, node: &mut EmptyStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_empty_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_es_version(&mut self, node: &mut EsVersion, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_es_version(&mut **self, node, ast_path)
    }

    fn visit_mut_export_all(&mut self, node: &mut ExportAll, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_export_all(&mut **self, node, ast_path)
    }

    fn visit_mut_export_decl(&mut self, node: &mut ExportDecl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_export_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_export_default_decl(
        &mut self,
        node: &mut ExportDefaultDecl,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_export_default_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_export_default_expr(
        &mut self,
        node: &mut ExportDefaultExpr,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_export_default_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_export_default_specifier(
        &mut self,
        node: &mut ExportDefaultSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_export_default_specifier(&mut **self, node, ast_path)
    }

    fn visit_mut_export_named_specifier(
        &mut self,
        node: &mut ExportNamedSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_export_named_specifier(&mut **self, node, ast_path)
    }

    fn visit_mut_export_namespace_specifier(
        &mut self,
        node: &mut ExportNamespaceSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_export_namespace_specifier(&mut **self, node, ast_path)
    }

    fn visit_mut_export_specifier(
        &mut self,
        node: &mut ExportSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_export_specifier(&mut **self, node, ast_path)
    }

    fn visit_mut_export_specifiers(
        &mut self,
        node: &mut Vec<ExportSpecifier>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_export_specifiers(&mut **self, node, ast_path)
    }

    fn visit_mut_expr(&mut self, node: &mut Expr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_expr_or_spread(&mut self, node: &mut ExprOrSpread, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_expr_or_spread(&mut **self, node, ast_path)
    }

    fn visit_mut_expr_or_spreads(
        &mut self,
        node: &mut Vec<ExprOrSpread>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_expr_or_spreads(&mut **self, node, ast_path)
    }

    fn visit_mut_expr_stmt(&mut self, node: &mut ExprStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_expr_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_exprs(&mut self, node: &mut Vec<Box<Expr>>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_exprs(&mut **self, node, ast_path)
    }

    fn visit_mut_fn_decl(&mut self, node: &mut FnDecl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_fn_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_fn_expr(&mut self, node: &mut FnExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_fn_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_for_head(&mut self, node: &mut ForHead, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_for_head(&mut **self, node, ast_path)
    }

    fn visit_mut_for_in_stmt(&mut self, node: &mut ForInStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_for_in_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_for_of_stmt(&mut self, node: &mut ForOfStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_for_of_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_for_stmt(&mut self, node: &mut ForStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_for_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_function(&mut self, node: &mut Function, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_function(&mut **self, node, ast_path)
    }

    fn visit_mut_getter_prop(&mut self, node: &mut GetterProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_getter_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_ident(&mut self, node: &mut Ident, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ident(&mut **self, node, ast_path)
    }

    fn visit_mut_ident_name(&mut self, node: &mut IdentName, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ident_name(&mut **self, node, ast_path)
    }

    fn visit_mut_if_stmt(&mut self, node: &mut IfStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_if_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_import(&mut self, node: &mut Import, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_import(&mut **self, node, ast_path)
    }

    fn visit_mut_import_decl(&mut self, node: &mut ImportDecl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_import_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_import_default_specifier(
        &mut self,
        node: &mut ImportDefaultSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_import_default_specifier(&mut **self, node, ast_path)
    }

    fn visit_mut_import_named_specifier(
        &mut self,
        node: &mut ImportNamedSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_import_named_specifier(&mut **self, node, ast_path)
    }

    fn visit_mut_import_phase(&mut self, node: &mut ImportPhase, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_import_phase(&mut **self, node, ast_path)
    }

    fn visit_mut_import_specifier(
        &mut self,
        node: &mut ImportSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_import_specifier(&mut **self, node, ast_path)
    }

    fn visit_mut_import_specifiers(
        &mut self,
        node: &mut Vec<ImportSpecifier>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_import_specifiers(&mut **self, node, ast_path)
    }

    fn visit_mut_import_star_as_specifier(
        &mut self,
        node: &mut ImportStarAsSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_import_star_as_specifier(&mut **self, node, ast_path)
    }

    fn visit_mut_import_with(&mut self, node: &mut ImportWith, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_import_with(&mut **self, node, ast_path)
    }

    fn visit_mut_import_with_item(
        &mut self,
        node: &mut ImportWithItem,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_import_with_item(&mut **self, node, ast_path)
    }

    fn visit_mut_import_with_items(
        &mut self,
        node: &mut Vec<ImportWithItem>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_import_with_items(&mut **self, node, ast_path)
    }

    fn visit_mut_invalid(&mut self, node: &mut Invalid, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_invalid(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_attr(&mut self, node: &mut JSXAttr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_jsx_attr(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_attr_name(&mut self, node: &mut JSXAttrName, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_jsx_attr_name(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_attr_or_spread(
        &mut self,
        node: &mut JSXAttrOrSpread,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_attr_or_spread(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_attr_or_spreads(
        &mut self,
        node: &mut Vec<JSXAttrOrSpread>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_attr_or_spreads(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_attr_value(&mut self, node: &mut JSXAttrValue, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_jsx_attr_value(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_closing_element(
        &mut self,
        node: &mut JSXClosingElement,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_closing_element(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_closing_fragment(
        &mut self,
        node: &mut JSXClosingFragment,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_closing_fragment(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_element(&mut self, node: &mut JSXElement, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_jsx_element(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_element_child(
        &mut self,
        node: &mut JSXElementChild,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_element_child(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_element_childs(
        &mut self,
        node: &mut Vec<JSXElementChild>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_element_childs(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_element_name(
        &mut self,
        node: &mut JSXElementName,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_element_name(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_empty_expr(&mut self, node: &mut JSXEmptyExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_jsx_empty_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_expr(&mut self, node: &mut JSXExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_jsx_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_expr_container(
        &mut self,
        node: &mut JSXExprContainer,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_expr_container(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_fragment(&mut self, node: &mut JSXFragment, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_jsx_fragment(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_member_expr(&mut self, node: &mut JSXMemberExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_jsx_member_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_namespaced_name(
        &mut self,
        node: &mut JSXNamespacedName,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_namespaced_name(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_object(&mut self, node: &mut JSXObject, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_jsx_object(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_opening_element(
        &mut self,
        node: &mut JSXOpeningElement,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_opening_element(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_opening_fragment(
        &mut self,
        node: &mut JSXOpeningFragment,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_opening_fragment(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_spread_child(
        &mut self,
        node: &mut JSXSpreadChild,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_jsx_spread_child(&mut **self, node, ast_path)
    }

    fn visit_mut_jsx_text(&mut self, node: &mut JSXText, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_jsx_text(&mut **self, node, ast_path)
    }

    fn visit_mut_key(&mut self, node: &mut Key, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_key(&mut **self, node, ast_path)
    }

    fn visit_mut_key_value_pat_prop(
        &mut self,
        node: &mut KeyValuePatProp,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_key_value_pat_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_key_value_prop(&mut self, node: &mut KeyValueProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_key_value_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_labeled_stmt(&mut self, node: &mut LabeledStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_labeled_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_lit(&mut self, node: &mut Lit, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_lit(&mut **self, node, ast_path)
    }

    fn visit_mut_member_expr(&mut self, node: &mut MemberExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_member_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_member_prop(&mut self, node: &mut MemberProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_member_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_meta_prop_expr(&mut self, node: &mut MetaPropExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_meta_prop_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_meta_prop_kind(&mut self, node: &mut MetaPropKind, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_meta_prop_kind(&mut **self, node, ast_path)
    }

    fn visit_mut_method_kind(&mut self, node: &mut MethodKind, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_method_kind(&mut **self, node, ast_path)
    }

    fn visit_mut_method_prop(&mut self, node: &mut MethodProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_method_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_module(&mut self, node: &mut Module, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_module(&mut **self, node, ast_path)
    }

    fn visit_mut_module_decl(&mut self, node: &mut ModuleDecl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_module_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_module_export_name(
        &mut self,
        node: &mut ModuleExportName,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_module_export_name(&mut **self, node, ast_path)
    }

    fn visit_mut_module_item(&mut self, node: &mut ModuleItem, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_module_item(&mut **self, node, ast_path)
    }

    fn visit_mut_module_items(&mut self, node: &mut Vec<ModuleItem>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_module_items(&mut **self, node, ast_path)
    }

    fn visit_mut_named_export(&mut self, node: &mut NamedExport, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_named_export(&mut **self, node, ast_path)
    }

    fn visit_mut_new_expr(&mut self, node: &mut NewExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_new_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_null(&mut self, node: &mut Null, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_null(&mut **self, node, ast_path)
    }

    fn visit_mut_number(&mut self, node: &mut Number, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_number(&mut **self, node, ast_path)
    }

    fn visit_mut_object_lit(&mut self, node: &mut ObjectLit, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_object_lit(&mut **self, node, ast_path)
    }

    fn visit_mut_object_pat(&mut self, node: &mut ObjectPat, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_object_pat(&mut **self, node, ast_path)
    }

    fn visit_mut_object_pat_prop(&mut self, node: &mut ObjectPatProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_object_pat_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_object_pat_props(
        &mut self,
        node: &mut Vec<ObjectPatProp>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_object_pat_props(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_accessibility(
        &mut self,
        node: &mut Option<Accessibility>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_accessibility(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_atom(
        &mut self,
        node: &mut Option<swc_atoms::Atom>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_atom(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_block_stmt(
        &mut self,
        node: &mut Option<BlockStmt>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_block_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_call(&mut self, node: &mut OptCall, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_opt_call(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_catch_clause(
        &mut self,
        node: &mut Option<CatchClause>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_catch_clause(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_chain_base(&mut self, node: &mut OptChainBase, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_opt_chain_base(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_chain_expr(&mut self, node: &mut OptChainExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_opt_chain_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_expr(&mut self, node: &mut Option<Box<Expr>>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_opt_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_expr_or_spread(
        &mut self,
        node: &mut Option<ExprOrSpread>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_expr_or_spread(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_expr_or_spreads(
        &mut self,
        node: &mut Option<Vec<ExprOrSpread>>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_expr_or_spreads(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_ident(&mut self, node: &mut Option<Ident>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_opt_ident(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_jsx_attr_value(
        &mut self,
        node: &mut Option<JSXAttrValue>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_jsx_attr_value(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_jsx_closing_element(
        &mut self,
        node: &mut Option<JSXClosingElement>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_jsx_closing_element(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_module_export_name(
        &mut self,
        node: &mut Option<ModuleExportName>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_module_export_name(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_module_items(
        &mut self,
        node: &mut Option<Vec<ModuleItem>>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_module_items(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_object_lit(
        &mut self,
        node: &mut Option<Box<ObjectLit>>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_object_lit(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_pat(&mut self, node: &mut Option<Pat>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_opt_pat(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_span(
        &mut self,
        node: &mut Option<swc_common::Span>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_span(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_stmt(&mut self, node: &mut Option<Box<Stmt>>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_opt_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_str(&mut self, node: &mut Option<Box<Str>>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_opt_str(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_true_plus_minus(
        &mut self,
        node: &mut Option<TruePlusMinus>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_true_plus_minus(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_ts_entity_name(
        &mut self,
        node: &mut Option<TsEntityName>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_ts_entity_name(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_ts_namespace_body(
        &mut self,
        node: &mut Option<TsNamespaceBody>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_ts_namespace_body(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_ts_type(
        &mut self,
        node: &mut Option<Box<TsType>>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_ts_type(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_ts_type_ann(
        &mut self,
        node: &mut Option<Box<TsTypeAnn>>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_ts_type_ann(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_ts_type_param_decl(
        &mut self,
        node: &mut Option<Box<TsTypeParamDecl>>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_ts_type_param_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_ts_type_param_instantiation(
        &mut self,
        node: &mut Option<Box<TsTypeParamInstantiation>>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_ts_type_param_instantiation(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_var_decl_or_expr(
        &mut self,
        node: &mut Option<VarDeclOrExpr>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_var_decl_or_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_vec_expr_or_spreads(
        &mut self,
        node: &mut Vec<Option<ExprOrSpread>>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_opt_vec_expr_or_spreads(&mut **self, node, ast_path)
    }

    fn visit_mut_opt_vec_pats(&mut self, node: &mut Vec<Option<Pat>>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_opt_vec_pats(&mut **self, node, ast_path)
    }

    fn visit_mut_param(&mut self, node: &mut Param, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_param(&mut **self, node, ast_path)
    }

    fn visit_mut_param_or_ts_param_prop(
        &mut self,
        node: &mut ParamOrTsParamProp,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_param_or_ts_param_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_param_or_ts_param_props(
        &mut self,
        node: &mut Vec<ParamOrTsParamProp>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_param_or_ts_param_props(&mut **self, node, ast_path)
    }

    fn visit_mut_params(&mut self, node: &mut Vec<Param>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_params(&mut **self, node, ast_path)
    }

    fn visit_mut_paren_expr(&mut self, node: &mut ParenExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_paren_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_pat(&mut self, node: &mut Pat, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_pat(&mut **self, node, ast_path)
    }

    fn visit_mut_pats(&mut self, node: &mut Vec<Pat>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_pats(&mut **self, node, ast_path)
    }

    fn visit_mut_private_method(&mut self, node: &mut PrivateMethod, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_private_method(&mut **self, node, ast_path)
    }

    fn visit_mut_private_name(&mut self, node: &mut PrivateName, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_private_name(&mut **self, node, ast_path)
    }

    fn visit_mut_private_prop(&mut self, node: &mut PrivateProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_private_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_program(&mut self, node: &mut Program, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_program(&mut **self, node, ast_path)
    }

    fn visit_mut_prop(&mut self, node: &mut Prop, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_prop_name(&mut self, node: &mut PropName, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_prop_name(&mut **self, node, ast_path)
    }

    fn visit_mut_prop_or_spread(&mut self, node: &mut PropOrSpread, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_prop_or_spread(&mut **self, node, ast_path)
    }

    fn visit_mut_prop_or_spreads(
        &mut self,
        node: &mut Vec<PropOrSpread>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_prop_or_spreads(&mut **self, node, ast_path)
    }

    fn visit_mut_regex(&mut self, node: &mut Regex, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_regex(&mut **self, node, ast_path)
    }

    fn visit_mut_reserved_unused(&mut self, node: &mut ReservedUnused, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_reserved_unused(&mut **self, node, ast_path)
    }

    fn visit_mut_rest_pat(&mut self, node: &mut RestPat, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_rest_pat(&mut **self, node, ast_path)
    }

    fn visit_mut_return_stmt(&mut self, node: &mut ReturnStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_return_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_script(&mut self, node: &mut Script, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_script(&mut **self, node, ast_path)
    }

    fn visit_mut_seq_expr(&mut self, node: &mut SeqExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_seq_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_setter_prop(&mut self, node: &mut SetterProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_setter_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_simple_assign_target(
        &mut self,
        node: &mut SimpleAssignTarget,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_simple_assign_target(&mut **self, node, ast_path)
    }

    fn visit_mut_span(&mut self, node: &mut swc_common::Span, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_span(&mut **self, node, ast_path)
    }

    fn visit_mut_spread_element(&mut self, node: &mut SpreadElement, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_spread_element(&mut **self, node, ast_path)
    }

    fn visit_mut_static_block(&mut self, node: &mut StaticBlock, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_static_block(&mut **self, node, ast_path)
    }

    fn visit_mut_stmt(&mut self, node: &mut Stmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_stmts(&mut self, node: &mut Vec<Stmt>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_stmts(&mut **self, node, ast_path)
    }

    fn visit_mut_str(&mut self, node: &mut Str, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_str(&mut **self, node, ast_path)
    }

    fn visit_mut_super(&mut self, node: &mut Super, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_super(&mut **self, node, ast_path)
    }

    fn visit_mut_super_prop(&mut self, node: &mut SuperProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_super_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_super_prop_expr(&mut self, node: &mut SuperPropExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_super_prop_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_switch_case(&mut self, node: &mut SwitchCase, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_switch_case(&mut **self, node, ast_path)
    }

    fn visit_mut_switch_cases(&mut self, node: &mut Vec<SwitchCase>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_switch_cases(&mut **self, node, ast_path)
    }

    fn visit_mut_switch_stmt(&mut self, node: &mut SwitchStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_switch_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_syntax_context(
        &mut self,
        node: &mut swc_common::SyntaxContext,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_syntax_context(&mut **self, node, ast_path)
    }

    fn visit_mut_tagged_tpl(&mut self, node: &mut TaggedTpl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_tagged_tpl(&mut **self, node, ast_path)
    }

    fn visit_mut_this_expr(&mut self, node: &mut ThisExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_this_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_throw_stmt(&mut self, node: &mut ThrowStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_throw_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_tpl(&mut self, node: &mut Tpl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_tpl(&mut **self, node, ast_path)
    }

    fn visit_mut_tpl_element(&mut self, node: &mut TplElement, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_tpl_element(&mut **self, node, ast_path)
    }

    fn visit_mut_tpl_elements(&mut self, node: &mut Vec<TplElement>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_tpl_elements(&mut **self, node, ast_path)
    }

    fn visit_mut_true_plus_minus(&mut self, node: &mut TruePlusMinus, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_true_plus_minus(&mut **self, node, ast_path)
    }

    fn visit_mut_try_stmt(&mut self, node: &mut TryStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_try_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_array_type(&mut self, node: &mut TsArrayType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_array_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_as_expr(&mut self, node: &mut TsAsExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_as_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_call_signature_decl(
        &mut self,
        node: &mut TsCallSignatureDecl,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_call_signature_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_conditional_type(
        &mut self,
        node: &mut TsConditionalType,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_conditional_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_const_assertion(
        &mut self,
        node: &mut TsConstAssertion,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_const_assertion(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_construct_signature_decl(
        &mut self,
        node: &mut TsConstructSignatureDecl,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_construct_signature_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_constructor_type(
        &mut self,
        node: &mut TsConstructorType,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_constructor_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_entity_name(&mut self, node: &mut TsEntityName, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_entity_name(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_enum_decl(&mut self, node: &mut TsEnumDecl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_enum_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_enum_member(&mut self, node: &mut TsEnumMember, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_enum_member(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_enum_member_id(
        &mut self,
        node: &mut TsEnumMemberId,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_enum_member_id(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_enum_members(
        &mut self,
        node: &mut Vec<TsEnumMember>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_enum_members(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_export_assignment(
        &mut self,
        node: &mut TsExportAssignment,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_export_assignment(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_expr_with_type_args(
        &mut self,
        node: &mut TsExprWithTypeArgs,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_expr_with_type_args(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_expr_with_type_argss(
        &mut self,
        node: &mut Vec<TsExprWithTypeArgs>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_expr_with_type_argss(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_external_module_ref(
        &mut self,
        node: &mut TsExternalModuleRef,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_external_module_ref(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_fn_or_constructor_type(
        &mut self,
        node: &mut TsFnOrConstructorType,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_fn_or_constructor_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_fn_param(&mut self, node: &mut TsFnParam, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_fn_param(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_fn_params(&mut self, node: &mut Vec<TsFnParam>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_fn_params(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_fn_type(&mut self, node: &mut TsFnType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_fn_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_getter_signature(
        &mut self,
        node: &mut TsGetterSignature,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_getter_signature(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_import_equals_decl(
        &mut self,
        node: &mut TsImportEqualsDecl,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_import_equals_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_import_type(&mut self, node: &mut TsImportType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_import_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_index_signature(
        &mut self,
        node: &mut TsIndexSignature,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_index_signature(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_indexed_access_type(
        &mut self,
        node: &mut TsIndexedAccessType,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_indexed_access_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_infer_type(&mut self, node: &mut TsInferType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_infer_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_instantiation(
        &mut self,
        node: &mut TsInstantiation,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_instantiation(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_interface_body(
        &mut self,
        node: &mut TsInterfaceBody,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_interface_body(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_interface_decl(
        &mut self,
        node: &mut TsInterfaceDecl,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_interface_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_intersection_type(
        &mut self,
        node: &mut TsIntersectionType,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_intersection_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_keyword_type(&mut self, node: &mut TsKeywordType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_keyword_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_keyword_type_kind(
        &mut self,
        node: &mut TsKeywordTypeKind,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_keyword_type_kind(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_lit(&mut self, node: &mut TsLit, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_lit(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_lit_type(&mut self, node: &mut TsLitType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_lit_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_mapped_type(&mut self, node: &mut TsMappedType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_mapped_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_method_signature(
        &mut self,
        node: &mut TsMethodSignature,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_method_signature(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_module_block(&mut self, node: &mut TsModuleBlock, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_module_block(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_module_decl(&mut self, node: &mut TsModuleDecl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_module_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_module_name(&mut self, node: &mut TsModuleName, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_module_name(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_module_ref(&mut self, node: &mut TsModuleRef, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_module_ref(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_namespace_body(
        &mut self,
        node: &mut TsNamespaceBody,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_namespace_body(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_namespace_decl(
        &mut self,
        node: &mut TsNamespaceDecl,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_namespace_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_namespace_export_decl(
        &mut self,
        node: &mut TsNamespaceExportDecl,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_namespace_export_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_non_null_expr(&mut self, node: &mut TsNonNullExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_non_null_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_optional_type(
        &mut self,
        node: &mut TsOptionalType,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_optional_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_param_prop(&mut self, node: &mut TsParamProp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_param_prop(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_param_prop_param(
        &mut self,
        node: &mut TsParamPropParam,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_param_prop_param(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_parenthesized_type(
        &mut self,
        node: &mut TsParenthesizedType,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_parenthesized_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_property_signature(
        &mut self,
        node: &mut TsPropertySignature,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_property_signature(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_qualified_name(
        &mut self,
        node: &mut TsQualifiedName,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_qualified_name(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_rest_type(&mut self, node: &mut TsRestType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_rest_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_satisfies_expr(
        &mut self,
        node: &mut TsSatisfiesExpr,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_satisfies_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_setter_signature(
        &mut self,
        node: &mut TsSetterSignature,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_setter_signature(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_this_type(&mut self, node: &mut TsThisType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_this_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_this_type_or_ident(
        &mut self,
        node: &mut TsThisTypeOrIdent,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_this_type_or_ident(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_tpl_lit_type(&mut self, node: &mut TsTplLitType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_tpl_lit_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_tuple_element(
        &mut self,
        node: &mut TsTupleElement,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_tuple_element(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_tuple_elements(
        &mut self,
        node: &mut Vec<TsTupleElement>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_tuple_elements(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_tuple_type(&mut self, node: &mut TsTupleType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_tuple_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type(&mut self, node: &mut TsType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_alias_decl(
        &mut self,
        node: &mut TsTypeAliasDecl,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_type_alias_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_ann(&mut self, node: &mut TsTypeAnn, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_type_ann(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_assertion(
        &mut self,
        node: &mut TsTypeAssertion,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_type_assertion(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_element(&mut self, node: &mut TsTypeElement, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_type_element(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_elements(
        &mut self,
        node: &mut Vec<TsTypeElement>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_type_elements(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_lit(&mut self, node: &mut TsTypeLit, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_type_lit(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_operator(
        &mut self,
        node: &mut TsTypeOperator,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_type_operator(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_operator_op(
        &mut self,
        node: &mut TsTypeOperatorOp,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_type_operator_op(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_param(&mut self, node: &mut TsTypeParam, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_type_param(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_param_decl(
        &mut self,
        node: &mut TsTypeParamDecl,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_type_param_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_param_instantiation(
        &mut self,
        node: &mut TsTypeParamInstantiation,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_type_param_instantiation(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_params(
        &mut self,
        node: &mut Vec<TsTypeParam>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_type_params(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_predicate(
        &mut self,
        node: &mut TsTypePredicate,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_type_predicate(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_query(&mut self, node: &mut TsTypeQuery, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_type_query(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_query_expr(
        &mut self,
        node: &mut TsTypeQueryExpr,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_type_query_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_type_ref(&mut self, node: &mut TsTypeRef, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_type_ref(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_types(&mut self, node: &mut Vec<Box<TsType>>, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_types(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_union_or_intersection_type(
        &mut self,
        node: &mut TsUnionOrIntersectionType,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_ts_union_or_intersection_type(&mut **self, node, ast_path)
    }

    fn visit_mut_ts_union_type(&mut self, node: &mut TsUnionType, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_ts_union_type(&mut **self, node, ast_path)
    }

    fn visit_mut_unary_expr(&mut self, node: &mut UnaryExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_unary_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_unary_op(&mut self, node: &mut UnaryOp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_unary_op(&mut **self, node, ast_path)
    }

    fn visit_mut_update_expr(&mut self, node: &mut UpdateExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_update_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_update_op(&mut self, node: &mut UpdateOp, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_update_op(&mut **self, node, ast_path)
    }

    fn visit_mut_using_decl(&mut self, node: &mut UsingDecl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_using_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_var_decl(&mut self, node: &mut VarDecl, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_var_decl(&mut **self, node, ast_path)
    }

    fn visit_mut_var_decl_kind(&mut self, node: &mut VarDeclKind, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_var_decl_kind(&mut **self, node, ast_path)
    }

    fn visit_mut_var_decl_or_expr(&mut self, node: &mut VarDeclOrExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_var_decl_or_expr(&mut **self, node, ast_path)
    }

    fn visit_mut_var_declarator(&mut self, node: &mut VarDeclarator, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_var_declarator(&mut **self, node, ast_path)
    }

    fn visit_mut_var_declarators(
        &mut self,
        node: &mut Vec<VarDeclarator>,
        ast_path: &mut AstKindPath,
    ) {
        VisitMutAstPath::visit_mut_var_declarators(&mut **self, node, ast_path)
    }

    fn visit_mut_while_stmt(&mut self, node: &mut WhileStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_while_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_with_stmt(&mut self, node: &mut WithStmt, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_with_stmt(&mut **self, node, ast_path)
    }

    fn visit_mut_yield_expr(&mut self, node: &mut YieldExpr, ast_path: &mut AstKindPath) {
        VisitMutAstPath::visit_mut_yield_expr(&mut **self, node, ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<A, B> VisitMutAstPath for ::swc_visit::Either<A, B>
where
    A: VisitMutAstPath,
    B: VisitMutAstPath,
{
    fn visit_mut_accessibility(&mut self, node: &mut Accessibility, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_accessibility(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_accessibility(self, node, ast_path)
            }
        }
    }

    fn visit_mut_array_lit(&mut self, node: &mut ArrayLit, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_array_lit(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_array_lit(self, node, ast_path)
            }
        }
    }

    fn visit_mut_array_pat(&mut self, node: &mut ArrayPat, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_array_pat(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_array_pat(self, node, ast_path)
            }
        }
    }

    fn visit_mut_arrow_expr(&mut self, node: &mut ArrowExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_arrow_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_arrow_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_assign_expr(&mut self, node: &mut AssignExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_assign_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_assign_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_assign_op(&mut self, node: &mut AssignOp, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_assign_op(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_assign_op(self, node, ast_path)
            }
        }
    }

    fn visit_mut_assign_pat(&mut self, node: &mut AssignPat, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_assign_pat(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_assign_pat(self, node, ast_path)
            }
        }
    }

    fn visit_mut_assign_pat_prop(&mut self, node: &mut AssignPatProp, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_assign_pat_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_assign_pat_prop(self, node, ast_path)
            }
        }
    }

    fn visit_mut_assign_prop(&mut self, node: &mut AssignProp, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_assign_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_assign_prop(self, node, ast_path)
            }
        }
    }

    fn visit_mut_assign_target(&mut self, node: &mut AssignTarget, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_assign_target(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_assign_target(self, node, ast_path)
            }
        }
    }

    fn visit_mut_assign_target_pat(
        &mut self,
        node: &mut AssignTargetPat,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_assign_target_pat(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_assign_target_pat(self, node, ast_path)
            }
        }
    }

    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_atom(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_atom(self, node, ast_path)
            }
        }
    }

    fn visit_mut_auto_accessor(&mut self, node: &mut AutoAccessor, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_auto_accessor(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_auto_accessor(self, node, ast_path)
            }
        }
    }

    fn visit_mut_await_expr(&mut self, node: &mut AwaitExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_await_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_await_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_big_int(&mut self, node: &mut BigInt, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_big_int(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_big_int(self, node, ast_path)
            }
        }
    }

    fn visit_mut_big_int_value(&mut self, node: &mut BigIntValue, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_big_int_value(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_big_int_value(self, node, ast_path)
            }
        }
    }

    fn visit_mut_bin_expr(&mut self, node: &mut BinExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_bin_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_bin_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_binary_op(&mut self, node: &mut BinaryOp, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_binary_op(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_binary_op(self, node, ast_path)
            }
        }
    }

    fn visit_mut_binding_ident(&mut self, node: &mut BindingIdent, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_binding_ident(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_binding_ident(self, node, ast_path)
            }
        }
    }

    fn visit_mut_block_stmt(&mut self, node: &mut BlockStmt, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_block_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_block_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_mut_block_stmt_or_expr(
        &mut self,
        node: &mut BlockStmtOrExpr,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_block_stmt_or_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_block_stmt_or_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_bool(&mut self, node: &mut Bool, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_bool(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_bool(self, node, ast_path)
            }
        }
    }

    fn visit_mut_break_stmt(&mut self, node: &mut BreakStmt, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_break_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_break_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_mut_call_expr(&mut self, node: &mut CallExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_call_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_call_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_callee(&mut self, node: &mut Callee, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_callee(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_callee(self, node, ast_path)
            }
        }
    }

    fn visit_mut_catch_clause(&mut self, node: &mut CatchClause, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_catch_clause(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_catch_clause(self, node, ast_path)
            }
        }
    }

    fn visit_mut_class(&mut self, node: &mut Class, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_class(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_class(self, node, ast_path)
            }
        }
    }

    fn visit_mut_class_decl(&mut self, node: &mut ClassDecl, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_class_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_class_decl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_class_expr(&mut self, node: &mut ClassExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_class_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_class_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_class_member(&mut self, node: &mut ClassMember, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_class_member(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_class_member(self, node, ast_path)
            }
        }
    }

    fn visit_mut_class_members(&mut self, node: &mut Vec<ClassMember>, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_class_members(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_class_members(self, node, ast_path)
            }
        }
    }

    fn visit_mut_class_method(&mut self, node: &mut ClassMethod, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_class_method(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_class_method(self, node, ast_path)
            }
        }
    }

    fn visit_mut_class_prop(&mut self, node: &mut ClassProp, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_class_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_class_prop(self, node, ast_path)
            }
        }
    }

    fn visit_mut_computed_prop_name(
        &mut self,
        node: &mut ComputedPropName,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_computed_prop_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_computed_prop_name(self, node, ast_path)
            }
        }
    }

    fn visit_mut_cond_expr(&mut self, node: &mut CondExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_cond_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_cond_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_constructor(&mut self, node: &mut Constructor, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_constructor(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_constructor(self, node, ast_path)
            }
        }
    }

    fn visit_mut_continue_stmt(&mut self, node: &mut ContinueStmt, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_continue_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_continue_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_mut_debugger_stmt(&mut self, node: &mut DebuggerStmt, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_debugger_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_debugger_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_mut_decl(&mut self, node: &mut Decl, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_decl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_decorator(&mut self, node: &mut Decorator, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_decorator(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_decorator(self, node, ast_path)
            }
        }
    }

    fn visit_mut_decorators(&mut self, node: &mut Vec<Decorator>, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_decorators(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_decorators(self, node, ast_path)
            }
        }
    }

    fn visit_mut_default_decl(&mut self, node: &mut DefaultDecl, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_default_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_default_decl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_do_while_stmt(&mut self, node: &mut DoWhileStmt, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_do_while_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_do_while_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_mut_empty_stmt(&mut self, node: &mut EmptyStmt, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_empty_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_empty_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_mut_es_version(&mut self, node: &mut EsVersion, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_es_version(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_es_version(self, node, ast_path)
            }
        }
    }

    fn visit_mut_export_all(&mut self, node: &mut ExportAll, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_export_all(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_export_all(self, node, ast_path)
            }
        }
    }

    fn visit_mut_export_decl(&mut self, node: &mut ExportDecl, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_export_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_export_decl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_export_default_decl(
        &mut self,
        node: &mut ExportDefaultDecl,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_export_default_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_export_default_decl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_export_default_expr(
        &mut self,
        node: &mut ExportDefaultExpr,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_export_default_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_export_default_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_export_default_specifier(
        &mut self,
        node: &mut ExportDefaultSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_export_default_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_export_default_specifier(self, node, ast_path)
            }
        }
    }

    fn visit_mut_export_named_specifier(
        &mut self,
        node: &mut ExportNamedSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_export_named_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_export_named_specifier(self, node, ast_path)
            }
        }
    }

    fn visit_mut_export_namespace_specifier(
        &mut self,
        node: &mut ExportNamespaceSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_export_namespace_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_export_namespace_specifier(self, node, ast_path)
            }
        }
    }

    fn visit_mut_export_specifier(
        &mut self,
        node: &mut ExportSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_export_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_export_specifier(self, node, ast_path)
            }
        }
    }

    fn visit_mut_export_specifiers(
        &mut self,
        node: &mut Vec<ExportSpecifier>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_export_specifiers(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_export_specifiers(self, node, ast_path)
            }
        }
    }

    fn visit_mut_expr(&mut self, node: &mut Expr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_expr_or_spread(&mut self, node: &mut ExprOrSpread, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_expr_or_spread(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_expr_or_spread(self, node, ast_path)
            }
        }
    }

    fn visit_mut_expr_or_spreads(
        &mut self,
        node: &mut Vec<ExprOrSpread>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_expr_or_spreads(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_expr_or_spreads(self, node, ast_path)
            }
        }
    }

    fn visit_mut_expr_stmt(&mut self, node: &mut ExprStmt, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_expr_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_expr_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_mut_exprs(&mut self, node: &mut Vec<Box<Expr>>, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_exprs(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_exprs(self, node, ast_path)
            }
        }
    }

    fn visit_mut_fn_decl(&mut self, node: &mut FnDecl, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_fn_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_fn_decl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_fn_expr(&mut self, node: &mut FnExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_fn_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_fn_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_for_head(&mut self, node: &mut ForHead, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_for_head(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_for_head(self, node, ast_path)
            }
        }
    }

    fn visit_mut_for_in_stmt(&mut self, node: &mut ForInStmt, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_for_in_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_for_in_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_mut_for_of_stmt(&mut self, node: &mut ForOfStmt, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_for_of_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_for_of_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_mut_for_stmt(&mut self, node: &mut ForStmt, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_for_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_for_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_mut_function(&mut self, node: &mut Function, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_function(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_function(self, node, ast_path)
            }
        }
    }

    fn visit_mut_getter_prop(&mut self, node: &mut GetterProp, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_getter_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_getter_prop(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ident(&mut self, node: &mut Ident, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ident(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ident(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ident_name(&mut self, node: &mut IdentName, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ident_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ident_name(self, node, ast_path)
            }
        }
    }

    fn visit_mut_if_stmt(&mut self, node: &mut IfStmt, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_if_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_if_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_mut_import(&mut self, node: &mut Import, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import(self, node, ast_path)
            }
        }
    }

    fn visit_mut_import_decl(&mut self, node: &mut ImportDecl, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import_decl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_import_default_specifier(
        &mut self,
        node: &mut ImportDefaultSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import_default_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import_default_specifier(self, node, ast_path)
            }
        }
    }

    fn visit_mut_import_named_specifier(
        &mut self,
        node: &mut ImportNamedSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import_named_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import_named_specifier(self, node, ast_path)
            }
        }
    }

    fn visit_mut_import_phase(&mut self, node: &mut ImportPhase, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import_phase(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import_phase(self, node, ast_path)
            }
        }
    }

    fn visit_mut_import_specifier(
        &mut self,
        node: &mut ImportSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import_specifier(self, node, ast_path)
            }
        }
    }

    fn visit_mut_import_specifiers(
        &mut self,
        node: &mut Vec<ImportSpecifier>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import_specifiers(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import_specifiers(self, node, ast_path)
            }
        }
    }

    fn visit_mut_import_star_as_specifier(
        &mut self,
        node: &mut ImportStarAsSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import_star_as_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import_star_as_specifier(self, node, ast_path)
            }
        }
    }

    fn visit_mut_import_with(&mut self, node: &mut ImportWith, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import_with(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import_with(self, node, ast_path)
            }
        }
    }

    fn visit_mut_import_with_item(
        &mut self,
        node: &mut ImportWithItem,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import_with_item(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import_with_item(self, node, ast_path)
            }
        }
    }

    fn visit_mut_import_with_items(
        &mut self,
        node: &mut Vec<ImportWithItem>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_import_with_items(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_import_with_items(self, node, ast_path)
            }
        }
    }

    fn visit_mut_invalid(&mut self, node: &mut Invalid, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_invalid(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_invalid(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_attr(&mut self, node: &mut JSXAttr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_attr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_attr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_attr_name(&mut self, node: &mut JSXAttrName, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_attr_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_attr_name(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_attr_or_spread(
        &mut self,
        node: &mut JSXAttrOrSpread,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_attr_or_spread(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_attr_or_spread(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_attr_or_spreads(
        &mut self,
        node: &mut Vec<JSXAttrOrSpread>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_attr_or_spreads(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_attr_or_spreads(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_attr_value(&mut self, node: &mut JSXAttrValue, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_attr_value(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_attr_value(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_closing_element(
        &mut self,
        node: &mut JSXClosingElement,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_closing_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_closing_element(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_closing_fragment(
        &mut self,
        node: &mut JSXClosingFragment,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_closing_fragment(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_closing_fragment(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_element(&mut self, node: &mut JSXElement, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_element(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_element_child(
        &mut self,
        node: &mut JSXElementChild,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_element_child(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_element_child(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_element_childs(
        &mut self,
        node: &mut Vec<JSXElementChild>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_element_childs(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_element_childs(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_element_name(
        &mut self,
        node: &mut JSXElementName,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_element_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_element_name(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_empty_expr(&mut self, node: &mut JSXEmptyExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_empty_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_empty_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_expr(&mut self, node: &mut JSXExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_expr_container(
        &mut self,
        node: &mut JSXExprContainer,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_expr_container(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_expr_container(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_fragment(&mut self, node: &mut JSXFragment, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_fragment(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_fragment(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_member_expr(&mut self, node: &mut JSXMemberExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_member_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_member_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_namespaced_name(
        &mut self,
        node: &mut JSXNamespacedName,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_namespaced_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_namespaced_name(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_object(&mut self, node: &mut JSXObject, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_object(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_object(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_opening_element(
        &mut self,
        node: &mut JSXOpeningElement,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_opening_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_opening_element(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_opening_fragment(
        &mut self,
        node: &mut JSXOpeningFragment,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_opening_fragment(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_opening_fragment(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_spread_child(
        &mut self,
        node: &mut JSXSpreadChild,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_spread_child(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_spread_child(self, node, ast_path)
            }
        }
    }

    fn visit_mut_jsx_text(&mut self, node: &mut JSXText, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_jsx_text(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_jsx_text(self, node, ast_path)
            }
        }
    }

    fn visit_mut_key(&mut self, node: &mut Key, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_key(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_key(self, node, ast_path)
            }
        }
    }

    fn visit_mut_key_value_pat_prop(
        &mut self,
        node: &mut KeyValuePatProp,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_key_value_pat_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_key_value_pat_prop(self, node, ast_path)
            }
        }
    }

    fn visit_mut_key_value_prop(&mut self, node: &mut KeyValueProp, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_key_value_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_key_value_prop(self, node, ast_path)
            }
        }
    }

    fn visit_mut_labeled_stmt(&mut self, node: &mut LabeledStmt, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_labeled_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_labeled_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_mut_lit(&mut self, node: &mut Lit, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_lit(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_lit(self, node, ast_path)
            }
        }
    }

    fn visit_mut_member_expr(&mut self, node: &mut MemberExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_member_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_member_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_member_prop(&mut self, node: &mut MemberProp, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_member_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_member_prop(self, node, ast_path)
            }
        }
    }

    fn visit_mut_meta_prop_expr(&mut self, node: &mut MetaPropExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_meta_prop_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_meta_prop_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_meta_prop_kind(&mut self, node: &mut MetaPropKind, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_meta_prop_kind(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_meta_prop_kind(self, node, ast_path)
            }
        }
    }

    fn visit_mut_method_kind(&mut self, node: &mut MethodKind, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_method_kind(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_method_kind(self, node, ast_path)
            }
        }
    }

    fn visit_mut_method_prop(&mut self, node: &mut MethodProp, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_method_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_method_prop(self, node, ast_path)
            }
        }
    }

    fn visit_mut_module(&mut self, node: &mut Module, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_module(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_module(self, node, ast_path)
            }
        }
    }

    fn visit_mut_module_decl(&mut self, node: &mut ModuleDecl, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_module_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_module_decl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_module_export_name(
        &mut self,
        node: &mut ModuleExportName,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_module_export_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_module_export_name(self, node, ast_path)
            }
        }
    }

    fn visit_mut_module_item(&mut self, node: &mut ModuleItem, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_module_item(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_module_item(self, node, ast_path)
            }
        }
    }

    fn visit_mut_module_items(&mut self, node: &mut Vec<ModuleItem>, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_module_items(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_module_items(self, node, ast_path)
            }
        }
    }

    fn visit_mut_named_export(&mut self, node: &mut NamedExport, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_named_export(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_named_export(self, node, ast_path)
            }
        }
    }

    fn visit_mut_new_expr(&mut self, node: &mut NewExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_new_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_new_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_null(&mut self, node: &mut Null, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_null(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_null(self, node, ast_path)
            }
        }
    }

    fn visit_mut_number(&mut self, node: &mut Number, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_number(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_number(self, node, ast_path)
            }
        }
    }

    fn visit_mut_object_lit(&mut self, node: &mut ObjectLit, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_object_lit(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_object_lit(self, node, ast_path)
            }
        }
    }

    fn visit_mut_object_pat(&mut self, node: &mut ObjectPat, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_object_pat(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_object_pat(self, node, ast_path)
            }
        }
    }

    fn visit_mut_object_pat_prop(&mut self, node: &mut ObjectPatProp, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_object_pat_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_object_pat_prop(self, node, ast_path)
            }
        }
    }

    fn visit_mut_object_pat_props(
        &mut self,
        node: &mut Vec<ObjectPatProp>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_object_pat_props(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_object_pat_props(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_accessibility(
        &mut self,
        node: &mut Option<Accessibility>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_accessibility(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_accessibility(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_atom(
        &mut self,
        node: &mut Option<swc_atoms::Atom>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_atom(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_atom(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_block_stmt(
        &mut self,
        node: &mut Option<BlockStmt>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_block_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_block_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_call(&mut self, node: &mut OptCall, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_call(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_call(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_catch_clause(
        &mut self,
        node: &mut Option<CatchClause>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_catch_clause(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_catch_clause(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_chain_base(&mut self, node: &mut OptChainBase, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_chain_base(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_chain_base(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_chain_expr(&mut self, node: &mut OptChainExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_chain_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_chain_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_expr(&mut self, node: &mut Option<Box<Expr>>, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_expr_or_spread(
        &mut self,
        node: &mut Option<ExprOrSpread>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_expr_or_spread(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_expr_or_spread(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_expr_or_spreads(
        &mut self,
        node: &mut Option<Vec<ExprOrSpread>>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_expr_or_spreads(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_expr_or_spreads(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_ident(&mut self, node: &mut Option<Ident>, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_ident(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_ident(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_jsx_attr_value(
        &mut self,
        node: &mut Option<JSXAttrValue>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_jsx_attr_value(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_jsx_attr_value(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_jsx_closing_element(
        &mut self,
        node: &mut Option<JSXClosingElement>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_jsx_closing_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_jsx_closing_element(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_module_export_name(
        &mut self,
        node: &mut Option<ModuleExportName>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_module_export_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_module_export_name(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_module_items(
        &mut self,
        node: &mut Option<Vec<ModuleItem>>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_module_items(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_module_items(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_object_lit(
        &mut self,
        node: &mut Option<Box<ObjectLit>>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_object_lit(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_object_lit(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_pat(&mut self, node: &mut Option<Pat>, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_pat(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_pat(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_span(
        &mut self,
        node: &mut Option<swc_common::Span>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_span(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_span(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_stmt(&mut self, node: &mut Option<Box<Stmt>>, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_str(&mut self, node: &mut Option<Box<Str>>, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_str(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_str(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_true_plus_minus(
        &mut self,
        node: &mut Option<TruePlusMinus>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_true_plus_minus(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_true_plus_minus(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_ts_entity_name(
        &mut self,
        node: &mut Option<TsEntityName>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_ts_entity_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_ts_entity_name(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_ts_namespace_body(
        &mut self,
        node: &mut Option<TsNamespaceBody>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_ts_namespace_body(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_ts_namespace_body(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_ts_type(
        &mut self,
        node: &mut Option<Box<TsType>>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_ts_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_ts_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_ts_type_ann(
        &mut self,
        node: &mut Option<Box<TsTypeAnn>>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_ts_type_ann(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_ts_type_ann(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_ts_type_param_decl(
        &mut self,
        node: &mut Option<Box<TsTypeParamDecl>>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_ts_type_param_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_ts_type_param_decl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_ts_type_param_instantiation(
        &mut self,
        node: &mut Option<Box<TsTypeParamInstantiation>>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_ts_type_param_instantiation(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_ts_type_param_instantiation(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_var_decl_or_expr(
        &mut self,
        node: &mut Option<VarDeclOrExpr>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_var_decl_or_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_var_decl_or_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_vec_expr_or_spreads(
        &mut self,
        node: &mut Vec<Option<ExprOrSpread>>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_vec_expr_or_spreads(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_vec_expr_or_spreads(self, node, ast_path)
            }
        }
    }

    fn visit_mut_opt_vec_pats(&mut self, node: &mut Vec<Option<Pat>>, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_opt_vec_pats(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_opt_vec_pats(self, node, ast_path)
            }
        }
    }

    fn visit_mut_param(&mut self, node: &mut Param, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_param(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_param(self, node, ast_path)
            }
        }
    }

    fn visit_mut_param_or_ts_param_prop(
        &mut self,
        node: &mut ParamOrTsParamProp,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_param_or_ts_param_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_param_or_ts_param_prop(self, node, ast_path)
            }
        }
    }

    fn visit_mut_param_or_ts_param_props(
        &mut self,
        node: &mut Vec<ParamOrTsParamProp>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_param_or_ts_param_props(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_param_or_ts_param_props(self, node, ast_path)
            }
        }
    }

    fn visit_mut_params(&mut self, node: &mut Vec<Param>, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_params(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_params(self, node, ast_path)
            }
        }
    }

    fn visit_mut_paren_expr(&mut self, node: &mut ParenExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_paren_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_paren_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_pat(&mut self, node: &mut Pat, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_pat(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_pat(self, node, ast_path)
            }
        }
    }

    fn visit_mut_pats(&mut self, node: &mut Vec<Pat>, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_pats(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_pats(self, node, ast_path)
            }
        }
    }

    fn visit_mut_private_method(&mut self, node: &mut PrivateMethod, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_private_method(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_private_method(self, node, ast_path)
            }
        }
    }

    fn visit_mut_private_name(&mut self, node: &mut PrivateName, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_private_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_private_name(self, node, ast_path)
            }
        }
    }

    fn visit_mut_private_prop(&mut self, node: &mut PrivateProp, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_private_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_private_prop(self, node, ast_path)
            }
        }
    }

    fn visit_mut_program(&mut self, node: &mut Program, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_program(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_program(self, node, ast_path)
            }
        }
    }

    fn visit_mut_prop(&mut self, node: &mut Prop, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_prop(self, node, ast_path)
            }
        }
    }

    fn visit_mut_prop_name(&mut self, node: &mut PropName, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_prop_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_prop_name(self, node, ast_path)
            }
        }
    }

    fn visit_mut_prop_or_spread(&mut self, node: &mut PropOrSpread, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_prop_or_spread(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_prop_or_spread(self, node, ast_path)
            }
        }
    }

    fn visit_mut_prop_or_spreads(
        &mut self,
        node: &mut Vec<PropOrSpread>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_prop_or_spreads(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_prop_or_spreads(self, node, ast_path)
            }
        }
    }

    fn visit_mut_regex(&mut self, node: &mut Regex, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_regex(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_regex(self, node, ast_path)
            }
        }
    }

    fn visit_mut_reserved_unused(&mut self, node: &mut ReservedUnused, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_reserved_unused(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_reserved_unused(self, node, ast_path)
            }
        }
    }

    fn visit_mut_rest_pat(&mut self, node: &mut RestPat, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_rest_pat(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_rest_pat(self, node, ast_path)
            }
        }
    }

    fn visit_mut_return_stmt(&mut self, node: &mut ReturnStmt, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_return_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_return_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_mut_script(&mut self, node: &mut Script, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_script(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_script(self, node, ast_path)
            }
        }
    }

    fn visit_mut_seq_expr(&mut self, node: &mut SeqExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_seq_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_seq_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_setter_prop(&mut self, node: &mut SetterProp, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_setter_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_setter_prop(self, node, ast_path)
            }
        }
    }

    fn visit_mut_simple_assign_target(
        &mut self,
        node: &mut SimpleAssignTarget,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_simple_assign_target(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_simple_assign_target(self, node, ast_path)
            }
        }
    }

    fn visit_mut_span(&mut self, node: &mut swc_common::Span, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_span(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_span(self, node, ast_path)
            }
        }
    }

    fn visit_mut_spread_element(&mut self, node: &mut SpreadElement, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_spread_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_spread_element(self, node, ast_path)
            }
        }
    }

    fn visit_mut_static_block(&mut self, node: &mut StaticBlock, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_static_block(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_static_block(self, node, ast_path)
            }
        }
    }

    fn visit_mut_stmt(&mut self, node: &mut Stmt, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_mut_stmts(&mut self, node: &mut Vec<Stmt>, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_stmts(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_stmts(self, node, ast_path)
            }
        }
    }

    fn visit_mut_str(&mut self, node: &mut Str, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_str(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_str(self, node, ast_path)
            }
        }
    }

    fn visit_mut_super(&mut self, node: &mut Super, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_super(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_super(self, node, ast_path)
            }
        }
    }

    fn visit_mut_super_prop(&mut self, node: &mut SuperProp, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_super_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_super_prop(self, node, ast_path)
            }
        }
    }

    fn visit_mut_super_prop_expr(&mut self, node: &mut SuperPropExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_super_prop_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_super_prop_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_switch_case(&mut self, node: &mut SwitchCase, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_switch_case(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_switch_case(self, node, ast_path)
            }
        }
    }

    fn visit_mut_switch_cases(&mut self, node: &mut Vec<SwitchCase>, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_switch_cases(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_switch_cases(self, node, ast_path)
            }
        }
    }

    fn visit_mut_switch_stmt(&mut self, node: &mut SwitchStmt, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_switch_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_switch_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_mut_syntax_context(
        &mut self,
        node: &mut swc_common::SyntaxContext,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_syntax_context(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_syntax_context(self, node, ast_path)
            }
        }
    }

    fn visit_mut_tagged_tpl(&mut self, node: &mut TaggedTpl, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_tagged_tpl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_tagged_tpl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_this_expr(&mut self, node: &mut ThisExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_this_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_this_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_throw_stmt(&mut self, node: &mut ThrowStmt, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_throw_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_throw_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_mut_tpl(&mut self, node: &mut Tpl, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_tpl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_tpl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_tpl_element(&mut self, node: &mut TplElement, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_tpl_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_tpl_element(self, node, ast_path)
            }
        }
    }

    fn visit_mut_tpl_elements(&mut self, node: &mut Vec<TplElement>, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_tpl_elements(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_tpl_elements(self, node, ast_path)
            }
        }
    }

    fn visit_mut_true_plus_minus(&mut self, node: &mut TruePlusMinus, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_true_plus_minus(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_true_plus_minus(self, node, ast_path)
            }
        }
    }

    fn visit_mut_try_stmt(&mut self, node: &mut TryStmt, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_try_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_try_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_array_type(&mut self, node: &mut TsArrayType, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_array_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_array_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_as_expr(&mut self, node: &mut TsAsExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_as_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_as_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_call_signature_decl(
        &mut self,
        node: &mut TsCallSignatureDecl,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_call_signature_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_call_signature_decl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_conditional_type(
        &mut self,
        node: &mut TsConditionalType,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_conditional_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_conditional_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_const_assertion(
        &mut self,
        node: &mut TsConstAssertion,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_const_assertion(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_const_assertion(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_construct_signature_decl(
        &mut self,
        node: &mut TsConstructSignatureDecl,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_construct_signature_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_construct_signature_decl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_constructor_type(
        &mut self,
        node: &mut TsConstructorType,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_constructor_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_constructor_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_entity_name(&mut self, node: &mut TsEntityName, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_entity_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_entity_name(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_enum_decl(&mut self, node: &mut TsEnumDecl, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_enum_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_enum_decl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_enum_member(&mut self, node: &mut TsEnumMember, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_enum_member(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_enum_member(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_enum_member_id(
        &mut self,
        node: &mut TsEnumMemberId,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_enum_member_id(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_enum_member_id(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_enum_members(
        &mut self,
        node: &mut Vec<TsEnumMember>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_enum_members(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_enum_members(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_export_assignment(
        &mut self,
        node: &mut TsExportAssignment,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_export_assignment(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_export_assignment(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_expr_with_type_args(
        &mut self,
        node: &mut TsExprWithTypeArgs,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_expr_with_type_args(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_expr_with_type_args(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_expr_with_type_argss(
        &mut self,
        node: &mut Vec<TsExprWithTypeArgs>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_expr_with_type_argss(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_expr_with_type_argss(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_external_module_ref(
        &mut self,
        node: &mut TsExternalModuleRef,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_external_module_ref(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_external_module_ref(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_fn_or_constructor_type(
        &mut self,
        node: &mut TsFnOrConstructorType,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_fn_or_constructor_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_fn_or_constructor_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_fn_param(&mut self, node: &mut TsFnParam, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_fn_param(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_fn_param(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_fn_params(&mut self, node: &mut Vec<TsFnParam>, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_fn_params(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_fn_params(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_fn_type(&mut self, node: &mut TsFnType, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_fn_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_fn_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_getter_signature(
        &mut self,
        node: &mut TsGetterSignature,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_getter_signature(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_getter_signature(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_import_equals_decl(
        &mut self,
        node: &mut TsImportEqualsDecl,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_import_equals_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_import_equals_decl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_import_type(&mut self, node: &mut TsImportType, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_import_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_import_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_index_signature(
        &mut self,
        node: &mut TsIndexSignature,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_index_signature(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_index_signature(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_indexed_access_type(
        &mut self,
        node: &mut TsIndexedAccessType,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_indexed_access_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_indexed_access_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_infer_type(&mut self, node: &mut TsInferType, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_infer_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_infer_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_instantiation(
        &mut self,
        node: &mut TsInstantiation,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_instantiation(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_instantiation(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_interface_body(
        &mut self,
        node: &mut TsInterfaceBody,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_interface_body(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_interface_body(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_interface_decl(
        &mut self,
        node: &mut TsInterfaceDecl,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_interface_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_interface_decl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_intersection_type(
        &mut self,
        node: &mut TsIntersectionType,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_intersection_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_intersection_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_keyword_type(&mut self, node: &mut TsKeywordType, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_keyword_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_keyword_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_keyword_type_kind(
        &mut self,
        node: &mut TsKeywordTypeKind,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_keyword_type_kind(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_keyword_type_kind(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_lit(&mut self, node: &mut TsLit, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_lit(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_lit(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_lit_type(&mut self, node: &mut TsLitType, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_lit_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_lit_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_mapped_type(&mut self, node: &mut TsMappedType, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_mapped_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_mapped_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_method_signature(
        &mut self,
        node: &mut TsMethodSignature,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_method_signature(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_method_signature(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_module_block(&mut self, node: &mut TsModuleBlock, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_module_block(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_module_block(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_module_decl(&mut self, node: &mut TsModuleDecl, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_module_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_module_decl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_module_name(&mut self, node: &mut TsModuleName, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_module_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_module_name(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_module_ref(&mut self, node: &mut TsModuleRef, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_module_ref(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_module_ref(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_namespace_body(
        &mut self,
        node: &mut TsNamespaceBody,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_namespace_body(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_namespace_body(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_namespace_decl(
        &mut self,
        node: &mut TsNamespaceDecl,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_namespace_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_namespace_decl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_namespace_export_decl(
        &mut self,
        node: &mut TsNamespaceExportDecl,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_namespace_export_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_namespace_export_decl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_non_null_expr(&mut self, node: &mut TsNonNullExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_non_null_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_non_null_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_optional_type(
        &mut self,
        node: &mut TsOptionalType,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_optional_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_optional_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_param_prop(&mut self, node: &mut TsParamProp, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_param_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_param_prop(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_param_prop_param(
        &mut self,
        node: &mut TsParamPropParam,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_param_prop_param(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_param_prop_param(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_parenthesized_type(
        &mut self,
        node: &mut TsParenthesizedType,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_parenthesized_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_parenthesized_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_property_signature(
        &mut self,
        node: &mut TsPropertySignature,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_property_signature(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_property_signature(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_qualified_name(
        &mut self,
        node: &mut TsQualifiedName,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_qualified_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_qualified_name(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_rest_type(&mut self, node: &mut TsRestType, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_rest_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_rest_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_satisfies_expr(
        &mut self,
        node: &mut TsSatisfiesExpr,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_satisfies_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_satisfies_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_setter_signature(
        &mut self,
        node: &mut TsSetterSignature,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_setter_signature(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_setter_signature(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_this_type(&mut self, node: &mut TsThisType, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_this_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_this_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_this_type_or_ident(
        &mut self,
        node: &mut TsThisTypeOrIdent,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_this_type_or_ident(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_this_type_or_ident(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_tpl_lit_type(&mut self, node: &mut TsTplLitType, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_tpl_lit_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_tpl_lit_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_tuple_element(
        &mut self,
        node: &mut TsTupleElement,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_tuple_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_tuple_element(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_tuple_elements(
        &mut self,
        node: &mut Vec<TsTupleElement>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_tuple_elements(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_tuple_elements(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_tuple_type(&mut self, node: &mut TsTupleType, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_tuple_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_tuple_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_type(&mut self, node: &mut TsType, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_type_alias_decl(
        &mut self,
        node: &mut TsTypeAliasDecl,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_alias_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_alias_decl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_type_ann(&mut self, node: &mut TsTypeAnn, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_ann(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_ann(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_type_assertion(
        &mut self,
        node: &mut TsTypeAssertion,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_assertion(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_assertion(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_type_element(&mut self, node: &mut TsTypeElement, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_element(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_type_elements(
        &mut self,
        node: &mut Vec<TsTypeElement>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_elements(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_elements(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_type_lit(&mut self, node: &mut TsTypeLit, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_lit(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_lit(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_type_operator(
        &mut self,
        node: &mut TsTypeOperator,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_operator(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_operator(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_type_operator_op(
        &mut self,
        node: &mut TsTypeOperatorOp,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_operator_op(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_operator_op(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_type_param(&mut self, node: &mut TsTypeParam, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_param(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_param(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_type_param_decl(
        &mut self,
        node: &mut TsTypeParamDecl,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_param_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_param_decl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_type_param_instantiation(
        &mut self,
        node: &mut TsTypeParamInstantiation,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_param_instantiation(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_param_instantiation(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_type_params(
        &mut self,
        node: &mut Vec<TsTypeParam>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_params(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_params(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_type_predicate(
        &mut self,
        node: &mut TsTypePredicate,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_predicate(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_predicate(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_type_query(&mut self, node: &mut TsTypeQuery, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_query(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_query(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_type_query_expr(
        &mut self,
        node: &mut TsTypeQueryExpr,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_query_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_query_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_type_ref(&mut self, node: &mut TsTypeRef, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_ref(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_type_ref(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_types(&mut self, node: &mut Vec<Box<TsType>>, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_types(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_types(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_union_or_intersection_type(
        &mut self,
        node: &mut TsUnionOrIntersectionType,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_union_or_intersection_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_union_or_intersection_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_ts_union_type(&mut self, node: &mut TsUnionType, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_ts_union_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_ts_union_type(self, node, ast_path)
            }
        }
    }

    fn visit_mut_unary_expr(&mut self, node: &mut UnaryExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_unary_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_unary_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_unary_op(&mut self, node: &mut UnaryOp, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_unary_op(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_unary_op(self, node, ast_path)
            }
        }
    }

    fn visit_mut_update_expr(&mut self, node: &mut UpdateExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_update_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_update_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_update_op(&mut self, node: &mut UpdateOp, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_update_op(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_update_op(self, node, ast_path)
            }
        }
    }

    fn visit_mut_using_decl(&mut self, node: &mut UsingDecl, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_using_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_using_decl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_var_decl(&mut self, node: &mut VarDecl, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_var_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_var_decl(self, node, ast_path)
            }
        }
    }

    fn visit_mut_var_decl_kind(&mut self, node: &mut VarDeclKind, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_var_decl_kind(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_var_decl_kind(self, node, ast_path)
            }
        }
    }

    fn visit_mut_var_decl_or_expr(&mut self, node: &mut VarDeclOrExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_var_decl_or_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_var_decl_or_expr(self, node, ast_path)
            }
        }
    }

    fn visit_mut_var_declarator(&mut self, node: &mut VarDeclarator, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_var_declarator(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_var_declarator(self, node, ast_path)
            }
        }
    }

    fn visit_mut_var_declarators(
        &mut self,
        node: &mut Vec<VarDeclarator>,
        ast_path: &mut AstKindPath,
    ) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_var_declarators(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_var_declarators(self, node, ast_path)
            }
        }
    }

    fn visit_mut_while_stmt(&mut self, node: &mut WhileStmt, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_while_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_while_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_mut_with_stmt(&mut self, node: &mut WithStmt, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_with_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_with_stmt(self, node, ast_path)
            }
        }
    }

    fn visit_mut_yield_expr(&mut self, node: &mut YieldExpr, ast_path: &mut AstKindPath) {
        match self {
            swc_visit::Either::Left(visitor) => {
                VisitMutAstPath::visit_mut_yield_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                VisitMutAstPath::visit_mut_yield_expr(self, node, ast_path)
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> VisitMutAstPath for ::swc_visit::Optional<V>
where
    V: VisitMutAstPath,
{
    fn visit_mut_accessibility(&mut self, node: &mut Accessibility, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_accessibility(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_array_lit(&mut self, node: &mut ArrayLit, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_array_lit(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_array_pat(&mut self, node: &mut ArrayPat, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_array_pat(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_arrow_expr(&mut self, node: &mut ArrowExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_arrow_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_assign_expr(&mut self, node: &mut AssignExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_assign_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_assign_op(&mut self, node: &mut AssignOp, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_assign_op(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_assign_pat(&mut self, node: &mut AssignPat, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_assign_pat(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_assign_pat_prop(&mut self, node: &mut AssignPatProp, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_assign_pat_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_assign_prop(&mut self, node: &mut AssignProp, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_assign_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_assign_target(&mut self, node: &mut AssignTarget, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_assign_target(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_assign_target_pat(
        &mut self,
        node: &mut AssignTargetPat,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_assign_target_pat(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_atom(&mut self, node: &mut swc_atoms::Atom, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_atom(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_auto_accessor(&mut self, node: &mut AutoAccessor, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_auto_accessor(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_await_expr(&mut self, node: &mut AwaitExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_await_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_big_int(&mut self, node: &mut BigInt, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_big_int(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_big_int_value(&mut self, node: &mut BigIntValue, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_big_int_value(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_bin_expr(&mut self, node: &mut BinExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_bin_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_binary_op(&mut self, node: &mut BinaryOp, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_binary_op(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_binding_ident(&mut self, node: &mut BindingIdent, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_binding_ident(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_block_stmt(&mut self, node: &mut BlockStmt, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_block_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_block_stmt_or_expr(
        &mut self,
        node: &mut BlockStmtOrExpr,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_block_stmt_or_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_bool(&mut self, node: &mut Bool, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_bool(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_break_stmt(&mut self, node: &mut BreakStmt, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_break_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_call_expr(&mut self, node: &mut CallExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_call_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_callee(&mut self, node: &mut Callee, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_callee(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_catch_clause(&mut self, node: &mut CatchClause, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_catch_clause(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_class(&mut self, node: &mut Class, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_class(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_class_decl(&mut self, node: &mut ClassDecl, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_class_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_class_expr(&mut self, node: &mut ClassExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_class_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_class_member(&mut self, node: &mut ClassMember, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_class_member(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_class_members(&mut self, node: &mut Vec<ClassMember>, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_class_members(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_class_method(&mut self, node: &mut ClassMethod, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_class_method(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_class_prop(&mut self, node: &mut ClassProp, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_class_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_computed_prop_name(
        &mut self,
        node: &mut ComputedPropName,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_computed_prop_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_cond_expr(&mut self, node: &mut CondExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_cond_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_constructor(&mut self, node: &mut Constructor, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_constructor(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_continue_stmt(&mut self, node: &mut ContinueStmt, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_continue_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_debugger_stmt(&mut self, node: &mut DebuggerStmt, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_debugger_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_decl(&mut self, node: &mut Decl, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_decorator(&mut self, node: &mut Decorator, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_decorator(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_decorators(&mut self, node: &mut Vec<Decorator>, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_decorators(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_default_decl(&mut self, node: &mut DefaultDecl, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_default_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_do_while_stmt(&mut self, node: &mut DoWhileStmt, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_do_while_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_empty_stmt(&mut self, node: &mut EmptyStmt, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_empty_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_es_version(&mut self, node: &mut EsVersion, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_es_version(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_export_all(&mut self, node: &mut ExportAll, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_export_all(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_export_decl(&mut self, node: &mut ExportDecl, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_export_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_export_default_decl(
        &mut self,
        node: &mut ExportDefaultDecl,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_export_default_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_export_default_expr(
        &mut self,
        node: &mut ExportDefaultExpr,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_export_default_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_export_default_specifier(
        &mut self,
        node: &mut ExportDefaultSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_export_default_specifier(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_export_named_specifier(
        &mut self,
        node: &mut ExportNamedSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_export_named_specifier(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_export_namespace_specifier(
        &mut self,
        node: &mut ExportNamespaceSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_export_namespace_specifier(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_export_specifier(
        &mut self,
        node: &mut ExportSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_export_specifier(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_export_specifiers(
        &mut self,
        node: &mut Vec<ExportSpecifier>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_export_specifiers(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_expr(&mut self, node: &mut Expr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_expr_or_spread(&mut self, node: &mut ExprOrSpread, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_expr_or_spread(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_expr_or_spreads(
        &mut self,
        node: &mut Vec<ExprOrSpread>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_expr_or_spreads(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_expr_stmt(&mut self, node: &mut ExprStmt, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_expr_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_exprs(&mut self, node: &mut Vec<Box<Expr>>, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_exprs(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_fn_decl(&mut self, node: &mut FnDecl, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_fn_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_fn_expr(&mut self, node: &mut FnExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_fn_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_for_head(&mut self, node: &mut ForHead, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_for_head(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_for_in_stmt(&mut self, node: &mut ForInStmt, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_for_in_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_for_of_stmt(&mut self, node: &mut ForOfStmt, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_for_of_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_for_stmt(&mut self, node: &mut ForStmt, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_for_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_function(&mut self, node: &mut Function, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_function(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_getter_prop(&mut self, node: &mut GetterProp, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_getter_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ident(&mut self, node: &mut Ident, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ident(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ident_name(&mut self, node: &mut IdentName, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ident_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_if_stmt(&mut self, node: &mut IfStmt, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_if_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_import(&mut self, node: &mut Import, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_import(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_import_decl(&mut self, node: &mut ImportDecl, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_import_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_import_default_specifier(
        &mut self,
        node: &mut ImportDefaultSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_import_default_specifier(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_import_named_specifier(
        &mut self,
        node: &mut ImportNamedSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_import_named_specifier(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_import_phase(&mut self, node: &mut ImportPhase, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_import_phase(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_import_specifier(
        &mut self,
        node: &mut ImportSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_import_specifier(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_import_specifiers(
        &mut self,
        node: &mut Vec<ImportSpecifier>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_import_specifiers(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_import_star_as_specifier(
        &mut self,
        node: &mut ImportStarAsSpecifier,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_import_star_as_specifier(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_import_with(&mut self, node: &mut ImportWith, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_import_with(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_import_with_item(
        &mut self,
        node: &mut ImportWithItem,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_import_with_item(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_import_with_items(
        &mut self,
        node: &mut Vec<ImportWithItem>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_import_with_items(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_invalid(&mut self, node: &mut Invalid, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_invalid(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_attr(&mut self, node: &mut JSXAttr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_attr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_attr_name(&mut self, node: &mut JSXAttrName, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_attr_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_attr_or_spread(
        &mut self,
        node: &mut JSXAttrOrSpread,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_attr_or_spread(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_attr_or_spreads(
        &mut self,
        node: &mut Vec<JSXAttrOrSpread>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_attr_or_spreads(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_attr_value(&mut self, node: &mut JSXAttrValue, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_attr_value(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_closing_element(
        &mut self,
        node: &mut JSXClosingElement,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_closing_element(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_closing_fragment(
        &mut self,
        node: &mut JSXClosingFragment,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_closing_fragment(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_element(&mut self, node: &mut JSXElement, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_element(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_element_child(
        &mut self,
        node: &mut JSXElementChild,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_element_child(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_element_childs(
        &mut self,
        node: &mut Vec<JSXElementChild>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_element_childs(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_element_name(
        &mut self,
        node: &mut JSXElementName,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_element_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_empty_expr(&mut self, node: &mut JSXEmptyExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_empty_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_expr(&mut self, node: &mut JSXExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_expr_container(
        &mut self,
        node: &mut JSXExprContainer,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_expr_container(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_fragment(&mut self, node: &mut JSXFragment, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_fragment(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_member_expr(&mut self, node: &mut JSXMemberExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_member_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_namespaced_name(
        &mut self,
        node: &mut JSXNamespacedName,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_namespaced_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_object(&mut self, node: &mut JSXObject, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_object(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_opening_element(
        &mut self,
        node: &mut JSXOpeningElement,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_opening_element(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_opening_fragment(
        &mut self,
        node: &mut JSXOpeningFragment,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_opening_fragment(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_spread_child(
        &mut self,
        node: &mut JSXSpreadChild,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_spread_child(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_jsx_text(&mut self, node: &mut JSXText, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_jsx_text(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_key(&mut self, node: &mut Key, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_key(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_key_value_pat_prop(
        &mut self,
        node: &mut KeyValuePatProp,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_key_value_pat_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_key_value_prop(&mut self, node: &mut KeyValueProp, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_key_value_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_labeled_stmt(&mut self, node: &mut LabeledStmt, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_labeled_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_lit(&mut self, node: &mut Lit, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_lit(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_member_expr(&mut self, node: &mut MemberExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_member_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_member_prop(&mut self, node: &mut MemberProp, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_member_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_meta_prop_expr(&mut self, node: &mut MetaPropExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_meta_prop_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_meta_prop_kind(&mut self, node: &mut MetaPropKind, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_meta_prop_kind(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_method_kind(&mut self, node: &mut MethodKind, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_method_kind(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_method_prop(&mut self, node: &mut MethodProp, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_method_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_module(&mut self, node: &mut Module, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_module(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_module_decl(&mut self, node: &mut ModuleDecl, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_module_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_module_export_name(
        &mut self,
        node: &mut ModuleExportName,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_module_export_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_module_item(&mut self, node: &mut ModuleItem, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_module_item(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_module_items(&mut self, node: &mut Vec<ModuleItem>, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_module_items(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_named_export(&mut self, node: &mut NamedExport, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_named_export(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_new_expr(&mut self, node: &mut NewExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_new_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_null(&mut self, node: &mut Null, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_null(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_number(&mut self, node: &mut Number, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_number(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_object_lit(&mut self, node: &mut ObjectLit, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_object_lit(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_object_pat(&mut self, node: &mut ObjectPat, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_object_pat(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_object_pat_prop(&mut self, node: &mut ObjectPatProp, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_object_pat_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_object_pat_props(
        &mut self,
        node: &mut Vec<ObjectPatProp>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_object_pat_props(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_accessibility(
        &mut self,
        node: &mut Option<Accessibility>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_accessibility(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_atom(
        &mut self,
        node: &mut Option<swc_atoms::Atom>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_atom(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_block_stmt(
        &mut self,
        node: &mut Option<BlockStmt>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_block_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_call(&mut self, node: &mut OptCall, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_call(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_catch_clause(
        &mut self,
        node: &mut Option<CatchClause>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_catch_clause(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_chain_base(&mut self, node: &mut OptChainBase, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_chain_base(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_chain_expr(&mut self, node: &mut OptChainExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_chain_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_expr(&mut self, node: &mut Option<Box<Expr>>, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_expr_or_spread(
        &mut self,
        node: &mut Option<ExprOrSpread>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_expr_or_spread(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_expr_or_spreads(
        &mut self,
        node: &mut Option<Vec<ExprOrSpread>>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_expr_or_spreads(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_ident(&mut self, node: &mut Option<Ident>, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_ident(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_jsx_attr_value(
        &mut self,
        node: &mut Option<JSXAttrValue>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_jsx_attr_value(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_jsx_closing_element(
        &mut self,
        node: &mut Option<JSXClosingElement>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_jsx_closing_element(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_module_export_name(
        &mut self,
        node: &mut Option<ModuleExportName>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_module_export_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_module_items(
        &mut self,
        node: &mut Option<Vec<ModuleItem>>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_module_items(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_object_lit(
        &mut self,
        node: &mut Option<Box<ObjectLit>>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_object_lit(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_pat(&mut self, node: &mut Option<Pat>, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_pat(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_span(
        &mut self,
        node: &mut Option<swc_common::Span>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_span(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_stmt(&mut self, node: &mut Option<Box<Stmt>>, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_str(&mut self, node: &mut Option<Box<Str>>, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_str(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_true_plus_minus(
        &mut self,
        node: &mut Option<TruePlusMinus>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_true_plus_minus(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_ts_entity_name(
        &mut self,
        node: &mut Option<TsEntityName>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_ts_entity_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_ts_namespace_body(
        &mut self,
        node: &mut Option<TsNamespaceBody>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_ts_namespace_body(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_ts_type(
        &mut self,
        node: &mut Option<Box<TsType>>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_ts_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_ts_type_ann(
        &mut self,
        node: &mut Option<Box<TsTypeAnn>>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_ts_type_ann(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_ts_type_param_decl(
        &mut self,
        node: &mut Option<Box<TsTypeParamDecl>>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_ts_type_param_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_ts_type_param_instantiation(
        &mut self,
        node: &mut Option<Box<TsTypeParamInstantiation>>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_ts_type_param_instantiation(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_var_decl_or_expr(
        &mut self,
        node: &mut Option<VarDeclOrExpr>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_var_decl_or_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_vec_expr_or_spreads(
        &mut self,
        node: &mut Vec<Option<ExprOrSpread>>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_vec_expr_or_spreads(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_opt_vec_pats(&mut self, node: &mut Vec<Option<Pat>>, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_opt_vec_pats(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_param(&mut self, node: &mut Param, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_param(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_param_or_ts_param_prop(
        &mut self,
        node: &mut ParamOrTsParamProp,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_param_or_ts_param_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_param_or_ts_param_props(
        &mut self,
        node: &mut Vec<ParamOrTsParamProp>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_param_or_ts_param_props(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_params(&mut self, node: &mut Vec<Param>, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_params(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_paren_expr(&mut self, node: &mut ParenExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_paren_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_pat(&mut self, node: &mut Pat, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_pat(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_pats(&mut self, node: &mut Vec<Pat>, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_pats(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_private_method(&mut self, node: &mut PrivateMethod, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_private_method(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_private_name(&mut self, node: &mut PrivateName, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_private_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_private_prop(&mut self, node: &mut PrivateProp, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_private_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_program(&mut self, node: &mut Program, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_program(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_prop(&mut self, node: &mut Prop, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_prop_name(&mut self, node: &mut PropName, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_prop_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_prop_or_spread(&mut self, node: &mut PropOrSpread, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_prop_or_spread(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_prop_or_spreads(
        &mut self,
        node: &mut Vec<PropOrSpread>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_prop_or_spreads(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_regex(&mut self, node: &mut Regex, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_regex(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_reserved_unused(&mut self, node: &mut ReservedUnused, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_reserved_unused(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_rest_pat(&mut self, node: &mut RestPat, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_rest_pat(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_return_stmt(&mut self, node: &mut ReturnStmt, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_return_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_script(&mut self, node: &mut Script, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_script(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_seq_expr(&mut self, node: &mut SeqExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_seq_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_setter_prop(&mut self, node: &mut SetterProp, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_setter_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_simple_assign_target(
        &mut self,
        node: &mut SimpleAssignTarget,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_simple_assign_target(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_span(&mut self, node: &mut swc_common::Span, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_span(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_spread_element(&mut self, node: &mut SpreadElement, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_spread_element(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_static_block(&mut self, node: &mut StaticBlock, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_static_block(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_stmt(&mut self, node: &mut Stmt, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_stmts(&mut self, node: &mut Vec<Stmt>, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_stmts(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_str(&mut self, node: &mut Str, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_str(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_super(&mut self, node: &mut Super, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_super(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_super_prop(&mut self, node: &mut SuperProp, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_super_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_super_prop_expr(&mut self, node: &mut SuperPropExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_super_prop_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_switch_case(&mut self, node: &mut SwitchCase, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_switch_case(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_switch_cases(&mut self, node: &mut Vec<SwitchCase>, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_switch_cases(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_switch_stmt(&mut self, node: &mut SwitchStmt, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_switch_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_syntax_context(
        &mut self,
        node: &mut swc_common::SyntaxContext,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_syntax_context(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_tagged_tpl(&mut self, node: &mut TaggedTpl, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_tagged_tpl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_this_expr(&mut self, node: &mut ThisExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_this_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_throw_stmt(&mut self, node: &mut ThrowStmt, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_throw_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_tpl(&mut self, node: &mut Tpl, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_tpl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_tpl_element(&mut self, node: &mut TplElement, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_tpl_element(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_tpl_elements(&mut self, node: &mut Vec<TplElement>, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_tpl_elements(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_true_plus_minus(&mut self, node: &mut TruePlusMinus, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_true_plus_minus(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_try_stmt(&mut self, node: &mut TryStmt, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_try_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_array_type(&mut self, node: &mut TsArrayType, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_array_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_as_expr(&mut self, node: &mut TsAsExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_as_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_call_signature_decl(
        &mut self,
        node: &mut TsCallSignatureDecl,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_call_signature_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_conditional_type(
        &mut self,
        node: &mut TsConditionalType,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_conditional_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_const_assertion(
        &mut self,
        node: &mut TsConstAssertion,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_const_assertion(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_construct_signature_decl(
        &mut self,
        node: &mut TsConstructSignatureDecl,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_construct_signature_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_constructor_type(
        &mut self,
        node: &mut TsConstructorType,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_constructor_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_entity_name(&mut self, node: &mut TsEntityName, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_entity_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_enum_decl(&mut self, node: &mut TsEnumDecl, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_enum_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_enum_member(&mut self, node: &mut TsEnumMember, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_enum_member(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_enum_member_id(
        &mut self,
        node: &mut TsEnumMemberId,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_enum_member_id(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_enum_members(
        &mut self,
        node: &mut Vec<TsEnumMember>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_enum_members(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_export_assignment(
        &mut self,
        node: &mut TsExportAssignment,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_export_assignment(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_expr_with_type_args(
        &mut self,
        node: &mut TsExprWithTypeArgs,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_expr_with_type_args(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_expr_with_type_argss(
        &mut self,
        node: &mut Vec<TsExprWithTypeArgs>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_expr_with_type_argss(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_external_module_ref(
        &mut self,
        node: &mut TsExternalModuleRef,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_external_module_ref(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_fn_or_constructor_type(
        &mut self,
        node: &mut TsFnOrConstructorType,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_fn_or_constructor_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_fn_param(&mut self, node: &mut TsFnParam, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_fn_param(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_fn_params(&mut self, node: &mut Vec<TsFnParam>, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_fn_params(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_fn_type(&mut self, node: &mut TsFnType, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_fn_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_getter_signature(
        &mut self,
        node: &mut TsGetterSignature,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_getter_signature(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_import_equals_decl(
        &mut self,
        node: &mut TsImportEqualsDecl,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_import_equals_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_import_type(&mut self, node: &mut TsImportType, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_import_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_index_signature(
        &mut self,
        node: &mut TsIndexSignature,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_index_signature(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_indexed_access_type(
        &mut self,
        node: &mut TsIndexedAccessType,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_indexed_access_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_infer_type(&mut self, node: &mut TsInferType, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_infer_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_instantiation(
        &mut self,
        node: &mut TsInstantiation,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_instantiation(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_interface_body(
        &mut self,
        node: &mut TsInterfaceBody,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_interface_body(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_interface_decl(
        &mut self,
        node: &mut TsInterfaceDecl,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_interface_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_intersection_type(
        &mut self,
        node: &mut TsIntersectionType,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_intersection_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_keyword_type(&mut self, node: &mut TsKeywordType, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_keyword_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_keyword_type_kind(
        &mut self,
        node: &mut TsKeywordTypeKind,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_keyword_type_kind(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_lit(&mut self, node: &mut TsLit, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_lit(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_lit_type(&mut self, node: &mut TsLitType, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_lit_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_mapped_type(&mut self, node: &mut TsMappedType, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_mapped_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_method_signature(
        &mut self,
        node: &mut TsMethodSignature,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_method_signature(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_module_block(&mut self, node: &mut TsModuleBlock, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_module_block(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_module_decl(&mut self, node: &mut TsModuleDecl, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_module_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_module_name(&mut self, node: &mut TsModuleName, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_module_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_module_ref(&mut self, node: &mut TsModuleRef, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_module_ref(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_namespace_body(
        &mut self,
        node: &mut TsNamespaceBody,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_namespace_body(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_namespace_decl(
        &mut self,
        node: &mut TsNamespaceDecl,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_namespace_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_namespace_export_decl(
        &mut self,
        node: &mut TsNamespaceExportDecl,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_namespace_export_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_non_null_expr(&mut self, node: &mut TsNonNullExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_non_null_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_optional_type(
        &mut self,
        node: &mut TsOptionalType,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_optional_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_param_prop(&mut self, node: &mut TsParamProp, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_param_prop(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_param_prop_param(
        &mut self,
        node: &mut TsParamPropParam,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_param_prop_param(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_parenthesized_type(
        &mut self,
        node: &mut TsParenthesizedType,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_parenthesized_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_property_signature(
        &mut self,
        node: &mut TsPropertySignature,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_property_signature(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_qualified_name(
        &mut self,
        node: &mut TsQualifiedName,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_qualified_name(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_rest_type(&mut self, node: &mut TsRestType, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_rest_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_satisfies_expr(
        &mut self,
        node: &mut TsSatisfiesExpr,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_satisfies_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_setter_signature(
        &mut self,
        node: &mut TsSetterSignature,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_setter_signature(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_this_type(&mut self, node: &mut TsThisType, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_this_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_this_type_or_ident(
        &mut self,
        node: &mut TsThisTypeOrIdent,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_this_type_or_ident(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_tpl_lit_type(&mut self, node: &mut TsTplLitType, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_tpl_lit_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_tuple_element(
        &mut self,
        node: &mut TsTupleElement,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_tuple_element(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_tuple_elements(
        &mut self,
        node: &mut Vec<TsTupleElement>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_tuple_elements(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_tuple_type(&mut self, node: &mut TsTupleType, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_tuple_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_type(&mut self, node: &mut TsType, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_type_alias_decl(
        &mut self,
        node: &mut TsTypeAliasDecl,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_type_alias_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_type_ann(&mut self, node: &mut TsTypeAnn, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_type_ann(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_type_assertion(
        &mut self,
        node: &mut TsTypeAssertion,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_type_assertion(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_type_element(&mut self, node: &mut TsTypeElement, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_type_element(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_type_elements(
        &mut self,
        node: &mut Vec<TsTypeElement>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_type_elements(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_type_lit(&mut self, node: &mut TsTypeLit, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_type_lit(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_type_operator(
        &mut self,
        node: &mut TsTypeOperator,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_type_operator(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_type_operator_op(
        &mut self,
        node: &mut TsTypeOperatorOp,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_type_operator_op(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_type_param(&mut self, node: &mut TsTypeParam, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_type_param(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_type_param_decl(
        &mut self,
        node: &mut TsTypeParamDecl,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_type_param_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_type_param_instantiation(
        &mut self,
        node: &mut TsTypeParamInstantiation,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_type_param_instantiation(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_type_params(
        &mut self,
        node: &mut Vec<TsTypeParam>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_type_params(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_type_predicate(
        &mut self,
        node: &mut TsTypePredicate,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_type_predicate(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_type_query(&mut self, node: &mut TsTypeQuery, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_type_query(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_type_query_expr(
        &mut self,
        node: &mut TsTypeQueryExpr,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_type_query_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_type_ref(&mut self, node: &mut TsTypeRef, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_type_ref(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_types(&mut self, node: &mut Vec<Box<TsType>>, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_types(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_union_or_intersection_type(
        &mut self,
        node: &mut TsUnionOrIntersectionType,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_union_or_intersection_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_ts_union_type(&mut self, node: &mut TsUnionType, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_ts_union_type(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_unary_expr(&mut self, node: &mut UnaryExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_unary_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_unary_op(&mut self, node: &mut UnaryOp, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_unary_op(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_update_expr(&mut self, node: &mut UpdateExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_update_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_update_op(&mut self, node: &mut UpdateOp, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_update_op(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_using_decl(&mut self, node: &mut UsingDecl, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_using_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_var_decl(&mut self, node: &mut VarDecl, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_var_decl(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_var_decl_kind(&mut self, node: &mut VarDeclKind, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_var_decl_kind(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_var_decl_or_expr(&mut self, node: &mut VarDeclOrExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_var_decl_or_expr(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_var_declarator(&mut self, node: &mut VarDeclarator, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_var_declarator(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_var_declarators(
        &mut self,
        node: &mut Vec<VarDeclarator>,
        ast_path: &mut AstKindPath,
    ) {
        if self.enabled {
            VisitMutAstPath::visit_mut_var_declarators(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_while_stmt(&mut self, node: &mut WhileStmt, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_while_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_with_stmt(&mut self, node: &mut WithStmt, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_with_stmt(self, node, ast_path)
        } else {
        }
    }

    fn visit_mut_yield_expr(&mut self, node: &mut YieldExpr, ast_path: &mut AstKindPath) {
        if self.enabled {
            VisitMutAstPath::visit_mut_yield_expr(self, node, ast_path)
        } else {
        }
    }
}
#[doc = r" A trait implemented for types that can be visited using a visitor."]
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
pub trait VisitMutWithAstPath<V: ?Sized + VisitMutAstPath> {
    #[doc = r" Calls a visitor method (visitor.fold_xxx) with self."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath);
    #[doc = r" Visit children nodes of `self`` with `visitor`."]
    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath);
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Accessibility {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_accessibility`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_accessibility(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Accessibility::Public => {}
            Accessibility::Protected => {}
            Accessibility::Private => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ArrayLit {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_array_lit`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_array_lit(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ArrayLit { span, elems } => {
                <Vec<Option<ExprOrSpread>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    elems, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ArrayPat {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_array_pat`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_array_pat(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ArrayPat {
                span,
                elems,
                optional,
                type_ann,
            } => {
                <Vec<Option<Pat>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    elems, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ArrowExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_arrow_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_arrow_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ArrowExpr {
                span,
                ctxt,
                params,
                body,
                is_async,
                is_generator,
                type_params,
                return_type,
            } => {
                <Vec<Pat> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    params, visitor, ast_path,
                );
                <Box<BlockStmtOrExpr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
                <Option<Box<TsTypeParamDecl>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    return_type,
                    visitor,
                    ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for AssignExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_assign_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            AssignExpr {
                span,
                op,
                left,
                right,
            } => {
                <AssignOp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    op, visitor, ast_path,
                );
                <AssignTarget as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    left, visitor, ast_path,
                );
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    right, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for AssignOp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_assign_op`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_op(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            AssignOp::Assign => {}
            AssignOp::AddAssign => {}
            AssignOp::SubAssign => {}
            AssignOp::MulAssign => {}
            AssignOp::DivAssign => {}
            AssignOp::ModAssign => {}
            AssignOp::LShiftAssign => {}
            AssignOp::RShiftAssign => {}
            AssignOp::ZeroFillRShiftAssign => {}
            AssignOp::BitOrAssign => {}
            AssignOp::BitXorAssign => {}
            AssignOp::BitAndAssign => {}
            AssignOp::ExpAssign => {}
            AssignOp::AndAssign => {}
            AssignOp::OrAssign => {}
            AssignOp::NullishAssign => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for AssignPat {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_assign_pat`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_pat(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            AssignPat { span, left, right } => {
                <Box<Pat> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    left, visitor, ast_path,
                );
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    right, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for AssignPatProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_assign_pat_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_pat_prop(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            AssignPatProp { span, key, value } => {
                <BindingIdent as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    key, visitor, ast_path,
                );
                <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    value, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for AssignProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_assign_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_prop(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            AssignProp { span, key, value } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(key, visitor, ast_path);
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    value, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for AssignTarget {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_assign_target`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_target(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            AssignTarget::Simple { 0: _field_0 } => {
                <SimpleAssignTarget as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            AssignTarget::Pat { 0: _field_0 } => {
                <AssignTargetPat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for AssignTargetPat {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_assign_target_pat`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_assign_target_pat(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            AssignTargetPat::Array { 0: _field_0 } => {
                <ArrayPat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            AssignTargetPat::Object { 0: _field_0 } => {
                <ObjectPat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            AssignTargetPat::Invalid { 0: _field_0 } => {
                <Invalid as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for AutoAccessor {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_auto_accessor`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_auto_accessor(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            AutoAccessor {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_override,
                definite,
            } => {
                <Key as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(key, visitor, ast_path);
                <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    value, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                <Vec<Decorator> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    decorators, visitor, ast_path,
                );
                <Option<Accessibility> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    accessibility,
                    visitor,
                    ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for AwaitExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_await_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_await_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            AwaitExpr { span, arg } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    arg, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for BigInt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_big_int`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_big_int(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            BigInt { span, value, raw } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for BinExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_bin_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_bin_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            BinExpr {
                span,
                op,
                left,
                right,
            } => {
                <BinaryOp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    op, visitor, ast_path,
                );
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    left, visitor, ast_path,
                );
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    right, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for BinaryOp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_binary_op`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_binary_op(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            BinaryOp::EqEq => {}
            BinaryOp::NotEq => {}
            BinaryOp::EqEqEq => {}
            BinaryOp::NotEqEq => {}
            BinaryOp::Lt => {}
            BinaryOp::LtEq => {}
            BinaryOp::Gt => {}
            BinaryOp::GtEq => {}
            BinaryOp::LShift => {}
            BinaryOp::RShift => {}
            BinaryOp::ZeroFillRShift => {}
            BinaryOp::Add => {}
            BinaryOp::Sub => {}
            BinaryOp::Mul => {}
            BinaryOp::Div => {}
            BinaryOp::Mod => {}
            BinaryOp::BitOr => {}
            BinaryOp::BitXor => {}
            BinaryOp::BitAnd => {}
            BinaryOp::LogicalOr => {}
            BinaryOp::LogicalAnd => {}
            BinaryOp::In => {}
            BinaryOp::InstanceOf => {}
            BinaryOp::Exp => {}
            BinaryOp::NullishCoalescing => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for BindingIdent {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_binding_ident`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_binding_ident(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            BindingIdent { id, type_ann } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(id, visitor, ast_path);
                <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for BlockStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_block_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_block_stmt(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            BlockStmt { span, ctxt, stmts } => {
                <Vec<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    stmts, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for BlockStmtOrExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_block_stmt_or_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_block_stmt_or_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            BlockStmtOrExpr::BlockStmt { 0: _field_0 } => {
                <BlockStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            BlockStmtOrExpr::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Bool {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_bool`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_bool(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Bool { span, value } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for BreakStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_break_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_break_stmt(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            BreakStmt { span, label } => {
                <Option<Ident> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    label, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for CallExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_call_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_call_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            CallExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                <Callee as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    callee, visitor, ast_path,
                );
                <Vec<ExprOrSpread> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    args, visitor, ast_path,
                );
                < Option < Box < TsTypeParamInstantiation > > as VisitMutWithAstPath < V > > :: visit_mut_with_ast_path (type_args , visitor , ast_path) ;
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Callee {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_callee`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_callee(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Callee::Super { 0: _field_0 } => {
                <Super as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Callee::Import { 0: _field_0 } => {
                <Import as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Callee::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for CatchClause {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_catch_clause`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_catch_clause(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            CatchClause { span, param, body } => {
                <Option<Pat> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    param, visitor, ast_path,
                );
                <BlockStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Class {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_class`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Class {
                span,
                ctxt,
                decorators,
                body,
                super_class,
                is_abstract,
                type_params,
                super_type_params,
                implements,
            } => {
                <Vec<Decorator> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    decorators, visitor, ast_path,
                );
                <Vec<ClassMember> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
                <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    super_class,
                    visitor,
                    ast_path,
                );
                <Option<Box<TsTypeParamDecl>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
                < Option < Box < TsTypeParamInstantiation > > as VisitMutWithAstPath < V > > :: visit_mut_with_ast_path (super_type_params , visitor , ast_path) ;
                <Vec<TsExprWithTypeArgs> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    implements, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ClassDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_class_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_decl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ClassDecl {
                ident,
                declare,
                class,
            } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    ident, visitor, ast_path,
                );
                <Box<Class> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    class, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ClassExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_class_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ClassExpr { ident, class } => {
                <Option<Ident> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    ident, visitor, ast_path,
                );
                <Box<Class> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    class, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ClassMember {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_class_member`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_member(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ClassMember::Constructor { 0: _field_0 } => {
                <Constructor as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ClassMember::Method { 0: _field_0 } => {}
            ClassMember::PrivateMethod { 0: _field_0 } => {}
            ClassMember::ClassProp { 0: _field_0 } => {
                <ClassProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ClassMember::PrivateProp { 0: _field_0 } => {
                <PrivateProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ClassMember::TsIndexSignature { 0: _field_0 } => {
                <TsIndexSignature as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ClassMember::Empty { 0: _field_0 } => {
                <EmptyStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ClassMember::StaticBlock { 0: _field_0 } => {
                <StaticBlock as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ClassMember::AutoAccessor { 0: _field_0 } => {
                <AutoAccessor as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ClassProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_class_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_prop(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ClassProp {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
                readonly,
                declare,
                definite,
            } => {
                <PropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    key, visitor, ast_path,
                );
                <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    value, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                <Vec<Decorator> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    decorators, visitor, ast_path,
                );
                <Option<Accessibility> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    accessibility,
                    visitor,
                    ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ComputedPropName {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_computed_prop_name`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_computed_prop_name(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ComputedPropName { span, expr } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    expr, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for CondExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_cond_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_cond_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            CondExpr {
                span,
                test,
                cons,
                alt,
            } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    test, visitor, ast_path,
                );
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    cons, visitor, ast_path,
                );
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    alt, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Constructor {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_constructor`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_constructor(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Constructor {
                span,
                ctxt,
                key,
                params,
                body,
                accessibility,
                is_optional,
            } => {
                <PropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    key, visitor, ast_path,
                );
                <Vec<ParamOrTsParamProp> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    params, visitor, ast_path,
                );
                <Option<BlockStmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
                <Option<Accessibility> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    accessibility,
                    visitor,
                    ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ContinueStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_continue_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_continue_stmt(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ContinueStmt { span, label } => {
                <Option<Ident> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    label, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for DebuggerStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_debugger_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_debugger_stmt(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            DebuggerStmt { span } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Decl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_decl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Decl::Class { 0: _field_0 } => {
                <ClassDecl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Decl::Fn { 0: _field_0 } => {
                <FnDecl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Decl::Var { 0: _field_0 } => {
                <Box<VarDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Decl::Using { 0: _field_0 } => {
                <Box<UsingDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Decl::TsInterface { 0: _field_0 } => {
                <Box<TsInterfaceDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Decl::TsTypeAlias { 0: _field_0 } => {
                <Box<TsTypeAliasDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Decl::TsEnum { 0: _field_0 } => {
                <Box<TsEnumDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Decl::TsModule { 0: _field_0 } => {
                <Box<TsModuleDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Decorator {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_decorator`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_decorator(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Decorator { span, expr } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    expr, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for DefaultDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_default_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_default_decl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            DefaultDecl::Class { 0: _field_0 } => {
                <ClassExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            DefaultDecl::Fn { 0: _field_0 } => {
                <FnExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            DefaultDecl::TsInterfaceDecl { 0: _field_0 } => {
                <Box<TsInterfaceDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for DoWhileStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_do_while_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_do_while_stmt(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            DoWhileStmt { span, test, body } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    test, visitor, ast_path,
                );
                <Box<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for EmptyStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_empty_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_empty_stmt(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            EmptyStmt { span } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for EsVersion {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_es_version`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_es_version(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            EsVersion::Es3 => {}
            EsVersion::Es5 => {}
            EsVersion::Es2015 => {}
            EsVersion::Es2016 => {}
            EsVersion::Es2017 => {}
            EsVersion::Es2018 => {}
            EsVersion::Es2019 => {}
            EsVersion::Es2020 => {}
            EsVersion::Es2021 => {}
            EsVersion::Es2022 => {}
            EsVersion::EsNext => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ExportAll {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_export_all`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_all(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ExportAll {
                span,
                src,
                type_only,
                with,
            } => {
                <Box<Str> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    src, visitor, ast_path,
                );
                <Option<Box<ObjectLit>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    with, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ExportDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_export_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_decl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ExportDecl { span, decl } => {
                <Decl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(decl, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ExportDefaultDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_export_default_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_default_decl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ExportDefaultDecl { span, decl } => {
                <DefaultDecl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    decl, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ExportDefaultExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_export_default_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_default_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ExportDefaultExpr { span, expr } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    expr, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ExportDefaultSpecifier {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_export_default_specifier`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_default_specifier(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ExportDefaultSpecifier { exported } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    exported, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ExportNamedSpecifier {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_export_named_specifier`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_named_specifier(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ExportNamedSpecifier {
                span,
                orig,
                exported,
                is_type_only,
            } => {
                <ModuleExportName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    orig, visitor, ast_path,
                );
                <Option<ModuleExportName> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    exported, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ExportNamespaceSpecifier {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_export_namespace_specifier`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_namespace_specifier(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ExportNamespaceSpecifier { span, name } => {
                <ModuleExportName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    name, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ExportSpecifier {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_export_specifier`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_specifier(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ExportSpecifier::Namespace { 0: _field_0 } => {
                <ExportNamespaceSpecifier as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ExportSpecifier::Default { 0: _field_0 } => {
                <ExportDefaultSpecifier as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ExportSpecifier::Named { 0: _field_0 } => {
                <ExportNamedSpecifier as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Expr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Expr::This { 0: _field_0 } => {
                <ThisExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Array { 0: _field_0 } => {
                <ArrayLit as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Object { 0: _field_0 } => {
                <ObjectLit as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Fn { 0: _field_0 } => {
                <FnExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Unary { 0: _field_0 } => {
                <UnaryExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Update { 0: _field_0 } => {
                <UpdateExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Bin { 0: _field_0 } => {
                <BinExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Assign { 0: _field_0 } => {
                <AssignExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Member { 0: _field_0 } => {
                <MemberExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::SuperProp { 0: _field_0 } => {
                <SuperPropExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Cond { 0: _field_0 } => {
                <CondExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Call { 0: _field_0 } => {
                <CallExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::New { 0: _field_0 } => {
                <NewExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Seq { 0: _field_0 } => {
                <SeqExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Ident { 0: _field_0 } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Lit { 0: _field_0 } => {
                <Lit as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Tpl { 0: _field_0 } => {
                <Tpl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::TaggedTpl { 0: _field_0 } => {
                <TaggedTpl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Arrow { 0: _field_0 } => {
                <ArrowExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Class { 0: _field_0 } => {
                <ClassExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Yield { 0: _field_0 } => {
                <YieldExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::MetaProp { 0: _field_0 } => {
                <MetaPropExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Await { 0: _field_0 } => {
                <AwaitExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Paren { 0: _field_0 } => {
                <ParenExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::JSXMember { 0: _field_0 } => {
                <JSXMemberExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::JSXNamespacedName { 0: _field_0 } => {
                <JSXNamespacedName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::JSXEmpty { 0: _field_0 } => {
                <JSXEmptyExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::JSXElement { 0: _field_0 } => {
                <Box<JSXElement> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::JSXFragment { 0: _field_0 } => {
                <JSXFragment as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::TsTypeAssertion { 0: _field_0 } => {
                <TsTypeAssertion as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::TsConstAssertion { 0: _field_0 } => {
                <TsConstAssertion as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::TsNonNull { 0: _field_0 } => {
                <TsNonNullExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::TsAs { 0: _field_0 } => {
                <TsAsExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::TsInstantiation { 0: _field_0 } => {
                <TsInstantiation as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::TsSatisfies { 0: _field_0 } => {
                <TsSatisfiesExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::PrivateName { 0: _field_0 } => {
                <PrivateName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::OptChain { 0: _field_0 } => {
                <OptChainExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Expr::Invalid { 0: _field_0 } => {
                <Invalid as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ExprOrSpread {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_expr_or_spread`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_expr_or_spread(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ExprOrSpread { spread, expr } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    expr, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ExprStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_expr_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_expr_stmt(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ExprStmt { span, expr } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    expr, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for FnDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_fn_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_fn_decl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            FnDecl {
                ident,
                declare,
                function,
            } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    ident, visitor, ast_path,
                );
                <Box<Function> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    function, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for FnExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_fn_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_fn_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            FnExpr { ident, function } => {
                <Option<Ident> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    ident, visitor, ast_path,
                );
                <Box<Function> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    function, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ForHead {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_for_head`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_for_head(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ForHead::VarDecl { 0: _field_0 } => {
                <Box<VarDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ForHead::UsingDecl { 0: _field_0 } => {
                <Box<UsingDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ForHead::Pat { 0: _field_0 } => {
                <Box<Pat> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ForInStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_for_in_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_for_in_stmt(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ForInStmt {
                span,
                left,
                right,
                body,
            } => {
                <ForHead as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    left, visitor, ast_path,
                );
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    right, visitor, ast_path,
                );
                <Box<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ForOfStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_for_of_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_for_of_stmt(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ForOfStmt {
                span,
                is_await,
                left,
                right,
                body,
            } => {
                <ForHead as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    left, visitor, ast_path,
                );
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    right, visitor, ast_path,
                );
                <Box<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ForStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_for_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_for_stmt(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ForStmt {
                span,
                init,
                test,
                update,
                body,
            } => {
                <Option<VarDeclOrExpr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    init, visitor, ast_path,
                );
                <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    test, visitor, ast_path,
                );
                <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    update, visitor, ast_path,
                );
                <Box<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Function {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_function`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_function(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Function {
                params,
                decorators,
                span,
                ctxt,
                body,
                is_generator,
                is_async,
                type_params,
                return_type,
            } => {
                <Vec<Param> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    params, visitor, ast_path,
                );
                <Vec<Decorator> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    decorators, visitor, ast_path,
                );
                <Option<BlockStmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
                <Option<Box<TsTypeParamDecl>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    return_type,
                    visitor,
                    ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for GetterProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_getter_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_getter_prop(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            GetterProp {
                span,
                key,
                type_ann,
                body,
            } => {
                <PropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    key, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                <Option<BlockStmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Ident {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ident`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ident(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Ident {
                span,
                ctxt,
                sym,
                optional,
            } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for IdentName {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ident_name`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ident_name(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            IdentName { span, sym } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for IfStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_if_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_if_stmt(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            IfStmt {
                span,
                test,
                cons,
                alt,
            } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    test, visitor, ast_path,
                );
                <Box<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    cons, visitor, ast_path,
                );
                <Option<Box<Stmt>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    alt, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Import {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Import { span, phase } => {
                <ImportPhase as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    phase, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ImportDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_decl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ImportDecl {
                span,
                specifiers,
                src,
                type_only,
                with,
                phase,
            } => {
                <Vec<ImportSpecifier> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    specifiers, visitor, ast_path,
                );
                <Box<Str> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    src, visitor, ast_path,
                );
                <Option<Box<ObjectLit>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    with, visitor, ast_path,
                );
                <ImportPhase as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    phase, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ImportDefaultSpecifier {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import_default_specifier`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_default_specifier(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ImportDefaultSpecifier { span, local } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    local, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ImportNamedSpecifier {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import_named_specifier`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_named_specifier(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ImportNamedSpecifier {
                span,
                local,
                imported,
                is_type_only,
            } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    local, visitor, ast_path,
                );
                <Option<ModuleExportName> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    imported, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ImportPhase {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import_phase`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_phase(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ImportPhase::Evaluation => {}
            ImportPhase::Source => {}
            ImportPhase::Defer => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ImportSpecifier {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import_specifier`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_specifier(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ImportSpecifier::Named { 0: _field_0 } => {
                <ImportNamedSpecifier as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ImportSpecifier::Default { 0: _field_0 } => {
                <ImportDefaultSpecifier as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ImportSpecifier::Namespace { 0: _field_0 } => {
                <ImportStarAsSpecifier as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ImportStarAsSpecifier {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import_star_as_specifier`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_star_as_specifier(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ImportStarAsSpecifier { span, local } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    local, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ImportWith {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import_with`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_with(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ImportWith { span, values } => {
                <Vec<ImportWithItem> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    values, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ImportWithItem {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import_with_item`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_with_item(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ImportWithItem { key, value } => {
                <IdentName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    key, visitor, ast_path,
                );
                <Str as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(value, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Invalid {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_invalid`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_invalid(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Invalid { span } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXAttr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_attr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_attr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            JSXAttr { span, name, value } => {
                <JSXAttrName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    name, visitor, ast_path,
                );
                <Option<JSXAttrValue> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    value, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXAttrName {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_attr_name`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_attr_name(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            JSXAttrName::Ident { 0: _field_0 } => {
                <IdentName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXAttrName::JSXNamespacedName { 0: _field_0 } => {
                <JSXNamespacedName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXAttrOrSpread {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_attr_or_spread`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_attr_or_spread(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            JSXAttrOrSpread::JSXAttr { 0: _field_0 } => {
                <JSXAttr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXAttrOrSpread::SpreadElement { 0: _field_0 } => {
                <SpreadElement as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXAttrValue {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_attr_value`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_attr_value(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            JSXAttrValue::Lit { 0: _field_0 } => {
                <Lit as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXAttrValue::JSXExprContainer { 0: _field_0 } => {
                <JSXExprContainer as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXAttrValue::JSXElement { 0: _field_0 } => {
                <Box<JSXElement> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXAttrValue::JSXFragment { 0: _field_0 } => {
                <JSXFragment as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXClosingElement {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_closing_element`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_closing_element(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            JSXClosingElement { span, name } => {
                <JSXElementName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    name, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXClosingFragment {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_closing_fragment`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_closing_fragment(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            JSXClosingFragment { span } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXElement {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_element`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_element(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            JSXElement {
                span,
                opening,
                children,
                closing,
            } => {
                <JSXOpeningElement as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    opening, visitor, ast_path,
                );
                <Vec<JSXElementChild> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    children, visitor, ast_path,
                );
                <Option<JSXClosingElement> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    closing, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXElementChild {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_element_child`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_element_child(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            JSXElementChild::JSXText { 0: _field_0 } => {
                <JSXText as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXElementChild::JSXExprContainer { 0: _field_0 } => {
                <JSXExprContainer as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXElementChild::JSXSpreadChild { 0: _field_0 } => {
                <JSXSpreadChild as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXElementChild::JSXElement { 0: _field_0 } => {
                <Box<JSXElement> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXElementChild::JSXFragment { 0: _field_0 } => {
                <JSXFragment as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXElementName {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_element_name`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_element_name(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            JSXElementName::Ident { 0: _field_0 } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXElementName::JSXMemberExpr { 0: _field_0 } => {
                <JSXMemberExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXElementName::JSXNamespacedName { 0: _field_0 } => {
                <JSXNamespacedName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXEmptyExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_empty_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_empty_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            JSXEmptyExpr { span } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            JSXExpr::JSXEmptyExpr { 0: _field_0 } => {
                <JSXEmptyExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXExpr::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXExprContainer {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_expr_container`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_expr_container(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            JSXExprContainer { span, expr } => {
                <JSXExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    expr, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXFragment {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_fragment`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_fragment(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            JSXFragment {
                span,
                opening,
                children,
                closing,
            } => {
                <JSXOpeningFragment as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    opening, visitor, ast_path,
                );
                <Vec<JSXElementChild> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    children, visitor, ast_path,
                );
                <JSXClosingFragment as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    closing, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXMemberExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_member_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_member_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            JSXMemberExpr { span, obj, prop } => {
                <JSXObject as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    obj, visitor, ast_path,
                );
                <IdentName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    prop, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXNamespacedName {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_namespaced_name`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_namespaced_name(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            JSXNamespacedName { span, ns, name } => {
                <IdentName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    ns, visitor, ast_path,
                );
                <IdentName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    name, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXObject {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_object`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_object(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            JSXObject::JSXMemberExpr { 0: _field_0 } => {
                <Box<JSXMemberExpr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            JSXObject::Ident { 0: _field_0 } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXOpeningElement {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_opening_element`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_opening_element(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            JSXOpeningElement {
                name,
                span,
                attrs,
                self_closing,
                type_args,
            } => {
                <JSXElementName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    name, visitor, ast_path,
                );
                <Vec<JSXAttrOrSpread> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    attrs, visitor, ast_path,
                );
                < Option < Box < TsTypeParamInstantiation > > as VisitMutWithAstPath < V > > :: visit_mut_with_ast_path (type_args , visitor , ast_path) ;
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXOpeningFragment {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_opening_fragment`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_opening_fragment(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            JSXOpeningFragment { span } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXSpreadChild {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_spread_child`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_spread_child(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            JSXSpreadChild { span, expr } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    expr, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for JSXText {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_text`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_text(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            JSXText { span, value, raw } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Key {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_key`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_key(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Key::Private { 0: _field_0 } => {
                <PrivateName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Key::Public { 0: _field_0 } => {
                <PropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for KeyValuePatProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_key_value_pat_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_key_value_pat_prop(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            KeyValuePatProp { key, value } => {
                <PropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    key, visitor, ast_path,
                );
                <Box<Pat> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    value, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for KeyValueProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_key_value_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_key_value_prop(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            KeyValueProp { key, value } => {
                <PropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    key, visitor, ast_path,
                );
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    value, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for LabeledStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_labeled_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_labeled_stmt(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            LabeledStmt { span, label, body } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    label, visitor, ast_path,
                );
                <Box<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Lit {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_lit`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_lit(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Lit::Str { 0: _field_0 } => {
                <Str as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Lit::Bool { 0: _field_0 } => {
                <Bool as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Lit::Null { 0: _field_0 } => {
                <Null as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Lit::Num { 0: _field_0 } => {
                <Number as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Lit::BigInt { 0: _field_0 } => {
                <BigInt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Lit::Regex { 0: _field_0 } => {
                <Regex as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Lit::JSXText { 0: _field_0 } => {
                <JSXText as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for MemberExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_member_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_member_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            MemberExpr { span, obj, prop } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    obj, visitor, ast_path,
                );
                <MemberProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    prop, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for MemberProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_member_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_member_prop(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            MemberProp::Ident { 0: _field_0 } => {
                <IdentName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            MemberProp::PrivateName { 0: _field_0 } => {
                <PrivateName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            MemberProp::Computed { 0: _field_0 } => {
                <ComputedPropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for MetaPropExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_meta_prop_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_meta_prop_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            MetaPropExpr { span, kind } => {
                <MetaPropKind as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    kind, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for MetaPropKind {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_meta_prop_kind`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_meta_prop_kind(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            MetaPropKind::NewTarget => {}
            MetaPropKind::ImportMeta => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for MethodKind {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_method_kind`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_method_kind(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            MethodKind::Method => {}
            MethodKind::Getter => {}
            MethodKind::Setter => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for MethodProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_method_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_method_prop(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            MethodProp { key, function } => {
                <PropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    key, visitor, ast_path,
                );
                <Box<Function> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    function, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Module {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_module`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_module(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Module {
                span,
                body,
                shebang,
            } => {
                <Vec<ModuleItem> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ModuleDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_module_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_module_decl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ModuleDecl::Import { 0: _field_0 } => {
                <ImportDecl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ModuleDecl::ExportDecl { 0: _field_0 } => {
                <ExportDecl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ModuleDecl::ExportNamed { 0: _field_0 } => {
                <NamedExport as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ModuleDecl::ExportDefaultDecl { 0: _field_0 } => {
                <ExportDefaultDecl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ModuleDecl::ExportDefaultExpr { 0: _field_0 } => {
                <ExportDefaultExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ModuleDecl::ExportAll { 0: _field_0 } => {
                <ExportAll as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ModuleDecl::TsImportEquals { 0: _field_0 } => {
                <Box<TsImportEqualsDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ModuleDecl::TsExportAssignment { 0: _field_0 } => {
                <TsExportAssignment as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ModuleDecl::TsNamespaceExport { 0: _field_0 } => {
                <TsNamespaceExportDecl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ModuleExportName {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_module_export_name`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_module_export_name(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ModuleExportName::Ident { 0: _field_0 } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ModuleExportName::Str { 0: _field_0 } => {
                <Str as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ModuleItem {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_module_item`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_module_item(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ModuleItem::ModuleDecl { 0: _field_0 } => {
                <ModuleDecl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ModuleItem::Stmt { 0: _field_0 } => {
                <Stmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for NamedExport {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_named_export`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_named_export(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            NamedExport {
                span,
                specifiers,
                src,
                type_only,
                with,
            } => {
                <Vec<ExportSpecifier> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    specifiers, visitor, ast_path,
                );
                <Option<Box<Str>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    src, visitor, ast_path,
                );
                <Option<Box<ObjectLit>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    with, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for NewExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_new_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_new_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            NewExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    callee, visitor, ast_path,
                );
                <Option<Vec<ExprOrSpread>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    args, visitor, ast_path,
                );
                < Option < Box < TsTypeParamInstantiation > > as VisitMutWithAstPath < V > > :: visit_mut_with_ast_path (type_args , visitor , ast_path) ;
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Null {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_null`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_null(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Null { span } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Number {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_number`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_number(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Number { span, value, raw } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ObjectLit {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_object_lit`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_object_lit(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ObjectLit { span, props } => {
                <Vec<PropOrSpread> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    props, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ObjectPat {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_object_pat`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_object_pat(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ObjectPat {
                span,
                props,
                optional,
                type_ann,
            } => {
                <Vec<ObjectPatProp> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    props, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ObjectPatProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_object_pat_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_object_pat_prop(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ObjectPatProp::KeyValue { 0: _field_0 } => {
                <KeyValuePatProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ObjectPatProp::Assign { 0: _field_0 } => {
                <AssignPatProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ObjectPatProp::Rest { 0: _field_0 } => {
                <RestPat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for OptCall {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_call`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_call(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            OptCall {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    callee, visitor, ast_path,
                );
                <Vec<ExprOrSpread> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    args, visitor, ast_path,
                );
                < Option < Box < TsTypeParamInstantiation > > as VisitMutWithAstPath < V > > :: visit_mut_with_ast_path (type_args , visitor , ast_path) ;
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for OptChainBase {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_chain_base`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_chain_base(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            OptChainBase::Member { 0: _field_0 } => {
                <MemberExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            OptChainBase::Call { 0: _field_0 } => {
                <OptCall as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for OptChainExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_chain_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_chain_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            OptChainExpr {
                span,
                optional,
                base,
            } => {
                <Box<OptChainBase> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    base, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Param {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_param`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_param(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Param {
                span,
                decorators,
                pat,
            } => {
                <Vec<Decorator> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    decorators, visitor, ast_path,
                );
                <Pat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(pat, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ParamOrTsParamProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_param_or_ts_param_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_param_or_ts_param_prop(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ParamOrTsParamProp::TsParamProp { 0: _field_0 } => {
                <TsParamProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            ParamOrTsParamProp::Param { 0: _field_0 } => {
                <Param as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ParenExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_paren_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_paren_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ParenExpr { span, expr } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    expr, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Pat {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_pat`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_pat(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Pat::Ident { 0: _field_0 } => {
                <BindingIdent as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Pat::Array { 0: _field_0 } => {
                <ArrayPat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Pat::Rest { 0: _field_0 } => {
                <RestPat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Pat::Object { 0: _field_0 } => {
                <ObjectPat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Pat::Assign { 0: _field_0 } => {
                <AssignPat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Pat::Invalid { 0: _field_0 } => {
                <Invalid as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Pat::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for PrivateName {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_private_name`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_private_name(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            PrivateName { span, name } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for PrivateProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_private_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_private_prop(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            PrivateProp {
                span,
                ctxt,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_optional,
                is_override,
                readonly,
                definite,
            } => {
                <PrivateName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    key, visitor, ast_path,
                );
                <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    value, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                <Vec<Decorator> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    decorators, visitor, ast_path,
                );
                <Option<Accessibility> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    accessibility,
                    visitor,
                    ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Program {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_program`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_program(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Program::Module { 0: _field_0 } => {
                <Module as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Program::Script { 0: _field_0 } => {
                <Script as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Prop {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_prop(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Prop::Shorthand { 0: _field_0 } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Prop::KeyValue { 0: _field_0 } => {
                <KeyValueProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Prop::Assign { 0: _field_0 } => {
                <AssignProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Prop::Getter { 0: _field_0 } => {
                <GetterProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Prop::Setter { 0: _field_0 } => {
                <SetterProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Prop::Method { 0: _field_0 } => {
                <MethodProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for PropName {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_prop_name`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_prop_name(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            PropName::Ident { 0: _field_0 } => {
                <IdentName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            PropName::Str { 0: _field_0 } => {
                <Str as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            PropName::Num { 0: _field_0 } => {
                <Number as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            PropName::Computed { 0: _field_0 } => {
                <ComputedPropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            PropName::BigInt { 0: _field_0 } => {
                <BigInt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for PropOrSpread {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_prop_or_spread`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_prop_or_spread(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            PropOrSpread::Spread { 0: _field_0 } => {
                <SpreadElement as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            PropOrSpread::Prop { 0: _field_0 } => {
                <Box<Prop> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Regex {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_regex`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_regex(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Regex { span, exp, flags } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ReservedUnused {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_reserved_unused`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_reserved_unused(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ReservedUnused { span, body } => {
                <Option<Vec<ModuleItem>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for RestPat {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_rest_pat`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_rest_pat(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            RestPat {
                span,
                dot3_token,
                arg,
                type_ann,
            } => {
                <Box<Pat> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    arg, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ReturnStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_return_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_return_stmt(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ReturnStmt { span, arg } => {
                <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    arg, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Script {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_script`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_script(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Script {
                span,
                body,
                shebang,
            } => {
                <Vec<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for SeqExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_seq_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_seq_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            SeqExpr { span, exprs } => {
                <Vec<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    exprs, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for SetterProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_setter_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_setter_prop(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            SetterProp {
                span,
                key,
                this_param,
                param,
                body,
            } => {
                <PropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    key, visitor, ast_path,
                );
                <Option<Pat> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    this_param, visitor, ast_path,
                );
                <Box<Pat> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    param, visitor, ast_path,
                );
                <Option<BlockStmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for SimpleAssignTarget {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_simple_assign_target`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_simple_assign_target(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            SimpleAssignTarget::Ident { 0: _field_0 } => {
                <BindingIdent as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            SimpleAssignTarget::Member { 0: _field_0 } => {
                <MemberExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            SimpleAssignTarget::SuperProp { 0: _field_0 } => {
                <SuperPropExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            SimpleAssignTarget::Paren { 0: _field_0 } => {
                <ParenExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            SimpleAssignTarget::OptChain { 0: _field_0 } => {
                <OptChainExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            SimpleAssignTarget::TsAs { 0: _field_0 } => {
                <TsAsExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            SimpleAssignTarget::TsSatisfies { 0: _field_0 } => {
                <TsSatisfiesExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            SimpleAssignTarget::TsNonNull { 0: _field_0 } => {
                <TsNonNullExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            SimpleAssignTarget::TsTypeAssertion { 0: _field_0 } => {
                <TsTypeAssertion as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            SimpleAssignTarget::TsInstantiation { 0: _field_0 } => {
                <TsInstantiation as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            SimpleAssignTarget::Invalid { 0: _field_0 } => {
                <Invalid as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for SpreadElement {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_spread_element`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_spread_element(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            SpreadElement { dot3_token, expr } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    expr, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for StaticBlock {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_static_block`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_static_block(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            StaticBlock { span, body } => {
                <BlockStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Stmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_stmt(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Stmt::Block { 0: _field_0 } => {
                <BlockStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::Empty { 0: _field_0 } => {
                <EmptyStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::Debugger { 0: _field_0 } => {
                <DebuggerStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::With { 0: _field_0 } => {
                <WithStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::Return { 0: _field_0 } => {
                <ReturnStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::Labeled { 0: _field_0 } => {
                <LabeledStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::Break { 0: _field_0 } => {
                <BreakStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::Continue { 0: _field_0 } => {
                <ContinueStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::If { 0: _field_0 } => {
                <IfStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::Switch { 0: _field_0 } => {
                <SwitchStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::Throw { 0: _field_0 } => {
                <ThrowStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::Try { 0: _field_0 } => {
                <Box<TryStmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::While { 0: _field_0 } => {
                <WhileStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::DoWhile { 0: _field_0 } => {
                <DoWhileStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::For { 0: _field_0 } => {
                <ForStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::ForIn { 0: _field_0 } => {
                <ForInStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::ForOf { 0: _field_0 } => {
                <ForOfStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::Decl { 0: _field_0 } => {
                <Decl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            Stmt::Expr { 0: _field_0 } => {
                <ExprStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Str {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_str`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_str(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Str { span, value, raw } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Super {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_super`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_super(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Super { span } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for SuperProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_super_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_super_prop(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            SuperProp::Ident { 0: _field_0 } => {
                <IdentName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            SuperProp::Computed { 0: _field_0 } => {
                <ComputedPropName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for SuperPropExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_super_prop_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_super_prop_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            SuperPropExpr { span, obj, prop } => {
                <Super as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(obj, visitor, ast_path);
                <SuperProp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    prop, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for SwitchCase {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_switch_case`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_switch_case(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            SwitchCase { span, test, cons } => {
                <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    test, visitor, ast_path,
                );
                <Vec<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    cons, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for SwitchStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_switch_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_switch_stmt(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            SwitchStmt {
                span,
                discriminant,
                cases,
            } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    discriminant,
                    visitor,
                    ast_path,
                );
                <Vec<SwitchCase> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    cases, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TaggedTpl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_tagged_tpl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_tagged_tpl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TaggedTpl {
                span,
                ctxt,
                tag,
                type_params,
                tpl,
            } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    tag, visitor, ast_path,
                );
                < Option < Box < TsTypeParamInstantiation > > as VisitMutWithAstPath < V > > :: visit_mut_with_ast_path (type_params , visitor , ast_path) ;
                <Box<Tpl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    tpl, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ThisExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_this_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_this_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ThisExpr { span } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ThrowStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_throw_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_throw_stmt(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            ThrowStmt { span, arg } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    arg, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Tpl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_tpl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_tpl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Tpl {
                span,
                exprs,
                quasis,
            } => {
                <Vec<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    exprs, visitor, ast_path,
                );
                <Vec<TplElement> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    quasis, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TplElement {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_tpl_element`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_tpl_element(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TplElement {
                span,
                tail,
                cooked,
                raw,
            } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TruePlusMinus {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_true_plus_minus`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_true_plus_minus(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TruePlusMinus::True => {}
            TruePlusMinus::Plus => {}
            TruePlusMinus::Minus => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TryStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_try_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_try_stmt(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TryStmt {
                span,
                block,
                handler,
                finalizer,
            } => {
                <BlockStmt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    block, visitor, ast_path,
                );
                <Option<CatchClause> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    handler, visitor, ast_path,
                );
                <Option<BlockStmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    finalizer, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsArrayType {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_array_type`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_array_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsArrayType { span, elem_type } => {
                <Box<TsType> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    elem_type, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsAsExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_as_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_as_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsAsExpr {
                span,
                expr,
                type_ann,
            } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    expr, visitor, ast_path,
                );
                <Box<TsType> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsCallSignatureDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_call_signature_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_call_signature_decl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsCallSignatureDecl {
                span,
                params,
                type_ann,
                type_params,
            } => {
                <Vec<TsFnParam> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    params, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                <Option<Box<TsTypeParamDecl>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsConditionalType {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_conditional_type`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_conditional_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsConditionalType {
                span,
                check_type,
                extends_type,
                true_type,
                false_type,
            } => {
                <Box<TsType> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    check_type, visitor, ast_path,
                );
                <Box<TsType> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    extends_type,
                    visitor,
                    ast_path,
                );
                <Box<TsType> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    true_type, visitor, ast_path,
                );
                <Box<TsType> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    false_type, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsConstAssertion {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_const_assertion`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_const_assertion(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsConstAssertion { span, expr } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    expr, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsConstructSignatureDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_construct_signature_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_construct_signature_decl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsConstructSignatureDecl {
                span,
                params,
                type_ann,
                type_params,
            } => {
                <Vec<TsFnParam> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    params, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                <Option<Box<TsTypeParamDecl>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsConstructorType {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_constructor_type`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_constructor_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsConstructorType {
                span,
                params,
                type_params,
                type_ann,
                is_abstract,
            } => {
                <Vec<TsFnParam> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    params, visitor, ast_path,
                );
                <Option<Box<TsTypeParamDecl>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
                <Box<TsTypeAnn> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsEntityName {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_entity_name`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_entity_name(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsEntityName::TsQualifiedName { 0: _field_0 } => {
                <Box<TsQualifiedName> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsEntityName::Ident { 0: _field_0 } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsEnumDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_enum_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_enum_decl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsEnumDecl {
                span,
                declare,
                is_const,
                id,
                members,
            } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(id, visitor, ast_path);
                <Vec<TsEnumMember> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    members, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsEnumMember {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_enum_member`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_enum_member(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsEnumMember { span, id, init } => {
                <TsEnumMemberId as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    id, visitor, ast_path,
                );
                <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    init, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsEnumMemberId {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_enum_member_id`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_enum_member_id(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsEnumMemberId::Ident { 0: _field_0 } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsEnumMemberId::Str { 0: _field_0 } => {
                <Str as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsExportAssignment {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_export_assignment`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_export_assignment(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsExportAssignment { span, expr } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    expr, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsExprWithTypeArgs {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_expr_with_type_args`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_expr_with_type_args(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsExprWithTypeArgs {
                span,
                expr,
                type_args,
            } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    expr, visitor, ast_path,
                );
                < Option < Box < TsTypeParamInstantiation > > as VisitMutWithAstPath < V > > :: visit_mut_with_ast_path (type_args , visitor , ast_path) ;
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsExternalModuleRef {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_external_module_ref`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_external_module_ref(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsExternalModuleRef { span, expr } => {
                <Str as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(expr, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsFnOrConstructorType {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_fn_or_constructor_type`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_fn_or_constructor_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsFnOrConstructorType::TsFnType { 0: _field_0 } => {
                <TsFnType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsFnOrConstructorType::TsConstructorType { 0: _field_0 } => {
                <TsConstructorType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsFnParam {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_fn_param`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_fn_param(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsFnParam::Ident { 0: _field_0 } => {
                <BindingIdent as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsFnParam::Array { 0: _field_0 } => {
                <ArrayPat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsFnParam::Rest { 0: _field_0 } => {
                <RestPat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsFnParam::Object { 0: _field_0 } => {
                <ObjectPat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsFnType {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_fn_type`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_fn_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsFnType {
                span,
                params,
                type_params,
                type_ann,
            } => {
                <Vec<TsFnParam> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    params, visitor, ast_path,
                );
                <Option<Box<TsTypeParamDecl>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
                <Box<TsTypeAnn> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsGetterSignature {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_getter_signature`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_getter_signature(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsGetterSignature {
                span,
                key,
                computed,
                type_ann,
            } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    key, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsImportEqualsDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_import_equals_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_import_equals_decl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsImportEqualsDecl {
                span,
                is_export,
                is_type_only,
                id,
                module_ref,
            } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(id, visitor, ast_path);
                <TsModuleRef as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    module_ref, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsImportType {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_import_type`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_import_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsImportType {
                span,
                arg,
                qualifier,
                type_args,
            } => {
                <Str as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(arg, visitor, ast_path);
                <Option<TsEntityName> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    qualifier, visitor, ast_path,
                );
                < Option < Box < TsTypeParamInstantiation > > as VisitMutWithAstPath < V > > :: visit_mut_with_ast_path (type_args , visitor , ast_path) ;
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsIndexSignature {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_index_signature`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_index_signature(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsIndexSignature {
                params,
                type_ann,
                readonly,
                is_static,
                span,
            } => {
                <Vec<TsFnParam> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    params, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsIndexedAccessType {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_indexed_access_type`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_indexed_access_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsIndexedAccessType {
                span,
                readonly,
                obj_type,
                index_type,
            } => {
                <Box<TsType> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    obj_type, visitor, ast_path,
                );
                <Box<TsType> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    index_type, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsInferType {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_infer_type`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_infer_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsInferType { span, type_param } => {
                <TsTypeParam as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_param, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsInstantiation {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_instantiation`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_instantiation(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsInstantiation {
                span,
                expr,
                type_args,
            } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    expr, visitor, ast_path,
                );
                <Box<TsTypeParamInstantiation> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_args, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsInterfaceBody {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_interface_body`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_interface_body(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsInterfaceBody { span, body } => {
                <Vec<TsTypeElement> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsInterfaceDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_interface_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_interface_decl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsInterfaceDecl {
                span,
                id,
                declare,
                type_params,
                extends,
                body,
            } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(id, visitor, ast_path);
                <Option<Box<TsTypeParamDecl>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
                <Vec<TsExprWithTypeArgs> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    extends, visitor, ast_path,
                );
                <TsInterfaceBody as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsIntersectionType {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_intersection_type`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_intersection_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsIntersectionType { span, types } => {
                <Vec<Box<TsType>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    types, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsKeywordType {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_keyword_type`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_keyword_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsKeywordType { span, kind } => {
                <TsKeywordTypeKind as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    kind, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsKeywordTypeKind {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_keyword_type_kind`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_keyword_type_kind(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsKeywordTypeKind::TsAnyKeyword => {}
            TsKeywordTypeKind::TsUnknownKeyword => {}
            TsKeywordTypeKind::TsNumberKeyword => {}
            TsKeywordTypeKind::TsObjectKeyword => {}
            TsKeywordTypeKind::TsBooleanKeyword => {}
            TsKeywordTypeKind::TsBigIntKeyword => {}
            TsKeywordTypeKind::TsStringKeyword => {}
            TsKeywordTypeKind::TsSymbolKeyword => {}
            TsKeywordTypeKind::TsVoidKeyword => {}
            TsKeywordTypeKind::TsUndefinedKeyword => {}
            TsKeywordTypeKind::TsNullKeyword => {}
            TsKeywordTypeKind::TsNeverKeyword => {}
            TsKeywordTypeKind::TsIntrinsicKeyword => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsLit {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_lit`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_lit(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsLit::Number { 0: _field_0 } => {
                <Number as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsLit::Str { 0: _field_0 } => {
                <Str as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsLit::Bool { 0: _field_0 } => {
                <Bool as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsLit::BigInt { 0: _field_0 } => {
                <BigInt as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsLit::Tpl { 0: _field_0 } => {
                <TsTplLitType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsLitType {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_lit_type`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_lit_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsLitType { span, lit } => {
                <TsLit as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(lit, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsMappedType {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_mapped_type`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_mapped_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsMappedType {
                span,
                readonly,
                type_param,
                name_type,
                optional,
                type_ann,
            } => {
                <Option<TruePlusMinus> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    readonly, visitor, ast_path,
                );
                <TsTypeParam as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_param, visitor, ast_path,
                );
                <Option<Box<TsType>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    name_type, visitor, ast_path,
                );
                <Option<TruePlusMinus> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    optional, visitor, ast_path,
                );
                <Option<Box<TsType>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsMethodSignature {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_method_signature`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_method_signature(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsMethodSignature {
                span,
                key,
                computed,
                optional,
                params,
                type_ann,
                type_params,
            } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    key, visitor, ast_path,
                );
                <Vec<TsFnParam> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    params, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                <Option<Box<TsTypeParamDecl>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsModuleBlock {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_module_block`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_module_block(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsModuleBlock { span, body } => {
                <Vec<ModuleItem> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsModuleDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_module_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_module_decl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsModuleDecl {
                span,
                declare,
                global,
                id,
                body,
            } => {
                <TsModuleName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    id, visitor, ast_path,
                );
                <Option<TsNamespaceBody> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsModuleName {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_module_name`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_module_name(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsModuleName::Ident { 0: _field_0 } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsModuleName::Str { 0: _field_0 } => {
                <Str as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsModuleRef {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_module_ref`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_module_ref(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsModuleRef::TsEntityName { 0: _field_0 } => {
                <TsEntityName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsModuleRef::TsExternalModuleRef { 0: _field_0 } => {
                <TsExternalModuleRef as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsNamespaceBody {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_namespace_body`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_namespace_body(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsNamespaceBody::TsModuleBlock { 0: _field_0 } => {
                <TsModuleBlock as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsNamespaceBody::TsNamespaceDecl { 0: _field_0 } => {
                <TsNamespaceDecl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsNamespaceDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_namespace_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_namespace_decl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsNamespaceDecl {
                span,
                declare,
                global,
                id,
                body,
            } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(id, visitor, ast_path);
                <Box<TsNamespaceBody> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsNamespaceExportDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_namespace_export_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_namespace_export_decl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsNamespaceExportDecl { span, id } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(id, visitor, ast_path);
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsNonNullExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_non_null_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_non_null_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsNonNullExpr { span, expr } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    expr, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsOptionalType {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_optional_type`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_optional_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsOptionalType { span, type_ann } => {
                <Box<TsType> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsParamProp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_param_prop`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_param_prop(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsParamProp {
                span,
                decorators,
                accessibility,
                is_override,
                readonly,
                param,
            } => {
                <Vec<Decorator> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    decorators, visitor, ast_path,
                );
                <Option<Accessibility> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    accessibility,
                    visitor,
                    ast_path,
                );
                <TsParamPropParam as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    param, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsParamPropParam {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_param_prop_param`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_param_prop_param(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsParamPropParam::Ident { 0: _field_0 } => {
                <BindingIdent as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsParamPropParam::Assign { 0: _field_0 } => {
                <AssignPat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsParenthesizedType {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_parenthesized_type`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_parenthesized_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsParenthesizedType { span, type_ann } => {
                <Box<TsType> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsPropertySignature {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_property_signature`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_property_signature(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsPropertySignature {
                span,
                readonly,
                key,
                computed,
                optional,
                type_ann,
            } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    key, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsQualifiedName {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_qualified_name`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_qualified_name(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsQualifiedName { span, left, right } => {
                <TsEntityName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    left, visitor, ast_path,
                );
                <IdentName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    right, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsRestType {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_rest_type`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_rest_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsRestType { span, type_ann } => {
                <Box<TsType> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsSatisfiesExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_satisfies_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_satisfies_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsSatisfiesExpr {
                span,
                expr,
                type_ann,
            } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    expr, visitor, ast_path,
                );
                <Box<TsType> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsSetterSignature {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_setter_signature`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_setter_signature(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsSetterSignature {
                span,
                key,
                computed,
                param,
            } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    key, visitor, ast_path,
                );
                <TsFnParam as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    param, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsThisType {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_this_type`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_this_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsThisType { span } => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsThisTypeOrIdent {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_this_type_or_ident`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_this_type_or_ident(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsThisTypeOrIdent::TsThisType { 0: _field_0 } => {
                <TsThisType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsThisTypeOrIdent::Ident { 0: _field_0 } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsTplLitType {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_tpl_lit_type`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_tpl_lit_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsTplLitType {
                span,
                types,
                quasis,
            } => {
                <Vec<Box<TsType>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    types, visitor, ast_path,
                );
                <Vec<TplElement> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    quasis, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsTupleElement {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_tuple_element`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_tuple_element(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsTupleElement { span, label, ty } => {
                <Option<Pat> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    label, visitor, ast_path,
                );
                <Box<TsType> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    ty, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsTupleType {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_tuple_type`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_tuple_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsTupleType { span, elem_types } => {
                <Vec<TsTupleElement> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    elem_types, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsType {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_type`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsType::TsKeywordType { 0: _field_0 } => {
                <TsKeywordType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsThisType { 0: _field_0 } => {
                <TsThisType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsFnOrConstructorType { 0: _field_0 } => {
                <TsFnOrConstructorType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsTypeRef { 0: _field_0 } => {
                <TsTypeRef as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsTypeQuery { 0: _field_0 } => {
                <TsTypeQuery as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsTypeLit { 0: _field_0 } => {
                <TsTypeLit as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsArrayType { 0: _field_0 } => {
                <TsArrayType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsTupleType { 0: _field_0 } => {
                <TsTupleType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsOptionalType { 0: _field_0 } => {
                <TsOptionalType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsRestType { 0: _field_0 } => {
                <TsRestType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsUnionOrIntersectionType { 0: _field_0 } => {
                <TsUnionOrIntersectionType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsConditionalType { 0: _field_0 } => {
                <TsConditionalType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsInferType { 0: _field_0 } => {
                <TsInferType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsParenthesizedType { 0: _field_0 } => {
                <TsParenthesizedType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsTypeOperator { 0: _field_0 } => {
                <TsTypeOperator as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsIndexedAccessType { 0: _field_0 } => {
                <TsIndexedAccessType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsMappedType { 0: _field_0 } => {
                <TsMappedType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsLitType { 0: _field_0 } => {
                <TsLitType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsTypePredicate { 0: _field_0 } => {
                <TsTypePredicate as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsType::TsImportType { 0: _field_0 } => {
                <TsImportType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsTypeAliasDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_type_alias_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_type_alias_decl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsTypeAliasDecl {
                span,
                declare,
                id,
                type_params,
                type_ann,
            } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(id, visitor, ast_path);
                <Option<Box<TsTypeParamDecl>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_params,
                    visitor,
                    ast_path,
                );
                <Box<TsType> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsTypeAnn {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_type_ann`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_type_ann(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsTypeAnn { span, type_ann } => {
                <Box<TsType> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsTypeAssertion {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_type_assertion`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_type_assertion(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsTypeAssertion {
                span,
                expr,
                type_ann,
            } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    expr, visitor, ast_path,
                );
                <Box<TsType> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsTypeElement {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_type_element`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_type_element(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsTypeElement::TsCallSignatureDecl { 0: _field_0 } => {
                <TsCallSignatureDecl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsTypeElement::TsConstructSignatureDecl { 0: _field_0 } => {
                <TsConstructSignatureDecl as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsTypeElement::TsPropertySignature { 0: _field_0 } => {
                <TsPropertySignature as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsTypeElement::TsGetterSignature { 0: _field_0 } => {
                <TsGetterSignature as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsTypeElement::TsSetterSignature { 0: _field_0 } => {
                <TsSetterSignature as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsTypeElement::TsMethodSignature { 0: _field_0 } => {
                <TsMethodSignature as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsTypeElement::TsIndexSignature { 0: _field_0 } => {
                <TsIndexSignature as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsTypeLit {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_type_lit`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_type_lit(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsTypeLit { span, members } => {
                <Vec<TsTypeElement> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    members, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsTypeOperator {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_type_operator`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_type_operator(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsTypeOperator { span, op, type_ann } => {
                <TsTypeOperatorOp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    op, visitor, ast_path,
                );
                <Box<TsType> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsTypeOperatorOp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_type_operator_op`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_type_operator_op(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsTypeOperatorOp::KeyOf => {}
            TsTypeOperatorOp::Unique => {}
            TsTypeOperatorOp::ReadOnly => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsTypeParam {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_type_param`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_type_param(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsTypeParam {
                span,
                name,
                is_in,
                is_out,
                is_const,
                constraint,
                default,
            } => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(name, visitor, ast_path);
                <Option<Box<TsType>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    constraint, visitor, ast_path,
                );
                <Option<Box<TsType>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    default, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsTypeParamDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_type_param_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_type_param_decl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsTypeParamDecl { span, params } => {
                <Vec<TsTypeParam> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    params, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsTypeParamInstantiation {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_type_param_instantiation`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_type_param_instantiation(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsTypeParamInstantiation { span, params } => {
                <Vec<Box<TsType>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    params, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsTypePredicate {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_type_predicate`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_type_predicate(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsTypePredicate {
                span,
                asserts,
                param_name,
                type_ann,
            } => {
                <TsThisTypeOrIdent as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    param_name, visitor, ast_path,
                );
                <Option<Box<TsTypeAnn>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_ann, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsTypeQuery {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_type_query`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_type_query(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsTypeQuery {
                span,
                expr_name,
                type_args,
            } => {
                <TsTypeQueryExpr as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    expr_name, visitor, ast_path,
                );
                < Option < Box < TsTypeParamInstantiation > > as VisitMutWithAstPath < V > > :: visit_mut_with_ast_path (type_args , visitor , ast_path) ;
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsTypeQueryExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_type_query_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_type_query_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsTypeQueryExpr::TsEntityName { 0: _field_0 } => {
                <TsEntityName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsTypeQueryExpr::Import { 0: _field_0 } => {
                <TsImportType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsTypeRef {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_type_ref`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_type_ref(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsTypeRef {
                span,
                type_name,
                type_params,
            } => {
                <TsEntityName as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    type_name, visitor, ast_path,
                );
                < Option < Box < TsTypeParamInstantiation > > as VisitMutWithAstPath < V > > :: visit_mut_with_ast_path (type_params , visitor , ast_path) ;
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsUnionOrIntersectionType {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_union_or_intersection_type`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_union_or_intersection_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsUnionOrIntersectionType::TsUnionType { 0: _field_0 } => {
                <TsUnionType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            TsUnionOrIntersectionType::TsIntersectionType { 0: _field_0 } => {
                <TsIntersectionType as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for TsUnionType {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_union_type`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_union_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            TsUnionType { span, types } => {
                <Vec<Box<TsType>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    types, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for UnaryExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_unary_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_unary_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            UnaryExpr { span, op, arg } => {
                <UnaryOp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(op, visitor, ast_path);
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    arg, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for UnaryOp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_unary_op`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_unary_op(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            UnaryOp::Minus => {}
            UnaryOp::Plus => {}
            UnaryOp::Bang => {}
            UnaryOp::Tilde => {}
            UnaryOp::TypeOf => {}
            UnaryOp::Void => {}
            UnaryOp::Delete => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for UpdateExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_update_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_update_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            UpdateExpr {
                span,
                op,
                prefix,
                arg,
            } => {
                <UpdateOp as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    op, visitor, ast_path,
                );
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    arg, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for UpdateOp {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_update_op`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_update_op(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            UpdateOp::PlusPlus => {}
            UpdateOp::MinusMinus => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for UsingDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_using_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_using_decl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            UsingDecl {
                span,
                is_await,
                decls,
            } => {
                <Vec<VarDeclarator> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    decls, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for VarDecl {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_var_decl`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_var_decl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            VarDecl {
                span,
                ctxt,
                kind,
                declare,
                decls,
            } => {
                <VarDeclKind as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    kind, visitor, ast_path,
                );
                <Vec<VarDeclarator> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    decls, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for VarDeclKind {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_var_decl_kind`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_var_decl_kind(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            VarDeclKind::Var => {}
            VarDeclKind::Let => {}
            VarDeclKind::Const => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for VarDeclOrExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_var_decl_or_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_var_decl_or_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            VarDeclOrExpr::VarDecl { 0: _field_0 } => {
                <Box<VarDecl> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
            VarDeclOrExpr::Expr { 0: _field_0 } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    _field_0, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for VarDeclarator {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_var_declarator`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_var_declarator(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            VarDeclarator {
                span,
                name,
                init,
                definite,
            } => {
                <Pat as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(name, visitor, ast_path);
                <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    init, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for WhileStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_while_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_while_stmt(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            WhileStmt { span, test, body } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    test, visitor, ast_path,
                );
                <Box<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for WithStmt {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_with_stmt`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_with_stmt(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            WithStmt { span, obj, body } => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    obj, visitor, ast_path,
                );
                <Box<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    body, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for YieldExpr {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_yield_expr`] with `self`."]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_yield_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            YieldExpr {
                span,
                arg,
                delegate,
            } => {
                <Option<Box<Expr>> as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(
                    arg, visitor, ast_path,
                );
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for swc_atoms::Atom {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_atom`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_atom(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for BigIntValue {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_big_int_value`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_big_int_value(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<ClassMember> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_class_members`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_members(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <ClassMember as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for ClassMethod {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_class_method`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_class_method(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<Decorator> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_decorators`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_decorators(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <Decorator as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<ExportSpecifier> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_export_specifiers`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_export_specifiers(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <ExportSpecifier as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<ExprOrSpread> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_expr_or_spreads`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_expr_or_spreads(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <ExprOrSpread as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<Box<Expr>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_exprs`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_exprs(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<ImportSpecifier> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import_specifiers`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_specifiers(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <ImportSpecifier as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<ImportWithItem> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_import_with_items`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_import_with_items(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <ImportWithItem as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<JSXAttrOrSpread> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_attr_or_spreads`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_attr_or_spreads(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <JSXAttrOrSpread as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<JSXElementChild> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_jsx_element_childs`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_jsx_element_childs(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <JSXElementChild as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<ModuleItem> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_module_items`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_module_items(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <ModuleItem as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<ObjectPatProp> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_object_pat_props`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_object_pat_props(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <ObjectPatProp as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<Accessibility> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_accessibility`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_accessibility(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => {
                <Accessibility as VisitMutWithAstPath<V>>::visit_mut_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<swc_atoms::Atom> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_atom`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_atom(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <swc_atoms::Atom as VisitMutWithAstPath<V>>::visit_mut_with(
                inner, visitor, ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<BlockStmt> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_block_stmt`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_block_stmt(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => {
                <BlockStmt as VisitMutWithAstPath<V>>::visit_mut_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<CatchClause> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_catch_clause`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_catch_clause(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => {
                <CatchClause as VisitMutWithAstPath<V>>::visit_mut_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<Box<Expr>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_expr`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => {
                <Box<Expr> as VisitMutWithAstPath<V>>::visit_mut_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<ExprOrSpread> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_expr_or_spread`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_expr_or_spread(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => {
                <ExprOrSpread as VisitMutWithAstPath<V>>::visit_mut_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<Vec<ExprOrSpread>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_expr_or_spreads`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_expr_or_spreads(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <Vec<ExprOrSpread> as VisitMutWithAstPath<V>>::visit_mut_with(
                inner, visitor, ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<Ident> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_ident`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_ident(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => {
                <Ident as VisitMutWithAstPath<V>>::visit_mut_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<JSXAttrValue> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_jsx_attr_value`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_jsx_attr_value(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => {
                <JSXAttrValue as VisitMutWithAstPath<V>>::visit_mut_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<JSXClosingElement> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_jsx_closing_element`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_jsx_closing_element(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <JSXClosingElement as VisitMutWithAstPath<V>>::visit_mut_with(
                inner, visitor, ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<ModuleExportName> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_module_export_name`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_module_export_name(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <ModuleExportName as VisitMutWithAstPath<V>>::visit_mut_with(
                inner, visitor, ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<Vec<ModuleItem>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_module_items`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_module_items(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <Vec<ModuleItem> as VisitMutWithAstPath<V>>::visit_mut_with(
                inner, visitor, ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<Box<ObjectLit>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_object_lit`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_object_lit(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => {
                <Box<ObjectLit> as VisitMutWithAstPath<V>>::visit_mut_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<Pat> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_pat`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_pat(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => {
                <Pat as VisitMutWithAstPath<V>>::visit_mut_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<swc_common::Span> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_span`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_span(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <swc_common::Span as VisitMutWithAstPath<V>>::visit_mut_with(
                inner, visitor, ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<Box<Stmt>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_stmt`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_stmt(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => {
                <Box<Stmt> as VisitMutWithAstPath<V>>::visit_mut_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<Box<Str>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_str`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_str(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => {
                <Box<Str> as VisitMutWithAstPath<V>>::visit_mut_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<TruePlusMinus> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_true_plus_minus`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_true_plus_minus(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => {
                <TruePlusMinus as VisitMutWithAstPath<V>>::visit_mut_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<TsEntityName> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_ts_entity_name`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_ts_entity_name(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => {
                <TsEntityName as VisitMutWithAstPath<V>>::visit_mut_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<TsNamespaceBody> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_ts_namespace_body`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_ts_namespace_body(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <TsNamespaceBody as VisitMutWithAstPath<V>>::visit_mut_with(
                inner, visitor, ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<Box<TsType>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_ts_type`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_ts_type(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => {
                <Box<TsType> as VisitMutWithAstPath<V>>::visit_mut_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<Box<TsTypeAnn>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_ts_type_ann`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_ts_type_ann(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => {
                <Box<TsTypeAnn> as VisitMutWithAstPath<V>>::visit_mut_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<Box<TsTypeParamDecl>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_ts_type_param_decl`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_ts_type_param_decl(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => <Box<TsTypeParamDecl> as VisitMutWithAstPath<V>>::visit_mut_with(
                inner, visitor, ast_path,
            ),
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<Box<TsTypeParamInstantiation>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_ts_type_param_instantiation`] with `self`. \
             (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_ts_type_param_instantiation(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => {
                <Box<TsTypeParamInstantiation> as VisitMutWithAstPath<V>>::visit_mut_with(
                    inner, visitor, ast_path,
                )
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Option<VarDeclOrExpr> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_var_decl_or_expr`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_var_decl_or_expr(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        match self {
            Some(inner) => {
                <VarDeclOrExpr as VisitMutWithAstPath<V>>::visit_mut_with(inner, visitor, ast_path)
            }
            None => {}
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<Option<ExprOrSpread>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_vec_expr_or_spreads`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_vec_expr_or_spreads(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <Option<ExprOrSpread> as VisitMutWithAstPath<V>>::visit_mut_with(
                item, visitor, ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<Option<Pat>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_opt_vec_pats`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_opt_vec_pats(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <Option<Pat> as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<ParamOrTsParamProp> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_param_or_ts_param_props`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_param_or_ts_param_props(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <ParamOrTsParamProp as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<Param> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_params`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_params(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <Param as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<Pat> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_pats`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_pats(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <Pat as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for PrivateMethod {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_private_method`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_private_method(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<PropOrSpread> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_prop_or_spreads`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_prop_or_spreads(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <PropOrSpread as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for swc_common::Span {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_span`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_span(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<Stmt> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_stmts`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_stmts(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <Stmt as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<SwitchCase> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_switch_cases`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_switch_cases(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <SwitchCase as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for swc_common::SyntaxContext {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_syntax_context`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_syntax_context(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        {}
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<TplElement> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_tpl_elements`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_tpl_elements(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <TplElement as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<TsEnumMember> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_enum_members`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_enum_members(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <TsEnumMember as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<TsExprWithTypeArgs> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_expr_with_type_argss`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_expr_with_type_argss(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <TsExprWithTypeArgs as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<TsFnParam> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_fn_params`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_fn_params(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <TsFnParam as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<TsTupleElement> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_tuple_elements`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_tuple_elements(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <TsTupleElement as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<TsTypeElement> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_type_elements`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_type_elements(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <TsTypeElement as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<TsTypeParam> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_type_params`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_type_params(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <TsTypeParam as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<Box<TsType>> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_ts_types`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_ts_types(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <Box<TsType> as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + VisitMutAstPath> VisitMutWithAstPath<V> for Vec<VarDeclarator> {
    #[doc = "Calls [VisitMutAstPath`::visit_mut_var_declarators`] with `self`. (Extra impl)"]
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        <V as VisitMutAstPath>::visit_mut_var_declarators(visitor, self, ast_path)
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        self.iter_mut().for_each(|item| {
            <VarDeclarator as VisitMutWithAstPath<V>>::visit_mut_with(item, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V, T> VisitMutWithAstPath<V> for std::boxed::Box<T>
where
    V: ?Sized + VisitMutAstPath,
    T: VisitMutWithAstPath<V>,
{
    fn visit_mut_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        let v =
            <T as VisitMutWithAstPath<V>>::visit_mut_with_ast_path(&mut **self, visitor, ast_path);
        v
    }

    fn visit_mut_children_with_ast_path(&mut self, visitor: &mut V, ast_path: &mut AstKindPath) {
        let v = <T as VisitMutWithAstPath<V>>::visit_mut_children_with_ast_path(
            &mut **self,
            visitor,
            ast_path,
        );
        v
    }
}
#[doc = r" A visitor trait for traversing the AST."]
pub trait Fold {
    #[doc = "Visit a node of type `Accessibility`.\n\nBy default, this method calls \
             [`Accessibility::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_accessibility(&mut self, node: Accessibility) -> Accessibility {
        <Accessibility as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ArrayLit`.\n\nBy default, this method calls \
             [`ArrayLit::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_array_lit(&mut self, node: ArrayLit) -> ArrayLit {
        <ArrayLit as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ArrayPat`.\n\nBy default, this method calls \
             [`ArrayPat::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_array_pat(&mut self, node: ArrayPat) -> ArrayPat {
        <ArrayPat as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ArrowExpr`.\n\nBy default, this method calls \
             [`ArrowExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_arrow_expr(&mut self, node: ArrowExpr) -> ArrowExpr {
        <ArrowExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignExpr`.\n\nBy default, this method calls \
             [`AssignExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_assign_expr(&mut self, node: AssignExpr) -> AssignExpr {
        <AssignExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignOp`.\n\nBy default, this method calls \
             [`AssignOp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_assign_op(&mut self, node: AssignOp) -> AssignOp {
        <AssignOp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignPat`.\n\nBy default, this method calls \
             [`AssignPat::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_assign_pat(&mut self, node: AssignPat) -> AssignPat {
        <AssignPat as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignPatProp`.\n\nBy default, this method calls \
             [`AssignPatProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_assign_pat_prop(&mut self, node: AssignPatProp) -> AssignPatProp {
        <AssignPatProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignProp`.\n\nBy default, this method calls \
             [`AssignProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_assign_prop(&mut self, node: AssignProp) -> AssignProp {
        <AssignProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignTarget`.\n\nBy default, this method calls \
             [`AssignTarget::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_assign_target(&mut self, node: AssignTarget) -> AssignTarget {
        <AssignTarget as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `AssignTargetPat`.\n\nBy default, this method calls \
             [`AssignTargetPat::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_assign_target_pat(&mut self, node: AssignTargetPat) -> AssignTargetPat {
        <AssignTargetPat as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_atoms :: Atom`.\n\nBy default, this method calls \
             [`swc_atoms :: Atom::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_atom(&mut self, node: swc_atoms::Atom) -> swc_atoms::Atom {
        <swc_atoms::Atom as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `AutoAccessor`.\n\nBy default, this method calls \
             [`AutoAccessor::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_auto_accessor(&mut self, node: AutoAccessor) -> AutoAccessor {
        <AutoAccessor as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `AwaitExpr`.\n\nBy default, this method calls \
             [`AwaitExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_await_expr(&mut self, node: AwaitExpr) -> AwaitExpr {
        <AwaitExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `BigInt`.\n\nBy default, this method calls \
             [`BigInt::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_big_int(&mut self, node: BigInt) -> BigInt {
        <BigInt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `BigIntValue`.\n\nBy default, this method calls \
             [`BigIntValue::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_big_int_value(&mut self, node: BigIntValue) -> BigIntValue {
        <BigIntValue as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `BinExpr`.\n\nBy default, this method calls \
             [`BinExpr::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_bin_expr(&mut self, node: BinExpr) -> BinExpr {
        <BinExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `BinaryOp`.\n\nBy default, this method calls \
             [`BinaryOp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_binary_op(&mut self, node: BinaryOp) -> BinaryOp {
        <BinaryOp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `BindingIdent`.\n\nBy default, this method calls \
             [`BindingIdent::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_binding_ident(&mut self, node: BindingIdent) -> BindingIdent {
        <BindingIdent as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `BlockStmt`.\n\nBy default, this method calls \
             [`BlockStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_block_stmt(&mut self, node: BlockStmt) -> BlockStmt {
        <BlockStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `BlockStmtOrExpr`.\n\nBy default, this method calls \
             [`BlockStmtOrExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_block_stmt_or_expr(&mut self, node: BlockStmtOrExpr) -> BlockStmtOrExpr {
        <BlockStmtOrExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Bool`.\n\nBy default, this method calls \
             [`Bool::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_bool(&mut self, node: Bool) -> Bool {
        <Bool as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `BreakStmt`.\n\nBy default, this method calls \
             [`BreakStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_break_stmt(&mut self, node: BreakStmt) -> BreakStmt {
        <BreakStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `CallExpr`.\n\nBy default, this method calls \
             [`CallExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_call_expr(&mut self, node: CallExpr) -> CallExpr {
        <CallExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Callee`.\n\nBy default, this method calls \
             [`Callee::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_callee(&mut self, node: Callee) -> Callee {
        <Callee as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `CatchClause`.\n\nBy default, this method calls \
             [`CatchClause::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_catch_clause(&mut self, node: CatchClause) -> CatchClause {
        <CatchClause as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Class`.\n\nBy default, this method calls \
             [`Class::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_class(&mut self, node: Class) -> Class {
        <Class as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassDecl`.\n\nBy default, this method calls \
             [`ClassDecl::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_class_decl(&mut self, node: ClassDecl) -> ClassDecl {
        <ClassDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassExpr`.\n\nBy default, this method calls \
             [`ClassExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_class_expr(&mut self, node: ClassExpr) -> ClassExpr {
        <ClassExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassMember`.\n\nBy default, this method calls \
             [`ClassMember::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_class_member(&mut self, node: ClassMember) -> ClassMember {
        <ClassMember as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ClassMember >`.\n\nBy default, this method calls [`Vec < \
             ClassMember >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_class_members(&mut self, node: Vec<ClassMember>) -> Vec<ClassMember> {
        <Vec<ClassMember> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassMethod`.\n\nBy default, this method calls \
             [`ClassMethod::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_class_method(&mut self, node: ClassMethod) -> ClassMethod {
        <ClassMethod as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ClassProp`.\n\nBy default, this method calls \
             [`ClassProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_class_prop(&mut self, node: ClassProp) -> ClassProp {
        <ClassProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ComputedPropName`.\n\nBy default, this method calls \
             [`ComputedPropName::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_computed_prop_name(&mut self, node: ComputedPropName) -> ComputedPropName {
        <ComputedPropName as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `CondExpr`.\n\nBy default, this method calls \
             [`CondExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_cond_expr(&mut self, node: CondExpr) -> CondExpr {
        <CondExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Constructor`.\n\nBy default, this method calls \
             [`Constructor::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_constructor(&mut self, node: Constructor) -> Constructor {
        <Constructor as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ContinueStmt`.\n\nBy default, this method calls \
             [`ContinueStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_continue_stmt(&mut self, node: ContinueStmt) -> ContinueStmt {
        <ContinueStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `DebuggerStmt`.\n\nBy default, this method calls \
             [`DebuggerStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_debugger_stmt(&mut self, node: DebuggerStmt) -> DebuggerStmt {
        <DebuggerStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Decl`.\n\nBy default, this method calls \
             [`Decl::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_decl(&mut self, node: Decl) -> Decl {
        <Decl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Decorator`.\n\nBy default, this method calls \
             [`Decorator::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_decorator(&mut self, node: Decorator) -> Decorator {
        <Decorator as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Decorator >`.\n\nBy default, this method calls [`Vec < \
             Decorator >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_decorators(&mut self, node: Vec<Decorator>) -> Vec<Decorator> {
        <Vec<Decorator> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `DefaultDecl`.\n\nBy default, this method calls \
             [`DefaultDecl::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_default_decl(&mut self, node: DefaultDecl) -> DefaultDecl {
        <DefaultDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `DoWhileStmt`.\n\nBy default, this method calls \
             [`DoWhileStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_do_while_stmt(&mut self, node: DoWhileStmt) -> DoWhileStmt {
        <DoWhileStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `EmptyStmt`.\n\nBy default, this method calls \
             [`EmptyStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_empty_stmt(&mut self, node: EmptyStmt) -> EmptyStmt {
        <EmptyStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `EsVersion`.\n\nBy default, this method calls \
             [`EsVersion::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_es_version(&mut self, node: EsVersion) -> EsVersion {
        <EsVersion as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportAll`.\n\nBy default, this method calls \
             [`ExportAll::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_export_all(&mut self, node: ExportAll) -> ExportAll {
        <ExportAll as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDecl`.\n\nBy default, this method calls \
             [`ExportDecl::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_export_decl(&mut self, node: ExportDecl) -> ExportDecl {
        <ExportDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDefaultDecl`.\n\nBy default, this method calls \
             [`ExportDefaultDecl::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_export_default_decl(&mut self, node: ExportDefaultDecl) -> ExportDefaultDecl {
        <ExportDefaultDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDefaultExpr`.\n\nBy default, this method calls \
             [`ExportDefaultExpr::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_export_default_expr(&mut self, node: ExportDefaultExpr) -> ExportDefaultExpr {
        <ExportDefaultExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ExportDefaultSpecifier::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_export_default_specifier(
        &mut self,
        node: ExportDefaultSpecifier,
    ) -> ExportDefaultSpecifier {
        <ExportDefaultSpecifier as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportNamedSpecifier`.\n\nBy default, this method calls \
             [`ExportNamedSpecifier::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_export_named_specifier(&mut self, node: ExportNamedSpecifier) -> ExportNamedSpecifier {
        <ExportNamedSpecifier as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportNamespaceSpecifier`.\n\nBy default, this method calls \
             [`ExportNamespaceSpecifier::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_export_namespace_specifier(
        &mut self,
        node: ExportNamespaceSpecifier,
    ) -> ExportNamespaceSpecifier {
        <ExportNamespaceSpecifier as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExportSpecifier`.\n\nBy default, this method calls \
             [`ExportSpecifier::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_export_specifier(&mut self, node: ExportSpecifier) -> ExportSpecifier {
        <ExportSpecifier as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ExportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ExportSpecifier >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_export_specifiers(&mut self, node: Vec<ExportSpecifier>) -> Vec<ExportSpecifier> {
        <Vec<ExportSpecifier> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Expr`.\n\nBy default, this method calls \
             [`Expr::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_expr(&mut self, node: Expr) -> Expr {
        <Expr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExprOrSpread`.\n\nBy default, this method calls \
             [`ExprOrSpread::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_expr_or_spread(&mut self, node: ExprOrSpread) -> ExprOrSpread {
        <ExprOrSpread as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ExprOrSpread >`.\n\nBy default, this method calls [`Vec < \
             ExprOrSpread >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_expr_or_spreads(&mut self, node: Vec<ExprOrSpread>) -> Vec<ExprOrSpread> {
        <Vec<ExprOrSpread> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ExprStmt`.\n\nBy default, this method calls \
             [`ExprStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_expr_stmt(&mut self, node: ExprStmt) -> ExprStmt {
        <ExprStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Box < Expr > >`.\n\nBy default, this method calls [`Vec < \
             Box < Expr > >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_exprs(&mut self, node: Vec<Box<Expr>>) -> Vec<Box<Expr>> {
        <Vec<Box<Expr>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `FnDecl`.\n\nBy default, this method calls \
             [`FnDecl::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_fn_decl(&mut self, node: FnDecl) -> FnDecl {
        <FnDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `FnExpr`.\n\nBy default, this method calls \
             [`FnExpr::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_fn_expr(&mut self, node: FnExpr) -> FnExpr {
        <FnExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForHead`.\n\nBy default, this method calls \
             [`ForHead::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_for_head(&mut self, node: ForHead) -> ForHead {
        <ForHead as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForInStmt`.\n\nBy default, this method calls \
             [`ForInStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_for_in_stmt(&mut self, node: ForInStmt) -> ForInStmt {
        <ForInStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForOfStmt`.\n\nBy default, this method calls \
             [`ForOfStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_for_of_stmt(&mut self, node: ForOfStmt) -> ForOfStmt {
        <ForOfStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ForStmt`.\n\nBy default, this method calls \
             [`ForStmt::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_for_stmt(&mut self, node: ForStmt) -> ForStmt {
        <ForStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Function`.\n\nBy default, this method calls \
             [`Function::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_function(&mut self, node: Function) -> Function {
        <Function as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `GetterProp`.\n\nBy default, this method calls \
             [`GetterProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_getter_prop(&mut self, node: GetterProp) -> GetterProp {
        <GetterProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Ident`.\n\nBy default, this method calls \
             [`Ident::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_ident(&mut self, node: Ident) -> Ident {
        <Ident as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `IdentName`.\n\nBy default, this method calls \
             [`IdentName::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ident_name(&mut self, node: IdentName) -> IdentName {
        <IdentName as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `IfStmt`.\n\nBy default, this method calls \
             [`IfStmt::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_if_stmt(&mut self, node: IfStmt) -> IfStmt {
        <IfStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Import`.\n\nBy default, this method calls \
             [`Import::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_import(&mut self, node: Import) -> Import {
        <Import as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportDecl`.\n\nBy default, this method calls \
             [`ImportDecl::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_import_decl(&mut self, node: ImportDecl) -> ImportDecl {
        <ImportDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ImportDefaultSpecifier::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_import_default_specifier(
        &mut self,
        node: ImportDefaultSpecifier,
    ) -> ImportDefaultSpecifier {
        <ImportDefaultSpecifier as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportNamedSpecifier`.\n\nBy default, this method calls \
             [`ImportNamedSpecifier::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_import_named_specifier(&mut self, node: ImportNamedSpecifier) -> ImportNamedSpecifier {
        <ImportNamedSpecifier as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportPhase`.\n\nBy default, this method calls \
             [`ImportPhase::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_import_phase(&mut self, node: ImportPhase) -> ImportPhase {
        <ImportPhase as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportSpecifier`.\n\nBy default, this method calls \
             [`ImportSpecifier::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_import_specifier(&mut self, node: ImportSpecifier) -> ImportSpecifier {
        <ImportSpecifier as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ImportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ImportSpecifier >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_import_specifiers(&mut self, node: Vec<ImportSpecifier>) -> Vec<ImportSpecifier> {
        <Vec<ImportSpecifier> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportStarAsSpecifier`.\n\nBy default, this method calls \
             [`ImportStarAsSpecifier::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_import_star_as_specifier(
        &mut self,
        node: ImportStarAsSpecifier,
    ) -> ImportStarAsSpecifier {
        <ImportStarAsSpecifier as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportWith`.\n\nBy default, this method calls \
             [`ImportWith::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_import_with(&mut self, node: ImportWith) -> ImportWith {
        <ImportWith as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ImportWithItem`.\n\nBy default, this method calls \
             [`ImportWithItem::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_import_with_item(&mut self, node: ImportWithItem) -> ImportWithItem {
        <ImportWithItem as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ImportWithItem >`.\n\nBy default, this method calls [`Vec \
             < ImportWithItem >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_import_with_items(&mut self, node: Vec<ImportWithItem>) -> Vec<ImportWithItem> {
        <Vec<ImportWithItem> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Invalid`.\n\nBy default, this method calls \
             [`Invalid::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_invalid(&mut self, node: Invalid) -> Invalid {
        <Invalid as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttr`.\n\nBy default, this method calls \
             [`JSXAttr::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_jsx_attr(&mut self, node: JSXAttr) -> JSXAttr {
        <JSXAttr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttrName`.\n\nBy default, this method calls \
             [`JSXAttrName::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_jsx_attr_name(&mut self, node: JSXAttrName) -> JSXAttrName {
        <JSXAttrName as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttrOrSpread`.\n\nBy default, this method calls \
             [`JSXAttrOrSpread::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_jsx_attr_or_spread(&mut self, node: JSXAttrOrSpread) -> JSXAttrOrSpread {
        <JSXAttrOrSpread as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < JSXAttrOrSpread >`.\n\nBy default, this method calls \
             [`Vec < JSXAttrOrSpread >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_jsx_attr_or_spreads(&mut self, node: Vec<JSXAttrOrSpread>) -> Vec<JSXAttrOrSpread> {
        <Vec<JSXAttrOrSpread> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXAttrValue`.\n\nBy default, this method calls \
             [`JSXAttrValue::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_jsx_attr_value(&mut self, node: JSXAttrValue) -> JSXAttrValue {
        <JSXAttrValue as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXClosingElement`.\n\nBy default, this method calls \
             [`JSXClosingElement::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_jsx_closing_element(&mut self, node: JSXClosingElement) -> JSXClosingElement {
        <JSXClosingElement as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXClosingFragment`.\n\nBy default, this method calls \
             [`JSXClosingFragment::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_jsx_closing_fragment(&mut self, node: JSXClosingFragment) -> JSXClosingFragment {
        <JSXClosingFragment as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXElement`.\n\nBy default, this method calls \
             [`JSXElement::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_jsx_element(&mut self, node: JSXElement) -> JSXElement {
        <JSXElement as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXElementChild`.\n\nBy default, this method calls \
             [`JSXElementChild::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_jsx_element_child(&mut self, node: JSXElementChild) -> JSXElementChild {
        <JSXElementChild as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < JSXElementChild >`.\n\nBy default, this method calls \
             [`Vec < JSXElementChild >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_jsx_element_childs(&mut self, node: Vec<JSXElementChild>) -> Vec<JSXElementChild> {
        <Vec<JSXElementChild> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXElementName`.\n\nBy default, this method calls \
             [`JSXElementName::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_jsx_element_name(&mut self, node: JSXElementName) -> JSXElementName {
        <JSXElementName as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXEmptyExpr`.\n\nBy default, this method calls \
             [`JSXEmptyExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_jsx_empty_expr(&mut self, node: JSXEmptyExpr) -> JSXEmptyExpr {
        <JSXEmptyExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXExpr`.\n\nBy default, this method calls \
             [`JSXExpr::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_jsx_expr(&mut self, node: JSXExpr) -> JSXExpr {
        <JSXExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXExprContainer`.\n\nBy default, this method calls \
             [`JSXExprContainer::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_jsx_expr_container(&mut self, node: JSXExprContainer) -> JSXExprContainer {
        <JSXExprContainer as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXFragment`.\n\nBy default, this method calls \
             [`JSXFragment::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_jsx_fragment(&mut self, node: JSXFragment) -> JSXFragment {
        <JSXFragment as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXMemberExpr`.\n\nBy default, this method calls \
             [`JSXMemberExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_jsx_member_expr(&mut self, node: JSXMemberExpr) -> JSXMemberExpr {
        <JSXMemberExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXNamespacedName`.\n\nBy default, this method calls \
             [`JSXNamespacedName::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_jsx_namespaced_name(&mut self, node: JSXNamespacedName) -> JSXNamespacedName {
        <JSXNamespacedName as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXObject`.\n\nBy default, this method calls \
             [`JSXObject::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_jsx_object(&mut self, node: JSXObject) -> JSXObject {
        <JSXObject as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXOpeningElement`.\n\nBy default, this method calls \
             [`JSXOpeningElement::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_jsx_opening_element(&mut self, node: JSXOpeningElement) -> JSXOpeningElement {
        <JSXOpeningElement as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXOpeningFragment`.\n\nBy default, this method calls \
             [`JSXOpeningFragment::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_jsx_opening_fragment(&mut self, node: JSXOpeningFragment) -> JSXOpeningFragment {
        <JSXOpeningFragment as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXSpreadChild`.\n\nBy default, this method calls \
             [`JSXSpreadChild::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_jsx_spread_child(&mut self, node: JSXSpreadChild) -> JSXSpreadChild {
        <JSXSpreadChild as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `JSXText`.\n\nBy default, this method calls \
             [`JSXText::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_jsx_text(&mut self, node: JSXText) -> JSXText {
        <JSXText as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Key`.\n\nBy default, this method calls \
             [`Key::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_key(&mut self, node: Key) -> Key {
        <Key as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `KeyValuePatProp`.\n\nBy default, this method calls \
             [`KeyValuePatProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_key_value_pat_prop(&mut self, node: KeyValuePatProp) -> KeyValuePatProp {
        <KeyValuePatProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `KeyValueProp`.\n\nBy default, this method calls \
             [`KeyValueProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_key_value_prop(&mut self, node: KeyValueProp) -> KeyValueProp {
        <KeyValueProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `LabeledStmt`.\n\nBy default, this method calls \
             [`LabeledStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_labeled_stmt(&mut self, node: LabeledStmt) -> LabeledStmt {
        <LabeledStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Lit`.\n\nBy default, this method calls \
             [`Lit::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_lit(&mut self, node: Lit) -> Lit {
        <Lit as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `MemberExpr`.\n\nBy default, this method calls \
             [`MemberExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_member_expr(&mut self, node: MemberExpr) -> MemberExpr {
        <MemberExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `MemberProp`.\n\nBy default, this method calls \
             [`MemberProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_member_prop(&mut self, node: MemberProp) -> MemberProp {
        <MemberProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `MetaPropExpr`.\n\nBy default, this method calls \
             [`MetaPropExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_meta_prop_expr(&mut self, node: MetaPropExpr) -> MetaPropExpr {
        <MetaPropExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `MetaPropKind`.\n\nBy default, this method calls \
             [`MetaPropKind::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_meta_prop_kind(&mut self, node: MetaPropKind) -> MetaPropKind {
        <MetaPropKind as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `MethodKind`.\n\nBy default, this method calls \
             [`MethodKind::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_method_kind(&mut self, node: MethodKind) -> MethodKind {
        <MethodKind as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `MethodProp`.\n\nBy default, this method calls \
             [`MethodProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_method_prop(&mut self, node: MethodProp) -> MethodProp {
        <MethodProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Module`.\n\nBy default, this method calls \
             [`Module::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_module(&mut self, node: Module) -> Module {
        <Module as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ModuleDecl`.\n\nBy default, this method calls \
             [`ModuleDecl::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_module_decl(&mut self, node: ModuleDecl) -> ModuleDecl {
        <ModuleDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ModuleExportName`.\n\nBy default, this method calls \
             [`ModuleExportName::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_module_export_name(&mut self, node: ModuleExportName) -> ModuleExportName {
        <ModuleExportName as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ModuleItem`.\n\nBy default, this method calls \
             [`ModuleItem::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_module_item(&mut self, node: ModuleItem) -> ModuleItem {
        <ModuleItem as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ModuleItem >`.\n\nBy default, this method calls [`Vec < \
             ModuleItem >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_module_items(&mut self, node: Vec<ModuleItem>) -> Vec<ModuleItem> {
        <Vec<ModuleItem> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `NamedExport`.\n\nBy default, this method calls \
             [`NamedExport::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_named_export(&mut self, node: NamedExport) -> NamedExport {
        <NamedExport as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `NewExpr`.\n\nBy default, this method calls \
             [`NewExpr::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_new_expr(&mut self, node: NewExpr) -> NewExpr {
        <NewExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Null`.\n\nBy default, this method calls \
             [`Null::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_null(&mut self, node: Null) -> Null {
        <Null as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Number`.\n\nBy default, this method calls \
             [`Number::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_number(&mut self, node: Number) -> Number {
        <Number as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ObjectLit`.\n\nBy default, this method calls \
             [`ObjectLit::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_object_lit(&mut self, node: ObjectLit) -> ObjectLit {
        <ObjectLit as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ObjectPat`.\n\nBy default, this method calls \
             [`ObjectPat::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_object_pat(&mut self, node: ObjectPat) -> ObjectPat {
        <ObjectPat as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ObjectPatProp`.\n\nBy default, this method calls \
             [`ObjectPatProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_object_pat_prop(&mut self, node: ObjectPatProp) -> ObjectPatProp {
        <ObjectPatProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ObjectPatProp >`.\n\nBy default, this method calls [`Vec \
             < ObjectPatProp >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_object_pat_props(&mut self, node: Vec<ObjectPatProp>) -> Vec<ObjectPatProp> {
        <Vec<ObjectPatProp> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Accessibility >`.\n\nBy default, this method calls \
             [`Option < Accessibility >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_opt_accessibility(&mut self, node: Option<Accessibility>) -> Option<Accessibility> {
        <Option<Accessibility> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < swc_atoms :: Atom >`.\n\nBy default, this method calls \
             [`Option < swc_atoms :: Atom >::fold_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_opt_atom(&mut self, node: Option<swc_atoms::Atom>) -> Option<swc_atoms::Atom> {
        <Option<swc_atoms::Atom> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < BlockStmt >`.\n\nBy default, this method calls \
             [`Option < BlockStmt >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_opt_block_stmt(&mut self, node: Option<BlockStmt>) -> Option<BlockStmt> {
        <Option<BlockStmt> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `OptCall`.\n\nBy default, this method calls \
             [`OptCall::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_opt_call(&mut self, node: OptCall) -> OptCall {
        <OptCall as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < CatchClause >`.\n\nBy default, this method calls \
             [`Option < CatchClause >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_opt_catch_clause(&mut self, node: Option<CatchClause>) -> Option<CatchClause> {
        <Option<CatchClause> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `OptChainBase`.\n\nBy default, this method calls \
             [`OptChainBase::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_opt_chain_base(&mut self, node: OptChainBase) -> OptChainBase {
        <OptChainBase as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `OptChainExpr`.\n\nBy default, this method calls \
             [`OptChainExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_opt_chain_expr(&mut self, node: OptChainExpr) -> OptChainExpr {
        <OptChainExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < Expr > >`.\n\nBy default, this method calls \
             [`Option < Box < Expr > >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_opt_expr(&mut self, node: Option<Box<Expr>>) -> Option<Box<Expr>> {
        <Option<Box<Expr>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < ExprOrSpread >`.\n\nBy default, this method calls \
             [`Option < ExprOrSpread >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_opt_expr_or_spread(&mut self, node: Option<ExprOrSpread>) -> Option<ExprOrSpread> {
        <Option<ExprOrSpread> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Vec < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Option < Vec < ExprOrSpread > >::fold_children_with`]. If you want to \
             recurse, you need to call it manually."]
    fn fold_opt_expr_or_spreads(
        &mut self,
        node: Option<Vec<ExprOrSpread>>,
    ) -> Option<Vec<ExprOrSpread>> {
        <Option<Vec<ExprOrSpread>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Ident >`.\n\nBy default, this method calls [`Option < \
             Ident >::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_opt_ident(&mut self, node: Option<Ident>) -> Option<Ident> {
        <Option<Ident> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < JSXAttrValue >`.\n\nBy default, this method calls \
             [`Option < JSXAttrValue >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_opt_jsx_attr_value(&mut self, node: Option<JSXAttrValue>) -> Option<JSXAttrValue> {
        <Option<JSXAttrValue> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < JSXClosingElement >`.\n\nBy default, this method calls \
             [`Option < JSXClosingElement >::fold_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_opt_jsx_closing_element(
        &mut self,
        node: Option<JSXClosingElement>,
    ) -> Option<JSXClosingElement> {
        <Option<JSXClosingElement> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < ModuleExportName >`.\n\nBy default, this method calls \
             [`Option < ModuleExportName >::fold_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_opt_module_export_name(
        &mut self,
        node: Option<ModuleExportName>,
    ) -> Option<ModuleExportName> {
        <Option<ModuleExportName> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Vec < ModuleItem > >`.\n\nBy default, this method \
             calls [`Option < Vec < ModuleItem > >::fold_children_with`]. If you want to recurse, \
             you need to call it manually."]
    fn fold_opt_module_items(&mut self, node: Option<Vec<ModuleItem>>) -> Option<Vec<ModuleItem>> {
        <Option<Vec<ModuleItem>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < ObjectLit > >`.\n\nBy default, this method calls \
             [`Option < Box < ObjectLit > >::fold_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_opt_object_lit(&mut self, node: Option<Box<ObjectLit>>) -> Option<Box<ObjectLit>> {
        <Option<Box<ObjectLit>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Pat >`.\n\nBy default, this method calls [`Option < \
             Pat >::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_opt_pat(&mut self, node: Option<Pat>) -> Option<Pat> {
        <Option<Pat> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < swc_common :: Span >`.\n\nBy default, this method \
             calls [`Option < swc_common :: Span >::fold_children_with`]. If you want to recurse, \
             you need to call it manually."]
    fn fold_opt_span(&mut self, node: Option<swc_common::Span>) -> Option<swc_common::Span> {
        <Option<swc_common::Span> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < Stmt > >`.\n\nBy default, this method calls \
             [`Option < Box < Stmt > >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_opt_stmt(&mut self, node: Option<Box<Stmt>>) -> Option<Box<Stmt>> {
        <Option<Box<Stmt>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < Str > >`.\n\nBy default, this method calls \
             [`Option < Box < Str > >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_opt_str(&mut self, node: Option<Box<Str>>) -> Option<Box<Str>> {
        <Option<Box<Str>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < TruePlusMinus >`.\n\nBy default, this method calls \
             [`Option < TruePlusMinus >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_opt_true_plus_minus(&mut self, node: Option<TruePlusMinus>) -> Option<TruePlusMinus> {
        <Option<TruePlusMinus> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < TsEntityName >`.\n\nBy default, this method calls \
             [`Option < TsEntityName >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_opt_ts_entity_name(&mut self, node: Option<TsEntityName>) -> Option<TsEntityName> {
        <Option<TsEntityName> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < TsNamespaceBody >`.\n\nBy default, this method calls \
             [`Option < TsNamespaceBody >::fold_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_opt_ts_namespace_body(
        &mut self,
        node: Option<TsNamespaceBody>,
    ) -> Option<TsNamespaceBody> {
        <Option<TsNamespaceBody> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < TsType > >`.\n\nBy default, this method calls \
             [`Option < Box < TsType > >::fold_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_opt_ts_type(&mut self, node: Option<Box<TsType>>) -> Option<Box<TsType>> {
        <Option<Box<TsType>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < TsTypeAnn > >`.\n\nBy default, this method calls \
             [`Option < Box < TsTypeAnn > >::fold_children_with`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_opt_ts_type_ann(&mut self, node: Option<Box<TsTypeAnn>>) -> Option<Box<TsTypeAnn>> {
        <Option<Box<TsTypeAnn>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < TsTypeParamDecl > >`.\n\nBy default, this method \
             calls [`Option < Box < TsTypeParamDecl > >::fold_children_with`]. If you want to \
             recurse, you need to call it manually."]
    fn fold_opt_ts_type_param_decl(
        &mut self,
        node: Option<Box<TsTypeParamDecl>>,
    ) -> Option<Box<TsTypeParamDecl>> {
        <Option<Box<TsTypeParamDecl>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < Box < TsTypeParamInstantiation > >`.\n\nBy default, \
             this method calls [`Option < Box < TsTypeParamInstantiation > \
             >::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_opt_ts_type_param_instantiation(
        &mut self,
        node: Option<Box<TsTypeParamInstantiation>>,
    ) -> Option<Box<TsTypeParamInstantiation>> {
        <Option<Box<TsTypeParamInstantiation>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Option < VarDeclOrExpr >`.\n\nBy default, this method calls \
             [`Option < VarDeclOrExpr >::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_opt_var_decl_or_expr(&mut self, node: Option<VarDeclOrExpr>) -> Option<VarDeclOrExpr> {
        <Option<VarDeclOrExpr> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Option < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Vec < Option < ExprOrSpread > >::fold_children_with`]. If you want to \
             recurse, you need to call it manually."]
    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        node: Vec<Option<ExprOrSpread>>,
    ) -> Vec<Option<ExprOrSpread>> {
        <Vec<Option<ExprOrSpread>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Option < Pat > >`.\n\nBy default, this method calls [`Vec \
             < Option < Pat > >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_opt_vec_pats(&mut self, node: Vec<Option<Pat>>) -> Vec<Option<Pat>> {
        <Vec<Option<Pat>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Param`.\n\nBy default, this method calls \
             [`Param::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_param(&mut self, node: Param) -> Param {
        <Param as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ParamOrTsParamProp`.\n\nBy default, this method calls \
             [`ParamOrTsParamProp::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_param_or_ts_param_prop(&mut self, node: ParamOrTsParamProp) -> ParamOrTsParamProp {
        <ParamOrTsParamProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < ParamOrTsParamProp >`.\n\nBy default, this method calls \
             [`Vec < ParamOrTsParamProp >::fold_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_param_or_ts_param_props(
        &mut self,
        node: Vec<ParamOrTsParamProp>,
    ) -> Vec<ParamOrTsParamProp> {
        <Vec<ParamOrTsParamProp> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Param >`.\n\nBy default, this method calls [`Vec < Param \
             >::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_params(&mut self, node: Vec<Param>) -> Vec<Param> {
        <Vec<Param> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ParenExpr`.\n\nBy default, this method calls \
             [`ParenExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_paren_expr(&mut self, node: ParenExpr) -> ParenExpr {
        <ParenExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Pat`.\n\nBy default, this method calls \
             [`Pat::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_pat(&mut self, node: Pat) -> Pat {
        <Pat as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Pat >`.\n\nBy default, this method calls [`Vec < Pat \
             >::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_pats(&mut self, node: Vec<Pat>) -> Vec<Pat> {
        <Vec<Pat> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `PrivateMethod`.\n\nBy default, this method calls \
             [`PrivateMethod::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_private_method(&mut self, node: PrivateMethod) -> PrivateMethod {
        <PrivateMethod as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `PrivateName`.\n\nBy default, this method calls \
             [`PrivateName::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_private_name(&mut self, node: PrivateName) -> PrivateName {
        <PrivateName as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `PrivateProp`.\n\nBy default, this method calls \
             [`PrivateProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_private_prop(&mut self, node: PrivateProp) -> PrivateProp {
        <PrivateProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Program`.\n\nBy default, this method calls \
             [`Program::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_program(&mut self, node: Program) -> Program {
        <Program as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Prop`.\n\nBy default, this method calls \
             [`Prop::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_prop(&mut self, node: Prop) -> Prop {
        <Prop as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `PropName`.\n\nBy default, this method calls \
             [`PropName::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_prop_name(&mut self, node: PropName) -> PropName {
        <PropName as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `PropOrSpread`.\n\nBy default, this method calls \
             [`PropOrSpread::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_prop_or_spread(&mut self, node: PropOrSpread) -> PropOrSpread {
        <PropOrSpread as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < PropOrSpread >`.\n\nBy default, this method calls [`Vec < \
             PropOrSpread >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_prop_or_spreads(&mut self, node: Vec<PropOrSpread>) -> Vec<PropOrSpread> {
        <Vec<PropOrSpread> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Regex`.\n\nBy default, this method calls \
             [`Regex::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_regex(&mut self, node: Regex) -> Regex {
        <Regex as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ReservedUnused`.\n\nBy default, this method calls \
             [`ReservedUnused::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_reserved_unused(&mut self, node: ReservedUnused) -> ReservedUnused {
        <ReservedUnused as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `RestPat`.\n\nBy default, this method calls \
             [`RestPat::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_rest_pat(&mut self, node: RestPat) -> RestPat {
        <RestPat as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ReturnStmt`.\n\nBy default, this method calls \
             [`ReturnStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_return_stmt(&mut self, node: ReturnStmt) -> ReturnStmt {
        <ReturnStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Script`.\n\nBy default, this method calls \
             [`Script::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_script(&mut self, node: Script) -> Script {
        <Script as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `SeqExpr`.\n\nBy default, this method calls \
             [`SeqExpr::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_seq_expr(&mut self, node: SeqExpr) -> SeqExpr {
        <SeqExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `SetterProp`.\n\nBy default, this method calls \
             [`SetterProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_setter_prop(&mut self, node: SetterProp) -> SetterProp {
        <SetterProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `SimpleAssignTarget`.\n\nBy default, this method calls \
             [`SimpleAssignTarget::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_simple_assign_target(&mut self, node: SimpleAssignTarget) -> SimpleAssignTarget {
        <SimpleAssignTarget as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_common :: Span`.\n\nBy default, this method calls \
             [`swc_common :: Span::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_span(&mut self, node: swc_common::Span) -> swc_common::Span {
        <swc_common::Span as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `SpreadElement`.\n\nBy default, this method calls \
             [`SpreadElement::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_spread_element(&mut self, node: SpreadElement) -> SpreadElement {
        <SpreadElement as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `StaticBlock`.\n\nBy default, this method calls \
             [`StaticBlock::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_static_block(&mut self, node: StaticBlock) -> StaticBlock {
        <StaticBlock as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Stmt`.\n\nBy default, this method calls \
             [`Stmt::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_stmt(&mut self, node: Stmt) -> Stmt {
        <Stmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Stmt >`.\n\nBy default, this method calls [`Vec < Stmt \
             >::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_stmts(&mut self, node: Vec<Stmt>) -> Vec<Stmt> {
        <Vec<Stmt> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Str`.\n\nBy default, this method calls \
             [`Str::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_str(&mut self, node: Str) -> Str {
        <Str as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Super`.\n\nBy default, this method calls \
             [`Super::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_super(&mut self, node: Super) -> Super {
        <Super as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `SuperProp`.\n\nBy default, this method calls \
             [`SuperProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_super_prop(&mut self, node: SuperProp) -> SuperProp {
        <SuperProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `SuperPropExpr`.\n\nBy default, this method calls \
             [`SuperPropExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_super_prop_expr(&mut self, node: SuperPropExpr) -> SuperPropExpr {
        <SuperPropExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `SwitchCase`.\n\nBy default, this method calls \
             [`SwitchCase::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_switch_case(&mut self, node: SwitchCase) -> SwitchCase {
        <SwitchCase as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < SwitchCase >`.\n\nBy default, this method calls [`Vec < \
             SwitchCase >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_switch_cases(&mut self, node: Vec<SwitchCase>) -> Vec<SwitchCase> {
        <Vec<SwitchCase> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `SwitchStmt`.\n\nBy default, this method calls \
             [`SwitchStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_switch_stmt(&mut self, node: SwitchStmt) -> SwitchStmt {
        <SwitchStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `swc_common :: SyntaxContext`.\n\nBy default, this method calls \
             [`swc_common :: SyntaxContext::fold_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_syntax_context(
        &mut self,
        node: swc_common::SyntaxContext,
    ) -> swc_common::SyntaxContext {
        <swc_common::SyntaxContext as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TaggedTpl`.\n\nBy default, this method calls \
             [`TaggedTpl::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_tagged_tpl(&mut self, node: TaggedTpl) -> TaggedTpl {
        <TaggedTpl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ThisExpr`.\n\nBy default, this method calls \
             [`ThisExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_this_expr(&mut self, node: ThisExpr) -> ThisExpr {
        <ThisExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `ThrowStmt`.\n\nBy default, this method calls \
             [`ThrowStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_throw_stmt(&mut self, node: ThrowStmt) -> ThrowStmt {
        <ThrowStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Tpl`.\n\nBy default, this method calls \
             [`Tpl::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_tpl(&mut self, node: Tpl) -> Tpl {
        <Tpl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TplElement`.\n\nBy default, this method calls \
             [`TplElement::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_tpl_element(&mut self, node: TplElement) -> TplElement {
        <TplElement as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TplElement >`.\n\nBy default, this method calls [`Vec < \
             TplElement >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_tpl_elements(&mut self, node: Vec<TplElement>) -> Vec<TplElement> {
        <Vec<TplElement> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TruePlusMinus`.\n\nBy default, this method calls \
             [`TruePlusMinus::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_true_plus_minus(&mut self, node: TruePlusMinus) -> TruePlusMinus {
        <TruePlusMinus as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TryStmt`.\n\nBy default, this method calls \
             [`TryStmt::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_try_stmt(&mut self, node: TryStmt) -> TryStmt {
        <TryStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsArrayType`.\n\nBy default, this method calls \
             [`TsArrayType::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_array_type(&mut self, node: TsArrayType) -> TsArrayType {
        <TsArrayType as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsAsExpr`.\n\nBy default, this method calls \
             [`TsAsExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_as_expr(&mut self, node: TsAsExpr) -> TsAsExpr {
        <TsAsExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsCallSignatureDecl`.\n\nBy default, this method calls \
             [`TsCallSignatureDecl::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_call_signature_decl(&mut self, node: TsCallSignatureDecl) -> TsCallSignatureDecl {
        <TsCallSignatureDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsConditionalType`.\n\nBy default, this method calls \
             [`TsConditionalType::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_conditional_type(&mut self, node: TsConditionalType) -> TsConditionalType {
        <TsConditionalType as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsConstAssertion`.\n\nBy default, this method calls \
             [`TsConstAssertion::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_const_assertion(&mut self, node: TsConstAssertion) -> TsConstAssertion {
        <TsConstAssertion as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsConstructSignatureDecl`.\n\nBy default, this method calls \
             [`TsConstructSignatureDecl::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_construct_signature_decl(
        &mut self,
        node: TsConstructSignatureDecl,
    ) -> TsConstructSignatureDecl {
        <TsConstructSignatureDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsConstructorType`.\n\nBy default, this method calls \
             [`TsConstructorType::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_constructor_type(&mut self, node: TsConstructorType) -> TsConstructorType {
        <TsConstructorType as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsEntityName`.\n\nBy default, this method calls \
             [`TsEntityName::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_entity_name(&mut self, node: TsEntityName) -> TsEntityName {
        <TsEntityName as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsEnumDecl`.\n\nBy default, this method calls \
             [`TsEnumDecl::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_enum_decl(&mut self, node: TsEnumDecl) -> TsEnumDecl {
        <TsEnumDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsEnumMember`.\n\nBy default, this method calls \
             [`TsEnumMember::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_enum_member(&mut self, node: TsEnumMember) -> TsEnumMember {
        <TsEnumMember as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsEnumMemberId`.\n\nBy default, this method calls \
             [`TsEnumMemberId::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_enum_member_id(&mut self, node: TsEnumMemberId) -> TsEnumMemberId {
        <TsEnumMemberId as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TsEnumMember >`.\n\nBy default, this method calls [`Vec < \
             TsEnumMember >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_enum_members(&mut self, node: Vec<TsEnumMember>) -> Vec<TsEnumMember> {
        <Vec<TsEnumMember> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsExportAssignment`.\n\nBy default, this method calls \
             [`TsExportAssignment::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_export_assignment(&mut self, node: TsExportAssignment) -> TsExportAssignment {
        <TsExportAssignment as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsExprWithTypeArgs`.\n\nBy default, this method calls \
             [`TsExprWithTypeArgs::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_expr_with_type_args(&mut self, node: TsExprWithTypeArgs) -> TsExprWithTypeArgs {
        <TsExprWithTypeArgs as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TsExprWithTypeArgs >`.\n\nBy default, this method calls \
             [`Vec < TsExprWithTypeArgs >::fold_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_ts_expr_with_type_argss(
        &mut self,
        node: Vec<TsExprWithTypeArgs>,
    ) -> Vec<TsExprWithTypeArgs> {
        <Vec<TsExprWithTypeArgs> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsExternalModuleRef`.\n\nBy default, this method calls \
             [`TsExternalModuleRef::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_external_module_ref(&mut self, node: TsExternalModuleRef) -> TsExternalModuleRef {
        <TsExternalModuleRef as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsFnOrConstructorType`.\n\nBy default, this method calls \
             [`TsFnOrConstructorType::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_fn_or_constructor_type(
        &mut self,
        node: TsFnOrConstructorType,
    ) -> TsFnOrConstructorType {
        <TsFnOrConstructorType as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsFnParam`.\n\nBy default, this method calls \
             [`TsFnParam::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_fn_param(&mut self, node: TsFnParam) -> TsFnParam {
        <TsFnParam as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TsFnParam >`.\n\nBy default, this method calls [`Vec < \
             TsFnParam >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_fn_params(&mut self, node: Vec<TsFnParam>) -> Vec<TsFnParam> {
        <Vec<TsFnParam> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsFnType`.\n\nBy default, this method calls \
             [`TsFnType::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_fn_type(&mut self, node: TsFnType) -> TsFnType {
        <TsFnType as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsGetterSignature`.\n\nBy default, this method calls \
             [`TsGetterSignature::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_getter_signature(&mut self, node: TsGetterSignature) -> TsGetterSignature {
        <TsGetterSignature as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsImportEqualsDecl`.\n\nBy default, this method calls \
             [`TsImportEqualsDecl::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_import_equals_decl(&mut self, node: TsImportEqualsDecl) -> TsImportEqualsDecl {
        <TsImportEqualsDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsImportType`.\n\nBy default, this method calls \
             [`TsImportType::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_import_type(&mut self, node: TsImportType) -> TsImportType {
        <TsImportType as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsIndexSignature`.\n\nBy default, this method calls \
             [`TsIndexSignature::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_index_signature(&mut self, node: TsIndexSignature) -> TsIndexSignature {
        <TsIndexSignature as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsIndexedAccessType`.\n\nBy default, this method calls \
             [`TsIndexedAccessType::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_indexed_access_type(&mut self, node: TsIndexedAccessType) -> TsIndexedAccessType {
        <TsIndexedAccessType as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsInferType`.\n\nBy default, this method calls \
             [`TsInferType::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_infer_type(&mut self, node: TsInferType) -> TsInferType {
        <TsInferType as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsInstantiation`.\n\nBy default, this method calls \
             [`TsInstantiation::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_instantiation(&mut self, node: TsInstantiation) -> TsInstantiation {
        <TsInstantiation as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsInterfaceBody`.\n\nBy default, this method calls \
             [`TsInterfaceBody::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_interface_body(&mut self, node: TsInterfaceBody) -> TsInterfaceBody {
        <TsInterfaceBody as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsInterfaceDecl`.\n\nBy default, this method calls \
             [`TsInterfaceDecl::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_interface_decl(&mut self, node: TsInterfaceDecl) -> TsInterfaceDecl {
        <TsInterfaceDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsIntersectionType`.\n\nBy default, this method calls \
             [`TsIntersectionType::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_intersection_type(&mut self, node: TsIntersectionType) -> TsIntersectionType {
        <TsIntersectionType as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsKeywordType`.\n\nBy default, this method calls \
             [`TsKeywordType::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_keyword_type(&mut self, node: TsKeywordType) -> TsKeywordType {
        <TsKeywordType as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsKeywordTypeKind`.\n\nBy default, this method calls \
             [`TsKeywordTypeKind::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_keyword_type_kind(&mut self, node: TsKeywordTypeKind) -> TsKeywordTypeKind {
        <TsKeywordTypeKind as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsLit`.\n\nBy default, this method calls \
             [`TsLit::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_ts_lit(&mut self, node: TsLit) -> TsLit {
        <TsLit as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsLitType`.\n\nBy default, this method calls \
             [`TsLitType::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_lit_type(&mut self, node: TsLitType) -> TsLitType {
        <TsLitType as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsMappedType`.\n\nBy default, this method calls \
             [`TsMappedType::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_mapped_type(&mut self, node: TsMappedType) -> TsMappedType {
        <TsMappedType as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsMethodSignature`.\n\nBy default, this method calls \
             [`TsMethodSignature::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_method_signature(&mut self, node: TsMethodSignature) -> TsMethodSignature {
        <TsMethodSignature as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsModuleBlock`.\n\nBy default, this method calls \
             [`TsModuleBlock::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_module_block(&mut self, node: TsModuleBlock) -> TsModuleBlock {
        <TsModuleBlock as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsModuleDecl`.\n\nBy default, this method calls \
             [`TsModuleDecl::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_module_decl(&mut self, node: TsModuleDecl) -> TsModuleDecl {
        <TsModuleDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsModuleName`.\n\nBy default, this method calls \
             [`TsModuleName::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_module_name(&mut self, node: TsModuleName) -> TsModuleName {
        <TsModuleName as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsModuleRef`.\n\nBy default, this method calls \
             [`TsModuleRef::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_module_ref(&mut self, node: TsModuleRef) -> TsModuleRef {
        <TsModuleRef as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsNamespaceBody`.\n\nBy default, this method calls \
             [`TsNamespaceBody::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_namespace_body(&mut self, node: TsNamespaceBody) -> TsNamespaceBody {
        <TsNamespaceBody as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsNamespaceDecl`.\n\nBy default, this method calls \
             [`TsNamespaceDecl::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_namespace_decl(&mut self, node: TsNamespaceDecl) -> TsNamespaceDecl {
        <TsNamespaceDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsNamespaceExportDecl`.\n\nBy default, this method calls \
             [`TsNamespaceExportDecl::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_namespace_export_decl(
        &mut self,
        node: TsNamespaceExportDecl,
    ) -> TsNamespaceExportDecl {
        <TsNamespaceExportDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsNonNullExpr`.\n\nBy default, this method calls \
             [`TsNonNullExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_non_null_expr(&mut self, node: TsNonNullExpr) -> TsNonNullExpr {
        <TsNonNullExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsOptionalType`.\n\nBy default, this method calls \
             [`TsOptionalType::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_optional_type(&mut self, node: TsOptionalType) -> TsOptionalType {
        <TsOptionalType as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsParamProp`.\n\nBy default, this method calls \
             [`TsParamProp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_param_prop(&mut self, node: TsParamProp) -> TsParamProp {
        <TsParamProp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsParamPropParam`.\n\nBy default, this method calls \
             [`TsParamPropParam::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_param_prop_param(&mut self, node: TsParamPropParam) -> TsParamPropParam {
        <TsParamPropParam as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsParenthesizedType`.\n\nBy default, this method calls \
             [`TsParenthesizedType::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_parenthesized_type(&mut self, node: TsParenthesizedType) -> TsParenthesizedType {
        <TsParenthesizedType as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsPropertySignature`.\n\nBy default, this method calls \
             [`TsPropertySignature::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_property_signature(&mut self, node: TsPropertySignature) -> TsPropertySignature {
        <TsPropertySignature as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsQualifiedName`.\n\nBy default, this method calls \
             [`TsQualifiedName::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_qualified_name(&mut self, node: TsQualifiedName) -> TsQualifiedName {
        <TsQualifiedName as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsRestType`.\n\nBy default, this method calls \
             [`TsRestType::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_rest_type(&mut self, node: TsRestType) -> TsRestType {
        <TsRestType as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsSatisfiesExpr`.\n\nBy default, this method calls \
             [`TsSatisfiesExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_satisfies_expr(&mut self, node: TsSatisfiesExpr) -> TsSatisfiesExpr {
        <TsSatisfiesExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsSetterSignature`.\n\nBy default, this method calls \
             [`TsSetterSignature::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_setter_signature(&mut self, node: TsSetterSignature) -> TsSetterSignature {
        <TsSetterSignature as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsThisType`.\n\nBy default, this method calls \
             [`TsThisType::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_this_type(&mut self, node: TsThisType) -> TsThisType {
        <TsThisType as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsThisTypeOrIdent`.\n\nBy default, this method calls \
             [`TsThisTypeOrIdent::fold_children_with`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_this_type_or_ident(&mut self, node: TsThisTypeOrIdent) -> TsThisTypeOrIdent {
        <TsThisTypeOrIdent as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTplLitType`.\n\nBy default, this method calls \
             [`TsTplLitType::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_tpl_lit_type(&mut self, node: TsTplLitType) -> TsTplLitType {
        <TsTplLitType as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTupleElement`.\n\nBy default, this method calls \
             [`TsTupleElement::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_tuple_element(&mut self, node: TsTupleElement) -> TsTupleElement {
        <TsTupleElement as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TsTupleElement >`.\n\nBy default, this method calls [`Vec \
             < TsTupleElement >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_tuple_elements(&mut self, node: Vec<TsTupleElement>) -> Vec<TsTupleElement> {
        <Vec<TsTupleElement> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTupleType`.\n\nBy default, this method calls \
             [`TsTupleType::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_tuple_type(&mut self, node: TsTupleType) -> TsTupleType {
        <TsTupleType as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsType`.\n\nBy default, this method calls \
             [`TsType::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_ts_type(&mut self, node: TsType) -> TsType {
        <TsType as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeAliasDecl`.\n\nBy default, this method calls \
             [`TsTypeAliasDecl::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_type_alias_decl(&mut self, node: TsTypeAliasDecl) -> TsTypeAliasDecl {
        <TsTypeAliasDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeAnn`.\n\nBy default, this method calls \
             [`TsTypeAnn::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_type_ann(&mut self, node: TsTypeAnn) -> TsTypeAnn {
        <TsTypeAnn as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeAssertion`.\n\nBy default, this method calls \
             [`TsTypeAssertion::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_type_assertion(&mut self, node: TsTypeAssertion) -> TsTypeAssertion {
        <TsTypeAssertion as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeElement`.\n\nBy default, this method calls \
             [`TsTypeElement::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_type_element(&mut self, node: TsTypeElement) -> TsTypeElement {
        <TsTypeElement as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TsTypeElement >`.\n\nBy default, this method calls [`Vec \
             < TsTypeElement >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_type_elements(&mut self, node: Vec<TsTypeElement>) -> Vec<TsTypeElement> {
        <Vec<TsTypeElement> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeLit`.\n\nBy default, this method calls \
             [`TsTypeLit::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_type_lit(&mut self, node: TsTypeLit) -> TsTypeLit {
        <TsTypeLit as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeOperator`.\n\nBy default, this method calls \
             [`TsTypeOperator::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_type_operator(&mut self, node: TsTypeOperator) -> TsTypeOperator {
        <TsTypeOperator as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeOperatorOp`.\n\nBy default, this method calls \
             [`TsTypeOperatorOp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_type_operator_op(&mut self, node: TsTypeOperatorOp) -> TsTypeOperatorOp {
        <TsTypeOperatorOp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeParam`.\n\nBy default, this method calls \
             [`TsTypeParam::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_type_param(&mut self, node: TsTypeParam) -> TsTypeParam {
        <TsTypeParam as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeParamDecl`.\n\nBy default, this method calls \
             [`TsTypeParamDecl::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_type_param_decl(&mut self, node: TsTypeParamDecl) -> TsTypeParamDecl {
        <TsTypeParamDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeParamInstantiation`.\n\nBy default, this method calls \
             [`TsTypeParamInstantiation::fold_children_with`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_type_param_instantiation(
        &mut self,
        node: TsTypeParamInstantiation,
    ) -> TsTypeParamInstantiation {
        <TsTypeParamInstantiation as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < TsTypeParam >`.\n\nBy default, this method calls [`Vec < \
             TsTypeParam >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_type_params(&mut self, node: Vec<TsTypeParam>) -> Vec<TsTypeParam> {
        <Vec<TsTypeParam> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypePredicate`.\n\nBy default, this method calls \
             [`TsTypePredicate::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_type_predicate(&mut self, node: TsTypePredicate) -> TsTypePredicate {
        <TsTypePredicate as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeQuery`.\n\nBy default, this method calls \
             [`TsTypeQuery::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_type_query(&mut self, node: TsTypeQuery) -> TsTypeQuery {
        <TsTypeQuery as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeQueryExpr`.\n\nBy default, this method calls \
             [`TsTypeQueryExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_type_query_expr(&mut self, node: TsTypeQueryExpr) -> TsTypeQueryExpr {
        <TsTypeQueryExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsTypeRef`.\n\nBy default, this method calls \
             [`TsTypeRef::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_type_ref(&mut self, node: TsTypeRef) -> TsTypeRef {
        <TsTypeRef as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < Box < TsType > >`.\n\nBy default, this method calls [`Vec \
             < Box < TsType > >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_types(&mut self, node: Vec<Box<TsType>>) -> Vec<Box<TsType>> {
        <Vec<Box<TsType>> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsUnionOrIntersectionType`.\n\nBy default, this method calls \
             [`TsUnionOrIntersectionType::fold_children_with`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_ts_union_or_intersection_type(
        &mut self,
        node: TsUnionOrIntersectionType,
    ) -> TsUnionOrIntersectionType {
        <TsUnionOrIntersectionType as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `TsUnionType`.\n\nBy default, this method calls \
             [`TsUnionType::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_union_type(&mut self, node: TsUnionType) -> TsUnionType {
        <TsUnionType as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `UnaryExpr`.\n\nBy default, this method calls \
             [`UnaryExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_unary_expr(&mut self, node: UnaryExpr) -> UnaryExpr {
        <UnaryExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `UnaryOp`.\n\nBy default, this method calls \
             [`UnaryOp::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_unary_op(&mut self, node: UnaryOp) -> UnaryOp {
        <UnaryOp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `UpdateExpr`.\n\nBy default, this method calls \
             [`UpdateExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_update_expr(&mut self, node: UpdateExpr) -> UpdateExpr {
        <UpdateExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `UpdateOp`.\n\nBy default, this method calls \
             [`UpdateOp::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_update_op(&mut self, node: UpdateOp) -> UpdateOp {
        <UpdateOp as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `UsingDecl`.\n\nBy default, this method calls \
             [`UsingDecl::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_using_decl(&mut self, node: UsingDecl) -> UsingDecl {
        <UsingDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDecl`.\n\nBy default, this method calls \
             [`VarDecl::fold_children_with`]. If you want to recurse, you need to call it manually."]
    fn fold_var_decl(&mut self, node: VarDecl) -> VarDecl {
        <VarDecl as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDeclKind`.\n\nBy default, this method calls \
             [`VarDeclKind::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_var_decl_kind(&mut self, node: VarDeclKind) -> VarDeclKind {
        <VarDeclKind as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDeclOrExpr`.\n\nBy default, this method calls \
             [`VarDeclOrExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_var_decl_or_expr(&mut self, node: VarDeclOrExpr) -> VarDeclOrExpr {
        <VarDeclOrExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `VarDeclarator`.\n\nBy default, this method calls \
             [`VarDeclarator::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_var_declarator(&mut self, node: VarDeclarator) -> VarDeclarator {
        <VarDeclarator as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `Vec < VarDeclarator >`.\n\nBy default, this method calls [`Vec \
             < VarDeclarator >::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_var_declarators(&mut self, node: Vec<VarDeclarator>) -> Vec<VarDeclarator> {
        <Vec<VarDeclarator> as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `WhileStmt`.\n\nBy default, this method calls \
             [`WhileStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_while_stmt(&mut self, node: WhileStmt) -> WhileStmt {
        <WhileStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `WithStmt`.\n\nBy default, this method calls \
             [`WithStmt::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_with_stmt(&mut self, node: WithStmt) -> WithStmt {
        <WithStmt as FoldWith<Self>>::fold_children_with(node, self)
    }
    #[doc = "Visit a node of type `YieldExpr`.\n\nBy default, this method calls \
             [`YieldExpr::fold_children_with`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_yield_expr(&mut self, node: YieldExpr) -> YieldExpr {
        <YieldExpr as FoldWith<Self>>::fold_children_with(node, self)
    }
}
impl<V> Fold for &mut V
where
    V: ?Sized + Fold,
{
    fn fold_accessibility(&mut self, node: Accessibility) -> Accessibility {
        Fold::fold_accessibility(&mut **self, node)
    }

    fn fold_array_lit(&mut self, node: ArrayLit) -> ArrayLit {
        Fold::fold_array_lit(&mut **self, node)
    }

    fn fold_array_pat(&mut self, node: ArrayPat) -> ArrayPat {
        Fold::fold_array_pat(&mut **self, node)
    }

    fn fold_arrow_expr(&mut self, node: ArrowExpr) -> ArrowExpr {
        Fold::fold_arrow_expr(&mut **self, node)
    }

    fn fold_assign_expr(&mut self, node: AssignExpr) -> AssignExpr {
        Fold::fold_assign_expr(&mut **self, node)
    }

    fn fold_assign_op(&mut self, node: AssignOp) -> AssignOp {
        Fold::fold_assign_op(&mut **self, node)
    }

    fn fold_assign_pat(&mut self, node: AssignPat) -> AssignPat {
        Fold::fold_assign_pat(&mut **self, node)
    }

    fn fold_assign_pat_prop(&mut self, node: AssignPatProp) -> AssignPatProp {
        Fold::fold_assign_pat_prop(&mut **self, node)
    }

    fn fold_assign_prop(&mut self, node: AssignProp) -> AssignProp {
        Fold::fold_assign_prop(&mut **self, node)
    }

    fn fold_assign_target(&mut self, node: AssignTarget) -> AssignTarget {
        Fold::fold_assign_target(&mut **self, node)
    }

    fn fold_assign_target_pat(&mut self, node: AssignTargetPat) -> AssignTargetPat {
        Fold::fold_assign_target_pat(&mut **self, node)
    }

    fn fold_atom(&mut self, node: swc_atoms::Atom) -> swc_atoms::Atom {
        Fold::fold_atom(&mut **self, node)
    }

    fn fold_auto_accessor(&mut self, node: AutoAccessor) -> AutoAccessor {
        Fold::fold_auto_accessor(&mut **self, node)
    }

    fn fold_await_expr(&mut self, node: AwaitExpr) -> AwaitExpr {
        Fold::fold_await_expr(&mut **self, node)
    }

    fn fold_big_int(&mut self, node: BigInt) -> BigInt {
        Fold::fold_big_int(&mut **self, node)
    }

    fn fold_big_int_value(&mut self, node: BigIntValue) -> BigIntValue {
        Fold::fold_big_int_value(&mut **self, node)
    }

    fn fold_bin_expr(&mut self, node: BinExpr) -> BinExpr {
        Fold::fold_bin_expr(&mut **self, node)
    }

    fn fold_binary_op(&mut self, node: BinaryOp) -> BinaryOp {
        Fold::fold_binary_op(&mut **self, node)
    }

    fn fold_binding_ident(&mut self, node: BindingIdent) -> BindingIdent {
        Fold::fold_binding_ident(&mut **self, node)
    }

    fn fold_block_stmt(&mut self, node: BlockStmt) -> BlockStmt {
        Fold::fold_block_stmt(&mut **self, node)
    }

    fn fold_block_stmt_or_expr(&mut self, node: BlockStmtOrExpr) -> BlockStmtOrExpr {
        Fold::fold_block_stmt_or_expr(&mut **self, node)
    }

    fn fold_bool(&mut self, node: Bool) -> Bool {
        Fold::fold_bool(&mut **self, node)
    }

    fn fold_break_stmt(&mut self, node: BreakStmt) -> BreakStmt {
        Fold::fold_break_stmt(&mut **self, node)
    }

    fn fold_call_expr(&mut self, node: CallExpr) -> CallExpr {
        Fold::fold_call_expr(&mut **self, node)
    }

    fn fold_callee(&mut self, node: Callee) -> Callee {
        Fold::fold_callee(&mut **self, node)
    }

    fn fold_catch_clause(&mut self, node: CatchClause) -> CatchClause {
        Fold::fold_catch_clause(&mut **self, node)
    }

    fn fold_class(&mut self, node: Class) -> Class {
        Fold::fold_class(&mut **self, node)
    }

    fn fold_class_decl(&mut self, node: ClassDecl) -> ClassDecl {
        Fold::fold_class_decl(&mut **self, node)
    }

    fn fold_class_expr(&mut self, node: ClassExpr) -> ClassExpr {
        Fold::fold_class_expr(&mut **self, node)
    }

    fn fold_class_member(&mut self, node: ClassMember) -> ClassMember {
        Fold::fold_class_member(&mut **self, node)
    }

    fn fold_class_members(&mut self, node: Vec<ClassMember>) -> Vec<ClassMember> {
        Fold::fold_class_members(&mut **self, node)
    }

    fn fold_class_method(&mut self, node: ClassMethod) -> ClassMethod {
        Fold::fold_class_method(&mut **self, node)
    }

    fn fold_class_prop(&mut self, node: ClassProp) -> ClassProp {
        Fold::fold_class_prop(&mut **self, node)
    }

    fn fold_computed_prop_name(&mut self, node: ComputedPropName) -> ComputedPropName {
        Fold::fold_computed_prop_name(&mut **self, node)
    }

    fn fold_cond_expr(&mut self, node: CondExpr) -> CondExpr {
        Fold::fold_cond_expr(&mut **self, node)
    }

    fn fold_constructor(&mut self, node: Constructor) -> Constructor {
        Fold::fold_constructor(&mut **self, node)
    }

    fn fold_continue_stmt(&mut self, node: ContinueStmt) -> ContinueStmt {
        Fold::fold_continue_stmt(&mut **self, node)
    }

    fn fold_debugger_stmt(&mut self, node: DebuggerStmt) -> DebuggerStmt {
        Fold::fold_debugger_stmt(&mut **self, node)
    }

    fn fold_decl(&mut self, node: Decl) -> Decl {
        Fold::fold_decl(&mut **self, node)
    }

    fn fold_decorator(&mut self, node: Decorator) -> Decorator {
        Fold::fold_decorator(&mut **self, node)
    }

    fn fold_decorators(&mut self, node: Vec<Decorator>) -> Vec<Decorator> {
        Fold::fold_decorators(&mut **self, node)
    }

    fn fold_default_decl(&mut self, node: DefaultDecl) -> DefaultDecl {
        Fold::fold_default_decl(&mut **self, node)
    }

    fn fold_do_while_stmt(&mut self, node: DoWhileStmt) -> DoWhileStmt {
        Fold::fold_do_while_stmt(&mut **self, node)
    }

    fn fold_empty_stmt(&mut self, node: EmptyStmt) -> EmptyStmt {
        Fold::fold_empty_stmt(&mut **self, node)
    }

    fn fold_es_version(&mut self, node: EsVersion) -> EsVersion {
        Fold::fold_es_version(&mut **self, node)
    }

    fn fold_export_all(&mut self, node: ExportAll) -> ExportAll {
        Fold::fold_export_all(&mut **self, node)
    }

    fn fold_export_decl(&mut self, node: ExportDecl) -> ExportDecl {
        Fold::fold_export_decl(&mut **self, node)
    }

    fn fold_export_default_decl(&mut self, node: ExportDefaultDecl) -> ExportDefaultDecl {
        Fold::fold_export_default_decl(&mut **self, node)
    }

    fn fold_export_default_expr(&mut self, node: ExportDefaultExpr) -> ExportDefaultExpr {
        Fold::fold_export_default_expr(&mut **self, node)
    }

    fn fold_export_default_specifier(
        &mut self,
        node: ExportDefaultSpecifier,
    ) -> ExportDefaultSpecifier {
        Fold::fold_export_default_specifier(&mut **self, node)
    }

    fn fold_export_named_specifier(&mut self, node: ExportNamedSpecifier) -> ExportNamedSpecifier {
        Fold::fold_export_named_specifier(&mut **self, node)
    }

    fn fold_export_namespace_specifier(
        &mut self,
        node: ExportNamespaceSpecifier,
    ) -> ExportNamespaceSpecifier {
        Fold::fold_export_namespace_specifier(&mut **self, node)
    }

    fn fold_export_specifier(&mut self, node: ExportSpecifier) -> ExportSpecifier {
        Fold::fold_export_specifier(&mut **self, node)
    }

    fn fold_export_specifiers(&mut self, node: Vec<ExportSpecifier>) -> Vec<ExportSpecifier> {
        Fold::fold_export_specifiers(&mut **self, node)
    }

    fn fold_expr(&mut self, node: Expr) -> Expr {
        Fold::fold_expr(&mut **self, node)
    }

    fn fold_expr_or_spread(&mut self, node: ExprOrSpread) -> ExprOrSpread {
        Fold::fold_expr_or_spread(&mut **self, node)
    }

    fn fold_expr_or_spreads(&mut self, node: Vec<ExprOrSpread>) -> Vec<ExprOrSpread> {
        Fold::fold_expr_or_spreads(&mut **self, node)
    }

    fn fold_expr_stmt(&mut self, node: ExprStmt) -> ExprStmt {
        Fold::fold_expr_stmt(&mut **self, node)
    }

    fn fold_exprs(&mut self, node: Vec<Box<Expr>>) -> Vec<Box<Expr>> {
        Fold::fold_exprs(&mut **self, node)
    }

    fn fold_fn_decl(&mut self, node: FnDecl) -> FnDecl {
        Fold::fold_fn_decl(&mut **self, node)
    }

    fn fold_fn_expr(&mut self, node: FnExpr) -> FnExpr {
        Fold::fold_fn_expr(&mut **self, node)
    }

    fn fold_for_head(&mut self, node: ForHead) -> ForHead {
        Fold::fold_for_head(&mut **self, node)
    }

    fn fold_for_in_stmt(&mut self, node: ForInStmt) -> ForInStmt {
        Fold::fold_for_in_stmt(&mut **self, node)
    }

    fn fold_for_of_stmt(&mut self, node: ForOfStmt) -> ForOfStmt {
        Fold::fold_for_of_stmt(&mut **self, node)
    }

    fn fold_for_stmt(&mut self, node: ForStmt) -> ForStmt {
        Fold::fold_for_stmt(&mut **self, node)
    }

    fn fold_function(&mut self, node: Function) -> Function {
        Fold::fold_function(&mut **self, node)
    }

    fn fold_getter_prop(&mut self, node: GetterProp) -> GetterProp {
        Fold::fold_getter_prop(&mut **self, node)
    }

    fn fold_ident(&mut self, node: Ident) -> Ident {
        Fold::fold_ident(&mut **self, node)
    }

    fn fold_ident_name(&mut self, node: IdentName) -> IdentName {
        Fold::fold_ident_name(&mut **self, node)
    }

    fn fold_if_stmt(&mut self, node: IfStmt) -> IfStmt {
        Fold::fold_if_stmt(&mut **self, node)
    }

    fn fold_import(&mut self, node: Import) -> Import {
        Fold::fold_import(&mut **self, node)
    }

    fn fold_import_decl(&mut self, node: ImportDecl) -> ImportDecl {
        Fold::fold_import_decl(&mut **self, node)
    }

    fn fold_import_default_specifier(
        &mut self,
        node: ImportDefaultSpecifier,
    ) -> ImportDefaultSpecifier {
        Fold::fold_import_default_specifier(&mut **self, node)
    }

    fn fold_import_named_specifier(&mut self, node: ImportNamedSpecifier) -> ImportNamedSpecifier {
        Fold::fold_import_named_specifier(&mut **self, node)
    }

    fn fold_import_phase(&mut self, node: ImportPhase) -> ImportPhase {
        Fold::fold_import_phase(&mut **self, node)
    }

    fn fold_import_specifier(&mut self, node: ImportSpecifier) -> ImportSpecifier {
        Fold::fold_import_specifier(&mut **self, node)
    }

    fn fold_import_specifiers(&mut self, node: Vec<ImportSpecifier>) -> Vec<ImportSpecifier> {
        Fold::fold_import_specifiers(&mut **self, node)
    }

    fn fold_import_star_as_specifier(
        &mut self,
        node: ImportStarAsSpecifier,
    ) -> ImportStarAsSpecifier {
        Fold::fold_import_star_as_specifier(&mut **self, node)
    }

    fn fold_import_with(&mut self, node: ImportWith) -> ImportWith {
        Fold::fold_import_with(&mut **self, node)
    }

    fn fold_import_with_item(&mut self, node: ImportWithItem) -> ImportWithItem {
        Fold::fold_import_with_item(&mut **self, node)
    }

    fn fold_import_with_items(&mut self, node: Vec<ImportWithItem>) -> Vec<ImportWithItem> {
        Fold::fold_import_with_items(&mut **self, node)
    }

    fn fold_invalid(&mut self, node: Invalid) -> Invalid {
        Fold::fold_invalid(&mut **self, node)
    }

    fn fold_jsx_attr(&mut self, node: JSXAttr) -> JSXAttr {
        Fold::fold_jsx_attr(&mut **self, node)
    }

    fn fold_jsx_attr_name(&mut self, node: JSXAttrName) -> JSXAttrName {
        Fold::fold_jsx_attr_name(&mut **self, node)
    }

    fn fold_jsx_attr_or_spread(&mut self, node: JSXAttrOrSpread) -> JSXAttrOrSpread {
        Fold::fold_jsx_attr_or_spread(&mut **self, node)
    }

    fn fold_jsx_attr_or_spreads(&mut self, node: Vec<JSXAttrOrSpread>) -> Vec<JSXAttrOrSpread> {
        Fold::fold_jsx_attr_or_spreads(&mut **self, node)
    }

    fn fold_jsx_attr_value(&mut self, node: JSXAttrValue) -> JSXAttrValue {
        Fold::fold_jsx_attr_value(&mut **self, node)
    }

    fn fold_jsx_closing_element(&mut self, node: JSXClosingElement) -> JSXClosingElement {
        Fold::fold_jsx_closing_element(&mut **self, node)
    }

    fn fold_jsx_closing_fragment(&mut self, node: JSXClosingFragment) -> JSXClosingFragment {
        Fold::fold_jsx_closing_fragment(&mut **self, node)
    }

    fn fold_jsx_element(&mut self, node: JSXElement) -> JSXElement {
        Fold::fold_jsx_element(&mut **self, node)
    }

    fn fold_jsx_element_child(&mut self, node: JSXElementChild) -> JSXElementChild {
        Fold::fold_jsx_element_child(&mut **self, node)
    }

    fn fold_jsx_element_childs(&mut self, node: Vec<JSXElementChild>) -> Vec<JSXElementChild> {
        Fold::fold_jsx_element_childs(&mut **self, node)
    }

    fn fold_jsx_element_name(&mut self, node: JSXElementName) -> JSXElementName {
        Fold::fold_jsx_element_name(&mut **self, node)
    }

    fn fold_jsx_empty_expr(&mut self, node: JSXEmptyExpr) -> JSXEmptyExpr {
        Fold::fold_jsx_empty_expr(&mut **self, node)
    }

    fn fold_jsx_expr(&mut self, node: JSXExpr) -> JSXExpr {
        Fold::fold_jsx_expr(&mut **self, node)
    }

    fn fold_jsx_expr_container(&mut self, node: JSXExprContainer) -> JSXExprContainer {
        Fold::fold_jsx_expr_container(&mut **self, node)
    }

    fn fold_jsx_fragment(&mut self, node: JSXFragment) -> JSXFragment {
        Fold::fold_jsx_fragment(&mut **self, node)
    }

    fn fold_jsx_member_expr(&mut self, node: JSXMemberExpr) -> JSXMemberExpr {
        Fold::fold_jsx_member_expr(&mut **self, node)
    }

    fn fold_jsx_namespaced_name(&mut self, node: JSXNamespacedName) -> JSXNamespacedName {
        Fold::fold_jsx_namespaced_name(&mut **self, node)
    }

    fn fold_jsx_object(&mut self, node: JSXObject) -> JSXObject {
        Fold::fold_jsx_object(&mut **self, node)
    }

    fn fold_jsx_opening_element(&mut self, node: JSXOpeningElement) -> JSXOpeningElement {
        Fold::fold_jsx_opening_element(&mut **self, node)
    }

    fn fold_jsx_opening_fragment(&mut self, node: JSXOpeningFragment) -> JSXOpeningFragment {
        Fold::fold_jsx_opening_fragment(&mut **self, node)
    }

    fn fold_jsx_spread_child(&mut self, node: JSXSpreadChild) -> JSXSpreadChild {
        Fold::fold_jsx_spread_child(&mut **self, node)
    }

    fn fold_jsx_text(&mut self, node: JSXText) -> JSXText {
        Fold::fold_jsx_text(&mut **self, node)
    }

    fn fold_key(&mut self, node: Key) -> Key {
        Fold::fold_key(&mut **self, node)
    }

    fn fold_key_value_pat_prop(&mut self, node: KeyValuePatProp) -> KeyValuePatProp {
        Fold::fold_key_value_pat_prop(&mut **self, node)
    }

    fn fold_key_value_prop(&mut self, node: KeyValueProp) -> KeyValueProp {
        Fold::fold_key_value_prop(&mut **self, node)
    }

    fn fold_labeled_stmt(&mut self, node: LabeledStmt) -> LabeledStmt {
        Fold::fold_labeled_stmt(&mut **self, node)
    }

    fn fold_lit(&mut self, node: Lit) -> Lit {
        Fold::fold_lit(&mut **self, node)
    }

    fn fold_member_expr(&mut self, node: MemberExpr) -> MemberExpr {
        Fold::fold_member_expr(&mut **self, node)
    }

    fn fold_member_prop(&mut self, node: MemberProp) -> MemberProp {
        Fold::fold_member_prop(&mut **self, node)
    }

    fn fold_meta_prop_expr(&mut self, node: MetaPropExpr) -> MetaPropExpr {
        Fold::fold_meta_prop_expr(&mut **self, node)
    }

    fn fold_meta_prop_kind(&mut self, node: MetaPropKind) -> MetaPropKind {
        Fold::fold_meta_prop_kind(&mut **self, node)
    }

    fn fold_method_kind(&mut self, node: MethodKind) -> MethodKind {
        Fold::fold_method_kind(&mut **self, node)
    }

    fn fold_method_prop(&mut self, node: MethodProp) -> MethodProp {
        Fold::fold_method_prop(&mut **self, node)
    }

    fn fold_module(&mut self, node: Module) -> Module {
        Fold::fold_module(&mut **self, node)
    }

    fn fold_module_decl(&mut self, node: ModuleDecl) -> ModuleDecl {
        Fold::fold_module_decl(&mut **self, node)
    }

    fn fold_module_export_name(&mut self, node: ModuleExportName) -> ModuleExportName {
        Fold::fold_module_export_name(&mut **self, node)
    }

    fn fold_module_item(&mut self, node: ModuleItem) -> ModuleItem {
        Fold::fold_module_item(&mut **self, node)
    }

    fn fold_module_items(&mut self, node: Vec<ModuleItem>) -> Vec<ModuleItem> {
        Fold::fold_module_items(&mut **self, node)
    }

    fn fold_named_export(&mut self, node: NamedExport) -> NamedExport {
        Fold::fold_named_export(&mut **self, node)
    }

    fn fold_new_expr(&mut self, node: NewExpr) -> NewExpr {
        Fold::fold_new_expr(&mut **self, node)
    }

    fn fold_null(&mut self, node: Null) -> Null {
        Fold::fold_null(&mut **self, node)
    }

    fn fold_number(&mut self, node: Number) -> Number {
        Fold::fold_number(&mut **self, node)
    }

    fn fold_object_lit(&mut self, node: ObjectLit) -> ObjectLit {
        Fold::fold_object_lit(&mut **self, node)
    }

    fn fold_object_pat(&mut self, node: ObjectPat) -> ObjectPat {
        Fold::fold_object_pat(&mut **self, node)
    }

    fn fold_object_pat_prop(&mut self, node: ObjectPatProp) -> ObjectPatProp {
        Fold::fold_object_pat_prop(&mut **self, node)
    }

    fn fold_object_pat_props(&mut self, node: Vec<ObjectPatProp>) -> Vec<ObjectPatProp> {
        Fold::fold_object_pat_props(&mut **self, node)
    }

    fn fold_opt_accessibility(&mut self, node: Option<Accessibility>) -> Option<Accessibility> {
        Fold::fold_opt_accessibility(&mut **self, node)
    }

    fn fold_opt_atom(&mut self, node: Option<swc_atoms::Atom>) -> Option<swc_atoms::Atom> {
        Fold::fold_opt_atom(&mut **self, node)
    }

    fn fold_opt_block_stmt(&mut self, node: Option<BlockStmt>) -> Option<BlockStmt> {
        Fold::fold_opt_block_stmt(&mut **self, node)
    }

    fn fold_opt_call(&mut self, node: OptCall) -> OptCall {
        Fold::fold_opt_call(&mut **self, node)
    }

    fn fold_opt_catch_clause(&mut self, node: Option<CatchClause>) -> Option<CatchClause> {
        Fold::fold_opt_catch_clause(&mut **self, node)
    }

    fn fold_opt_chain_base(&mut self, node: OptChainBase) -> OptChainBase {
        Fold::fold_opt_chain_base(&mut **self, node)
    }

    fn fold_opt_chain_expr(&mut self, node: OptChainExpr) -> OptChainExpr {
        Fold::fold_opt_chain_expr(&mut **self, node)
    }

    fn fold_opt_expr(&mut self, node: Option<Box<Expr>>) -> Option<Box<Expr>> {
        Fold::fold_opt_expr(&mut **self, node)
    }

    fn fold_opt_expr_or_spread(&mut self, node: Option<ExprOrSpread>) -> Option<ExprOrSpread> {
        Fold::fold_opt_expr_or_spread(&mut **self, node)
    }

    fn fold_opt_expr_or_spreads(
        &mut self,
        node: Option<Vec<ExprOrSpread>>,
    ) -> Option<Vec<ExprOrSpread>> {
        Fold::fold_opt_expr_or_spreads(&mut **self, node)
    }

    fn fold_opt_ident(&mut self, node: Option<Ident>) -> Option<Ident> {
        Fold::fold_opt_ident(&mut **self, node)
    }

    fn fold_opt_jsx_attr_value(&mut self, node: Option<JSXAttrValue>) -> Option<JSXAttrValue> {
        Fold::fold_opt_jsx_attr_value(&mut **self, node)
    }

    fn fold_opt_jsx_closing_element(
        &mut self,
        node: Option<JSXClosingElement>,
    ) -> Option<JSXClosingElement> {
        Fold::fold_opt_jsx_closing_element(&mut **self, node)
    }

    fn fold_opt_module_export_name(
        &mut self,
        node: Option<ModuleExportName>,
    ) -> Option<ModuleExportName> {
        Fold::fold_opt_module_export_name(&mut **self, node)
    }

    fn fold_opt_module_items(&mut self, node: Option<Vec<ModuleItem>>) -> Option<Vec<ModuleItem>> {
        Fold::fold_opt_module_items(&mut **self, node)
    }

    fn fold_opt_object_lit(&mut self, node: Option<Box<ObjectLit>>) -> Option<Box<ObjectLit>> {
        Fold::fold_opt_object_lit(&mut **self, node)
    }

    fn fold_opt_pat(&mut self, node: Option<Pat>) -> Option<Pat> {
        Fold::fold_opt_pat(&mut **self, node)
    }

    fn fold_opt_span(&mut self, node: Option<swc_common::Span>) -> Option<swc_common::Span> {
        Fold::fold_opt_span(&mut **self, node)
    }

    fn fold_opt_stmt(&mut self, node: Option<Box<Stmt>>) -> Option<Box<Stmt>> {
        Fold::fold_opt_stmt(&mut **self, node)
    }

    fn fold_opt_str(&mut self, node: Option<Box<Str>>) -> Option<Box<Str>> {
        Fold::fold_opt_str(&mut **self, node)
    }

    fn fold_opt_true_plus_minus(&mut self, node: Option<TruePlusMinus>) -> Option<TruePlusMinus> {
        Fold::fold_opt_true_plus_minus(&mut **self, node)
    }

    fn fold_opt_ts_entity_name(&mut self, node: Option<TsEntityName>) -> Option<TsEntityName> {
        Fold::fold_opt_ts_entity_name(&mut **self, node)
    }

    fn fold_opt_ts_namespace_body(
        &mut self,
        node: Option<TsNamespaceBody>,
    ) -> Option<TsNamespaceBody> {
        Fold::fold_opt_ts_namespace_body(&mut **self, node)
    }

    fn fold_opt_ts_type(&mut self, node: Option<Box<TsType>>) -> Option<Box<TsType>> {
        Fold::fold_opt_ts_type(&mut **self, node)
    }

    fn fold_opt_ts_type_ann(&mut self, node: Option<Box<TsTypeAnn>>) -> Option<Box<TsTypeAnn>> {
        Fold::fold_opt_ts_type_ann(&mut **self, node)
    }

    fn fold_opt_ts_type_param_decl(
        &mut self,
        node: Option<Box<TsTypeParamDecl>>,
    ) -> Option<Box<TsTypeParamDecl>> {
        Fold::fold_opt_ts_type_param_decl(&mut **self, node)
    }

    fn fold_opt_ts_type_param_instantiation(
        &mut self,
        node: Option<Box<TsTypeParamInstantiation>>,
    ) -> Option<Box<TsTypeParamInstantiation>> {
        Fold::fold_opt_ts_type_param_instantiation(&mut **self, node)
    }

    fn fold_opt_var_decl_or_expr(&mut self, node: Option<VarDeclOrExpr>) -> Option<VarDeclOrExpr> {
        Fold::fold_opt_var_decl_or_expr(&mut **self, node)
    }

    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        node: Vec<Option<ExprOrSpread>>,
    ) -> Vec<Option<ExprOrSpread>> {
        Fold::fold_opt_vec_expr_or_spreads(&mut **self, node)
    }

    fn fold_opt_vec_pats(&mut self, node: Vec<Option<Pat>>) -> Vec<Option<Pat>> {
        Fold::fold_opt_vec_pats(&mut **self, node)
    }

    fn fold_param(&mut self, node: Param) -> Param {
        Fold::fold_param(&mut **self, node)
    }

    fn fold_param_or_ts_param_prop(&mut self, node: ParamOrTsParamProp) -> ParamOrTsParamProp {
        Fold::fold_param_or_ts_param_prop(&mut **self, node)
    }

    fn fold_param_or_ts_param_props(
        &mut self,
        node: Vec<ParamOrTsParamProp>,
    ) -> Vec<ParamOrTsParamProp> {
        Fold::fold_param_or_ts_param_props(&mut **self, node)
    }

    fn fold_params(&mut self, node: Vec<Param>) -> Vec<Param> {
        Fold::fold_params(&mut **self, node)
    }

    fn fold_paren_expr(&mut self, node: ParenExpr) -> ParenExpr {
        Fold::fold_paren_expr(&mut **self, node)
    }

    fn fold_pat(&mut self, node: Pat) -> Pat {
        Fold::fold_pat(&mut **self, node)
    }

    fn fold_pats(&mut self, node: Vec<Pat>) -> Vec<Pat> {
        Fold::fold_pats(&mut **self, node)
    }

    fn fold_private_method(&mut self, node: PrivateMethod) -> PrivateMethod {
        Fold::fold_private_method(&mut **self, node)
    }

    fn fold_private_name(&mut self, node: PrivateName) -> PrivateName {
        Fold::fold_private_name(&mut **self, node)
    }

    fn fold_private_prop(&mut self, node: PrivateProp) -> PrivateProp {
        Fold::fold_private_prop(&mut **self, node)
    }

    fn fold_program(&mut self, node: Program) -> Program {
        Fold::fold_program(&mut **self, node)
    }

    fn fold_prop(&mut self, node: Prop) -> Prop {
        Fold::fold_prop(&mut **self, node)
    }

    fn fold_prop_name(&mut self, node: PropName) -> PropName {
        Fold::fold_prop_name(&mut **self, node)
    }

    fn fold_prop_or_spread(&mut self, node: PropOrSpread) -> PropOrSpread {
        Fold::fold_prop_or_spread(&mut **self, node)
    }

    fn fold_prop_or_spreads(&mut self, node: Vec<PropOrSpread>) -> Vec<PropOrSpread> {
        Fold::fold_prop_or_spreads(&mut **self, node)
    }

    fn fold_regex(&mut self, node: Regex) -> Regex {
        Fold::fold_regex(&mut **self, node)
    }

    fn fold_reserved_unused(&mut self, node: ReservedUnused) -> ReservedUnused {
        Fold::fold_reserved_unused(&mut **self, node)
    }

    fn fold_rest_pat(&mut self, node: RestPat) -> RestPat {
        Fold::fold_rest_pat(&mut **self, node)
    }

    fn fold_return_stmt(&mut self, node: ReturnStmt) -> ReturnStmt {
        Fold::fold_return_stmt(&mut **self, node)
    }

    fn fold_script(&mut self, node: Script) -> Script {
        Fold::fold_script(&mut **self, node)
    }

    fn fold_seq_expr(&mut self, node: SeqExpr) -> SeqExpr {
        Fold::fold_seq_expr(&mut **self, node)
    }

    fn fold_setter_prop(&mut self, node: SetterProp) -> SetterProp {
        Fold::fold_setter_prop(&mut **self, node)
    }

    fn fold_simple_assign_target(&mut self, node: SimpleAssignTarget) -> SimpleAssignTarget {
        Fold::fold_simple_assign_target(&mut **self, node)
    }

    fn fold_span(&mut self, node: swc_common::Span) -> swc_common::Span {
        Fold::fold_span(&mut **self, node)
    }

    fn fold_spread_element(&mut self, node: SpreadElement) -> SpreadElement {
        Fold::fold_spread_element(&mut **self, node)
    }

    fn fold_static_block(&mut self, node: StaticBlock) -> StaticBlock {
        Fold::fold_static_block(&mut **self, node)
    }

    fn fold_stmt(&mut self, node: Stmt) -> Stmt {
        Fold::fold_stmt(&mut **self, node)
    }

    fn fold_stmts(&mut self, node: Vec<Stmt>) -> Vec<Stmt> {
        Fold::fold_stmts(&mut **self, node)
    }

    fn fold_str(&mut self, node: Str) -> Str {
        Fold::fold_str(&mut **self, node)
    }

    fn fold_super(&mut self, node: Super) -> Super {
        Fold::fold_super(&mut **self, node)
    }

    fn fold_super_prop(&mut self, node: SuperProp) -> SuperProp {
        Fold::fold_super_prop(&mut **self, node)
    }

    fn fold_super_prop_expr(&mut self, node: SuperPropExpr) -> SuperPropExpr {
        Fold::fold_super_prop_expr(&mut **self, node)
    }

    fn fold_switch_case(&mut self, node: SwitchCase) -> SwitchCase {
        Fold::fold_switch_case(&mut **self, node)
    }

    fn fold_switch_cases(&mut self, node: Vec<SwitchCase>) -> Vec<SwitchCase> {
        Fold::fold_switch_cases(&mut **self, node)
    }

    fn fold_switch_stmt(&mut self, node: SwitchStmt) -> SwitchStmt {
        Fold::fold_switch_stmt(&mut **self, node)
    }

    fn fold_syntax_context(
        &mut self,
        node: swc_common::SyntaxContext,
    ) -> swc_common::SyntaxContext {
        Fold::fold_syntax_context(&mut **self, node)
    }

    fn fold_tagged_tpl(&mut self, node: TaggedTpl) -> TaggedTpl {
        Fold::fold_tagged_tpl(&mut **self, node)
    }

    fn fold_this_expr(&mut self, node: ThisExpr) -> ThisExpr {
        Fold::fold_this_expr(&mut **self, node)
    }

    fn fold_throw_stmt(&mut self, node: ThrowStmt) -> ThrowStmt {
        Fold::fold_throw_stmt(&mut **self, node)
    }

    fn fold_tpl(&mut self, node: Tpl) -> Tpl {
        Fold::fold_tpl(&mut **self, node)
    }

    fn fold_tpl_element(&mut self, node: TplElement) -> TplElement {
        Fold::fold_tpl_element(&mut **self, node)
    }

    fn fold_tpl_elements(&mut self, node: Vec<TplElement>) -> Vec<TplElement> {
        Fold::fold_tpl_elements(&mut **self, node)
    }

    fn fold_true_plus_minus(&mut self, node: TruePlusMinus) -> TruePlusMinus {
        Fold::fold_true_plus_minus(&mut **self, node)
    }

    fn fold_try_stmt(&mut self, node: TryStmt) -> TryStmt {
        Fold::fold_try_stmt(&mut **self, node)
    }

    fn fold_ts_array_type(&mut self, node: TsArrayType) -> TsArrayType {
        Fold::fold_ts_array_type(&mut **self, node)
    }

    fn fold_ts_as_expr(&mut self, node: TsAsExpr) -> TsAsExpr {
        Fold::fold_ts_as_expr(&mut **self, node)
    }

    fn fold_ts_call_signature_decl(&mut self, node: TsCallSignatureDecl) -> TsCallSignatureDecl {
        Fold::fold_ts_call_signature_decl(&mut **self, node)
    }

    fn fold_ts_conditional_type(&mut self, node: TsConditionalType) -> TsConditionalType {
        Fold::fold_ts_conditional_type(&mut **self, node)
    }

    fn fold_ts_const_assertion(&mut self, node: TsConstAssertion) -> TsConstAssertion {
        Fold::fold_ts_const_assertion(&mut **self, node)
    }

    fn fold_ts_construct_signature_decl(
        &mut self,
        node: TsConstructSignatureDecl,
    ) -> TsConstructSignatureDecl {
        Fold::fold_ts_construct_signature_decl(&mut **self, node)
    }

    fn fold_ts_constructor_type(&mut self, node: TsConstructorType) -> TsConstructorType {
        Fold::fold_ts_constructor_type(&mut **self, node)
    }

    fn fold_ts_entity_name(&mut self, node: TsEntityName) -> TsEntityName {
        Fold::fold_ts_entity_name(&mut **self, node)
    }

    fn fold_ts_enum_decl(&mut self, node: TsEnumDecl) -> TsEnumDecl {
        Fold::fold_ts_enum_decl(&mut **self, node)
    }

    fn fold_ts_enum_member(&mut self, node: TsEnumMember) -> TsEnumMember {
        Fold::fold_ts_enum_member(&mut **self, node)
    }

    fn fold_ts_enum_member_id(&mut self, node: TsEnumMemberId) -> TsEnumMemberId {
        Fold::fold_ts_enum_member_id(&mut **self, node)
    }

    fn fold_ts_enum_members(&mut self, node: Vec<TsEnumMember>) -> Vec<TsEnumMember> {
        Fold::fold_ts_enum_members(&mut **self, node)
    }

    fn fold_ts_export_assignment(&mut self, node: TsExportAssignment) -> TsExportAssignment {
        Fold::fold_ts_export_assignment(&mut **self, node)
    }

    fn fold_ts_expr_with_type_args(&mut self, node: TsExprWithTypeArgs) -> TsExprWithTypeArgs {
        Fold::fold_ts_expr_with_type_args(&mut **self, node)
    }

    fn fold_ts_expr_with_type_argss(
        &mut self,
        node: Vec<TsExprWithTypeArgs>,
    ) -> Vec<TsExprWithTypeArgs> {
        Fold::fold_ts_expr_with_type_argss(&mut **self, node)
    }

    fn fold_ts_external_module_ref(&mut self, node: TsExternalModuleRef) -> TsExternalModuleRef {
        Fold::fold_ts_external_module_ref(&mut **self, node)
    }

    fn fold_ts_fn_or_constructor_type(
        &mut self,
        node: TsFnOrConstructorType,
    ) -> TsFnOrConstructorType {
        Fold::fold_ts_fn_or_constructor_type(&mut **self, node)
    }

    fn fold_ts_fn_param(&mut self, node: TsFnParam) -> TsFnParam {
        Fold::fold_ts_fn_param(&mut **self, node)
    }

    fn fold_ts_fn_params(&mut self, node: Vec<TsFnParam>) -> Vec<TsFnParam> {
        Fold::fold_ts_fn_params(&mut **self, node)
    }

    fn fold_ts_fn_type(&mut self, node: TsFnType) -> TsFnType {
        Fold::fold_ts_fn_type(&mut **self, node)
    }

    fn fold_ts_getter_signature(&mut self, node: TsGetterSignature) -> TsGetterSignature {
        Fold::fold_ts_getter_signature(&mut **self, node)
    }

    fn fold_ts_import_equals_decl(&mut self, node: TsImportEqualsDecl) -> TsImportEqualsDecl {
        Fold::fold_ts_import_equals_decl(&mut **self, node)
    }

    fn fold_ts_import_type(&mut self, node: TsImportType) -> TsImportType {
        Fold::fold_ts_import_type(&mut **self, node)
    }

    fn fold_ts_index_signature(&mut self, node: TsIndexSignature) -> TsIndexSignature {
        Fold::fold_ts_index_signature(&mut **self, node)
    }

    fn fold_ts_indexed_access_type(&mut self, node: TsIndexedAccessType) -> TsIndexedAccessType {
        Fold::fold_ts_indexed_access_type(&mut **self, node)
    }

    fn fold_ts_infer_type(&mut self, node: TsInferType) -> TsInferType {
        Fold::fold_ts_infer_type(&mut **self, node)
    }

    fn fold_ts_instantiation(&mut self, node: TsInstantiation) -> TsInstantiation {
        Fold::fold_ts_instantiation(&mut **self, node)
    }

    fn fold_ts_interface_body(&mut self, node: TsInterfaceBody) -> TsInterfaceBody {
        Fold::fold_ts_interface_body(&mut **self, node)
    }

    fn fold_ts_interface_decl(&mut self, node: TsInterfaceDecl) -> TsInterfaceDecl {
        Fold::fold_ts_interface_decl(&mut **self, node)
    }

    fn fold_ts_intersection_type(&mut self, node: TsIntersectionType) -> TsIntersectionType {
        Fold::fold_ts_intersection_type(&mut **self, node)
    }

    fn fold_ts_keyword_type(&mut self, node: TsKeywordType) -> TsKeywordType {
        Fold::fold_ts_keyword_type(&mut **self, node)
    }

    fn fold_ts_keyword_type_kind(&mut self, node: TsKeywordTypeKind) -> TsKeywordTypeKind {
        Fold::fold_ts_keyword_type_kind(&mut **self, node)
    }

    fn fold_ts_lit(&mut self, node: TsLit) -> TsLit {
        Fold::fold_ts_lit(&mut **self, node)
    }

    fn fold_ts_lit_type(&mut self, node: TsLitType) -> TsLitType {
        Fold::fold_ts_lit_type(&mut **self, node)
    }

    fn fold_ts_mapped_type(&mut self, node: TsMappedType) -> TsMappedType {
        Fold::fold_ts_mapped_type(&mut **self, node)
    }

    fn fold_ts_method_signature(&mut self, node: TsMethodSignature) -> TsMethodSignature {
        Fold::fold_ts_method_signature(&mut **self, node)
    }

    fn fold_ts_module_block(&mut self, node: TsModuleBlock) -> TsModuleBlock {
        Fold::fold_ts_module_block(&mut **self, node)
    }

    fn fold_ts_module_decl(&mut self, node: TsModuleDecl) -> TsModuleDecl {
        Fold::fold_ts_module_decl(&mut **self, node)
    }

    fn fold_ts_module_name(&mut self, node: TsModuleName) -> TsModuleName {
        Fold::fold_ts_module_name(&mut **self, node)
    }

    fn fold_ts_module_ref(&mut self, node: TsModuleRef) -> TsModuleRef {
        Fold::fold_ts_module_ref(&mut **self, node)
    }

    fn fold_ts_namespace_body(&mut self, node: TsNamespaceBody) -> TsNamespaceBody {
        Fold::fold_ts_namespace_body(&mut **self, node)
    }

    fn fold_ts_namespace_decl(&mut self, node: TsNamespaceDecl) -> TsNamespaceDecl {
        Fold::fold_ts_namespace_decl(&mut **self, node)
    }

    fn fold_ts_namespace_export_decl(
        &mut self,
        node: TsNamespaceExportDecl,
    ) -> TsNamespaceExportDecl {
        Fold::fold_ts_namespace_export_decl(&mut **self, node)
    }

    fn fold_ts_non_null_expr(&mut self, node: TsNonNullExpr) -> TsNonNullExpr {
        Fold::fold_ts_non_null_expr(&mut **self, node)
    }

    fn fold_ts_optional_type(&mut self, node: TsOptionalType) -> TsOptionalType {
        Fold::fold_ts_optional_type(&mut **self, node)
    }

    fn fold_ts_param_prop(&mut self, node: TsParamProp) -> TsParamProp {
        Fold::fold_ts_param_prop(&mut **self, node)
    }

    fn fold_ts_param_prop_param(&mut self, node: TsParamPropParam) -> TsParamPropParam {
        Fold::fold_ts_param_prop_param(&mut **self, node)
    }

    fn fold_ts_parenthesized_type(&mut self, node: TsParenthesizedType) -> TsParenthesizedType {
        Fold::fold_ts_parenthesized_type(&mut **self, node)
    }

    fn fold_ts_property_signature(&mut self, node: TsPropertySignature) -> TsPropertySignature {
        Fold::fold_ts_property_signature(&mut **self, node)
    }

    fn fold_ts_qualified_name(&mut self, node: TsQualifiedName) -> TsQualifiedName {
        Fold::fold_ts_qualified_name(&mut **self, node)
    }

    fn fold_ts_rest_type(&mut self, node: TsRestType) -> TsRestType {
        Fold::fold_ts_rest_type(&mut **self, node)
    }

    fn fold_ts_satisfies_expr(&mut self, node: TsSatisfiesExpr) -> TsSatisfiesExpr {
        Fold::fold_ts_satisfies_expr(&mut **self, node)
    }

    fn fold_ts_setter_signature(&mut self, node: TsSetterSignature) -> TsSetterSignature {
        Fold::fold_ts_setter_signature(&mut **self, node)
    }

    fn fold_ts_this_type(&mut self, node: TsThisType) -> TsThisType {
        Fold::fold_ts_this_type(&mut **self, node)
    }

    fn fold_ts_this_type_or_ident(&mut self, node: TsThisTypeOrIdent) -> TsThisTypeOrIdent {
        Fold::fold_ts_this_type_or_ident(&mut **self, node)
    }

    fn fold_ts_tpl_lit_type(&mut self, node: TsTplLitType) -> TsTplLitType {
        Fold::fold_ts_tpl_lit_type(&mut **self, node)
    }

    fn fold_ts_tuple_element(&mut self, node: TsTupleElement) -> TsTupleElement {
        Fold::fold_ts_tuple_element(&mut **self, node)
    }

    fn fold_ts_tuple_elements(&mut self, node: Vec<TsTupleElement>) -> Vec<TsTupleElement> {
        Fold::fold_ts_tuple_elements(&mut **self, node)
    }

    fn fold_ts_tuple_type(&mut self, node: TsTupleType) -> TsTupleType {
        Fold::fold_ts_tuple_type(&mut **self, node)
    }

    fn fold_ts_type(&mut self, node: TsType) -> TsType {
        Fold::fold_ts_type(&mut **self, node)
    }

    fn fold_ts_type_alias_decl(&mut self, node: TsTypeAliasDecl) -> TsTypeAliasDecl {
        Fold::fold_ts_type_alias_decl(&mut **self, node)
    }

    fn fold_ts_type_ann(&mut self, node: TsTypeAnn) -> TsTypeAnn {
        Fold::fold_ts_type_ann(&mut **self, node)
    }

    fn fold_ts_type_assertion(&mut self, node: TsTypeAssertion) -> TsTypeAssertion {
        Fold::fold_ts_type_assertion(&mut **self, node)
    }

    fn fold_ts_type_element(&mut self, node: TsTypeElement) -> TsTypeElement {
        Fold::fold_ts_type_element(&mut **self, node)
    }

    fn fold_ts_type_elements(&mut self, node: Vec<TsTypeElement>) -> Vec<TsTypeElement> {
        Fold::fold_ts_type_elements(&mut **self, node)
    }

    fn fold_ts_type_lit(&mut self, node: TsTypeLit) -> TsTypeLit {
        Fold::fold_ts_type_lit(&mut **self, node)
    }

    fn fold_ts_type_operator(&mut self, node: TsTypeOperator) -> TsTypeOperator {
        Fold::fold_ts_type_operator(&mut **self, node)
    }

    fn fold_ts_type_operator_op(&mut self, node: TsTypeOperatorOp) -> TsTypeOperatorOp {
        Fold::fold_ts_type_operator_op(&mut **self, node)
    }

    fn fold_ts_type_param(&mut self, node: TsTypeParam) -> TsTypeParam {
        Fold::fold_ts_type_param(&mut **self, node)
    }

    fn fold_ts_type_param_decl(&mut self, node: TsTypeParamDecl) -> TsTypeParamDecl {
        Fold::fold_ts_type_param_decl(&mut **self, node)
    }

    fn fold_ts_type_param_instantiation(
        &mut self,
        node: TsTypeParamInstantiation,
    ) -> TsTypeParamInstantiation {
        Fold::fold_ts_type_param_instantiation(&mut **self, node)
    }

    fn fold_ts_type_params(&mut self, node: Vec<TsTypeParam>) -> Vec<TsTypeParam> {
        Fold::fold_ts_type_params(&mut **self, node)
    }

    fn fold_ts_type_predicate(&mut self, node: TsTypePredicate) -> TsTypePredicate {
        Fold::fold_ts_type_predicate(&mut **self, node)
    }

    fn fold_ts_type_query(&mut self, node: TsTypeQuery) -> TsTypeQuery {
        Fold::fold_ts_type_query(&mut **self, node)
    }

    fn fold_ts_type_query_expr(&mut self, node: TsTypeQueryExpr) -> TsTypeQueryExpr {
        Fold::fold_ts_type_query_expr(&mut **self, node)
    }

    fn fold_ts_type_ref(&mut self, node: TsTypeRef) -> TsTypeRef {
        Fold::fold_ts_type_ref(&mut **self, node)
    }

    fn fold_ts_types(&mut self, node: Vec<Box<TsType>>) -> Vec<Box<TsType>> {
        Fold::fold_ts_types(&mut **self, node)
    }

    fn fold_ts_union_or_intersection_type(
        &mut self,
        node: TsUnionOrIntersectionType,
    ) -> TsUnionOrIntersectionType {
        Fold::fold_ts_union_or_intersection_type(&mut **self, node)
    }

    fn fold_ts_union_type(&mut self, node: TsUnionType) -> TsUnionType {
        Fold::fold_ts_union_type(&mut **self, node)
    }

    fn fold_unary_expr(&mut self, node: UnaryExpr) -> UnaryExpr {
        Fold::fold_unary_expr(&mut **self, node)
    }

    fn fold_unary_op(&mut self, node: UnaryOp) -> UnaryOp {
        Fold::fold_unary_op(&mut **self, node)
    }

    fn fold_update_expr(&mut self, node: UpdateExpr) -> UpdateExpr {
        Fold::fold_update_expr(&mut **self, node)
    }

    fn fold_update_op(&mut self, node: UpdateOp) -> UpdateOp {
        Fold::fold_update_op(&mut **self, node)
    }

    fn fold_using_decl(&mut self, node: UsingDecl) -> UsingDecl {
        Fold::fold_using_decl(&mut **self, node)
    }

    fn fold_var_decl(&mut self, node: VarDecl) -> VarDecl {
        Fold::fold_var_decl(&mut **self, node)
    }

    fn fold_var_decl_kind(&mut self, node: VarDeclKind) -> VarDeclKind {
        Fold::fold_var_decl_kind(&mut **self, node)
    }

    fn fold_var_decl_or_expr(&mut self, node: VarDeclOrExpr) -> VarDeclOrExpr {
        Fold::fold_var_decl_or_expr(&mut **self, node)
    }

    fn fold_var_declarator(&mut self, node: VarDeclarator) -> VarDeclarator {
        Fold::fold_var_declarator(&mut **self, node)
    }

    fn fold_var_declarators(&mut self, node: Vec<VarDeclarator>) -> Vec<VarDeclarator> {
        Fold::fold_var_declarators(&mut **self, node)
    }

    fn fold_while_stmt(&mut self, node: WhileStmt) -> WhileStmt {
        Fold::fold_while_stmt(&mut **self, node)
    }

    fn fold_with_stmt(&mut self, node: WithStmt) -> WithStmt {
        Fold::fold_with_stmt(&mut **self, node)
    }

    fn fold_yield_expr(&mut self, node: YieldExpr) -> YieldExpr {
        Fold::fold_yield_expr(&mut **self, node)
    }
}
impl<V> Fold for Box<V>
where
    V: ?Sized + Fold,
{
    fn fold_accessibility(&mut self, node: Accessibility) -> Accessibility {
        Fold::fold_accessibility(&mut **self, node)
    }

    fn fold_array_lit(&mut self, node: ArrayLit) -> ArrayLit {
        Fold::fold_array_lit(&mut **self, node)
    }

    fn fold_array_pat(&mut self, node: ArrayPat) -> ArrayPat {
        Fold::fold_array_pat(&mut **self, node)
    }

    fn fold_arrow_expr(&mut self, node: ArrowExpr) -> ArrowExpr {
        Fold::fold_arrow_expr(&mut **self, node)
    }

    fn fold_assign_expr(&mut self, node: AssignExpr) -> AssignExpr {
        Fold::fold_assign_expr(&mut **self, node)
    }

    fn fold_assign_op(&mut self, node: AssignOp) -> AssignOp {
        Fold::fold_assign_op(&mut **self, node)
    }

    fn fold_assign_pat(&mut self, node: AssignPat) -> AssignPat {
        Fold::fold_assign_pat(&mut **self, node)
    }

    fn fold_assign_pat_prop(&mut self, node: AssignPatProp) -> AssignPatProp {
        Fold::fold_assign_pat_prop(&mut **self, node)
    }

    fn fold_assign_prop(&mut self, node: AssignProp) -> AssignProp {
        Fold::fold_assign_prop(&mut **self, node)
    }

    fn fold_assign_target(&mut self, node: AssignTarget) -> AssignTarget {
        Fold::fold_assign_target(&mut **self, node)
    }

    fn fold_assign_target_pat(&mut self, node: AssignTargetPat) -> AssignTargetPat {
        Fold::fold_assign_target_pat(&mut **self, node)
    }

    fn fold_atom(&mut self, node: swc_atoms::Atom) -> swc_atoms::Atom {
        Fold::fold_atom(&mut **self, node)
    }

    fn fold_auto_accessor(&mut self, node: AutoAccessor) -> AutoAccessor {
        Fold::fold_auto_accessor(&mut **self, node)
    }

    fn fold_await_expr(&mut self, node: AwaitExpr) -> AwaitExpr {
        Fold::fold_await_expr(&mut **self, node)
    }

    fn fold_big_int(&mut self, node: BigInt) -> BigInt {
        Fold::fold_big_int(&mut **self, node)
    }

    fn fold_big_int_value(&mut self, node: BigIntValue) -> BigIntValue {
        Fold::fold_big_int_value(&mut **self, node)
    }

    fn fold_bin_expr(&mut self, node: BinExpr) -> BinExpr {
        Fold::fold_bin_expr(&mut **self, node)
    }

    fn fold_binary_op(&mut self, node: BinaryOp) -> BinaryOp {
        Fold::fold_binary_op(&mut **self, node)
    }

    fn fold_binding_ident(&mut self, node: BindingIdent) -> BindingIdent {
        Fold::fold_binding_ident(&mut **self, node)
    }

    fn fold_block_stmt(&mut self, node: BlockStmt) -> BlockStmt {
        Fold::fold_block_stmt(&mut **self, node)
    }

    fn fold_block_stmt_or_expr(&mut self, node: BlockStmtOrExpr) -> BlockStmtOrExpr {
        Fold::fold_block_stmt_or_expr(&mut **self, node)
    }

    fn fold_bool(&mut self, node: Bool) -> Bool {
        Fold::fold_bool(&mut **self, node)
    }

    fn fold_break_stmt(&mut self, node: BreakStmt) -> BreakStmt {
        Fold::fold_break_stmt(&mut **self, node)
    }

    fn fold_call_expr(&mut self, node: CallExpr) -> CallExpr {
        Fold::fold_call_expr(&mut **self, node)
    }

    fn fold_callee(&mut self, node: Callee) -> Callee {
        Fold::fold_callee(&mut **self, node)
    }

    fn fold_catch_clause(&mut self, node: CatchClause) -> CatchClause {
        Fold::fold_catch_clause(&mut **self, node)
    }

    fn fold_class(&mut self, node: Class) -> Class {
        Fold::fold_class(&mut **self, node)
    }

    fn fold_class_decl(&mut self, node: ClassDecl) -> ClassDecl {
        Fold::fold_class_decl(&mut **self, node)
    }

    fn fold_class_expr(&mut self, node: ClassExpr) -> ClassExpr {
        Fold::fold_class_expr(&mut **self, node)
    }

    fn fold_class_member(&mut self, node: ClassMember) -> ClassMember {
        Fold::fold_class_member(&mut **self, node)
    }

    fn fold_class_members(&mut self, node: Vec<ClassMember>) -> Vec<ClassMember> {
        Fold::fold_class_members(&mut **self, node)
    }

    fn fold_class_method(&mut self, node: ClassMethod) -> ClassMethod {
        Fold::fold_class_method(&mut **self, node)
    }

    fn fold_class_prop(&mut self, node: ClassProp) -> ClassProp {
        Fold::fold_class_prop(&mut **self, node)
    }

    fn fold_computed_prop_name(&mut self, node: ComputedPropName) -> ComputedPropName {
        Fold::fold_computed_prop_name(&mut **self, node)
    }

    fn fold_cond_expr(&mut self, node: CondExpr) -> CondExpr {
        Fold::fold_cond_expr(&mut **self, node)
    }

    fn fold_constructor(&mut self, node: Constructor) -> Constructor {
        Fold::fold_constructor(&mut **self, node)
    }

    fn fold_continue_stmt(&mut self, node: ContinueStmt) -> ContinueStmt {
        Fold::fold_continue_stmt(&mut **self, node)
    }

    fn fold_debugger_stmt(&mut self, node: DebuggerStmt) -> DebuggerStmt {
        Fold::fold_debugger_stmt(&mut **self, node)
    }

    fn fold_decl(&mut self, node: Decl) -> Decl {
        Fold::fold_decl(&mut **self, node)
    }

    fn fold_decorator(&mut self, node: Decorator) -> Decorator {
        Fold::fold_decorator(&mut **self, node)
    }

    fn fold_decorators(&mut self, node: Vec<Decorator>) -> Vec<Decorator> {
        Fold::fold_decorators(&mut **self, node)
    }

    fn fold_default_decl(&mut self, node: DefaultDecl) -> DefaultDecl {
        Fold::fold_default_decl(&mut **self, node)
    }

    fn fold_do_while_stmt(&mut self, node: DoWhileStmt) -> DoWhileStmt {
        Fold::fold_do_while_stmt(&mut **self, node)
    }

    fn fold_empty_stmt(&mut self, node: EmptyStmt) -> EmptyStmt {
        Fold::fold_empty_stmt(&mut **self, node)
    }

    fn fold_es_version(&mut self, node: EsVersion) -> EsVersion {
        Fold::fold_es_version(&mut **self, node)
    }

    fn fold_export_all(&mut self, node: ExportAll) -> ExportAll {
        Fold::fold_export_all(&mut **self, node)
    }

    fn fold_export_decl(&mut self, node: ExportDecl) -> ExportDecl {
        Fold::fold_export_decl(&mut **self, node)
    }

    fn fold_export_default_decl(&mut self, node: ExportDefaultDecl) -> ExportDefaultDecl {
        Fold::fold_export_default_decl(&mut **self, node)
    }

    fn fold_export_default_expr(&mut self, node: ExportDefaultExpr) -> ExportDefaultExpr {
        Fold::fold_export_default_expr(&mut **self, node)
    }

    fn fold_export_default_specifier(
        &mut self,
        node: ExportDefaultSpecifier,
    ) -> ExportDefaultSpecifier {
        Fold::fold_export_default_specifier(&mut **self, node)
    }

    fn fold_export_named_specifier(&mut self, node: ExportNamedSpecifier) -> ExportNamedSpecifier {
        Fold::fold_export_named_specifier(&mut **self, node)
    }

    fn fold_export_namespace_specifier(
        &mut self,
        node: ExportNamespaceSpecifier,
    ) -> ExportNamespaceSpecifier {
        Fold::fold_export_namespace_specifier(&mut **self, node)
    }

    fn fold_export_specifier(&mut self, node: ExportSpecifier) -> ExportSpecifier {
        Fold::fold_export_specifier(&mut **self, node)
    }

    fn fold_export_specifiers(&mut self, node: Vec<ExportSpecifier>) -> Vec<ExportSpecifier> {
        Fold::fold_export_specifiers(&mut **self, node)
    }

    fn fold_expr(&mut self, node: Expr) -> Expr {
        Fold::fold_expr(&mut **self, node)
    }

    fn fold_expr_or_spread(&mut self, node: ExprOrSpread) -> ExprOrSpread {
        Fold::fold_expr_or_spread(&mut **self, node)
    }

    fn fold_expr_or_spreads(&mut self, node: Vec<ExprOrSpread>) -> Vec<ExprOrSpread> {
        Fold::fold_expr_or_spreads(&mut **self, node)
    }

    fn fold_expr_stmt(&mut self, node: ExprStmt) -> ExprStmt {
        Fold::fold_expr_stmt(&mut **self, node)
    }

    fn fold_exprs(&mut self, node: Vec<Box<Expr>>) -> Vec<Box<Expr>> {
        Fold::fold_exprs(&mut **self, node)
    }

    fn fold_fn_decl(&mut self, node: FnDecl) -> FnDecl {
        Fold::fold_fn_decl(&mut **self, node)
    }

    fn fold_fn_expr(&mut self, node: FnExpr) -> FnExpr {
        Fold::fold_fn_expr(&mut **self, node)
    }

    fn fold_for_head(&mut self, node: ForHead) -> ForHead {
        Fold::fold_for_head(&mut **self, node)
    }

    fn fold_for_in_stmt(&mut self, node: ForInStmt) -> ForInStmt {
        Fold::fold_for_in_stmt(&mut **self, node)
    }

    fn fold_for_of_stmt(&mut self, node: ForOfStmt) -> ForOfStmt {
        Fold::fold_for_of_stmt(&mut **self, node)
    }

    fn fold_for_stmt(&mut self, node: ForStmt) -> ForStmt {
        Fold::fold_for_stmt(&mut **self, node)
    }

    fn fold_function(&mut self, node: Function) -> Function {
        Fold::fold_function(&mut **self, node)
    }

    fn fold_getter_prop(&mut self, node: GetterProp) -> GetterProp {
        Fold::fold_getter_prop(&mut **self, node)
    }

    fn fold_ident(&mut self, node: Ident) -> Ident {
        Fold::fold_ident(&mut **self, node)
    }

    fn fold_ident_name(&mut self, node: IdentName) -> IdentName {
        Fold::fold_ident_name(&mut **self, node)
    }

    fn fold_if_stmt(&mut self, node: IfStmt) -> IfStmt {
        Fold::fold_if_stmt(&mut **self, node)
    }

    fn fold_import(&mut self, node: Import) -> Import {
        Fold::fold_import(&mut **self, node)
    }

    fn fold_import_decl(&mut self, node: ImportDecl) -> ImportDecl {
        Fold::fold_import_decl(&mut **self, node)
    }

    fn fold_import_default_specifier(
        &mut self,
        node: ImportDefaultSpecifier,
    ) -> ImportDefaultSpecifier {
        Fold::fold_import_default_specifier(&mut **self, node)
    }

    fn fold_import_named_specifier(&mut self, node: ImportNamedSpecifier) -> ImportNamedSpecifier {
        Fold::fold_import_named_specifier(&mut **self, node)
    }

    fn fold_import_phase(&mut self, node: ImportPhase) -> ImportPhase {
        Fold::fold_import_phase(&mut **self, node)
    }

    fn fold_import_specifier(&mut self, node: ImportSpecifier) -> ImportSpecifier {
        Fold::fold_import_specifier(&mut **self, node)
    }

    fn fold_import_specifiers(&mut self, node: Vec<ImportSpecifier>) -> Vec<ImportSpecifier> {
        Fold::fold_import_specifiers(&mut **self, node)
    }

    fn fold_import_star_as_specifier(
        &mut self,
        node: ImportStarAsSpecifier,
    ) -> ImportStarAsSpecifier {
        Fold::fold_import_star_as_specifier(&mut **self, node)
    }

    fn fold_import_with(&mut self, node: ImportWith) -> ImportWith {
        Fold::fold_import_with(&mut **self, node)
    }

    fn fold_import_with_item(&mut self, node: ImportWithItem) -> ImportWithItem {
        Fold::fold_import_with_item(&mut **self, node)
    }

    fn fold_import_with_items(&mut self, node: Vec<ImportWithItem>) -> Vec<ImportWithItem> {
        Fold::fold_import_with_items(&mut **self, node)
    }

    fn fold_invalid(&mut self, node: Invalid) -> Invalid {
        Fold::fold_invalid(&mut **self, node)
    }

    fn fold_jsx_attr(&mut self, node: JSXAttr) -> JSXAttr {
        Fold::fold_jsx_attr(&mut **self, node)
    }

    fn fold_jsx_attr_name(&mut self, node: JSXAttrName) -> JSXAttrName {
        Fold::fold_jsx_attr_name(&mut **self, node)
    }

    fn fold_jsx_attr_or_spread(&mut self, node: JSXAttrOrSpread) -> JSXAttrOrSpread {
        Fold::fold_jsx_attr_or_spread(&mut **self, node)
    }

    fn fold_jsx_attr_or_spreads(&mut self, node: Vec<JSXAttrOrSpread>) -> Vec<JSXAttrOrSpread> {
        Fold::fold_jsx_attr_or_spreads(&mut **self, node)
    }

    fn fold_jsx_attr_value(&mut self, node: JSXAttrValue) -> JSXAttrValue {
        Fold::fold_jsx_attr_value(&mut **self, node)
    }

    fn fold_jsx_closing_element(&mut self, node: JSXClosingElement) -> JSXClosingElement {
        Fold::fold_jsx_closing_element(&mut **self, node)
    }

    fn fold_jsx_closing_fragment(&mut self, node: JSXClosingFragment) -> JSXClosingFragment {
        Fold::fold_jsx_closing_fragment(&mut **self, node)
    }

    fn fold_jsx_element(&mut self, node: JSXElement) -> JSXElement {
        Fold::fold_jsx_element(&mut **self, node)
    }

    fn fold_jsx_element_child(&mut self, node: JSXElementChild) -> JSXElementChild {
        Fold::fold_jsx_element_child(&mut **self, node)
    }

    fn fold_jsx_element_childs(&mut self, node: Vec<JSXElementChild>) -> Vec<JSXElementChild> {
        Fold::fold_jsx_element_childs(&mut **self, node)
    }

    fn fold_jsx_element_name(&mut self, node: JSXElementName) -> JSXElementName {
        Fold::fold_jsx_element_name(&mut **self, node)
    }

    fn fold_jsx_empty_expr(&mut self, node: JSXEmptyExpr) -> JSXEmptyExpr {
        Fold::fold_jsx_empty_expr(&mut **self, node)
    }

    fn fold_jsx_expr(&mut self, node: JSXExpr) -> JSXExpr {
        Fold::fold_jsx_expr(&mut **self, node)
    }

    fn fold_jsx_expr_container(&mut self, node: JSXExprContainer) -> JSXExprContainer {
        Fold::fold_jsx_expr_container(&mut **self, node)
    }

    fn fold_jsx_fragment(&mut self, node: JSXFragment) -> JSXFragment {
        Fold::fold_jsx_fragment(&mut **self, node)
    }

    fn fold_jsx_member_expr(&mut self, node: JSXMemberExpr) -> JSXMemberExpr {
        Fold::fold_jsx_member_expr(&mut **self, node)
    }

    fn fold_jsx_namespaced_name(&mut self, node: JSXNamespacedName) -> JSXNamespacedName {
        Fold::fold_jsx_namespaced_name(&mut **self, node)
    }

    fn fold_jsx_object(&mut self, node: JSXObject) -> JSXObject {
        Fold::fold_jsx_object(&mut **self, node)
    }

    fn fold_jsx_opening_element(&mut self, node: JSXOpeningElement) -> JSXOpeningElement {
        Fold::fold_jsx_opening_element(&mut **self, node)
    }

    fn fold_jsx_opening_fragment(&mut self, node: JSXOpeningFragment) -> JSXOpeningFragment {
        Fold::fold_jsx_opening_fragment(&mut **self, node)
    }

    fn fold_jsx_spread_child(&mut self, node: JSXSpreadChild) -> JSXSpreadChild {
        Fold::fold_jsx_spread_child(&mut **self, node)
    }

    fn fold_jsx_text(&mut self, node: JSXText) -> JSXText {
        Fold::fold_jsx_text(&mut **self, node)
    }

    fn fold_key(&mut self, node: Key) -> Key {
        Fold::fold_key(&mut **self, node)
    }

    fn fold_key_value_pat_prop(&mut self, node: KeyValuePatProp) -> KeyValuePatProp {
        Fold::fold_key_value_pat_prop(&mut **self, node)
    }

    fn fold_key_value_prop(&mut self, node: KeyValueProp) -> KeyValueProp {
        Fold::fold_key_value_prop(&mut **self, node)
    }

    fn fold_labeled_stmt(&mut self, node: LabeledStmt) -> LabeledStmt {
        Fold::fold_labeled_stmt(&mut **self, node)
    }

    fn fold_lit(&mut self, node: Lit) -> Lit {
        Fold::fold_lit(&mut **self, node)
    }

    fn fold_member_expr(&mut self, node: MemberExpr) -> MemberExpr {
        Fold::fold_member_expr(&mut **self, node)
    }

    fn fold_member_prop(&mut self, node: MemberProp) -> MemberProp {
        Fold::fold_member_prop(&mut **self, node)
    }

    fn fold_meta_prop_expr(&mut self, node: MetaPropExpr) -> MetaPropExpr {
        Fold::fold_meta_prop_expr(&mut **self, node)
    }

    fn fold_meta_prop_kind(&mut self, node: MetaPropKind) -> MetaPropKind {
        Fold::fold_meta_prop_kind(&mut **self, node)
    }

    fn fold_method_kind(&mut self, node: MethodKind) -> MethodKind {
        Fold::fold_method_kind(&mut **self, node)
    }

    fn fold_method_prop(&mut self, node: MethodProp) -> MethodProp {
        Fold::fold_method_prop(&mut **self, node)
    }

    fn fold_module(&mut self, node: Module) -> Module {
        Fold::fold_module(&mut **self, node)
    }

    fn fold_module_decl(&mut self, node: ModuleDecl) -> ModuleDecl {
        Fold::fold_module_decl(&mut **self, node)
    }

    fn fold_module_export_name(&mut self, node: ModuleExportName) -> ModuleExportName {
        Fold::fold_module_export_name(&mut **self, node)
    }

    fn fold_module_item(&mut self, node: ModuleItem) -> ModuleItem {
        Fold::fold_module_item(&mut **self, node)
    }

    fn fold_module_items(&mut self, node: Vec<ModuleItem>) -> Vec<ModuleItem> {
        Fold::fold_module_items(&mut **self, node)
    }

    fn fold_named_export(&mut self, node: NamedExport) -> NamedExport {
        Fold::fold_named_export(&mut **self, node)
    }

    fn fold_new_expr(&mut self, node: NewExpr) -> NewExpr {
        Fold::fold_new_expr(&mut **self, node)
    }

    fn fold_null(&mut self, node: Null) -> Null {
        Fold::fold_null(&mut **self, node)
    }

    fn fold_number(&mut self, node: Number) -> Number {
        Fold::fold_number(&mut **self, node)
    }

    fn fold_object_lit(&mut self, node: ObjectLit) -> ObjectLit {
        Fold::fold_object_lit(&mut **self, node)
    }

    fn fold_object_pat(&mut self, node: ObjectPat) -> ObjectPat {
        Fold::fold_object_pat(&mut **self, node)
    }

    fn fold_object_pat_prop(&mut self, node: ObjectPatProp) -> ObjectPatProp {
        Fold::fold_object_pat_prop(&mut **self, node)
    }

    fn fold_object_pat_props(&mut self, node: Vec<ObjectPatProp>) -> Vec<ObjectPatProp> {
        Fold::fold_object_pat_props(&mut **self, node)
    }

    fn fold_opt_accessibility(&mut self, node: Option<Accessibility>) -> Option<Accessibility> {
        Fold::fold_opt_accessibility(&mut **self, node)
    }

    fn fold_opt_atom(&mut self, node: Option<swc_atoms::Atom>) -> Option<swc_atoms::Atom> {
        Fold::fold_opt_atom(&mut **self, node)
    }

    fn fold_opt_block_stmt(&mut self, node: Option<BlockStmt>) -> Option<BlockStmt> {
        Fold::fold_opt_block_stmt(&mut **self, node)
    }

    fn fold_opt_call(&mut self, node: OptCall) -> OptCall {
        Fold::fold_opt_call(&mut **self, node)
    }

    fn fold_opt_catch_clause(&mut self, node: Option<CatchClause>) -> Option<CatchClause> {
        Fold::fold_opt_catch_clause(&mut **self, node)
    }

    fn fold_opt_chain_base(&mut self, node: OptChainBase) -> OptChainBase {
        Fold::fold_opt_chain_base(&mut **self, node)
    }

    fn fold_opt_chain_expr(&mut self, node: OptChainExpr) -> OptChainExpr {
        Fold::fold_opt_chain_expr(&mut **self, node)
    }

    fn fold_opt_expr(&mut self, node: Option<Box<Expr>>) -> Option<Box<Expr>> {
        Fold::fold_opt_expr(&mut **self, node)
    }

    fn fold_opt_expr_or_spread(&mut self, node: Option<ExprOrSpread>) -> Option<ExprOrSpread> {
        Fold::fold_opt_expr_or_spread(&mut **self, node)
    }

    fn fold_opt_expr_or_spreads(
        &mut self,
        node: Option<Vec<ExprOrSpread>>,
    ) -> Option<Vec<ExprOrSpread>> {
        Fold::fold_opt_expr_or_spreads(&mut **self, node)
    }

    fn fold_opt_ident(&mut self, node: Option<Ident>) -> Option<Ident> {
        Fold::fold_opt_ident(&mut **self, node)
    }

    fn fold_opt_jsx_attr_value(&mut self, node: Option<JSXAttrValue>) -> Option<JSXAttrValue> {
        Fold::fold_opt_jsx_attr_value(&mut **self, node)
    }

    fn fold_opt_jsx_closing_element(
        &mut self,
        node: Option<JSXClosingElement>,
    ) -> Option<JSXClosingElement> {
        Fold::fold_opt_jsx_closing_element(&mut **self, node)
    }

    fn fold_opt_module_export_name(
        &mut self,
        node: Option<ModuleExportName>,
    ) -> Option<ModuleExportName> {
        Fold::fold_opt_module_export_name(&mut **self, node)
    }

    fn fold_opt_module_items(&mut self, node: Option<Vec<ModuleItem>>) -> Option<Vec<ModuleItem>> {
        Fold::fold_opt_module_items(&mut **self, node)
    }

    fn fold_opt_object_lit(&mut self, node: Option<Box<ObjectLit>>) -> Option<Box<ObjectLit>> {
        Fold::fold_opt_object_lit(&mut **self, node)
    }

    fn fold_opt_pat(&mut self, node: Option<Pat>) -> Option<Pat> {
        Fold::fold_opt_pat(&mut **self, node)
    }

    fn fold_opt_span(&mut self, node: Option<swc_common::Span>) -> Option<swc_common::Span> {
        Fold::fold_opt_span(&mut **self, node)
    }

    fn fold_opt_stmt(&mut self, node: Option<Box<Stmt>>) -> Option<Box<Stmt>> {
        Fold::fold_opt_stmt(&mut **self, node)
    }

    fn fold_opt_str(&mut self, node: Option<Box<Str>>) -> Option<Box<Str>> {
        Fold::fold_opt_str(&mut **self, node)
    }

    fn fold_opt_true_plus_minus(&mut self, node: Option<TruePlusMinus>) -> Option<TruePlusMinus> {
        Fold::fold_opt_true_plus_minus(&mut **self, node)
    }

    fn fold_opt_ts_entity_name(&mut self, node: Option<TsEntityName>) -> Option<TsEntityName> {
        Fold::fold_opt_ts_entity_name(&mut **self, node)
    }

    fn fold_opt_ts_namespace_body(
        &mut self,
        node: Option<TsNamespaceBody>,
    ) -> Option<TsNamespaceBody> {
        Fold::fold_opt_ts_namespace_body(&mut **self, node)
    }

    fn fold_opt_ts_type(&mut self, node: Option<Box<TsType>>) -> Option<Box<TsType>> {
        Fold::fold_opt_ts_type(&mut **self, node)
    }

    fn fold_opt_ts_type_ann(&mut self, node: Option<Box<TsTypeAnn>>) -> Option<Box<TsTypeAnn>> {
        Fold::fold_opt_ts_type_ann(&mut **self, node)
    }

    fn fold_opt_ts_type_param_decl(
        &mut self,
        node: Option<Box<TsTypeParamDecl>>,
    ) -> Option<Box<TsTypeParamDecl>> {
        Fold::fold_opt_ts_type_param_decl(&mut **self, node)
    }

    fn fold_opt_ts_type_param_instantiation(
        &mut self,
        node: Option<Box<TsTypeParamInstantiation>>,
    ) -> Option<Box<TsTypeParamInstantiation>> {
        Fold::fold_opt_ts_type_param_instantiation(&mut **self, node)
    }

    fn fold_opt_var_decl_or_expr(&mut self, node: Option<VarDeclOrExpr>) -> Option<VarDeclOrExpr> {
        Fold::fold_opt_var_decl_or_expr(&mut **self, node)
    }

    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        node: Vec<Option<ExprOrSpread>>,
    ) -> Vec<Option<ExprOrSpread>> {
        Fold::fold_opt_vec_expr_or_spreads(&mut **self, node)
    }

    fn fold_opt_vec_pats(&mut self, node: Vec<Option<Pat>>) -> Vec<Option<Pat>> {
        Fold::fold_opt_vec_pats(&mut **self, node)
    }

    fn fold_param(&mut self, node: Param) -> Param {
        Fold::fold_param(&mut **self, node)
    }

    fn fold_param_or_ts_param_prop(&mut self, node: ParamOrTsParamProp) -> ParamOrTsParamProp {
        Fold::fold_param_or_ts_param_prop(&mut **self, node)
    }

    fn fold_param_or_ts_param_props(
        &mut self,
        node: Vec<ParamOrTsParamProp>,
    ) -> Vec<ParamOrTsParamProp> {
        Fold::fold_param_or_ts_param_props(&mut **self, node)
    }

    fn fold_params(&mut self, node: Vec<Param>) -> Vec<Param> {
        Fold::fold_params(&mut **self, node)
    }

    fn fold_paren_expr(&mut self, node: ParenExpr) -> ParenExpr {
        Fold::fold_paren_expr(&mut **self, node)
    }

    fn fold_pat(&mut self, node: Pat) -> Pat {
        Fold::fold_pat(&mut **self, node)
    }

    fn fold_pats(&mut self, node: Vec<Pat>) -> Vec<Pat> {
        Fold::fold_pats(&mut **self, node)
    }

    fn fold_private_method(&mut self, node: PrivateMethod) -> PrivateMethod {
        Fold::fold_private_method(&mut **self, node)
    }

    fn fold_private_name(&mut self, node: PrivateName) -> PrivateName {
        Fold::fold_private_name(&mut **self, node)
    }

    fn fold_private_prop(&mut self, node: PrivateProp) -> PrivateProp {
        Fold::fold_private_prop(&mut **self, node)
    }

    fn fold_program(&mut self, node: Program) -> Program {
        Fold::fold_program(&mut **self, node)
    }

    fn fold_prop(&mut self, node: Prop) -> Prop {
        Fold::fold_prop(&mut **self, node)
    }

    fn fold_prop_name(&mut self, node: PropName) -> PropName {
        Fold::fold_prop_name(&mut **self, node)
    }

    fn fold_prop_or_spread(&mut self, node: PropOrSpread) -> PropOrSpread {
        Fold::fold_prop_or_spread(&mut **self, node)
    }

    fn fold_prop_or_spreads(&mut self, node: Vec<PropOrSpread>) -> Vec<PropOrSpread> {
        Fold::fold_prop_or_spreads(&mut **self, node)
    }

    fn fold_regex(&mut self, node: Regex) -> Regex {
        Fold::fold_regex(&mut **self, node)
    }

    fn fold_reserved_unused(&mut self, node: ReservedUnused) -> ReservedUnused {
        Fold::fold_reserved_unused(&mut **self, node)
    }

    fn fold_rest_pat(&mut self, node: RestPat) -> RestPat {
        Fold::fold_rest_pat(&mut **self, node)
    }

    fn fold_return_stmt(&mut self, node: ReturnStmt) -> ReturnStmt {
        Fold::fold_return_stmt(&mut **self, node)
    }

    fn fold_script(&mut self, node: Script) -> Script {
        Fold::fold_script(&mut **self, node)
    }

    fn fold_seq_expr(&mut self, node: SeqExpr) -> SeqExpr {
        Fold::fold_seq_expr(&mut **self, node)
    }

    fn fold_setter_prop(&mut self, node: SetterProp) -> SetterProp {
        Fold::fold_setter_prop(&mut **self, node)
    }

    fn fold_simple_assign_target(&mut self, node: SimpleAssignTarget) -> SimpleAssignTarget {
        Fold::fold_simple_assign_target(&mut **self, node)
    }

    fn fold_span(&mut self, node: swc_common::Span) -> swc_common::Span {
        Fold::fold_span(&mut **self, node)
    }

    fn fold_spread_element(&mut self, node: SpreadElement) -> SpreadElement {
        Fold::fold_spread_element(&mut **self, node)
    }

    fn fold_static_block(&mut self, node: StaticBlock) -> StaticBlock {
        Fold::fold_static_block(&mut **self, node)
    }

    fn fold_stmt(&mut self, node: Stmt) -> Stmt {
        Fold::fold_stmt(&mut **self, node)
    }

    fn fold_stmts(&mut self, node: Vec<Stmt>) -> Vec<Stmt> {
        Fold::fold_stmts(&mut **self, node)
    }

    fn fold_str(&mut self, node: Str) -> Str {
        Fold::fold_str(&mut **self, node)
    }

    fn fold_super(&mut self, node: Super) -> Super {
        Fold::fold_super(&mut **self, node)
    }

    fn fold_super_prop(&mut self, node: SuperProp) -> SuperProp {
        Fold::fold_super_prop(&mut **self, node)
    }

    fn fold_super_prop_expr(&mut self, node: SuperPropExpr) -> SuperPropExpr {
        Fold::fold_super_prop_expr(&mut **self, node)
    }

    fn fold_switch_case(&mut self, node: SwitchCase) -> SwitchCase {
        Fold::fold_switch_case(&mut **self, node)
    }

    fn fold_switch_cases(&mut self, node: Vec<SwitchCase>) -> Vec<SwitchCase> {
        Fold::fold_switch_cases(&mut **self, node)
    }

    fn fold_switch_stmt(&mut self, node: SwitchStmt) -> SwitchStmt {
        Fold::fold_switch_stmt(&mut **self, node)
    }

    fn fold_syntax_context(
        &mut self,
        node: swc_common::SyntaxContext,
    ) -> swc_common::SyntaxContext {
        Fold::fold_syntax_context(&mut **self, node)
    }

    fn fold_tagged_tpl(&mut self, node: TaggedTpl) -> TaggedTpl {
        Fold::fold_tagged_tpl(&mut **self, node)
    }

    fn fold_this_expr(&mut self, node: ThisExpr) -> ThisExpr {
        Fold::fold_this_expr(&mut **self, node)
    }

    fn fold_throw_stmt(&mut self, node: ThrowStmt) -> ThrowStmt {
        Fold::fold_throw_stmt(&mut **self, node)
    }

    fn fold_tpl(&mut self, node: Tpl) -> Tpl {
        Fold::fold_tpl(&mut **self, node)
    }

    fn fold_tpl_element(&mut self, node: TplElement) -> TplElement {
        Fold::fold_tpl_element(&mut **self, node)
    }

    fn fold_tpl_elements(&mut self, node: Vec<TplElement>) -> Vec<TplElement> {
        Fold::fold_tpl_elements(&mut **self, node)
    }

    fn fold_true_plus_minus(&mut self, node: TruePlusMinus) -> TruePlusMinus {
        Fold::fold_true_plus_minus(&mut **self, node)
    }

    fn fold_try_stmt(&mut self, node: TryStmt) -> TryStmt {
        Fold::fold_try_stmt(&mut **self, node)
    }

    fn fold_ts_array_type(&mut self, node: TsArrayType) -> TsArrayType {
        Fold::fold_ts_array_type(&mut **self, node)
    }

    fn fold_ts_as_expr(&mut self, node: TsAsExpr) -> TsAsExpr {
        Fold::fold_ts_as_expr(&mut **self, node)
    }

    fn fold_ts_call_signature_decl(&mut self, node: TsCallSignatureDecl) -> TsCallSignatureDecl {
        Fold::fold_ts_call_signature_decl(&mut **self, node)
    }

    fn fold_ts_conditional_type(&mut self, node: TsConditionalType) -> TsConditionalType {
        Fold::fold_ts_conditional_type(&mut **self, node)
    }

    fn fold_ts_const_assertion(&mut self, node: TsConstAssertion) -> TsConstAssertion {
        Fold::fold_ts_const_assertion(&mut **self, node)
    }

    fn fold_ts_construct_signature_decl(
        &mut self,
        node: TsConstructSignatureDecl,
    ) -> TsConstructSignatureDecl {
        Fold::fold_ts_construct_signature_decl(&mut **self, node)
    }

    fn fold_ts_constructor_type(&mut self, node: TsConstructorType) -> TsConstructorType {
        Fold::fold_ts_constructor_type(&mut **self, node)
    }

    fn fold_ts_entity_name(&mut self, node: TsEntityName) -> TsEntityName {
        Fold::fold_ts_entity_name(&mut **self, node)
    }

    fn fold_ts_enum_decl(&mut self, node: TsEnumDecl) -> TsEnumDecl {
        Fold::fold_ts_enum_decl(&mut **self, node)
    }

    fn fold_ts_enum_member(&mut self, node: TsEnumMember) -> TsEnumMember {
        Fold::fold_ts_enum_member(&mut **self, node)
    }

    fn fold_ts_enum_member_id(&mut self, node: TsEnumMemberId) -> TsEnumMemberId {
        Fold::fold_ts_enum_member_id(&mut **self, node)
    }

    fn fold_ts_enum_members(&mut self, node: Vec<TsEnumMember>) -> Vec<TsEnumMember> {
        Fold::fold_ts_enum_members(&mut **self, node)
    }

    fn fold_ts_export_assignment(&mut self, node: TsExportAssignment) -> TsExportAssignment {
        Fold::fold_ts_export_assignment(&mut **self, node)
    }

    fn fold_ts_expr_with_type_args(&mut self, node: TsExprWithTypeArgs) -> TsExprWithTypeArgs {
        Fold::fold_ts_expr_with_type_args(&mut **self, node)
    }

    fn fold_ts_expr_with_type_argss(
        &mut self,
        node: Vec<TsExprWithTypeArgs>,
    ) -> Vec<TsExprWithTypeArgs> {
        Fold::fold_ts_expr_with_type_argss(&mut **self, node)
    }

    fn fold_ts_external_module_ref(&mut self, node: TsExternalModuleRef) -> TsExternalModuleRef {
        Fold::fold_ts_external_module_ref(&mut **self, node)
    }

    fn fold_ts_fn_or_constructor_type(
        &mut self,
        node: TsFnOrConstructorType,
    ) -> TsFnOrConstructorType {
        Fold::fold_ts_fn_or_constructor_type(&mut **self, node)
    }

    fn fold_ts_fn_param(&mut self, node: TsFnParam) -> TsFnParam {
        Fold::fold_ts_fn_param(&mut **self, node)
    }

    fn fold_ts_fn_params(&mut self, node: Vec<TsFnParam>) -> Vec<TsFnParam> {
        Fold::fold_ts_fn_params(&mut **self, node)
    }

    fn fold_ts_fn_type(&mut self, node: TsFnType) -> TsFnType {
        Fold::fold_ts_fn_type(&mut **self, node)
    }

    fn fold_ts_getter_signature(&mut self, node: TsGetterSignature) -> TsGetterSignature {
        Fold::fold_ts_getter_signature(&mut **self, node)
    }

    fn fold_ts_import_equals_decl(&mut self, node: TsImportEqualsDecl) -> TsImportEqualsDecl {
        Fold::fold_ts_import_equals_decl(&mut **self, node)
    }

    fn fold_ts_import_type(&mut self, node: TsImportType) -> TsImportType {
        Fold::fold_ts_import_type(&mut **self, node)
    }

    fn fold_ts_index_signature(&mut self, node: TsIndexSignature) -> TsIndexSignature {
        Fold::fold_ts_index_signature(&mut **self, node)
    }

    fn fold_ts_indexed_access_type(&mut self, node: TsIndexedAccessType) -> TsIndexedAccessType {
        Fold::fold_ts_indexed_access_type(&mut **self, node)
    }

    fn fold_ts_infer_type(&mut self, node: TsInferType) -> TsInferType {
        Fold::fold_ts_infer_type(&mut **self, node)
    }

    fn fold_ts_instantiation(&mut self, node: TsInstantiation) -> TsInstantiation {
        Fold::fold_ts_instantiation(&mut **self, node)
    }

    fn fold_ts_interface_body(&mut self, node: TsInterfaceBody) -> TsInterfaceBody {
        Fold::fold_ts_interface_body(&mut **self, node)
    }

    fn fold_ts_interface_decl(&mut self, node: TsInterfaceDecl) -> TsInterfaceDecl {
        Fold::fold_ts_interface_decl(&mut **self, node)
    }

    fn fold_ts_intersection_type(&mut self, node: TsIntersectionType) -> TsIntersectionType {
        Fold::fold_ts_intersection_type(&mut **self, node)
    }

    fn fold_ts_keyword_type(&mut self, node: TsKeywordType) -> TsKeywordType {
        Fold::fold_ts_keyword_type(&mut **self, node)
    }

    fn fold_ts_keyword_type_kind(&mut self, node: TsKeywordTypeKind) -> TsKeywordTypeKind {
        Fold::fold_ts_keyword_type_kind(&mut **self, node)
    }

    fn fold_ts_lit(&mut self, node: TsLit) -> TsLit {
        Fold::fold_ts_lit(&mut **self, node)
    }

    fn fold_ts_lit_type(&mut self, node: TsLitType) -> TsLitType {
        Fold::fold_ts_lit_type(&mut **self, node)
    }

    fn fold_ts_mapped_type(&mut self, node: TsMappedType) -> TsMappedType {
        Fold::fold_ts_mapped_type(&mut **self, node)
    }

    fn fold_ts_method_signature(&mut self, node: TsMethodSignature) -> TsMethodSignature {
        Fold::fold_ts_method_signature(&mut **self, node)
    }

    fn fold_ts_module_block(&mut self, node: TsModuleBlock) -> TsModuleBlock {
        Fold::fold_ts_module_block(&mut **self, node)
    }

    fn fold_ts_module_decl(&mut self, node: TsModuleDecl) -> TsModuleDecl {
        Fold::fold_ts_module_decl(&mut **self, node)
    }

    fn fold_ts_module_name(&mut self, node: TsModuleName) -> TsModuleName {
        Fold::fold_ts_module_name(&mut **self, node)
    }

    fn fold_ts_module_ref(&mut self, node: TsModuleRef) -> TsModuleRef {
        Fold::fold_ts_module_ref(&mut **self, node)
    }

    fn fold_ts_namespace_body(&mut self, node: TsNamespaceBody) -> TsNamespaceBody {
        Fold::fold_ts_namespace_body(&mut **self, node)
    }

    fn fold_ts_namespace_decl(&mut self, node: TsNamespaceDecl) -> TsNamespaceDecl {
        Fold::fold_ts_namespace_decl(&mut **self, node)
    }

    fn fold_ts_namespace_export_decl(
        &mut self,
        node: TsNamespaceExportDecl,
    ) -> TsNamespaceExportDecl {
        Fold::fold_ts_namespace_export_decl(&mut **self, node)
    }

    fn fold_ts_non_null_expr(&mut self, node: TsNonNullExpr) -> TsNonNullExpr {
        Fold::fold_ts_non_null_expr(&mut **self, node)
    }

    fn fold_ts_optional_type(&mut self, node: TsOptionalType) -> TsOptionalType {
        Fold::fold_ts_optional_type(&mut **self, node)
    }

    fn fold_ts_param_prop(&mut self, node: TsParamProp) -> TsParamProp {
        Fold::fold_ts_param_prop(&mut **self, node)
    }

    fn fold_ts_param_prop_param(&mut self, node: TsParamPropParam) -> TsParamPropParam {
        Fold::fold_ts_param_prop_param(&mut **self, node)
    }

    fn fold_ts_parenthesized_type(&mut self, node: TsParenthesizedType) -> TsParenthesizedType {
        Fold::fold_ts_parenthesized_type(&mut **self, node)
    }

    fn fold_ts_property_signature(&mut self, node: TsPropertySignature) -> TsPropertySignature {
        Fold::fold_ts_property_signature(&mut **self, node)
    }

    fn fold_ts_qualified_name(&mut self, node: TsQualifiedName) -> TsQualifiedName {
        Fold::fold_ts_qualified_name(&mut **self, node)
    }

    fn fold_ts_rest_type(&mut self, node: TsRestType) -> TsRestType {
        Fold::fold_ts_rest_type(&mut **self, node)
    }

    fn fold_ts_satisfies_expr(&mut self, node: TsSatisfiesExpr) -> TsSatisfiesExpr {
        Fold::fold_ts_satisfies_expr(&mut **self, node)
    }

    fn fold_ts_setter_signature(&mut self, node: TsSetterSignature) -> TsSetterSignature {
        Fold::fold_ts_setter_signature(&mut **self, node)
    }

    fn fold_ts_this_type(&mut self, node: TsThisType) -> TsThisType {
        Fold::fold_ts_this_type(&mut **self, node)
    }

    fn fold_ts_this_type_or_ident(&mut self, node: TsThisTypeOrIdent) -> TsThisTypeOrIdent {
        Fold::fold_ts_this_type_or_ident(&mut **self, node)
    }

    fn fold_ts_tpl_lit_type(&mut self, node: TsTplLitType) -> TsTplLitType {
        Fold::fold_ts_tpl_lit_type(&mut **self, node)
    }

    fn fold_ts_tuple_element(&mut self, node: TsTupleElement) -> TsTupleElement {
        Fold::fold_ts_tuple_element(&mut **self, node)
    }

    fn fold_ts_tuple_elements(&mut self, node: Vec<TsTupleElement>) -> Vec<TsTupleElement> {
        Fold::fold_ts_tuple_elements(&mut **self, node)
    }

    fn fold_ts_tuple_type(&mut self, node: TsTupleType) -> TsTupleType {
        Fold::fold_ts_tuple_type(&mut **self, node)
    }

    fn fold_ts_type(&mut self, node: TsType) -> TsType {
        Fold::fold_ts_type(&mut **self, node)
    }

    fn fold_ts_type_alias_decl(&mut self, node: TsTypeAliasDecl) -> TsTypeAliasDecl {
        Fold::fold_ts_type_alias_decl(&mut **self, node)
    }

    fn fold_ts_type_ann(&mut self, node: TsTypeAnn) -> TsTypeAnn {
        Fold::fold_ts_type_ann(&mut **self, node)
    }

    fn fold_ts_type_assertion(&mut self, node: TsTypeAssertion) -> TsTypeAssertion {
        Fold::fold_ts_type_assertion(&mut **self, node)
    }

    fn fold_ts_type_element(&mut self, node: TsTypeElement) -> TsTypeElement {
        Fold::fold_ts_type_element(&mut **self, node)
    }

    fn fold_ts_type_elements(&mut self, node: Vec<TsTypeElement>) -> Vec<TsTypeElement> {
        Fold::fold_ts_type_elements(&mut **self, node)
    }

    fn fold_ts_type_lit(&mut self, node: TsTypeLit) -> TsTypeLit {
        Fold::fold_ts_type_lit(&mut **self, node)
    }

    fn fold_ts_type_operator(&mut self, node: TsTypeOperator) -> TsTypeOperator {
        Fold::fold_ts_type_operator(&mut **self, node)
    }

    fn fold_ts_type_operator_op(&mut self, node: TsTypeOperatorOp) -> TsTypeOperatorOp {
        Fold::fold_ts_type_operator_op(&mut **self, node)
    }

    fn fold_ts_type_param(&mut self, node: TsTypeParam) -> TsTypeParam {
        Fold::fold_ts_type_param(&mut **self, node)
    }

    fn fold_ts_type_param_decl(&mut self, node: TsTypeParamDecl) -> TsTypeParamDecl {
        Fold::fold_ts_type_param_decl(&mut **self, node)
    }

    fn fold_ts_type_param_instantiation(
        &mut self,
        node: TsTypeParamInstantiation,
    ) -> TsTypeParamInstantiation {
        Fold::fold_ts_type_param_instantiation(&mut **self, node)
    }

    fn fold_ts_type_params(&mut self, node: Vec<TsTypeParam>) -> Vec<TsTypeParam> {
        Fold::fold_ts_type_params(&mut **self, node)
    }

    fn fold_ts_type_predicate(&mut self, node: TsTypePredicate) -> TsTypePredicate {
        Fold::fold_ts_type_predicate(&mut **self, node)
    }

    fn fold_ts_type_query(&mut self, node: TsTypeQuery) -> TsTypeQuery {
        Fold::fold_ts_type_query(&mut **self, node)
    }

    fn fold_ts_type_query_expr(&mut self, node: TsTypeQueryExpr) -> TsTypeQueryExpr {
        Fold::fold_ts_type_query_expr(&mut **self, node)
    }

    fn fold_ts_type_ref(&mut self, node: TsTypeRef) -> TsTypeRef {
        Fold::fold_ts_type_ref(&mut **self, node)
    }

    fn fold_ts_types(&mut self, node: Vec<Box<TsType>>) -> Vec<Box<TsType>> {
        Fold::fold_ts_types(&mut **self, node)
    }

    fn fold_ts_union_or_intersection_type(
        &mut self,
        node: TsUnionOrIntersectionType,
    ) -> TsUnionOrIntersectionType {
        Fold::fold_ts_union_or_intersection_type(&mut **self, node)
    }

    fn fold_ts_union_type(&mut self, node: TsUnionType) -> TsUnionType {
        Fold::fold_ts_union_type(&mut **self, node)
    }

    fn fold_unary_expr(&mut self, node: UnaryExpr) -> UnaryExpr {
        Fold::fold_unary_expr(&mut **self, node)
    }

    fn fold_unary_op(&mut self, node: UnaryOp) -> UnaryOp {
        Fold::fold_unary_op(&mut **self, node)
    }

    fn fold_update_expr(&mut self, node: UpdateExpr) -> UpdateExpr {
        Fold::fold_update_expr(&mut **self, node)
    }

    fn fold_update_op(&mut self, node: UpdateOp) -> UpdateOp {
        Fold::fold_update_op(&mut **self, node)
    }

    fn fold_using_decl(&mut self, node: UsingDecl) -> UsingDecl {
        Fold::fold_using_decl(&mut **self, node)
    }

    fn fold_var_decl(&mut self, node: VarDecl) -> VarDecl {
        Fold::fold_var_decl(&mut **self, node)
    }

    fn fold_var_decl_kind(&mut self, node: VarDeclKind) -> VarDeclKind {
        Fold::fold_var_decl_kind(&mut **self, node)
    }

    fn fold_var_decl_or_expr(&mut self, node: VarDeclOrExpr) -> VarDeclOrExpr {
        Fold::fold_var_decl_or_expr(&mut **self, node)
    }

    fn fold_var_declarator(&mut self, node: VarDeclarator) -> VarDeclarator {
        Fold::fold_var_declarator(&mut **self, node)
    }

    fn fold_var_declarators(&mut self, node: Vec<VarDeclarator>) -> Vec<VarDeclarator> {
        Fold::fold_var_declarators(&mut **self, node)
    }

    fn fold_while_stmt(&mut self, node: WhileStmt) -> WhileStmt {
        Fold::fold_while_stmt(&mut **self, node)
    }

    fn fold_with_stmt(&mut self, node: WithStmt) -> WithStmt {
        Fold::fold_with_stmt(&mut **self, node)
    }

    fn fold_yield_expr(&mut self, node: YieldExpr) -> YieldExpr {
        Fold::fold_yield_expr(&mut **self, node)
    }
}
impl<A, B> Fold for ::swc_visit::Either<A, B>
where
    A: Fold,
    B: Fold,
{
    fn fold_accessibility(&mut self, node: Accessibility) -> Accessibility {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_accessibility(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_accessibility(self, node),
        }
    }

    fn fold_array_lit(&mut self, node: ArrayLit) -> ArrayLit {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_array_lit(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_array_lit(self, node),
        }
    }

    fn fold_array_pat(&mut self, node: ArrayPat) -> ArrayPat {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_array_pat(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_array_pat(self, node),
        }
    }

    fn fold_arrow_expr(&mut self, node: ArrowExpr) -> ArrowExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_arrow_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_arrow_expr(self, node),
        }
    }

    fn fold_assign_expr(&mut self, node: AssignExpr) -> AssignExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_assign_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_assign_expr(self, node),
        }
    }

    fn fold_assign_op(&mut self, node: AssignOp) -> AssignOp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_assign_op(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_assign_op(self, node),
        }
    }

    fn fold_assign_pat(&mut self, node: AssignPat) -> AssignPat {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_assign_pat(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_assign_pat(self, node),
        }
    }

    fn fold_assign_pat_prop(&mut self, node: AssignPatProp) -> AssignPatProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_assign_pat_prop(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_assign_pat_prop(self, node),
        }
    }

    fn fold_assign_prop(&mut self, node: AssignProp) -> AssignProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_assign_prop(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_assign_prop(self, node),
        }
    }

    fn fold_assign_target(&mut self, node: AssignTarget) -> AssignTarget {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_assign_target(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_assign_target(self, node),
        }
    }

    fn fold_assign_target_pat(&mut self, node: AssignTargetPat) -> AssignTargetPat {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_assign_target_pat(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_assign_target_pat(self, node),
        }
    }

    fn fold_atom(&mut self, node: swc_atoms::Atom) -> swc_atoms::Atom {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_atom(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_atom(self, node),
        }
    }

    fn fold_auto_accessor(&mut self, node: AutoAccessor) -> AutoAccessor {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_auto_accessor(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_auto_accessor(self, node),
        }
    }

    fn fold_await_expr(&mut self, node: AwaitExpr) -> AwaitExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_await_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_await_expr(self, node),
        }
    }

    fn fold_big_int(&mut self, node: BigInt) -> BigInt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_big_int(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_big_int(self, node),
        }
    }

    fn fold_big_int_value(&mut self, node: BigIntValue) -> BigIntValue {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_big_int_value(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_big_int_value(self, node),
        }
    }

    fn fold_bin_expr(&mut self, node: BinExpr) -> BinExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_bin_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_bin_expr(self, node),
        }
    }

    fn fold_binary_op(&mut self, node: BinaryOp) -> BinaryOp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_binary_op(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_binary_op(self, node),
        }
    }

    fn fold_binding_ident(&mut self, node: BindingIdent) -> BindingIdent {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_binding_ident(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_binding_ident(self, node),
        }
    }

    fn fold_block_stmt(&mut self, node: BlockStmt) -> BlockStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_block_stmt(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_block_stmt(self, node),
        }
    }

    fn fold_block_stmt_or_expr(&mut self, node: BlockStmtOrExpr) -> BlockStmtOrExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_block_stmt_or_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_block_stmt_or_expr(self, node),
        }
    }

    fn fold_bool(&mut self, node: Bool) -> Bool {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_bool(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_bool(self, node),
        }
    }

    fn fold_break_stmt(&mut self, node: BreakStmt) -> BreakStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_break_stmt(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_break_stmt(self, node),
        }
    }

    fn fold_call_expr(&mut self, node: CallExpr) -> CallExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_call_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_call_expr(self, node),
        }
    }

    fn fold_callee(&mut self, node: Callee) -> Callee {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_callee(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_callee(self, node),
        }
    }

    fn fold_catch_clause(&mut self, node: CatchClause) -> CatchClause {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_catch_clause(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_catch_clause(self, node),
        }
    }

    fn fold_class(&mut self, node: Class) -> Class {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_class(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_class(self, node),
        }
    }

    fn fold_class_decl(&mut self, node: ClassDecl) -> ClassDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_class_decl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_class_decl(self, node),
        }
    }

    fn fold_class_expr(&mut self, node: ClassExpr) -> ClassExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_class_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_class_expr(self, node),
        }
    }

    fn fold_class_member(&mut self, node: ClassMember) -> ClassMember {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_class_member(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_class_member(self, node),
        }
    }

    fn fold_class_members(&mut self, node: Vec<ClassMember>) -> Vec<ClassMember> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_class_members(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_class_members(self, node),
        }
    }

    fn fold_class_method(&mut self, node: ClassMethod) -> ClassMethod {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_class_method(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_class_method(self, node),
        }
    }

    fn fold_class_prop(&mut self, node: ClassProp) -> ClassProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_class_prop(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_class_prop(self, node),
        }
    }

    fn fold_computed_prop_name(&mut self, node: ComputedPropName) -> ComputedPropName {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_computed_prop_name(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_computed_prop_name(self, node),
        }
    }

    fn fold_cond_expr(&mut self, node: CondExpr) -> CondExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_cond_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_cond_expr(self, node),
        }
    }

    fn fold_constructor(&mut self, node: Constructor) -> Constructor {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_constructor(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_constructor(self, node),
        }
    }

    fn fold_continue_stmt(&mut self, node: ContinueStmt) -> ContinueStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_continue_stmt(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_continue_stmt(self, node),
        }
    }

    fn fold_debugger_stmt(&mut self, node: DebuggerStmt) -> DebuggerStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_debugger_stmt(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_debugger_stmt(self, node),
        }
    }

    fn fold_decl(&mut self, node: Decl) -> Decl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_decl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_decl(self, node),
        }
    }

    fn fold_decorator(&mut self, node: Decorator) -> Decorator {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_decorator(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_decorator(self, node),
        }
    }

    fn fold_decorators(&mut self, node: Vec<Decorator>) -> Vec<Decorator> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_decorators(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_decorators(self, node),
        }
    }

    fn fold_default_decl(&mut self, node: DefaultDecl) -> DefaultDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_default_decl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_default_decl(self, node),
        }
    }

    fn fold_do_while_stmt(&mut self, node: DoWhileStmt) -> DoWhileStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_do_while_stmt(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_do_while_stmt(self, node),
        }
    }

    fn fold_empty_stmt(&mut self, node: EmptyStmt) -> EmptyStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_empty_stmt(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_empty_stmt(self, node),
        }
    }

    fn fold_es_version(&mut self, node: EsVersion) -> EsVersion {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_es_version(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_es_version(self, node),
        }
    }

    fn fold_export_all(&mut self, node: ExportAll) -> ExportAll {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_export_all(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_export_all(self, node),
        }
    }

    fn fold_export_decl(&mut self, node: ExportDecl) -> ExportDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_export_decl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_export_decl(self, node),
        }
    }

    fn fold_export_default_decl(&mut self, node: ExportDefaultDecl) -> ExportDefaultDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_export_default_decl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_export_default_decl(self, node),
        }
    }

    fn fold_export_default_expr(&mut self, node: ExportDefaultExpr) -> ExportDefaultExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_export_default_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_export_default_expr(self, node),
        }
    }

    fn fold_export_default_specifier(
        &mut self,
        node: ExportDefaultSpecifier,
    ) -> ExportDefaultSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_export_default_specifier(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_export_default_specifier(self, node),
        }
    }

    fn fold_export_named_specifier(&mut self, node: ExportNamedSpecifier) -> ExportNamedSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_export_named_specifier(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_export_named_specifier(self, node),
        }
    }

    fn fold_export_namespace_specifier(
        &mut self,
        node: ExportNamespaceSpecifier,
    ) -> ExportNamespaceSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_export_namespace_specifier(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_export_namespace_specifier(self, node),
        }
    }

    fn fold_export_specifier(&mut self, node: ExportSpecifier) -> ExportSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_export_specifier(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_export_specifier(self, node),
        }
    }

    fn fold_export_specifiers(&mut self, node: Vec<ExportSpecifier>) -> Vec<ExportSpecifier> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_export_specifiers(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_export_specifiers(self, node),
        }
    }

    fn fold_expr(&mut self, node: Expr) -> Expr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_expr(self, node),
        }
    }

    fn fold_expr_or_spread(&mut self, node: ExprOrSpread) -> ExprOrSpread {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_expr_or_spread(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_expr_or_spread(self, node),
        }
    }

    fn fold_expr_or_spreads(&mut self, node: Vec<ExprOrSpread>) -> Vec<ExprOrSpread> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_expr_or_spreads(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_expr_or_spreads(self, node),
        }
    }

    fn fold_expr_stmt(&mut self, node: ExprStmt) -> ExprStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_expr_stmt(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_expr_stmt(self, node),
        }
    }

    fn fold_exprs(&mut self, node: Vec<Box<Expr>>) -> Vec<Box<Expr>> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_exprs(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_exprs(self, node),
        }
    }

    fn fold_fn_decl(&mut self, node: FnDecl) -> FnDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_fn_decl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_fn_decl(self, node),
        }
    }

    fn fold_fn_expr(&mut self, node: FnExpr) -> FnExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_fn_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_fn_expr(self, node),
        }
    }

    fn fold_for_head(&mut self, node: ForHead) -> ForHead {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_for_head(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_for_head(self, node),
        }
    }

    fn fold_for_in_stmt(&mut self, node: ForInStmt) -> ForInStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_for_in_stmt(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_for_in_stmt(self, node),
        }
    }

    fn fold_for_of_stmt(&mut self, node: ForOfStmt) -> ForOfStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_for_of_stmt(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_for_of_stmt(self, node),
        }
    }

    fn fold_for_stmt(&mut self, node: ForStmt) -> ForStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_for_stmt(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_for_stmt(self, node),
        }
    }

    fn fold_function(&mut self, node: Function) -> Function {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_function(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_function(self, node),
        }
    }

    fn fold_getter_prop(&mut self, node: GetterProp) -> GetterProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_getter_prop(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_getter_prop(self, node),
        }
    }

    fn fold_ident(&mut self, node: Ident) -> Ident {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ident(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ident(self, node),
        }
    }

    fn fold_ident_name(&mut self, node: IdentName) -> IdentName {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ident_name(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ident_name(self, node),
        }
    }

    fn fold_if_stmt(&mut self, node: IfStmt) -> IfStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_if_stmt(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_if_stmt(self, node),
        }
    }

    fn fold_import(&mut self, node: Import) -> Import {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import(self, node),
        }
    }

    fn fold_import_decl(&mut self, node: ImportDecl) -> ImportDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import_decl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import_decl(self, node),
        }
    }

    fn fold_import_default_specifier(
        &mut self,
        node: ImportDefaultSpecifier,
    ) -> ImportDefaultSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import_default_specifier(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import_default_specifier(self, node),
        }
    }

    fn fold_import_named_specifier(&mut self, node: ImportNamedSpecifier) -> ImportNamedSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import_named_specifier(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import_named_specifier(self, node),
        }
    }

    fn fold_import_phase(&mut self, node: ImportPhase) -> ImportPhase {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import_phase(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import_phase(self, node),
        }
    }

    fn fold_import_specifier(&mut self, node: ImportSpecifier) -> ImportSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import_specifier(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import_specifier(self, node),
        }
    }

    fn fold_import_specifiers(&mut self, node: Vec<ImportSpecifier>) -> Vec<ImportSpecifier> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import_specifiers(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import_specifiers(self, node),
        }
    }

    fn fold_import_star_as_specifier(
        &mut self,
        node: ImportStarAsSpecifier,
    ) -> ImportStarAsSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import_star_as_specifier(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import_star_as_specifier(self, node),
        }
    }

    fn fold_import_with(&mut self, node: ImportWith) -> ImportWith {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import_with(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import_with(self, node),
        }
    }

    fn fold_import_with_item(&mut self, node: ImportWithItem) -> ImportWithItem {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import_with_item(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import_with_item(self, node),
        }
    }

    fn fold_import_with_items(&mut self, node: Vec<ImportWithItem>) -> Vec<ImportWithItem> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_import_with_items(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_import_with_items(self, node),
        }
    }

    fn fold_invalid(&mut self, node: Invalid) -> Invalid {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_invalid(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_invalid(self, node),
        }
    }

    fn fold_jsx_attr(&mut self, node: JSXAttr) -> JSXAttr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_attr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_attr(self, node),
        }
    }

    fn fold_jsx_attr_name(&mut self, node: JSXAttrName) -> JSXAttrName {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_attr_name(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_attr_name(self, node),
        }
    }

    fn fold_jsx_attr_or_spread(&mut self, node: JSXAttrOrSpread) -> JSXAttrOrSpread {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_attr_or_spread(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_attr_or_spread(self, node),
        }
    }

    fn fold_jsx_attr_or_spreads(&mut self, node: Vec<JSXAttrOrSpread>) -> Vec<JSXAttrOrSpread> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_attr_or_spreads(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_attr_or_spreads(self, node),
        }
    }

    fn fold_jsx_attr_value(&mut self, node: JSXAttrValue) -> JSXAttrValue {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_attr_value(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_attr_value(self, node),
        }
    }

    fn fold_jsx_closing_element(&mut self, node: JSXClosingElement) -> JSXClosingElement {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_closing_element(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_closing_element(self, node),
        }
    }

    fn fold_jsx_closing_fragment(&mut self, node: JSXClosingFragment) -> JSXClosingFragment {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_closing_fragment(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_closing_fragment(self, node),
        }
    }

    fn fold_jsx_element(&mut self, node: JSXElement) -> JSXElement {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_element(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_element(self, node),
        }
    }

    fn fold_jsx_element_child(&mut self, node: JSXElementChild) -> JSXElementChild {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_element_child(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_element_child(self, node),
        }
    }

    fn fold_jsx_element_childs(&mut self, node: Vec<JSXElementChild>) -> Vec<JSXElementChild> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_element_childs(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_element_childs(self, node),
        }
    }

    fn fold_jsx_element_name(&mut self, node: JSXElementName) -> JSXElementName {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_element_name(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_element_name(self, node),
        }
    }

    fn fold_jsx_empty_expr(&mut self, node: JSXEmptyExpr) -> JSXEmptyExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_empty_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_empty_expr(self, node),
        }
    }

    fn fold_jsx_expr(&mut self, node: JSXExpr) -> JSXExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_expr(self, node),
        }
    }

    fn fold_jsx_expr_container(&mut self, node: JSXExprContainer) -> JSXExprContainer {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_expr_container(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_expr_container(self, node),
        }
    }

    fn fold_jsx_fragment(&mut self, node: JSXFragment) -> JSXFragment {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_fragment(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_fragment(self, node),
        }
    }

    fn fold_jsx_member_expr(&mut self, node: JSXMemberExpr) -> JSXMemberExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_member_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_member_expr(self, node),
        }
    }

    fn fold_jsx_namespaced_name(&mut self, node: JSXNamespacedName) -> JSXNamespacedName {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_namespaced_name(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_namespaced_name(self, node),
        }
    }

    fn fold_jsx_object(&mut self, node: JSXObject) -> JSXObject {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_object(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_object(self, node),
        }
    }

    fn fold_jsx_opening_element(&mut self, node: JSXOpeningElement) -> JSXOpeningElement {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_opening_element(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_opening_element(self, node),
        }
    }

    fn fold_jsx_opening_fragment(&mut self, node: JSXOpeningFragment) -> JSXOpeningFragment {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_opening_fragment(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_opening_fragment(self, node),
        }
    }

    fn fold_jsx_spread_child(&mut self, node: JSXSpreadChild) -> JSXSpreadChild {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_spread_child(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_spread_child(self, node),
        }
    }

    fn fold_jsx_text(&mut self, node: JSXText) -> JSXText {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_jsx_text(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_jsx_text(self, node),
        }
    }

    fn fold_key(&mut self, node: Key) -> Key {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_key(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_key(self, node),
        }
    }

    fn fold_key_value_pat_prop(&mut self, node: KeyValuePatProp) -> KeyValuePatProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_key_value_pat_prop(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_key_value_pat_prop(self, node),
        }
    }

    fn fold_key_value_prop(&mut self, node: KeyValueProp) -> KeyValueProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_key_value_prop(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_key_value_prop(self, node),
        }
    }

    fn fold_labeled_stmt(&mut self, node: LabeledStmt) -> LabeledStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_labeled_stmt(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_labeled_stmt(self, node),
        }
    }

    fn fold_lit(&mut self, node: Lit) -> Lit {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_lit(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_lit(self, node),
        }
    }

    fn fold_member_expr(&mut self, node: MemberExpr) -> MemberExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_member_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_member_expr(self, node),
        }
    }

    fn fold_member_prop(&mut self, node: MemberProp) -> MemberProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_member_prop(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_member_prop(self, node),
        }
    }

    fn fold_meta_prop_expr(&mut self, node: MetaPropExpr) -> MetaPropExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_meta_prop_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_meta_prop_expr(self, node),
        }
    }

    fn fold_meta_prop_kind(&mut self, node: MetaPropKind) -> MetaPropKind {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_meta_prop_kind(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_meta_prop_kind(self, node),
        }
    }

    fn fold_method_kind(&mut self, node: MethodKind) -> MethodKind {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_method_kind(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_method_kind(self, node),
        }
    }

    fn fold_method_prop(&mut self, node: MethodProp) -> MethodProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_method_prop(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_method_prop(self, node),
        }
    }

    fn fold_module(&mut self, node: Module) -> Module {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_module(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_module(self, node),
        }
    }

    fn fold_module_decl(&mut self, node: ModuleDecl) -> ModuleDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_module_decl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_module_decl(self, node),
        }
    }

    fn fold_module_export_name(&mut self, node: ModuleExportName) -> ModuleExportName {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_module_export_name(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_module_export_name(self, node),
        }
    }

    fn fold_module_item(&mut self, node: ModuleItem) -> ModuleItem {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_module_item(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_module_item(self, node),
        }
    }

    fn fold_module_items(&mut self, node: Vec<ModuleItem>) -> Vec<ModuleItem> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_module_items(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_module_items(self, node),
        }
    }

    fn fold_named_export(&mut self, node: NamedExport) -> NamedExport {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_named_export(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_named_export(self, node),
        }
    }

    fn fold_new_expr(&mut self, node: NewExpr) -> NewExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_new_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_new_expr(self, node),
        }
    }

    fn fold_null(&mut self, node: Null) -> Null {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_null(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_null(self, node),
        }
    }

    fn fold_number(&mut self, node: Number) -> Number {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_number(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_number(self, node),
        }
    }

    fn fold_object_lit(&mut self, node: ObjectLit) -> ObjectLit {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_object_lit(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_object_lit(self, node),
        }
    }

    fn fold_object_pat(&mut self, node: ObjectPat) -> ObjectPat {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_object_pat(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_object_pat(self, node),
        }
    }

    fn fold_object_pat_prop(&mut self, node: ObjectPatProp) -> ObjectPatProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_object_pat_prop(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_object_pat_prop(self, node),
        }
    }

    fn fold_object_pat_props(&mut self, node: Vec<ObjectPatProp>) -> Vec<ObjectPatProp> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_object_pat_props(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_object_pat_props(self, node),
        }
    }

    fn fold_opt_accessibility(&mut self, node: Option<Accessibility>) -> Option<Accessibility> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_accessibility(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_accessibility(self, node),
        }
    }

    fn fold_opt_atom(&mut self, node: Option<swc_atoms::Atom>) -> Option<swc_atoms::Atom> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_atom(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_atom(self, node),
        }
    }

    fn fold_opt_block_stmt(&mut self, node: Option<BlockStmt>) -> Option<BlockStmt> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_block_stmt(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_block_stmt(self, node),
        }
    }

    fn fold_opt_call(&mut self, node: OptCall) -> OptCall {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_call(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_call(self, node),
        }
    }

    fn fold_opt_catch_clause(&mut self, node: Option<CatchClause>) -> Option<CatchClause> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_catch_clause(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_catch_clause(self, node),
        }
    }

    fn fold_opt_chain_base(&mut self, node: OptChainBase) -> OptChainBase {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_chain_base(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_chain_base(self, node),
        }
    }

    fn fold_opt_chain_expr(&mut self, node: OptChainExpr) -> OptChainExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_chain_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_chain_expr(self, node),
        }
    }

    fn fold_opt_expr(&mut self, node: Option<Box<Expr>>) -> Option<Box<Expr>> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_expr(self, node),
        }
    }

    fn fold_opt_expr_or_spread(&mut self, node: Option<ExprOrSpread>) -> Option<ExprOrSpread> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_expr_or_spread(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_expr_or_spread(self, node),
        }
    }

    fn fold_opt_expr_or_spreads(
        &mut self,
        node: Option<Vec<ExprOrSpread>>,
    ) -> Option<Vec<ExprOrSpread>> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_expr_or_spreads(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_expr_or_spreads(self, node),
        }
    }

    fn fold_opt_ident(&mut self, node: Option<Ident>) -> Option<Ident> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_ident(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_ident(self, node),
        }
    }

    fn fold_opt_jsx_attr_value(&mut self, node: Option<JSXAttrValue>) -> Option<JSXAttrValue> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_jsx_attr_value(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_jsx_attr_value(self, node),
        }
    }

    fn fold_opt_jsx_closing_element(
        &mut self,
        node: Option<JSXClosingElement>,
    ) -> Option<JSXClosingElement> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_jsx_closing_element(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_jsx_closing_element(self, node),
        }
    }

    fn fold_opt_module_export_name(
        &mut self,
        node: Option<ModuleExportName>,
    ) -> Option<ModuleExportName> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_module_export_name(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_module_export_name(self, node),
        }
    }

    fn fold_opt_module_items(&mut self, node: Option<Vec<ModuleItem>>) -> Option<Vec<ModuleItem>> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_module_items(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_module_items(self, node),
        }
    }

    fn fold_opt_object_lit(&mut self, node: Option<Box<ObjectLit>>) -> Option<Box<ObjectLit>> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_object_lit(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_object_lit(self, node),
        }
    }

    fn fold_opt_pat(&mut self, node: Option<Pat>) -> Option<Pat> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_pat(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_pat(self, node),
        }
    }

    fn fold_opt_span(&mut self, node: Option<swc_common::Span>) -> Option<swc_common::Span> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_span(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_span(self, node),
        }
    }

    fn fold_opt_stmt(&mut self, node: Option<Box<Stmt>>) -> Option<Box<Stmt>> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_stmt(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_stmt(self, node),
        }
    }

    fn fold_opt_str(&mut self, node: Option<Box<Str>>) -> Option<Box<Str>> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_str(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_str(self, node),
        }
    }

    fn fold_opt_true_plus_minus(&mut self, node: Option<TruePlusMinus>) -> Option<TruePlusMinus> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_true_plus_minus(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_true_plus_minus(self, node),
        }
    }

    fn fold_opt_ts_entity_name(&mut self, node: Option<TsEntityName>) -> Option<TsEntityName> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_ts_entity_name(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_ts_entity_name(self, node),
        }
    }

    fn fold_opt_ts_namespace_body(
        &mut self,
        node: Option<TsNamespaceBody>,
    ) -> Option<TsNamespaceBody> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_ts_namespace_body(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_ts_namespace_body(self, node),
        }
    }

    fn fold_opt_ts_type(&mut self, node: Option<Box<TsType>>) -> Option<Box<TsType>> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_ts_type(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_ts_type(self, node),
        }
    }

    fn fold_opt_ts_type_ann(&mut self, node: Option<Box<TsTypeAnn>>) -> Option<Box<TsTypeAnn>> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_ts_type_ann(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_ts_type_ann(self, node),
        }
    }

    fn fold_opt_ts_type_param_decl(
        &mut self,
        node: Option<Box<TsTypeParamDecl>>,
    ) -> Option<Box<TsTypeParamDecl>> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_ts_type_param_decl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_ts_type_param_decl(self, node),
        }
    }

    fn fold_opt_ts_type_param_instantiation(
        &mut self,
        node: Option<Box<TsTypeParamInstantiation>>,
    ) -> Option<Box<TsTypeParamInstantiation>> {
        match self {
            swc_visit::Either::Left(visitor) => {
                Fold::fold_opt_ts_type_param_instantiation(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                Fold::fold_opt_ts_type_param_instantiation(self, node)
            }
        }
    }

    fn fold_opt_var_decl_or_expr(&mut self, node: Option<VarDeclOrExpr>) -> Option<VarDeclOrExpr> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_var_decl_or_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_var_decl_or_expr(self, node),
        }
    }

    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        node: Vec<Option<ExprOrSpread>>,
    ) -> Vec<Option<ExprOrSpread>> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_vec_expr_or_spreads(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_vec_expr_or_spreads(self, node),
        }
    }

    fn fold_opt_vec_pats(&mut self, node: Vec<Option<Pat>>) -> Vec<Option<Pat>> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_opt_vec_pats(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_opt_vec_pats(self, node),
        }
    }

    fn fold_param(&mut self, node: Param) -> Param {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_param(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_param(self, node),
        }
    }

    fn fold_param_or_ts_param_prop(&mut self, node: ParamOrTsParamProp) -> ParamOrTsParamProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_param_or_ts_param_prop(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_param_or_ts_param_prop(self, node),
        }
    }

    fn fold_param_or_ts_param_props(
        &mut self,
        node: Vec<ParamOrTsParamProp>,
    ) -> Vec<ParamOrTsParamProp> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_param_or_ts_param_props(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_param_or_ts_param_props(self, node),
        }
    }

    fn fold_params(&mut self, node: Vec<Param>) -> Vec<Param> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_params(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_params(self, node),
        }
    }

    fn fold_paren_expr(&mut self, node: ParenExpr) -> ParenExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_paren_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_paren_expr(self, node),
        }
    }

    fn fold_pat(&mut self, node: Pat) -> Pat {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_pat(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_pat(self, node),
        }
    }

    fn fold_pats(&mut self, node: Vec<Pat>) -> Vec<Pat> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_pats(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_pats(self, node),
        }
    }

    fn fold_private_method(&mut self, node: PrivateMethod) -> PrivateMethod {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_private_method(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_private_method(self, node),
        }
    }

    fn fold_private_name(&mut self, node: PrivateName) -> PrivateName {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_private_name(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_private_name(self, node),
        }
    }

    fn fold_private_prop(&mut self, node: PrivateProp) -> PrivateProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_private_prop(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_private_prop(self, node),
        }
    }

    fn fold_program(&mut self, node: Program) -> Program {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_program(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_program(self, node),
        }
    }

    fn fold_prop(&mut self, node: Prop) -> Prop {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_prop(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_prop(self, node),
        }
    }

    fn fold_prop_name(&mut self, node: PropName) -> PropName {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_prop_name(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_prop_name(self, node),
        }
    }

    fn fold_prop_or_spread(&mut self, node: PropOrSpread) -> PropOrSpread {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_prop_or_spread(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_prop_or_spread(self, node),
        }
    }

    fn fold_prop_or_spreads(&mut self, node: Vec<PropOrSpread>) -> Vec<PropOrSpread> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_prop_or_spreads(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_prop_or_spreads(self, node),
        }
    }

    fn fold_regex(&mut self, node: Regex) -> Regex {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_regex(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_regex(self, node),
        }
    }

    fn fold_reserved_unused(&mut self, node: ReservedUnused) -> ReservedUnused {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_reserved_unused(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_reserved_unused(self, node),
        }
    }

    fn fold_rest_pat(&mut self, node: RestPat) -> RestPat {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_rest_pat(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_rest_pat(self, node),
        }
    }

    fn fold_return_stmt(&mut self, node: ReturnStmt) -> ReturnStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_return_stmt(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_return_stmt(self, node),
        }
    }

    fn fold_script(&mut self, node: Script) -> Script {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_script(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_script(self, node),
        }
    }

    fn fold_seq_expr(&mut self, node: SeqExpr) -> SeqExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_seq_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_seq_expr(self, node),
        }
    }

    fn fold_setter_prop(&mut self, node: SetterProp) -> SetterProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_setter_prop(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_setter_prop(self, node),
        }
    }

    fn fold_simple_assign_target(&mut self, node: SimpleAssignTarget) -> SimpleAssignTarget {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_simple_assign_target(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_simple_assign_target(self, node),
        }
    }

    fn fold_span(&mut self, node: swc_common::Span) -> swc_common::Span {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_span(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_span(self, node),
        }
    }

    fn fold_spread_element(&mut self, node: SpreadElement) -> SpreadElement {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_spread_element(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_spread_element(self, node),
        }
    }

    fn fold_static_block(&mut self, node: StaticBlock) -> StaticBlock {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_static_block(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_static_block(self, node),
        }
    }

    fn fold_stmt(&mut self, node: Stmt) -> Stmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_stmt(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_stmt(self, node),
        }
    }

    fn fold_stmts(&mut self, node: Vec<Stmt>) -> Vec<Stmt> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_stmts(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_stmts(self, node),
        }
    }

    fn fold_str(&mut self, node: Str) -> Str {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_str(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_str(self, node),
        }
    }

    fn fold_super(&mut self, node: Super) -> Super {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_super(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_super(self, node),
        }
    }

    fn fold_super_prop(&mut self, node: SuperProp) -> SuperProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_super_prop(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_super_prop(self, node),
        }
    }

    fn fold_super_prop_expr(&mut self, node: SuperPropExpr) -> SuperPropExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_super_prop_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_super_prop_expr(self, node),
        }
    }

    fn fold_switch_case(&mut self, node: SwitchCase) -> SwitchCase {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_switch_case(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_switch_case(self, node),
        }
    }

    fn fold_switch_cases(&mut self, node: Vec<SwitchCase>) -> Vec<SwitchCase> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_switch_cases(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_switch_cases(self, node),
        }
    }

    fn fold_switch_stmt(&mut self, node: SwitchStmt) -> SwitchStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_switch_stmt(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_switch_stmt(self, node),
        }
    }

    fn fold_syntax_context(
        &mut self,
        node: swc_common::SyntaxContext,
    ) -> swc_common::SyntaxContext {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_syntax_context(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_syntax_context(self, node),
        }
    }

    fn fold_tagged_tpl(&mut self, node: TaggedTpl) -> TaggedTpl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_tagged_tpl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_tagged_tpl(self, node),
        }
    }

    fn fold_this_expr(&mut self, node: ThisExpr) -> ThisExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_this_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_this_expr(self, node),
        }
    }

    fn fold_throw_stmt(&mut self, node: ThrowStmt) -> ThrowStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_throw_stmt(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_throw_stmt(self, node),
        }
    }

    fn fold_tpl(&mut self, node: Tpl) -> Tpl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_tpl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_tpl(self, node),
        }
    }

    fn fold_tpl_element(&mut self, node: TplElement) -> TplElement {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_tpl_element(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_tpl_element(self, node),
        }
    }

    fn fold_tpl_elements(&mut self, node: Vec<TplElement>) -> Vec<TplElement> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_tpl_elements(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_tpl_elements(self, node),
        }
    }

    fn fold_true_plus_minus(&mut self, node: TruePlusMinus) -> TruePlusMinus {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_true_plus_minus(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_true_plus_minus(self, node),
        }
    }

    fn fold_try_stmt(&mut self, node: TryStmt) -> TryStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_try_stmt(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_try_stmt(self, node),
        }
    }

    fn fold_ts_array_type(&mut self, node: TsArrayType) -> TsArrayType {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_array_type(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_array_type(self, node),
        }
    }

    fn fold_ts_as_expr(&mut self, node: TsAsExpr) -> TsAsExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_as_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_as_expr(self, node),
        }
    }

    fn fold_ts_call_signature_decl(&mut self, node: TsCallSignatureDecl) -> TsCallSignatureDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_call_signature_decl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_call_signature_decl(self, node),
        }
    }

    fn fold_ts_conditional_type(&mut self, node: TsConditionalType) -> TsConditionalType {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_conditional_type(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_conditional_type(self, node),
        }
    }

    fn fold_ts_const_assertion(&mut self, node: TsConstAssertion) -> TsConstAssertion {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_const_assertion(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_const_assertion(self, node),
        }
    }

    fn fold_ts_construct_signature_decl(
        &mut self,
        node: TsConstructSignatureDecl,
    ) -> TsConstructSignatureDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_construct_signature_decl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_construct_signature_decl(self, node),
        }
    }

    fn fold_ts_constructor_type(&mut self, node: TsConstructorType) -> TsConstructorType {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_constructor_type(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_constructor_type(self, node),
        }
    }

    fn fold_ts_entity_name(&mut self, node: TsEntityName) -> TsEntityName {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_entity_name(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_entity_name(self, node),
        }
    }

    fn fold_ts_enum_decl(&mut self, node: TsEnumDecl) -> TsEnumDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_enum_decl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_enum_decl(self, node),
        }
    }

    fn fold_ts_enum_member(&mut self, node: TsEnumMember) -> TsEnumMember {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_enum_member(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_enum_member(self, node),
        }
    }

    fn fold_ts_enum_member_id(&mut self, node: TsEnumMemberId) -> TsEnumMemberId {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_enum_member_id(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_enum_member_id(self, node),
        }
    }

    fn fold_ts_enum_members(&mut self, node: Vec<TsEnumMember>) -> Vec<TsEnumMember> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_enum_members(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_enum_members(self, node),
        }
    }

    fn fold_ts_export_assignment(&mut self, node: TsExportAssignment) -> TsExportAssignment {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_export_assignment(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_export_assignment(self, node),
        }
    }

    fn fold_ts_expr_with_type_args(&mut self, node: TsExprWithTypeArgs) -> TsExprWithTypeArgs {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_expr_with_type_args(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_expr_with_type_args(self, node),
        }
    }

    fn fold_ts_expr_with_type_argss(
        &mut self,
        node: Vec<TsExprWithTypeArgs>,
    ) -> Vec<TsExprWithTypeArgs> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_expr_with_type_argss(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_expr_with_type_argss(self, node),
        }
    }

    fn fold_ts_external_module_ref(&mut self, node: TsExternalModuleRef) -> TsExternalModuleRef {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_external_module_ref(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_external_module_ref(self, node),
        }
    }

    fn fold_ts_fn_or_constructor_type(
        &mut self,
        node: TsFnOrConstructorType,
    ) -> TsFnOrConstructorType {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_fn_or_constructor_type(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_fn_or_constructor_type(self, node),
        }
    }

    fn fold_ts_fn_param(&mut self, node: TsFnParam) -> TsFnParam {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_fn_param(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_fn_param(self, node),
        }
    }

    fn fold_ts_fn_params(&mut self, node: Vec<TsFnParam>) -> Vec<TsFnParam> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_fn_params(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_fn_params(self, node),
        }
    }

    fn fold_ts_fn_type(&mut self, node: TsFnType) -> TsFnType {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_fn_type(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_fn_type(self, node),
        }
    }

    fn fold_ts_getter_signature(&mut self, node: TsGetterSignature) -> TsGetterSignature {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_getter_signature(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_getter_signature(self, node),
        }
    }

    fn fold_ts_import_equals_decl(&mut self, node: TsImportEqualsDecl) -> TsImportEqualsDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_import_equals_decl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_import_equals_decl(self, node),
        }
    }

    fn fold_ts_import_type(&mut self, node: TsImportType) -> TsImportType {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_import_type(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_import_type(self, node),
        }
    }

    fn fold_ts_index_signature(&mut self, node: TsIndexSignature) -> TsIndexSignature {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_index_signature(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_index_signature(self, node),
        }
    }

    fn fold_ts_indexed_access_type(&mut self, node: TsIndexedAccessType) -> TsIndexedAccessType {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_indexed_access_type(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_indexed_access_type(self, node),
        }
    }

    fn fold_ts_infer_type(&mut self, node: TsInferType) -> TsInferType {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_infer_type(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_infer_type(self, node),
        }
    }

    fn fold_ts_instantiation(&mut self, node: TsInstantiation) -> TsInstantiation {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_instantiation(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_instantiation(self, node),
        }
    }

    fn fold_ts_interface_body(&mut self, node: TsInterfaceBody) -> TsInterfaceBody {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_interface_body(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_interface_body(self, node),
        }
    }

    fn fold_ts_interface_decl(&mut self, node: TsInterfaceDecl) -> TsInterfaceDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_interface_decl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_interface_decl(self, node),
        }
    }

    fn fold_ts_intersection_type(&mut self, node: TsIntersectionType) -> TsIntersectionType {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_intersection_type(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_intersection_type(self, node),
        }
    }

    fn fold_ts_keyword_type(&mut self, node: TsKeywordType) -> TsKeywordType {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_keyword_type(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_keyword_type(self, node),
        }
    }

    fn fold_ts_keyword_type_kind(&mut self, node: TsKeywordTypeKind) -> TsKeywordTypeKind {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_keyword_type_kind(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_keyword_type_kind(self, node),
        }
    }

    fn fold_ts_lit(&mut self, node: TsLit) -> TsLit {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_lit(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_lit(self, node),
        }
    }

    fn fold_ts_lit_type(&mut self, node: TsLitType) -> TsLitType {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_lit_type(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_lit_type(self, node),
        }
    }

    fn fold_ts_mapped_type(&mut self, node: TsMappedType) -> TsMappedType {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_mapped_type(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_mapped_type(self, node),
        }
    }

    fn fold_ts_method_signature(&mut self, node: TsMethodSignature) -> TsMethodSignature {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_method_signature(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_method_signature(self, node),
        }
    }

    fn fold_ts_module_block(&mut self, node: TsModuleBlock) -> TsModuleBlock {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_module_block(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_module_block(self, node),
        }
    }

    fn fold_ts_module_decl(&mut self, node: TsModuleDecl) -> TsModuleDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_module_decl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_module_decl(self, node),
        }
    }

    fn fold_ts_module_name(&mut self, node: TsModuleName) -> TsModuleName {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_module_name(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_module_name(self, node),
        }
    }

    fn fold_ts_module_ref(&mut self, node: TsModuleRef) -> TsModuleRef {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_module_ref(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_module_ref(self, node),
        }
    }

    fn fold_ts_namespace_body(&mut self, node: TsNamespaceBody) -> TsNamespaceBody {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_namespace_body(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_namespace_body(self, node),
        }
    }

    fn fold_ts_namespace_decl(&mut self, node: TsNamespaceDecl) -> TsNamespaceDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_namespace_decl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_namespace_decl(self, node),
        }
    }

    fn fold_ts_namespace_export_decl(
        &mut self,
        node: TsNamespaceExportDecl,
    ) -> TsNamespaceExportDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_namespace_export_decl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_namespace_export_decl(self, node),
        }
    }

    fn fold_ts_non_null_expr(&mut self, node: TsNonNullExpr) -> TsNonNullExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_non_null_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_non_null_expr(self, node),
        }
    }

    fn fold_ts_optional_type(&mut self, node: TsOptionalType) -> TsOptionalType {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_optional_type(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_optional_type(self, node),
        }
    }

    fn fold_ts_param_prop(&mut self, node: TsParamProp) -> TsParamProp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_param_prop(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_param_prop(self, node),
        }
    }

    fn fold_ts_param_prop_param(&mut self, node: TsParamPropParam) -> TsParamPropParam {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_param_prop_param(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_param_prop_param(self, node),
        }
    }

    fn fold_ts_parenthesized_type(&mut self, node: TsParenthesizedType) -> TsParenthesizedType {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_parenthesized_type(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_parenthesized_type(self, node),
        }
    }

    fn fold_ts_property_signature(&mut self, node: TsPropertySignature) -> TsPropertySignature {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_property_signature(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_property_signature(self, node),
        }
    }

    fn fold_ts_qualified_name(&mut self, node: TsQualifiedName) -> TsQualifiedName {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_qualified_name(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_qualified_name(self, node),
        }
    }

    fn fold_ts_rest_type(&mut self, node: TsRestType) -> TsRestType {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_rest_type(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_rest_type(self, node),
        }
    }

    fn fold_ts_satisfies_expr(&mut self, node: TsSatisfiesExpr) -> TsSatisfiesExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_satisfies_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_satisfies_expr(self, node),
        }
    }

    fn fold_ts_setter_signature(&mut self, node: TsSetterSignature) -> TsSetterSignature {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_setter_signature(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_setter_signature(self, node),
        }
    }

    fn fold_ts_this_type(&mut self, node: TsThisType) -> TsThisType {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_this_type(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_this_type(self, node),
        }
    }

    fn fold_ts_this_type_or_ident(&mut self, node: TsThisTypeOrIdent) -> TsThisTypeOrIdent {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_this_type_or_ident(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_this_type_or_ident(self, node),
        }
    }

    fn fold_ts_tpl_lit_type(&mut self, node: TsTplLitType) -> TsTplLitType {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_tpl_lit_type(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_tpl_lit_type(self, node),
        }
    }

    fn fold_ts_tuple_element(&mut self, node: TsTupleElement) -> TsTupleElement {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_tuple_element(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_tuple_element(self, node),
        }
    }

    fn fold_ts_tuple_elements(&mut self, node: Vec<TsTupleElement>) -> Vec<TsTupleElement> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_tuple_elements(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_tuple_elements(self, node),
        }
    }

    fn fold_ts_tuple_type(&mut self, node: TsTupleType) -> TsTupleType {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_tuple_type(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_tuple_type(self, node),
        }
    }

    fn fold_ts_type(&mut self, node: TsType) -> TsType {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_type(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_type(self, node),
        }
    }

    fn fold_ts_type_alias_decl(&mut self, node: TsTypeAliasDecl) -> TsTypeAliasDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_type_alias_decl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_type_alias_decl(self, node),
        }
    }

    fn fold_ts_type_ann(&mut self, node: TsTypeAnn) -> TsTypeAnn {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_type_ann(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_type_ann(self, node),
        }
    }

    fn fold_ts_type_assertion(&mut self, node: TsTypeAssertion) -> TsTypeAssertion {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_type_assertion(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_type_assertion(self, node),
        }
    }

    fn fold_ts_type_element(&mut self, node: TsTypeElement) -> TsTypeElement {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_type_element(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_type_element(self, node),
        }
    }

    fn fold_ts_type_elements(&mut self, node: Vec<TsTypeElement>) -> Vec<TsTypeElement> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_type_elements(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_type_elements(self, node),
        }
    }

    fn fold_ts_type_lit(&mut self, node: TsTypeLit) -> TsTypeLit {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_type_lit(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_type_lit(self, node),
        }
    }

    fn fold_ts_type_operator(&mut self, node: TsTypeOperator) -> TsTypeOperator {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_type_operator(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_type_operator(self, node),
        }
    }

    fn fold_ts_type_operator_op(&mut self, node: TsTypeOperatorOp) -> TsTypeOperatorOp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_type_operator_op(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_type_operator_op(self, node),
        }
    }

    fn fold_ts_type_param(&mut self, node: TsTypeParam) -> TsTypeParam {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_type_param(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_type_param(self, node),
        }
    }

    fn fold_ts_type_param_decl(&mut self, node: TsTypeParamDecl) -> TsTypeParamDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_type_param_decl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_type_param_decl(self, node),
        }
    }

    fn fold_ts_type_param_instantiation(
        &mut self,
        node: TsTypeParamInstantiation,
    ) -> TsTypeParamInstantiation {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_type_param_instantiation(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_type_param_instantiation(self, node),
        }
    }

    fn fold_ts_type_params(&mut self, node: Vec<TsTypeParam>) -> Vec<TsTypeParam> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_type_params(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_type_params(self, node),
        }
    }

    fn fold_ts_type_predicate(&mut self, node: TsTypePredicate) -> TsTypePredicate {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_type_predicate(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_type_predicate(self, node),
        }
    }

    fn fold_ts_type_query(&mut self, node: TsTypeQuery) -> TsTypeQuery {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_type_query(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_type_query(self, node),
        }
    }

    fn fold_ts_type_query_expr(&mut self, node: TsTypeQueryExpr) -> TsTypeQueryExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_type_query_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_type_query_expr(self, node),
        }
    }

    fn fold_ts_type_ref(&mut self, node: TsTypeRef) -> TsTypeRef {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_type_ref(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_type_ref(self, node),
        }
    }

    fn fold_ts_types(&mut self, node: Vec<Box<TsType>>) -> Vec<Box<TsType>> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_types(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_types(self, node),
        }
    }

    fn fold_ts_union_or_intersection_type(
        &mut self,
        node: TsUnionOrIntersectionType,
    ) -> TsUnionOrIntersectionType {
        match self {
            swc_visit::Either::Left(visitor) => {
                Fold::fold_ts_union_or_intersection_type(self, node)
            }
            swc_visit::Either::Right(visitor) => {
                Fold::fold_ts_union_or_intersection_type(self, node)
            }
        }
    }

    fn fold_ts_union_type(&mut self, node: TsUnionType) -> TsUnionType {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_ts_union_type(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_ts_union_type(self, node),
        }
    }

    fn fold_unary_expr(&mut self, node: UnaryExpr) -> UnaryExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_unary_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_unary_expr(self, node),
        }
    }

    fn fold_unary_op(&mut self, node: UnaryOp) -> UnaryOp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_unary_op(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_unary_op(self, node),
        }
    }

    fn fold_update_expr(&mut self, node: UpdateExpr) -> UpdateExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_update_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_update_expr(self, node),
        }
    }

    fn fold_update_op(&mut self, node: UpdateOp) -> UpdateOp {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_update_op(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_update_op(self, node),
        }
    }

    fn fold_using_decl(&mut self, node: UsingDecl) -> UsingDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_using_decl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_using_decl(self, node),
        }
    }

    fn fold_var_decl(&mut self, node: VarDecl) -> VarDecl {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_var_decl(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_var_decl(self, node),
        }
    }

    fn fold_var_decl_kind(&mut self, node: VarDeclKind) -> VarDeclKind {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_var_decl_kind(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_var_decl_kind(self, node),
        }
    }

    fn fold_var_decl_or_expr(&mut self, node: VarDeclOrExpr) -> VarDeclOrExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_var_decl_or_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_var_decl_or_expr(self, node),
        }
    }

    fn fold_var_declarator(&mut self, node: VarDeclarator) -> VarDeclarator {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_var_declarator(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_var_declarator(self, node),
        }
    }

    fn fold_var_declarators(&mut self, node: Vec<VarDeclarator>) -> Vec<VarDeclarator> {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_var_declarators(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_var_declarators(self, node),
        }
    }

    fn fold_while_stmt(&mut self, node: WhileStmt) -> WhileStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_while_stmt(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_while_stmt(self, node),
        }
    }

    fn fold_with_stmt(&mut self, node: WithStmt) -> WithStmt {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_with_stmt(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_with_stmt(self, node),
        }
    }

    fn fold_yield_expr(&mut self, node: YieldExpr) -> YieldExpr {
        match self {
            swc_visit::Either::Left(visitor) => Fold::fold_yield_expr(self, node),
            swc_visit::Either::Right(visitor) => Fold::fold_yield_expr(self, node),
        }
    }
}
impl<V> Fold for ::swc_visit::Optional<V>
where
    V: Fold,
{
    fn fold_accessibility(&mut self, node: Accessibility) -> Accessibility {
        if self.enabled {
            Fold::fold_accessibility(self, node)
        } else {
            node
        }
    }

    fn fold_array_lit(&mut self, node: ArrayLit) -> ArrayLit {
        if self.enabled {
            Fold::fold_array_lit(self, node)
        } else {
            node
        }
    }

    fn fold_array_pat(&mut self, node: ArrayPat) -> ArrayPat {
        if self.enabled {
            Fold::fold_array_pat(self, node)
        } else {
            node
        }
    }

    fn fold_arrow_expr(&mut self, node: ArrowExpr) -> ArrowExpr {
        if self.enabled {
            Fold::fold_arrow_expr(self, node)
        } else {
            node
        }
    }

    fn fold_assign_expr(&mut self, node: AssignExpr) -> AssignExpr {
        if self.enabled {
            Fold::fold_assign_expr(self, node)
        } else {
            node
        }
    }

    fn fold_assign_op(&mut self, node: AssignOp) -> AssignOp {
        if self.enabled {
            Fold::fold_assign_op(self, node)
        } else {
            node
        }
    }

    fn fold_assign_pat(&mut self, node: AssignPat) -> AssignPat {
        if self.enabled {
            Fold::fold_assign_pat(self, node)
        } else {
            node
        }
    }

    fn fold_assign_pat_prop(&mut self, node: AssignPatProp) -> AssignPatProp {
        if self.enabled {
            Fold::fold_assign_pat_prop(self, node)
        } else {
            node
        }
    }

    fn fold_assign_prop(&mut self, node: AssignProp) -> AssignProp {
        if self.enabled {
            Fold::fold_assign_prop(self, node)
        } else {
            node
        }
    }

    fn fold_assign_target(&mut self, node: AssignTarget) -> AssignTarget {
        if self.enabled {
            Fold::fold_assign_target(self, node)
        } else {
            node
        }
    }

    fn fold_assign_target_pat(&mut self, node: AssignTargetPat) -> AssignTargetPat {
        if self.enabled {
            Fold::fold_assign_target_pat(self, node)
        } else {
            node
        }
    }

    fn fold_atom(&mut self, node: swc_atoms::Atom) -> swc_atoms::Atom {
        if self.enabled {
            Fold::fold_atom(self, node)
        } else {
            node
        }
    }

    fn fold_auto_accessor(&mut self, node: AutoAccessor) -> AutoAccessor {
        if self.enabled {
            Fold::fold_auto_accessor(self, node)
        } else {
            node
        }
    }

    fn fold_await_expr(&mut self, node: AwaitExpr) -> AwaitExpr {
        if self.enabled {
            Fold::fold_await_expr(self, node)
        } else {
            node
        }
    }

    fn fold_big_int(&mut self, node: BigInt) -> BigInt {
        if self.enabled {
            Fold::fold_big_int(self, node)
        } else {
            node
        }
    }

    fn fold_big_int_value(&mut self, node: BigIntValue) -> BigIntValue {
        if self.enabled {
            Fold::fold_big_int_value(self, node)
        } else {
            node
        }
    }

    fn fold_bin_expr(&mut self, node: BinExpr) -> BinExpr {
        if self.enabled {
            Fold::fold_bin_expr(self, node)
        } else {
            node
        }
    }

    fn fold_binary_op(&mut self, node: BinaryOp) -> BinaryOp {
        if self.enabled {
            Fold::fold_binary_op(self, node)
        } else {
            node
        }
    }

    fn fold_binding_ident(&mut self, node: BindingIdent) -> BindingIdent {
        if self.enabled {
            Fold::fold_binding_ident(self, node)
        } else {
            node
        }
    }

    fn fold_block_stmt(&mut self, node: BlockStmt) -> BlockStmt {
        if self.enabled {
            Fold::fold_block_stmt(self, node)
        } else {
            node
        }
    }

    fn fold_block_stmt_or_expr(&mut self, node: BlockStmtOrExpr) -> BlockStmtOrExpr {
        if self.enabled {
            Fold::fold_block_stmt_or_expr(self, node)
        } else {
            node
        }
    }

    fn fold_bool(&mut self, node: Bool) -> Bool {
        if self.enabled {
            Fold::fold_bool(self, node)
        } else {
            node
        }
    }

    fn fold_break_stmt(&mut self, node: BreakStmt) -> BreakStmt {
        if self.enabled {
            Fold::fold_break_stmt(self, node)
        } else {
            node
        }
    }

    fn fold_call_expr(&mut self, node: CallExpr) -> CallExpr {
        if self.enabled {
            Fold::fold_call_expr(self, node)
        } else {
            node
        }
    }

    fn fold_callee(&mut self, node: Callee) -> Callee {
        if self.enabled {
            Fold::fold_callee(self, node)
        } else {
            node
        }
    }

    fn fold_catch_clause(&mut self, node: CatchClause) -> CatchClause {
        if self.enabled {
            Fold::fold_catch_clause(self, node)
        } else {
            node
        }
    }

    fn fold_class(&mut self, node: Class) -> Class {
        if self.enabled {
            Fold::fold_class(self, node)
        } else {
            node
        }
    }

    fn fold_class_decl(&mut self, node: ClassDecl) -> ClassDecl {
        if self.enabled {
            Fold::fold_class_decl(self, node)
        } else {
            node
        }
    }

    fn fold_class_expr(&mut self, node: ClassExpr) -> ClassExpr {
        if self.enabled {
            Fold::fold_class_expr(self, node)
        } else {
            node
        }
    }

    fn fold_class_member(&mut self, node: ClassMember) -> ClassMember {
        if self.enabled {
            Fold::fold_class_member(self, node)
        } else {
            node
        }
    }

    fn fold_class_members(&mut self, node: Vec<ClassMember>) -> Vec<ClassMember> {
        if self.enabled {
            Fold::fold_class_members(self, node)
        } else {
            node
        }
    }

    fn fold_class_method(&mut self, node: ClassMethod) -> ClassMethod {
        if self.enabled {
            Fold::fold_class_method(self, node)
        } else {
            node
        }
    }

    fn fold_class_prop(&mut self, node: ClassProp) -> ClassProp {
        if self.enabled {
            Fold::fold_class_prop(self, node)
        } else {
            node
        }
    }

    fn fold_computed_prop_name(&mut self, node: ComputedPropName) -> ComputedPropName {
        if self.enabled {
            Fold::fold_computed_prop_name(self, node)
        } else {
            node
        }
    }

    fn fold_cond_expr(&mut self, node: CondExpr) -> CondExpr {
        if self.enabled {
            Fold::fold_cond_expr(self, node)
        } else {
            node
        }
    }

    fn fold_constructor(&mut self, node: Constructor) -> Constructor {
        if self.enabled {
            Fold::fold_constructor(self, node)
        } else {
            node
        }
    }

    fn fold_continue_stmt(&mut self, node: ContinueStmt) -> ContinueStmt {
        if self.enabled {
            Fold::fold_continue_stmt(self, node)
        } else {
            node
        }
    }

    fn fold_debugger_stmt(&mut self, node: DebuggerStmt) -> DebuggerStmt {
        if self.enabled {
            Fold::fold_debugger_stmt(self, node)
        } else {
            node
        }
    }

    fn fold_decl(&mut self, node: Decl) -> Decl {
        if self.enabled {
            Fold::fold_decl(self, node)
        } else {
            node
        }
    }

    fn fold_decorator(&mut self, node: Decorator) -> Decorator {
        if self.enabled {
            Fold::fold_decorator(self, node)
        } else {
            node
        }
    }

    fn fold_decorators(&mut self, node: Vec<Decorator>) -> Vec<Decorator> {
        if self.enabled {
            Fold::fold_decorators(self, node)
        } else {
            node
        }
    }

    fn fold_default_decl(&mut self, node: DefaultDecl) -> DefaultDecl {
        if self.enabled {
            Fold::fold_default_decl(self, node)
        } else {
            node
        }
    }

    fn fold_do_while_stmt(&mut self, node: DoWhileStmt) -> DoWhileStmt {
        if self.enabled {
            Fold::fold_do_while_stmt(self, node)
        } else {
            node
        }
    }

    fn fold_empty_stmt(&mut self, node: EmptyStmt) -> EmptyStmt {
        if self.enabled {
            Fold::fold_empty_stmt(self, node)
        } else {
            node
        }
    }

    fn fold_es_version(&mut self, node: EsVersion) -> EsVersion {
        if self.enabled {
            Fold::fold_es_version(self, node)
        } else {
            node
        }
    }

    fn fold_export_all(&mut self, node: ExportAll) -> ExportAll {
        if self.enabled {
            Fold::fold_export_all(self, node)
        } else {
            node
        }
    }

    fn fold_export_decl(&mut self, node: ExportDecl) -> ExportDecl {
        if self.enabled {
            Fold::fold_export_decl(self, node)
        } else {
            node
        }
    }

    fn fold_export_default_decl(&mut self, node: ExportDefaultDecl) -> ExportDefaultDecl {
        if self.enabled {
            Fold::fold_export_default_decl(self, node)
        } else {
            node
        }
    }

    fn fold_export_default_expr(&mut self, node: ExportDefaultExpr) -> ExportDefaultExpr {
        if self.enabled {
            Fold::fold_export_default_expr(self, node)
        } else {
            node
        }
    }

    fn fold_export_default_specifier(
        &mut self,
        node: ExportDefaultSpecifier,
    ) -> ExportDefaultSpecifier {
        if self.enabled {
            Fold::fold_export_default_specifier(self, node)
        } else {
            node
        }
    }

    fn fold_export_named_specifier(&mut self, node: ExportNamedSpecifier) -> ExportNamedSpecifier {
        if self.enabled {
            Fold::fold_export_named_specifier(self, node)
        } else {
            node
        }
    }

    fn fold_export_namespace_specifier(
        &mut self,
        node: ExportNamespaceSpecifier,
    ) -> ExportNamespaceSpecifier {
        if self.enabled {
            Fold::fold_export_namespace_specifier(self, node)
        } else {
            node
        }
    }

    fn fold_export_specifier(&mut self, node: ExportSpecifier) -> ExportSpecifier {
        if self.enabled {
            Fold::fold_export_specifier(self, node)
        } else {
            node
        }
    }

    fn fold_export_specifiers(&mut self, node: Vec<ExportSpecifier>) -> Vec<ExportSpecifier> {
        if self.enabled {
            Fold::fold_export_specifiers(self, node)
        } else {
            node
        }
    }

    fn fold_expr(&mut self, node: Expr) -> Expr {
        if self.enabled {
            Fold::fold_expr(self, node)
        } else {
            node
        }
    }

    fn fold_expr_or_spread(&mut self, node: ExprOrSpread) -> ExprOrSpread {
        if self.enabled {
            Fold::fold_expr_or_spread(self, node)
        } else {
            node
        }
    }

    fn fold_expr_or_spreads(&mut self, node: Vec<ExprOrSpread>) -> Vec<ExprOrSpread> {
        if self.enabled {
            Fold::fold_expr_or_spreads(self, node)
        } else {
            node
        }
    }

    fn fold_expr_stmt(&mut self, node: ExprStmt) -> ExprStmt {
        if self.enabled {
            Fold::fold_expr_stmt(self, node)
        } else {
            node
        }
    }

    fn fold_exprs(&mut self, node: Vec<Box<Expr>>) -> Vec<Box<Expr>> {
        if self.enabled {
            Fold::fold_exprs(self, node)
        } else {
            node
        }
    }

    fn fold_fn_decl(&mut self, node: FnDecl) -> FnDecl {
        if self.enabled {
            Fold::fold_fn_decl(self, node)
        } else {
            node
        }
    }

    fn fold_fn_expr(&mut self, node: FnExpr) -> FnExpr {
        if self.enabled {
            Fold::fold_fn_expr(self, node)
        } else {
            node
        }
    }

    fn fold_for_head(&mut self, node: ForHead) -> ForHead {
        if self.enabled {
            Fold::fold_for_head(self, node)
        } else {
            node
        }
    }

    fn fold_for_in_stmt(&mut self, node: ForInStmt) -> ForInStmt {
        if self.enabled {
            Fold::fold_for_in_stmt(self, node)
        } else {
            node
        }
    }

    fn fold_for_of_stmt(&mut self, node: ForOfStmt) -> ForOfStmt {
        if self.enabled {
            Fold::fold_for_of_stmt(self, node)
        } else {
            node
        }
    }

    fn fold_for_stmt(&mut self, node: ForStmt) -> ForStmt {
        if self.enabled {
            Fold::fold_for_stmt(self, node)
        } else {
            node
        }
    }

    fn fold_function(&mut self, node: Function) -> Function {
        if self.enabled {
            Fold::fold_function(self, node)
        } else {
            node
        }
    }

    fn fold_getter_prop(&mut self, node: GetterProp) -> GetterProp {
        if self.enabled {
            Fold::fold_getter_prop(self, node)
        } else {
            node
        }
    }

    fn fold_ident(&mut self, node: Ident) -> Ident {
        if self.enabled {
            Fold::fold_ident(self, node)
        } else {
            node
        }
    }

    fn fold_ident_name(&mut self, node: IdentName) -> IdentName {
        if self.enabled {
            Fold::fold_ident_name(self, node)
        } else {
            node
        }
    }

    fn fold_if_stmt(&mut self, node: IfStmt) -> IfStmt {
        if self.enabled {
            Fold::fold_if_stmt(self, node)
        } else {
            node
        }
    }

    fn fold_import(&mut self, node: Import) -> Import {
        if self.enabled {
            Fold::fold_import(self, node)
        } else {
            node
        }
    }

    fn fold_import_decl(&mut self, node: ImportDecl) -> ImportDecl {
        if self.enabled {
            Fold::fold_import_decl(self, node)
        } else {
            node
        }
    }

    fn fold_import_default_specifier(
        &mut self,
        node: ImportDefaultSpecifier,
    ) -> ImportDefaultSpecifier {
        if self.enabled {
            Fold::fold_import_default_specifier(self, node)
        } else {
            node
        }
    }

    fn fold_import_named_specifier(&mut self, node: ImportNamedSpecifier) -> ImportNamedSpecifier {
        if self.enabled {
            Fold::fold_import_named_specifier(self, node)
        } else {
            node
        }
    }

    fn fold_import_phase(&mut self, node: ImportPhase) -> ImportPhase {
        if self.enabled {
            Fold::fold_import_phase(self, node)
        } else {
            node
        }
    }

    fn fold_import_specifier(&mut self, node: ImportSpecifier) -> ImportSpecifier {
        if self.enabled {
            Fold::fold_import_specifier(self, node)
        } else {
            node
        }
    }

    fn fold_import_specifiers(&mut self, node: Vec<ImportSpecifier>) -> Vec<ImportSpecifier> {
        if self.enabled {
            Fold::fold_import_specifiers(self, node)
        } else {
            node
        }
    }

    fn fold_import_star_as_specifier(
        &mut self,
        node: ImportStarAsSpecifier,
    ) -> ImportStarAsSpecifier {
        if self.enabled {
            Fold::fold_import_star_as_specifier(self, node)
        } else {
            node
        }
    }

    fn fold_import_with(&mut self, node: ImportWith) -> ImportWith {
        if self.enabled {
            Fold::fold_import_with(self, node)
        } else {
            node
        }
    }

    fn fold_import_with_item(&mut self, node: ImportWithItem) -> ImportWithItem {
        if self.enabled {
            Fold::fold_import_with_item(self, node)
        } else {
            node
        }
    }

    fn fold_import_with_items(&mut self, node: Vec<ImportWithItem>) -> Vec<ImportWithItem> {
        if self.enabled {
            Fold::fold_import_with_items(self, node)
        } else {
            node
        }
    }

    fn fold_invalid(&mut self, node: Invalid) -> Invalid {
        if self.enabled {
            Fold::fold_invalid(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_attr(&mut self, node: JSXAttr) -> JSXAttr {
        if self.enabled {
            Fold::fold_jsx_attr(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_attr_name(&mut self, node: JSXAttrName) -> JSXAttrName {
        if self.enabled {
            Fold::fold_jsx_attr_name(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_attr_or_spread(&mut self, node: JSXAttrOrSpread) -> JSXAttrOrSpread {
        if self.enabled {
            Fold::fold_jsx_attr_or_spread(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_attr_or_spreads(&mut self, node: Vec<JSXAttrOrSpread>) -> Vec<JSXAttrOrSpread> {
        if self.enabled {
            Fold::fold_jsx_attr_or_spreads(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_attr_value(&mut self, node: JSXAttrValue) -> JSXAttrValue {
        if self.enabled {
            Fold::fold_jsx_attr_value(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_closing_element(&mut self, node: JSXClosingElement) -> JSXClosingElement {
        if self.enabled {
            Fold::fold_jsx_closing_element(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_closing_fragment(&mut self, node: JSXClosingFragment) -> JSXClosingFragment {
        if self.enabled {
            Fold::fold_jsx_closing_fragment(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_element(&mut self, node: JSXElement) -> JSXElement {
        if self.enabled {
            Fold::fold_jsx_element(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_element_child(&mut self, node: JSXElementChild) -> JSXElementChild {
        if self.enabled {
            Fold::fold_jsx_element_child(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_element_childs(&mut self, node: Vec<JSXElementChild>) -> Vec<JSXElementChild> {
        if self.enabled {
            Fold::fold_jsx_element_childs(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_element_name(&mut self, node: JSXElementName) -> JSXElementName {
        if self.enabled {
            Fold::fold_jsx_element_name(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_empty_expr(&mut self, node: JSXEmptyExpr) -> JSXEmptyExpr {
        if self.enabled {
            Fold::fold_jsx_empty_expr(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_expr(&mut self, node: JSXExpr) -> JSXExpr {
        if self.enabled {
            Fold::fold_jsx_expr(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_expr_container(&mut self, node: JSXExprContainer) -> JSXExprContainer {
        if self.enabled {
            Fold::fold_jsx_expr_container(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_fragment(&mut self, node: JSXFragment) -> JSXFragment {
        if self.enabled {
            Fold::fold_jsx_fragment(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_member_expr(&mut self, node: JSXMemberExpr) -> JSXMemberExpr {
        if self.enabled {
            Fold::fold_jsx_member_expr(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_namespaced_name(&mut self, node: JSXNamespacedName) -> JSXNamespacedName {
        if self.enabled {
            Fold::fold_jsx_namespaced_name(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_object(&mut self, node: JSXObject) -> JSXObject {
        if self.enabled {
            Fold::fold_jsx_object(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_opening_element(&mut self, node: JSXOpeningElement) -> JSXOpeningElement {
        if self.enabled {
            Fold::fold_jsx_opening_element(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_opening_fragment(&mut self, node: JSXOpeningFragment) -> JSXOpeningFragment {
        if self.enabled {
            Fold::fold_jsx_opening_fragment(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_spread_child(&mut self, node: JSXSpreadChild) -> JSXSpreadChild {
        if self.enabled {
            Fold::fold_jsx_spread_child(self, node)
        } else {
            node
        }
    }

    fn fold_jsx_text(&mut self, node: JSXText) -> JSXText {
        if self.enabled {
            Fold::fold_jsx_text(self, node)
        } else {
            node
        }
    }

    fn fold_key(&mut self, node: Key) -> Key {
        if self.enabled {
            Fold::fold_key(self, node)
        } else {
            node
        }
    }

    fn fold_key_value_pat_prop(&mut self, node: KeyValuePatProp) -> KeyValuePatProp {
        if self.enabled {
            Fold::fold_key_value_pat_prop(self, node)
        } else {
            node
        }
    }

    fn fold_key_value_prop(&mut self, node: KeyValueProp) -> KeyValueProp {
        if self.enabled {
            Fold::fold_key_value_prop(self, node)
        } else {
            node
        }
    }

    fn fold_labeled_stmt(&mut self, node: LabeledStmt) -> LabeledStmt {
        if self.enabled {
            Fold::fold_labeled_stmt(self, node)
        } else {
            node
        }
    }

    fn fold_lit(&mut self, node: Lit) -> Lit {
        if self.enabled {
            Fold::fold_lit(self, node)
        } else {
            node
        }
    }

    fn fold_member_expr(&mut self, node: MemberExpr) -> MemberExpr {
        if self.enabled {
            Fold::fold_member_expr(self, node)
        } else {
            node
        }
    }

    fn fold_member_prop(&mut self, node: MemberProp) -> MemberProp {
        if self.enabled {
            Fold::fold_member_prop(self, node)
        } else {
            node
        }
    }

    fn fold_meta_prop_expr(&mut self, node: MetaPropExpr) -> MetaPropExpr {
        if self.enabled {
            Fold::fold_meta_prop_expr(self, node)
        } else {
            node
        }
    }

    fn fold_meta_prop_kind(&mut self, node: MetaPropKind) -> MetaPropKind {
        if self.enabled {
            Fold::fold_meta_prop_kind(self, node)
        } else {
            node
        }
    }

    fn fold_method_kind(&mut self, node: MethodKind) -> MethodKind {
        if self.enabled {
            Fold::fold_method_kind(self, node)
        } else {
            node
        }
    }

    fn fold_method_prop(&mut self, node: MethodProp) -> MethodProp {
        if self.enabled {
            Fold::fold_method_prop(self, node)
        } else {
            node
        }
    }

    fn fold_module(&mut self, node: Module) -> Module {
        if self.enabled {
            Fold::fold_module(self, node)
        } else {
            node
        }
    }

    fn fold_module_decl(&mut self, node: ModuleDecl) -> ModuleDecl {
        if self.enabled {
            Fold::fold_module_decl(self, node)
        } else {
            node
        }
    }

    fn fold_module_export_name(&mut self, node: ModuleExportName) -> ModuleExportName {
        if self.enabled {
            Fold::fold_module_export_name(self, node)
        } else {
            node
        }
    }

    fn fold_module_item(&mut self, node: ModuleItem) -> ModuleItem {
        if self.enabled {
            Fold::fold_module_item(self, node)
        } else {
            node
        }
    }

    fn fold_module_items(&mut self, node: Vec<ModuleItem>) -> Vec<ModuleItem> {
        if self.enabled {
            Fold::fold_module_items(self, node)
        } else {
            node
        }
    }

    fn fold_named_export(&mut self, node: NamedExport) -> NamedExport {
        if self.enabled {
            Fold::fold_named_export(self, node)
        } else {
            node
        }
    }

    fn fold_new_expr(&mut self, node: NewExpr) -> NewExpr {
        if self.enabled {
            Fold::fold_new_expr(self, node)
        } else {
            node
        }
    }

    fn fold_null(&mut self, node: Null) -> Null {
        if self.enabled {
            Fold::fold_null(self, node)
        } else {
            node
        }
    }

    fn fold_number(&mut self, node: Number) -> Number {
        if self.enabled {
            Fold::fold_number(self, node)
        } else {
            node
        }
    }

    fn fold_object_lit(&mut self, node: ObjectLit) -> ObjectLit {
        if self.enabled {
            Fold::fold_object_lit(self, node)
        } else {
            node
        }
    }

    fn fold_object_pat(&mut self, node: ObjectPat) -> ObjectPat {
        if self.enabled {
            Fold::fold_object_pat(self, node)
        } else {
            node
        }
    }

    fn fold_object_pat_prop(&mut self, node: ObjectPatProp) -> ObjectPatProp {
        if self.enabled {
            Fold::fold_object_pat_prop(self, node)
        } else {
            node
        }
    }

    fn fold_object_pat_props(&mut self, node: Vec<ObjectPatProp>) -> Vec<ObjectPatProp> {
        if self.enabled {
            Fold::fold_object_pat_props(self, node)
        } else {
            node
        }
    }

    fn fold_opt_accessibility(&mut self, node: Option<Accessibility>) -> Option<Accessibility> {
        if self.enabled {
            Fold::fold_opt_accessibility(self, node)
        } else {
            node
        }
    }

    fn fold_opt_atom(&mut self, node: Option<swc_atoms::Atom>) -> Option<swc_atoms::Atom> {
        if self.enabled {
            Fold::fold_opt_atom(self, node)
        } else {
            node
        }
    }

    fn fold_opt_block_stmt(&mut self, node: Option<BlockStmt>) -> Option<BlockStmt> {
        if self.enabled {
            Fold::fold_opt_block_stmt(self, node)
        } else {
            node
        }
    }

    fn fold_opt_call(&mut self, node: OptCall) -> OptCall {
        if self.enabled {
            Fold::fold_opt_call(self, node)
        } else {
            node
        }
    }

    fn fold_opt_catch_clause(&mut self, node: Option<CatchClause>) -> Option<CatchClause> {
        if self.enabled {
            Fold::fold_opt_catch_clause(self, node)
        } else {
            node
        }
    }

    fn fold_opt_chain_base(&mut self, node: OptChainBase) -> OptChainBase {
        if self.enabled {
            Fold::fold_opt_chain_base(self, node)
        } else {
            node
        }
    }

    fn fold_opt_chain_expr(&mut self, node: OptChainExpr) -> OptChainExpr {
        if self.enabled {
            Fold::fold_opt_chain_expr(self, node)
        } else {
            node
        }
    }

    fn fold_opt_expr(&mut self, node: Option<Box<Expr>>) -> Option<Box<Expr>> {
        if self.enabled {
            Fold::fold_opt_expr(self, node)
        } else {
            node
        }
    }

    fn fold_opt_expr_or_spread(&mut self, node: Option<ExprOrSpread>) -> Option<ExprOrSpread> {
        if self.enabled {
            Fold::fold_opt_expr_or_spread(self, node)
        } else {
            node
        }
    }

    fn fold_opt_expr_or_spreads(
        &mut self,
        node: Option<Vec<ExprOrSpread>>,
    ) -> Option<Vec<ExprOrSpread>> {
        if self.enabled {
            Fold::fold_opt_expr_or_spreads(self, node)
        } else {
            node
        }
    }

    fn fold_opt_ident(&mut self, node: Option<Ident>) -> Option<Ident> {
        if self.enabled {
            Fold::fold_opt_ident(self, node)
        } else {
            node
        }
    }

    fn fold_opt_jsx_attr_value(&mut self, node: Option<JSXAttrValue>) -> Option<JSXAttrValue> {
        if self.enabled {
            Fold::fold_opt_jsx_attr_value(self, node)
        } else {
            node
        }
    }

    fn fold_opt_jsx_closing_element(
        &mut self,
        node: Option<JSXClosingElement>,
    ) -> Option<JSXClosingElement> {
        if self.enabled {
            Fold::fold_opt_jsx_closing_element(self, node)
        } else {
            node
        }
    }

    fn fold_opt_module_export_name(
        &mut self,
        node: Option<ModuleExportName>,
    ) -> Option<ModuleExportName> {
        if self.enabled {
            Fold::fold_opt_module_export_name(self, node)
        } else {
            node
        }
    }

    fn fold_opt_module_items(&mut self, node: Option<Vec<ModuleItem>>) -> Option<Vec<ModuleItem>> {
        if self.enabled {
            Fold::fold_opt_module_items(self, node)
        } else {
            node
        }
    }

    fn fold_opt_object_lit(&mut self, node: Option<Box<ObjectLit>>) -> Option<Box<ObjectLit>> {
        if self.enabled {
            Fold::fold_opt_object_lit(self, node)
        } else {
            node
        }
    }

    fn fold_opt_pat(&mut self, node: Option<Pat>) -> Option<Pat> {
        if self.enabled {
            Fold::fold_opt_pat(self, node)
        } else {
            node
        }
    }

    fn fold_opt_span(&mut self, node: Option<swc_common::Span>) -> Option<swc_common::Span> {
        if self.enabled {
            Fold::fold_opt_span(self, node)
        } else {
            node
        }
    }

    fn fold_opt_stmt(&mut self, node: Option<Box<Stmt>>) -> Option<Box<Stmt>> {
        if self.enabled {
            Fold::fold_opt_stmt(self, node)
        } else {
            node
        }
    }

    fn fold_opt_str(&mut self, node: Option<Box<Str>>) -> Option<Box<Str>> {
        if self.enabled {
            Fold::fold_opt_str(self, node)
        } else {
            node
        }
    }

    fn fold_opt_true_plus_minus(&mut self, node: Option<TruePlusMinus>) -> Option<TruePlusMinus> {
        if self.enabled {
            Fold::fold_opt_true_plus_minus(self, node)
        } else {
            node
        }
    }

    fn fold_opt_ts_entity_name(&mut self, node: Option<TsEntityName>) -> Option<TsEntityName> {
        if self.enabled {
            Fold::fold_opt_ts_entity_name(self, node)
        } else {
            node
        }
    }

    fn fold_opt_ts_namespace_body(
        &mut self,
        node: Option<TsNamespaceBody>,
    ) -> Option<TsNamespaceBody> {
        if self.enabled {
            Fold::fold_opt_ts_namespace_body(self, node)
        } else {
            node
        }
    }

    fn fold_opt_ts_type(&mut self, node: Option<Box<TsType>>) -> Option<Box<TsType>> {
        if self.enabled {
            Fold::fold_opt_ts_type(self, node)
        } else {
            node
        }
    }

    fn fold_opt_ts_type_ann(&mut self, node: Option<Box<TsTypeAnn>>) -> Option<Box<TsTypeAnn>> {
        if self.enabled {
            Fold::fold_opt_ts_type_ann(self, node)
        } else {
            node
        }
    }

    fn fold_opt_ts_type_param_decl(
        &mut self,
        node: Option<Box<TsTypeParamDecl>>,
    ) -> Option<Box<TsTypeParamDecl>> {
        if self.enabled {
            Fold::fold_opt_ts_type_param_decl(self, node)
        } else {
            node
        }
    }

    fn fold_opt_ts_type_param_instantiation(
        &mut self,
        node: Option<Box<TsTypeParamInstantiation>>,
    ) -> Option<Box<TsTypeParamInstantiation>> {
        if self.enabled {
            Fold::fold_opt_ts_type_param_instantiation(self, node)
        } else {
            node
        }
    }

    fn fold_opt_var_decl_or_expr(&mut self, node: Option<VarDeclOrExpr>) -> Option<VarDeclOrExpr> {
        if self.enabled {
            Fold::fold_opt_var_decl_or_expr(self, node)
        } else {
            node
        }
    }

    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        node: Vec<Option<ExprOrSpread>>,
    ) -> Vec<Option<ExprOrSpread>> {
        if self.enabled {
            Fold::fold_opt_vec_expr_or_spreads(self, node)
        } else {
            node
        }
    }

    fn fold_opt_vec_pats(&mut self, node: Vec<Option<Pat>>) -> Vec<Option<Pat>> {
        if self.enabled {
            Fold::fold_opt_vec_pats(self, node)
        } else {
            node
        }
    }

    fn fold_param(&mut self, node: Param) -> Param {
        if self.enabled {
            Fold::fold_param(self, node)
        } else {
            node
        }
    }

    fn fold_param_or_ts_param_prop(&mut self, node: ParamOrTsParamProp) -> ParamOrTsParamProp {
        if self.enabled {
            Fold::fold_param_or_ts_param_prop(self, node)
        } else {
            node
        }
    }

    fn fold_param_or_ts_param_props(
        &mut self,
        node: Vec<ParamOrTsParamProp>,
    ) -> Vec<ParamOrTsParamProp> {
        if self.enabled {
            Fold::fold_param_or_ts_param_props(self, node)
        } else {
            node
        }
    }

    fn fold_params(&mut self, node: Vec<Param>) -> Vec<Param> {
        if self.enabled {
            Fold::fold_params(self, node)
        } else {
            node
        }
    }

    fn fold_paren_expr(&mut self, node: ParenExpr) -> ParenExpr {
        if self.enabled {
            Fold::fold_paren_expr(self, node)
        } else {
            node
        }
    }

    fn fold_pat(&mut self, node: Pat) -> Pat {
        if self.enabled {
            Fold::fold_pat(self, node)
        } else {
            node
        }
    }

    fn fold_pats(&mut self, node: Vec<Pat>) -> Vec<Pat> {
        if self.enabled {
            Fold::fold_pats(self, node)
        } else {
            node
        }
    }

    fn fold_private_method(&mut self, node: PrivateMethod) -> PrivateMethod {
        if self.enabled {
            Fold::fold_private_method(self, node)
        } else {
            node
        }
    }

    fn fold_private_name(&mut self, node: PrivateName) -> PrivateName {
        if self.enabled {
            Fold::fold_private_name(self, node)
        } else {
            node
        }
    }

    fn fold_private_prop(&mut self, node: PrivateProp) -> PrivateProp {
        if self.enabled {
            Fold::fold_private_prop(self, node)
        } else {
            node
        }
    }

    fn fold_program(&mut self, node: Program) -> Program {
        if self.enabled {
            Fold::fold_program(self, node)
        } else {
            node
        }
    }

    fn fold_prop(&mut self, node: Prop) -> Prop {
        if self.enabled {
            Fold::fold_prop(self, node)
        } else {
            node
        }
    }

    fn fold_prop_name(&mut self, node: PropName) -> PropName {
        if self.enabled {
            Fold::fold_prop_name(self, node)
        } else {
            node
        }
    }

    fn fold_prop_or_spread(&mut self, node: PropOrSpread) -> PropOrSpread {
        if self.enabled {
            Fold::fold_prop_or_spread(self, node)
        } else {
            node
        }
    }

    fn fold_prop_or_spreads(&mut self, node: Vec<PropOrSpread>) -> Vec<PropOrSpread> {
        if self.enabled {
            Fold::fold_prop_or_spreads(self, node)
        } else {
            node
        }
    }

    fn fold_regex(&mut self, node: Regex) -> Regex {
        if self.enabled {
            Fold::fold_regex(self, node)
        } else {
            node
        }
    }

    fn fold_reserved_unused(&mut self, node: ReservedUnused) -> ReservedUnused {
        if self.enabled {
            Fold::fold_reserved_unused(self, node)
        } else {
            node
        }
    }

    fn fold_rest_pat(&mut self, node: RestPat) -> RestPat {
        if self.enabled {
            Fold::fold_rest_pat(self, node)
        } else {
            node
        }
    }

    fn fold_return_stmt(&mut self, node: ReturnStmt) -> ReturnStmt {
        if self.enabled {
            Fold::fold_return_stmt(self, node)
        } else {
            node
        }
    }

    fn fold_script(&mut self, node: Script) -> Script {
        if self.enabled {
            Fold::fold_script(self, node)
        } else {
            node
        }
    }

    fn fold_seq_expr(&mut self, node: SeqExpr) -> SeqExpr {
        if self.enabled {
            Fold::fold_seq_expr(self, node)
        } else {
            node
        }
    }

    fn fold_setter_prop(&mut self, node: SetterProp) -> SetterProp {
        if self.enabled {
            Fold::fold_setter_prop(self, node)
        } else {
            node
        }
    }

    fn fold_simple_assign_target(&mut self, node: SimpleAssignTarget) -> SimpleAssignTarget {
        if self.enabled {
            Fold::fold_simple_assign_target(self, node)
        } else {
            node
        }
    }

    fn fold_span(&mut self, node: swc_common::Span) -> swc_common::Span {
        if self.enabled {
            Fold::fold_span(self, node)
        } else {
            node
        }
    }

    fn fold_spread_element(&mut self, node: SpreadElement) -> SpreadElement {
        if self.enabled {
            Fold::fold_spread_element(self, node)
        } else {
            node
        }
    }

    fn fold_static_block(&mut self, node: StaticBlock) -> StaticBlock {
        if self.enabled {
            Fold::fold_static_block(self, node)
        } else {
            node
        }
    }

    fn fold_stmt(&mut self, node: Stmt) -> Stmt {
        if self.enabled {
            Fold::fold_stmt(self, node)
        } else {
            node
        }
    }

    fn fold_stmts(&mut self, node: Vec<Stmt>) -> Vec<Stmt> {
        if self.enabled {
            Fold::fold_stmts(self, node)
        } else {
            node
        }
    }

    fn fold_str(&mut self, node: Str) -> Str {
        if self.enabled {
            Fold::fold_str(self, node)
        } else {
            node
        }
    }

    fn fold_super(&mut self, node: Super) -> Super {
        if self.enabled {
            Fold::fold_super(self, node)
        } else {
            node
        }
    }

    fn fold_super_prop(&mut self, node: SuperProp) -> SuperProp {
        if self.enabled {
            Fold::fold_super_prop(self, node)
        } else {
            node
        }
    }

    fn fold_super_prop_expr(&mut self, node: SuperPropExpr) -> SuperPropExpr {
        if self.enabled {
            Fold::fold_super_prop_expr(self, node)
        } else {
            node
        }
    }

    fn fold_switch_case(&mut self, node: SwitchCase) -> SwitchCase {
        if self.enabled {
            Fold::fold_switch_case(self, node)
        } else {
            node
        }
    }

    fn fold_switch_cases(&mut self, node: Vec<SwitchCase>) -> Vec<SwitchCase> {
        if self.enabled {
            Fold::fold_switch_cases(self, node)
        } else {
            node
        }
    }

    fn fold_switch_stmt(&mut self, node: SwitchStmt) -> SwitchStmt {
        if self.enabled {
            Fold::fold_switch_stmt(self, node)
        } else {
            node
        }
    }

    fn fold_syntax_context(
        &mut self,
        node: swc_common::SyntaxContext,
    ) -> swc_common::SyntaxContext {
        if self.enabled {
            Fold::fold_syntax_context(self, node)
        } else {
            node
        }
    }

    fn fold_tagged_tpl(&mut self, node: TaggedTpl) -> TaggedTpl {
        if self.enabled {
            Fold::fold_tagged_tpl(self, node)
        } else {
            node
        }
    }

    fn fold_this_expr(&mut self, node: ThisExpr) -> ThisExpr {
        if self.enabled {
            Fold::fold_this_expr(self, node)
        } else {
            node
        }
    }

    fn fold_throw_stmt(&mut self, node: ThrowStmt) -> ThrowStmt {
        if self.enabled {
            Fold::fold_throw_stmt(self, node)
        } else {
            node
        }
    }

    fn fold_tpl(&mut self, node: Tpl) -> Tpl {
        if self.enabled {
            Fold::fold_tpl(self, node)
        } else {
            node
        }
    }

    fn fold_tpl_element(&mut self, node: TplElement) -> TplElement {
        if self.enabled {
            Fold::fold_tpl_element(self, node)
        } else {
            node
        }
    }

    fn fold_tpl_elements(&mut self, node: Vec<TplElement>) -> Vec<TplElement> {
        if self.enabled {
            Fold::fold_tpl_elements(self, node)
        } else {
            node
        }
    }

    fn fold_true_plus_minus(&mut self, node: TruePlusMinus) -> TruePlusMinus {
        if self.enabled {
            Fold::fold_true_plus_minus(self, node)
        } else {
            node
        }
    }

    fn fold_try_stmt(&mut self, node: TryStmt) -> TryStmt {
        if self.enabled {
            Fold::fold_try_stmt(self, node)
        } else {
            node
        }
    }

    fn fold_ts_array_type(&mut self, node: TsArrayType) -> TsArrayType {
        if self.enabled {
            Fold::fold_ts_array_type(self, node)
        } else {
            node
        }
    }

    fn fold_ts_as_expr(&mut self, node: TsAsExpr) -> TsAsExpr {
        if self.enabled {
            Fold::fold_ts_as_expr(self, node)
        } else {
            node
        }
    }

    fn fold_ts_call_signature_decl(&mut self, node: TsCallSignatureDecl) -> TsCallSignatureDecl {
        if self.enabled {
            Fold::fold_ts_call_signature_decl(self, node)
        } else {
            node
        }
    }

    fn fold_ts_conditional_type(&mut self, node: TsConditionalType) -> TsConditionalType {
        if self.enabled {
            Fold::fold_ts_conditional_type(self, node)
        } else {
            node
        }
    }

    fn fold_ts_const_assertion(&mut self, node: TsConstAssertion) -> TsConstAssertion {
        if self.enabled {
            Fold::fold_ts_const_assertion(self, node)
        } else {
            node
        }
    }

    fn fold_ts_construct_signature_decl(
        &mut self,
        node: TsConstructSignatureDecl,
    ) -> TsConstructSignatureDecl {
        if self.enabled {
            Fold::fold_ts_construct_signature_decl(self, node)
        } else {
            node
        }
    }

    fn fold_ts_constructor_type(&mut self, node: TsConstructorType) -> TsConstructorType {
        if self.enabled {
            Fold::fold_ts_constructor_type(self, node)
        } else {
            node
        }
    }

    fn fold_ts_entity_name(&mut self, node: TsEntityName) -> TsEntityName {
        if self.enabled {
            Fold::fold_ts_entity_name(self, node)
        } else {
            node
        }
    }

    fn fold_ts_enum_decl(&mut self, node: TsEnumDecl) -> TsEnumDecl {
        if self.enabled {
            Fold::fold_ts_enum_decl(self, node)
        } else {
            node
        }
    }

    fn fold_ts_enum_member(&mut self, node: TsEnumMember) -> TsEnumMember {
        if self.enabled {
            Fold::fold_ts_enum_member(self, node)
        } else {
            node
        }
    }

    fn fold_ts_enum_member_id(&mut self, node: TsEnumMemberId) -> TsEnumMemberId {
        if self.enabled {
            Fold::fold_ts_enum_member_id(self, node)
        } else {
            node
        }
    }

    fn fold_ts_enum_members(&mut self, node: Vec<TsEnumMember>) -> Vec<TsEnumMember> {
        if self.enabled {
            Fold::fold_ts_enum_members(self, node)
        } else {
            node
        }
    }

    fn fold_ts_export_assignment(&mut self, node: TsExportAssignment) -> TsExportAssignment {
        if self.enabled {
            Fold::fold_ts_export_assignment(self, node)
        } else {
            node
        }
    }

    fn fold_ts_expr_with_type_args(&mut self, node: TsExprWithTypeArgs) -> TsExprWithTypeArgs {
        if self.enabled {
            Fold::fold_ts_expr_with_type_args(self, node)
        } else {
            node
        }
    }

    fn fold_ts_expr_with_type_argss(
        &mut self,
        node: Vec<TsExprWithTypeArgs>,
    ) -> Vec<TsExprWithTypeArgs> {
        if self.enabled {
            Fold::fold_ts_expr_with_type_argss(self, node)
        } else {
            node
        }
    }

    fn fold_ts_external_module_ref(&mut self, node: TsExternalModuleRef) -> TsExternalModuleRef {
        if self.enabled {
            Fold::fold_ts_external_module_ref(self, node)
        } else {
            node
        }
    }

    fn fold_ts_fn_or_constructor_type(
        &mut self,
        node: TsFnOrConstructorType,
    ) -> TsFnOrConstructorType {
        if self.enabled {
            Fold::fold_ts_fn_or_constructor_type(self, node)
        } else {
            node
        }
    }

    fn fold_ts_fn_param(&mut self, node: TsFnParam) -> TsFnParam {
        if self.enabled {
            Fold::fold_ts_fn_param(self, node)
        } else {
            node
        }
    }

    fn fold_ts_fn_params(&mut self, node: Vec<TsFnParam>) -> Vec<TsFnParam> {
        if self.enabled {
            Fold::fold_ts_fn_params(self, node)
        } else {
            node
        }
    }

    fn fold_ts_fn_type(&mut self, node: TsFnType) -> TsFnType {
        if self.enabled {
            Fold::fold_ts_fn_type(self, node)
        } else {
            node
        }
    }

    fn fold_ts_getter_signature(&mut self, node: TsGetterSignature) -> TsGetterSignature {
        if self.enabled {
            Fold::fold_ts_getter_signature(self, node)
        } else {
            node
        }
    }

    fn fold_ts_import_equals_decl(&mut self, node: TsImportEqualsDecl) -> TsImportEqualsDecl {
        if self.enabled {
            Fold::fold_ts_import_equals_decl(self, node)
        } else {
            node
        }
    }

    fn fold_ts_import_type(&mut self, node: TsImportType) -> TsImportType {
        if self.enabled {
            Fold::fold_ts_import_type(self, node)
        } else {
            node
        }
    }

    fn fold_ts_index_signature(&mut self, node: TsIndexSignature) -> TsIndexSignature {
        if self.enabled {
            Fold::fold_ts_index_signature(self, node)
        } else {
            node
        }
    }

    fn fold_ts_indexed_access_type(&mut self, node: TsIndexedAccessType) -> TsIndexedAccessType {
        if self.enabled {
            Fold::fold_ts_indexed_access_type(self, node)
        } else {
            node
        }
    }

    fn fold_ts_infer_type(&mut self, node: TsInferType) -> TsInferType {
        if self.enabled {
            Fold::fold_ts_infer_type(self, node)
        } else {
            node
        }
    }

    fn fold_ts_instantiation(&mut self, node: TsInstantiation) -> TsInstantiation {
        if self.enabled {
            Fold::fold_ts_instantiation(self, node)
        } else {
            node
        }
    }

    fn fold_ts_interface_body(&mut self, node: TsInterfaceBody) -> TsInterfaceBody {
        if self.enabled {
            Fold::fold_ts_interface_body(self, node)
        } else {
            node
        }
    }

    fn fold_ts_interface_decl(&mut self, node: TsInterfaceDecl) -> TsInterfaceDecl {
        if self.enabled {
            Fold::fold_ts_interface_decl(self, node)
        } else {
            node
        }
    }

    fn fold_ts_intersection_type(&mut self, node: TsIntersectionType) -> TsIntersectionType {
        if self.enabled {
            Fold::fold_ts_intersection_type(self, node)
        } else {
            node
        }
    }

    fn fold_ts_keyword_type(&mut self, node: TsKeywordType) -> TsKeywordType {
        if self.enabled {
            Fold::fold_ts_keyword_type(self, node)
        } else {
            node
        }
    }

    fn fold_ts_keyword_type_kind(&mut self, node: TsKeywordTypeKind) -> TsKeywordTypeKind {
        if self.enabled {
            Fold::fold_ts_keyword_type_kind(self, node)
        } else {
            node
        }
    }

    fn fold_ts_lit(&mut self, node: TsLit) -> TsLit {
        if self.enabled {
            Fold::fold_ts_lit(self, node)
        } else {
            node
        }
    }

    fn fold_ts_lit_type(&mut self, node: TsLitType) -> TsLitType {
        if self.enabled {
            Fold::fold_ts_lit_type(self, node)
        } else {
            node
        }
    }

    fn fold_ts_mapped_type(&mut self, node: TsMappedType) -> TsMappedType {
        if self.enabled {
            Fold::fold_ts_mapped_type(self, node)
        } else {
            node
        }
    }

    fn fold_ts_method_signature(&mut self, node: TsMethodSignature) -> TsMethodSignature {
        if self.enabled {
            Fold::fold_ts_method_signature(self, node)
        } else {
            node
        }
    }

    fn fold_ts_module_block(&mut self, node: TsModuleBlock) -> TsModuleBlock {
        if self.enabled {
            Fold::fold_ts_module_block(self, node)
        } else {
            node
        }
    }

    fn fold_ts_module_decl(&mut self, node: TsModuleDecl) -> TsModuleDecl {
        if self.enabled {
            Fold::fold_ts_module_decl(self, node)
        } else {
            node
        }
    }

    fn fold_ts_module_name(&mut self, node: TsModuleName) -> TsModuleName {
        if self.enabled {
            Fold::fold_ts_module_name(self, node)
        } else {
            node
        }
    }

    fn fold_ts_module_ref(&mut self, node: TsModuleRef) -> TsModuleRef {
        if self.enabled {
            Fold::fold_ts_module_ref(self, node)
        } else {
            node
        }
    }

    fn fold_ts_namespace_body(&mut self, node: TsNamespaceBody) -> TsNamespaceBody {
        if self.enabled {
            Fold::fold_ts_namespace_body(self, node)
        } else {
            node
        }
    }

    fn fold_ts_namespace_decl(&mut self, node: TsNamespaceDecl) -> TsNamespaceDecl {
        if self.enabled {
            Fold::fold_ts_namespace_decl(self, node)
        } else {
            node
        }
    }

    fn fold_ts_namespace_export_decl(
        &mut self,
        node: TsNamespaceExportDecl,
    ) -> TsNamespaceExportDecl {
        if self.enabled {
            Fold::fold_ts_namespace_export_decl(self, node)
        } else {
            node
        }
    }

    fn fold_ts_non_null_expr(&mut self, node: TsNonNullExpr) -> TsNonNullExpr {
        if self.enabled {
            Fold::fold_ts_non_null_expr(self, node)
        } else {
            node
        }
    }

    fn fold_ts_optional_type(&mut self, node: TsOptionalType) -> TsOptionalType {
        if self.enabled {
            Fold::fold_ts_optional_type(self, node)
        } else {
            node
        }
    }

    fn fold_ts_param_prop(&mut self, node: TsParamProp) -> TsParamProp {
        if self.enabled {
            Fold::fold_ts_param_prop(self, node)
        } else {
            node
        }
    }

    fn fold_ts_param_prop_param(&mut self, node: TsParamPropParam) -> TsParamPropParam {
        if self.enabled {
            Fold::fold_ts_param_prop_param(self, node)
        } else {
            node
        }
    }

    fn fold_ts_parenthesized_type(&mut self, node: TsParenthesizedType) -> TsParenthesizedType {
        if self.enabled {
            Fold::fold_ts_parenthesized_type(self, node)
        } else {
            node
        }
    }

    fn fold_ts_property_signature(&mut self, node: TsPropertySignature) -> TsPropertySignature {
        if self.enabled {
            Fold::fold_ts_property_signature(self, node)
        } else {
            node
        }
    }

    fn fold_ts_qualified_name(&mut self, node: TsQualifiedName) -> TsQualifiedName {
        if self.enabled {
            Fold::fold_ts_qualified_name(self, node)
        } else {
            node
        }
    }

    fn fold_ts_rest_type(&mut self, node: TsRestType) -> TsRestType {
        if self.enabled {
            Fold::fold_ts_rest_type(self, node)
        } else {
            node
        }
    }

    fn fold_ts_satisfies_expr(&mut self, node: TsSatisfiesExpr) -> TsSatisfiesExpr {
        if self.enabled {
            Fold::fold_ts_satisfies_expr(self, node)
        } else {
            node
        }
    }

    fn fold_ts_setter_signature(&mut self, node: TsSetterSignature) -> TsSetterSignature {
        if self.enabled {
            Fold::fold_ts_setter_signature(self, node)
        } else {
            node
        }
    }

    fn fold_ts_this_type(&mut self, node: TsThisType) -> TsThisType {
        if self.enabled {
            Fold::fold_ts_this_type(self, node)
        } else {
            node
        }
    }

    fn fold_ts_this_type_or_ident(&mut self, node: TsThisTypeOrIdent) -> TsThisTypeOrIdent {
        if self.enabled {
            Fold::fold_ts_this_type_or_ident(self, node)
        } else {
            node
        }
    }

    fn fold_ts_tpl_lit_type(&mut self, node: TsTplLitType) -> TsTplLitType {
        if self.enabled {
            Fold::fold_ts_tpl_lit_type(self, node)
        } else {
            node
        }
    }

    fn fold_ts_tuple_element(&mut self, node: TsTupleElement) -> TsTupleElement {
        if self.enabled {
            Fold::fold_ts_tuple_element(self, node)
        } else {
            node
        }
    }

    fn fold_ts_tuple_elements(&mut self, node: Vec<TsTupleElement>) -> Vec<TsTupleElement> {
        if self.enabled {
            Fold::fold_ts_tuple_elements(self, node)
        } else {
            node
        }
    }

    fn fold_ts_tuple_type(&mut self, node: TsTupleType) -> TsTupleType {
        if self.enabled {
            Fold::fold_ts_tuple_type(self, node)
        } else {
            node
        }
    }

    fn fold_ts_type(&mut self, node: TsType) -> TsType {
        if self.enabled {
            Fold::fold_ts_type(self, node)
        } else {
            node
        }
    }

    fn fold_ts_type_alias_decl(&mut self, node: TsTypeAliasDecl) -> TsTypeAliasDecl {
        if self.enabled {
            Fold::fold_ts_type_alias_decl(self, node)
        } else {
            node
        }
    }

    fn fold_ts_type_ann(&mut self, node: TsTypeAnn) -> TsTypeAnn {
        if self.enabled {
            Fold::fold_ts_type_ann(self, node)
        } else {
            node
        }
    }

    fn fold_ts_type_assertion(&mut self, node: TsTypeAssertion) -> TsTypeAssertion {
        if self.enabled {
            Fold::fold_ts_type_assertion(self, node)
        } else {
            node
        }
    }

    fn fold_ts_type_element(&mut self, node: TsTypeElement) -> TsTypeElement {
        if self.enabled {
            Fold::fold_ts_type_element(self, node)
        } else {
            node
        }
    }

    fn fold_ts_type_elements(&mut self, node: Vec<TsTypeElement>) -> Vec<TsTypeElement> {
        if self.enabled {
            Fold::fold_ts_type_elements(self, node)
        } else {
            node
        }
    }

    fn fold_ts_type_lit(&mut self, node: TsTypeLit) -> TsTypeLit {
        if self.enabled {
            Fold::fold_ts_type_lit(self, node)
        } else {
            node
        }
    }

    fn fold_ts_type_operator(&mut self, node: TsTypeOperator) -> TsTypeOperator {
        if self.enabled {
            Fold::fold_ts_type_operator(self, node)
        } else {
            node
        }
    }

    fn fold_ts_type_operator_op(&mut self, node: TsTypeOperatorOp) -> TsTypeOperatorOp {
        if self.enabled {
            Fold::fold_ts_type_operator_op(self, node)
        } else {
            node
        }
    }

    fn fold_ts_type_param(&mut self, node: TsTypeParam) -> TsTypeParam {
        if self.enabled {
            Fold::fold_ts_type_param(self, node)
        } else {
            node
        }
    }

    fn fold_ts_type_param_decl(&mut self, node: TsTypeParamDecl) -> TsTypeParamDecl {
        if self.enabled {
            Fold::fold_ts_type_param_decl(self, node)
        } else {
            node
        }
    }

    fn fold_ts_type_param_instantiation(
        &mut self,
        node: TsTypeParamInstantiation,
    ) -> TsTypeParamInstantiation {
        if self.enabled {
            Fold::fold_ts_type_param_instantiation(self, node)
        } else {
            node
        }
    }

    fn fold_ts_type_params(&mut self, node: Vec<TsTypeParam>) -> Vec<TsTypeParam> {
        if self.enabled {
            Fold::fold_ts_type_params(self, node)
        } else {
            node
        }
    }

    fn fold_ts_type_predicate(&mut self, node: TsTypePredicate) -> TsTypePredicate {
        if self.enabled {
            Fold::fold_ts_type_predicate(self, node)
        } else {
            node
        }
    }

    fn fold_ts_type_query(&mut self, node: TsTypeQuery) -> TsTypeQuery {
        if self.enabled {
            Fold::fold_ts_type_query(self, node)
        } else {
            node
        }
    }

    fn fold_ts_type_query_expr(&mut self, node: TsTypeQueryExpr) -> TsTypeQueryExpr {
        if self.enabled {
            Fold::fold_ts_type_query_expr(self, node)
        } else {
            node
        }
    }

    fn fold_ts_type_ref(&mut self, node: TsTypeRef) -> TsTypeRef {
        if self.enabled {
            Fold::fold_ts_type_ref(self, node)
        } else {
            node
        }
    }

    fn fold_ts_types(&mut self, node: Vec<Box<TsType>>) -> Vec<Box<TsType>> {
        if self.enabled {
            Fold::fold_ts_types(self, node)
        } else {
            node
        }
    }

    fn fold_ts_union_or_intersection_type(
        &mut self,
        node: TsUnionOrIntersectionType,
    ) -> TsUnionOrIntersectionType {
        if self.enabled {
            Fold::fold_ts_union_or_intersection_type(self, node)
        } else {
            node
        }
    }

    fn fold_ts_union_type(&mut self, node: TsUnionType) -> TsUnionType {
        if self.enabled {
            Fold::fold_ts_union_type(self, node)
        } else {
            node
        }
    }

    fn fold_unary_expr(&mut self, node: UnaryExpr) -> UnaryExpr {
        if self.enabled {
            Fold::fold_unary_expr(self, node)
        } else {
            node
        }
    }

    fn fold_unary_op(&mut self, node: UnaryOp) -> UnaryOp {
        if self.enabled {
            Fold::fold_unary_op(self, node)
        } else {
            node
        }
    }

    fn fold_update_expr(&mut self, node: UpdateExpr) -> UpdateExpr {
        if self.enabled {
            Fold::fold_update_expr(self, node)
        } else {
            node
        }
    }

    fn fold_update_op(&mut self, node: UpdateOp) -> UpdateOp {
        if self.enabled {
            Fold::fold_update_op(self, node)
        } else {
            node
        }
    }

    fn fold_using_decl(&mut self, node: UsingDecl) -> UsingDecl {
        if self.enabled {
            Fold::fold_using_decl(self, node)
        } else {
            node
        }
    }

    fn fold_var_decl(&mut self, node: VarDecl) -> VarDecl {
        if self.enabled {
            Fold::fold_var_decl(self, node)
        } else {
            node
        }
    }

    fn fold_var_decl_kind(&mut self, node: VarDeclKind) -> VarDeclKind {
        if self.enabled {
            Fold::fold_var_decl_kind(self, node)
        } else {
            node
        }
    }

    fn fold_var_decl_or_expr(&mut self, node: VarDeclOrExpr) -> VarDeclOrExpr {
        if self.enabled {
            Fold::fold_var_decl_or_expr(self, node)
        } else {
            node
        }
    }

    fn fold_var_declarator(&mut self, node: VarDeclarator) -> VarDeclarator {
        if self.enabled {
            Fold::fold_var_declarator(self, node)
        } else {
            node
        }
    }

    fn fold_var_declarators(&mut self, node: Vec<VarDeclarator>) -> Vec<VarDeclarator> {
        if self.enabled {
            Fold::fold_var_declarators(self, node)
        } else {
            node
        }
    }

    fn fold_while_stmt(&mut self, node: WhileStmt) -> WhileStmt {
        if self.enabled {
            Fold::fold_while_stmt(self, node)
        } else {
            node
        }
    }

    fn fold_with_stmt(&mut self, node: WithStmt) -> WithStmt {
        if self.enabled {
            Fold::fold_with_stmt(self, node)
        } else {
            node
        }
    }

    fn fold_yield_expr(&mut self, node: YieldExpr) -> YieldExpr {
        if self.enabled {
            Fold::fold_yield_expr(self, node)
        } else {
            node
        }
    }
}
#[doc = r" A trait implemented for types that can be visited using a visitor."]
pub trait FoldWith<V: ?Sized + Fold> {
    #[doc = r" Calls a visitor method (visitor.fold_xxx) with self."]
    fn fold_with(self, visitor: &mut V) -> Self;
    #[doc = r" Visit children nodes of `self`` with `visitor`."]
    fn fold_children_with(self, visitor: &mut V) -> Self;
}
impl<V: ?Sized + Fold> FoldWith<V> for Accessibility {
    #[doc = "Calls [Fold`::fold_accessibility`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_accessibility(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Accessibility::Public => Accessibility::Public,
            Accessibility::Protected => Accessibility::Protected,
            Accessibility::Private => Accessibility::Private,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ArrayLit {
    #[doc = "Calls [Fold`::fold_array_lit`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_array_lit(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ArrayLit { span, elems } => {
                let elems = <Vec<Option<ExprOrSpread>> as FoldWith<V>>::fold_with(elems, visitor);
                ArrayLit { span, elems }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ArrayPat {
    #[doc = "Calls [Fold`::fold_array_pat`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_array_pat(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ArrayPat {
                span,
                elems,
                optional,
                type_ann,
            } => {
                let elems = <Vec<Option<Pat>> as FoldWith<V>>::fold_with(elems, visitor);
                let type_ann =
                    <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor);
                ArrayPat {
                    span,
                    elems,
                    optional,
                    type_ann,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ArrowExpr {
    #[doc = "Calls [Fold`::fold_arrow_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_arrow_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ArrowExpr {
                span,
                ctxt,
                params,
                body,
                is_async,
                is_generator,
                type_params,
                return_type,
            } => {
                let params = <Vec<Pat> as FoldWith<V>>::fold_with(params, visitor);
                let body = <Box<BlockStmtOrExpr> as FoldWith<V>>::fold_with(body, visitor);
                let type_params =
                    <Option<Box<TsTypeParamDecl>> as FoldWith<V>>::fold_with(type_params, visitor);
                let return_type =
                    <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(return_type, visitor);
                ArrowExpr {
                    span,
                    ctxt,
                    params,
                    body,
                    is_async,
                    is_generator,
                    type_params,
                    return_type,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for AssignExpr {
    #[doc = "Calls [Fold`::fold_assign_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_assign_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            AssignExpr {
                span,
                op,
                left,
                right,
            } => {
                let op = <AssignOp as FoldWith<V>>::fold_with(op, visitor);
                let left = <AssignTarget as FoldWith<V>>::fold_with(left, visitor);
                let right = <Box<Expr> as FoldWith<V>>::fold_with(right, visitor);
                AssignExpr {
                    span,
                    op,
                    left,
                    right,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for AssignOp {
    #[doc = "Calls [Fold`::fold_assign_op`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_assign_op(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            AssignOp::Assign => AssignOp::Assign,
            AssignOp::AddAssign => AssignOp::AddAssign,
            AssignOp::SubAssign => AssignOp::SubAssign,
            AssignOp::MulAssign => AssignOp::MulAssign,
            AssignOp::DivAssign => AssignOp::DivAssign,
            AssignOp::ModAssign => AssignOp::ModAssign,
            AssignOp::LShiftAssign => AssignOp::LShiftAssign,
            AssignOp::RShiftAssign => AssignOp::RShiftAssign,
            AssignOp::ZeroFillRShiftAssign => AssignOp::ZeroFillRShiftAssign,
            AssignOp::BitOrAssign => AssignOp::BitOrAssign,
            AssignOp::BitXorAssign => AssignOp::BitXorAssign,
            AssignOp::BitAndAssign => AssignOp::BitAndAssign,
            AssignOp::ExpAssign => AssignOp::ExpAssign,
            AssignOp::AndAssign => AssignOp::AndAssign,
            AssignOp::OrAssign => AssignOp::OrAssign,
            AssignOp::NullishAssign => AssignOp::NullishAssign,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for AssignPat {
    #[doc = "Calls [Fold`::fold_assign_pat`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_assign_pat(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            AssignPat { span, left, right } => {
                let left = <Box<Pat> as FoldWith<V>>::fold_with(left, visitor);
                let right = <Box<Expr> as FoldWith<V>>::fold_with(right, visitor);
                AssignPat { span, left, right }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for AssignPatProp {
    #[doc = "Calls [Fold`::fold_assign_pat_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_assign_pat_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            AssignPatProp { span, key, value } => {
                let key = <BindingIdent as FoldWith<V>>::fold_with(key, visitor);
                let value = <Option<Box<Expr>> as FoldWith<V>>::fold_with(value, visitor);
                AssignPatProp { span, key, value }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for AssignProp {
    #[doc = "Calls [Fold`::fold_assign_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_assign_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            AssignProp { span, key, value } => {
                let key = <Ident as FoldWith<V>>::fold_with(key, visitor);
                let value = <Box<Expr> as FoldWith<V>>::fold_with(value, visitor);
                AssignProp { span, key, value }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for AssignTarget {
    #[doc = "Calls [Fold`::fold_assign_target`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_assign_target(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            AssignTarget::Simple { 0: _field_0 } => {
                let _field_0 = <SimpleAssignTarget as FoldWith<V>>::fold_with(_field_0, visitor);
                AssignTarget::Simple { 0: _field_0 }
            }
            AssignTarget::Pat { 0: _field_0 } => {
                let _field_0 = <AssignTargetPat as FoldWith<V>>::fold_with(_field_0, visitor);
                AssignTarget::Pat { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for AssignTargetPat {
    #[doc = "Calls [Fold`::fold_assign_target_pat`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_assign_target_pat(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            AssignTargetPat::Array { 0: _field_0 } => {
                let _field_0 = <ArrayPat as FoldWith<V>>::fold_with(_field_0, visitor);
                AssignTargetPat::Array { 0: _field_0 }
            }
            AssignTargetPat::Object { 0: _field_0 } => {
                let _field_0 = <ObjectPat as FoldWith<V>>::fold_with(_field_0, visitor);
                AssignTargetPat::Object { 0: _field_0 }
            }
            AssignTargetPat::Invalid { 0: _field_0 } => {
                let _field_0 = <Invalid as FoldWith<V>>::fold_with(_field_0, visitor);
                AssignTargetPat::Invalid { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for AutoAccessor {
    #[doc = "Calls [Fold`::fold_auto_accessor`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_auto_accessor(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            AutoAccessor {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_override,
                definite,
            } => {
                let key = <Key as FoldWith<V>>::fold_with(key, visitor);
                let value = <Option<Box<Expr>> as FoldWith<V>>::fold_with(value, visitor);
                let type_ann =
                    <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor);
                let decorators = <Vec<Decorator> as FoldWith<V>>::fold_with(decorators, visitor);
                let accessibility =
                    <Option<Accessibility> as FoldWith<V>>::fold_with(accessibility, visitor);
                AutoAccessor {
                    span,
                    key,
                    value,
                    type_ann,
                    is_static,
                    decorators,
                    accessibility,
                    is_abstract,
                    is_override,
                    definite,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for AwaitExpr {
    #[doc = "Calls [Fold`::fold_await_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_await_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            AwaitExpr { span, arg } => {
                let arg = <Box<Expr> as FoldWith<V>>::fold_with(arg, visitor);
                AwaitExpr { span, arg }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for BigInt {
    #[doc = "Calls [Fold`::fold_big_int`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_big_int(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            BigInt { span, value, raw } => BigInt { span, value, raw },
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for BinExpr {
    #[doc = "Calls [Fold`::fold_bin_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_bin_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            BinExpr {
                span,
                op,
                left,
                right,
            } => {
                let op = <BinaryOp as FoldWith<V>>::fold_with(op, visitor);
                let left = <Box<Expr> as FoldWith<V>>::fold_with(left, visitor);
                let right = <Box<Expr> as FoldWith<V>>::fold_with(right, visitor);
                BinExpr {
                    span,
                    op,
                    left,
                    right,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for BinaryOp {
    #[doc = "Calls [Fold`::fold_binary_op`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_binary_op(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            BinaryOp::EqEq => BinaryOp::EqEq,
            BinaryOp::NotEq => BinaryOp::NotEq,
            BinaryOp::EqEqEq => BinaryOp::EqEqEq,
            BinaryOp::NotEqEq => BinaryOp::NotEqEq,
            BinaryOp::Lt => BinaryOp::Lt,
            BinaryOp::LtEq => BinaryOp::LtEq,
            BinaryOp::Gt => BinaryOp::Gt,
            BinaryOp::GtEq => BinaryOp::GtEq,
            BinaryOp::LShift => BinaryOp::LShift,
            BinaryOp::RShift => BinaryOp::RShift,
            BinaryOp::ZeroFillRShift => BinaryOp::ZeroFillRShift,
            BinaryOp::Add => BinaryOp::Add,
            BinaryOp::Sub => BinaryOp::Sub,
            BinaryOp::Mul => BinaryOp::Mul,
            BinaryOp::Div => BinaryOp::Div,
            BinaryOp::Mod => BinaryOp::Mod,
            BinaryOp::BitOr => BinaryOp::BitOr,
            BinaryOp::BitXor => BinaryOp::BitXor,
            BinaryOp::BitAnd => BinaryOp::BitAnd,
            BinaryOp::LogicalOr => BinaryOp::LogicalOr,
            BinaryOp::LogicalAnd => BinaryOp::LogicalAnd,
            BinaryOp::In => BinaryOp::In,
            BinaryOp::InstanceOf => BinaryOp::InstanceOf,
            BinaryOp::Exp => BinaryOp::Exp,
            BinaryOp::NullishCoalescing => BinaryOp::NullishCoalescing,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for BindingIdent {
    #[doc = "Calls [Fold`::fold_binding_ident`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_binding_ident(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            BindingIdent { id, type_ann } => {
                let id = <Ident as FoldWith<V>>::fold_with(id, visitor);
                let type_ann =
                    <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor);
                BindingIdent { id, type_ann }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for BlockStmt {
    #[doc = "Calls [Fold`::fold_block_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_block_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            BlockStmt { span, ctxt, stmts } => {
                let stmts = <Vec<Stmt> as FoldWith<V>>::fold_with(stmts, visitor);
                BlockStmt { span, ctxt, stmts }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for BlockStmtOrExpr {
    #[doc = "Calls [Fold`::fold_block_stmt_or_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_block_stmt_or_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            BlockStmtOrExpr::BlockStmt { 0: _field_0 } => {
                let _field_0 = <BlockStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                BlockStmtOrExpr::BlockStmt { 0: _field_0 }
            }
            BlockStmtOrExpr::Expr { 0: _field_0 } => {
                let _field_0 = <Box<Expr> as FoldWith<V>>::fold_with(_field_0, visitor);
                BlockStmtOrExpr::Expr { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Bool {
    #[doc = "Calls [Fold`::fold_bool`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_bool(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Bool { span, value } => Bool { span, value },
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for BreakStmt {
    #[doc = "Calls [Fold`::fold_break_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_break_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            BreakStmt { span, label } => {
                let label = <Option<Ident> as FoldWith<V>>::fold_with(label, visitor);
                BreakStmt { span, label }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for CallExpr {
    #[doc = "Calls [Fold`::fold_call_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_call_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            CallExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                let callee = <Callee as FoldWith<V>>::fold_with(callee, visitor);
                let args = <Vec<ExprOrSpread> as FoldWith<V>>::fold_with(args, visitor);
                let type_args = <Option<Box<TsTypeParamInstantiation>> as FoldWith<V>>::fold_with(
                    type_args, visitor,
                );
                CallExpr {
                    span,
                    ctxt,
                    callee,
                    args,
                    type_args,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Callee {
    #[doc = "Calls [Fold`::fold_callee`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_callee(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Callee::Super { 0: _field_0 } => {
                let _field_0 = <Super as FoldWith<V>>::fold_with(_field_0, visitor);
                Callee::Super { 0: _field_0 }
            }
            Callee::Import { 0: _field_0 } => {
                let _field_0 = <Import as FoldWith<V>>::fold_with(_field_0, visitor);
                Callee::Import { 0: _field_0 }
            }
            Callee::Expr { 0: _field_0 } => {
                let _field_0 = <Box<Expr> as FoldWith<V>>::fold_with(_field_0, visitor);
                Callee::Expr { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for CatchClause {
    #[doc = "Calls [Fold`::fold_catch_clause`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_catch_clause(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            CatchClause { span, param, body } => {
                let param = <Option<Pat> as FoldWith<V>>::fold_with(param, visitor);
                let body = <BlockStmt as FoldWith<V>>::fold_with(body, visitor);
                CatchClause { span, param, body }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Class {
    #[doc = "Calls [Fold`::fold_class`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_class(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Class {
                span,
                ctxt,
                decorators,
                body,
                super_class,
                is_abstract,
                type_params,
                super_type_params,
                implements,
            } => {
                let decorators = <Vec<Decorator> as FoldWith<V>>::fold_with(decorators, visitor);
                let body = <Vec<ClassMember> as FoldWith<V>>::fold_with(body, visitor);
                let super_class =
                    <Option<Box<Expr>> as FoldWith<V>>::fold_with(super_class, visitor);
                let type_params =
                    <Option<Box<TsTypeParamDecl>> as FoldWith<V>>::fold_with(type_params, visitor);
                let super_type_params =
                    <Option<Box<TsTypeParamInstantiation>> as FoldWith<V>>::fold_with(
                        super_type_params,
                        visitor,
                    );
                let implements =
                    <Vec<TsExprWithTypeArgs> as FoldWith<V>>::fold_with(implements, visitor);
                Class {
                    span,
                    ctxt,
                    decorators,
                    body,
                    super_class,
                    is_abstract,
                    type_params,
                    super_type_params,
                    implements,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ClassDecl {
    #[doc = "Calls [Fold`::fold_class_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_class_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ClassDecl {
                ident,
                declare,
                class,
            } => {
                let ident = <Ident as FoldWith<V>>::fold_with(ident, visitor);
                let class = <Box<Class> as FoldWith<V>>::fold_with(class, visitor);
                ClassDecl {
                    ident,
                    declare,
                    class,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ClassExpr {
    #[doc = "Calls [Fold`::fold_class_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_class_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ClassExpr { ident, class } => {
                let ident = <Option<Ident> as FoldWith<V>>::fold_with(ident, visitor);
                let class = <Box<Class> as FoldWith<V>>::fold_with(class, visitor);
                ClassExpr { ident, class }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ClassMember {
    #[doc = "Calls [Fold`::fold_class_member`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_class_member(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ClassMember::Constructor { 0: _field_0 } => {
                let _field_0 = <Constructor as FoldWith<V>>::fold_with(_field_0, visitor);
                ClassMember::Constructor { 0: _field_0 }
            }
            ClassMember::Method { 0: _field_0 } => ClassMember::Method { 0: _field_0 },
            ClassMember::PrivateMethod { 0: _field_0 } => {
                ClassMember::PrivateMethod { 0: _field_0 }
            }
            ClassMember::ClassProp { 0: _field_0 } => {
                let _field_0 = <ClassProp as FoldWith<V>>::fold_with(_field_0, visitor);
                ClassMember::ClassProp { 0: _field_0 }
            }
            ClassMember::PrivateProp { 0: _field_0 } => {
                let _field_0 = <PrivateProp as FoldWith<V>>::fold_with(_field_0, visitor);
                ClassMember::PrivateProp { 0: _field_0 }
            }
            ClassMember::TsIndexSignature { 0: _field_0 } => {
                let _field_0 = <TsIndexSignature as FoldWith<V>>::fold_with(_field_0, visitor);
                ClassMember::TsIndexSignature { 0: _field_0 }
            }
            ClassMember::Empty { 0: _field_0 } => {
                let _field_0 = <EmptyStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                ClassMember::Empty { 0: _field_0 }
            }
            ClassMember::StaticBlock { 0: _field_0 } => {
                let _field_0 = <StaticBlock as FoldWith<V>>::fold_with(_field_0, visitor);
                ClassMember::StaticBlock { 0: _field_0 }
            }
            ClassMember::AutoAccessor { 0: _field_0 } => {
                let _field_0 = <AutoAccessor as FoldWith<V>>::fold_with(_field_0, visitor);
                ClassMember::AutoAccessor { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ClassProp {
    #[doc = "Calls [Fold`::fold_class_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_class_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ClassProp {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
                readonly,
                declare,
                definite,
            } => {
                let key = <PropName as FoldWith<V>>::fold_with(key, visitor);
                let value = <Option<Box<Expr>> as FoldWith<V>>::fold_with(value, visitor);
                let type_ann =
                    <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor);
                let decorators = <Vec<Decorator> as FoldWith<V>>::fold_with(decorators, visitor);
                let accessibility =
                    <Option<Accessibility> as FoldWith<V>>::fold_with(accessibility, visitor);
                ClassProp {
                    span,
                    key,
                    value,
                    type_ann,
                    is_static,
                    decorators,
                    accessibility,
                    is_abstract,
                    is_optional,
                    is_override,
                    readonly,
                    declare,
                    definite,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ComputedPropName {
    #[doc = "Calls [Fold`::fold_computed_prop_name`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_computed_prop_name(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ComputedPropName { span, expr } => {
                let expr = <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor);
                ComputedPropName { span, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for CondExpr {
    #[doc = "Calls [Fold`::fold_cond_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_cond_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            CondExpr {
                span,
                test,
                cons,
                alt,
            } => {
                let test = <Box<Expr> as FoldWith<V>>::fold_with(test, visitor);
                let cons = <Box<Expr> as FoldWith<V>>::fold_with(cons, visitor);
                let alt = <Box<Expr> as FoldWith<V>>::fold_with(alt, visitor);
                CondExpr {
                    span,
                    test,
                    cons,
                    alt,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Constructor {
    #[doc = "Calls [Fold`::fold_constructor`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_constructor(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Constructor {
                span,
                ctxt,
                key,
                params,
                body,
                accessibility,
                is_optional,
            } => {
                let key = <PropName as FoldWith<V>>::fold_with(key, visitor);
                let params = <Vec<ParamOrTsParamProp> as FoldWith<V>>::fold_with(params, visitor);
                let body = <Option<BlockStmt> as FoldWith<V>>::fold_with(body, visitor);
                let accessibility =
                    <Option<Accessibility> as FoldWith<V>>::fold_with(accessibility, visitor);
                Constructor {
                    span,
                    ctxt,
                    key,
                    params,
                    body,
                    accessibility,
                    is_optional,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ContinueStmt {
    #[doc = "Calls [Fold`::fold_continue_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_continue_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ContinueStmt { span, label } => {
                let label = <Option<Ident> as FoldWith<V>>::fold_with(label, visitor);
                ContinueStmt { span, label }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for DebuggerStmt {
    #[doc = "Calls [Fold`::fold_debugger_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_debugger_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            DebuggerStmt { span } => DebuggerStmt { span },
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Decl {
    #[doc = "Calls [Fold`::fold_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Decl::Class { 0: _field_0 } => {
                let _field_0 = <ClassDecl as FoldWith<V>>::fold_with(_field_0, visitor);
                Decl::Class { 0: _field_0 }
            }
            Decl::Fn { 0: _field_0 } => {
                let _field_0 = <FnDecl as FoldWith<V>>::fold_with(_field_0, visitor);
                Decl::Fn { 0: _field_0 }
            }
            Decl::Var { 0: _field_0 } => {
                let _field_0 = <Box<VarDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                Decl::Var { 0: _field_0 }
            }
            Decl::Using { 0: _field_0 } => {
                let _field_0 = <Box<UsingDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                Decl::Using { 0: _field_0 }
            }
            Decl::TsInterface { 0: _field_0 } => {
                let _field_0 = <Box<TsInterfaceDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                Decl::TsInterface { 0: _field_0 }
            }
            Decl::TsTypeAlias { 0: _field_0 } => {
                let _field_0 = <Box<TsTypeAliasDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                Decl::TsTypeAlias { 0: _field_0 }
            }
            Decl::TsEnum { 0: _field_0 } => {
                let _field_0 = <Box<TsEnumDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                Decl::TsEnum { 0: _field_0 }
            }
            Decl::TsModule { 0: _field_0 } => {
                let _field_0 = <Box<TsModuleDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                Decl::TsModule { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Decorator {
    #[doc = "Calls [Fold`::fold_decorator`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_decorator(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Decorator { span, expr } => {
                let expr = <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor);
                Decorator { span, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for DefaultDecl {
    #[doc = "Calls [Fold`::fold_default_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_default_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            DefaultDecl::Class { 0: _field_0 } => {
                let _field_0 = <ClassExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                DefaultDecl::Class { 0: _field_0 }
            }
            DefaultDecl::Fn { 0: _field_0 } => {
                let _field_0 = <FnExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                DefaultDecl::Fn { 0: _field_0 }
            }
            DefaultDecl::TsInterfaceDecl { 0: _field_0 } => {
                let _field_0 = <Box<TsInterfaceDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                DefaultDecl::TsInterfaceDecl { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for DoWhileStmt {
    #[doc = "Calls [Fold`::fold_do_while_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_do_while_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            DoWhileStmt { span, test, body } => {
                let test = <Box<Expr> as FoldWith<V>>::fold_with(test, visitor);
                let body = <Box<Stmt> as FoldWith<V>>::fold_with(body, visitor);
                DoWhileStmt { span, test, body }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for EmptyStmt {
    #[doc = "Calls [Fold`::fold_empty_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_empty_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            EmptyStmt { span } => EmptyStmt { span },
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for EsVersion {
    #[doc = "Calls [Fold`::fold_es_version`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_es_version(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            EsVersion::Es3 => EsVersion::Es3,
            EsVersion::Es5 => EsVersion::Es5,
            EsVersion::Es2015 => EsVersion::Es2015,
            EsVersion::Es2016 => EsVersion::Es2016,
            EsVersion::Es2017 => EsVersion::Es2017,
            EsVersion::Es2018 => EsVersion::Es2018,
            EsVersion::Es2019 => EsVersion::Es2019,
            EsVersion::Es2020 => EsVersion::Es2020,
            EsVersion::Es2021 => EsVersion::Es2021,
            EsVersion::Es2022 => EsVersion::Es2022,
            EsVersion::EsNext => EsVersion::EsNext,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ExportAll {
    #[doc = "Calls [Fold`::fold_export_all`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_export_all(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ExportAll {
                span,
                src,
                type_only,
                with,
            } => {
                let src = <Box<Str> as FoldWith<V>>::fold_with(src, visitor);
                let with = <Option<Box<ObjectLit>> as FoldWith<V>>::fold_with(with, visitor);
                ExportAll {
                    span,
                    src,
                    type_only,
                    with,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ExportDecl {
    #[doc = "Calls [Fold`::fold_export_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_export_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ExportDecl { span, decl } => {
                let decl = <Decl as FoldWith<V>>::fold_with(decl, visitor);
                ExportDecl { span, decl }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ExportDefaultDecl {
    #[doc = "Calls [Fold`::fold_export_default_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_export_default_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ExportDefaultDecl { span, decl } => {
                let decl = <DefaultDecl as FoldWith<V>>::fold_with(decl, visitor);
                ExportDefaultDecl { span, decl }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ExportDefaultExpr {
    #[doc = "Calls [Fold`::fold_export_default_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_export_default_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ExportDefaultExpr { span, expr } => {
                let expr = <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor);
                ExportDefaultExpr { span, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ExportDefaultSpecifier {
    #[doc = "Calls [Fold`::fold_export_default_specifier`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_export_default_specifier(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ExportDefaultSpecifier { exported } => {
                let exported = <Ident as FoldWith<V>>::fold_with(exported, visitor);
                ExportDefaultSpecifier { exported }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ExportNamedSpecifier {
    #[doc = "Calls [Fold`::fold_export_named_specifier`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_export_named_specifier(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ExportNamedSpecifier {
                span,
                orig,
                exported,
                is_type_only,
            } => {
                let orig = <ModuleExportName as FoldWith<V>>::fold_with(orig, visitor);
                let exported =
                    <Option<ModuleExportName> as FoldWith<V>>::fold_with(exported, visitor);
                ExportNamedSpecifier {
                    span,
                    orig,
                    exported,
                    is_type_only,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ExportNamespaceSpecifier {
    #[doc = "Calls [Fold`::fold_export_namespace_specifier`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_export_namespace_specifier(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ExportNamespaceSpecifier { span, name } => {
                let name = <ModuleExportName as FoldWith<V>>::fold_with(name, visitor);
                ExportNamespaceSpecifier { span, name }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ExportSpecifier {
    #[doc = "Calls [Fold`::fold_export_specifier`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_export_specifier(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ExportSpecifier::Namespace { 0: _field_0 } => {
                let _field_0 =
                    <ExportNamespaceSpecifier as FoldWith<V>>::fold_with(_field_0, visitor);
                ExportSpecifier::Namespace { 0: _field_0 }
            }
            ExportSpecifier::Default { 0: _field_0 } => {
                let _field_0 =
                    <ExportDefaultSpecifier as FoldWith<V>>::fold_with(_field_0, visitor);
                ExportSpecifier::Default { 0: _field_0 }
            }
            ExportSpecifier::Named { 0: _field_0 } => {
                let _field_0 = <ExportNamedSpecifier as FoldWith<V>>::fold_with(_field_0, visitor);
                ExportSpecifier::Named { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Expr {
    #[doc = "Calls [Fold`::fold_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Expr::This { 0: _field_0 } => {
                let _field_0 = <ThisExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::This { 0: _field_0 }
            }
            Expr::Array { 0: _field_0 } => {
                let _field_0 = <ArrayLit as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Array { 0: _field_0 }
            }
            Expr::Object { 0: _field_0 } => {
                let _field_0 = <ObjectLit as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Object { 0: _field_0 }
            }
            Expr::Fn { 0: _field_0 } => {
                let _field_0 = <FnExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Fn { 0: _field_0 }
            }
            Expr::Unary { 0: _field_0 } => {
                let _field_0 = <UnaryExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Unary { 0: _field_0 }
            }
            Expr::Update { 0: _field_0 } => {
                let _field_0 = <UpdateExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Update { 0: _field_0 }
            }
            Expr::Bin { 0: _field_0 } => {
                let _field_0 = <BinExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Bin { 0: _field_0 }
            }
            Expr::Assign { 0: _field_0 } => {
                let _field_0 = <AssignExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Assign { 0: _field_0 }
            }
            Expr::Member { 0: _field_0 } => {
                let _field_0 = <MemberExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Member { 0: _field_0 }
            }
            Expr::SuperProp { 0: _field_0 } => {
                let _field_0 = <SuperPropExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::SuperProp { 0: _field_0 }
            }
            Expr::Cond { 0: _field_0 } => {
                let _field_0 = <CondExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Cond { 0: _field_0 }
            }
            Expr::Call { 0: _field_0 } => {
                let _field_0 = <CallExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Call { 0: _field_0 }
            }
            Expr::New { 0: _field_0 } => {
                let _field_0 = <NewExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::New { 0: _field_0 }
            }
            Expr::Seq { 0: _field_0 } => {
                let _field_0 = <SeqExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Seq { 0: _field_0 }
            }
            Expr::Ident { 0: _field_0 } => {
                let _field_0 = <Ident as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Ident { 0: _field_0 }
            }
            Expr::Lit { 0: _field_0 } => {
                let _field_0 = <Lit as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Lit { 0: _field_0 }
            }
            Expr::Tpl { 0: _field_0 } => {
                let _field_0 = <Tpl as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Tpl { 0: _field_0 }
            }
            Expr::TaggedTpl { 0: _field_0 } => {
                let _field_0 = <TaggedTpl as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::TaggedTpl { 0: _field_0 }
            }
            Expr::Arrow { 0: _field_0 } => {
                let _field_0 = <ArrowExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Arrow { 0: _field_0 }
            }
            Expr::Class { 0: _field_0 } => {
                let _field_0 = <ClassExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Class { 0: _field_0 }
            }
            Expr::Yield { 0: _field_0 } => {
                let _field_0 = <YieldExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Yield { 0: _field_0 }
            }
            Expr::MetaProp { 0: _field_0 } => {
                let _field_0 = <MetaPropExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::MetaProp { 0: _field_0 }
            }
            Expr::Await { 0: _field_0 } => {
                let _field_0 = <AwaitExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Await { 0: _field_0 }
            }
            Expr::Paren { 0: _field_0 } => {
                let _field_0 = <ParenExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Paren { 0: _field_0 }
            }
            Expr::JSXMember { 0: _field_0 } => {
                let _field_0 = <JSXMemberExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::JSXMember { 0: _field_0 }
            }
            Expr::JSXNamespacedName { 0: _field_0 } => {
                let _field_0 = <JSXNamespacedName as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::JSXNamespacedName { 0: _field_0 }
            }
            Expr::JSXEmpty { 0: _field_0 } => {
                let _field_0 = <JSXEmptyExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::JSXEmpty { 0: _field_0 }
            }
            Expr::JSXElement { 0: _field_0 } => {
                let _field_0 = <Box<JSXElement> as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::JSXElement { 0: _field_0 }
            }
            Expr::JSXFragment { 0: _field_0 } => {
                let _field_0 = <JSXFragment as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::JSXFragment { 0: _field_0 }
            }
            Expr::TsTypeAssertion { 0: _field_0 } => {
                let _field_0 = <TsTypeAssertion as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::TsTypeAssertion { 0: _field_0 }
            }
            Expr::TsConstAssertion { 0: _field_0 } => {
                let _field_0 = <TsConstAssertion as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::TsConstAssertion { 0: _field_0 }
            }
            Expr::TsNonNull { 0: _field_0 } => {
                let _field_0 = <TsNonNullExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::TsNonNull { 0: _field_0 }
            }
            Expr::TsAs { 0: _field_0 } => {
                let _field_0 = <TsAsExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::TsAs { 0: _field_0 }
            }
            Expr::TsInstantiation { 0: _field_0 } => {
                let _field_0 = <TsInstantiation as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::TsInstantiation { 0: _field_0 }
            }
            Expr::TsSatisfies { 0: _field_0 } => {
                let _field_0 = <TsSatisfiesExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::TsSatisfies { 0: _field_0 }
            }
            Expr::PrivateName { 0: _field_0 } => {
                let _field_0 = <PrivateName as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::PrivateName { 0: _field_0 }
            }
            Expr::OptChain { 0: _field_0 } => {
                let _field_0 = <OptChainExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::OptChain { 0: _field_0 }
            }
            Expr::Invalid { 0: _field_0 } => {
                let _field_0 = <Invalid as FoldWith<V>>::fold_with(_field_0, visitor);
                Expr::Invalid { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ExprOrSpread {
    #[doc = "Calls [Fold`::fold_expr_or_spread`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_expr_or_spread(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ExprOrSpread { spread, expr } => {
                let expr = <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor);
                ExprOrSpread { spread, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ExprStmt {
    #[doc = "Calls [Fold`::fold_expr_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_expr_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ExprStmt { span, expr } => {
                let expr = <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor);
                ExprStmt { span, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for FnDecl {
    #[doc = "Calls [Fold`::fold_fn_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_fn_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            FnDecl {
                ident,
                declare,
                function,
            } => {
                let ident = <Ident as FoldWith<V>>::fold_with(ident, visitor);
                let function = <Box<Function> as FoldWith<V>>::fold_with(function, visitor);
                FnDecl {
                    ident,
                    declare,
                    function,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for FnExpr {
    #[doc = "Calls [Fold`::fold_fn_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_fn_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            FnExpr { ident, function } => {
                let ident = <Option<Ident> as FoldWith<V>>::fold_with(ident, visitor);
                let function = <Box<Function> as FoldWith<V>>::fold_with(function, visitor);
                FnExpr { ident, function }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ForHead {
    #[doc = "Calls [Fold`::fold_for_head`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_for_head(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ForHead::VarDecl { 0: _field_0 } => {
                let _field_0 = <Box<VarDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                ForHead::VarDecl { 0: _field_0 }
            }
            ForHead::UsingDecl { 0: _field_0 } => {
                let _field_0 = <Box<UsingDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                ForHead::UsingDecl { 0: _field_0 }
            }
            ForHead::Pat { 0: _field_0 } => {
                let _field_0 = <Box<Pat> as FoldWith<V>>::fold_with(_field_0, visitor);
                ForHead::Pat { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ForInStmt {
    #[doc = "Calls [Fold`::fold_for_in_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_for_in_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ForInStmt {
                span,
                left,
                right,
                body,
            } => {
                let left = <ForHead as FoldWith<V>>::fold_with(left, visitor);
                let right = <Box<Expr> as FoldWith<V>>::fold_with(right, visitor);
                let body = <Box<Stmt> as FoldWith<V>>::fold_with(body, visitor);
                ForInStmt {
                    span,
                    left,
                    right,
                    body,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ForOfStmt {
    #[doc = "Calls [Fold`::fold_for_of_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_for_of_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ForOfStmt {
                span,
                is_await,
                left,
                right,
                body,
            } => {
                let left = <ForHead as FoldWith<V>>::fold_with(left, visitor);
                let right = <Box<Expr> as FoldWith<V>>::fold_with(right, visitor);
                let body = <Box<Stmt> as FoldWith<V>>::fold_with(body, visitor);
                ForOfStmt {
                    span,
                    is_await,
                    left,
                    right,
                    body,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ForStmt {
    #[doc = "Calls [Fold`::fold_for_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_for_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ForStmt {
                span,
                init,
                test,
                update,
                body,
            } => {
                let init = <Option<VarDeclOrExpr> as FoldWith<V>>::fold_with(init, visitor);
                let test = <Option<Box<Expr>> as FoldWith<V>>::fold_with(test, visitor);
                let update = <Option<Box<Expr>> as FoldWith<V>>::fold_with(update, visitor);
                let body = <Box<Stmt> as FoldWith<V>>::fold_with(body, visitor);
                ForStmt {
                    span,
                    init,
                    test,
                    update,
                    body,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Function {
    #[doc = "Calls [Fold`::fold_function`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_function(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Function {
                params,
                decorators,
                span,
                ctxt,
                body,
                is_generator,
                is_async,
                type_params,
                return_type,
            } => {
                let params = <Vec<Param> as FoldWith<V>>::fold_with(params, visitor);
                let decorators = <Vec<Decorator> as FoldWith<V>>::fold_with(decorators, visitor);
                let body = <Option<BlockStmt> as FoldWith<V>>::fold_with(body, visitor);
                let type_params =
                    <Option<Box<TsTypeParamDecl>> as FoldWith<V>>::fold_with(type_params, visitor);
                let return_type =
                    <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(return_type, visitor);
                Function {
                    params,
                    decorators,
                    span,
                    ctxt,
                    body,
                    is_generator,
                    is_async,
                    type_params,
                    return_type,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for GetterProp {
    #[doc = "Calls [Fold`::fold_getter_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_getter_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            GetterProp {
                span,
                key,
                type_ann,
                body,
            } => {
                let key = <PropName as FoldWith<V>>::fold_with(key, visitor);
                let type_ann =
                    <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor);
                let body = <Option<BlockStmt> as FoldWith<V>>::fold_with(body, visitor);
                GetterProp {
                    span,
                    key,
                    type_ann,
                    body,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Ident {
    #[doc = "Calls [Fold`::fold_ident`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ident(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Ident {
                span,
                ctxt,
                sym,
                optional,
            } => Ident {
                span,
                ctxt,
                sym,
                optional,
            },
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for IdentName {
    #[doc = "Calls [Fold`::fold_ident_name`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ident_name(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            IdentName { span, sym } => IdentName { span, sym },
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for IfStmt {
    #[doc = "Calls [Fold`::fold_if_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_if_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            IfStmt {
                span,
                test,
                cons,
                alt,
            } => {
                let test = <Box<Expr> as FoldWith<V>>::fold_with(test, visitor);
                let cons = <Box<Stmt> as FoldWith<V>>::fold_with(cons, visitor);
                let alt = <Option<Box<Stmt>> as FoldWith<V>>::fold_with(alt, visitor);
                IfStmt {
                    span,
                    test,
                    cons,
                    alt,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Import {
    #[doc = "Calls [Fold`::fold_import`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Import { span, phase } => {
                let phase = <ImportPhase as FoldWith<V>>::fold_with(phase, visitor);
                Import { span, phase }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ImportDecl {
    #[doc = "Calls [Fold`::fold_import_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ImportDecl {
                span,
                specifiers,
                src,
                type_only,
                with,
                phase,
            } => {
                let specifiers =
                    <Vec<ImportSpecifier> as FoldWith<V>>::fold_with(specifiers, visitor);
                let src = <Box<Str> as FoldWith<V>>::fold_with(src, visitor);
                let with = <Option<Box<ObjectLit>> as FoldWith<V>>::fold_with(with, visitor);
                let phase = <ImportPhase as FoldWith<V>>::fold_with(phase, visitor);
                ImportDecl {
                    span,
                    specifiers,
                    src,
                    type_only,
                    with,
                    phase,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ImportDefaultSpecifier {
    #[doc = "Calls [Fold`::fold_import_default_specifier`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import_default_specifier(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ImportDefaultSpecifier { span, local } => {
                let local = <Ident as FoldWith<V>>::fold_with(local, visitor);
                ImportDefaultSpecifier { span, local }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ImportNamedSpecifier {
    #[doc = "Calls [Fold`::fold_import_named_specifier`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import_named_specifier(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ImportNamedSpecifier {
                span,
                local,
                imported,
                is_type_only,
            } => {
                let local = <Ident as FoldWith<V>>::fold_with(local, visitor);
                let imported =
                    <Option<ModuleExportName> as FoldWith<V>>::fold_with(imported, visitor);
                ImportNamedSpecifier {
                    span,
                    local,
                    imported,
                    is_type_only,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ImportPhase {
    #[doc = "Calls [Fold`::fold_import_phase`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import_phase(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ImportPhase::Evaluation => ImportPhase::Evaluation,
            ImportPhase::Source => ImportPhase::Source,
            ImportPhase::Defer => ImportPhase::Defer,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ImportSpecifier {
    #[doc = "Calls [Fold`::fold_import_specifier`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import_specifier(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ImportSpecifier::Named { 0: _field_0 } => {
                let _field_0 = <ImportNamedSpecifier as FoldWith<V>>::fold_with(_field_0, visitor);
                ImportSpecifier::Named { 0: _field_0 }
            }
            ImportSpecifier::Default { 0: _field_0 } => {
                let _field_0 =
                    <ImportDefaultSpecifier as FoldWith<V>>::fold_with(_field_0, visitor);
                ImportSpecifier::Default { 0: _field_0 }
            }
            ImportSpecifier::Namespace { 0: _field_0 } => {
                let _field_0 = <ImportStarAsSpecifier as FoldWith<V>>::fold_with(_field_0, visitor);
                ImportSpecifier::Namespace { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ImportStarAsSpecifier {
    #[doc = "Calls [Fold`::fold_import_star_as_specifier`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import_star_as_specifier(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ImportStarAsSpecifier { span, local } => {
                let local = <Ident as FoldWith<V>>::fold_with(local, visitor);
                ImportStarAsSpecifier { span, local }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ImportWith {
    #[doc = "Calls [Fold`::fold_import_with`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import_with(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ImportWith { span, values } => {
                let values = <Vec<ImportWithItem> as FoldWith<V>>::fold_with(values, visitor);
                ImportWith { span, values }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ImportWithItem {
    #[doc = "Calls [Fold`::fold_import_with_item`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import_with_item(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ImportWithItem { key, value } => {
                let key = <IdentName as FoldWith<V>>::fold_with(key, visitor);
                let value = <Str as FoldWith<V>>::fold_with(value, visitor);
                ImportWithItem { key, value }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Invalid {
    #[doc = "Calls [Fold`::fold_invalid`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_invalid(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Invalid { span } => Invalid { span },
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXAttr {
    #[doc = "Calls [Fold`::fold_jsx_attr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_attr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXAttr { span, name, value } => {
                let name = <JSXAttrName as FoldWith<V>>::fold_with(name, visitor);
                let value = <Option<JSXAttrValue> as FoldWith<V>>::fold_with(value, visitor);
                JSXAttr { span, name, value }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXAttrName {
    #[doc = "Calls [Fold`::fold_jsx_attr_name`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_attr_name(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXAttrName::Ident { 0: _field_0 } => {
                let _field_0 = <IdentName as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXAttrName::Ident { 0: _field_0 }
            }
            JSXAttrName::JSXNamespacedName { 0: _field_0 } => {
                let _field_0 = <JSXNamespacedName as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXAttrName::JSXNamespacedName { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXAttrOrSpread {
    #[doc = "Calls [Fold`::fold_jsx_attr_or_spread`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_attr_or_spread(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXAttrOrSpread::JSXAttr { 0: _field_0 } => {
                let _field_0 = <JSXAttr as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXAttrOrSpread::JSXAttr { 0: _field_0 }
            }
            JSXAttrOrSpread::SpreadElement { 0: _field_0 } => {
                let _field_0 = <SpreadElement as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXAttrOrSpread::SpreadElement { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXAttrValue {
    #[doc = "Calls [Fold`::fold_jsx_attr_value`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_attr_value(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXAttrValue::Lit { 0: _field_0 } => {
                let _field_0 = <Lit as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXAttrValue::Lit { 0: _field_0 }
            }
            JSXAttrValue::JSXExprContainer { 0: _field_0 } => {
                let _field_0 = <JSXExprContainer as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXAttrValue::JSXExprContainer { 0: _field_0 }
            }
            JSXAttrValue::JSXElement { 0: _field_0 } => {
                let _field_0 = <Box<JSXElement> as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXAttrValue::JSXElement { 0: _field_0 }
            }
            JSXAttrValue::JSXFragment { 0: _field_0 } => {
                let _field_0 = <JSXFragment as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXAttrValue::JSXFragment { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXClosingElement {
    #[doc = "Calls [Fold`::fold_jsx_closing_element`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_closing_element(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXClosingElement { span, name } => {
                let name = <JSXElementName as FoldWith<V>>::fold_with(name, visitor);
                JSXClosingElement { span, name }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXClosingFragment {
    #[doc = "Calls [Fold`::fold_jsx_closing_fragment`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_closing_fragment(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXClosingFragment { span } => JSXClosingFragment { span },
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXElement {
    #[doc = "Calls [Fold`::fold_jsx_element`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_element(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXElement {
                span,
                opening,
                children,
                closing,
            } => {
                let opening = <JSXOpeningElement as FoldWith<V>>::fold_with(opening, visitor);
                let children = <Vec<JSXElementChild> as FoldWith<V>>::fold_with(children, visitor);
                let closing =
                    <Option<JSXClosingElement> as FoldWith<V>>::fold_with(closing, visitor);
                JSXElement {
                    span,
                    opening,
                    children,
                    closing,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXElementChild {
    #[doc = "Calls [Fold`::fold_jsx_element_child`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_element_child(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXElementChild::JSXText { 0: _field_0 } => {
                let _field_0 = <JSXText as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXElementChild::JSXText { 0: _field_0 }
            }
            JSXElementChild::JSXExprContainer { 0: _field_0 } => {
                let _field_0 = <JSXExprContainer as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXElementChild::JSXExprContainer { 0: _field_0 }
            }
            JSXElementChild::JSXSpreadChild { 0: _field_0 } => {
                let _field_0 = <JSXSpreadChild as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXElementChild::JSXSpreadChild { 0: _field_0 }
            }
            JSXElementChild::JSXElement { 0: _field_0 } => {
                let _field_0 = <Box<JSXElement> as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXElementChild::JSXElement { 0: _field_0 }
            }
            JSXElementChild::JSXFragment { 0: _field_0 } => {
                let _field_0 = <JSXFragment as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXElementChild::JSXFragment { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXElementName {
    #[doc = "Calls [Fold`::fold_jsx_element_name`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_element_name(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXElementName::Ident { 0: _field_0 } => {
                let _field_0 = <Ident as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXElementName::Ident { 0: _field_0 }
            }
            JSXElementName::JSXMemberExpr { 0: _field_0 } => {
                let _field_0 = <JSXMemberExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXElementName::JSXMemberExpr { 0: _field_0 }
            }
            JSXElementName::JSXNamespacedName { 0: _field_0 } => {
                let _field_0 = <JSXNamespacedName as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXElementName::JSXNamespacedName { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXEmptyExpr {
    #[doc = "Calls [Fold`::fold_jsx_empty_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_empty_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXEmptyExpr { span } => JSXEmptyExpr { span },
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXExpr {
    #[doc = "Calls [Fold`::fold_jsx_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXExpr::JSXEmptyExpr { 0: _field_0 } => {
                let _field_0 = <JSXEmptyExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXExpr::JSXEmptyExpr { 0: _field_0 }
            }
            JSXExpr::Expr { 0: _field_0 } => {
                let _field_0 = <Box<Expr> as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXExpr::Expr { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXExprContainer {
    #[doc = "Calls [Fold`::fold_jsx_expr_container`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_expr_container(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXExprContainer { span, expr } => {
                let expr = <JSXExpr as FoldWith<V>>::fold_with(expr, visitor);
                JSXExprContainer { span, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXFragment {
    #[doc = "Calls [Fold`::fold_jsx_fragment`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_fragment(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXFragment {
                span,
                opening,
                children,
                closing,
            } => {
                let opening = <JSXOpeningFragment as FoldWith<V>>::fold_with(opening, visitor);
                let children = <Vec<JSXElementChild> as FoldWith<V>>::fold_with(children, visitor);
                let closing = <JSXClosingFragment as FoldWith<V>>::fold_with(closing, visitor);
                JSXFragment {
                    span,
                    opening,
                    children,
                    closing,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXMemberExpr {
    #[doc = "Calls [Fold`::fold_jsx_member_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_member_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXMemberExpr { span, obj, prop } => {
                let obj = <JSXObject as FoldWith<V>>::fold_with(obj, visitor);
                let prop = <IdentName as FoldWith<V>>::fold_with(prop, visitor);
                JSXMemberExpr { span, obj, prop }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXNamespacedName {
    #[doc = "Calls [Fold`::fold_jsx_namespaced_name`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_namespaced_name(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXNamespacedName { span, ns, name } => {
                let ns = <IdentName as FoldWith<V>>::fold_with(ns, visitor);
                let name = <IdentName as FoldWith<V>>::fold_with(name, visitor);
                JSXNamespacedName { span, ns, name }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXObject {
    #[doc = "Calls [Fold`::fold_jsx_object`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_object(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXObject::JSXMemberExpr { 0: _field_0 } => {
                let _field_0 = <Box<JSXMemberExpr> as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXObject::JSXMemberExpr { 0: _field_0 }
            }
            JSXObject::Ident { 0: _field_0 } => {
                let _field_0 = <Ident as FoldWith<V>>::fold_with(_field_0, visitor);
                JSXObject::Ident { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXOpeningElement {
    #[doc = "Calls [Fold`::fold_jsx_opening_element`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_opening_element(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXOpeningElement {
                name,
                span,
                attrs,
                self_closing,
                type_args,
            } => {
                let name = <JSXElementName as FoldWith<V>>::fold_with(name, visitor);
                let attrs = <Vec<JSXAttrOrSpread> as FoldWith<V>>::fold_with(attrs, visitor);
                let type_args = <Option<Box<TsTypeParamInstantiation>> as FoldWith<V>>::fold_with(
                    type_args, visitor,
                );
                JSXOpeningElement {
                    name,
                    span,
                    attrs,
                    self_closing,
                    type_args,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXOpeningFragment {
    #[doc = "Calls [Fold`::fold_jsx_opening_fragment`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_opening_fragment(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXOpeningFragment { span } => JSXOpeningFragment { span },
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXSpreadChild {
    #[doc = "Calls [Fold`::fold_jsx_spread_child`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_spread_child(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXSpreadChild { span, expr } => {
                let expr = <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor);
                JSXSpreadChild { span, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for JSXText {
    #[doc = "Calls [Fold`::fold_jsx_text`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_text(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            JSXText { span, value, raw } => JSXText { span, value, raw },
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Key {
    #[doc = "Calls [Fold`::fold_key`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_key(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Key::Private { 0: _field_0 } => {
                let _field_0 = <PrivateName as FoldWith<V>>::fold_with(_field_0, visitor);
                Key::Private { 0: _field_0 }
            }
            Key::Public { 0: _field_0 } => {
                let _field_0 = <PropName as FoldWith<V>>::fold_with(_field_0, visitor);
                Key::Public { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for KeyValuePatProp {
    #[doc = "Calls [Fold`::fold_key_value_pat_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_key_value_pat_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            KeyValuePatProp { key, value } => {
                let key = <PropName as FoldWith<V>>::fold_with(key, visitor);
                let value = <Box<Pat> as FoldWith<V>>::fold_with(value, visitor);
                KeyValuePatProp { key, value }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for KeyValueProp {
    #[doc = "Calls [Fold`::fold_key_value_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_key_value_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            KeyValueProp { key, value } => {
                let key = <PropName as FoldWith<V>>::fold_with(key, visitor);
                let value = <Box<Expr> as FoldWith<V>>::fold_with(value, visitor);
                KeyValueProp { key, value }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for LabeledStmt {
    #[doc = "Calls [Fold`::fold_labeled_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_labeled_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            LabeledStmt { span, label, body } => {
                let label = <Ident as FoldWith<V>>::fold_with(label, visitor);
                let body = <Box<Stmt> as FoldWith<V>>::fold_with(body, visitor);
                LabeledStmt { span, label, body }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Lit {
    #[doc = "Calls [Fold`::fold_lit`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_lit(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Lit::Str { 0: _field_0 } => {
                let _field_0 = <Str as FoldWith<V>>::fold_with(_field_0, visitor);
                Lit::Str { 0: _field_0 }
            }
            Lit::Bool { 0: _field_0 } => {
                let _field_0 = <Bool as FoldWith<V>>::fold_with(_field_0, visitor);
                Lit::Bool { 0: _field_0 }
            }
            Lit::Null { 0: _field_0 } => {
                let _field_0 = <Null as FoldWith<V>>::fold_with(_field_0, visitor);
                Lit::Null { 0: _field_0 }
            }
            Lit::Num { 0: _field_0 } => {
                let _field_0 = <Number as FoldWith<V>>::fold_with(_field_0, visitor);
                Lit::Num { 0: _field_0 }
            }
            Lit::BigInt { 0: _field_0 } => {
                let _field_0 = <BigInt as FoldWith<V>>::fold_with(_field_0, visitor);
                Lit::BigInt { 0: _field_0 }
            }
            Lit::Regex { 0: _field_0 } => {
                let _field_0 = <Regex as FoldWith<V>>::fold_with(_field_0, visitor);
                Lit::Regex { 0: _field_0 }
            }
            Lit::JSXText { 0: _field_0 } => {
                let _field_0 = <JSXText as FoldWith<V>>::fold_with(_field_0, visitor);
                Lit::JSXText { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for MemberExpr {
    #[doc = "Calls [Fold`::fold_member_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_member_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            MemberExpr { span, obj, prop } => {
                let obj = <Box<Expr> as FoldWith<V>>::fold_with(obj, visitor);
                let prop = <MemberProp as FoldWith<V>>::fold_with(prop, visitor);
                MemberExpr { span, obj, prop }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for MemberProp {
    #[doc = "Calls [Fold`::fold_member_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_member_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            MemberProp::Ident { 0: _field_0 } => {
                let _field_0 = <IdentName as FoldWith<V>>::fold_with(_field_0, visitor);
                MemberProp::Ident { 0: _field_0 }
            }
            MemberProp::PrivateName { 0: _field_0 } => {
                let _field_0 = <PrivateName as FoldWith<V>>::fold_with(_field_0, visitor);
                MemberProp::PrivateName { 0: _field_0 }
            }
            MemberProp::Computed { 0: _field_0 } => {
                let _field_0 = <ComputedPropName as FoldWith<V>>::fold_with(_field_0, visitor);
                MemberProp::Computed { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for MetaPropExpr {
    #[doc = "Calls [Fold`::fold_meta_prop_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_meta_prop_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            MetaPropExpr { span, kind } => {
                let kind = <MetaPropKind as FoldWith<V>>::fold_with(kind, visitor);
                MetaPropExpr { span, kind }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for MetaPropKind {
    #[doc = "Calls [Fold`::fold_meta_prop_kind`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_meta_prop_kind(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            MetaPropKind::NewTarget => MetaPropKind::NewTarget,
            MetaPropKind::ImportMeta => MetaPropKind::ImportMeta,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for MethodKind {
    #[doc = "Calls [Fold`::fold_method_kind`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_method_kind(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            MethodKind::Method => MethodKind::Method,
            MethodKind::Getter => MethodKind::Getter,
            MethodKind::Setter => MethodKind::Setter,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for MethodProp {
    #[doc = "Calls [Fold`::fold_method_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_method_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            MethodProp { key, function } => {
                let key = <PropName as FoldWith<V>>::fold_with(key, visitor);
                let function = <Box<Function> as FoldWith<V>>::fold_with(function, visitor);
                MethodProp { key, function }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Module {
    #[doc = "Calls [Fold`::fold_module`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_module(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Module {
                span,
                body,
                shebang,
            } => {
                let body = <Vec<ModuleItem> as FoldWith<V>>::fold_with(body, visitor);
                Module {
                    span,
                    body,
                    shebang,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ModuleDecl {
    #[doc = "Calls [Fold`::fold_module_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_module_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ModuleDecl::Import { 0: _field_0 } => {
                let _field_0 = <ImportDecl as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleDecl::Import { 0: _field_0 }
            }
            ModuleDecl::ExportDecl { 0: _field_0 } => {
                let _field_0 = <ExportDecl as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleDecl::ExportDecl { 0: _field_0 }
            }
            ModuleDecl::ExportNamed { 0: _field_0 } => {
                let _field_0 = <NamedExport as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleDecl::ExportNamed { 0: _field_0 }
            }
            ModuleDecl::ExportDefaultDecl { 0: _field_0 } => {
                let _field_0 = <ExportDefaultDecl as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleDecl::ExportDefaultDecl { 0: _field_0 }
            }
            ModuleDecl::ExportDefaultExpr { 0: _field_0 } => {
                let _field_0 = <ExportDefaultExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleDecl::ExportDefaultExpr { 0: _field_0 }
            }
            ModuleDecl::ExportAll { 0: _field_0 } => {
                let _field_0 = <ExportAll as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleDecl::ExportAll { 0: _field_0 }
            }
            ModuleDecl::TsImportEquals { 0: _field_0 } => {
                let _field_0 =
                    <Box<TsImportEqualsDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleDecl::TsImportEquals { 0: _field_0 }
            }
            ModuleDecl::TsExportAssignment { 0: _field_0 } => {
                let _field_0 = <TsExportAssignment as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleDecl::TsExportAssignment { 0: _field_0 }
            }
            ModuleDecl::TsNamespaceExport { 0: _field_0 } => {
                let _field_0 = <TsNamespaceExportDecl as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleDecl::TsNamespaceExport { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ModuleExportName {
    #[doc = "Calls [Fold`::fold_module_export_name`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_module_export_name(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ModuleExportName::Ident { 0: _field_0 } => {
                let _field_0 = <Ident as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleExportName::Ident { 0: _field_0 }
            }
            ModuleExportName::Str { 0: _field_0 } => {
                let _field_0 = <Str as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleExportName::Str { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ModuleItem {
    #[doc = "Calls [Fold`::fold_module_item`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_module_item(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ModuleItem::ModuleDecl { 0: _field_0 } => {
                let _field_0 = <ModuleDecl as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleItem::ModuleDecl { 0: _field_0 }
            }
            ModuleItem::Stmt { 0: _field_0 } => {
                let _field_0 = <Stmt as FoldWith<V>>::fold_with(_field_0, visitor);
                ModuleItem::Stmt { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for NamedExport {
    #[doc = "Calls [Fold`::fold_named_export`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_named_export(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            NamedExport {
                span,
                specifiers,
                src,
                type_only,
                with,
            } => {
                let specifiers =
                    <Vec<ExportSpecifier> as FoldWith<V>>::fold_with(specifiers, visitor);
                let src = <Option<Box<Str>> as FoldWith<V>>::fold_with(src, visitor);
                let with = <Option<Box<ObjectLit>> as FoldWith<V>>::fold_with(with, visitor);
                NamedExport {
                    span,
                    specifiers,
                    src,
                    type_only,
                    with,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for NewExpr {
    #[doc = "Calls [Fold`::fold_new_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_new_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            NewExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                let callee = <Box<Expr> as FoldWith<V>>::fold_with(callee, visitor);
                let args = <Option<Vec<ExprOrSpread>> as FoldWith<V>>::fold_with(args, visitor);
                let type_args = <Option<Box<TsTypeParamInstantiation>> as FoldWith<V>>::fold_with(
                    type_args, visitor,
                );
                NewExpr {
                    span,
                    ctxt,
                    callee,
                    args,
                    type_args,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Null {
    #[doc = "Calls [Fold`::fold_null`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_null(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Null { span } => Null { span },
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Number {
    #[doc = "Calls [Fold`::fold_number`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_number(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Number { span, value, raw } => Number { span, value, raw },
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ObjectLit {
    #[doc = "Calls [Fold`::fold_object_lit`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_object_lit(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ObjectLit { span, props } => {
                let props = <Vec<PropOrSpread> as FoldWith<V>>::fold_with(props, visitor);
                ObjectLit { span, props }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ObjectPat {
    #[doc = "Calls [Fold`::fold_object_pat`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_object_pat(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ObjectPat {
                span,
                props,
                optional,
                type_ann,
            } => {
                let props = <Vec<ObjectPatProp> as FoldWith<V>>::fold_with(props, visitor);
                let type_ann =
                    <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor);
                ObjectPat {
                    span,
                    props,
                    optional,
                    type_ann,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ObjectPatProp {
    #[doc = "Calls [Fold`::fold_object_pat_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_object_pat_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ObjectPatProp::KeyValue { 0: _field_0 } => {
                let _field_0 = <KeyValuePatProp as FoldWith<V>>::fold_with(_field_0, visitor);
                ObjectPatProp::KeyValue { 0: _field_0 }
            }
            ObjectPatProp::Assign { 0: _field_0 } => {
                let _field_0 = <AssignPatProp as FoldWith<V>>::fold_with(_field_0, visitor);
                ObjectPatProp::Assign { 0: _field_0 }
            }
            ObjectPatProp::Rest { 0: _field_0 } => {
                let _field_0 = <RestPat as FoldWith<V>>::fold_with(_field_0, visitor);
                ObjectPatProp::Rest { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for OptCall {
    #[doc = "Calls [Fold`::fold_opt_call`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_call(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            OptCall {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                let callee = <Box<Expr> as FoldWith<V>>::fold_with(callee, visitor);
                let args = <Vec<ExprOrSpread> as FoldWith<V>>::fold_with(args, visitor);
                let type_args = <Option<Box<TsTypeParamInstantiation>> as FoldWith<V>>::fold_with(
                    type_args, visitor,
                );
                OptCall {
                    span,
                    ctxt,
                    callee,
                    args,
                    type_args,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for OptChainBase {
    #[doc = "Calls [Fold`::fold_opt_chain_base`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_chain_base(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            OptChainBase::Member { 0: _field_0 } => {
                let _field_0 = <MemberExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                OptChainBase::Member { 0: _field_0 }
            }
            OptChainBase::Call { 0: _field_0 } => {
                let _field_0 = <OptCall as FoldWith<V>>::fold_with(_field_0, visitor);
                OptChainBase::Call { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for OptChainExpr {
    #[doc = "Calls [Fold`::fold_opt_chain_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_chain_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            OptChainExpr {
                span,
                optional,
                base,
            } => {
                let base = <Box<OptChainBase> as FoldWith<V>>::fold_with(base, visitor);
                OptChainExpr {
                    span,
                    optional,
                    base,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Param {
    #[doc = "Calls [Fold`::fold_param`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_param(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Param {
                span,
                decorators,
                pat,
            } => {
                let decorators = <Vec<Decorator> as FoldWith<V>>::fold_with(decorators, visitor);
                let pat = <Pat as FoldWith<V>>::fold_with(pat, visitor);
                Param {
                    span,
                    decorators,
                    pat,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ParamOrTsParamProp {
    #[doc = "Calls [Fold`::fold_param_or_ts_param_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_param_or_ts_param_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ParamOrTsParamProp::TsParamProp { 0: _field_0 } => {
                let _field_0 = <TsParamProp as FoldWith<V>>::fold_with(_field_0, visitor);
                ParamOrTsParamProp::TsParamProp { 0: _field_0 }
            }
            ParamOrTsParamProp::Param { 0: _field_0 } => {
                let _field_0 = <Param as FoldWith<V>>::fold_with(_field_0, visitor);
                ParamOrTsParamProp::Param { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ParenExpr {
    #[doc = "Calls [Fold`::fold_paren_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_paren_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ParenExpr { span, expr } => {
                let expr = <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor);
                ParenExpr { span, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Pat {
    #[doc = "Calls [Fold`::fold_pat`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_pat(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Pat::Ident { 0: _field_0 } => {
                let _field_0 = <BindingIdent as FoldWith<V>>::fold_with(_field_0, visitor);
                Pat::Ident { 0: _field_0 }
            }
            Pat::Array { 0: _field_0 } => {
                let _field_0 = <ArrayPat as FoldWith<V>>::fold_with(_field_0, visitor);
                Pat::Array { 0: _field_0 }
            }
            Pat::Rest { 0: _field_0 } => {
                let _field_0 = <RestPat as FoldWith<V>>::fold_with(_field_0, visitor);
                Pat::Rest { 0: _field_0 }
            }
            Pat::Object { 0: _field_0 } => {
                let _field_0 = <ObjectPat as FoldWith<V>>::fold_with(_field_0, visitor);
                Pat::Object { 0: _field_0 }
            }
            Pat::Assign { 0: _field_0 } => {
                let _field_0 = <AssignPat as FoldWith<V>>::fold_with(_field_0, visitor);
                Pat::Assign { 0: _field_0 }
            }
            Pat::Invalid { 0: _field_0 } => {
                let _field_0 = <Invalid as FoldWith<V>>::fold_with(_field_0, visitor);
                Pat::Invalid { 0: _field_0 }
            }
            Pat::Expr { 0: _field_0 } => {
                let _field_0 = <Box<Expr> as FoldWith<V>>::fold_with(_field_0, visitor);
                Pat::Expr { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for PrivateName {
    #[doc = "Calls [Fold`::fold_private_name`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_private_name(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            PrivateName { span, name } => PrivateName { span, name },
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for PrivateProp {
    #[doc = "Calls [Fold`::fold_private_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_private_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            PrivateProp {
                span,
                ctxt,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_optional,
                is_override,
                readonly,
                definite,
            } => {
                let key = <PrivateName as FoldWith<V>>::fold_with(key, visitor);
                let value = <Option<Box<Expr>> as FoldWith<V>>::fold_with(value, visitor);
                let type_ann =
                    <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor);
                let decorators = <Vec<Decorator> as FoldWith<V>>::fold_with(decorators, visitor);
                let accessibility =
                    <Option<Accessibility> as FoldWith<V>>::fold_with(accessibility, visitor);
                PrivateProp {
                    span,
                    ctxt,
                    key,
                    value,
                    type_ann,
                    is_static,
                    decorators,
                    accessibility,
                    is_optional,
                    is_override,
                    readonly,
                    definite,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Program {
    #[doc = "Calls [Fold`::fold_program`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_program(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Program::Module { 0: _field_0 } => {
                let _field_0 = <Module as FoldWith<V>>::fold_with(_field_0, visitor);
                Program::Module { 0: _field_0 }
            }
            Program::Script { 0: _field_0 } => {
                let _field_0 = <Script as FoldWith<V>>::fold_with(_field_0, visitor);
                Program::Script { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Prop {
    #[doc = "Calls [Fold`::fold_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Prop::Shorthand { 0: _field_0 } => {
                let _field_0 = <Ident as FoldWith<V>>::fold_with(_field_0, visitor);
                Prop::Shorthand { 0: _field_0 }
            }
            Prop::KeyValue { 0: _field_0 } => {
                let _field_0 = <KeyValueProp as FoldWith<V>>::fold_with(_field_0, visitor);
                Prop::KeyValue { 0: _field_0 }
            }
            Prop::Assign { 0: _field_0 } => {
                let _field_0 = <AssignProp as FoldWith<V>>::fold_with(_field_0, visitor);
                Prop::Assign { 0: _field_0 }
            }
            Prop::Getter { 0: _field_0 } => {
                let _field_0 = <GetterProp as FoldWith<V>>::fold_with(_field_0, visitor);
                Prop::Getter { 0: _field_0 }
            }
            Prop::Setter { 0: _field_0 } => {
                let _field_0 = <SetterProp as FoldWith<V>>::fold_with(_field_0, visitor);
                Prop::Setter { 0: _field_0 }
            }
            Prop::Method { 0: _field_0 } => {
                let _field_0 = <MethodProp as FoldWith<V>>::fold_with(_field_0, visitor);
                Prop::Method { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for PropName {
    #[doc = "Calls [Fold`::fold_prop_name`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_prop_name(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            PropName::Ident { 0: _field_0 } => {
                let _field_0 = <IdentName as FoldWith<V>>::fold_with(_field_0, visitor);
                PropName::Ident { 0: _field_0 }
            }
            PropName::Str { 0: _field_0 } => {
                let _field_0 = <Str as FoldWith<V>>::fold_with(_field_0, visitor);
                PropName::Str { 0: _field_0 }
            }
            PropName::Num { 0: _field_0 } => {
                let _field_0 = <Number as FoldWith<V>>::fold_with(_field_0, visitor);
                PropName::Num { 0: _field_0 }
            }
            PropName::Computed { 0: _field_0 } => {
                let _field_0 = <ComputedPropName as FoldWith<V>>::fold_with(_field_0, visitor);
                PropName::Computed { 0: _field_0 }
            }
            PropName::BigInt { 0: _field_0 } => {
                let _field_0 = <BigInt as FoldWith<V>>::fold_with(_field_0, visitor);
                PropName::BigInt { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for PropOrSpread {
    #[doc = "Calls [Fold`::fold_prop_or_spread`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_prop_or_spread(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            PropOrSpread::Spread { 0: _field_0 } => {
                let _field_0 = <SpreadElement as FoldWith<V>>::fold_with(_field_0, visitor);
                PropOrSpread::Spread { 0: _field_0 }
            }
            PropOrSpread::Prop { 0: _field_0 } => {
                let _field_0 = <Box<Prop> as FoldWith<V>>::fold_with(_field_0, visitor);
                PropOrSpread::Prop { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Regex {
    #[doc = "Calls [Fold`::fold_regex`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_regex(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Regex { span, exp, flags } => Regex { span, exp, flags },
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ReservedUnused {
    #[doc = "Calls [Fold`::fold_reserved_unused`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_reserved_unused(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ReservedUnused { span, body } => {
                let body = <Option<Vec<ModuleItem>> as FoldWith<V>>::fold_with(body, visitor);
                ReservedUnused { span, body }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for RestPat {
    #[doc = "Calls [Fold`::fold_rest_pat`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_rest_pat(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            RestPat {
                span,
                dot3_token,
                arg,
                type_ann,
            } => {
                let arg = <Box<Pat> as FoldWith<V>>::fold_with(arg, visitor);
                let type_ann =
                    <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor);
                RestPat {
                    span,
                    dot3_token,
                    arg,
                    type_ann,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ReturnStmt {
    #[doc = "Calls [Fold`::fold_return_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_return_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ReturnStmt { span, arg } => {
                let arg = <Option<Box<Expr>> as FoldWith<V>>::fold_with(arg, visitor);
                ReturnStmt { span, arg }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Script {
    #[doc = "Calls [Fold`::fold_script`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_script(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Script {
                span,
                body,
                shebang,
            } => {
                let body = <Vec<Stmt> as FoldWith<V>>::fold_with(body, visitor);
                Script {
                    span,
                    body,
                    shebang,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for SeqExpr {
    #[doc = "Calls [Fold`::fold_seq_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_seq_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            SeqExpr { span, exprs } => {
                let exprs = <Vec<Box<Expr>> as FoldWith<V>>::fold_with(exprs, visitor);
                SeqExpr { span, exprs }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for SetterProp {
    #[doc = "Calls [Fold`::fold_setter_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_setter_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            SetterProp {
                span,
                key,
                this_param,
                param,
                body,
            } => {
                let key = <PropName as FoldWith<V>>::fold_with(key, visitor);
                let this_param = <Option<Pat> as FoldWith<V>>::fold_with(this_param, visitor);
                let param = <Box<Pat> as FoldWith<V>>::fold_with(param, visitor);
                let body = <Option<BlockStmt> as FoldWith<V>>::fold_with(body, visitor);
                SetterProp {
                    span,
                    key,
                    this_param,
                    param,
                    body,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for SimpleAssignTarget {
    #[doc = "Calls [Fold`::fold_simple_assign_target`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_simple_assign_target(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            SimpleAssignTarget::Ident { 0: _field_0 } => {
                let _field_0 = <BindingIdent as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::Ident { 0: _field_0 }
            }
            SimpleAssignTarget::Member { 0: _field_0 } => {
                let _field_0 = <MemberExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::Member { 0: _field_0 }
            }
            SimpleAssignTarget::SuperProp { 0: _field_0 } => {
                let _field_0 = <SuperPropExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::SuperProp { 0: _field_0 }
            }
            SimpleAssignTarget::Paren { 0: _field_0 } => {
                let _field_0 = <ParenExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::Paren { 0: _field_0 }
            }
            SimpleAssignTarget::OptChain { 0: _field_0 } => {
                let _field_0 = <OptChainExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::OptChain { 0: _field_0 }
            }
            SimpleAssignTarget::TsAs { 0: _field_0 } => {
                let _field_0 = <TsAsExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::TsAs { 0: _field_0 }
            }
            SimpleAssignTarget::TsSatisfies { 0: _field_0 } => {
                let _field_0 = <TsSatisfiesExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::TsSatisfies { 0: _field_0 }
            }
            SimpleAssignTarget::TsNonNull { 0: _field_0 } => {
                let _field_0 = <TsNonNullExpr as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::TsNonNull { 0: _field_0 }
            }
            SimpleAssignTarget::TsTypeAssertion { 0: _field_0 } => {
                let _field_0 = <TsTypeAssertion as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::TsTypeAssertion { 0: _field_0 }
            }
            SimpleAssignTarget::TsInstantiation { 0: _field_0 } => {
                let _field_0 = <TsInstantiation as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::TsInstantiation { 0: _field_0 }
            }
            SimpleAssignTarget::Invalid { 0: _field_0 } => {
                let _field_0 = <Invalid as FoldWith<V>>::fold_with(_field_0, visitor);
                SimpleAssignTarget::Invalid { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for SpreadElement {
    #[doc = "Calls [Fold`::fold_spread_element`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_spread_element(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            SpreadElement { dot3_token, expr } => {
                let expr = <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor);
                SpreadElement { dot3_token, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for StaticBlock {
    #[doc = "Calls [Fold`::fold_static_block`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_static_block(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            StaticBlock { span, body } => {
                let body = <BlockStmt as FoldWith<V>>::fold_with(body, visitor);
                StaticBlock { span, body }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Stmt {
    #[doc = "Calls [Fold`::fold_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Stmt::Block { 0: _field_0 } => {
                let _field_0 = <BlockStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Block { 0: _field_0 }
            }
            Stmt::Empty { 0: _field_0 } => {
                let _field_0 = <EmptyStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Empty { 0: _field_0 }
            }
            Stmt::Debugger { 0: _field_0 } => {
                let _field_0 = <DebuggerStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Debugger { 0: _field_0 }
            }
            Stmt::With { 0: _field_0 } => {
                let _field_0 = <WithStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::With { 0: _field_0 }
            }
            Stmt::Return { 0: _field_0 } => {
                let _field_0 = <ReturnStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Return { 0: _field_0 }
            }
            Stmt::Labeled { 0: _field_0 } => {
                let _field_0 = <LabeledStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Labeled { 0: _field_0 }
            }
            Stmt::Break { 0: _field_0 } => {
                let _field_0 = <BreakStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Break { 0: _field_0 }
            }
            Stmt::Continue { 0: _field_0 } => {
                let _field_0 = <ContinueStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Continue { 0: _field_0 }
            }
            Stmt::If { 0: _field_0 } => {
                let _field_0 = <IfStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::If { 0: _field_0 }
            }
            Stmt::Switch { 0: _field_0 } => {
                let _field_0 = <SwitchStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Switch { 0: _field_0 }
            }
            Stmt::Throw { 0: _field_0 } => {
                let _field_0 = <ThrowStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Throw { 0: _field_0 }
            }
            Stmt::Try { 0: _field_0 } => {
                let _field_0 = <Box<TryStmt> as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Try { 0: _field_0 }
            }
            Stmt::While { 0: _field_0 } => {
                let _field_0 = <WhileStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::While { 0: _field_0 }
            }
            Stmt::DoWhile { 0: _field_0 } => {
                let _field_0 = <DoWhileStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::DoWhile { 0: _field_0 }
            }
            Stmt::For { 0: _field_0 } => {
                let _field_0 = <ForStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::For { 0: _field_0 }
            }
            Stmt::ForIn { 0: _field_0 } => {
                let _field_0 = <ForInStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::ForIn { 0: _field_0 }
            }
            Stmt::ForOf { 0: _field_0 } => {
                let _field_0 = <ForOfStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::ForOf { 0: _field_0 }
            }
            Stmt::Decl { 0: _field_0 } => {
                let _field_0 = <Decl as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Decl { 0: _field_0 }
            }
            Stmt::Expr { 0: _field_0 } => {
                let _field_0 = <ExprStmt as FoldWith<V>>::fold_with(_field_0, visitor);
                Stmt::Expr { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Str {
    #[doc = "Calls [Fold`::fold_str`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_str(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Str { span, value, raw } => Str { span, value, raw },
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Super {
    #[doc = "Calls [Fold`::fold_super`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_super(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Super { span } => Super { span },
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for SuperProp {
    #[doc = "Calls [Fold`::fold_super_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_super_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            SuperProp::Ident { 0: _field_0 } => {
                let _field_0 = <IdentName as FoldWith<V>>::fold_with(_field_0, visitor);
                SuperProp::Ident { 0: _field_0 }
            }
            SuperProp::Computed { 0: _field_0 } => {
                let _field_0 = <ComputedPropName as FoldWith<V>>::fold_with(_field_0, visitor);
                SuperProp::Computed { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for SuperPropExpr {
    #[doc = "Calls [Fold`::fold_super_prop_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_super_prop_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            SuperPropExpr { span, obj, prop } => {
                let obj = <Super as FoldWith<V>>::fold_with(obj, visitor);
                let prop = <SuperProp as FoldWith<V>>::fold_with(prop, visitor);
                SuperPropExpr { span, obj, prop }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for SwitchCase {
    #[doc = "Calls [Fold`::fold_switch_case`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_switch_case(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            SwitchCase { span, test, cons } => {
                let test = <Option<Box<Expr>> as FoldWith<V>>::fold_with(test, visitor);
                let cons = <Vec<Stmt> as FoldWith<V>>::fold_with(cons, visitor);
                SwitchCase { span, test, cons }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for SwitchStmt {
    #[doc = "Calls [Fold`::fold_switch_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_switch_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            SwitchStmt {
                span,
                discriminant,
                cases,
            } => {
                let discriminant = <Box<Expr> as FoldWith<V>>::fold_with(discriminant, visitor);
                let cases = <Vec<SwitchCase> as FoldWith<V>>::fold_with(cases, visitor);
                SwitchStmt {
                    span,
                    discriminant,
                    cases,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TaggedTpl {
    #[doc = "Calls [Fold`::fold_tagged_tpl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_tagged_tpl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TaggedTpl {
                span,
                ctxt,
                tag,
                type_params,
                tpl,
            } => {
                let tag = <Box<Expr> as FoldWith<V>>::fold_with(tag, visitor);
                let type_params = <Option<Box<TsTypeParamInstantiation>> as FoldWith<V>>::fold_with(
                    type_params,
                    visitor,
                );
                let tpl = <Box<Tpl> as FoldWith<V>>::fold_with(tpl, visitor);
                TaggedTpl {
                    span,
                    ctxt,
                    tag,
                    type_params,
                    tpl,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ThisExpr {
    #[doc = "Calls [Fold`::fold_this_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_this_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ThisExpr { span } => ThisExpr { span },
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ThrowStmt {
    #[doc = "Calls [Fold`::fold_throw_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_throw_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            ThrowStmt { span, arg } => {
                let arg = <Box<Expr> as FoldWith<V>>::fold_with(arg, visitor);
                ThrowStmt { span, arg }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Tpl {
    #[doc = "Calls [Fold`::fold_tpl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_tpl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            Tpl {
                span,
                exprs,
                quasis,
            } => {
                let exprs = <Vec<Box<Expr>> as FoldWith<V>>::fold_with(exprs, visitor);
                let quasis = <Vec<TplElement> as FoldWith<V>>::fold_with(quasis, visitor);
                Tpl {
                    span,
                    exprs,
                    quasis,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TplElement {
    #[doc = "Calls [Fold`::fold_tpl_element`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_tpl_element(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TplElement {
                span,
                tail,
                cooked,
                raw,
            } => TplElement {
                span,
                tail,
                cooked,
                raw,
            },
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TruePlusMinus {
    #[doc = "Calls [Fold`::fold_true_plus_minus`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_true_plus_minus(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TruePlusMinus::True => TruePlusMinus::True,
            TruePlusMinus::Plus => TruePlusMinus::Plus,
            TruePlusMinus::Minus => TruePlusMinus::Minus,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TryStmt {
    #[doc = "Calls [Fold`::fold_try_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_try_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TryStmt {
                span,
                block,
                handler,
                finalizer,
            } => {
                let block = <BlockStmt as FoldWith<V>>::fold_with(block, visitor);
                let handler = <Option<CatchClause> as FoldWith<V>>::fold_with(handler, visitor);
                let finalizer = <Option<BlockStmt> as FoldWith<V>>::fold_with(finalizer, visitor);
                TryStmt {
                    span,
                    block,
                    handler,
                    finalizer,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsArrayType {
    #[doc = "Calls [Fold`::fold_ts_array_type`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_array_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsArrayType { span, elem_type } => {
                let elem_type = <Box<TsType> as FoldWith<V>>::fold_with(elem_type, visitor);
                TsArrayType { span, elem_type }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsAsExpr {
    #[doc = "Calls [Fold`::fold_ts_as_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_as_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsAsExpr {
                span,
                expr,
                type_ann,
            } => {
                let expr = <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor);
                let type_ann = <Box<TsType> as FoldWith<V>>::fold_with(type_ann, visitor);
                TsAsExpr {
                    span,
                    expr,
                    type_ann,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsCallSignatureDecl {
    #[doc = "Calls [Fold`::fold_ts_call_signature_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_call_signature_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsCallSignatureDecl {
                span,
                params,
                type_ann,
                type_params,
            } => {
                let params = <Vec<TsFnParam> as FoldWith<V>>::fold_with(params, visitor);
                let type_ann =
                    <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor);
                let type_params =
                    <Option<Box<TsTypeParamDecl>> as FoldWith<V>>::fold_with(type_params, visitor);
                TsCallSignatureDecl {
                    span,
                    params,
                    type_ann,
                    type_params,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsConditionalType {
    #[doc = "Calls [Fold`::fold_ts_conditional_type`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_conditional_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsConditionalType {
                span,
                check_type,
                extends_type,
                true_type,
                false_type,
            } => {
                let check_type = <Box<TsType> as FoldWith<V>>::fold_with(check_type, visitor);
                let extends_type = <Box<TsType> as FoldWith<V>>::fold_with(extends_type, visitor);
                let true_type = <Box<TsType> as FoldWith<V>>::fold_with(true_type, visitor);
                let false_type = <Box<TsType> as FoldWith<V>>::fold_with(false_type, visitor);
                TsConditionalType {
                    span,
                    check_type,
                    extends_type,
                    true_type,
                    false_type,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsConstAssertion {
    #[doc = "Calls [Fold`::fold_ts_const_assertion`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_const_assertion(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsConstAssertion { span, expr } => {
                let expr = <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor);
                TsConstAssertion { span, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsConstructSignatureDecl {
    #[doc = "Calls [Fold`::fold_ts_construct_signature_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_construct_signature_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsConstructSignatureDecl {
                span,
                params,
                type_ann,
                type_params,
            } => {
                let params = <Vec<TsFnParam> as FoldWith<V>>::fold_with(params, visitor);
                let type_ann =
                    <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor);
                let type_params =
                    <Option<Box<TsTypeParamDecl>> as FoldWith<V>>::fold_with(type_params, visitor);
                TsConstructSignatureDecl {
                    span,
                    params,
                    type_ann,
                    type_params,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsConstructorType {
    #[doc = "Calls [Fold`::fold_ts_constructor_type`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_constructor_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsConstructorType {
                span,
                params,
                type_params,
                type_ann,
                is_abstract,
            } => {
                let params = <Vec<TsFnParam> as FoldWith<V>>::fold_with(params, visitor);
                let type_params =
                    <Option<Box<TsTypeParamDecl>> as FoldWith<V>>::fold_with(type_params, visitor);
                let type_ann = <Box<TsTypeAnn> as FoldWith<V>>::fold_with(type_ann, visitor);
                TsConstructorType {
                    span,
                    params,
                    type_params,
                    type_ann,
                    is_abstract,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsEntityName {
    #[doc = "Calls [Fold`::fold_ts_entity_name`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_entity_name(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsEntityName::TsQualifiedName { 0: _field_0 } => {
                let _field_0 = <Box<TsQualifiedName> as FoldWith<V>>::fold_with(_field_0, visitor);
                TsEntityName::TsQualifiedName { 0: _field_0 }
            }
            TsEntityName::Ident { 0: _field_0 } => {
                let _field_0 = <Ident as FoldWith<V>>::fold_with(_field_0, visitor);
                TsEntityName::Ident { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsEnumDecl {
    #[doc = "Calls [Fold`::fold_ts_enum_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_enum_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsEnumDecl {
                span,
                declare,
                is_const,
                id,
                members,
            } => {
                let id = <Ident as FoldWith<V>>::fold_with(id, visitor);
                let members = <Vec<TsEnumMember> as FoldWith<V>>::fold_with(members, visitor);
                TsEnumDecl {
                    span,
                    declare,
                    is_const,
                    id,
                    members,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsEnumMember {
    #[doc = "Calls [Fold`::fold_ts_enum_member`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_enum_member(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsEnumMember { span, id, init } => {
                let id = <TsEnumMemberId as FoldWith<V>>::fold_with(id, visitor);
                let init = <Option<Box<Expr>> as FoldWith<V>>::fold_with(init, visitor);
                TsEnumMember { span, id, init }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsEnumMemberId {
    #[doc = "Calls [Fold`::fold_ts_enum_member_id`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_enum_member_id(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsEnumMemberId::Ident { 0: _field_0 } => {
                let _field_0 = <Ident as FoldWith<V>>::fold_with(_field_0, visitor);
                TsEnumMemberId::Ident { 0: _field_0 }
            }
            TsEnumMemberId::Str { 0: _field_0 } => {
                let _field_0 = <Str as FoldWith<V>>::fold_with(_field_0, visitor);
                TsEnumMemberId::Str { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsExportAssignment {
    #[doc = "Calls [Fold`::fold_ts_export_assignment`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_export_assignment(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsExportAssignment { span, expr } => {
                let expr = <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor);
                TsExportAssignment { span, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsExprWithTypeArgs {
    #[doc = "Calls [Fold`::fold_ts_expr_with_type_args`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_expr_with_type_args(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsExprWithTypeArgs {
                span,
                expr,
                type_args,
            } => {
                let expr = <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor);
                let type_args = <Option<Box<TsTypeParamInstantiation>> as FoldWith<V>>::fold_with(
                    type_args, visitor,
                );
                TsExprWithTypeArgs {
                    span,
                    expr,
                    type_args,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsExternalModuleRef {
    #[doc = "Calls [Fold`::fold_ts_external_module_ref`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_external_module_ref(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsExternalModuleRef { span, expr } => {
                let expr = <Str as FoldWith<V>>::fold_with(expr, visitor);
                TsExternalModuleRef { span, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsFnOrConstructorType {
    #[doc = "Calls [Fold`::fold_ts_fn_or_constructor_type`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_fn_or_constructor_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsFnOrConstructorType::TsFnType { 0: _field_0 } => {
                let _field_0 = <TsFnType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsFnOrConstructorType::TsFnType { 0: _field_0 }
            }
            TsFnOrConstructorType::TsConstructorType { 0: _field_0 } => {
                let _field_0 = <TsConstructorType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsFnOrConstructorType::TsConstructorType { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsFnParam {
    #[doc = "Calls [Fold`::fold_ts_fn_param`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_fn_param(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsFnParam::Ident { 0: _field_0 } => {
                let _field_0 = <BindingIdent as FoldWith<V>>::fold_with(_field_0, visitor);
                TsFnParam::Ident { 0: _field_0 }
            }
            TsFnParam::Array { 0: _field_0 } => {
                let _field_0 = <ArrayPat as FoldWith<V>>::fold_with(_field_0, visitor);
                TsFnParam::Array { 0: _field_0 }
            }
            TsFnParam::Rest { 0: _field_0 } => {
                let _field_0 = <RestPat as FoldWith<V>>::fold_with(_field_0, visitor);
                TsFnParam::Rest { 0: _field_0 }
            }
            TsFnParam::Object { 0: _field_0 } => {
                let _field_0 = <ObjectPat as FoldWith<V>>::fold_with(_field_0, visitor);
                TsFnParam::Object { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsFnType {
    #[doc = "Calls [Fold`::fold_ts_fn_type`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_fn_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsFnType {
                span,
                params,
                type_params,
                type_ann,
            } => {
                let params = <Vec<TsFnParam> as FoldWith<V>>::fold_with(params, visitor);
                let type_params =
                    <Option<Box<TsTypeParamDecl>> as FoldWith<V>>::fold_with(type_params, visitor);
                let type_ann = <Box<TsTypeAnn> as FoldWith<V>>::fold_with(type_ann, visitor);
                TsFnType {
                    span,
                    params,
                    type_params,
                    type_ann,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsGetterSignature {
    #[doc = "Calls [Fold`::fold_ts_getter_signature`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_getter_signature(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsGetterSignature {
                span,
                key,
                computed,
                type_ann,
            } => {
                let key = <Box<Expr> as FoldWith<V>>::fold_with(key, visitor);
                let type_ann =
                    <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor);
                TsGetterSignature {
                    span,
                    key,
                    computed,
                    type_ann,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsImportEqualsDecl {
    #[doc = "Calls [Fold`::fold_ts_import_equals_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_import_equals_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsImportEqualsDecl {
                span,
                is_export,
                is_type_only,
                id,
                module_ref,
            } => {
                let id = <Ident as FoldWith<V>>::fold_with(id, visitor);
                let module_ref = <TsModuleRef as FoldWith<V>>::fold_with(module_ref, visitor);
                TsImportEqualsDecl {
                    span,
                    is_export,
                    is_type_only,
                    id,
                    module_ref,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsImportType {
    #[doc = "Calls [Fold`::fold_ts_import_type`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_import_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsImportType {
                span,
                arg,
                qualifier,
                type_args,
            } => {
                let arg = <Str as FoldWith<V>>::fold_with(arg, visitor);
                let qualifier =
                    <Option<TsEntityName> as FoldWith<V>>::fold_with(qualifier, visitor);
                let type_args = <Option<Box<TsTypeParamInstantiation>> as FoldWith<V>>::fold_with(
                    type_args, visitor,
                );
                TsImportType {
                    span,
                    arg,
                    qualifier,
                    type_args,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsIndexSignature {
    #[doc = "Calls [Fold`::fold_ts_index_signature`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_index_signature(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsIndexSignature {
                params,
                type_ann,
                readonly,
                is_static,
                span,
            } => {
                let params = <Vec<TsFnParam> as FoldWith<V>>::fold_with(params, visitor);
                let type_ann =
                    <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor);
                TsIndexSignature {
                    params,
                    type_ann,
                    readonly,
                    is_static,
                    span,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsIndexedAccessType {
    #[doc = "Calls [Fold`::fold_ts_indexed_access_type`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_indexed_access_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsIndexedAccessType {
                span,
                readonly,
                obj_type,
                index_type,
            } => {
                let obj_type = <Box<TsType> as FoldWith<V>>::fold_with(obj_type, visitor);
                let index_type = <Box<TsType> as FoldWith<V>>::fold_with(index_type, visitor);
                TsIndexedAccessType {
                    span,
                    readonly,
                    obj_type,
                    index_type,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsInferType {
    #[doc = "Calls [Fold`::fold_ts_infer_type`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_infer_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsInferType { span, type_param } => {
                let type_param = <TsTypeParam as FoldWith<V>>::fold_with(type_param, visitor);
                TsInferType { span, type_param }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsInstantiation {
    #[doc = "Calls [Fold`::fold_ts_instantiation`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_instantiation(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsInstantiation {
                span,
                expr,
                type_args,
            } => {
                let expr = <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor);
                let type_args =
                    <Box<TsTypeParamInstantiation> as FoldWith<V>>::fold_with(type_args, visitor);
                TsInstantiation {
                    span,
                    expr,
                    type_args,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsInterfaceBody {
    #[doc = "Calls [Fold`::fold_ts_interface_body`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_interface_body(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsInterfaceBody { span, body } => {
                let body = <Vec<TsTypeElement> as FoldWith<V>>::fold_with(body, visitor);
                TsInterfaceBody { span, body }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsInterfaceDecl {
    #[doc = "Calls [Fold`::fold_ts_interface_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_interface_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsInterfaceDecl {
                span,
                id,
                declare,
                type_params,
                extends,
                body,
            } => {
                let id = <Ident as FoldWith<V>>::fold_with(id, visitor);
                let type_params =
                    <Option<Box<TsTypeParamDecl>> as FoldWith<V>>::fold_with(type_params, visitor);
                let extends = <Vec<TsExprWithTypeArgs> as FoldWith<V>>::fold_with(extends, visitor);
                let body = <TsInterfaceBody as FoldWith<V>>::fold_with(body, visitor);
                TsInterfaceDecl {
                    span,
                    id,
                    declare,
                    type_params,
                    extends,
                    body,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsIntersectionType {
    #[doc = "Calls [Fold`::fold_ts_intersection_type`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_intersection_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsIntersectionType { span, types } => {
                let types = <Vec<Box<TsType>> as FoldWith<V>>::fold_with(types, visitor);
                TsIntersectionType { span, types }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsKeywordType {
    #[doc = "Calls [Fold`::fold_ts_keyword_type`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_keyword_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsKeywordType { span, kind } => {
                let kind = <TsKeywordTypeKind as FoldWith<V>>::fold_with(kind, visitor);
                TsKeywordType { span, kind }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsKeywordTypeKind {
    #[doc = "Calls [Fold`::fold_ts_keyword_type_kind`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_keyword_type_kind(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsKeywordTypeKind::TsAnyKeyword => TsKeywordTypeKind::TsAnyKeyword,
            TsKeywordTypeKind::TsUnknownKeyword => TsKeywordTypeKind::TsUnknownKeyword,
            TsKeywordTypeKind::TsNumberKeyword => TsKeywordTypeKind::TsNumberKeyword,
            TsKeywordTypeKind::TsObjectKeyword => TsKeywordTypeKind::TsObjectKeyword,
            TsKeywordTypeKind::TsBooleanKeyword => TsKeywordTypeKind::TsBooleanKeyword,
            TsKeywordTypeKind::TsBigIntKeyword => TsKeywordTypeKind::TsBigIntKeyword,
            TsKeywordTypeKind::TsStringKeyword => TsKeywordTypeKind::TsStringKeyword,
            TsKeywordTypeKind::TsSymbolKeyword => TsKeywordTypeKind::TsSymbolKeyword,
            TsKeywordTypeKind::TsVoidKeyword => TsKeywordTypeKind::TsVoidKeyword,
            TsKeywordTypeKind::TsUndefinedKeyword => TsKeywordTypeKind::TsUndefinedKeyword,
            TsKeywordTypeKind::TsNullKeyword => TsKeywordTypeKind::TsNullKeyword,
            TsKeywordTypeKind::TsNeverKeyword => TsKeywordTypeKind::TsNeverKeyword,
            TsKeywordTypeKind::TsIntrinsicKeyword => TsKeywordTypeKind::TsIntrinsicKeyword,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsLit {
    #[doc = "Calls [Fold`::fold_ts_lit`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_lit(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsLit::Number { 0: _field_0 } => {
                let _field_0 = <Number as FoldWith<V>>::fold_with(_field_0, visitor);
                TsLit::Number { 0: _field_0 }
            }
            TsLit::Str { 0: _field_0 } => {
                let _field_0 = <Str as FoldWith<V>>::fold_with(_field_0, visitor);
                TsLit::Str { 0: _field_0 }
            }
            TsLit::Bool { 0: _field_0 } => {
                let _field_0 = <Bool as FoldWith<V>>::fold_with(_field_0, visitor);
                TsLit::Bool { 0: _field_0 }
            }
            TsLit::BigInt { 0: _field_0 } => {
                let _field_0 = <BigInt as FoldWith<V>>::fold_with(_field_0, visitor);
                TsLit::BigInt { 0: _field_0 }
            }
            TsLit::Tpl { 0: _field_0 } => {
                let _field_0 = <TsTplLitType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsLit::Tpl { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsLitType {
    #[doc = "Calls [Fold`::fold_ts_lit_type`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_lit_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsLitType { span, lit } => {
                let lit = <TsLit as FoldWith<V>>::fold_with(lit, visitor);
                TsLitType { span, lit }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsMappedType {
    #[doc = "Calls [Fold`::fold_ts_mapped_type`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_mapped_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsMappedType {
                span,
                readonly,
                type_param,
                name_type,
                optional,
                type_ann,
            } => {
                let readonly = <Option<TruePlusMinus> as FoldWith<V>>::fold_with(readonly, visitor);
                let type_param = <TsTypeParam as FoldWith<V>>::fold_with(type_param, visitor);
                let name_type = <Option<Box<TsType>> as FoldWith<V>>::fold_with(name_type, visitor);
                let optional = <Option<TruePlusMinus> as FoldWith<V>>::fold_with(optional, visitor);
                let type_ann = <Option<Box<TsType>> as FoldWith<V>>::fold_with(type_ann, visitor);
                TsMappedType {
                    span,
                    readonly,
                    type_param,
                    name_type,
                    optional,
                    type_ann,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsMethodSignature {
    #[doc = "Calls [Fold`::fold_ts_method_signature`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_method_signature(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsMethodSignature {
                span,
                key,
                computed,
                optional,
                params,
                type_ann,
                type_params,
            } => {
                let key = <Box<Expr> as FoldWith<V>>::fold_with(key, visitor);
                let params = <Vec<TsFnParam> as FoldWith<V>>::fold_with(params, visitor);
                let type_ann =
                    <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor);
                let type_params =
                    <Option<Box<TsTypeParamDecl>> as FoldWith<V>>::fold_with(type_params, visitor);
                TsMethodSignature {
                    span,
                    key,
                    computed,
                    optional,
                    params,
                    type_ann,
                    type_params,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsModuleBlock {
    #[doc = "Calls [Fold`::fold_ts_module_block`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_module_block(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsModuleBlock { span, body } => {
                let body = <Vec<ModuleItem> as FoldWith<V>>::fold_with(body, visitor);
                TsModuleBlock { span, body }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsModuleDecl {
    #[doc = "Calls [Fold`::fold_ts_module_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_module_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsModuleDecl {
                span,
                declare,
                global,
                id,
                body,
            } => {
                let id = <TsModuleName as FoldWith<V>>::fold_with(id, visitor);
                let body = <Option<TsNamespaceBody> as FoldWith<V>>::fold_with(body, visitor);
                TsModuleDecl {
                    span,
                    declare,
                    global,
                    id,
                    body,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsModuleName {
    #[doc = "Calls [Fold`::fold_ts_module_name`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_module_name(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsModuleName::Ident { 0: _field_0 } => {
                let _field_0 = <Ident as FoldWith<V>>::fold_with(_field_0, visitor);
                TsModuleName::Ident { 0: _field_0 }
            }
            TsModuleName::Str { 0: _field_0 } => {
                let _field_0 = <Str as FoldWith<V>>::fold_with(_field_0, visitor);
                TsModuleName::Str { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsModuleRef {
    #[doc = "Calls [Fold`::fold_ts_module_ref`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_module_ref(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsModuleRef::TsEntityName { 0: _field_0 } => {
                let _field_0 = <TsEntityName as FoldWith<V>>::fold_with(_field_0, visitor);
                TsModuleRef::TsEntityName { 0: _field_0 }
            }
            TsModuleRef::TsExternalModuleRef { 0: _field_0 } => {
                let _field_0 = <TsExternalModuleRef as FoldWith<V>>::fold_with(_field_0, visitor);
                TsModuleRef::TsExternalModuleRef { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsNamespaceBody {
    #[doc = "Calls [Fold`::fold_ts_namespace_body`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_namespace_body(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsNamespaceBody::TsModuleBlock { 0: _field_0 } => {
                let _field_0 = <TsModuleBlock as FoldWith<V>>::fold_with(_field_0, visitor);
                TsNamespaceBody::TsModuleBlock { 0: _field_0 }
            }
            TsNamespaceBody::TsNamespaceDecl { 0: _field_0 } => {
                let _field_0 = <TsNamespaceDecl as FoldWith<V>>::fold_with(_field_0, visitor);
                TsNamespaceBody::TsNamespaceDecl { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsNamespaceDecl {
    #[doc = "Calls [Fold`::fold_ts_namespace_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_namespace_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsNamespaceDecl {
                span,
                declare,
                global,
                id,
                body,
            } => {
                let id = <Ident as FoldWith<V>>::fold_with(id, visitor);
                let body = <Box<TsNamespaceBody> as FoldWith<V>>::fold_with(body, visitor);
                TsNamespaceDecl {
                    span,
                    declare,
                    global,
                    id,
                    body,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsNamespaceExportDecl {
    #[doc = "Calls [Fold`::fold_ts_namespace_export_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_namespace_export_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsNamespaceExportDecl { span, id } => {
                let id = <Ident as FoldWith<V>>::fold_with(id, visitor);
                TsNamespaceExportDecl { span, id }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsNonNullExpr {
    #[doc = "Calls [Fold`::fold_ts_non_null_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_non_null_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsNonNullExpr { span, expr } => {
                let expr = <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor);
                TsNonNullExpr { span, expr }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsOptionalType {
    #[doc = "Calls [Fold`::fold_ts_optional_type`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_optional_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsOptionalType { span, type_ann } => {
                let type_ann = <Box<TsType> as FoldWith<V>>::fold_with(type_ann, visitor);
                TsOptionalType { span, type_ann }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsParamProp {
    #[doc = "Calls [Fold`::fold_ts_param_prop`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_param_prop(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsParamProp {
                span,
                decorators,
                accessibility,
                is_override,
                readonly,
                param,
            } => {
                let decorators = <Vec<Decorator> as FoldWith<V>>::fold_with(decorators, visitor);
                let accessibility =
                    <Option<Accessibility> as FoldWith<V>>::fold_with(accessibility, visitor);
                let param = <TsParamPropParam as FoldWith<V>>::fold_with(param, visitor);
                TsParamProp {
                    span,
                    decorators,
                    accessibility,
                    is_override,
                    readonly,
                    param,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsParamPropParam {
    #[doc = "Calls [Fold`::fold_ts_param_prop_param`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_param_prop_param(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsParamPropParam::Ident { 0: _field_0 } => {
                let _field_0 = <BindingIdent as FoldWith<V>>::fold_with(_field_0, visitor);
                TsParamPropParam::Ident { 0: _field_0 }
            }
            TsParamPropParam::Assign { 0: _field_0 } => {
                let _field_0 = <AssignPat as FoldWith<V>>::fold_with(_field_0, visitor);
                TsParamPropParam::Assign { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsParenthesizedType {
    #[doc = "Calls [Fold`::fold_ts_parenthesized_type`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_parenthesized_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsParenthesizedType { span, type_ann } => {
                let type_ann = <Box<TsType> as FoldWith<V>>::fold_with(type_ann, visitor);
                TsParenthesizedType { span, type_ann }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsPropertySignature {
    #[doc = "Calls [Fold`::fold_ts_property_signature`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_property_signature(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsPropertySignature {
                span,
                readonly,
                key,
                computed,
                optional,
                type_ann,
            } => {
                let key = <Box<Expr> as FoldWith<V>>::fold_with(key, visitor);
                let type_ann =
                    <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor);
                TsPropertySignature {
                    span,
                    readonly,
                    key,
                    computed,
                    optional,
                    type_ann,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsQualifiedName {
    #[doc = "Calls [Fold`::fold_ts_qualified_name`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_qualified_name(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsQualifiedName { span, left, right } => {
                let left = <TsEntityName as FoldWith<V>>::fold_with(left, visitor);
                let right = <IdentName as FoldWith<V>>::fold_with(right, visitor);
                TsQualifiedName { span, left, right }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsRestType {
    #[doc = "Calls [Fold`::fold_ts_rest_type`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_rest_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsRestType { span, type_ann } => {
                let type_ann = <Box<TsType> as FoldWith<V>>::fold_with(type_ann, visitor);
                TsRestType { span, type_ann }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsSatisfiesExpr {
    #[doc = "Calls [Fold`::fold_ts_satisfies_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_satisfies_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsSatisfiesExpr {
                span,
                expr,
                type_ann,
            } => {
                let expr = <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor);
                let type_ann = <Box<TsType> as FoldWith<V>>::fold_with(type_ann, visitor);
                TsSatisfiesExpr {
                    span,
                    expr,
                    type_ann,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsSetterSignature {
    #[doc = "Calls [Fold`::fold_ts_setter_signature`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_setter_signature(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsSetterSignature {
                span,
                key,
                computed,
                param,
            } => {
                let key = <Box<Expr> as FoldWith<V>>::fold_with(key, visitor);
                let param = <TsFnParam as FoldWith<V>>::fold_with(param, visitor);
                TsSetterSignature {
                    span,
                    key,
                    computed,
                    param,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsThisType {
    #[doc = "Calls [Fold`::fold_ts_this_type`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_this_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsThisType { span } => TsThisType { span },
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsThisTypeOrIdent {
    #[doc = "Calls [Fold`::fold_ts_this_type_or_ident`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_this_type_or_ident(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsThisTypeOrIdent::TsThisType { 0: _field_0 } => {
                let _field_0 = <TsThisType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsThisTypeOrIdent::TsThisType { 0: _field_0 }
            }
            TsThisTypeOrIdent::Ident { 0: _field_0 } => {
                let _field_0 = <Ident as FoldWith<V>>::fold_with(_field_0, visitor);
                TsThisTypeOrIdent::Ident { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsTplLitType {
    #[doc = "Calls [Fold`::fold_ts_tpl_lit_type`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_tpl_lit_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsTplLitType {
                span,
                types,
                quasis,
            } => {
                let types = <Vec<Box<TsType>> as FoldWith<V>>::fold_with(types, visitor);
                let quasis = <Vec<TplElement> as FoldWith<V>>::fold_with(quasis, visitor);
                TsTplLitType {
                    span,
                    types,
                    quasis,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsTupleElement {
    #[doc = "Calls [Fold`::fold_ts_tuple_element`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_tuple_element(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsTupleElement { span, label, ty } => {
                let label = <Option<Pat> as FoldWith<V>>::fold_with(label, visitor);
                let ty = <Box<TsType> as FoldWith<V>>::fold_with(ty, visitor);
                TsTupleElement { span, label, ty }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsTupleType {
    #[doc = "Calls [Fold`::fold_ts_tuple_type`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_tuple_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsTupleType { span, elem_types } => {
                let elem_types =
                    <Vec<TsTupleElement> as FoldWith<V>>::fold_with(elem_types, visitor);
                TsTupleType { span, elem_types }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsType {
    #[doc = "Calls [Fold`::fold_ts_type`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsType::TsKeywordType { 0: _field_0 } => {
                let _field_0 = <TsKeywordType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsType::TsKeywordType { 0: _field_0 }
            }
            TsType::TsThisType { 0: _field_0 } => {
                let _field_0 = <TsThisType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsType::TsThisType { 0: _field_0 }
            }
            TsType::TsFnOrConstructorType { 0: _field_0 } => {
                let _field_0 = <TsFnOrConstructorType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsType::TsFnOrConstructorType { 0: _field_0 }
            }
            TsType::TsTypeRef { 0: _field_0 } => {
                let _field_0 = <TsTypeRef as FoldWith<V>>::fold_with(_field_0, visitor);
                TsType::TsTypeRef { 0: _field_0 }
            }
            TsType::TsTypeQuery { 0: _field_0 } => {
                let _field_0 = <TsTypeQuery as FoldWith<V>>::fold_with(_field_0, visitor);
                TsType::TsTypeQuery { 0: _field_0 }
            }
            TsType::TsTypeLit { 0: _field_0 } => {
                let _field_0 = <TsTypeLit as FoldWith<V>>::fold_with(_field_0, visitor);
                TsType::TsTypeLit { 0: _field_0 }
            }
            TsType::TsArrayType { 0: _field_0 } => {
                let _field_0 = <TsArrayType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsType::TsArrayType { 0: _field_0 }
            }
            TsType::TsTupleType { 0: _field_0 } => {
                let _field_0 = <TsTupleType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsType::TsTupleType { 0: _field_0 }
            }
            TsType::TsOptionalType { 0: _field_0 } => {
                let _field_0 = <TsOptionalType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsType::TsOptionalType { 0: _field_0 }
            }
            TsType::TsRestType { 0: _field_0 } => {
                let _field_0 = <TsRestType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsType::TsRestType { 0: _field_0 }
            }
            TsType::TsUnionOrIntersectionType { 0: _field_0 } => {
                let _field_0 =
                    <TsUnionOrIntersectionType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsType::TsUnionOrIntersectionType { 0: _field_0 }
            }
            TsType::TsConditionalType { 0: _field_0 } => {
                let _field_0 = <TsConditionalType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsType::TsConditionalType { 0: _field_0 }
            }
            TsType::TsInferType { 0: _field_0 } => {
                let _field_0 = <TsInferType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsType::TsInferType { 0: _field_0 }
            }
            TsType::TsParenthesizedType { 0: _field_0 } => {
                let _field_0 = <TsParenthesizedType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsType::TsParenthesizedType { 0: _field_0 }
            }
            TsType::TsTypeOperator { 0: _field_0 } => {
                let _field_0 = <TsTypeOperator as FoldWith<V>>::fold_with(_field_0, visitor);
                TsType::TsTypeOperator { 0: _field_0 }
            }
            TsType::TsIndexedAccessType { 0: _field_0 } => {
                let _field_0 = <TsIndexedAccessType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsType::TsIndexedAccessType { 0: _field_0 }
            }
            TsType::TsMappedType { 0: _field_0 } => {
                let _field_0 = <TsMappedType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsType::TsMappedType { 0: _field_0 }
            }
            TsType::TsLitType { 0: _field_0 } => {
                let _field_0 = <TsLitType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsType::TsLitType { 0: _field_0 }
            }
            TsType::TsTypePredicate { 0: _field_0 } => {
                let _field_0 = <TsTypePredicate as FoldWith<V>>::fold_with(_field_0, visitor);
                TsType::TsTypePredicate { 0: _field_0 }
            }
            TsType::TsImportType { 0: _field_0 } => {
                let _field_0 = <TsImportType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsType::TsImportType { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsTypeAliasDecl {
    #[doc = "Calls [Fold`::fold_ts_type_alias_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_type_alias_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsTypeAliasDecl {
                span,
                declare,
                id,
                type_params,
                type_ann,
            } => {
                let id = <Ident as FoldWith<V>>::fold_with(id, visitor);
                let type_params =
                    <Option<Box<TsTypeParamDecl>> as FoldWith<V>>::fold_with(type_params, visitor);
                let type_ann = <Box<TsType> as FoldWith<V>>::fold_with(type_ann, visitor);
                TsTypeAliasDecl {
                    span,
                    declare,
                    id,
                    type_params,
                    type_ann,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsTypeAnn {
    #[doc = "Calls [Fold`::fold_ts_type_ann`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_type_ann(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsTypeAnn { span, type_ann } => {
                let type_ann = <Box<TsType> as FoldWith<V>>::fold_with(type_ann, visitor);
                TsTypeAnn { span, type_ann }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsTypeAssertion {
    #[doc = "Calls [Fold`::fold_ts_type_assertion`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_type_assertion(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsTypeAssertion {
                span,
                expr,
                type_ann,
            } => {
                let expr = <Box<Expr> as FoldWith<V>>::fold_with(expr, visitor);
                let type_ann = <Box<TsType> as FoldWith<V>>::fold_with(type_ann, visitor);
                TsTypeAssertion {
                    span,
                    expr,
                    type_ann,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsTypeElement {
    #[doc = "Calls [Fold`::fold_ts_type_element`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_type_element(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsTypeElement::TsCallSignatureDecl { 0: _field_0 } => {
                let _field_0 = <TsCallSignatureDecl as FoldWith<V>>::fold_with(_field_0, visitor);
                TsTypeElement::TsCallSignatureDecl { 0: _field_0 }
            }
            TsTypeElement::TsConstructSignatureDecl { 0: _field_0 } => {
                let _field_0 =
                    <TsConstructSignatureDecl as FoldWith<V>>::fold_with(_field_0, visitor);
                TsTypeElement::TsConstructSignatureDecl { 0: _field_0 }
            }
            TsTypeElement::TsPropertySignature { 0: _field_0 } => {
                let _field_0 = <TsPropertySignature as FoldWith<V>>::fold_with(_field_0, visitor);
                TsTypeElement::TsPropertySignature { 0: _field_0 }
            }
            TsTypeElement::TsGetterSignature { 0: _field_0 } => {
                let _field_0 = <TsGetterSignature as FoldWith<V>>::fold_with(_field_0, visitor);
                TsTypeElement::TsGetterSignature { 0: _field_0 }
            }
            TsTypeElement::TsSetterSignature { 0: _field_0 } => {
                let _field_0 = <TsSetterSignature as FoldWith<V>>::fold_with(_field_0, visitor);
                TsTypeElement::TsSetterSignature { 0: _field_0 }
            }
            TsTypeElement::TsMethodSignature { 0: _field_0 } => {
                let _field_0 = <TsMethodSignature as FoldWith<V>>::fold_with(_field_0, visitor);
                TsTypeElement::TsMethodSignature { 0: _field_0 }
            }
            TsTypeElement::TsIndexSignature { 0: _field_0 } => {
                let _field_0 = <TsIndexSignature as FoldWith<V>>::fold_with(_field_0, visitor);
                TsTypeElement::TsIndexSignature { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsTypeLit {
    #[doc = "Calls [Fold`::fold_ts_type_lit`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_type_lit(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsTypeLit { span, members } => {
                let members = <Vec<TsTypeElement> as FoldWith<V>>::fold_with(members, visitor);
                TsTypeLit { span, members }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsTypeOperator {
    #[doc = "Calls [Fold`::fold_ts_type_operator`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_type_operator(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsTypeOperator { span, op, type_ann } => {
                let op = <TsTypeOperatorOp as FoldWith<V>>::fold_with(op, visitor);
                let type_ann = <Box<TsType> as FoldWith<V>>::fold_with(type_ann, visitor);
                TsTypeOperator { span, op, type_ann }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsTypeOperatorOp {
    #[doc = "Calls [Fold`::fold_ts_type_operator_op`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_type_operator_op(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsTypeOperatorOp::KeyOf => TsTypeOperatorOp::KeyOf,
            TsTypeOperatorOp::Unique => TsTypeOperatorOp::Unique,
            TsTypeOperatorOp::ReadOnly => TsTypeOperatorOp::ReadOnly,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsTypeParam {
    #[doc = "Calls [Fold`::fold_ts_type_param`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_type_param(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsTypeParam {
                span,
                name,
                is_in,
                is_out,
                is_const,
                constraint,
                default,
            } => {
                let name = <Ident as FoldWith<V>>::fold_with(name, visitor);
                let constraint =
                    <Option<Box<TsType>> as FoldWith<V>>::fold_with(constraint, visitor);
                let default = <Option<Box<TsType>> as FoldWith<V>>::fold_with(default, visitor);
                TsTypeParam {
                    span,
                    name,
                    is_in,
                    is_out,
                    is_const,
                    constraint,
                    default,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsTypeParamDecl {
    #[doc = "Calls [Fold`::fold_ts_type_param_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_type_param_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsTypeParamDecl { span, params } => {
                let params = <Vec<TsTypeParam> as FoldWith<V>>::fold_with(params, visitor);
                TsTypeParamDecl { span, params }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsTypeParamInstantiation {
    #[doc = "Calls [Fold`::fold_ts_type_param_instantiation`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_type_param_instantiation(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsTypeParamInstantiation { span, params } => {
                let params = <Vec<Box<TsType>> as FoldWith<V>>::fold_with(params, visitor);
                TsTypeParamInstantiation { span, params }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsTypePredicate {
    #[doc = "Calls [Fold`::fold_ts_type_predicate`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_type_predicate(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsTypePredicate {
                span,
                asserts,
                param_name,
                type_ann,
            } => {
                let param_name = <TsThisTypeOrIdent as FoldWith<V>>::fold_with(param_name, visitor);
                let type_ann =
                    <Option<Box<TsTypeAnn>> as FoldWith<V>>::fold_with(type_ann, visitor);
                TsTypePredicate {
                    span,
                    asserts,
                    param_name,
                    type_ann,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsTypeQuery {
    #[doc = "Calls [Fold`::fold_ts_type_query`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_type_query(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsTypeQuery {
                span,
                expr_name,
                type_args,
            } => {
                let expr_name = <TsTypeQueryExpr as FoldWith<V>>::fold_with(expr_name, visitor);
                let type_args = <Option<Box<TsTypeParamInstantiation>> as FoldWith<V>>::fold_with(
                    type_args, visitor,
                );
                TsTypeQuery {
                    span,
                    expr_name,
                    type_args,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsTypeQueryExpr {
    #[doc = "Calls [Fold`::fold_ts_type_query_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_type_query_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsTypeQueryExpr::TsEntityName { 0: _field_0 } => {
                let _field_0 = <TsEntityName as FoldWith<V>>::fold_with(_field_0, visitor);
                TsTypeQueryExpr::TsEntityName { 0: _field_0 }
            }
            TsTypeQueryExpr::Import { 0: _field_0 } => {
                let _field_0 = <TsImportType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsTypeQueryExpr::Import { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsTypeRef {
    #[doc = "Calls [Fold`::fold_ts_type_ref`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_type_ref(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsTypeRef {
                span,
                type_name,
                type_params,
            } => {
                let type_name = <TsEntityName as FoldWith<V>>::fold_with(type_name, visitor);
                let type_params = <Option<Box<TsTypeParamInstantiation>> as FoldWith<V>>::fold_with(
                    type_params,
                    visitor,
                );
                TsTypeRef {
                    span,
                    type_name,
                    type_params,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsUnionOrIntersectionType {
    #[doc = "Calls [Fold`::fold_ts_union_or_intersection_type`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_union_or_intersection_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsUnionOrIntersectionType::TsUnionType { 0: _field_0 } => {
                let _field_0 = <TsUnionType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsUnionOrIntersectionType::TsUnionType { 0: _field_0 }
            }
            TsUnionOrIntersectionType::TsIntersectionType { 0: _field_0 } => {
                let _field_0 = <TsIntersectionType as FoldWith<V>>::fold_with(_field_0, visitor);
                TsUnionOrIntersectionType::TsIntersectionType { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for TsUnionType {
    #[doc = "Calls [Fold`::fold_ts_union_type`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_union_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            TsUnionType { span, types } => {
                let types = <Vec<Box<TsType>> as FoldWith<V>>::fold_with(types, visitor);
                TsUnionType { span, types }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for UnaryExpr {
    #[doc = "Calls [Fold`::fold_unary_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_unary_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            UnaryExpr { span, op, arg } => {
                let op = <UnaryOp as FoldWith<V>>::fold_with(op, visitor);
                let arg = <Box<Expr> as FoldWith<V>>::fold_with(arg, visitor);
                UnaryExpr { span, op, arg }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for UnaryOp {
    #[doc = "Calls [Fold`::fold_unary_op`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_unary_op(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            UnaryOp::Minus => UnaryOp::Minus,
            UnaryOp::Plus => UnaryOp::Plus,
            UnaryOp::Bang => UnaryOp::Bang,
            UnaryOp::Tilde => UnaryOp::Tilde,
            UnaryOp::TypeOf => UnaryOp::TypeOf,
            UnaryOp::Void => UnaryOp::Void,
            UnaryOp::Delete => UnaryOp::Delete,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for UpdateExpr {
    #[doc = "Calls [Fold`::fold_update_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_update_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            UpdateExpr {
                span,
                op,
                prefix,
                arg,
            } => {
                let op = <UpdateOp as FoldWith<V>>::fold_with(op, visitor);
                let arg = <Box<Expr> as FoldWith<V>>::fold_with(arg, visitor);
                UpdateExpr {
                    span,
                    op,
                    prefix,
                    arg,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for UpdateOp {
    #[doc = "Calls [Fold`::fold_update_op`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_update_op(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            UpdateOp::PlusPlus => UpdateOp::PlusPlus,
            UpdateOp::MinusMinus => UpdateOp::MinusMinus,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for UsingDecl {
    #[doc = "Calls [Fold`::fold_using_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_using_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            UsingDecl {
                span,
                is_await,
                decls,
            } => {
                let decls = <Vec<VarDeclarator> as FoldWith<V>>::fold_with(decls, visitor);
                UsingDecl {
                    span,
                    is_await,
                    decls,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for VarDecl {
    #[doc = "Calls [Fold`::fold_var_decl`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_var_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            VarDecl {
                span,
                ctxt,
                kind,
                declare,
                decls,
            } => {
                let kind = <VarDeclKind as FoldWith<V>>::fold_with(kind, visitor);
                let decls = <Vec<VarDeclarator> as FoldWith<V>>::fold_with(decls, visitor);
                VarDecl {
                    span,
                    ctxt,
                    kind,
                    declare,
                    decls,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for VarDeclKind {
    #[doc = "Calls [Fold`::fold_var_decl_kind`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_var_decl_kind(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            VarDeclKind::Var => VarDeclKind::Var,
            VarDeclKind::Let => VarDeclKind::Let,
            VarDeclKind::Const => VarDeclKind::Const,
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for VarDeclOrExpr {
    #[doc = "Calls [Fold`::fold_var_decl_or_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_var_decl_or_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            VarDeclOrExpr::VarDecl { 0: _field_0 } => {
                let _field_0 = <Box<VarDecl> as FoldWith<V>>::fold_with(_field_0, visitor);
                VarDeclOrExpr::VarDecl { 0: _field_0 }
            }
            VarDeclOrExpr::Expr { 0: _field_0 } => {
                let _field_0 = <Box<Expr> as FoldWith<V>>::fold_with(_field_0, visitor);
                VarDeclOrExpr::Expr { 0: _field_0 }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for VarDeclarator {
    #[doc = "Calls [Fold`::fold_var_declarator`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_var_declarator(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            VarDeclarator {
                span,
                name,
                init,
                definite,
            } => {
                let name = <Pat as FoldWith<V>>::fold_with(name, visitor);
                let init = <Option<Box<Expr>> as FoldWith<V>>::fold_with(init, visitor);
                VarDeclarator {
                    span,
                    name,
                    init,
                    definite,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for WhileStmt {
    #[doc = "Calls [Fold`::fold_while_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_while_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            WhileStmt { span, test, body } => {
                let test = <Box<Expr> as FoldWith<V>>::fold_with(test, visitor);
                let body = <Box<Stmt> as FoldWith<V>>::fold_with(body, visitor);
                WhileStmt { span, test, body }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for WithStmt {
    #[doc = "Calls [Fold`::fold_with_stmt`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_with_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            WithStmt { span, obj, body } => {
                let obj = <Box<Expr> as FoldWith<V>>::fold_with(obj, visitor);
                let body = <Box<Stmt> as FoldWith<V>>::fold_with(body, visitor);
                WithStmt { span, obj, body }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for YieldExpr {
    #[doc = "Calls [Fold`::fold_yield_expr`] with `self`."]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_yield_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        match self {
            YieldExpr {
                span,
                arg,
                delegate,
            } => {
                let arg = <Option<Box<Expr>> as FoldWith<V>>::fold_with(arg, visitor);
                YieldExpr {
                    span,
                    arg,
                    delegate,
                }
            }
        }
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for swc_atoms::Atom {
    #[doc = "Calls [Fold`::fold_atom`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_atom(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for BigIntValue {
    #[doc = "Calls [Fold`::fold_big_int_value`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_big_int_value(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<ClassMember> {
    #[doc = "Calls [Fold`::fold_class_members`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_class_members(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <ClassMember as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for ClassMethod {
    #[doc = "Calls [Fold`::fold_class_method`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_class_method(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<Decorator> {
    #[doc = "Calls [Fold`::fold_decorators`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_decorators(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <Decorator as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<ExportSpecifier> {
    #[doc = "Calls [Fold`::fold_export_specifiers`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_export_specifiers(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <ExportSpecifier as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<ExprOrSpread> {
    #[doc = "Calls [Fold`::fold_expr_or_spreads`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_expr_or_spreads(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <ExprOrSpread as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<Box<Expr>> {
    #[doc = "Calls [Fold`::fold_exprs`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_exprs(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <Box<Expr> as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<ImportSpecifier> {
    #[doc = "Calls [Fold`::fold_import_specifiers`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import_specifiers(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <ImportSpecifier as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<ImportWithItem> {
    #[doc = "Calls [Fold`::fold_import_with_items`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_import_with_items(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <ImportWithItem as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<JSXAttrOrSpread> {
    #[doc = "Calls [Fold`::fold_jsx_attr_or_spreads`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_attr_or_spreads(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <JSXAttrOrSpread as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<JSXElementChild> {
    #[doc = "Calls [Fold`::fold_jsx_element_childs`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_jsx_element_childs(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <JSXElementChild as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<ModuleItem> {
    #[doc = "Calls [Fold`::fold_module_items`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_module_items(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <ModuleItem as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<ObjectPatProp> {
    #[doc = "Calls [Fold`::fold_object_pat_props`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_object_pat_props(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <ObjectPatProp as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<Accessibility> {
    #[doc = "Calls [Fold`::fold_opt_accessibility`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_accessibility(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <Accessibility as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<swc_atoms::Atom> {
    #[doc = "Calls [Fold`::fold_opt_atom`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_atom(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <swc_atoms::Atom as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<BlockStmt> {
    #[doc = "Calls [Fold`::fold_opt_block_stmt`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_block_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <BlockStmt as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<CatchClause> {
    #[doc = "Calls [Fold`::fold_opt_catch_clause`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_catch_clause(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <CatchClause as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<Box<Expr>> {
    #[doc = "Calls [Fold`::fold_opt_expr`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <Box<Expr> as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<ExprOrSpread> {
    #[doc = "Calls [Fold`::fold_opt_expr_or_spread`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_expr_or_spread(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <ExprOrSpread as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<Vec<ExprOrSpread>> {
    #[doc = "Calls [Fold`::fold_opt_expr_or_spreads`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_expr_or_spreads(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <Vec<ExprOrSpread> as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<Ident> {
    #[doc = "Calls [Fold`::fold_opt_ident`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_ident(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <Ident as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<JSXAttrValue> {
    #[doc = "Calls [Fold`::fold_opt_jsx_attr_value`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_jsx_attr_value(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <JSXAttrValue as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<JSXClosingElement> {
    #[doc = "Calls [Fold`::fold_opt_jsx_closing_element`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_jsx_closing_element(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <JSXClosingElement as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<ModuleExportName> {
    #[doc = "Calls [Fold`::fold_opt_module_export_name`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_module_export_name(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <ModuleExportName as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<Vec<ModuleItem>> {
    #[doc = "Calls [Fold`::fold_opt_module_items`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_module_items(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <Vec<ModuleItem> as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<Box<ObjectLit>> {
    #[doc = "Calls [Fold`::fold_opt_object_lit`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_object_lit(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <Box<ObjectLit> as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<Pat> {
    #[doc = "Calls [Fold`::fold_opt_pat`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_pat(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <Pat as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<swc_common::Span> {
    #[doc = "Calls [Fold`::fold_opt_span`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_span(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <swc_common::Span as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<Box<Stmt>> {
    #[doc = "Calls [Fold`::fold_opt_stmt`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_stmt(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <Box<Stmt> as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<Box<Str>> {
    #[doc = "Calls [Fold`::fold_opt_str`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_str(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <Box<Str> as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<TruePlusMinus> {
    #[doc = "Calls [Fold`::fold_opt_true_plus_minus`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_true_plus_minus(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <TruePlusMinus as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<TsEntityName> {
    #[doc = "Calls [Fold`::fold_opt_ts_entity_name`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_ts_entity_name(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <TsEntityName as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<TsNamespaceBody> {
    #[doc = "Calls [Fold`::fold_opt_ts_namespace_body`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_ts_namespace_body(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <TsNamespaceBody as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<Box<TsType>> {
    #[doc = "Calls [Fold`::fold_opt_ts_type`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_ts_type(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <Box<TsType> as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<Box<TsTypeAnn>> {
    #[doc = "Calls [Fold`::fold_opt_ts_type_ann`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_ts_type_ann(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <Box<TsTypeAnn> as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<Box<TsTypeParamDecl>> {
    #[doc = "Calls [Fold`::fold_opt_ts_type_param_decl`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_ts_type_param_decl(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <Box<TsTypeParamDecl> as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<Box<TsTypeParamInstantiation>> {
    #[doc = "Calls [Fold`::fold_opt_ts_type_param_instantiation`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_ts_type_param_instantiation(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <Box<TsTypeParamInstantiation> as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Option<VarDeclOrExpr> {
    #[doc = "Calls [Fold`::fold_opt_var_decl_or_expr`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_var_decl_or_expr(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.map(|inner| <VarDeclOrExpr as FoldWith<V>>::fold_with(inner, visitor))
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<Option<ExprOrSpread>> {
    #[doc = "Calls [Fold`::fold_opt_vec_expr_or_spreads`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_vec_expr_or_spreads(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <Option<ExprOrSpread> as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<Option<Pat>> {
    #[doc = "Calls [Fold`::fold_opt_vec_pats`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_opt_vec_pats(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <Option<Pat> as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<ParamOrTsParamProp> {
    #[doc = "Calls [Fold`::fold_param_or_ts_param_props`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_param_or_ts_param_props(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <ParamOrTsParamProp as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<Param> {
    #[doc = "Calls [Fold`::fold_params`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_params(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <Param as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<Pat> {
    #[doc = "Calls [Fold`::fold_pats`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_pats(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <Pat as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for PrivateMethod {
    #[doc = "Calls [Fold`::fold_private_method`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_private_method(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<PropOrSpread> {
    #[doc = "Calls [Fold`::fold_prop_or_spreads`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_prop_or_spreads(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <PropOrSpread as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for swc_common::Span {
    #[doc = "Calls [Fold`::fold_span`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_span(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<Stmt> {
    #[doc = "Calls [Fold`::fold_stmts`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_stmts(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <Stmt as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<SwitchCase> {
    #[doc = "Calls [Fold`::fold_switch_cases`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_switch_cases(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <SwitchCase as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for swc_common::SyntaxContext {
    #[doc = "Calls [Fold`::fold_syntax_context`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_syntax_context(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<TplElement> {
    #[doc = "Calls [Fold`::fold_tpl_elements`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_tpl_elements(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <TplElement as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<TsEnumMember> {
    #[doc = "Calls [Fold`::fold_ts_enum_members`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_enum_members(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <TsEnumMember as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<TsExprWithTypeArgs> {
    #[doc = "Calls [Fold`::fold_ts_expr_with_type_argss`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_expr_with_type_argss(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <TsExprWithTypeArgs as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<TsFnParam> {
    #[doc = "Calls [Fold`::fold_ts_fn_params`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_fn_params(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <TsFnParam as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<TsTupleElement> {
    #[doc = "Calls [Fold`::fold_ts_tuple_elements`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_tuple_elements(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <TsTupleElement as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<TsTypeElement> {
    #[doc = "Calls [Fold`::fold_ts_type_elements`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_type_elements(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <TsTypeElement as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<TsTypeParam> {
    #[doc = "Calls [Fold`::fold_ts_type_params`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_type_params(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <TsTypeParam as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<Box<TsType>> {
    #[doc = "Calls [Fold`::fold_ts_types`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_ts_types(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <Box<TsType> as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V: ?Sized + Fold> FoldWith<V> for Vec<VarDeclarator> {
    #[doc = "Calls [Fold`::fold_var_declarators`] with `self`. (Extra impl)"]
    fn fold_with(self, visitor: &mut V) -> Self {
        <V as Fold>::fold_var_declarators(visitor, self)
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        self.into_iter()
            .map(|item| <VarDeclarator as FoldWith<V>>::fold_with(item, visitor))
            .collect()
    }
}
impl<V, T> FoldWith<V> for std::boxed::Box<T>
where
    V: ?Sized + Fold,
    T: FoldWith<V>,
{
    fn fold_with(self, visitor: &mut V) -> Self {
        let v = <T as FoldWith<V>>::fold_with(*self, visitor);
        let v = std::boxed::Box::new(v);
        v
    }

    fn fold_children_with(self, visitor: &mut V) -> Self {
        let v = <T as FoldWith<V>>::fold_children_with(*self, visitor);
        let v = std::boxed::Box::new(v);
        v
    }
}
#[doc = r" A visitor trait for traversing the AST."]
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
pub trait FoldAstPath {
    #[doc = "Visit a node of type `Accessibility`.\n\nBy default, this method calls \
             [`Accessibility::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_accessibility(
        &mut self,
        node: Accessibility,
        ast_path: &mut AstKindPath,
    ) -> Accessibility {
        <Accessibility as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ArrayLit`.\n\nBy default, this method calls \
             [`ArrayLit::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_array_lit(&mut self, node: ArrayLit, ast_path: &mut AstKindPath) -> ArrayLit {
        <ArrayLit as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ArrayPat`.\n\nBy default, this method calls \
             [`ArrayPat::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_array_pat(&mut self, node: ArrayPat, ast_path: &mut AstKindPath) -> ArrayPat {
        <ArrayPat as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ArrowExpr`.\n\nBy default, this method calls \
             [`ArrowExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_arrow_expr(&mut self, node: ArrowExpr, ast_path: &mut AstKindPath) -> ArrowExpr {
        <ArrowExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `AssignExpr`.\n\nBy default, this method calls \
             [`AssignExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_assign_expr(&mut self, node: AssignExpr, ast_path: &mut AstKindPath) -> AssignExpr {
        <AssignExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `AssignOp`.\n\nBy default, this method calls \
             [`AssignOp::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_assign_op(&mut self, node: AssignOp, ast_path: &mut AstKindPath) -> AssignOp {
        <AssignOp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `AssignPat`.\n\nBy default, this method calls \
             [`AssignPat::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_assign_pat(&mut self, node: AssignPat, ast_path: &mut AstKindPath) -> AssignPat {
        <AssignPat as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `AssignPatProp`.\n\nBy default, this method calls \
             [`AssignPatProp::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_assign_pat_prop(
        &mut self,
        node: AssignPatProp,
        ast_path: &mut AstKindPath,
    ) -> AssignPatProp {
        <AssignPatProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `AssignProp`.\n\nBy default, this method calls \
             [`AssignProp::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_assign_prop(&mut self, node: AssignProp, ast_path: &mut AstKindPath) -> AssignProp {
        <AssignProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `AssignTarget`.\n\nBy default, this method calls \
             [`AssignTarget::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_assign_target(
        &mut self,
        node: AssignTarget,
        ast_path: &mut AstKindPath,
    ) -> AssignTarget {
        <AssignTarget as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `AssignTargetPat`.\n\nBy default, this method calls \
             [`AssignTargetPat::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_assign_target_pat(
        &mut self,
        node: AssignTargetPat,
        ast_path: &mut AstKindPath,
    ) -> AssignTargetPat {
        <AssignTargetPat as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `swc_atoms :: Atom`.\n\nBy default, this method calls \
             [`swc_atoms :: Atom::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_atom(&mut self, node: swc_atoms::Atom, ast_path: &mut AstKindPath) -> swc_atoms::Atom {
        <swc_atoms::Atom as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `AutoAccessor`.\n\nBy default, this method calls \
             [`AutoAccessor::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_auto_accessor(
        &mut self,
        node: AutoAccessor,
        ast_path: &mut AstKindPath,
    ) -> AutoAccessor {
        <AutoAccessor as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `AwaitExpr`.\n\nBy default, this method calls \
             [`AwaitExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_await_expr(&mut self, node: AwaitExpr, ast_path: &mut AstKindPath) -> AwaitExpr {
        <AwaitExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `BigInt`.\n\nBy default, this method calls \
             [`BigInt::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_big_int(&mut self, node: BigInt, ast_path: &mut AstKindPath) -> BigInt {
        <BigInt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `BigIntValue`.\n\nBy default, this method calls \
             [`BigIntValue::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_big_int_value(&mut self, node: BigIntValue, ast_path: &mut AstKindPath) -> BigIntValue {
        <BigIntValue as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `BinExpr`.\n\nBy default, this method calls \
             [`BinExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_bin_expr(&mut self, node: BinExpr, ast_path: &mut AstKindPath) -> BinExpr {
        <BinExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `BinaryOp`.\n\nBy default, this method calls \
             [`BinaryOp::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_binary_op(&mut self, node: BinaryOp, ast_path: &mut AstKindPath) -> BinaryOp {
        <BinaryOp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `BindingIdent`.\n\nBy default, this method calls \
             [`BindingIdent::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_binding_ident(
        &mut self,
        node: BindingIdent,
        ast_path: &mut AstKindPath,
    ) -> BindingIdent {
        <BindingIdent as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `BlockStmt`.\n\nBy default, this method calls \
             [`BlockStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_block_stmt(&mut self, node: BlockStmt, ast_path: &mut AstKindPath) -> BlockStmt {
        <BlockStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `BlockStmtOrExpr`.\n\nBy default, this method calls \
             [`BlockStmtOrExpr::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_block_stmt_or_expr(
        &mut self,
        node: BlockStmtOrExpr,
        ast_path: &mut AstKindPath,
    ) -> BlockStmtOrExpr {
        <BlockStmtOrExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Bool`.\n\nBy default, this method calls \
             [`Bool::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_bool(&mut self, node: Bool, ast_path: &mut AstKindPath) -> Bool {
        <Bool as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `BreakStmt`.\n\nBy default, this method calls \
             [`BreakStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_break_stmt(&mut self, node: BreakStmt, ast_path: &mut AstKindPath) -> BreakStmt {
        <BreakStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `CallExpr`.\n\nBy default, this method calls \
             [`CallExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_call_expr(&mut self, node: CallExpr, ast_path: &mut AstKindPath) -> CallExpr {
        <CallExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Callee`.\n\nBy default, this method calls \
             [`Callee::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_callee(&mut self, node: Callee, ast_path: &mut AstKindPath) -> Callee {
        <Callee as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `CatchClause`.\n\nBy default, this method calls \
             [`CatchClause::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_catch_clause(&mut self, node: CatchClause, ast_path: &mut AstKindPath) -> CatchClause {
        <CatchClause as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Class`.\n\nBy default, this method calls \
             [`Class::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_class(&mut self, node: Class, ast_path: &mut AstKindPath) -> Class {
        <Class as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ClassDecl`.\n\nBy default, this method calls \
             [`ClassDecl::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_class_decl(&mut self, node: ClassDecl, ast_path: &mut AstKindPath) -> ClassDecl {
        <ClassDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ClassExpr`.\n\nBy default, this method calls \
             [`ClassExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_class_expr(&mut self, node: ClassExpr, ast_path: &mut AstKindPath) -> ClassExpr {
        <ClassExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ClassMember`.\n\nBy default, this method calls \
             [`ClassMember::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_class_member(&mut self, node: ClassMember, ast_path: &mut AstKindPath) -> ClassMember {
        <ClassMember as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < ClassMember >`.\n\nBy default, this method calls [`Vec < \
             ClassMember >::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_class_members(
        &mut self,
        node: Vec<ClassMember>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ClassMember> {
        <Vec<ClassMember> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ClassMethod`.\n\nBy default, this method calls \
             [`ClassMethod::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_class_method(&mut self, node: ClassMethod, ast_path: &mut AstKindPath) -> ClassMethod {
        <ClassMethod as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ClassProp`.\n\nBy default, this method calls \
             [`ClassProp::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_class_prop(&mut self, node: ClassProp, ast_path: &mut AstKindPath) -> ClassProp {
        <ClassProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ComputedPropName`.\n\nBy default, this method calls \
             [`ComputedPropName::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_computed_prop_name(
        &mut self,
        node: ComputedPropName,
        ast_path: &mut AstKindPath,
    ) -> ComputedPropName {
        <ComputedPropName as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `CondExpr`.\n\nBy default, this method calls \
             [`CondExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_cond_expr(&mut self, node: CondExpr, ast_path: &mut AstKindPath) -> CondExpr {
        <CondExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Constructor`.\n\nBy default, this method calls \
             [`Constructor::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_constructor(&mut self, node: Constructor, ast_path: &mut AstKindPath) -> Constructor {
        <Constructor as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ContinueStmt`.\n\nBy default, this method calls \
             [`ContinueStmt::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_continue_stmt(
        &mut self,
        node: ContinueStmt,
        ast_path: &mut AstKindPath,
    ) -> ContinueStmt {
        <ContinueStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `DebuggerStmt`.\n\nBy default, this method calls \
             [`DebuggerStmt::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_debugger_stmt(
        &mut self,
        node: DebuggerStmt,
        ast_path: &mut AstKindPath,
    ) -> DebuggerStmt {
        <DebuggerStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Decl`.\n\nBy default, this method calls \
             [`Decl::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_decl(&mut self, node: Decl, ast_path: &mut AstKindPath) -> Decl {
        <Decl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Decorator`.\n\nBy default, this method calls \
             [`Decorator::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_decorator(&mut self, node: Decorator, ast_path: &mut AstKindPath) -> Decorator {
        <Decorator as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < Decorator >`.\n\nBy default, this method calls [`Vec < \
             Decorator >::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_decorators(
        &mut self,
        node: Vec<Decorator>,
        ast_path: &mut AstKindPath,
    ) -> Vec<Decorator> {
        <Vec<Decorator> as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `DefaultDecl`.\n\nBy default, this method calls \
             [`DefaultDecl::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_default_decl(&mut self, node: DefaultDecl, ast_path: &mut AstKindPath) -> DefaultDecl {
        <DefaultDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `DoWhileStmt`.\n\nBy default, this method calls \
             [`DoWhileStmt::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_do_while_stmt(&mut self, node: DoWhileStmt, ast_path: &mut AstKindPath) -> DoWhileStmt {
        <DoWhileStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `EmptyStmt`.\n\nBy default, this method calls \
             [`EmptyStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_empty_stmt(&mut self, node: EmptyStmt, ast_path: &mut AstKindPath) -> EmptyStmt {
        <EmptyStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `EsVersion`.\n\nBy default, this method calls \
             [`EsVersion::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_es_version(&mut self, node: EsVersion, ast_path: &mut AstKindPath) -> EsVersion {
        <EsVersion as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ExportAll`.\n\nBy default, this method calls \
             [`ExportAll::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_export_all(&mut self, node: ExportAll, ast_path: &mut AstKindPath) -> ExportAll {
        <ExportAll as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ExportDecl`.\n\nBy default, this method calls \
             [`ExportDecl::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_export_decl(&mut self, node: ExportDecl, ast_path: &mut AstKindPath) -> ExportDecl {
        <ExportDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ExportDefaultDecl`.\n\nBy default, this method calls \
             [`ExportDefaultDecl::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_export_default_decl(
        &mut self,
        node: ExportDefaultDecl,
        ast_path: &mut AstKindPath,
    ) -> ExportDefaultDecl {
        <ExportDefaultDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportDefaultExpr`.\n\nBy default, this method calls \
             [`ExportDefaultExpr::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_export_default_expr(
        &mut self,
        node: ExportDefaultExpr,
        ast_path: &mut AstKindPath,
    ) -> ExportDefaultExpr {
        <ExportDefaultExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ExportDefaultSpecifier::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_export_default_specifier(
        &mut self,
        node: ExportDefaultSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ExportDefaultSpecifier {
        <ExportDefaultSpecifier as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportNamedSpecifier`.\n\nBy default, this method calls \
             [`ExportNamedSpecifier::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_export_named_specifier(
        &mut self,
        node: ExportNamedSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ExportNamedSpecifier {
        <ExportNamedSpecifier as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportNamespaceSpecifier`.\n\nBy default, this method calls \
             [`ExportNamespaceSpecifier::fold_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn fold_export_namespace_specifier(
        &mut self,
        node: ExportNamespaceSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ExportNamespaceSpecifier {
        <ExportNamespaceSpecifier as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ExportSpecifier`.\n\nBy default, this method calls \
             [`ExportSpecifier::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_export_specifier(
        &mut self,
        node: ExportSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ExportSpecifier {
        <ExportSpecifier as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ExportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ExportSpecifier >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_export_specifiers(
        &mut self,
        node: Vec<ExportSpecifier>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ExportSpecifier> {
        <Vec<ExportSpecifier> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Expr`.\n\nBy default, this method calls \
             [`Expr::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_expr(&mut self, node: Expr, ast_path: &mut AstKindPath) -> Expr {
        <Expr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ExprOrSpread`.\n\nBy default, this method calls \
             [`ExprOrSpread::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_expr_or_spread(
        &mut self,
        node: ExprOrSpread,
        ast_path: &mut AstKindPath,
    ) -> ExprOrSpread {
        <ExprOrSpread as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < ExprOrSpread >`.\n\nBy default, this method calls [`Vec < \
             ExprOrSpread >::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_expr_or_spreads(
        &mut self,
        node: Vec<ExprOrSpread>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ExprOrSpread> {
        <Vec<ExprOrSpread> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ExprStmt`.\n\nBy default, this method calls \
             [`ExprStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_expr_stmt(&mut self, node: ExprStmt, ast_path: &mut AstKindPath) -> ExprStmt {
        <ExprStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < Box < Expr > >`.\n\nBy default, this method calls [`Vec < \
             Box < Expr > >::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_exprs(&mut self, node: Vec<Box<Expr>>, ast_path: &mut AstKindPath) -> Vec<Box<Expr>> {
        <Vec<Box<Expr>> as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `FnDecl`.\n\nBy default, this method calls \
             [`FnDecl::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_fn_decl(&mut self, node: FnDecl, ast_path: &mut AstKindPath) -> FnDecl {
        <FnDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `FnExpr`.\n\nBy default, this method calls \
             [`FnExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_fn_expr(&mut self, node: FnExpr, ast_path: &mut AstKindPath) -> FnExpr {
        <FnExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ForHead`.\n\nBy default, this method calls \
             [`ForHead::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_for_head(&mut self, node: ForHead, ast_path: &mut AstKindPath) -> ForHead {
        <ForHead as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ForInStmt`.\n\nBy default, this method calls \
             [`ForInStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_for_in_stmt(&mut self, node: ForInStmt, ast_path: &mut AstKindPath) -> ForInStmt {
        <ForInStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ForOfStmt`.\n\nBy default, this method calls \
             [`ForOfStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_for_of_stmt(&mut self, node: ForOfStmt, ast_path: &mut AstKindPath) -> ForOfStmt {
        <ForOfStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ForStmt`.\n\nBy default, this method calls \
             [`ForStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_for_stmt(&mut self, node: ForStmt, ast_path: &mut AstKindPath) -> ForStmt {
        <ForStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Function`.\n\nBy default, this method calls \
             [`Function::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_function(&mut self, node: Function, ast_path: &mut AstKindPath) -> Function {
        <Function as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `GetterProp`.\n\nBy default, this method calls \
             [`GetterProp::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_getter_prop(&mut self, node: GetterProp, ast_path: &mut AstKindPath) -> GetterProp {
        <GetterProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Ident`.\n\nBy default, this method calls \
             [`Ident::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ident(&mut self, node: Ident, ast_path: &mut AstKindPath) -> Ident {
        <Ident as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `IdentName`.\n\nBy default, this method calls \
             [`IdentName::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ident_name(&mut self, node: IdentName, ast_path: &mut AstKindPath) -> IdentName {
        <IdentName as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `IfStmt`.\n\nBy default, this method calls \
             [`IfStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_if_stmt(&mut self, node: IfStmt, ast_path: &mut AstKindPath) -> IfStmt {
        <IfStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Import`.\n\nBy default, this method calls \
             [`Import::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_import(&mut self, node: Import, ast_path: &mut AstKindPath) -> Import {
        <Import as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ImportDecl`.\n\nBy default, this method calls \
             [`ImportDecl::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_import_decl(&mut self, node: ImportDecl, ast_path: &mut AstKindPath) -> ImportDecl {
        <ImportDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ImportDefaultSpecifier`.\n\nBy default, this method calls \
             [`ImportDefaultSpecifier::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_import_default_specifier(
        &mut self,
        node: ImportDefaultSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ImportDefaultSpecifier {
        <ImportDefaultSpecifier as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportNamedSpecifier`.\n\nBy default, this method calls \
             [`ImportNamedSpecifier::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_import_named_specifier(
        &mut self,
        node: ImportNamedSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ImportNamedSpecifier {
        <ImportNamedSpecifier as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportPhase`.\n\nBy default, this method calls \
             [`ImportPhase::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_import_phase(&mut self, node: ImportPhase, ast_path: &mut AstKindPath) -> ImportPhase {
        <ImportPhase as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ImportSpecifier`.\n\nBy default, this method calls \
             [`ImportSpecifier::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_import_specifier(
        &mut self,
        node: ImportSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ImportSpecifier {
        <ImportSpecifier as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ImportSpecifier >`.\n\nBy default, this method calls \
             [`Vec < ImportSpecifier >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_import_specifiers(
        &mut self,
        node: Vec<ImportSpecifier>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ImportSpecifier> {
        <Vec<ImportSpecifier> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportStarAsSpecifier`.\n\nBy default, this method calls \
             [`ImportStarAsSpecifier::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_import_star_as_specifier(
        &mut self,
        node: ImportStarAsSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ImportStarAsSpecifier {
        <ImportStarAsSpecifier as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ImportWith`.\n\nBy default, this method calls \
             [`ImportWith::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_import_with(&mut self, node: ImportWith, ast_path: &mut AstKindPath) -> ImportWith {
        <ImportWith as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ImportWithItem`.\n\nBy default, this method calls \
             [`ImportWithItem::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_import_with_item(
        &mut self,
        node: ImportWithItem,
        ast_path: &mut AstKindPath,
    ) -> ImportWithItem {
        <ImportWithItem as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < ImportWithItem >`.\n\nBy default, this method calls [`Vec \
             < ImportWithItem >::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_import_with_items(
        &mut self,
        node: Vec<ImportWithItem>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ImportWithItem> {
        <Vec<ImportWithItem> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Invalid`.\n\nBy default, this method calls \
             [`Invalid::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_invalid(&mut self, node: Invalid, ast_path: &mut AstKindPath) -> Invalid {
        <Invalid as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `JSXAttr`.\n\nBy default, this method calls \
             [`JSXAttr::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_jsx_attr(&mut self, node: JSXAttr, ast_path: &mut AstKindPath) -> JSXAttr {
        <JSXAttr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `JSXAttrName`.\n\nBy default, this method calls \
             [`JSXAttrName::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_jsx_attr_name(&mut self, node: JSXAttrName, ast_path: &mut AstKindPath) -> JSXAttrName {
        <JSXAttrName as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `JSXAttrOrSpread`.\n\nBy default, this method calls \
             [`JSXAttrOrSpread::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_jsx_attr_or_spread(
        &mut self,
        node: JSXAttrOrSpread,
        ast_path: &mut AstKindPath,
    ) -> JSXAttrOrSpread {
        <JSXAttrOrSpread as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < JSXAttrOrSpread >`.\n\nBy default, this method calls \
             [`Vec < JSXAttrOrSpread >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_jsx_attr_or_spreads(
        &mut self,
        node: Vec<JSXAttrOrSpread>,
        ast_path: &mut AstKindPath,
    ) -> Vec<JSXAttrOrSpread> {
        <Vec<JSXAttrOrSpread> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXAttrValue`.\n\nBy default, this method calls \
             [`JSXAttrValue::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_jsx_attr_value(
        &mut self,
        node: JSXAttrValue,
        ast_path: &mut AstKindPath,
    ) -> JSXAttrValue {
        <JSXAttrValue as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `JSXClosingElement`.\n\nBy default, this method calls \
             [`JSXClosingElement::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_jsx_closing_element(
        &mut self,
        node: JSXClosingElement,
        ast_path: &mut AstKindPath,
    ) -> JSXClosingElement {
        <JSXClosingElement as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXClosingFragment`.\n\nBy default, this method calls \
             [`JSXClosingFragment::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_jsx_closing_fragment(
        &mut self,
        node: JSXClosingFragment,
        ast_path: &mut AstKindPath,
    ) -> JSXClosingFragment {
        <JSXClosingFragment as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXElement`.\n\nBy default, this method calls \
             [`JSXElement::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_jsx_element(&mut self, node: JSXElement, ast_path: &mut AstKindPath) -> JSXElement {
        <JSXElement as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `JSXElementChild`.\n\nBy default, this method calls \
             [`JSXElementChild::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_jsx_element_child(
        &mut self,
        node: JSXElementChild,
        ast_path: &mut AstKindPath,
    ) -> JSXElementChild {
        <JSXElementChild as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < JSXElementChild >`.\n\nBy default, this method calls \
             [`Vec < JSXElementChild >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_jsx_element_childs(
        &mut self,
        node: Vec<JSXElementChild>,
        ast_path: &mut AstKindPath,
    ) -> Vec<JSXElementChild> {
        <Vec<JSXElementChild> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXElementName`.\n\nBy default, this method calls \
             [`JSXElementName::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_jsx_element_name(
        &mut self,
        node: JSXElementName,
        ast_path: &mut AstKindPath,
    ) -> JSXElementName {
        <JSXElementName as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `JSXEmptyExpr`.\n\nBy default, this method calls \
             [`JSXEmptyExpr::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_jsx_empty_expr(
        &mut self,
        node: JSXEmptyExpr,
        ast_path: &mut AstKindPath,
    ) -> JSXEmptyExpr {
        <JSXEmptyExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `JSXExpr`.\n\nBy default, this method calls \
             [`JSXExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_jsx_expr(&mut self, node: JSXExpr, ast_path: &mut AstKindPath) -> JSXExpr {
        <JSXExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `JSXExprContainer`.\n\nBy default, this method calls \
             [`JSXExprContainer::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_jsx_expr_container(
        &mut self,
        node: JSXExprContainer,
        ast_path: &mut AstKindPath,
    ) -> JSXExprContainer {
        <JSXExprContainer as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXFragment`.\n\nBy default, this method calls \
             [`JSXFragment::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_jsx_fragment(&mut self, node: JSXFragment, ast_path: &mut AstKindPath) -> JSXFragment {
        <JSXFragment as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `JSXMemberExpr`.\n\nBy default, this method calls \
             [`JSXMemberExpr::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_jsx_member_expr(
        &mut self,
        node: JSXMemberExpr,
        ast_path: &mut AstKindPath,
    ) -> JSXMemberExpr {
        <JSXMemberExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `JSXNamespacedName`.\n\nBy default, this method calls \
             [`JSXNamespacedName::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_jsx_namespaced_name(
        &mut self,
        node: JSXNamespacedName,
        ast_path: &mut AstKindPath,
    ) -> JSXNamespacedName {
        <JSXNamespacedName as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXObject`.\n\nBy default, this method calls \
             [`JSXObject::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_jsx_object(&mut self, node: JSXObject, ast_path: &mut AstKindPath) -> JSXObject {
        <JSXObject as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `JSXOpeningElement`.\n\nBy default, this method calls \
             [`JSXOpeningElement::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_jsx_opening_element(
        &mut self,
        node: JSXOpeningElement,
        ast_path: &mut AstKindPath,
    ) -> JSXOpeningElement {
        <JSXOpeningElement as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXOpeningFragment`.\n\nBy default, this method calls \
             [`JSXOpeningFragment::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_jsx_opening_fragment(
        &mut self,
        node: JSXOpeningFragment,
        ast_path: &mut AstKindPath,
    ) -> JSXOpeningFragment {
        <JSXOpeningFragment as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `JSXSpreadChild`.\n\nBy default, this method calls \
             [`JSXSpreadChild::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_jsx_spread_child(
        &mut self,
        node: JSXSpreadChild,
        ast_path: &mut AstKindPath,
    ) -> JSXSpreadChild {
        <JSXSpreadChild as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `JSXText`.\n\nBy default, this method calls \
             [`JSXText::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_jsx_text(&mut self, node: JSXText, ast_path: &mut AstKindPath) -> JSXText {
        <JSXText as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Key`.\n\nBy default, this method calls \
             [`Key::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_key(&mut self, node: Key, ast_path: &mut AstKindPath) -> Key {
        <Key as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `KeyValuePatProp`.\n\nBy default, this method calls \
             [`KeyValuePatProp::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_key_value_pat_prop(
        &mut self,
        node: KeyValuePatProp,
        ast_path: &mut AstKindPath,
    ) -> KeyValuePatProp {
        <KeyValuePatProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `KeyValueProp`.\n\nBy default, this method calls \
             [`KeyValueProp::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_key_value_prop(
        &mut self,
        node: KeyValueProp,
        ast_path: &mut AstKindPath,
    ) -> KeyValueProp {
        <KeyValueProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `LabeledStmt`.\n\nBy default, this method calls \
             [`LabeledStmt::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_labeled_stmt(&mut self, node: LabeledStmt, ast_path: &mut AstKindPath) -> LabeledStmt {
        <LabeledStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Lit`.\n\nBy default, this method calls \
             [`Lit::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_lit(&mut self, node: Lit, ast_path: &mut AstKindPath) -> Lit {
        <Lit as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `MemberExpr`.\n\nBy default, this method calls \
             [`MemberExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_member_expr(&mut self, node: MemberExpr, ast_path: &mut AstKindPath) -> MemberExpr {
        <MemberExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `MemberProp`.\n\nBy default, this method calls \
             [`MemberProp::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_member_prop(&mut self, node: MemberProp, ast_path: &mut AstKindPath) -> MemberProp {
        <MemberProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `MetaPropExpr`.\n\nBy default, this method calls \
             [`MetaPropExpr::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_meta_prop_expr(
        &mut self,
        node: MetaPropExpr,
        ast_path: &mut AstKindPath,
    ) -> MetaPropExpr {
        <MetaPropExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `MetaPropKind`.\n\nBy default, this method calls \
             [`MetaPropKind::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_meta_prop_kind(
        &mut self,
        node: MetaPropKind,
        ast_path: &mut AstKindPath,
    ) -> MetaPropKind {
        <MetaPropKind as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `MethodKind`.\n\nBy default, this method calls \
             [`MethodKind::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_method_kind(&mut self, node: MethodKind, ast_path: &mut AstKindPath) -> MethodKind {
        <MethodKind as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `MethodProp`.\n\nBy default, this method calls \
             [`MethodProp::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_method_prop(&mut self, node: MethodProp, ast_path: &mut AstKindPath) -> MethodProp {
        <MethodProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Module`.\n\nBy default, this method calls \
             [`Module::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_module(&mut self, node: Module, ast_path: &mut AstKindPath) -> Module {
        <Module as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ModuleDecl`.\n\nBy default, this method calls \
             [`ModuleDecl::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_module_decl(&mut self, node: ModuleDecl, ast_path: &mut AstKindPath) -> ModuleDecl {
        <ModuleDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ModuleExportName`.\n\nBy default, this method calls \
             [`ModuleExportName::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_module_export_name(
        &mut self,
        node: ModuleExportName,
        ast_path: &mut AstKindPath,
    ) -> ModuleExportName {
        <ModuleExportName as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `ModuleItem`.\n\nBy default, this method calls \
             [`ModuleItem::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_module_item(&mut self, node: ModuleItem, ast_path: &mut AstKindPath) -> ModuleItem {
        <ModuleItem as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < ModuleItem >`.\n\nBy default, this method calls [`Vec < \
             ModuleItem >::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_module_items(
        &mut self,
        node: Vec<ModuleItem>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ModuleItem> {
        <Vec<ModuleItem> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `NamedExport`.\n\nBy default, this method calls \
             [`NamedExport::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_named_export(&mut self, node: NamedExport, ast_path: &mut AstKindPath) -> NamedExport {
        <NamedExport as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `NewExpr`.\n\nBy default, this method calls \
             [`NewExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_new_expr(&mut self, node: NewExpr, ast_path: &mut AstKindPath) -> NewExpr {
        <NewExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Null`.\n\nBy default, this method calls \
             [`Null::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_null(&mut self, node: Null, ast_path: &mut AstKindPath) -> Null {
        <Null as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Number`.\n\nBy default, this method calls \
             [`Number::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_number(&mut self, node: Number, ast_path: &mut AstKindPath) -> Number {
        <Number as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ObjectLit`.\n\nBy default, this method calls \
             [`ObjectLit::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_object_lit(&mut self, node: ObjectLit, ast_path: &mut AstKindPath) -> ObjectLit {
        <ObjectLit as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ObjectPat`.\n\nBy default, this method calls \
             [`ObjectPat::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_object_pat(&mut self, node: ObjectPat, ast_path: &mut AstKindPath) -> ObjectPat {
        <ObjectPat as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ObjectPatProp`.\n\nBy default, this method calls \
             [`ObjectPatProp::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_object_pat_prop(
        &mut self,
        node: ObjectPatProp,
        ast_path: &mut AstKindPath,
    ) -> ObjectPatProp {
        <ObjectPatProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < ObjectPatProp >`.\n\nBy default, this method calls [`Vec \
             < ObjectPatProp >::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_object_pat_props(
        &mut self,
        node: Vec<ObjectPatProp>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ObjectPatProp> {
        <Vec<ObjectPatProp> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Accessibility >`.\n\nBy default, this method calls \
             [`Option < Accessibility >::fold_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn fold_opt_accessibility(
        &mut self,
        node: Option<Accessibility>,
        ast_path: &mut AstKindPath,
    ) -> Option<Accessibility> {
        <Option<Accessibility> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < swc_atoms :: Atom >`.\n\nBy default, this method calls \
             [`Option < swc_atoms :: Atom >::fold_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn fold_opt_atom(
        &mut self,
        node: Option<swc_atoms::Atom>,
        ast_path: &mut AstKindPath,
    ) -> Option<swc_atoms::Atom> {
        <Option<swc_atoms::Atom> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < BlockStmt >`.\n\nBy default, this method calls \
             [`Option < BlockStmt >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_opt_block_stmt(
        &mut self,
        node: Option<BlockStmt>,
        ast_path: &mut AstKindPath,
    ) -> Option<BlockStmt> {
        <Option<BlockStmt> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `OptCall`.\n\nBy default, this method calls \
             [`OptCall::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_opt_call(&mut self, node: OptCall, ast_path: &mut AstKindPath) -> OptCall {
        <OptCall as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Option < CatchClause >`.\n\nBy default, this method calls \
             [`Option < CatchClause >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_opt_catch_clause(
        &mut self,
        node: Option<CatchClause>,
        ast_path: &mut AstKindPath,
    ) -> Option<CatchClause> {
        <Option<CatchClause> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `OptChainBase`.\n\nBy default, this method calls \
             [`OptChainBase::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_opt_chain_base(
        &mut self,
        node: OptChainBase,
        ast_path: &mut AstKindPath,
    ) -> OptChainBase {
        <OptChainBase as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `OptChainExpr`.\n\nBy default, this method calls \
             [`OptChainExpr::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_opt_chain_expr(
        &mut self,
        node: OptChainExpr,
        ast_path: &mut AstKindPath,
    ) -> OptChainExpr {
        <OptChainExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Option < Box < Expr > >`.\n\nBy default, this method calls \
             [`Option < Box < Expr > >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_opt_expr(
        &mut self,
        node: Option<Box<Expr>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<Expr>> {
        <Option<Box<Expr>> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < ExprOrSpread >`.\n\nBy default, this method calls \
             [`Option < ExprOrSpread >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_opt_expr_or_spread(
        &mut self,
        node: Option<ExprOrSpread>,
        ast_path: &mut AstKindPath,
    ) -> Option<ExprOrSpread> {
        <Option<ExprOrSpread> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Vec < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Option < Vec < ExprOrSpread > >::fold_children_with_ast_path`]. If you want \
             to recurse, you need to call it manually."]
    fn fold_opt_expr_or_spreads(
        &mut self,
        node: Option<Vec<ExprOrSpread>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Vec<ExprOrSpread>> {
        <Option<Vec<ExprOrSpread>> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Ident >`.\n\nBy default, this method calls [`Option < \
             Ident >::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_opt_ident(&mut self, node: Option<Ident>, ast_path: &mut AstKindPath) -> Option<Ident> {
        <Option<Ident> as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Option < JSXAttrValue >`.\n\nBy default, this method calls \
             [`Option < JSXAttrValue >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_opt_jsx_attr_value(
        &mut self,
        node: Option<JSXAttrValue>,
        ast_path: &mut AstKindPath,
    ) -> Option<JSXAttrValue> {
        <Option<JSXAttrValue> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < JSXClosingElement >`.\n\nBy default, this method calls \
             [`Option < JSXClosingElement >::fold_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn fold_opt_jsx_closing_element(
        &mut self,
        node: Option<JSXClosingElement>,
        ast_path: &mut AstKindPath,
    ) -> Option<JSXClosingElement> {
        <Option<JSXClosingElement> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < ModuleExportName >`.\n\nBy default, this method calls \
             [`Option < ModuleExportName >::fold_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn fold_opt_module_export_name(
        &mut self,
        node: Option<ModuleExportName>,
        ast_path: &mut AstKindPath,
    ) -> Option<ModuleExportName> {
        <Option<ModuleExportName> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Vec < ModuleItem > >`.\n\nBy default, this method \
             calls [`Option < Vec < ModuleItem > >::fold_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn fold_opt_module_items(
        &mut self,
        node: Option<Vec<ModuleItem>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Vec<ModuleItem>> {
        <Option<Vec<ModuleItem>> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < ObjectLit > >`.\n\nBy default, this method calls \
             [`Option < Box < ObjectLit > >::fold_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn fold_opt_object_lit(
        &mut self,
        node: Option<Box<ObjectLit>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<ObjectLit>> {
        <Option<Box<ObjectLit>> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Pat >`.\n\nBy default, this method calls [`Option < \
             Pat >::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_opt_pat(&mut self, node: Option<Pat>, ast_path: &mut AstKindPath) -> Option<Pat> {
        <Option<Pat> as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Option < swc_common :: Span >`.\n\nBy default, this method \
             calls [`Option < swc_common :: Span >::fold_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn fold_opt_span(
        &mut self,
        node: Option<swc_common::Span>,
        ast_path: &mut AstKindPath,
    ) -> Option<swc_common::Span> {
        <Option<swc_common::Span> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < Stmt > >`.\n\nBy default, this method calls \
             [`Option < Box < Stmt > >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_opt_stmt(
        &mut self,
        node: Option<Box<Stmt>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<Stmt>> {
        <Option<Box<Stmt>> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < Str > >`.\n\nBy default, this method calls \
             [`Option < Box < Str > >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_opt_str(
        &mut self,
        node: Option<Box<Str>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<Str>> {
        <Option<Box<Str>> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < TruePlusMinus >`.\n\nBy default, this method calls \
             [`Option < TruePlusMinus >::fold_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn fold_opt_true_plus_minus(
        &mut self,
        node: Option<TruePlusMinus>,
        ast_path: &mut AstKindPath,
    ) -> Option<TruePlusMinus> {
        <Option<TruePlusMinus> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < TsEntityName >`.\n\nBy default, this method calls \
             [`Option < TsEntityName >::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_opt_ts_entity_name(
        &mut self,
        node: Option<TsEntityName>,
        ast_path: &mut AstKindPath,
    ) -> Option<TsEntityName> {
        <Option<TsEntityName> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < TsNamespaceBody >`.\n\nBy default, this method calls \
             [`Option < TsNamespaceBody >::fold_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn fold_opt_ts_namespace_body(
        &mut self,
        node: Option<TsNamespaceBody>,
        ast_path: &mut AstKindPath,
    ) -> Option<TsNamespaceBody> {
        <Option<TsNamespaceBody> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < TsType > >`.\n\nBy default, this method calls \
             [`Option < Box < TsType > >::fold_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn fold_opt_ts_type(
        &mut self,
        node: Option<Box<TsType>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<TsType>> {
        <Option<Box<TsType>> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < TsTypeAnn > >`.\n\nBy default, this method calls \
             [`Option < Box < TsTypeAnn > >::fold_children_with_ast_path`]. If you want to \
             recurse, you need to call it manually."]
    fn fold_opt_ts_type_ann(
        &mut self,
        node: Option<Box<TsTypeAnn>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<TsTypeAnn>> {
        <Option<Box<TsTypeAnn>> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < TsTypeParamDecl > >`.\n\nBy default, this method \
             calls [`Option < Box < TsTypeParamDecl > >::fold_children_with_ast_path`]. If you \
             want to recurse, you need to call it manually."]
    fn fold_opt_ts_type_param_decl(
        &mut self,
        node: Option<Box<TsTypeParamDecl>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<TsTypeParamDecl>> {
        <Option<Box<TsTypeParamDecl>> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Option < Box < TsTypeParamInstantiation > >`.\n\nBy default, \
             this method calls [`Option < Box < TsTypeParamInstantiation > \
             >::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_opt_ts_type_param_instantiation(
        &mut self,
        node: Option<Box<TsTypeParamInstantiation>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<TsTypeParamInstantiation>> {
        < Option < Box < TsTypeParamInstantiation > > as FoldWithAstPath < Self > > :: fold_children_with_ast_path (node , self , ast_path)
    }
    #[doc = "Visit a node of type `Option < VarDeclOrExpr >`.\n\nBy default, this method calls \
             [`Option < VarDeclOrExpr >::fold_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn fold_opt_var_decl_or_expr(
        &mut self,
        node: Option<VarDeclOrExpr>,
        ast_path: &mut AstKindPath,
    ) -> Option<VarDeclOrExpr> {
        <Option<VarDeclOrExpr> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Option < ExprOrSpread > >`.\n\nBy default, this method \
             calls [`Vec < Option < ExprOrSpread > >::fold_children_with_ast_path`]. If you want \
             to recurse, you need to call it manually."]
    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        node: Vec<Option<ExprOrSpread>>,
        ast_path: &mut AstKindPath,
    ) -> Vec<Option<ExprOrSpread>> {
        <Vec<Option<ExprOrSpread>> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Option < Pat > >`.\n\nBy default, this method calls [`Vec \
             < Option < Pat > >::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_opt_vec_pats(
        &mut self,
        node: Vec<Option<Pat>>,
        ast_path: &mut AstKindPath,
    ) -> Vec<Option<Pat>> {
        <Vec<Option<Pat>> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Param`.\n\nBy default, this method calls \
             [`Param::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_param(&mut self, node: Param, ast_path: &mut AstKindPath) -> Param {
        <Param as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ParamOrTsParamProp`.\n\nBy default, this method calls \
             [`ParamOrTsParamProp::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_param_or_ts_param_prop(
        &mut self,
        node: ParamOrTsParamProp,
        ast_path: &mut AstKindPath,
    ) -> ParamOrTsParamProp {
        <ParamOrTsParamProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < ParamOrTsParamProp >`.\n\nBy default, this method calls \
             [`Vec < ParamOrTsParamProp >::fold_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn fold_param_or_ts_param_props(
        &mut self,
        node: Vec<ParamOrTsParamProp>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ParamOrTsParamProp> {
        <Vec<ParamOrTsParamProp> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < Param >`.\n\nBy default, this method calls [`Vec < Param \
             >::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_params(&mut self, node: Vec<Param>, ast_path: &mut AstKindPath) -> Vec<Param> {
        <Vec<Param> as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ParenExpr`.\n\nBy default, this method calls \
             [`ParenExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_paren_expr(&mut self, node: ParenExpr, ast_path: &mut AstKindPath) -> ParenExpr {
        <ParenExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Pat`.\n\nBy default, this method calls \
             [`Pat::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_pat(&mut self, node: Pat, ast_path: &mut AstKindPath) -> Pat {
        <Pat as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < Pat >`.\n\nBy default, this method calls [`Vec < Pat \
             >::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_pats(&mut self, node: Vec<Pat>, ast_path: &mut AstKindPath) -> Vec<Pat> {
        <Vec<Pat> as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `PrivateMethod`.\n\nBy default, this method calls \
             [`PrivateMethod::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_private_method(
        &mut self,
        node: PrivateMethod,
        ast_path: &mut AstKindPath,
    ) -> PrivateMethod {
        <PrivateMethod as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `PrivateName`.\n\nBy default, this method calls \
             [`PrivateName::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_private_name(&mut self, node: PrivateName, ast_path: &mut AstKindPath) -> PrivateName {
        <PrivateName as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `PrivateProp`.\n\nBy default, this method calls \
             [`PrivateProp::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_private_prop(&mut self, node: PrivateProp, ast_path: &mut AstKindPath) -> PrivateProp {
        <PrivateProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Program`.\n\nBy default, this method calls \
             [`Program::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_program(&mut self, node: Program, ast_path: &mut AstKindPath) -> Program {
        <Program as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Prop`.\n\nBy default, this method calls \
             [`Prop::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_prop(&mut self, node: Prop, ast_path: &mut AstKindPath) -> Prop {
        <Prop as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `PropName`.\n\nBy default, this method calls \
             [`PropName::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_prop_name(&mut self, node: PropName, ast_path: &mut AstKindPath) -> PropName {
        <PropName as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `PropOrSpread`.\n\nBy default, this method calls \
             [`PropOrSpread::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_prop_or_spread(
        &mut self,
        node: PropOrSpread,
        ast_path: &mut AstKindPath,
    ) -> PropOrSpread {
        <PropOrSpread as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < PropOrSpread >`.\n\nBy default, this method calls [`Vec < \
             PropOrSpread >::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_prop_or_spreads(
        &mut self,
        node: Vec<PropOrSpread>,
        ast_path: &mut AstKindPath,
    ) -> Vec<PropOrSpread> {
        <Vec<PropOrSpread> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Regex`.\n\nBy default, this method calls \
             [`Regex::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_regex(&mut self, node: Regex, ast_path: &mut AstKindPath) -> Regex {
        <Regex as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ReservedUnused`.\n\nBy default, this method calls \
             [`ReservedUnused::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_reserved_unused(
        &mut self,
        node: ReservedUnused,
        ast_path: &mut AstKindPath,
    ) -> ReservedUnused {
        <ReservedUnused as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `RestPat`.\n\nBy default, this method calls \
             [`RestPat::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_rest_pat(&mut self, node: RestPat, ast_path: &mut AstKindPath) -> RestPat {
        <RestPat as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ReturnStmt`.\n\nBy default, this method calls \
             [`ReturnStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_return_stmt(&mut self, node: ReturnStmt, ast_path: &mut AstKindPath) -> ReturnStmt {
        <ReturnStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Script`.\n\nBy default, this method calls \
             [`Script::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_script(&mut self, node: Script, ast_path: &mut AstKindPath) -> Script {
        <Script as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `SeqExpr`.\n\nBy default, this method calls \
             [`SeqExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_seq_expr(&mut self, node: SeqExpr, ast_path: &mut AstKindPath) -> SeqExpr {
        <SeqExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `SetterProp`.\n\nBy default, this method calls \
             [`SetterProp::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_setter_prop(&mut self, node: SetterProp, ast_path: &mut AstKindPath) -> SetterProp {
        <SetterProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `SimpleAssignTarget`.\n\nBy default, this method calls \
             [`SimpleAssignTarget::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_simple_assign_target(
        &mut self,
        node: SimpleAssignTarget,
        ast_path: &mut AstKindPath,
    ) -> SimpleAssignTarget {
        <SimpleAssignTarget as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `swc_common :: Span`.\n\nBy default, this method calls \
             [`swc_common :: Span::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_span(
        &mut self,
        node: swc_common::Span,
        ast_path: &mut AstKindPath,
    ) -> swc_common::Span {
        <swc_common::Span as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `SpreadElement`.\n\nBy default, this method calls \
             [`SpreadElement::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_spread_element(
        &mut self,
        node: SpreadElement,
        ast_path: &mut AstKindPath,
    ) -> SpreadElement {
        <SpreadElement as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `StaticBlock`.\n\nBy default, this method calls \
             [`StaticBlock::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_static_block(&mut self, node: StaticBlock, ast_path: &mut AstKindPath) -> StaticBlock {
        <StaticBlock as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Stmt`.\n\nBy default, this method calls \
             [`Stmt::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_stmt(&mut self, node: Stmt, ast_path: &mut AstKindPath) -> Stmt {
        <Stmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < Stmt >`.\n\nBy default, this method calls [`Vec < Stmt \
             >::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_stmts(&mut self, node: Vec<Stmt>, ast_path: &mut AstKindPath) -> Vec<Stmt> {
        <Vec<Stmt> as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Str`.\n\nBy default, this method calls \
             [`Str::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_str(&mut self, node: Str, ast_path: &mut AstKindPath) -> Str {
        <Str as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Super`.\n\nBy default, this method calls \
             [`Super::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_super(&mut self, node: Super, ast_path: &mut AstKindPath) -> Super {
        <Super as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `SuperProp`.\n\nBy default, this method calls \
             [`SuperProp::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_super_prop(&mut self, node: SuperProp, ast_path: &mut AstKindPath) -> SuperProp {
        <SuperProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `SuperPropExpr`.\n\nBy default, this method calls \
             [`SuperPropExpr::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_super_prop_expr(
        &mut self,
        node: SuperPropExpr,
        ast_path: &mut AstKindPath,
    ) -> SuperPropExpr {
        <SuperPropExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `SwitchCase`.\n\nBy default, this method calls \
             [`SwitchCase::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_switch_case(&mut self, node: SwitchCase, ast_path: &mut AstKindPath) -> SwitchCase {
        <SwitchCase as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < SwitchCase >`.\n\nBy default, this method calls [`Vec < \
             SwitchCase >::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_switch_cases(
        &mut self,
        node: Vec<SwitchCase>,
        ast_path: &mut AstKindPath,
    ) -> Vec<SwitchCase> {
        <Vec<SwitchCase> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `SwitchStmt`.\n\nBy default, this method calls \
             [`SwitchStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_switch_stmt(&mut self, node: SwitchStmt, ast_path: &mut AstKindPath) -> SwitchStmt {
        <SwitchStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `swc_common :: SyntaxContext`.\n\nBy default, this method calls \
             [`swc_common :: SyntaxContext::fold_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn fold_syntax_context(
        &mut self,
        node: swc_common::SyntaxContext,
        ast_path: &mut AstKindPath,
    ) -> swc_common::SyntaxContext {
        <swc_common::SyntaxContext as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TaggedTpl`.\n\nBy default, this method calls \
             [`TaggedTpl::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_tagged_tpl(&mut self, node: TaggedTpl, ast_path: &mut AstKindPath) -> TaggedTpl {
        <TaggedTpl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ThisExpr`.\n\nBy default, this method calls \
             [`ThisExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_this_expr(&mut self, node: ThisExpr, ast_path: &mut AstKindPath) -> ThisExpr {
        <ThisExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `ThrowStmt`.\n\nBy default, this method calls \
             [`ThrowStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_throw_stmt(&mut self, node: ThrowStmt, ast_path: &mut AstKindPath) -> ThrowStmt {
        <ThrowStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Tpl`.\n\nBy default, this method calls \
             [`Tpl::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_tpl(&mut self, node: Tpl, ast_path: &mut AstKindPath) -> Tpl {
        <Tpl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TplElement`.\n\nBy default, this method calls \
             [`TplElement::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_tpl_element(&mut self, node: TplElement, ast_path: &mut AstKindPath) -> TplElement {
        <TplElement as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < TplElement >`.\n\nBy default, this method calls [`Vec < \
             TplElement >::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_tpl_elements(
        &mut self,
        node: Vec<TplElement>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TplElement> {
        <Vec<TplElement> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TruePlusMinus`.\n\nBy default, this method calls \
             [`TruePlusMinus::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_true_plus_minus(
        &mut self,
        node: TruePlusMinus,
        ast_path: &mut AstKindPath,
    ) -> TruePlusMinus {
        <TruePlusMinus as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TryStmt`.\n\nBy default, this method calls \
             [`TryStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_try_stmt(&mut self, node: TryStmt, ast_path: &mut AstKindPath) -> TryStmt {
        <TryStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsArrayType`.\n\nBy default, this method calls \
             [`TsArrayType::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_array_type(&mut self, node: TsArrayType, ast_path: &mut AstKindPath) -> TsArrayType {
        <TsArrayType as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsAsExpr`.\n\nBy default, this method calls \
             [`TsAsExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_as_expr(&mut self, node: TsAsExpr, ast_path: &mut AstKindPath) -> TsAsExpr {
        <TsAsExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsCallSignatureDecl`.\n\nBy default, this method calls \
             [`TsCallSignatureDecl::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_ts_call_signature_decl(
        &mut self,
        node: TsCallSignatureDecl,
        ast_path: &mut AstKindPath,
    ) -> TsCallSignatureDecl {
        <TsCallSignatureDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsConditionalType`.\n\nBy default, this method calls \
             [`TsConditionalType::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_ts_conditional_type(
        &mut self,
        node: TsConditionalType,
        ast_path: &mut AstKindPath,
    ) -> TsConditionalType {
        <TsConditionalType as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsConstAssertion`.\n\nBy default, this method calls \
             [`TsConstAssertion::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_ts_const_assertion(
        &mut self,
        node: TsConstAssertion,
        ast_path: &mut AstKindPath,
    ) -> TsConstAssertion {
        <TsConstAssertion as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsConstructSignatureDecl`.\n\nBy default, this method calls \
             [`TsConstructSignatureDecl::fold_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn fold_ts_construct_signature_decl(
        &mut self,
        node: TsConstructSignatureDecl,
        ast_path: &mut AstKindPath,
    ) -> TsConstructSignatureDecl {
        <TsConstructSignatureDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsConstructorType`.\n\nBy default, this method calls \
             [`TsConstructorType::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_ts_constructor_type(
        &mut self,
        node: TsConstructorType,
        ast_path: &mut AstKindPath,
    ) -> TsConstructorType {
        <TsConstructorType as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsEntityName`.\n\nBy default, this method calls \
             [`TsEntityName::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_entity_name(
        &mut self,
        node: TsEntityName,
        ast_path: &mut AstKindPath,
    ) -> TsEntityName {
        <TsEntityName as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsEnumDecl`.\n\nBy default, this method calls \
             [`TsEnumDecl::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_enum_decl(&mut self, node: TsEnumDecl, ast_path: &mut AstKindPath) -> TsEnumDecl {
        <TsEnumDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsEnumMember`.\n\nBy default, this method calls \
             [`TsEnumMember::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_enum_member(
        &mut self,
        node: TsEnumMember,
        ast_path: &mut AstKindPath,
    ) -> TsEnumMember {
        <TsEnumMember as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsEnumMemberId`.\n\nBy default, this method calls \
             [`TsEnumMemberId::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_enum_member_id(
        &mut self,
        node: TsEnumMemberId,
        ast_path: &mut AstKindPath,
    ) -> TsEnumMemberId {
        <TsEnumMemberId as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < TsEnumMember >`.\n\nBy default, this method calls [`Vec < \
             TsEnumMember >::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_enum_members(
        &mut self,
        node: Vec<TsEnumMember>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsEnumMember> {
        <Vec<TsEnumMember> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsExportAssignment`.\n\nBy default, this method calls \
             [`TsExportAssignment::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_ts_export_assignment(
        &mut self,
        node: TsExportAssignment,
        ast_path: &mut AstKindPath,
    ) -> TsExportAssignment {
        <TsExportAssignment as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsExprWithTypeArgs`.\n\nBy default, this method calls \
             [`TsExprWithTypeArgs::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_ts_expr_with_type_args(
        &mut self,
        node: TsExprWithTypeArgs,
        ast_path: &mut AstKindPath,
    ) -> TsExprWithTypeArgs {
        <TsExprWithTypeArgs as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < TsExprWithTypeArgs >`.\n\nBy default, this method calls \
             [`Vec < TsExprWithTypeArgs >::fold_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn fold_ts_expr_with_type_argss(
        &mut self,
        node: Vec<TsExprWithTypeArgs>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsExprWithTypeArgs> {
        <Vec<TsExprWithTypeArgs> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsExternalModuleRef`.\n\nBy default, this method calls \
             [`TsExternalModuleRef::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_ts_external_module_ref(
        &mut self,
        node: TsExternalModuleRef,
        ast_path: &mut AstKindPath,
    ) -> TsExternalModuleRef {
        <TsExternalModuleRef as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsFnOrConstructorType`.\n\nBy default, this method calls \
             [`TsFnOrConstructorType::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_ts_fn_or_constructor_type(
        &mut self,
        node: TsFnOrConstructorType,
        ast_path: &mut AstKindPath,
    ) -> TsFnOrConstructorType {
        <TsFnOrConstructorType as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsFnParam`.\n\nBy default, this method calls \
             [`TsFnParam::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_fn_param(&mut self, node: TsFnParam, ast_path: &mut AstKindPath) -> TsFnParam {
        <TsFnParam as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < TsFnParam >`.\n\nBy default, this method calls [`Vec < \
             TsFnParam >::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_fn_params(
        &mut self,
        node: Vec<TsFnParam>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsFnParam> {
        <Vec<TsFnParam> as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsFnType`.\n\nBy default, this method calls \
             [`TsFnType::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_fn_type(&mut self, node: TsFnType, ast_path: &mut AstKindPath) -> TsFnType {
        <TsFnType as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsGetterSignature`.\n\nBy default, this method calls \
             [`TsGetterSignature::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_ts_getter_signature(
        &mut self,
        node: TsGetterSignature,
        ast_path: &mut AstKindPath,
    ) -> TsGetterSignature {
        <TsGetterSignature as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsImportEqualsDecl`.\n\nBy default, this method calls \
             [`TsImportEqualsDecl::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_ts_import_equals_decl(
        &mut self,
        node: TsImportEqualsDecl,
        ast_path: &mut AstKindPath,
    ) -> TsImportEqualsDecl {
        <TsImportEqualsDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsImportType`.\n\nBy default, this method calls \
             [`TsImportType::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_import_type(
        &mut self,
        node: TsImportType,
        ast_path: &mut AstKindPath,
    ) -> TsImportType {
        <TsImportType as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsIndexSignature`.\n\nBy default, this method calls \
             [`TsIndexSignature::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_ts_index_signature(
        &mut self,
        node: TsIndexSignature,
        ast_path: &mut AstKindPath,
    ) -> TsIndexSignature {
        <TsIndexSignature as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsIndexedAccessType`.\n\nBy default, this method calls \
             [`TsIndexedAccessType::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_ts_indexed_access_type(
        &mut self,
        node: TsIndexedAccessType,
        ast_path: &mut AstKindPath,
    ) -> TsIndexedAccessType {
        <TsIndexedAccessType as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsInferType`.\n\nBy default, this method calls \
             [`TsInferType::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_infer_type(&mut self, node: TsInferType, ast_path: &mut AstKindPath) -> TsInferType {
        <TsInferType as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsInstantiation`.\n\nBy default, this method calls \
             [`TsInstantiation::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_instantiation(
        &mut self,
        node: TsInstantiation,
        ast_path: &mut AstKindPath,
    ) -> TsInstantiation {
        <TsInstantiation as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsInterfaceBody`.\n\nBy default, this method calls \
             [`TsInterfaceBody::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_interface_body(
        &mut self,
        node: TsInterfaceBody,
        ast_path: &mut AstKindPath,
    ) -> TsInterfaceBody {
        <TsInterfaceBody as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsInterfaceDecl`.\n\nBy default, this method calls \
             [`TsInterfaceDecl::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_interface_decl(
        &mut self,
        node: TsInterfaceDecl,
        ast_path: &mut AstKindPath,
    ) -> TsInterfaceDecl {
        <TsInterfaceDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsIntersectionType`.\n\nBy default, this method calls \
             [`TsIntersectionType::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_ts_intersection_type(
        &mut self,
        node: TsIntersectionType,
        ast_path: &mut AstKindPath,
    ) -> TsIntersectionType {
        <TsIntersectionType as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsKeywordType`.\n\nBy default, this method calls \
             [`TsKeywordType::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_keyword_type(
        &mut self,
        node: TsKeywordType,
        ast_path: &mut AstKindPath,
    ) -> TsKeywordType {
        <TsKeywordType as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsKeywordTypeKind`.\n\nBy default, this method calls \
             [`TsKeywordTypeKind::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_ts_keyword_type_kind(
        &mut self,
        node: TsKeywordTypeKind,
        ast_path: &mut AstKindPath,
    ) -> TsKeywordTypeKind {
        <TsKeywordTypeKind as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsLit`.\n\nBy default, this method calls \
             [`TsLit::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_lit(&mut self, node: TsLit, ast_path: &mut AstKindPath) -> TsLit {
        <TsLit as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsLitType`.\n\nBy default, this method calls \
             [`TsLitType::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_lit_type(&mut self, node: TsLitType, ast_path: &mut AstKindPath) -> TsLitType {
        <TsLitType as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsMappedType`.\n\nBy default, this method calls \
             [`TsMappedType::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_mapped_type(
        &mut self,
        node: TsMappedType,
        ast_path: &mut AstKindPath,
    ) -> TsMappedType {
        <TsMappedType as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsMethodSignature`.\n\nBy default, this method calls \
             [`TsMethodSignature::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_ts_method_signature(
        &mut self,
        node: TsMethodSignature,
        ast_path: &mut AstKindPath,
    ) -> TsMethodSignature {
        <TsMethodSignature as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsModuleBlock`.\n\nBy default, this method calls \
             [`TsModuleBlock::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_module_block(
        &mut self,
        node: TsModuleBlock,
        ast_path: &mut AstKindPath,
    ) -> TsModuleBlock {
        <TsModuleBlock as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsModuleDecl`.\n\nBy default, this method calls \
             [`TsModuleDecl::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_module_decl(
        &mut self,
        node: TsModuleDecl,
        ast_path: &mut AstKindPath,
    ) -> TsModuleDecl {
        <TsModuleDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsModuleName`.\n\nBy default, this method calls \
             [`TsModuleName::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_module_name(
        &mut self,
        node: TsModuleName,
        ast_path: &mut AstKindPath,
    ) -> TsModuleName {
        <TsModuleName as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsModuleRef`.\n\nBy default, this method calls \
             [`TsModuleRef::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_module_ref(&mut self, node: TsModuleRef, ast_path: &mut AstKindPath) -> TsModuleRef {
        <TsModuleRef as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsNamespaceBody`.\n\nBy default, this method calls \
             [`TsNamespaceBody::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_namespace_body(
        &mut self,
        node: TsNamespaceBody,
        ast_path: &mut AstKindPath,
    ) -> TsNamespaceBody {
        <TsNamespaceBody as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsNamespaceDecl`.\n\nBy default, this method calls \
             [`TsNamespaceDecl::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_namespace_decl(
        &mut self,
        node: TsNamespaceDecl,
        ast_path: &mut AstKindPath,
    ) -> TsNamespaceDecl {
        <TsNamespaceDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsNamespaceExportDecl`.\n\nBy default, this method calls \
             [`TsNamespaceExportDecl::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_ts_namespace_export_decl(
        &mut self,
        node: TsNamespaceExportDecl,
        ast_path: &mut AstKindPath,
    ) -> TsNamespaceExportDecl {
        <TsNamespaceExportDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsNonNullExpr`.\n\nBy default, this method calls \
             [`TsNonNullExpr::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_non_null_expr(
        &mut self,
        node: TsNonNullExpr,
        ast_path: &mut AstKindPath,
    ) -> TsNonNullExpr {
        <TsNonNullExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsOptionalType`.\n\nBy default, this method calls \
             [`TsOptionalType::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_optional_type(
        &mut self,
        node: TsOptionalType,
        ast_path: &mut AstKindPath,
    ) -> TsOptionalType {
        <TsOptionalType as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsParamProp`.\n\nBy default, this method calls \
             [`TsParamProp::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_param_prop(&mut self, node: TsParamProp, ast_path: &mut AstKindPath) -> TsParamProp {
        <TsParamProp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsParamPropParam`.\n\nBy default, this method calls \
             [`TsParamPropParam::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_ts_param_prop_param(
        &mut self,
        node: TsParamPropParam,
        ast_path: &mut AstKindPath,
    ) -> TsParamPropParam {
        <TsParamPropParam as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsParenthesizedType`.\n\nBy default, this method calls \
             [`TsParenthesizedType::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_ts_parenthesized_type(
        &mut self,
        node: TsParenthesizedType,
        ast_path: &mut AstKindPath,
    ) -> TsParenthesizedType {
        <TsParenthesizedType as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsPropertySignature`.\n\nBy default, this method calls \
             [`TsPropertySignature::fold_children_with_ast_path`]. If you want to recurse, you \
             need to call it manually."]
    fn fold_ts_property_signature(
        &mut self,
        node: TsPropertySignature,
        ast_path: &mut AstKindPath,
    ) -> TsPropertySignature {
        <TsPropertySignature as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsQualifiedName`.\n\nBy default, this method calls \
             [`TsQualifiedName::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_qualified_name(
        &mut self,
        node: TsQualifiedName,
        ast_path: &mut AstKindPath,
    ) -> TsQualifiedName {
        <TsQualifiedName as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsRestType`.\n\nBy default, this method calls \
             [`TsRestType::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_rest_type(&mut self, node: TsRestType, ast_path: &mut AstKindPath) -> TsRestType {
        <TsRestType as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsSatisfiesExpr`.\n\nBy default, this method calls \
             [`TsSatisfiesExpr::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_satisfies_expr(
        &mut self,
        node: TsSatisfiesExpr,
        ast_path: &mut AstKindPath,
    ) -> TsSatisfiesExpr {
        <TsSatisfiesExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsSetterSignature`.\n\nBy default, this method calls \
             [`TsSetterSignature::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_ts_setter_signature(
        &mut self,
        node: TsSetterSignature,
        ast_path: &mut AstKindPath,
    ) -> TsSetterSignature {
        <TsSetterSignature as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsThisType`.\n\nBy default, this method calls \
             [`TsThisType::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_this_type(&mut self, node: TsThisType, ast_path: &mut AstKindPath) -> TsThisType {
        <TsThisType as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsThisTypeOrIdent`.\n\nBy default, this method calls \
             [`TsThisTypeOrIdent::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_ts_this_type_or_ident(
        &mut self,
        node: TsThisTypeOrIdent,
        ast_path: &mut AstKindPath,
    ) -> TsThisTypeOrIdent {
        <TsThisTypeOrIdent as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTplLitType`.\n\nBy default, this method calls \
             [`TsTplLitType::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_tpl_lit_type(
        &mut self,
        node: TsTplLitType,
        ast_path: &mut AstKindPath,
    ) -> TsTplLitType {
        <TsTplLitType as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsTupleElement`.\n\nBy default, this method calls \
             [`TsTupleElement::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_tuple_element(
        &mut self,
        node: TsTupleElement,
        ast_path: &mut AstKindPath,
    ) -> TsTupleElement {
        <TsTupleElement as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < TsTupleElement >`.\n\nBy default, this method calls [`Vec \
             < TsTupleElement >::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_ts_tuple_elements(
        &mut self,
        node: Vec<TsTupleElement>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsTupleElement> {
        <Vec<TsTupleElement> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTupleType`.\n\nBy default, this method calls \
             [`TsTupleType::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_tuple_type(&mut self, node: TsTupleType, ast_path: &mut AstKindPath) -> TsTupleType {
        <TsTupleType as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsType`.\n\nBy default, this method calls \
             [`TsType::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_ts_type(&mut self, node: TsType, ast_path: &mut AstKindPath) -> TsType {
        <TsType as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsTypeAliasDecl`.\n\nBy default, this method calls \
             [`TsTypeAliasDecl::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_type_alias_decl(
        &mut self,
        node: TsTypeAliasDecl,
        ast_path: &mut AstKindPath,
    ) -> TsTypeAliasDecl {
        <TsTypeAliasDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeAnn`.\n\nBy default, this method calls \
             [`TsTypeAnn::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_type_ann(&mut self, node: TsTypeAnn, ast_path: &mut AstKindPath) -> TsTypeAnn {
        <TsTypeAnn as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsTypeAssertion`.\n\nBy default, this method calls \
             [`TsTypeAssertion::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_type_assertion(
        &mut self,
        node: TsTypeAssertion,
        ast_path: &mut AstKindPath,
    ) -> TsTypeAssertion {
        <TsTypeAssertion as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeElement`.\n\nBy default, this method calls \
             [`TsTypeElement::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_type_element(
        &mut self,
        node: TsTypeElement,
        ast_path: &mut AstKindPath,
    ) -> TsTypeElement {
        <TsTypeElement as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < TsTypeElement >`.\n\nBy default, this method calls [`Vec \
             < TsTypeElement >::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_type_elements(
        &mut self,
        node: Vec<TsTypeElement>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsTypeElement> {
        <Vec<TsTypeElement> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeLit`.\n\nBy default, this method calls \
             [`TsTypeLit::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_type_lit(&mut self, node: TsTypeLit, ast_path: &mut AstKindPath) -> TsTypeLit {
        <TsTypeLit as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsTypeOperator`.\n\nBy default, this method calls \
             [`TsTypeOperator::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_type_operator(
        &mut self,
        node: TsTypeOperator,
        ast_path: &mut AstKindPath,
    ) -> TsTypeOperator {
        <TsTypeOperator as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsTypeOperatorOp`.\n\nBy default, this method calls \
             [`TsTypeOperatorOp::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_ts_type_operator_op(
        &mut self,
        node: TsTypeOperatorOp,
        ast_path: &mut AstKindPath,
    ) -> TsTypeOperatorOp {
        <TsTypeOperatorOp as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeParam`.\n\nBy default, this method calls \
             [`TsTypeParam::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_type_param(&mut self, node: TsTypeParam, ast_path: &mut AstKindPath) -> TsTypeParam {
        <TsTypeParam as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsTypeParamDecl`.\n\nBy default, this method calls \
             [`TsTypeParamDecl::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_type_param_decl(
        &mut self,
        node: TsTypeParamDecl,
        ast_path: &mut AstKindPath,
    ) -> TsTypeParamDecl {
        <TsTypeParamDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeParamInstantiation`.\n\nBy default, this method calls \
             [`TsTypeParamInstantiation::fold_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn fold_ts_type_param_instantiation(
        &mut self,
        node: TsTypeParamInstantiation,
        ast_path: &mut AstKindPath,
    ) -> TsTypeParamInstantiation {
        <TsTypeParamInstantiation as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `Vec < TsTypeParam >`.\n\nBy default, this method calls [`Vec < \
             TsTypeParam >::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_type_params(
        &mut self,
        node: Vec<TsTypeParam>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsTypeParam> {
        <Vec<TsTypeParam> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypePredicate`.\n\nBy default, this method calls \
             [`TsTypePredicate::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_type_predicate(
        &mut self,
        node: TsTypePredicate,
        ast_path: &mut AstKindPath,
    ) -> TsTypePredicate {
        <TsTypePredicate as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeQuery`.\n\nBy default, this method calls \
             [`TsTypeQuery::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_type_query(&mut self, node: TsTypeQuery, ast_path: &mut AstKindPath) -> TsTypeQuery {
        <TsTypeQuery as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `TsTypeQueryExpr`.\n\nBy default, this method calls \
             [`TsTypeQueryExpr::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_type_query_expr(
        &mut self,
        node: TsTypeQueryExpr,
        ast_path: &mut AstKindPath,
    ) -> TsTypeQueryExpr {
        <TsTypeQueryExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsTypeRef`.\n\nBy default, this method calls \
             [`TsTypeRef::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_ts_type_ref(&mut self, node: TsTypeRef, ast_path: &mut AstKindPath) -> TsTypeRef {
        <TsTypeRef as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < Box < TsType > >`.\n\nBy default, this method calls [`Vec \
             < Box < TsType > >::fold_children_with_ast_path`]. If you want to recurse, you need \
             to call it manually."]
    fn fold_ts_types(
        &mut self,
        node: Vec<Box<TsType>>,
        ast_path: &mut AstKindPath,
    ) -> Vec<Box<TsType>> {
        <Vec<Box<TsType>> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsUnionOrIntersectionType`.\n\nBy default, this method calls \
             [`TsUnionOrIntersectionType::fold_children_with_ast_path`]. If you want to recurse, \
             you need to call it manually."]
    fn fold_ts_union_or_intersection_type(
        &mut self,
        node: TsUnionOrIntersectionType,
        ast_path: &mut AstKindPath,
    ) -> TsUnionOrIntersectionType {
        <TsUnionOrIntersectionType as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `TsUnionType`.\n\nBy default, this method calls \
             [`TsUnionType::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_ts_union_type(&mut self, node: TsUnionType, ast_path: &mut AstKindPath) -> TsUnionType {
        <TsUnionType as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `UnaryExpr`.\n\nBy default, this method calls \
             [`UnaryExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_unary_expr(&mut self, node: UnaryExpr, ast_path: &mut AstKindPath) -> UnaryExpr {
        <UnaryExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `UnaryOp`.\n\nBy default, this method calls \
             [`UnaryOp::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_unary_op(&mut self, node: UnaryOp, ast_path: &mut AstKindPath) -> UnaryOp {
        <UnaryOp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `UpdateExpr`.\n\nBy default, this method calls \
             [`UpdateExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_update_expr(&mut self, node: UpdateExpr, ast_path: &mut AstKindPath) -> UpdateExpr {
        <UpdateExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `UpdateOp`.\n\nBy default, this method calls \
             [`UpdateOp::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_update_op(&mut self, node: UpdateOp, ast_path: &mut AstKindPath) -> UpdateOp {
        <UpdateOp as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `UsingDecl`.\n\nBy default, this method calls \
             [`UsingDecl::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_using_decl(&mut self, node: UsingDecl, ast_path: &mut AstKindPath) -> UsingDecl {
        <UsingDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `VarDecl`.\n\nBy default, this method calls \
             [`VarDecl::fold_children_with_ast_path`]. If you want to recurse, you need to call it \
             manually."]
    fn fold_var_decl(&mut self, node: VarDecl, ast_path: &mut AstKindPath) -> VarDecl {
        <VarDecl as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `VarDeclKind`.\n\nBy default, this method calls \
             [`VarDeclKind::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_var_decl_kind(&mut self, node: VarDeclKind, ast_path: &mut AstKindPath) -> VarDeclKind {
        <VarDeclKind as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `VarDeclOrExpr`.\n\nBy default, this method calls \
             [`VarDeclOrExpr::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_var_decl_or_expr(
        &mut self,
        node: VarDeclOrExpr,
        ast_path: &mut AstKindPath,
    ) -> VarDeclOrExpr {
        <VarDeclOrExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `VarDeclarator`.\n\nBy default, this method calls \
             [`VarDeclarator::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_var_declarator(
        &mut self,
        node: VarDeclarator,
        ast_path: &mut AstKindPath,
    ) -> VarDeclarator {
        <VarDeclarator as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `Vec < VarDeclarator >`.\n\nBy default, this method calls [`Vec \
             < VarDeclarator >::fold_children_with_ast_path`]. If you want to recurse, you need to \
             call it manually."]
    fn fold_var_declarators(
        &mut self,
        node: Vec<VarDeclarator>,
        ast_path: &mut AstKindPath,
    ) -> Vec<VarDeclarator> {
        <Vec<VarDeclarator> as FoldWithAstPath<Self>>::fold_children_with_ast_path(
            node, self, ast_path,
        )
    }
    #[doc = "Visit a node of type `WhileStmt`.\n\nBy default, this method calls \
             [`WhileStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_while_stmt(&mut self, node: WhileStmt, ast_path: &mut AstKindPath) -> WhileStmt {
        <WhileStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `WithStmt`.\n\nBy default, this method calls \
             [`WithStmt::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_with_stmt(&mut self, node: WithStmt, ast_path: &mut AstKindPath) -> WithStmt {
        <WithStmt as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
    #[doc = "Visit a node of type `YieldExpr`.\n\nBy default, this method calls \
             [`YieldExpr::fold_children_with_ast_path`]. If you want to recurse, you need to call \
             it manually."]
    fn fold_yield_expr(&mut self, node: YieldExpr, ast_path: &mut AstKindPath) -> YieldExpr {
        <YieldExpr as FoldWithAstPath<Self>>::fold_children_with_ast_path(node, self, ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> FoldAstPath for &mut V
where
    V: ?Sized + FoldAstPath,
{
    fn fold_accessibility(
        &mut self,
        node: Accessibility,
        ast_path: &mut AstKindPath,
    ) -> Accessibility {
        FoldAstPath::fold_accessibility(&mut **self, node, ast_path)
    }

    fn fold_array_lit(&mut self, node: ArrayLit, ast_path: &mut AstKindPath) -> ArrayLit {
        FoldAstPath::fold_array_lit(&mut **self, node, ast_path)
    }

    fn fold_array_pat(&mut self, node: ArrayPat, ast_path: &mut AstKindPath) -> ArrayPat {
        FoldAstPath::fold_array_pat(&mut **self, node, ast_path)
    }

    fn fold_arrow_expr(&mut self, node: ArrowExpr, ast_path: &mut AstKindPath) -> ArrowExpr {
        FoldAstPath::fold_arrow_expr(&mut **self, node, ast_path)
    }

    fn fold_assign_expr(&mut self, node: AssignExpr, ast_path: &mut AstKindPath) -> AssignExpr {
        FoldAstPath::fold_assign_expr(&mut **self, node, ast_path)
    }

    fn fold_assign_op(&mut self, node: AssignOp, ast_path: &mut AstKindPath) -> AssignOp {
        FoldAstPath::fold_assign_op(&mut **self, node, ast_path)
    }

    fn fold_assign_pat(&mut self, node: AssignPat, ast_path: &mut AstKindPath) -> AssignPat {
        FoldAstPath::fold_assign_pat(&mut **self, node, ast_path)
    }

    fn fold_assign_pat_prop(
        &mut self,
        node: AssignPatProp,
        ast_path: &mut AstKindPath,
    ) -> AssignPatProp {
        FoldAstPath::fold_assign_pat_prop(&mut **self, node, ast_path)
    }

    fn fold_assign_prop(&mut self, node: AssignProp, ast_path: &mut AstKindPath) -> AssignProp {
        FoldAstPath::fold_assign_prop(&mut **self, node, ast_path)
    }

    fn fold_assign_target(
        &mut self,
        node: AssignTarget,
        ast_path: &mut AstKindPath,
    ) -> AssignTarget {
        FoldAstPath::fold_assign_target(&mut **self, node, ast_path)
    }

    fn fold_assign_target_pat(
        &mut self,
        node: AssignTargetPat,
        ast_path: &mut AstKindPath,
    ) -> AssignTargetPat {
        FoldAstPath::fold_assign_target_pat(&mut **self, node, ast_path)
    }

    fn fold_atom(&mut self, node: swc_atoms::Atom, ast_path: &mut AstKindPath) -> swc_atoms::Atom {
        FoldAstPath::fold_atom(&mut **self, node, ast_path)
    }

    fn fold_auto_accessor(
        &mut self,
        node: AutoAccessor,
        ast_path: &mut AstKindPath,
    ) -> AutoAccessor {
        FoldAstPath::fold_auto_accessor(&mut **self, node, ast_path)
    }

    fn fold_await_expr(&mut self, node: AwaitExpr, ast_path: &mut AstKindPath) -> AwaitExpr {
        FoldAstPath::fold_await_expr(&mut **self, node, ast_path)
    }

    fn fold_big_int(&mut self, node: BigInt, ast_path: &mut AstKindPath) -> BigInt {
        FoldAstPath::fold_big_int(&mut **self, node, ast_path)
    }

    fn fold_big_int_value(&mut self, node: BigIntValue, ast_path: &mut AstKindPath) -> BigIntValue {
        FoldAstPath::fold_big_int_value(&mut **self, node, ast_path)
    }

    fn fold_bin_expr(&mut self, node: BinExpr, ast_path: &mut AstKindPath) -> BinExpr {
        FoldAstPath::fold_bin_expr(&mut **self, node, ast_path)
    }

    fn fold_binary_op(&mut self, node: BinaryOp, ast_path: &mut AstKindPath) -> BinaryOp {
        FoldAstPath::fold_binary_op(&mut **self, node, ast_path)
    }

    fn fold_binding_ident(
        &mut self,
        node: BindingIdent,
        ast_path: &mut AstKindPath,
    ) -> BindingIdent {
        FoldAstPath::fold_binding_ident(&mut **self, node, ast_path)
    }

    fn fold_block_stmt(&mut self, node: BlockStmt, ast_path: &mut AstKindPath) -> BlockStmt {
        FoldAstPath::fold_block_stmt(&mut **self, node, ast_path)
    }

    fn fold_block_stmt_or_expr(
        &mut self,
        node: BlockStmtOrExpr,
        ast_path: &mut AstKindPath,
    ) -> BlockStmtOrExpr {
        FoldAstPath::fold_block_stmt_or_expr(&mut **self, node, ast_path)
    }

    fn fold_bool(&mut self, node: Bool, ast_path: &mut AstKindPath) -> Bool {
        FoldAstPath::fold_bool(&mut **self, node, ast_path)
    }

    fn fold_break_stmt(&mut self, node: BreakStmt, ast_path: &mut AstKindPath) -> BreakStmt {
        FoldAstPath::fold_break_stmt(&mut **self, node, ast_path)
    }

    fn fold_call_expr(&mut self, node: CallExpr, ast_path: &mut AstKindPath) -> CallExpr {
        FoldAstPath::fold_call_expr(&mut **self, node, ast_path)
    }

    fn fold_callee(&mut self, node: Callee, ast_path: &mut AstKindPath) -> Callee {
        FoldAstPath::fold_callee(&mut **self, node, ast_path)
    }

    fn fold_catch_clause(&mut self, node: CatchClause, ast_path: &mut AstKindPath) -> CatchClause {
        FoldAstPath::fold_catch_clause(&mut **self, node, ast_path)
    }

    fn fold_class(&mut self, node: Class, ast_path: &mut AstKindPath) -> Class {
        FoldAstPath::fold_class(&mut **self, node, ast_path)
    }

    fn fold_class_decl(&mut self, node: ClassDecl, ast_path: &mut AstKindPath) -> ClassDecl {
        FoldAstPath::fold_class_decl(&mut **self, node, ast_path)
    }

    fn fold_class_expr(&mut self, node: ClassExpr, ast_path: &mut AstKindPath) -> ClassExpr {
        FoldAstPath::fold_class_expr(&mut **self, node, ast_path)
    }

    fn fold_class_member(&mut self, node: ClassMember, ast_path: &mut AstKindPath) -> ClassMember {
        FoldAstPath::fold_class_member(&mut **self, node, ast_path)
    }

    fn fold_class_members(
        &mut self,
        node: Vec<ClassMember>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ClassMember> {
        FoldAstPath::fold_class_members(&mut **self, node, ast_path)
    }

    fn fold_class_method(&mut self, node: ClassMethod, ast_path: &mut AstKindPath) -> ClassMethod {
        FoldAstPath::fold_class_method(&mut **self, node, ast_path)
    }

    fn fold_class_prop(&mut self, node: ClassProp, ast_path: &mut AstKindPath) -> ClassProp {
        FoldAstPath::fold_class_prop(&mut **self, node, ast_path)
    }

    fn fold_computed_prop_name(
        &mut self,
        node: ComputedPropName,
        ast_path: &mut AstKindPath,
    ) -> ComputedPropName {
        FoldAstPath::fold_computed_prop_name(&mut **self, node, ast_path)
    }

    fn fold_cond_expr(&mut self, node: CondExpr, ast_path: &mut AstKindPath) -> CondExpr {
        FoldAstPath::fold_cond_expr(&mut **self, node, ast_path)
    }

    fn fold_constructor(&mut self, node: Constructor, ast_path: &mut AstKindPath) -> Constructor {
        FoldAstPath::fold_constructor(&mut **self, node, ast_path)
    }

    fn fold_continue_stmt(
        &mut self,
        node: ContinueStmt,
        ast_path: &mut AstKindPath,
    ) -> ContinueStmt {
        FoldAstPath::fold_continue_stmt(&mut **self, node, ast_path)
    }

    fn fold_debugger_stmt(
        &mut self,
        node: DebuggerStmt,
        ast_path: &mut AstKindPath,
    ) -> DebuggerStmt {
        FoldAstPath::fold_debugger_stmt(&mut **self, node, ast_path)
    }

    fn fold_decl(&mut self, node: Decl, ast_path: &mut AstKindPath) -> Decl {
        FoldAstPath::fold_decl(&mut **self, node, ast_path)
    }

    fn fold_decorator(&mut self, node: Decorator, ast_path: &mut AstKindPath) -> Decorator {
        FoldAstPath::fold_decorator(&mut **self, node, ast_path)
    }

    fn fold_decorators(
        &mut self,
        node: Vec<Decorator>,
        ast_path: &mut AstKindPath,
    ) -> Vec<Decorator> {
        FoldAstPath::fold_decorators(&mut **self, node, ast_path)
    }

    fn fold_default_decl(&mut self, node: DefaultDecl, ast_path: &mut AstKindPath) -> DefaultDecl {
        FoldAstPath::fold_default_decl(&mut **self, node, ast_path)
    }

    fn fold_do_while_stmt(&mut self, node: DoWhileStmt, ast_path: &mut AstKindPath) -> DoWhileStmt {
        FoldAstPath::fold_do_while_stmt(&mut **self, node, ast_path)
    }

    fn fold_empty_stmt(&mut self, node: EmptyStmt, ast_path: &mut AstKindPath) -> EmptyStmt {
        FoldAstPath::fold_empty_stmt(&mut **self, node, ast_path)
    }

    fn fold_es_version(&mut self, node: EsVersion, ast_path: &mut AstKindPath) -> EsVersion {
        FoldAstPath::fold_es_version(&mut **self, node, ast_path)
    }

    fn fold_export_all(&mut self, node: ExportAll, ast_path: &mut AstKindPath) -> ExportAll {
        FoldAstPath::fold_export_all(&mut **self, node, ast_path)
    }

    fn fold_export_decl(&mut self, node: ExportDecl, ast_path: &mut AstKindPath) -> ExportDecl {
        FoldAstPath::fold_export_decl(&mut **self, node, ast_path)
    }

    fn fold_export_default_decl(
        &mut self,
        node: ExportDefaultDecl,
        ast_path: &mut AstKindPath,
    ) -> ExportDefaultDecl {
        FoldAstPath::fold_export_default_decl(&mut **self, node, ast_path)
    }

    fn fold_export_default_expr(
        &mut self,
        node: ExportDefaultExpr,
        ast_path: &mut AstKindPath,
    ) -> ExportDefaultExpr {
        FoldAstPath::fold_export_default_expr(&mut **self, node, ast_path)
    }

    fn fold_export_default_specifier(
        &mut self,
        node: ExportDefaultSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ExportDefaultSpecifier {
        FoldAstPath::fold_export_default_specifier(&mut **self, node, ast_path)
    }

    fn fold_export_named_specifier(
        &mut self,
        node: ExportNamedSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ExportNamedSpecifier {
        FoldAstPath::fold_export_named_specifier(&mut **self, node, ast_path)
    }

    fn fold_export_namespace_specifier(
        &mut self,
        node: ExportNamespaceSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ExportNamespaceSpecifier {
        FoldAstPath::fold_export_namespace_specifier(&mut **self, node, ast_path)
    }

    fn fold_export_specifier(
        &mut self,
        node: ExportSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ExportSpecifier {
        FoldAstPath::fold_export_specifier(&mut **self, node, ast_path)
    }

    fn fold_export_specifiers(
        &mut self,
        node: Vec<ExportSpecifier>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ExportSpecifier> {
        FoldAstPath::fold_export_specifiers(&mut **self, node, ast_path)
    }

    fn fold_expr(&mut self, node: Expr, ast_path: &mut AstKindPath) -> Expr {
        FoldAstPath::fold_expr(&mut **self, node, ast_path)
    }

    fn fold_expr_or_spread(
        &mut self,
        node: ExprOrSpread,
        ast_path: &mut AstKindPath,
    ) -> ExprOrSpread {
        FoldAstPath::fold_expr_or_spread(&mut **self, node, ast_path)
    }

    fn fold_expr_or_spreads(
        &mut self,
        node: Vec<ExprOrSpread>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ExprOrSpread> {
        FoldAstPath::fold_expr_or_spreads(&mut **self, node, ast_path)
    }

    fn fold_expr_stmt(&mut self, node: ExprStmt, ast_path: &mut AstKindPath) -> ExprStmt {
        FoldAstPath::fold_expr_stmt(&mut **self, node, ast_path)
    }

    fn fold_exprs(&mut self, node: Vec<Box<Expr>>, ast_path: &mut AstKindPath) -> Vec<Box<Expr>> {
        FoldAstPath::fold_exprs(&mut **self, node, ast_path)
    }

    fn fold_fn_decl(&mut self, node: FnDecl, ast_path: &mut AstKindPath) -> FnDecl {
        FoldAstPath::fold_fn_decl(&mut **self, node, ast_path)
    }

    fn fold_fn_expr(&mut self, node: FnExpr, ast_path: &mut AstKindPath) -> FnExpr {
        FoldAstPath::fold_fn_expr(&mut **self, node, ast_path)
    }

    fn fold_for_head(&mut self, node: ForHead, ast_path: &mut AstKindPath) -> ForHead {
        FoldAstPath::fold_for_head(&mut **self, node, ast_path)
    }

    fn fold_for_in_stmt(&mut self, node: ForInStmt, ast_path: &mut AstKindPath) -> ForInStmt {
        FoldAstPath::fold_for_in_stmt(&mut **self, node, ast_path)
    }

    fn fold_for_of_stmt(&mut self, node: ForOfStmt, ast_path: &mut AstKindPath) -> ForOfStmt {
        FoldAstPath::fold_for_of_stmt(&mut **self, node, ast_path)
    }

    fn fold_for_stmt(&mut self, node: ForStmt, ast_path: &mut AstKindPath) -> ForStmt {
        FoldAstPath::fold_for_stmt(&mut **self, node, ast_path)
    }

    fn fold_function(&mut self, node: Function, ast_path: &mut AstKindPath) -> Function {
        FoldAstPath::fold_function(&mut **self, node, ast_path)
    }

    fn fold_getter_prop(&mut self, node: GetterProp, ast_path: &mut AstKindPath) -> GetterProp {
        FoldAstPath::fold_getter_prop(&mut **self, node, ast_path)
    }

    fn fold_ident(&mut self, node: Ident, ast_path: &mut AstKindPath) -> Ident {
        FoldAstPath::fold_ident(&mut **self, node, ast_path)
    }

    fn fold_ident_name(&mut self, node: IdentName, ast_path: &mut AstKindPath) -> IdentName {
        FoldAstPath::fold_ident_name(&mut **self, node, ast_path)
    }

    fn fold_if_stmt(&mut self, node: IfStmt, ast_path: &mut AstKindPath) -> IfStmt {
        FoldAstPath::fold_if_stmt(&mut **self, node, ast_path)
    }

    fn fold_import(&mut self, node: Import, ast_path: &mut AstKindPath) -> Import {
        FoldAstPath::fold_import(&mut **self, node, ast_path)
    }

    fn fold_import_decl(&mut self, node: ImportDecl, ast_path: &mut AstKindPath) -> ImportDecl {
        FoldAstPath::fold_import_decl(&mut **self, node, ast_path)
    }

    fn fold_import_default_specifier(
        &mut self,
        node: ImportDefaultSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ImportDefaultSpecifier {
        FoldAstPath::fold_import_default_specifier(&mut **self, node, ast_path)
    }

    fn fold_import_named_specifier(
        &mut self,
        node: ImportNamedSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ImportNamedSpecifier {
        FoldAstPath::fold_import_named_specifier(&mut **self, node, ast_path)
    }

    fn fold_import_phase(&mut self, node: ImportPhase, ast_path: &mut AstKindPath) -> ImportPhase {
        FoldAstPath::fold_import_phase(&mut **self, node, ast_path)
    }

    fn fold_import_specifier(
        &mut self,
        node: ImportSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ImportSpecifier {
        FoldAstPath::fold_import_specifier(&mut **self, node, ast_path)
    }

    fn fold_import_specifiers(
        &mut self,
        node: Vec<ImportSpecifier>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ImportSpecifier> {
        FoldAstPath::fold_import_specifiers(&mut **self, node, ast_path)
    }

    fn fold_import_star_as_specifier(
        &mut self,
        node: ImportStarAsSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ImportStarAsSpecifier {
        FoldAstPath::fold_import_star_as_specifier(&mut **self, node, ast_path)
    }

    fn fold_import_with(&mut self, node: ImportWith, ast_path: &mut AstKindPath) -> ImportWith {
        FoldAstPath::fold_import_with(&mut **self, node, ast_path)
    }

    fn fold_import_with_item(
        &mut self,
        node: ImportWithItem,
        ast_path: &mut AstKindPath,
    ) -> ImportWithItem {
        FoldAstPath::fold_import_with_item(&mut **self, node, ast_path)
    }

    fn fold_import_with_items(
        &mut self,
        node: Vec<ImportWithItem>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ImportWithItem> {
        FoldAstPath::fold_import_with_items(&mut **self, node, ast_path)
    }

    fn fold_invalid(&mut self, node: Invalid, ast_path: &mut AstKindPath) -> Invalid {
        FoldAstPath::fold_invalid(&mut **self, node, ast_path)
    }

    fn fold_jsx_attr(&mut self, node: JSXAttr, ast_path: &mut AstKindPath) -> JSXAttr {
        FoldAstPath::fold_jsx_attr(&mut **self, node, ast_path)
    }

    fn fold_jsx_attr_name(&mut self, node: JSXAttrName, ast_path: &mut AstKindPath) -> JSXAttrName {
        FoldAstPath::fold_jsx_attr_name(&mut **self, node, ast_path)
    }

    fn fold_jsx_attr_or_spread(
        &mut self,
        node: JSXAttrOrSpread,
        ast_path: &mut AstKindPath,
    ) -> JSXAttrOrSpread {
        FoldAstPath::fold_jsx_attr_or_spread(&mut **self, node, ast_path)
    }

    fn fold_jsx_attr_or_spreads(
        &mut self,
        node: Vec<JSXAttrOrSpread>,
        ast_path: &mut AstKindPath,
    ) -> Vec<JSXAttrOrSpread> {
        FoldAstPath::fold_jsx_attr_or_spreads(&mut **self, node, ast_path)
    }

    fn fold_jsx_attr_value(
        &mut self,
        node: JSXAttrValue,
        ast_path: &mut AstKindPath,
    ) -> JSXAttrValue {
        FoldAstPath::fold_jsx_attr_value(&mut **self, node, ast_path)
    }

    fn fold_jsx_closing_element(
        &mut self,
        node: JSXClosingElement,
        ast_path: &mut AstKindPath,
    ) -> JSXClosingElement {
        FoldAstPath::fold_jsx_closing_element(&mut **self, node, ast_path)
    }

    fn fold_jsx_closing_fragment(
        &mut self,
        node: JSXClosingFragment,
        ast_path: &mut AstKindPath,
    ) -> JSXClosingFragment {
        FoldAstPath::fold_jsx_closing_fragment(&mut **self, node, ast_path)
    }

    fn fold_jsx_element(&mut self, node: JSXElement, ast_path: &mut AstKindPath) -> JSXElement {
        FoldAstPath::fold_jsx_element(&mut **self, node, ast_path)
    }

    fn fold_jsx_element_child(
        &mut self,
        node: JSXElementChild,
        ast_path: &mut AstKindPath,
    ) -> JSXElementChild {
        FoldAstPath::fold_jsx_element_child(&mut **self, node, ast_path)
    }

    fn fold_jsx_element_childs(
        &mut self,
        node: Vec<JSXElementChild>,
        ast_path: &mut AstKindPath,
    ) -> Vec<JSXElementChild> {
        FoldAstPath::fold_jsx_element_childs(&mut **self, node, ast_path)
    }

    fn fold_jsx_element_name(
        &mut self,
        node: JSXElementName,
        ast_path: &mut AstKindPath,
    ) -> JSXElementName {
        FoldAstPath::fold_jsx_element_name(&mut **self, node, ast_path)
    }

    fn fold_jsx_empty_expr(
        &mut self,
        node: JSXEmptyExpr,
        ast_path: &mut AstKindPath,
    ) -> JSXEmptyExpr {
        FoldAstPath::fold_jsx_empty_expr(&mut **self, node, ast_path)
    }

    fn fold_jsx_expr(&mut self, node: JSXExpr, ast_path: &mut AstKindPath) -> JSXExpr {
        FoldAstPath::fold_jsx_expr(&mut **self, node, ast_path)
    }

    fn fold_jsx_expr_container(
        &mut self,
        node: JSXExprContainer,
        ast_path: &mut AstKindPath,
    ) -> JSXExprContainer {
        FoldAstPath::fold_jsx_expr_container(&mut **self, node, ast_path)
    }

    fn fold_jsx_fragment(&mut self, node: JSXFragment, ast_path: &mut AstKindPath) -> JSXFragment {
        FoldAstPath::fold_jsx_fragment(&mut **self, node, ast_path)
    }

    fn fold_jsx_member_expr(
        &mut self,
        node: JSXMemberExpr,
        ast_path: &mut AstKindPath,
    ) -> JSXMemberExpr {
        FoldAstPath::fold_jsx_member_expr(&mut **self, node, ast_path)
    }

    fn fold_jsx_namespaced_name(
        &mut self,
        node: JSXNamespacedName,
        ast_path: &mut AstKindPath,
    ) -> JSXNamespacedName {
        FoldAstPath::fold_jsx_namespaced_name(&mut **self, node, ast_path)
    }

    fn fold_jsx_object(&mut self, node: JSXObject, ast_path: &mut AstKindPath) -> JSXObject {
        FoldAstPath::fold_jsx_object(&mut **self, node, ast_path)
    }

    fn fold_jsx_opening_element(
        &mut self,
        node: JSXOpeningElement,
        ast_path: &mut AstKindPath,
    ) -> JSXOpeningElement {
        FoldAstPath::fold_jsx_opening_element(&mut **self, node, ast_path)
    }

    fn fold_jsx_opening_fragment(
        &mut self,
        node: JSXOpeningFragment,
        ast_path: &mut AstKindPath,
    ) -> JSXOpeningFragment {
        FoldAstPath::fold_jsx_opening_fragment(&mut **self, node, ast_path)
    }

    fn fold_jsx_spread_child(
        &mut self,
        node: JSXSpreadChild,
        ast_path: &mut AstKindPath,
    ) -> JSXSpreadChild {
        FoldAstPath::fold_jsx_spread_child(&mut **self, node, ast_path)
    }

    fn fold_jsx_text(&mut self, node: JSXText, ast_path: &mut AstKindPath) -> JSXText {
        FoldAstPath::fold_jsx_text(&mut **self, node, ast_path)
    }

    fn fold_key(&mut self, node: Key, ast_path: &mut AstKindPath) -> Key {
        FoldAstPath::fold_key(&mut **self, node, ast_path)
    }

    fn fold_key_value_pat_prop(
        &mut self,
        node: KeyValuePatProp,
        ast_path: &mut AstKindPath,
    ) -> KeyValuePatProp {
        FoldAstPath::fold_key_value_pat_prop(&mut **self, node, ast_path)
    }

    fn fold_key_value_prop(
        &mut self,
        node: KeyValueProp,
        ast_path: &mut AstKindPath,
    ) -> KeyValueProp {
        FoldAstPath::fold_key_value_prop(&mut **self, node, ast_path)
    }

    fn fold_labeled_stmt(&mut self, node: LabeledStmt, ast_path: &mut AstKindPath) -> LabeledStmt {
        FoldAstPath::fold_labeled_stmt(&mut **self, node, ast_path)
    }

    fn fold_lit(&mut self, node: Lit, ast_path: &mut AstKindPath) -> Lit {
        FoldAstPath::fold_lit(&mut **self, node, ast_path)
    }

    fn fold_member_expr(&mut self, node: MemberExpr, ast_path: &mut AstKindPath) -> MemberExpr {
        FoldAstPath::fold_member_expr(&mut **self, node, ast_path)
    }

    fn fold_member_prop(&mut self, node: MemberProp, ast_path: &mut AstKindPath) -> MemberProp {
        FoldAstPath::fold_member_prop(&mut **self, node, ast_path)
    }

    fn fold_meta_prop_expr(
        &mut self,
        node: MetaPropExpr,
        ast_path: &mut AstKindPath,
    ) -> MetaPropExpr {
        FoldAstPath::fold_meta_prop_expr(&mut **self, node, ast_path)
    }

    fn fold_meta_prop_kind(
        &mut self,
        node: MetaPropKind,
        ast_path: &mut AstKindPath,
    ) -> MetaPropKind {
        FoldAstPath::fold_meta_prop_kind(&mut **self, node, ast_path)
    }

    fn fold_method_kind(&mut self, node: MethodKind, ast_path: &mut AstKindPath) -> MethodKind {
        FoldAstPath::fold_method_kind(&mut **self, node, ast_path)
    }

    fn fold_method_prop(&mut self, node: MethodProp, ast_path: &mut AstKindPath) -> MethodProp {
        FoldAstPath::fold_method_prop(&mut **self, node, ast_path)
    }

    fn fold_module(&mut self, node: Module, ast_path: &mut AstKindPath) -> Module {
        FoldAstPath::fold_module(&mut **self, node, ast_path)
    }

    fn fold_module_decl(&mut self, node: ModuleDecl, ast_path: &mut AstKindPath) -> ModuleDecl {
        FoldAstPath::fold_module_decl(&mut **self, node, ast_path)
    }

    fn fold_module_export_name(
        &mut self,
        node: ModuleExportName,
        ast_path: &mut AstKindPath,
    ) -> ModuleExportName {
        FoldAstPath::fold_module_export_name(&mut **self, node, ast_path)
    }

    fn fold_module_item(&mut self, node: ModuleItem, ast_path: &mut AstKindPath) -> ModuleItem {
        FoldAstPath::fold_module_item(&mut **self, node, ast_path)
    }

    fn fold_module_items(
        &mut self,
        node: Vec<ModuleItem>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ModuleItem> {
        FoldAstPath::fold_module_items(&mut **self, node, ast_path)
    }

    fn fold_named_export(&mut self, node: NamedExport, ast_path: &mut AstKindPath) -> NamedExport {
        FoldAstPath::fold_named_export(&mut **self, node, ast_path)
    }

    fn fold_new_expr(&mut self, node: NewExpr, ast_path: &mut AstKindPath) -> NewExpr {
        FoldAstPath::fold_new_expr(&mut **self, node, ast_path)
    }

    fn fold_null(&mut self, node: Null, ast_path: &mut AstKindPath) -> Null {
        FoldAstPath::fold_null(&mut **self, node, ast_path)
    }

    fn fold_number(&mut self, node: Number, ast_path: &mut AstKindPath) -> Number {
        FoldAstPath::fold_number(&mut **self, node, ast_path)
    }

    fn fold_object_lit(&mut self, node: ObjectLit, ast_path: &mut AstKindPath) -> ObjectLit {
        FoldAstPath::fold_object_lit(&mut **self, node, ast_path)
    }

    fn fold_object_pat(&mut self, node: ObjectPat, ast_path: &mut AstKindPath) -> ObjectPat {
        FoldAstPath::fold_object_pat(&mut **self, node, ast_path)
    }

    fn fold_object_pat_prop(
        &mut self,
        node: ObjectPatProp,
        ast_path: &mut AstKindPath,
    ) -> ObjectPatProp {
        FoldAstPath::fold_object_pat_prop(&mut **self, node, ast_path)
    }

    fn fold_object_pat_props(
        &mut self,
        node: Vec<ObjectPatProp>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ObjectPatProp> {
        FoldAstPath::fold_object_pat_props(&mut **self, node, ast_path)
    }

    fn fold_opt_accessibility(
        &mut self,
        node: Option<Accessibility>,
        ast_path: &mut AstKindPath,
    ) -> Option<Accessibility> {
        FoldAstPath::fold_opt_accessibility(&mut **self, node, ast_path)
    }

    fn fold_opt_atom(
        &mut self,
        node: Option<swc_atoms::Atom>,
        ast_path: &mut AstKindPath,
    ) -> Option<swc_atoms::Atom> {
        FoldAstPath::fold_opt_atom(&mut **self, node, ast_path)
    }

    fn fold_opt_block_stmt(
        &mut self,
        node: Option<BlockStmt>,
        ast_path: &mut AstKindPath,
    ) -> Option<BlockStmt> {
        FoldAstPath::fold_opt_block_stmt(&mut **self, node, ast_path)
    }

    fn fold_opt_call(&mut self, node: OptCall, ast_path: &mut AstKindPath) -> OptCall {
        FoldAstPath::fold_opt_call(&mut **self, node, ast_path)
    }

    fn fold_opt_catch_clause(
        &mut self,
        node: Option<CatchClause>,
        ast_path: &mut AstKindPath,
    ) -> Option<CatchClause> {
        FoldAstPath::fold_opt_catch_clause(&mut **self, node, ast_path)
    }

    fn fold_opt_chain_base(
        &mut self,
        node: OptChainBase,
        ast_path: &mut AstKindPath,
    ) -> OptChainBase {
        FoldAstPath::fold_opt_chain_base(&mut **self, node, ast_path)
    }

    fn fold_opt_chain_expr(
        &mut self,
        node: OptChainExpr,
        ast_path: &mut AstKindPath,
    ) -> OptChainExpr {
        FoldAstPath::fold_opt_chain_expr(&mut **self, node, ast_path)
    }

    fn fold_opt_expr(
        &mut self,
        node: Option<Box<Expr>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<Expr>> {
        FoldAstPath::fold_opt_expr(&mut **self, node, ast_path)
    }

    fn fold_opt_expr_or_spread(
        &mut self,
        node: Option<ExprOrSpread>,
        ast_path: &mut AstKindPath,
    ) -> Option<ExprOrSpread> {
        FoldAstPath::fold_opt_expr_or_spread(&mut **self, node, ast_path)
    }

    fn fold_opt_expr_or_spreads(
        &mut self,
        node: Option<Vec<ExprOrSpread>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Vec<ExprOrSpread>> {
        FoldAstPath::fold_opt_expr_or_spreads(&mut **self, node, ast_path)
    }

    fn fold_opt_ident(&mut self, node: Option<Ident>, ast_path: &mut AstKindPath) -> Option<Ident> {
        FoldAstPath::fold_opt_ident(&mut **self, node, ast_path)
    }

    fn fold_opt_jsx_attr_value(
        &mut self,
        node: Option<JSXAttrValue>,
        ast_path: &mut AstKindPath,
    ) -> Option<JSXAttrValue> {
        FoldAstPath::fold_opt_jsx_attr_value(&mut **self, node, ast_path)
    }

    fn fold_opt_jsx_closing_element(
        &mut self,
        node: Option<JSXClosingElement>,
        ast_path: &mut AstKindPath,
    ) -> Option<JSXClosingElement> {
        FoldAstPath::fold_opt_jsx_closing_element(&mut **self, node, ast_path)
    }

    fn fold_opt_module_export_name(
        &mut self,
        node: Option<ModuleExportName>,
        ast_path: &mut AstKindPath,
    ) -> Option<ModuleExportName> {
        FoldAstPath::fold_opt_module_export_name(&mut **self, node, ast_path)
    }

    fn fold_opt_module_items(
        &mut self,
        node: Option<Vec<ModuleItem>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Vec<ModuleItem>> {
        FoldAstPath::fold_opt_module_items(&mut **self, node, ast_path)
    }

    fn fold_opt_object_lit(
        &mut self,
        node: Option<Box<ObjectLit>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<ObjectLit>> {
        FoldAstPath::fold_opt_object_lit(&mut **self, node, ast_path)
    }

    fn fold_opt_pat(&mut self, node: Option<Pat>, ast_path: &mut AstKindPath) -> Option<Pat> {
        FoldAstPath::fold_opt_pat(&mut **self, node, ast_path)
    }

    fn fold_opt_span(
        &mut self,
        node: Option<swc_common::Span>,
        ast_path: &mut AstKindPath,
    ) -> Option<swc_common::Span> {
        FoldAstPath::fold_opt_span(&mut **self, node, ast_path)
    }

    fn fold_opt_stmt(
        &mut self,
        node: Option<Box<Stmt>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<Stmt>> {
        FoldAstPath::fold_opt_stmt(&mut **self, node, ast_path)
    }

    fn fold_opt_str(
        &mut self,
        node: Option<Box<Str>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<Str>> {
        FoldAstPath::fold_opt_str(&mut **self, node, ast_path)
    }

    fn fold_opt_true_plus_minus(
        &mut self,
        node: Option<TruePlusMinus>,
        ast_path: &mut AstKindPath,
    ) -> Option<TruePlusMinus> {
        FoldAstPath::fold_opt_true_plus_minus(&mut **self, node, ast_path)
    }

    fn fold_opt_ts_entity_name(
        &mut self,
        node: Option<TsEntityName>,
        ast_path: &mut AstKindPath,
    ) -> Option<TsEntityName> {
        FoldAstPath::fold_opt_ts_entity_name(&mut **self, node, ast_path)
    }

    fn fold_opt_ts_namespace_body(
        &mut self,
        node: Option<TsNamespaceBody>,
        ast_path: &mut AstKindPath,
    ) -> Option<TsNamespaceBody> {
        FoldAstPath::fold_opt_ts_namespace_body(&mut **self, node, ast_path)
    }

    fn fold_opt_ts_type(
        &mut self,
        node: Option<Box<TsType>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<TsType>> {
        FoldAstPath::fold_opt_ts_type(&mut **self, node, ast_path)
    }

    fn fold_opt_ts_type_ann(
        &mut self,
        node: Option<Box<TsTypeAnn>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<TsTypeAnn>> {
        FoldAstPath::fold_opt_ts_type_ann(&mut **self, node, ast_path)
    }

    fn fold_opt_ts_type_param_decl(
        &mut self,
        node: Option<Box<TsTypeParamDecl>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<TsTypeParamDecl>> {
        FoldAstPath::fold_opt_ts_type_param_decl(&mut **self, node, ast_path)
    }

    fn fold_opt_ts_type_param_instantiation(
        &mut self,
        node: Option<Box<TsTypeParamInstantiation>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<TsTypeParamInstantiation>> {
        FoldAstPath::fold_opt_ts_type_param_instantiation(&mut **self, node, ast_path)
    }

    fn fold_opt_var_decl_or_expr(
        &mut self,
        node: Option<VarDeclOrExpr>,
        ast_path: &mut AstKindPath,
    ) -> Option<VarDeclOrExpr> {
        FoldAstPath::fold_opt_var_decl_or_expr(&mut **self, node, ast_path)
    }

    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        node: Vec<Option<ExprOrSpread>>,
        ast_path: &mut AstKindPath,
    ) -> Vec<Option<ExprOrSpread>> {
        FoldAstPath::fold_opt_vec_expr_or_spreads(&mut **self, node, ast_path)
    }

    fn fold_opt_vec_pats(
        &mut self,
        node: Vec<Option<Pat>>,
        ast_path: &mut AstKindPath,
    ) -> Vec<Option<Pat>> {
        FoldAstPath::fold_opt_vec_pats(&mut **self, node, ast_path)
    }

    fn fold_param(&mut self, node: Param, ast_path: &mut AstKindPath) -> Param {
        FoldAstPath::fold_param(&mut **self, node, ast_path)
    }

    fn fold_param_or_ts_param_prop(
        &mut self,
        node: ParamOrTsParamProp,
        ast_path: &mut AstKindPath,
    ) -> ParamOrTsParamProp {
        FoldAstPath::fold_param_or_ts_param_prop(&mut **self, node, ast_path)
    }

    fn fold_param_or_ts_param_props(
        &mut self,
        node: Vec<ParamOrTsParamProp>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ParamOrTsParamProp> {
        FoldAstPath::fold_param_or_ts_param_props(&mut **self, node, ast_path)
    }

    fn fold_params(&mut self, node: Vec<Param>, ast_path: &mut AstKindPath) -> Vec<Param> {
        FoldAstPath::fold_params(&mut **self, node, ast_path)
    }

    fn fold_paren_expr(&mut self, node: ParenExpr, ast_path: &mut AstKindPath) -> ParenExpr {
        FoldAstPath::fold_paren_expr(&mut **self, node, ast_path)
    }

    fn fold_pat(&mut self, node: Pat, ast_path: &mut AstKindPath) -> Pat {
        FoldAstPath::fold_pat(&mut **self, node, ast_path)
    }

    fn fold_pats(&mut self, node: Vec<Pat>, ast_path: &mut AstKindPath) -> Vec<Pat> {
        FoldAstPath::fold_pats(&mut **self, node, ast_path)
    }

    fn fold_private_method(
        &mut self,
        node: PrivateMethod,
        ast_path: &mut AstKindPath,
    ) -> PrivateMethod {
        FoldAstPath::fold_private_method(&mut **self, node, ast_path)
    }

    fn fold_private_name(&mut self, node: PrivateName, ast_path: &mut AstKindPath) -> PrivateName {
        FoldAstPath::fold_private_name(&mut **self, node, ast_path)
    }

    fn fold_private_prop(&mut self, node: PrivateProp, ast_path: &mut AstKindPath) -> PrivateProp {
        FoldAstPath::fold_private_prop(&mut **self, node, ast_path)
    }

    fn fold_program(&mut self, node: Program, ast_path: &mut AstKindPath) -> Program {
        FoldAstPath::fold_program(&mut **self, node, ast_path)
    }

    fn fold_prop(&mut self, node: Prop, ast_path: &mut AstKindPath) -> Prop {
        FoldAstPath::fold_prop(&mut **self, node, ast_path)
    }

    fn fold_prop_name(&mut self, node: PropName, ast_path: &mut AstKindPath) -> PropName {
        FoldAstPath::fold_prop_name(&mut **self, node, ast_path)
    }

    fn fold_prop_or_spread(
        &mut self,
        node: PropOrSpread,
        ast_path: &mut AstKindPath,
    ) -> PropOrSpread {
        FoldAstPath::fold_prop_or_spread(&mut **self, node, ast_path)
    }

    fn fold_prop_or_spreads(
        &mut self,
        node: Vec<PropOrSpread>,
        ast_path: &mut AstKindPath,
    ) -> Vec<PropOrSpread> {
        FoldAstPath::fold_prop_or_spreads(&mut **self, node, ast_path)
    }

    fn fold_regex(&mut self, node: Regex, ast_path: &mut AstKindPath) -> Regex {
        FoldAstPath::fold_regex(&mut **self, node, ast_path)
    }

    fn fold_reserved_unused(
        &mut self,
        node: ReservedUnused,
        ast_path: &mut AstKindPath,
    ) -> ReservedUnused {
        FoldAstPath::fold_reserved_unused(&mut **self, node, ast_path)
    }

    fn fold_rest_pat(&mut self, node: RestPat, ast_path: &mut AstKindPath) -> RestPat {
        FoldAstPath::fold_rest_pat(&mut **self, node, ast_path)
    }

    fn fold_return_stmt(&mut self, node: ReturnStmt, ast_path: &mut AstKindPath) -> ReturnStmt {
        FoldAstPath::fold_return_stmt(&mut **self, node, ast_path)
    }

    fn fold_script(&mut self, node: Script, ast_path: &mut AstKindPath) -> Script {
        FoldAstPath::fold_script(&mut **self, node, ast_path)
    }

    fn fold_seq_expr(&mut self, node: SeqExpr, ast_path: &mut AstKindPath) -> SeqExpr {
        FoldAstPath::fold_seq_expr(&mut **self, node, ast_path)
    }

    fn fold_setter_prop(&mut self, node: SetterProp, ast_path: &mut AstKindPath) -> SetterProp {
        FoldAstPath::fold_setter_prop(&mut **self, node, ast_path)
    }

    fn fold_simple_assign_target(
        &mut self,
        node: SimpleAssignTarget,
        ast_path: &mut AstKindPath,
    ) -> SimpleAssignTarget {
        FoldAstPath::fold_simple_assign_target(&mut **self, node, ast_path)
    }

    fn fold_span(
        &mut self,
        node: swc_common::Span,
        ast_path: &mut AstKindPath,
    ) -> swc_common::Span {
        FoldAstPath::fold_span(&mut **self, node, ast_path)
    }

    fn fold_spread_element(
        &mut self,
        node: SpreadElement,
        ast_path: &mut AstKindPath,
    ) -> SpreadElement {
        FoldAstPath::fold_spread_element(&mut **self, node, ast_path)
    }

    fn fold_static_block(&mut self, node: StaticBlock, ast_path: &mut AstKindPath) -> StaticBlock {
        FoldAstPath::fold_static_block(&mut **self, node, ast_path)
    }

    fn fold_stmt(&mut self, node: Stmt, ast_path: &mut AstKindPath) -> Stmt {
        FoldAstPath::fold_stmt(&mut **self, node, ast_path)
    }

    fn fold_stmts(&mut self, node: Vec<Stmt>, ast_path: &mut AstKindPath) -> Vec<Stmt> {
        FoldAstPath::fold_stmts(&mut **self, node, ast_path)
    }

    fn fold_str(&mut self, node: Str, ast_path: &mut AstKindPath) -> Str {
        FoldAstPath::fold_str(&mut **self, node, ast_path)
    }

    fn fold_super(&mut self, node: Super, ast_path: &mut AstKindPath) -> Super {
        FoldAstPath::fold_super(&mut **self, node, ast_path)
    }

    fn fold_super_prop(&mut self, node: SuperProp, ast_path: &mut AstKindPath) -> SuperProp {
        FoldAstPath::fold_super_prop(&mut **self, node, ast_path)
    }

    fn fold_super_prop_expr(
        &mut self,
        node: SuperPropExpr,
        ast_path: &mut AstKindPath,
    ) -> SuperPropExpr {
        FoldAstPath::fold_super_prop_expr(&mut **self, node, ast_path)
    }

    fn fold_switch_case(&mut self, node: SwitchCase, ast_path: &mut AstKindPath) -> SwitchCase {
        FoldAstPath::fold_switch_case(&mut **self, node, ast_path)
    }

    fn fold_switch_cases(
        &mut self,
        node: Vec<SwitchCase>,
        ast_path: &mut AstKindPath,
    ) -> Vec<SwitchCase> {
        FoldAstPath::fold_switch_cases(&mut **self, node, ast_path)
    }

    fn fold_switch_stmt(&mut self, node: SwitchStmt, ast_path: &mut AstKindPath) -> SwitchStmt {
        FoldAstPath::fold_switch_stmt(&mut **self, node, ast_path)
    }

    fn fold_syntax_context(
        &mut self,
        node: swc_common::SyntaxContext,
        ast_path: &mut AstKindPath,
    ) -> swc_common::SyntaxContext {
        FoldAstPath::fold_syntax_context(&mut **self, node, ast_path)
    }

    fn fold_tagged_tpl(&mut self, node: TaggedTpl, ast_path: &mut AstKindPath) -> TaggedTpl {
        FoldAstPath::fold_tagged_tpl(&mut **self, node, ast_path)
    }

    fn fold_this_expr(&mut self, node: ThisExpr, ast_path: &mut AstKindPath) -> ThisExpr {
        FoldAstPath::fold_this_expr(&mut **self, node, ast_path)
    }

    fn fold_throw_stmt(&mut self, node: ThrowStmt, ast_path: &mut AstKindPath) -> ThrowStmt {
        FoldAstPath::fold_throw_stmt(&mut **self, node, ast_path)
    }

    fn fold_tpl(&mut self, node: Tpl, ast_path: &mut AstKindPath) -> Tpl {
        FoldAstPath::fold_tpl(&mut **self, node, ast_path)
    }

    fn fold_tpl_element(&mut self, node: TplElement, ast_path: &mut AstKindPath) -> TplElement {
        FoldAstPath::fold_tpl_element(&mut **self, node, ast_path)
    }

    fn fold_tpl_elements(
        &mut self,
        node: Vec<TplElement>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TplElement> {
        FoldAstPath::fold_tpl_elements(&mut **self, node, ast_path)
    }

    fn fold_true_plus_minus(
        &mut self,
        node: TruePlusMinus,
        ast_path: &mut AstKindPath,
    ) -> TruePlusMinus {
        FoldAstPath::fold_true_plus_minus(&mut **self, node, ast_path)
    }

    fn fold_try_stmt(&mut self, node: TryStmt, ast_path: &mut AstKindPath) -> TryStmt {
        FoldAstPath::fold_try_stmt(&mut **self, node, ast_path)
    }

    fn fold_ts_array_type(&mut self, node: TsArrayType, ast_path: &mut AstKindPath) -> TsArrayType {
        FoldAstPath::fold_ts_array_type(&mut **self, node, ast_path)
    }

    fn fold_ts_as_expr(&mut self, node: TsAsExpr, ast_path: &mut AstKindPath) -> TsAsExpr {
        FoldAstPath::fold_ts_as_expr(&mut **self, node, ast_path)
    }

    fn fold_ts_call_signature_decl(
        &mut self,
        node: TsCallSignatureDecl,
        ast_path: &mut AstKindPath,
    ) -> TsCallSignatureDecl {
        FoldAstPath::fold_ts_call_signature_decl(&mut **self, node, ast_path)
    }

    fn fold_ts_conditional_type(
        &mut self,
        node: TsConditionalType,
        ast_path: &mut AstKindPath,
    ) -> TsConditionalType {
        FoldAstPath::fold_ts_conditional_type(&mut **self, node, ast_path)
    }

    fn fold_ts_const_assertion(
        &mut self,
        node: TsConstAssertion,
        ast_path: &mut AstKindPath,
    ) -> TsConstAssertion {
        FoldAstPath::fold_ts_const_assertion(&mut **self, node, ast_path)
    }

    fn fold_ts_construct_signature_decl(
        &mut self,
        node: TsConstructSignatureDecl,
        ast_path: &mut AstKindPath,
    ) -> TsConstructSignatureDecl {
        FoldAstPath::fold_ts_construct_signature_decl(&mut **self, node, ast_path)
    }

    fn fold_ts_constructor_type(
        &mut self,
        node: TsConstructorType,
        ast_path: &mut AstKindPath,
    ) -> TsConstructorType {
        FoldAstPath::fold_ts_constructor_type(&mut **self, node, ast_path)
    }

    fn fold_ts_entity_name(
        &mut self,
        node: TsEntityName,
        ast_path: &mut AstKindPath,
    ) -> TsEntityName {
        FoldAstPath::fold_ts_entity_name(&mut **self, node, ast_path)
    }

    fn fold_ts_enum_decl(&mut self, node: TsEnumDecl, ast_path: &mut AstKindPath) -> TsEnumDecl {
        FoldAstPath::fold_ts_enum_decl(&mut **self, node, ast_path)
    }

    fn fold_ts_enum_member(
        &mut self,
        node: TsEnumMember,
        ast_path: &mut AstKindPath,
    ) -> TsEnumMember {
        FoldAstPath::fold_ts_enum_member(&mut **self, node, ast_path)
    }

    fn fold_ts_enum_member_id(
        &mut self,
        node: TsEnumMemberId,
        ast_path: &mut AstKindPath,
    ) -> TsEnumMemberId {
        FoldAstPath::fold_ts_enum_member_id(&mut **self, node, ast_path)
    }

    fn fold_ts_enum_members(
        &mut self,
        node: Vec<TsEnumMember>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsEnumMember> {
        FoldAstPath::fold_ts_enum_members(&mut **self, node, ast_path)
    }

    fn fold_ts_export_assignment(
        &mut self,
        node: TsExportAssignment,
        ast_path: &mut AstKindPath,
    ) -> TsExportAssignment {
        FoldAstPath::fold_ts_export_assignment(&mut **self, node, ast_path)
    }

    fn fold_ts_expr_with_type_args(
        &mut self,
        node: TsExprWithTypeArgs,
        ast_path: &mut AstKindPath,
    ) -> TsExprWithTypeArgs {
        FoldAstPath::fold_ts_expr_with_type_args(&mut **self, node, ast_path)
    }

    fn fold_ts_expr_with_type_argss(
        &mut self,
        node: Vec<TsExprWithTypeArgs>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsExprWithTypeArgs> {
        FoldAstPath::fold_ts_expr_with_type_argss(&mut **self, node, ast_path)
    }

    fn fold_ts_external_module_ref(
        &mut self,
        node: TsExternalModuleRef,
        ast_path: &mut AstKindPath,
    ) -> TsExternalModuleRef {
        FoldAstPath::fold_ts_external_module_ref(&mut **self, node, ast_path)
    }

    fn fold_ts_fn_or_constructor_type(
        &mut self,
        node: TsFnOrConstructorType,
        ast_path: &mut AstKindPath,
    ) -> TsFnOrConstructorType {
        FoldAstPath::fold_ts_fn_or_constructor_type(&mut **self, node, ast_path)
    }

    fn fold_ts_fn_param(&mut self, node: TsFnParam, ast_path: &mut AstKindPath) -> TsFnParam {
        FoldAstPath::fold_ts_fn_param(&mut **self, node, ast_path)
    }

    fn fold_ts_fn_params(
        &mut self,
        node: Vec<TsFnParam>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsFnParam> {
        FoldAstPath::fold_ts_fn_params(&mut **self, node, ast_path)
    }

    fn fold_ts_fn_type(&mut self, node: TsFnType, ast_path: &mut AstKindPath) -> TsFnType {
        FoldAstPath::fold_ts_fn_type(&mut **self, node, ast_path)
    }

    fn fold_ts_getter_signature(
        &mut self,
        node: TsGetterSignature,
        ast_path: &mut AstKindPath,
    ) -> TsGetterSignature {
        FoldAstPath::fold_ts_getter_signature(&mut **self, node, ast_path)
    }

    fn fold_ts_import_equals_decl(
        &mut self,
        node: TsImportEqualsDecl,
        ast_path: &mut AstKindPath,
    ) -> TsImportEqualsDecl {
        FoldAstPath::fold_ts_import_equals_decl(&mut **self, node, ast_path)
    }

    fn fold_ts_import_type(
        &mut self,
        node: TsImportType,
        ast_path: &mut AstKindPath,
    ) -> TsImportType {
        FoldAstPath::fold_ts_import_type(&mut **self, node, ast_path)
    }

    fn fold_ts_index_signature(
        &mut self,
        node: TsIndexSignature,
        ast_path: &mut AstKindPath,
    ) -> TsIndexSignature {
        FoldAstPath::fold_ts_index_signature(&mut **self, node, ast_path)
    }

    fn fold_ts_indexed_access_type(
        &mut self,
        node: TsIndexedAccessType,
        ast_path: &mut AstKindPath,
    ) -> TsIndexedAccessType {
        FoldAstPath::fold_ts_indexed_access_type(&mut **self, node, ast_path)
    }

    fn fold_ts_infer_type(&mut self, node: TsInferType, ast_path: &mut AstKindPath) -> TsInferType {
        FoldAstPath::fold_ts_infer_type(&mut **self, node, ast_path)
    }

    fn fold_ts_instantiation(
        &mut self,
        node: TsInstantiation,
        ast_path: &mut AstKindPath,
    ) -> TsInstantiation {
        FoldAstPath::fold_ts_instantiation(&mut **self, node, ast_path)
    }

    fn fold_ts_interface_body(
        &mut self,
        node: TsInterfaceBody,
        ast_path: &mut AstKindPath,
    ) -> TsInterfaceBody {
        FoldAstPath::fold_ts_interface_body(&mut **self, node, ast_path)
    }

    fn fold_ts_interface_decl(
        &mut self,
        node: TsInterfaceDecl,
        ast_path: &mut AstKindPath,
    ) -> TsInterfaceDecl {
        FoldAstPath::fold_ts_interface_decl(&mut **self, node, ast_path)
    }

    fn fold_ts_intersection_type(
        &mut self,
        node: TsIntersectionType,
        ast_path: &mut AstKindPath,
    ) -> TsIntersectionType {
        FoldAstPath::fold_ts_intersection_type(&mut **self, node, ast_path)
    }

    fn fold_ts_keyword_type(
        &mut self,
        node: TsKeywordType,
        ast_path: &mut AstKindPath,
    ) -> TsKeywordType {
        FoldAstPath::fold_ts_keyword_type(&mut **self, node, ast_path)
    }

    fn fold_ts_keyword_type_kind(
        &mut self,
        node: TsKeywordTypeKind,
        ast_path: &mut AstKindPath,
    ) -> TsKeywordTypeKind {
        FoldAstPath::fold_ts_keyword_type_kind(&mut **self, node, ast_path)
    }

    fn fold_ts_lit(&mut self, node: TsLit, ast_path: &mut AstKindPath) -> TsLit {
        FoldAstPath::fold_ts_lit(&mut **self, node, ast_path)
    }

    fn fold_ts_lit_type(&mut self, node: TsLitType, ast_path: &mut AstKindPath) -> TsLitType {
        FoldAstPath::fold_ts_lit_type(&mut **self, node, ast_path)
    }

    fn fold_ts_mapped_type(
        &mut self,
        node: TsMappedType,
        ast_path: &mut AstKindPath,
    ) -> TsMappedType {
        FoldAstPath::fold_ts_mapped_type(&mut **self, node, ast_path)
    }

    fn fold_ts_method_signature(
        &mut self,
        node: TsMethodSignature,
        ast_path: &mut AstKindPath,
    ) -> TsMethodSignature {
        FoldAstPath::fold_ts_method_signature(&mut **self, node, ast_path)
    }

    fn fold_ts_module_block(
        &mut self,
        node: TsModuleBlock,
        ast_path: &mut AstKindPath,
    ) -> TsModuleBlock {
        FoldAstPath::fold_ts_module_block(&mut **self, node, ast_path)
    }

    fn fold_ts_module_decl(
        &mut self,
        node: TsModuleDecl,
        ast_path: &mut AstKindPath,
    ) -> TsModuleDecl {
        FoldAstPath::fold_ts_module_decl(&mut **self, node, ast_path)
    }

    fn fold_ts_module_name(
        &mut self,
        node: TsModuleName,
        ast_path: &mut AstKindPath,
    ) -> TsModuleName {
        FoldAstPath::fold_ts_module_name(&mut **self, node, ast_path)
    }

    fn fold_ts_module_ref(&mut self, node: TsModuleRef, ast_path: &mut AstKindPath) -> TsModuleRef {
        FoldAstPath::fold_ts_module_ref(&mut **self, node, ast_path)
    }

    fn fold_ts_namespace_body(
        &mut self,
        node: TsNamespaceBody,
        ast_path: &mut AstKindPath,
    ) -> TsNamespaceBody {
        FoldAstPath::fold_ts_namespace_body(&mut **self, node, ast_path)
    }

    fn fold_ts_namespace_decl(
        &mut self,
        node: TsNamespaceDecl,
        ast_path: &mut AstKindPath,
    ) -> TsNamespaceDecl {
        FoldAstPath::fold_ts_namespace_decl(&mut **self, node, ast_path)
    }

    fn fold_ts_namespace_export_decl(
        &mut self,
        node: TsNamespaceExportDecl,
        ast_path: &mut AstKindPath,
    ) -> TsNamespaceExportDecl {
        FoldAstPath::fold_ts_namespace_export_decl(&mut **self, node, ast_path)
    }

    fn fold_ts_non_null_expr(
        &mut self,
        node: TsNonNullExpr,
        ast_path: &mut AstKindPath,
    ) -> TsNonNullExpr {
        FoldAstPath::fold_ts_non_null_expr(&mut **self, node, ast_path)
    }

    fn fold_ts_optional_type(
        &mut self,
        node: TsOptionalType,
        ast_path: &mut AstKindPath,
    ) -> TsOptionalType {
        FoldAstPath::fold_ts_optional_type(&mut **self, node, ast_path)
    }

    fn fold_ts_param_prop(&mut self, node: TsParamProp, ast_path: &mut AstKindPath) -> TsParamProp {
        FoldAstPath::fold_ts_param_prop(&mut **self, node, ast_path)
    }

    fn fold_ts_param_prop_param(
        &mut self,
        node: TsParamPropParam,
        ast_path: &mut AstKindPath,
    ) -> TsParamPropParam {
        FoldAstPath::fold_ts_param_prop_param(&mut **self, node, ast_path)
    }

    fn fold_ts_parenthesized_type(
        &mut self,
        node: TsParenthesizedType,
        ast_path: &mut AstKindPath,
    ) -> TsParenthesizedType {
        FoldAstPath::fold_ts_parenthesized_type(&mut **self, node, ast_path)
    }

    fn fold_ts_property_signature(
        &mut self,
        node: TsPropertySignature,
        ast_path: &mut AstKindPath,
    ) -> TsPropertySignature {
        FoldAstPath::fold_ts_property_signature(&mut **self, node, ast_path)
    }

    fn fold_ts_qualified_name(
        &mut self,
        node: TsQualifiedName,
        ast_path: &mut AstKindPath,
    ) -> TsQualifiedName {
        FoldAstPath::fold_ts_qualified_name(&mut **self, node, ast_path)
    }

    fn fold_ts_rest_type(&mut self, node: TsRestType, ast_path: &mut AstKindPath) -> TsRestType {
        FoldAstPath::fold_ts_rest_type(&mut **self, node, ast_path)
    }

    fn fold_ts_satisfies_expr(
        &mut self,
        node: TsSatisfiesExpr,
        ast_path: &mut AstKindPath,
    ) -> TsSatisfiesExpr {
        FoldAstPath::fold_ts_satisfies_expr(&mut **self, node, ast_path)
    }

    fn fold_ts_setter_signature(
        &mut self,
        node: TsSetterSignature,
        ast_path: &mut AstKindPath,
    ) -> TsSetterSignature {
        FoldAstPath::fold_ts_setter_signature(&mut **self, node, ast_path)
    }

    fn fold_ts_this_type(&mut self, node: TsThisType, ast_path: &mut AstKindPath) -> TsThisType {
        FoldAstPath::fold_ts_this_type(&mut **self, node, ast_path)
    }

    fn fold_ts_this_type_or_ident(
        &mut self,
        node: TsThisTypeOrIdent,
        ast_path: &mut AstKindPath,
    ) -> TsThisTypeOrIdent {
        FoldAstPath::fold_ts_this_type_or_ident(&mut **self, node, ast_path)
    }

    fn fold_ts_tpl_lit_type(
        &mut self,
        node: TsTplLitType,
        ast_path: &mut AstKindPath,
    ) -> TsTplLitType {
        FoldAstPath::fold_ts_tpl_lit_type(&mut **self, node, ast_path)
    }

    fn fold_ts_tuple_element(
        &mut self,
        node: TsTupleElement,
        ast_path: &mut AstKindPath,
    ) -> TsTupleElement {
        FoldAstPath::fold_ts_tuple_element(&mut **self, node, ast_path)
    }

    fn fold_ts_tuple_elements(
        &mut self,
        node: Vec<TsTupleElement>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsTupleElement> {
        FoldAstPath::fold_ts_tuple_elements(&mut **self, node, ast_path)
    }

    fn fold_ts_tuple_type(&mut self, node: TsTupleType, ast_path: &mut AstKindPath) -> TsTupleType {
        FoldAstPath::fold_ts_tuple_type(&mut **self, node, ast_path)
    }

    fn fold_ts_type(&mut self, node: TsType, ast_path: &mut AstKindPath) -> TsType {
        FoldAstPath::fold_ts_type(&mut **self, node, ast_path)
    }

    fn fold_ts_type_alias_decl(
        &mut self,
        node: TsTypeAliasDecl,
        ast_path: &mut AstKindPath,
    ) -> TsTypeAliasDecl {
        FoldAstPath::fold_ts_type_alias_decl(&mut **self, node, ast_path)
    }

    fn fold_ts_type_ann(&mut self, node: TsTypeAnn, ast_path: &mut AstKindPath) -> TsTypeAnn {
        FoldAstPath::fold_ts_type_ann(&mut **self, node, ast_path)
    }

    fn fold_ts_type_assertion(
        &mut self,
        node: TsTypeAssertion,
        ast_path: &mut AstKindPath,
    ) -> TsTypeAssertion {
        FoldAstPath::fold_ts_type_assertion(&mut **self, node, ast_path)
    }

    fn fold_ts_type_element(
        &mut self,
        node: TsTypeElement,
        ast_path: &mut AstKindPath,
    ) -> TsTypeElement {
        FoldAstPath::fold_ts_type_element(&mut **self, node, ast_path)
    }

    fn fold_ts_type_elements(
        &mut self,
        node: Vec<TsTypeElement>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsTypeElement> {
        FoldAstPath::fold_ts_type_elements(&mut **self, node, ast_path)
    }

    fn fold_ts_type_lit(&mut self, node: TsTypeLit, ast_path: &mut AstKindPath) -> TsTypeLit {
        FoldAstPath::fold_ts_type_lit(&mut **self, node, ast_path)
    }

    fn fold_ts_type_operator(
        &mut self,
        node: TsTypeOperator,
        ast_path: &mut AstKindPath,
    ) -> TsTypeOperator {
        FoldAstPath::fold_ts_type_operator(&mut **self, node, ast_path)
    }

    fn fold_ts_type_operator_op(
        &mut self,
        node: TsTypeOperatorOp,
        ast_path: &mut AstKindPath,
    ) -> TsTypeOperatorOp {
        FoldAstPath::fold_ts_type_operator_op(&mut **self, node, ast_path)
    }

    fn fold_ts_type_param(&mut self, node: TsTypeParam, ast_path: &mut AstKindPath) -> TsTypeParam {
        FoldAstPath::fold_ts_type_param(&mut **self, node, ast_path)
    }

    fn fold_ts_type_param_decl(
        &mut self,
        node: TsTypeParamDecl,
        ast_path: &mut AstKindPath,
    ) -> TsTypeParamDecl {
        FoldAstPath::fold_ts_type_param_decl(&mut **self, node, ast_path)
    }

    fn fold_ts_type_param_instantiation(
        &mut self,
        node: TsTypeParamInstantiation,
        ast_path: &mut AstKindPath,
    ) -> TsTypeParamInstantiation {
        FoldAstPath::fold_ts_type_param_instantiation(&mut **self, node, ast_path)
    }

    fn fold_ts_type_params(
        &mut self,
        node: Vec<TsTypeParam>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsTypeParam> {
        FoldAstPath::fold_ts_type_params(&mut **self, node, ast_path)
    }

    fn fold_ts_type_predicate(
        &mut self,
        node: TsTypePredicate,
        ast_path: &mut AstKindPath,
    ) -> TsTypePredicate {
        FoldAstPath::fold_ts_type_predicate(&mut **self, node, ast_path)
    }

    fn fold_ts_type_query(&mut self, node: TsTypeQuery, ast_path: &mut AstKindPath) -> TsTypeQuery {
        FoldAstPath::fold_ts_type_query(&mut **self, node, ast_path)
    }

    fn fold_ts_type_query_expr(
        &mut self,
        node: TsTypeQueryExpr,
        ast_path: &mut AstKindPath,
    ) -> TsTypeQueryExpr {
        FoldAstPath::fold_ts_type_query_expr(&mut **self, node, ast_path)
    }

    fn fold_ts_type_ref(&mut self, node: TsTypeRef, ast_path: &mut AstKindPath) -> TsTypeRef {
        FoldAstPath::fold_ts_type_ref(&mut **self, node, ast_path)
    }

    fn fold_ts_types(
        &mut self,
        node: Vec<Box<TsType>>,
        ast_path: &mut AstKindPath,
    ) -> Vec<Box<TsType>> {
        FoldAstPath::fold_ts_types(&mut **self, node, ast_path)
    }

    fn fold_ts_union_or_intersection_type(
        &mut self,
        node: TsUnionOrIntersectionType,
        ast_path: &mut AstKindPath,
    ) -> TsUnionOrIntersectionType {
        FoldAstPath::fold_ts_union_or_intersection_type(&mut **self, node, ast_path)
    }

    fn fold_ts_union_type(&mut self, node: TsUnionType, ast_path: &mut AstKindPath) -> TsUnionType {
        FoldAstPath::fold_ts_union_type(&mut **self, node, ast_path)
    }

    fn fold_unary_expr(&mut self, node: UnaryExpr, ast_path: &mut AstKindPath) -> UnaryExpr {
        FoldAstPath::fold_unary_expr(&mut **self, node, ast_path)
    }

    fn fold_unary_op(&mut self, node: UnaryOp, ast_path: &mut AstKindPath) -> UnaryOp {
        FoldAstPath::fold_unary_op(&mut **self, node, ast_path)
    }

    fn fold_update_expr(&mut self, node: UpdateExpr, ast_path: &mut AstKindPath) -> UpdateExpr {
        FoldAstPath::fold_update_expr(&mut **self, node, ast_path)
    }

    fn fold_update_op(&mut self, node: UpdateOp, ast_path: &mut AstKindPath) -> UpdateOp {
        FoldAstPath::fold_update_op(&mut **self, node, ast_path)
    }

    fn fold_using_decl(&mut self, node: UsingDecl, ast_path: &mut AstKindPath) -> UsingDecl {
        FoldAstPath::fold_using_decl(&mut **self, node, ast_path)
    }

    fn fold_var_decl(&mut self, node: VarDecl, ast_path: &mut AstKindPath) -> VarDecl {
        FoldAstPath::fold_var_decl(&mut **self, node, ast_path)
    }

    fn fold_var_decl_kind(&mut self, node: VarDeclKind, ast_path: &mut AstKindPath) -> VarDeclKind {
        FoldAstPath::fold_var_decl_kind(&mut **self, node, ast_path)
    }

    fn fold_var_decl_or_expr(
        &mut self,
        node: VarDeclOrExpr,
        ast_path: &mut AstKindPath,
    ) -> VarDeclOrExpr {
        FoldAstPath::fold_var_decl_or_expr(&mut **self, node, ast_path)
    }

    fn fold_var_declarator(
        &mut self,
        node: VarDeclarator,
        ast_path: &mut AstKindPath,
    ) -> VarDeclarator {
        FoldAstPath::fold_var_declarator(&mut **self, node, ast_path)
    }

    fn fold_var_declarators(
        &mut self,
        node: Vec<VarDeclarator>,
        ast_path: &mut AstKindPath,
    ) -> Vec<VarDeclarator> {
        FoldAstPath::fold_var_declarators(&mut **self, node, ast_path)
    }

    fn fold_while_stmt(&mut self, node: WhileStmt, ast_path: &mut AstKindPath) -> WhileStmt {
        FoldAstPath::fold_while_stmt(&mut **self, node, ast_path)
    }

    fn fold_with_stmt(&mut self, node: WithStmt, ast_path: &mut AstKindPath) -> WithStmt {
        FoldAstPath::fold_with_stmt(&mut **self, node, ast_path)
    }

    fn fold_yield_expr(&mut self, node: YieldExpr, ast_path: &mut AstKindPath) -> YieldExpr {
        FoldAstPath::fold_yield_expr(&mut **self, node, ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> FoldAstPath for Box<V>
where
    V: ?Sized + FoldAstPath,
{
    fn fold_accessibility(
        &mut self,
        node: Accessibility,
        ast_path: &mut AstKindPath,
    ) -> Accessibility {
        FoldAstPath::fold_accessibility(&mut **self, node, ast_path)
    }

    fn fold_array_lit(&mut self, node: ArrayLit, ast_path: &mut AstKindPath) -> ArrayLit {
        FoldAstPath::fold_array_lit(&mut **self, node, ast_path)
    }

    fn fold_array_pat(&mut self, node: ArrayPat, ast_path: &mut AstKindPath) -> ArrayPat {
        FoldAstPath::fold_array_pat(&mut **self, node, ast_path)
    }

    fn fold_arrow_expr(&mut self, node: ArrowExpr, ast_path: &mut AstKindPath) -> ArrowExpr {
        FoldAstPath::fold_arrow_expr(&mut **self, node, ast_path)
    }

    fn fold_assign_expr(&mut self, node: AssignExpr, ast_path: &mut AstKindPath) -> AssignExpr {
        FoldAstPath::fold_assign_expr(&mut **self, node, ast_path)
    }

    fn fold_assign_op(&mut self, node: AssignOp, ast_path: &mut AstKindPath) -> AssignOp {
        FoldAstPath::fold_assign_op(&mut **self, node, ast_path)
    }

    fn fold_assign_pat(&mut self, node: AssignPat, ast_path: &mut AstKindPath) -> AssignPat {
        FoldAstPath::fold_assign_pat(&mut **self, node, ast_path)
    }

    fn fold_assign_pat_prop(
        &mut self,
        node: AssignPatProp,
        ast_path: &mut AstKindPath,
    ) -> AssignPatProp {
        FoldAstPath::fold_assign_pat_prop(&mut **self, node, ast_path)
    }

    fn fold_assign_prop(&mut self, node: AssignProp, ast_path: &mut AstKindPath) -> AssignProp {
        FoldAstPath::fold_assign_prop(&mut **self, node, ast_path)
    }

    fn fold_assign_target(
        &mut self,
        node: AssignTarget,
        ast_path: &mut AstKindPath,
    ) -> AssignTarget {
        FoldAstPath::fold_assign_target(&mut **self, node, ast_path)
    }

    fn fold_assign_target_pat(
        &mut self,
        node: AssignTargetPat,
        ast_path: &mut AstKindPath,
    ) -> AssignTargetPat {
        FoldAstPath::fold_assign_target_pat(&mut **self, node, ast_path)
    }

    fn fold_atom(&mut self, node: swc_atoms::Atom, ast_path: &mut AstKindPath) -> swc_atoms::Atom {
        FoldAstPath::fold_atom(&mut **self, node, ast_path)
    }

    fn fold_auto_accessor(
        &mut self,
        node: AutoAccessor,
        ast_path: &mut AstKindPath,
    ) -> AutoAccessor {
        FoldAstPath::fold_auto_accessor(&mut **self, node, ast_path)
    }

    fn fold_await_expr(&mut self, node: AwaitExpr, ast_path: &mut AstKindPath) -> AwaitExpr {
        FoldAstPath::fold_await_expr(&mut **self, node, ast_path)
    }

    fn fold_big_int(&mut self, node: BigInt, ast_path: &mut AstKindPath) -> BigInt {
        FoldAstPath::fold_big_int(&mut **self, node, ast_path)
    }

    fn fold_big_int_value(&mut self, node: BigIntValue, ast_path: &mut AstKindPath) -> BigIntValue {
        FoldAstPath::fold_big_int_value(&mut **self, node, ast_path)
    }

    fn fold_bin_expr(&mut self, node: BinExpr, ast_path: &mut AstKindPath) -> BinExpr {
        FoldAstPath::fold_bin_expr(&mut **self, node, ast_path)
    }

    fn fold_binary_op(&mut self, node: BinaryOp, ast_path: &mut AstKindPath) -> BinaryOp {
        FoldAstPath::fold_binary_op(&mut **self, node, ast_path)
    }

    fn fold_binding_ident(
        &mut self,
        node: BindingIdent,
        ast_path: &mut AstKindPath,
    ) -> BindingIdent {
        FoldAstPath::fold_binding_ident(&mut **self, node, ast_path)
    }

    fn fold_block_stmt(&mut self, node: BlockStmt, ast_path: &mut AstKindPath) -> BlockStmt {
        FoldAstPath::fold_block_stmt(&mut **self, node, ast_path)
    }

    fn fold_block_stmt_or_expr(
        &mut self,
        node: BlockStmtOrExpr,
        ast_path: &mut AstKindPath,
    ) -> BlockStmtOrExpr {
        FoldAstPath::fold_block_stmt_or_expr(&mut **self, node, ast_path)
    }

    fn fold_bool(&mut self, node: Bool, ast_path: &mut AstKindPath) -> Bool {
        FoldAstPath::fold_bool(&mut **self, node, ast_path)
    }

    fn fold_break_stmt(&mut self, node: BreakStmt, ast_path: &mut AstKindPath) -> BreakStmt {
        FoldAstPath::fold_break_stmt(&mut **self, node, ast_path)
    }

    fn fold_call_expr(&mut self, node: CallExpr, ast_path: &mut AstKindPath) -> CallExpr {
        FoldAstPath::fold_call_expr(&mut **self, node, ast_path)
    }

    fn fold_callee(&mut self, node: Callee, ast_path: &mut AstKindPath) -> Callee {
        FoldAstPath::fold_callee(&mut **self, node, ast_path)
    }

    fn fold_catch_clause(&mut self, node: CatchClause, ast_path: &mut AstKindPath) -> CatchClause {
        FoldAstPath::fold_catch_clause(&mut **self, node, ast_path)
    }

    fn fold_class(&mut self, node: Class, ast_path: &mut AstKindPath) -> Class {
        FoldAstPath::fold_class(&mut **self, node, ast_path)
    }

    fn fold_class_decl(&mut self, node: ClassDecl, ast_path: &mut AstKindPath) -> ClassDecl {
        FoldAstPath::fold_class_decl(&mut **self, node, ast_path)
    }

    fn fold_class_expr(&mut self, node: ClassExpr, ast_path: &mut AstKindPath) -> ClassExpr {
        FoldAstPath::fold_class_expr(&mut **self, node, ast_path)
    }

    fn fold_class_member(&mut self, node: ClassMember, ast_path: &mut AstKindPath) -> ClassMember {
        FoldAstPath::fold_class_member(&mut **self, node, ast_path)
    }

    fn fold_class_members(
        &mut self,
        node: Vec<ClassMember>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ClassMember> {
        FoldAstPath::fold_class_members(&mut **self, node, ast_path)
    }

    fn fold_class_method(&mut self, node: ClassMethod, ast_path: &mut AstKindPath) -> ClassMethod {
        FoldAstPath::fold_class_method(&mut **self, node, ast_path)
    }

    fn fold_class_prop(&mut self, node: ClassProp, ast_path: &mut AstKindPath) -> ClassProp {
        FoldAstPath::fold_class_prop(&mut **self, node, ast_path)
    }

    fn fold_computed_prop_name(
        &mut self,
        node: ComputedPropName,
        ast_path: &mut AstKindPath,
    ) -> ComputedPropName {
        FoldAstPath::fold_computed_prop_name(&mut **self, node, ast_path)
    }

    fn fold_cond_expr(&mut self, node: CondExpr, ast_path: &mut AstKindPath) -> CondExpr {
        FoldAstPath::fold_cond_expr(&mut **self, node, ast_path)
    }

    fn fold_constructor(&mut self, node: Constructor, ast_path: &mut AstKindPath) -> Constructor {
        FoldAstPath::fold_constructor(&mut **self, node, ast_path)
    }

    fn fold_continue_stmt(
        &mut self,
        node: ContinueStmt,
        ast_path: &mut AstKindPath,
    ) -> ContinueStmt {
        FoldAstPath::fold_continue_stmt(&mut **self, node, ast_path)
    }

    fn fold_debugger_stmt(
        &mut self,
        node: DebuggerStmt,
        ast_path: &mut AstKindPath,
    ) -> DebuggerStmt {
        FoldAstPath::fold_debugger_stmt(&mut **self, node, ast_path)
    }

    fn fold_decl(&mut self, node: Decl, ast_path: &mut AstKindPath) -> Decl {
        FoldAstPath::fold_decl(&mut **self, node, ast_path)
    }

    fn fold_decorator(&mut self, node: Decorator, ast_path: &mut AstKindPath) -> Decorator {
        FoldAstPath::fold_decorator(&mut **self, node, ast_path)
    }

    fn fold_decorators(
        &mut self,
        node: Vec<Decorator>,
        ast_path: &mut AstKindPath,
    ) -> Vec<Decorator> {
        FoldAstPath::fold_decorators(&mut **self, node, ast_path)
    }

    fn fold_default_decl(&mut self, node: DefaultDecl, ast_path: &mut AstKindPath) -> DefaultDecl {
        FoldAstPath::fold_default_decl(&mut **self, node, ast_path)
    }

    fn fold_do_while_stmt(&mut self, node: DoWhileStmt, ast_path: &mut AstKindPath) -> DoWhileStmt {
        FoldAstPath::fold_do_while_stmt(&mut **self, node, ast_path)
    }

    fn fold_empty_stmt(&mut self, node: EmptyStmt, ast_path: &mut AstKindPath) -> EmptyStmt {
        FoldAstPath::fold_empty_stmt(&mut **self, node, ast_path)
    }

    fn fold_es_version(&mut self, node: EsVersion, ast_path: &mut AstKindPath) -> EsVersion {
        FoldAstPath::fold_es_version(&mut **self, node, ast_path)
    }

    fn fold_export_all(&mut self, node: ExportAll, ast_path: &mut AstKindPath) -> ExportAll {
        FoldAstPath::fold_export_all(&mut **self, node, ast_path)
    }

    fn fold_export_decl(&mut self, node: ExportDecl, ast_path: &mut AstKindPath) -> ExportDecl {
        FoldAstPath::fold_export_decl(&mut **self, node, ast_path)
    }

    fn fold_export_default_decl(
        &mut self,
        node: ExportDefaultDecl,
        ast_path: &mut AstKindPath,
    ) -> ExportDefaultDecl {
        FoldAstPath::fold_export_default_decl(&mut **self, node, ast_path)
    }

    fn fold_export_default_expr(
        &mut self,
        node: ExportDefaultExpr,
        ast_path: &mut AstKindPath,
    ) -> ExportDefaultExpr {
        FoldAstPath::fold_export_default_expr(&mut **self, node, ast_path)
    }

    fn fold_export_default_specifier(
        &mut self,
        node: ExportDefaultSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ExportDefaultSpecifier {
        FoldAstPath::fold_export_default_specifier(&mut **self, node, ast_path)
    }

    fn fold_export_named_specifier(
        &mut self,
        node: ExportNamedSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ExportNamedSpecifier {
        FoldAstPath::fold_export_named_specifier(&mut **self, node, ast_path)
    }

    fn fold_export_namespace_specifier(
        &mut self,
        node: ExportNamespaceSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ExportNamespaceSpecifier {
        FoldAstPath::fold_export_namespace_specifier(&mut **self, node, ast_path)
    }

    fn fold_export_specifier(
        &mut self,
        node: ExportSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ExportSpecifier {
        FoldAstPath::fold_export_specifier(&mut **self, node, ast_path)
    }

    fn fold_export_specifiers(
        &mut self,
        node: Vec<ExportSpecifier>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ExportSpecifier> {
        FoldAstPath::fold_export_specifiers(&mut **self, node, ast_path)
    }

    fn fold_expr(&mut self, node: Expr, ast_path: &mut AstKindPath) -> Expr {
        FoldAstPath::fold_expr(&mut **self, node, ast_path)
    }

    fn fold_expr_or_spread(
        &mut self,
        node: ExprOrSpread,
        ast_path: &mut AstKindPath,
    ) -> ExprOrSpread {
        FoldAstPath::fold_expr_or_spread(&mut **self, node, ast_path)
    }

    fn fold_expr_or_spreads(
        &mut self,
        node: Vec<ExprOrSpread>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ExprOrSpread> {
        FoldAstPath::fold_expr_or_spreads(&mut **self, node, ast_path)
    }

    fn fold_expr_stmt(&mut self, node: ExprStmt, ast_path: &mut AstKindPath) -> ExprStmt {
        FoldAstPath::fold_expr_stmt(&mut **self, node, ast_path)
    }

    fn fold_exprs(&mut self, node: Vec<Box<Expr>>, ast_path: &mut AstKindPath) -> Vec<Box<Expr>> {
        FoldAstPath::fold_exprs(&mut **self, node, ast_path)
    }

    fn fold_fn_decl(&mut self, node: FnDecl, ast_path: &mut AstKindPath) -> FnDecl {
        FoldAstPath::fold_fn_decl(&mut **self, node, ast_path)
    }

    fn fold_fn_expr(&mut self, node: FnExpr, ast_path: &mut AstKindPath) -> FnExpr {
        FoldAstPath::fold_fn_expr(&mut **self, node, ast_path)
    }

    fn fold_for_head(&mut self, node: ForHead, ast_path: &mut AstKindPath) -> ForHead {
        FoldAstPath::fold_for_head(&mut **self, node, ast_path)
    }

    fn fold_for_in_stmt(&mut self, node: ForInStmt, ast_path: &mut AstKindPath) -> ForInStmt {
        FoldAstPath::fold_for_in_stmt(&mut **self, node, ast_path)
    }

    fn fold_for_of_stmt(&mut self, node: ForOfStmt, ast_path: &mut AstKindPath) -> ForOfStmt {
        FoldAstPath::fold_for_of_stmt(&mut **self, node, ast_path)
    }

    fn fold_for_stmt(&mut self, node: ForStmt, ast_path: &mut AstKindPath) -> ForStmt {
        FoldAstPath::fold_for_stmt(&mut **self, node, ast_path)
    }

    fn fold_function(&mut self, node: Function, ast_path: &mut AstKindPath) -> Function {
        FoldAstPath::fold_function(&mut **self, node, ast_path)
    }

    fn fold_getter_prop(&mut self, node: GetterProp, ast_path: &mut AstKindPath) -> GetterProp {
        FoldAstPath::fold_getter_prop(&mut **self, node, ast_path)
    }

    fn fold_ident(&mut self, node: Ident, ast_path: &mut AstKindPath) -> Ident {
        FoldAstPath::fold_ident(&mut **self, node, ast_path)
    }

    fn fold_ident_name(&mut self, node: IdentName, ast_path: &mut AstKindPath) -> IdentName {
        FoldAstPath::fold_ident_name(&mut **self, node, ast_path)
    }

    fn fold_if_stmt(&mut self, node: IfStmt, ast_path: &mut AstKindPath) -> IfStmt {
        FoldAstPath::fold_if_stmt(&mut **self, node, ast_path)
    }

    fn fold_import(&mut self, node: Import, ast_path: &mut AstKindPath) -> Import {
        FoldAstPath::fold_import(&mut **self, node, ast_path)
    }

    fn fold_import_decl(&mut self, node: ImportDecl, ast_path: &mut AstKindPath) -> ImportDecl {
        FoldAstPath::fold_import_decl(&mut **self, node, ast_path)
    }

    fn fold_import_default_specifier(
        &mut self,
        node: ImportDefaultSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ImportDefaultSpecifier {
        FoldAstPath::fold_import_default_specifier(&mut **self, node, ast_path)
    }

    fn fold_import_named_specifier(
        &mut self,
        node: ImportNamedSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ImportNamedSpecifier {
        FoldAstPath::fold_import_named_specifier(&mut **self, node, ast_path)
    }

    fn fold_import_phase(&mut self, node: ImportPhase, ast_path: &mut AstKindPath) -> ImportPhase {
        FoldAstPath::fold_import_phase(&mut **self, node, ast_path)
    }

    fn fold_import_specifier(
        &mut self,
        node: ImportSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ImportSpecifier {
        FoldAstPath::fold_import_specifier(&mut **self, node, ast_path)
    }

    fn fold_import_specifiers(
        &mut self,
        node: Vec<ImportSpecifier>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ImportSpecifier> {
        FoldAstPath::fold_import_specifiers(&mut **self, node, ast_path)
    }

    fn fold_import_star_as_specifier(
        &mut self,
        node: ImportStarAsSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ImportStarAsSpecifier {
        FoldAstPath::fold_import_star_as_specifier(&mut **self, node, ast_path)
    }

    fn fold_import_with(&mut self, node: ImportWith, ast_path: &mut AstKindPath) -> ImportWith {
        FoldAstPath::fold_import_with(&mut **self, node, ast_path)
    }

    fn fold_import_with_item(
        &mut self,
        node: ImportWithItem,
        ast_path: &mut AstKindPath,
    ) -> ImportWithItem {
        FoldAstPath::fold_import_with_item(&mut **self, node, ast_path)
    }

    fn fold_import_with_items(
        &mut self,
        node: Vec<ImportWithItem>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ImportWithItem> {
        FoldAstPath::fold_import_with_items(&mut **self, node, ast_path)
    }

    fn fold_invalid(&mut self, node: Invalid, ast_path: &mut AstKindPath) -> Invalid {
        FoldAstPath::fold_invalid(&mut **self, node, ast_path)
    }

    fn fold_jsx_attr(&mut self, node: JSXAttr, ast_path: &mut AstKindPath) -> JSXAttr {
        FoldAstPath::fold_jsx_attr(&mut **self, node, ast_path)
    }

    fn fold_jsx_attr_name(&mut self, node: JSXAttrName, ast_path: &mut AstKindPath) -> JSXAttrName {
        FoldAstPath::fold_jsx_attr_name(&mut **self, node, ast_path)
    }

    fn fold_jsx_attr_or_spread(
        &mut self,
        node: JSXAttrOrSpread,
        ast_path: &mut AstKindPath,
    ) -> JSXAttrOrSpread {
        FoldAstPath::fold_jsx_attr_or_spread(&mut **self, node, ast_path)
    }

    fn fold_jsx_attr_or_spreads(
        &mut self,
        node: Vec<JSXAttrOrSpread>,
        ast_path: &mut AstKindPath,
    ) -> Vec<JSXAttrOrSpread> {
        FoldAstPath::fold_jsx_attr_or_spreads(&mut **self, node, ast_path)
    }

    fn fold_jsx_attr_value(
        &mut self,
        node: JSXAttrValue,
        ast_path: &mut AstKindPath,
    ) -> JSXAttrValue {
        FoldAstPath::fold_jsx_attr_value(&mut **self, node, ast_path)
    }

    fn fold_jsx_closing_element(
        &mut self,
        node: JSXClosingElement,
        ast_path: &mut AstKindPath,
    ) -> JSXClosingElement {
        FoldAstPath::fold_jsx_closing_element(&mut **self, node, ast_path)
    }

    fn fold_jsx_closing_fragment(
        &mut self,
        node: JSXClosingFragment,
        ast_path: &mut AstKindPath,
    ) -> JSXClosingFragment {
        FoldAstPath::fold_jsx_closing_fragment(&mut **self, node, ast_path)
    }

    fn fold_jsx_element(&mut self, node: JSXElement, ast_path: &mut AstKindPath) -> JSXElement {
        FoldAstPath::fold_jsx_element(&mut **self, node, ast_path)
    }

    fn fold_jsx_element_child(
        &mut self,
        node: JSXElementChild,
        ast_path: &mut AstKindPath,
    ) -> JSXElementChild {
        FoldAstPath::fold_jsx_element_child(&mut **self, node, ast_path)
    }

    fn fold_jsx_element_childs(
        &mut self,
        node: Vec<JSXElementChild>,
        ast_path: &mut AstKindPath,
    ) -> Vec<JSXElementChild> {
        FoldAstPath::fold_jsx_element_childs(&mut **self, node, ast_path)
    }

    fn fold_jsx_element_name(
        &mut self,
        node: JSXElementName,
        ast_path: &mut AstKindPath,
    ) -> JSXElementName {
        FoldAstPath::fold_jsx_element_name(&mut **self, node, ast_path)
    }

    fn fold_jsx_empty_expr(
        &mut self,
        node: JSXEmptyExpr,
        ast_path: &mut AstKindPath,
    ) -> JSXEmptyExpr {
        FoldAstPath::fold_jsx_empty_expr(&mut **self, node, ast_path)
    }

    fn fold_jsx_expr(&mut self, node: JSXExpr, ast_path: &mut AstKindPath) -> JSXExpr {
        FoldAstPath::fold_jsx_expr(&mut **self, node, ast_path)
    }

    fn fold_jsx_expr_container(
        &mut self,
        node: JSXExprContainer,
        ast_path: &mut AstKindPath,
    ) -> JSXExprContainer {
        FoldAstPath::fold_jsx_expr_container(&mut **self, node, ast_path)
    }

    fn fold_jsx_fragment(&mut self, node: JSXFragment, ast_path: &mut AstKindPath) -> JSXFragment {
        FoldAstPath::fold_jsx_fragment(&mut **self, node, ast_path)
    }

    fn fold_jsx_member_expr(
        &mut self,
        node: JSXMemberExpr,
        ast_path: &mut AstKindPath,
    ) -> JSXMemberExpr {
        FoldAstPath::fold_jsx_member_expr(&mut **self, node, ast_path)
    }

    fn fold_jsx_namespaced_name(
        &mut self,
        node: JSXNamespacedName,
        ast_path: &mut AstKindPath,
    ) -> JSXNamespacedName {
        FoldAstPath::fold_jsx_namespaced_name(&mut **self, node, ast_path)
    }

    fn fold_jsx_object(&mut self, node: JSXObject, ast_path: &mut AstKindPath) -> JSXObject {
        FoldAstPath::fold_jsx_object(&mut **self, node, ast_path)
    }

    fn fold_jsx_opening_element(
        &mut self,
        node: JSXOpeningElement,
        ast_path: &mut AstKindPath,
    ) -> JSXOpeningElement {
        FoldAstPath::fold_jsx_opening_element(&mut **self, node, ast_path)
    }

    fn fold_jsx_opening_fragment(
        &mut self,
        node: JSXOpeningFragment,
        ast_path: &mut AstKindPath,
    ) -> JSXOpeningFragment {
        FoldAstPath::fold_jsx_opening_fragment(&mut **self, node, ast_path)
    }

    fn fold_jsx_spread_child(
        &mut self,
        node: JSXSpreadChild,
        ast_path: &mut AstKindPath,
    ) -> JSXSpreadChild {
        FoldAstPath::fold_jsx_spread_child(&mut **self, node, ast_path)
    }

    fn fold_jsx_text(&mut self, node: JSXText, ast_path: &mut AstKindPath) -> JSXText {
        FoldAstPath::fold_jsx_text(&mut **self, node, ast_path)
    }

    fn fold_key(&mut self, node: Key, ast_path: &mut AstKindPath) -> Key {
        FoldAstPath::fold_key(&mut **self, node, ast_path)
    }

    fn fold_key_value_pat_prop(
        &mut self,
        node: KeyValuePatProp,
        ast_path: &mut AstKindPath,
    ) -> KeyValuePatProp {
        FoldAstPath::fold_key_value_pat_prop(&mut **self, node, ast_path)
    }

    fn fold_key_value_prop(
        &mut self,
        node: KeyValueProp,
        ast_path: &mut AstKindPath,
    ) -> KeyValueProp {
        FoldAstPath::fold_key_value_prop(&mut **self, node, ast_path)
    }

    fn fold_labeled_stmt(&mut self, node: LabeledStmt, ast_path: &mut AstKindPath) -> LabeledStmt {
        FoldAstPath::fold_labeled_stmt(&mut **self, node, ast_path)
    }

    fn fold_lit(&mut self, node: Lit, ast_path: &mut AstKindPath) -> Lit {
        FoldAstPath::fold_lit(&mut **self, node, ast_path)
    }

    fn fold_member_expr(&mut self, node: MemberExpr, ast_path: &mut AstKindPath) -> MemberExpr {
        FoldAstPath::fold_member_expr(&mut **self, node, ast_path)
    }

    fn fold_member_prop(&mut self, node: MemberProp, ast_path: &mut AstKindPath) -> MemberProp {
        FoldAstPath::fold_member_prop(&mut **self, node, ast_path)
    }

    fn fold_meta_prop_expr(
        &mut self,
        node: MetaPropExpr,
        ast_path: &mut AstKindPath,
    ) -> MetaPropExpr {
        FoldAstPath::fold_meta_prop_expr(&mut **self, node, ast_path)
    }

    fn fold_meta_prop_kind(
        &mut self,
        node: MetaPropKind,
        ast_path: &mut AstKindPath,
    ) -> MetaPropKind {
        FoldAstPath::fold_meta_prop_kind(&mut **self, node, ast_path)
    }

    fn fold_method_kind(&mut self, node: MethodKind, ast_path: &mut AstKindPath) -> MethodKind {
        FoldAstPath::fold_method_kind(&mut **self, node, ast_path)
    }

    fn fold_method_prop(&mut self, node: MethodProp, ast_path: &mut AstKindPath) -> MethodProp {
        FoldAstPath::fold_method_prop(&mut **self, node, ast_path)
    }

    fn fold_module(&mut self, node: Module, ast_path: &mut AstKindPath) -> Module {
        FoldAstPath::fold_module(&mut **self, node, ast_path)
    }

    fn fold_module_decl(&mut self, node: ModuleDecl, ast_path: &mut AstKindPath) -> ModuleDecl {
        FoldAstPath::fold_module_decl(&mut **self, node, ast_path)
    }

    fn fold_module_export_name(
        &mut self,
        node: ModuleExportName,
        ast_path: &mut AstKindPath,
    ) -> ModuleExportName {
        FoldAstPath::fold_module_export_name(&mut **self, node, ast_path)
    }

    fn fold_module_item(&mut self, node: ModuleItem, ast_path: &mut AstKindPath) -> ModuleItem {
        FoldAstPath::fold_module_item(&mut **self, node, ast_path)
    }

    fn fold_module_items(
        &mut self,
        node: Vec<ModuleItem>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ModuleItem> {
        FoldAstPath::fold_module_items(&mut **self, node, ast_path)
    }

    fn fold_named_export(&mut self, node: NamedExport, ast_path: &mut AstKindPath) -> NamedExport {
        FoldAstPath::fold_named_export(&mut **self, node, ast_path)
    }

    fn fold_new_expr(&mut self, node: NewExpr, ast_path: &mut AstKindPath) -> NewExpr {
        FoldAstPath::fold_new_expr(&mut **self, node, ast_path)
    }

    fn fold_null(&mut self, node: Null, ast_path: &mut AstKindPath) -> Null {
        FoldAstPath::fold_null(&mut **self, node, ast_path)
    }

    fn fold_number(&mut self, node: Number, ast_path: &mut AstKindPath) -> Number {
        FoldAstPath::fold_number(&mut **self, node, ast_path)
    }

    fn fold_object_lit(&mut self, node: ObjectLit, ast_path: &mut AstKindPath) -> ObjectLit {
        FoldAstPath::fold_object_lit(&mut **self, node, ast_path)
    }

    fn fold_object_pat(&mut self, node: ObjectPat, ast_path: &mut AstKindPath) -> ObjectPat {
        FoldAstPath::fold_object_pat(&mut **self, node, ast_path)
    }

    fn fold_object_pat_prop(
        &mut self,
        node: ObjectPatProp,
        ast_path: &mut AstKindPath,
    ) -> ObjectPatProp {
        FoldAstPath::fold_object_pat_prop(&mut **self, node, ast_path)
    }

    fn fold_object_pat_props(
        &mut self,
        node: Vec<ObjectPatProp>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ObjectPatProp> {
        FoldAstPath::fold_object_pat_props(&mut **self, node, ast_path)
    }

    fn fold_opt_accessibility(
        &mut self,
        node: Option<Accessibility>,
        ast_path: &mut AstKindPath,
    ) -> Option<Accessibility> {
        FoldAstPath::fold_opt_accessibility(&mut **self, node, ast_path)
    }

    fn fold_opt_atom(
        &mut self,
        node: Option<swc_atoms::Atom>,
        ast_path: &mut AstKindPath,
    ) -> Option<swc_atoms::Atom> {
        FoldAstPath::fold_opt_atom(&mut **self, node, ast_path)
    }

    fn fold_opt_block_stmt(
        &mut self,
        node: Option<BlockStmt>,
        ast_path: &mut AstKindPath,
    ) -> Option<BlockStmt> {
        FoldAstPath::fold_opt_block_stmt(&mut **self, node, ast_path)
    }

    fn fold_opt_call(&mut self, node: OptCall, ast_path: &mut AstKindPath) -> OptCall {
        FoldAstPath::fold_opt_call(&mut **self, node, ast_path)
    }

    fn fold_opt_catch_clause(
        &mut self,
        node: Option<CatchClause>,
        ast_path: &mut AstKindPath,
    ) -> Option<CatchClause> {
        FoldAstPath::fold_opt_catch_clause(&mut **self, node, ast_path)
    }

    fn fold_opt_chain_base(
        &mut self,
        node: OptChainBase,
        ast_path: &mut AstKindPath,
    ) -> OptChainBase {
        FoldAstPath::fold_opt_chain_base(&mut **self, node, ast_path)
    }

    fn fold_opt_chain_expr(
        &mut self,
        node: OptChainExpr,
        ast_path: &mut AstKindPath,
    ) -> OptChainExpr {
        FoldAstPath::fold_opt_chain_expr(&mut **self, node, ast_path)
    }

    fn fold_opt_expr(
        &mut self,
        node: Option<Box<Expr>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<Expr>> {
        FoldAstPath::fold_opt_expr(&mut **self, node, ast_path)
    }

    fn fold_opt_expr_or_spread(
        &mut self,
        node: Option<ExprOrSpread>,
        ast_path: &mut AstKindPath,
    ) -> Option<ExprOrSpread> {
        FoldAstPath::fold_opt_expr_or_spread(&mut **self, node, ast_path)
    }

    fn fold_opt_expr_or_spreads(
        &mut self,
        node: Option<Vec<ExprOrSpread>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Vec<ExprOrSpread>> {
        FoldAstPath::fold_opt_expr_or_spreads(&mut **self, node, ast_path)
    }

    fn fold_opt_ident(&mut self, node: Option<Ident>, ast_path: &mut AstKindPath) -> Option<Ident> {
        FoldAstPath::fold_opt_ident(&mut **self, node, ast_path)
    }

    fn fold_opt_jsx_attr_value(
        &mut self,
        node: Option<JSXAttrValue>,
        ast_path: &mut AstKindPath,
    ) -> Option<JSXAttrValue> {
        FoldAstPath::fold_opt_jsx_attr_value(&mut **self, node, ast_path)
    }

    fn fold_opt_jsx_closing_element(
        &mut self,
        node: Option<JSXClosingElement>,
        ast_path: &mut AstKindPath,
    ) -> Option<JSXClosingElement> {
        FoldAstPath::fold_opt_jsx_closing_element(&mut **self, node, ast_path)
    }

    fn fold_opt_module_export_name(
        &mut self,
        node: Option<ModuleExportName>,
        ast_path: &mut AstKindPath,
    ) -> Option<ModuleExportName> {
        FoldAstPath::fold_opt_module_export_name(&mut **self, node, ast_path)
    }

    fn fold_opt_module_items(
        &mut self,
        node: Option<Vec<ModuleItem>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Vec<ModuleItem>> {
        FoldAstPath::fold_opt_module_items(&mut **self, node, ast_path)
    }

    fn fold_opt_object_lit(
        &mut self,
        node: Option<Box<ObjectLit>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<ObjectLit>> {
        FoldAstPath::fold_opt_object_lit(&mut **self, node, ast_path)
    }

    fn fold_opt_pat(&mut self, node: Option<Pat>, ast_path: &mut AstKindPath) -> Option<Pat> {
        FoldAstPath::fold_opt_pat(&mut **self, node, ast_path)
    }

    fn fold_opt_span(
        &mut self,
        node: Option<swc_common::Span>,
        ast_path: &mut AstKindPath,
    ) -> Option<swc_common::Span> {
        FoldAstPath::fold_opt_span(&mut **self, node, ast_path)
    }

    fn fold_opt_stmt(
        &mut self,
        node: Option<Box<Stmt>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<Stmt>> {
        FoldAstPath::fold_opt_stmt(&mut **self, node, ast_path)
    }

    fn fold_opt_str(
        &mut self,
        node: Option<Box<Str>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<Str>> {
        FoldAstPath::fold_opt_str(&mut **self, node, ast_path)
    }

    fn fold_opt_true_plus_minus(
        &mut self,
        node: Option<TruePlusMinus>,
        ast_path: &mut AstKindPath,
    ) -> Option<TruePlusMinus> {
        FoldAstPath::fold_opt_true_plus_minus(&mut **self, node, ast_path)
    }

    fn fold_opt_ts_entity_name(
        &mut self,
        node: Option<TsEntityName>,
        ast_path: &mut AstKindPath,
    ) -> Option<TsEntityName> {
        FoldAstPath::fold_opt_ts_entity_name(&mut **self, node, ast_path)
    }

    fn fold_opt_ts_namespace_body(
        &mut self,
        node: Option<TsNamespaceBody>,
        ast_path: &mut AstKindPath,
    ) -> Option<TsNamespaceBody> {
        FoldAstPath::fold_opt_ts_namespace_body(&mut **self, node, ast_path)
    }

    fn fold_opt_ts_type(
        &mut self,
        node: Option<Box<TsType>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<TsType>> {
        FoldAstPath::fold_opt_ts_type(&mut **self, node, ast_path)
    }

    fn fold_opt_ts_type_ann(
        &mut self,
        node: Option<Box<TsTypeAnn>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<TsTypeAnn>> {
        FoldAstPath::fold_opt_ts_type_ann(&mut **self, node, ast_path)
    }

    fn fold_opt_ts_type_param_decl(
        &mut self,
        node: Option<Box<TsTypeParamDecl>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<TsTypeParamDecl>> {
        FoldAstPath::fold_opt_ts_type_param_decl(&mut **self, node, ast_path)
    }

    fn fold_opt_ts_type_param_instantiation(
        &mut self,
        node: Option<Box<TsTypeParamInstantiation>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<TsTypeParamInstantiation>> {
        FoldAstPath::fold_opt_ts_type_param_instantiation(&mut **self, node, ast_path)
    }

    fn fold_opt_var_decl_or_expr(
        &mut self,
        node: Option<VarDeclOrExpr>,
        ast_path: &mut AstKindPath,
    ) -> Option<VarDeclOrExpr> {
        FoldAstPath::fold_opt_var_decl_or_expr(&mut **self, node, ast_path)
    }

    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        node: Vec<Option<ExprOrSpread>>,
        ast_path: &mut AstKindPath,
    ) -> Vec<Option<ExprOrSpread>> {
        FoldAstPath::fold_opt_vec_expr_or_spreads(&mut **self, node, ast_path)
    }

    fn fold_opt_vec_pats(
        &mut self,
        node: Vec<Option<Pat>>,
        ast_path: &mut AstKindPath,
    ) -> Vec<Option<Pat>> {
        FoldAstPath::fold_opt_vec_pats(&mut **self, node, ast_path)
    }

    fn fold_param(&mut self, node: Param, ast_path: &mut AstKindPath) -> Param {
        FoldAstPath::fold_param(&mut **self, node, ast_path)
    }

    fn fold_param_or_ts_param_prop(
        &mut self,
        node: ParamOrTsParamProp,
        ast_path: &mut AstKindPath,
    ) -> ParamOrTsParamProp {
        FoldAstPath::fold_param_or_ts_param_prop(&mut **self, node, ast_path)
    }

    fn fold_param_or_ts_param_props(
        &mut self,
        node: Vec<ParamOrTsParamProp>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ParamOrTsParamProp> {
        FoldAstPath::fold_param_or_ts_param_props(&mut **self, node, ast_path)
    }

    fn fold_params(&mut self, node: Vec<Param>, ast_path: &mut AstKindPath) -> Vec<Param> {
        FoldAstPath::fold_params(&mut **self, node, ast_path)
    }

    fn fold_paren_expr(&mut self, node: ParenExpr, ast_path: &mut AstKindPath) -> ParenExpr {
        FoldAstPath::fold_paren_expr(&mut **self, node, ast_path)
    }

    fn fold_pat(&mut self, node: Pat, ast_path: &mut AstKindPath) -> Pat {
        FoldAstPath::fold_pat(&mut **self, node, ast_path)
    }

    fn fold_pats(&mut self, node: Vec<Pat>, ast_path: &mut AstKindPath) -> Vec<Pat> {
        FoldAstPath::fold_pats(&mut **self, node, ast_path)
    }

    fn fold_private_method(
        &mut self,
        node: PrivateMethod,
        ast_path: &mut AstKindPath,
    ) -> PrivateMethod {
        FoldAstPath::fold_private_method(&mut **self, node, ast_path)
    }

    fn fold_private_name(&mut self, node: PrivateName, ast_path: &mut AstKindPath) -> PrivateName {
        FoldAstPath::fold_private_name(&mut **self, node, ast_path)
    }

    fn fold_private_prop(&mut self, node: PrivateProp, ast_path: &mut AstKindPath) -> PrivateProp {
        FoldAstPath::fold_private_prop(&mut **self, node, ast_path)
    }

    fn fold_program(&mut self, node: Program, ast_path: &mut AstKindPath) -> Program {
        FoldAstPath::fold_program(&mut **self, node, ast_path)
    }

    fn fold_prop(&mut self, node: Prop, ast_path: &mut AstKindPath) -> Prop {
        FoldAstPath::fold_prop(&mut **self, node, ast_path)
    }

    fn fold_prop_name(&mut self, node: PropName, ast_path: &mut AstKindPath) -> PropName {
        FoldAstPath::fold_prop_name(&mut **self, node, ast_path)
    }

    fn fold_prop_or_spread(
        &mut self,
        node: PropOrSpread,
        ast_path: &mut AstKindPath,
    ) -> PropOrSpread {
        FoldAstPath::fold_prop_or_spread(&mut **self, node, ast_path)
    }

    fn fold_prop_or_spreads(
        &mut self,
        node: Vec<PropOrSpread>,
        ast_path: &mut AstKindPath,
    ) -> Vec<PropOrSpread> {
        FoldAstPath::fold_prop_or_spreads(&mut **self, node, ast_path)
    }

    fn fold_regex(&mut self, node: Regex, ast_path: &mut AstKindPath) -> Regex {
        FoldAstPath::fold_regex(&mut **self, node, ast_path)
    }

    fn fold_reserved_unused(
        &mut self,
        node: ReservedUnused,
        ast_path: &mut AstKindPath,
    ) -> ReservedUnused {
        FoldAstPath::fold_reserved_unused(&mut **self, node, ast_path)
    }

    fn fold_rest_pat(&mut self, node: RestPat, ast_path: &mut AstKindPath) -> RestPat {
        FoldAstPath::fold_rest_pat(&mut **self, node, ast_path)
    }

    fn fold_return_stmt(&mut self, node: ReturnStmt, ast_path: &mut AstKindPath) -> ReturnStmt {
        FoldAstPath::fold_return_stmt(&mut **self, node, ast_path)
    }

    fn fold_script(&mut self, node: Script, ast_path: &mut AstKindPath) -> Script {
        FoldAstPath::fold_script(&mut **self, node, ast_path)
    }

    fn fold_seq_expr(&mut self, node: SeqExpr, ast_path: &mut AstKindPath) -> SeqExpr {
        FoldAstPath::fold_seq_expr(&mut **self, node, ast_path)
    }

    fn fold_setter_prop(&mut self, node: SetterProp, ast_path: &mut AstKindPath) -> SetterProp {
        FoldAstPath::fold_setter_prop(&mut **self, node, ast_path)
    }

    fn fold_simple_assign_target(
        &mut self,
        node: SimpleAssignTarget,
        ast_path: &mut AstKindPath,
    ) -> SimpleAssignTarget {
        FoldAstPath::fold_simple_assign_target(&mut **self, node, ast_path)
    }

    fn fold_span(
        &mut self,
        node: swc_common::Span,
        ast_path: &mut AstKindPath,
    ) -> swc_common::Span {
        FoldAstPath::fold_span(&mut **self, node, ast_path)
    }

    fn fold_spread_element(
        &mut self,
        node: SpreadElement,
        ast_path: &mut AstKindPath,
    ) -> SpreadElement {
        FoldAstPath::fold_spread_element(&mut **self, node, ast_path)
    }

    fn fold_static_block(&mut self, node: StaticBlock, ast_path: &mut AstKindPath) -> StaticBlock {
        FoldAstPath::fold_static_block(&mut **self, node, ast_path)
    }

    fn fold_stmt(&mut self, node: Stmt, ast_path: &mut AstKindPath) -> Stmt {
        FoldAstPath::fold_stmt(&mut **self, node, ast_path)
    }

    fn fold_stmts(&mut self, node: Vec<Stmt>, ast_path: &mut AstKindPath) -> Vec<Stmt> {
        FoldAstPath::fold_stmts(&mut **self, node, ast_path)
    }

    fn fold_str(&mut self, node: Str, ast_path: &mut AstKindPath) -> Str {
        FoldAstPath::fold_str(&mut **self, node, ast_path)
    }

    fn fold_super(&mut self, node: Super, ast_path: &mut AstKindPath) -> Super {
        FoldAstPath::fold_super(&mut **self, node, ast_path)
    }

    fn fold_super_prop(&mut self, node: SuperProp, ast_path: &mut AstKindPath) -> SuperProp {
        FoldAstPath::fold_super_prop(&mut **self, node, ast_path)
    }

    fn fold_super_prop_expr(
        &mut self,
        node: SuperPropExpr,
        ast_path: &mut AstKindPath,
    ) -> SuperPropExpr {
        FoldAstPath::fold_super_prop_expr(&mut **self, node, ast_path)
    }

    fn fold_switch_case(&mut self, node: SwitchCase, ast_path: &mut AstKindPath) -> SwitchCase {
        FoldAstPath::fold_switch_case(&mut **self, node, ast_path)
    }

    fn fold_switch_cases(
        &mut self,
        node: Vec<SwitchCase>,
        ast_path: &mut AstKindPath,
    ) -> Vec<SwitchCase> {
        FoldAstPath::fold_switch_cases(&mut **self, node, ast_path)
    }

    fn fold_switch_stmt(&mut self, node: SwitchStmt, ast_path: &mut AstKindPath) -> SwitchStmt {
        FoldAstPath::fold_switch_stmt(&mut **self, node, ast_path)
    }

    fn fold_syntax_context(
        &mut self,
        node: swc_common::SyntaxContext,
        ast_path: &mut AstKindPath,
    ) -> swc_common::SyntaxContext {
        FoldAstPath::fold_syntax_context(&mut **self, node, ast_path)
    }

    fn fold_tagged_tpl(&mut self, node: TaggedTpl, ast_path: &mut AstKindPath) -> TaggedTpl {
        FoldAstPath::fold_tagged_tpl(&mut **self, node, ast_path)
    }

    fn fold_this_expr(&mut self, node: ThisExpr, ast_path: &mut AstKindPath) -> ThisExpr {
        FoldAstPath::fold_this_expr(&mut **self, node, ast_path)
    }

    fn fold_throw_stmt(&mut self, node: ThrowStmt, ast_path: &mut AstKindPath) -> ThrowStmt {
        FoldAstPath::fold_throw_stmt(&mut **self, node, ast_path)
    }

    fn fold_tpl(&mut self, node: Tpl, ast_path: &mut AstKindPath) -> Tpl {
        FoldAstPath::fold_tpl(&mut **self, node, ast_path)
    }

    fn fold_tpl_element(&mut self, node: TplElement, ast_path: &mut AstKindPath) -> TplElement {
        FoldAstPath::fold_tpl_element(&mut **self, node, ast_path)
    }

    fn fold_tpl_elements(
        &mut self,
        node: Vec<TplElement>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TplElement> {
        FoldAstPath::fold_tpl_elements(&mut **self, node, ast_path)
    }

    fn fold_true_plus_minus(
        &mut self,
        node: TruePlusMinus,
        ast_path: &mut AstKindPath,
    ) -> TruePlusMinus {
        FoldAstPath::fold_true_plus_minus(&mut **self, node, ast_path)
    }

    fn fold_try_stmt(&mut self, node: TryStmt, ast_path: &mut AstKindPath) -> TryStmt {
        FoldAstPath::fold_try_stmt(&mut **self, node, ast_path)
    }

    fn fold_ts_array_type(&mut self, node: TsArrayType, ast_path: &mut AstKindPath) -> TsArrayType {
        FoldAstPath::fold_ts_array_type(&mut **self, node, ast_path)
    }

    fn fold_ts_as_expr(&mut self, node: TsAsExpr, ast_path: &mut AstKindPath) -> TsAsExpr {
        FoldAstPath::fold_ts_as_expr(&mut **self, node, ast_path)
    }

    fn fold_ts_call_signature_decl(
        &mut self,
        node: TsCallSignatureDecl,
        ast_path: &mut AstKindPath,
    ) -> TsCallSignatureDecl {
        FoldAstPath::fold_ts_call_signature_decl(&mut **self, node, ast_path)
    }

    fn fold_ts_conditional_type(
        &mut self,
        node: TsConditionalType,
        ast_path: &mut AstKindPath,
    ) -> TsConditionalType {
        FoldAstPath::fold_ts_conditional_type(&mut **self, node, ast_path)
    }

    fn fold_ts_const_assertion(
        &mut self,
        node: TsConstAssertion,
        ast_path: &mut AstKindPath,
    ) -> TsConstAssertion {
        FoldAstPath::fold_ts_const_assertion(&mut **self, node, ast_path)
    }

    fn fold_ts_construct_signature_decl(
        &mut self,
        node: TsConstructSignatureDecl,
        ast_path: &mut AstKindPath,
    ) -> TsConstructSignatureDecl {
        FoldAstPath::fold_ts_construct_signature_decl(&mut **self, node, ast_path)
    }

    fn fold_ts_constructor_type(
        &mut self,
        node: TsConstructorType,
        ast_path: &mut AstKindPath,
    ) -> TsConstructorType {
        FoldAstPath::fold_ts_constructor_type(&mut **self, node, ast_path)
    }

    fn fold_ts_entity_name(
        &mut self,
        node: TsEntityName,
        ast_path: &mut AstKindPath,
    ) -> TsEntityName {
        FoldAstPath::fold_ts_entity_name(&mut **self, node, ast_path)
    }

    fn fold_ts_enum_decl(&mut self, node: TsEnumDecl, ast_path: &mut AstKindPath) -> TsEnumDecl {
        FoldAstPath::fold_ts_enum_decl(&mut **self, node, ast_path)
    }

    fn fold_ts_enum_member(
        &mut self,
        node: TsEnumMember,
        ast_path: &mut AstKindPath,
    ) -> TsEnumMember {
        FoldAstPath::fold_ts_enum_member(&mut **self, node, ast_path)
    }

    fn fold_ts_enum_member_id(
        &mut self,
        node: TsEnumMemberId,
        ast_path: &mut AstKindPath,
    ) -> TsEnumMemberId {
        FoldAstPath::fold_ts_enum_member_id(&mut **self, node, ast_path)
    }

    fn fold_ts_enum_members(
        &mut self,
        node: Vec<TsEnumMember>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsEnumMember> {
        FoldAstPath::fold_ts_enum_members(&mut **self, node, ast_path)
    }

    fn fold_ts_export_assignment(
        &mut self,
        node: TsExportAssignment,
        ast_path: &mut AstKindPath,
    ) -> TsExportAssignment {
        FoldAstPath::fold_ts_export_assignment(&mut **self, node, ast_path)
    }

    fn fold_ts_expr_with_type_args(
        &mut self,
        node: TsExprWithTypeArgs,
        ast_path: &mut AstKindPath,
    ) -> TsExprWithTypeArgs {
        FoldAstPath::fold_ts_expr_with_type_args(&mut **self, node, ast_path)
    }

    fn fold_ts_expr_with_type_argss(
        &mut self,
        node: Vec<TsExprWithTypeArgs>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsExprWithTypeArgs> {
        FoldAstPath::fold_ts_expr_with_type_argss(&mut **self, node, ast_path)
    }

    fn fold_ts_external_module_ref(
        &mut self,
        node: TsExternalModuleRef,
        ast_path: &mut AstKindPath,
    ) -> TsExternalModuleRef {
        FoldAstPath::fold_ts_external_module_ref(&mut **self, node, ast_path)
    }

    fn fold_ts_fn_or_constructor_type(
        &mut self,
        node: TsFnOrConstructorType,
        ast_path: &mut AstKindPath,
    ) -> TsFnOrConstructorType {
        FoldAstPath::fold_ts_fn_or_constructor_type(&mut **self, node, ast_path)
    }

    fn fold_ts_fn_param(&mut self, node: TsFnParam, ast_path: &mut AstKindPath) -> TsFnParam {
        FoldAstPath::fold_ts_fn_param(&mut **self, node, ast_path)
    }

    fn fold_ts_fn_params(
        &mut self,
        node: Vec<TsFnParam>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsFnParam> {
        FoldAstPath::fold_ts_fn_params(&mut **self, node, ast_path)
    }

    fn fold_ts_fn_type(&mut self, node: TsFnType, ast_path: &mut AstKindPath) -> TsFnType {
        FoldAstPath::fold_ts_fn_type(&mut **self, node, ast_path)
    }

    fn fold_ts_getter_signature(
        &mut self,
        node: TsGetterSignature,
        ast_path: &mut AstKindPath,
    ) -> TsGetterSignature {
        FoldAstPath::fold_ts_getter_signature(&mut **self, node, ast_path)
    }

    fn fold_ts_import_equals_decl(
        &mut self,
        node: TsImportEqualsDecl,
        ast_path: &mut AstKindPath,
    ) -> TsImportEqualsDecl {
        FoldAstPath::fold_ts_import_equals_decl(&mut **self, node, ast_path)
    }

    fn fold_ts_import_type(
        &mut self,
        node: TsImportType,
        ast_path: &mut AstKindPath,
    ) -> TsImportType {
        FoldAstPath::fold_ts_import_type(&mut **self, node, ast_path)
    }

    fn fold_ts_index_signature(
        &mut self,
        node: TsIndexSignature,
        ast_path: &mut AstKindPath,
    ) -> TsIndexSignature {
        FoldAstPath::fold_ts_index_signature(&mut **self, node, ast_path)
    }

    fn fold_ts_indexed_access_type(
        &mut self,
        node: TsIndexedAccessType,
        ast_path: &mut AstKindPath,
    ) -> TsIndexedAccessType {
        FoldAstPath::fold_ts_indexed_access_type(&mut **self, node, ast_path)
    }

    fn fold_ts_infer_type(&mut self, node: TsInferType, ast_path: &mut AstKindPath) -> TsInferType {
        FoldAstPath::fold_ts_infer_type(&mut **self, node, ast_path)
    }

    fn fold_ts_instantiation(
        &mut self,
        node: TsInstantiation,
        ast_path: &mut AstKindPath,
    ) -> TsInstantiation {
        FoldAstPath::fold_ts_instantiation(&mut **self, node, ast_path)
    }

    fn fold_ts_interface_body(
        &mut self,
        node: TsInterfaceBody,
        ast_path: &mut AstKindPath,
    ) -> TsInterfaceBody {
        FoldAstPath::fold_ts_interface_body(&mut **self, node, ast_path)
    }

    fn fold_ts_interface_decl(
        &mut self,
        node: TsInterfaceDecl,
        ast_path: &mut AstKindPath,
    ) -> TsInterfaceDecl {
        FoldAstPath::fold_ts_interface_decl(&mut **self, node, ast_path)
    }

    fn fold_ts_intersection_type(
        &mut self,
        node: TsIntersectionType,
        ast_path: &mut AstKindPath,
    ) -> TsIntersectionType {
        FoldAstPath::fold_ts_intersection_type(&mut **self, node, ast_path)
    }

    fn fold_ts_keyword_type(
        &mut self,
        node: TsKeywordType,
        ast_path: &mut AstKindPath,
    ) -> TsKeywordType {
        FoldAstPath::fold_ts_keyword_type(&mut **self, node, ast_path)
    }

    fn fold_ts_keyword_type_kind(
        &mut self,
        node: TsKeywordTypeKind,
        ast_path: &mut AstKindPath,
    ) -> TsKeywordTypeKind {
        FoldAstPath::fold_ts_keyword_type_kind(&mut **self, node, ast_path)
    }

    fn fold_ts_lit(&mut self, node: TsLit, ast_path: &mut AstKindPath) -> TsLit {
        FoldAstPath::fold_ts_lit(&mut **self, node, ast_path)
    }

    fn fold_ts_lit_type(&mut self, node: TsLitType, ast_path: &mut AstKindPath) -> TsLitType {
        FoldAstPath::fold_ts_lit_type(&mut **self, node, ast_path)
    }

    fn fold_ts_mapped_type(
        &mut self,
        node: TsMappedType,
        ast_path: &mut AstKindPath,
    ) -> TsMappedType {
        FoldAstPath::fold_ts_mapped_type(&mut **self, node, ast_path)
    }

    fn fold_ts_method_signature(
        &mut self,
        node: TsMethodSignature,
        ast_path: &mut AstKindPath,
    ) -> TsMethodSignature {
        FoldAstPath::fold_ts_method_signature(&mut **self, node, ast_path)
    }

    fn fold_ts_module_block(
        &mut self,
        node: TsModuleBlock,
        ast_path: &mut AstKindPath,
    ) -> TsModuleBlock {
        FoldAstPath::fold_ts_module_block(&mut **self, node, ast_path)
    }

    fn fold_ts_module_decl(
        &mut self,
        node: TsModuleDecl,
        ast_path: &mut AstKindPath,
    ) -> TsModuleDecl {
        FoldAstPath::fold_ts_module_decl(&mut **self, node, ast_path)
    }

    fn fold_ts_module_name(
        &mut self,
        node: TsModuleName,
        ast_path: &mut AstKindPath,
    ) -> TsModuleName {
        FoldAstPath::fold_ts_module_name(&mut **self, node, ast_path)
    }

    fn fold_ts_module_ref(&mut self, node: TsModuleRef, ast_path: &mut AstKindPath) -> TsModuleRef {
        FoldAstPath::fold_ts_module_ref(&mut **self, node, ast_path)
    }

    fn fold_ts_namespace_body(
        &mut self,
        node: TsNamespaceBody,
        ast_path: &mut AstKindPath,
    ) -> TsNamespaceBody {
        FoldAstPath::fold_ts_namespace_body(&mut **self, node, ast_path)
    }

    fn fold_ts_namespace_decl(
        &mut self,
        node: TsNamespaceDecl,
        ast_path: &mut AstKindPath,
    ) -> TsNamespaceDecl {
        FoldAstPath::fold_ts_namespace_decl(&mut **self, node, ast_path)
    }

    fn fold_ts_namespace_export_decl(
        &mut self,
        node: TsNamespaceExportDecl,
        ast_path: &mut AstKindPath,
    ) -> TsNamespaceExportDecl {
        FoldAstPath::fold_ts_namespace_export_decl(&mut **self, node, ast_path)
    }

    fn fold_ts_non_null_expr(
        &mut self,
        node: TsNonNullExpr,
        ast_path: &mut AstKindPath,
    ) -> TsNonNullExpr {
        FoldAstPath::fold_ts_non_null_expr(&mut **self, node, ast_path)
    }

    fn fold_ts_optional_type(
        &mut self,
        node: TsOptionalType,
        ast_path: &mut AstKindPath,
    ) -> TsOptionalType {
        FoldAstPath::fold_ts_optional_type(&mut **self, node, ast_path)
    }

    fn fold_ts_param_prop(&mut self, node: TsParamProp, ast_path: &mut AstKindPath) -> TsParamProp {
        FoldAstPath::fold_ts_param_prop(&mut **self, node, ast_path)
    }

    fn fold_ts_param_prop_param(
        &mut self,
        node: TsParamPropParam,
        ast_path: &mut AstKindPath,
    ) -> TsParamPropParam {
        FoldAstPath::fold_ts_param_prop_param(&mut **self, node, ast_path)
    }

    fn fold_ts_parenthesized_type(
        &mut self,
        node: TsParenthesizedType,
        ast_path: &mut AstKindPath,
    ) -> TsParenthesizedType {
        FoldAstPath::fold_ts_parenthesized_type(&mut **self, node, ast_path)
    }

    fn fold_ts_property_signature(
        &mut self,
        node: TsPropertySignature,
        ast_path: &mut AstKindPath,
    ) -> TsPropertySignature {
        FoldAstPath::fold_ts_property_signature(&mut **self, node, ast_path)
    }

    fn fold_ts_qualified_name(
        &mut self,
        node: TsQualifiedName,
        ast_path: &mut AstKindPath,
    ) -> TsQualifiedName {
        FoldAstPath::fold_ts_qualified_name(&mut **self, node, ast_path)
    }

    fn fold_ts_rest_type(&mut self, node: TsRestType, ast_path: &mut AstKindPath) -> TsRestType {
        FoldAstPath::fold_ts_rest_type(&mut **self, node, ast_path)
    }

    fn fold_ts_satisfies_expr(
        &mut self,
        node: TsSatisfiesExpr,
        ast_path: &mut AstKindPath,
    ) -> TsSatisfiesExpr {
        FoldAstPath::fold_ts_satisfies_expr(&mut **self, node, ast_path)
    }

    fn fold_ts_setter_signature(
        &mut self,
        node: TsSetterSignature,
        ast_path: &mut AstKindPath,
    ) -> TsSetterSignature {
        FoldAstPath::fold_ts_setter_signature(&mut **self, node, ast_path)
    }

    fn fold_ts_this_type(&mut self, node: TsThisType, ast_path: &mut AstKindPath) -> TsThisType {
        FoldAstPath::fold_ts_this_type(&mut **self, node, ast_path)
    }

    fn fold_ts_this_type_or_ident(
        &mut self,
        node: TsThisTypeOrIdent,
        ast_path: &mut AstKindPath,
    ) -> TsThisTypeOrIdent {
        FoldAstPath::fold_ts_this_type_or_ident(&mut **self, node, ast_path)
    }

    fn fold_ts_tpl_lit_type(
        &mut self,
        node: TsTplLitType,
        ast_path: &mut AstKindPath,
    ) -> TsTplLitType {
        FoldAstPath::fold_ts_tpl_lit_type(&mut **self, node, ast_path)
    }

    fn fold_ts_tuple_element(
        &mut self,
        node: TsTupleElement,
        ast_path: &mut AstKindPath,
    ) -> TsTupleElement {
        FoldAstPath::fold_ts_tuple_element(&mut **self, node, ast_path)
    }

    fn fold_ts_tuple_elements(
        &mut self,
        node: Vec<TsTupleElement>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsTupleElement> {
        FoldAstPath::fold_ts_tuple_elements(&mut **self, node, ast_path)
    }

    fn fold_ts_tuple_type(&mut self, node: TsTupleType, ast_path: &mut AstKindPath) -> TsTupleType {
        FoldAstPath::fold_ts_tuple_type(&mut **self, node, ast_path)
    }

    fn fold_ts_type(&mut self, node: TsType, ast_path: &mut AstKindPath) -> TsType {
        FoldAstPath::fold_ts_type(&mut **self, node, ast_path)
    }

    fn fold_ts_type_alias_decl(
        &mut self,
        node: TsTypeAliasDecl,
        ast_path: &mut AstKindPath,
    ) -> TsTypeAliasDecl {
        FoldAstPath::fold_ts_type_alias_decl(&mut **self, node, ast_path)
    }

    fn fold_ts_type_ann(&mut self, node: TsTypeAnn, ast_path: &mut AstKindPath) -> TsTypeAnn {
        FoldAstPath::fold_ts_type_ann(&mut **self, node, ast_path)
    }

    fn fold_ts_type_assertion(
        &mut self,
        node: TsTypeAssertion,
        ast_path: &mut AstKindPath,
    ) -> TsTypeAssertion {
        FoldAstPath::fold_ts_type_assertion(&mut **self, node, ast_path)
    }

    fn fold_ts_type_element(
        &mut self,
        node: TsTypeElement,
        ast_path: &mut AstKindPath,
    ) -> TsTypeElement {
        FoldAstPath::fold_ts_type_element(&mut **self, node, ast_path)
    }

    fn fold_ts_type_elements(
        &mut self,
        node: Vec<TsTypeElement>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsTypeElement> {
        FoldAstPath::fold_ts_type_elements(&mut **self, node, ast_path)
    }

    fn fold_ts_type_lit(&mut self, node: TsTypeLit, ast_path: &mut AstKindPath) -> TsTypeLit {
        FoldAstPath::fold_ts_type_lit(&mut **self, node, ast_path)
    }

    fn fold_ts_type_operator(
        &mut self,
        node: TsTypeOperator,
        ast_path: &mut AstKindPath,
    ) -> TsTypeOperator {
        FoldAstPath::fold_ts_type_operator(&mut **self, node, ast_path)
    }

    fn fold_ts_type_operator_op(
        &mut self,
        node: TsTypeOperatorOp,
        ast_path: &mut AstKindPath,
    ) -> TsTypeOperatorOp {
        FoldAstPath::fold_ts_type_operator_op(&mut **self, node, ast_path)
    }

    fn fold_ts_type_param(&mut self, node: TsTypeParam, ast_path: &mut AstKindPath) -> TsTypeParam {
        FoldAstPath::fold_ts_type_param(&mut **self, node, ast_path)
    }

    fn fold_ts_type_param_decl(
        &mut self,
        node: TsTypeParamDecl,
        ast_path: &mut AstKindPath,
    ) -> TsTypeParamDecl {
        FoldAstPath::fold_ts_type_param_decl(&mut **self, node, ast_path)
    }

    fn fold_ts_type_param_instantiation(
        &mut self,
        node: TsTypeParamInstantiation,
        ast_path: &mut AstKindPath,
    ) -> TsTypeParamInstantiation {
        FoldAstPath::fold_ts_type_param_instantiation(&mut **self, node, ast_path)
    }

    fn fold_ts_type_params(
        &mut self,
        node: Vec<TsTypeParam>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsTypeParam> {
        FoldAstPath::fold_ts_type_params(&mut **self, node, ast_path)
    }

    fn fold_ts_type_predicate(
        &mut self,
        node: TsTypePredicate,
        ast_path: &mut AstKindPath,
    ) -> TsTypePredicate {
        FoldAstPath::fold_ts_type_predicate(&mut **self, node, ast_path)
    }

    fn fold_ts_type_query(&mut self, node: TsTypeQuery, ast_path: &mut AstKindPath) -> TsTypeQuery {
        FoldAstPath::fold_ts_type_query(&mut **self, node, ast_path)
    }

    fn fold_ts_type_query_expr(
        &mut self,
        node: TsTypeQueryExpr,
        ast_path: &mut AstKindPath,
    ) -> TsTypeQueryExpr {
        FoldAstPath::fold_ts_type_query_expr(&mut **self, node, ast_path)
    }

    fn fold_ts_type_ref(&mut self, node: TsTypeRef, ast_path: &mut AstKindPath) -> TsTypeRef {
        FoldAstPath::fold_ts_type_ref(&mut **self, node, ast_path)
    }

    fn fold_ts_types(
        &mut self,
        node: Vec<Box<TsType>>,
        ast_path: &mut AstKindPath,
    ) -> Vec<Box<TsType>> {
        FoldAstPath::fold_ts_types(&mut **self, node, ast_path)
    }

    fn fold_ts_union_or_intersection_type(
        &mut self,
        node: TsUnionOrIntersectionType,
        ast_path: &mut AstKindPath,
    ) -> TsUnionOrIntersectionType {
        FoldAstPath::fold_ts_union_or_intersection_type(&mut **self, node, ast_path)
    }

    fn fold_ts_union_type(&mut self, node: TsUnionType, ast_path: &mut AstKindPath) -> TsUnionType {
        FoldAstPath::fold_ts_union_type(&mut **self, node, ast_path)
    }

    fn fold_unary_expr(&mut self, node: UnaryExpr, ast_path: &mut AstKindPath) -> UnaryExpr {
        FoldAstPath::fold_unary_expr(&mut **self, node, ast_path)
    }

    fn fold_unary_op(&mut self, node: UnaryOp, ast_path: &mut AstKindPath) -> UnaryOp {
        FoldAstPath::fold_unary_op(&mut **self, node, ast_path)
    }

    fn fold_update_expr(&mut self, node: UpdateExpr, ast_path: &mut AstKindPath) -> UpdateExpr {
        FoldAstPath::fold_update_expr(&mut **self, node, ast_path)
    }

    fn fold_update_op(&mut self, node: UpdateOp, ast_path: &mut AstKindPath) -> UpdateOp {
        FoldAstPath::fold_update_op(&mut **self, node, ast_path)
    }

    fn fold_using_decl(&mut self, node: UsingDecl, ast_path: &mut AstKindPath) -> UsingDecl {
        FoldAstPath::fold_using_decl(&mut **self, node, ast_path)
    }

    fn fold_var_decl(&mut self, node: VarDecl, ast_path: &mut AstKindPath) -> VarDecl {
        FoldAstPath::fold_var_decl(&mut **self, node, ast_path)
    }

    fn fold_var_decl_kind(&mut self, node: VarDeclKind, ast_path: &mut AstKindPath) -> VarDeclKind {
        FoldAstPath::fold_var_decl_kind(&mut **self, node, ast_path)
    }

    fn fold_var_decl_or_expr(
        &mut self,
        node: VarDeclOrExpr,
        ast_path: &mut AstKindPath,
    ) -> VarDeclOrExpr {
        FoldAstPath::fold_var_decl_or_expr(&mut **self, node, ast_path)
    }

    fn fold_var_declarator(
        &mut self,
        node: VarDeclarator,
        ast_path: &mut AstKindPath,
    ) -> VarDeclarator {
        FoldAstPath::fold_var_declarator(&mut **self, node, ast_path)
    }

    fn fold_var_declarators(
        &mut self,
        node: Vec<VarDeclarator>,
        ast_path: &mut AstKindPath,
    ) -> Vec<VarDeclarator> {
        FoldAstPath::fold_var_declarators(&mut **self, node, ast_path)
    }

    fn fold_while_stmt(&mut self, node: WhileStmt, ast_path: &mut AstKindPath) -> WhileStmt {
        FoldAstPath::fold_while_stmt(&mut **self, node, ast_path)
    }

    fn fold_with_stmt(&mut self, node: WithStmt, ast_path: &mut AstKindPath) -> WithStmt {
        FoldAstPath::fold_with_stmt(&mut **self, node, ast_path)
    }

    fn fold_yield_expr(&mut self, node: YieldExpr, ast_path: &mut AstKindPath) -> YieldExpr {
        FoldAstPath::fold_yield_expr(&mut **self, node, ast_path)
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<A, B> FoldAstPath for ::swc_visit::Either<A, B>
where
    A: FoldAstPath,
    B: FoldAstPath,
{
    fn fold_accessibility(
        &mut self,
        node: Accessibility,
        ast_path: &mut AstKindPath,
    ) -> Accessibility {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_accessibility(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_accessibility(self, node, ast_path)
            }
        }
    }

    fn fold_array_lit(&mut self, node: ArrayLit, ast_path: &mut AstKindPath) -> ArrayLit {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_array_lit(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_array_lit(self, node, ast_path),
        }
    }

    fn fold_array_pat(&mut self, node: ArrayPat, ast_path: &mut AstKindPath) -> ArrayPat {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_array_pat(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_array_pat(self, node, ast_path),
        }
    }

    fn fold_arrow_expr(&mut self, node: ArrowExpr, ast_path: &mut AstKindPath) -> ArrowExpr {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_arrow_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_arrow_expr(self, node, ast_path),
        }
    }

    fn fold_assign_expr(&mut self, node: AssignExpr, ast_path: &mut AstKindPath) -> AssignExpr {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_assign_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_assign_expr(self, node, ast_path)
            }
        }
    }

    fn fold_assign_op(&mut self, node: AssignOp, ast_path: &mut AstKindPath) -> AssignOp {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_assign_op(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_assign_op(self, node, ast_path),
        }
    }

    fn fold_assign_pat(&mut self, node: AssignPat, ast_path: &mut AstKindPath) -> AssignPat {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_assign_pat(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_assign_pat(self, node, ast_path),
        }
    }

    fn fold_assign_pat_prop(
        &mut self,
        node: AssignPatProp,
        ast_path: &mut AstKindPath,
    ) -> AssignPatProp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_assign_pat_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_assign_pat_prop(self, node, ast_path)
            }
        }
    }

    fn fold_assign_prop(&mut self, node: AssignProp, ast_path: &mut AstKindPath) -> AssignProp {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_assign_prop(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_assign_prop(self, node, ast_path)
            }
        }
    }

    fn fold_assign_target(
        &mut self,
        node: AssignTarget,
        ast_path: &mut AstKindPath,
    ) -> AssignTarget {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_assign_target(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_assign_target(self, node, ast_path)
            }
        }
    }

    fn fold_assign_target_pat(
        &mut self,
        node: AssignTargetPat,
        ast_path: &mut AstKindPath,
    ) -> AssignTargetPat {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_assign_target_pat(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_assign_target_pat(self, node, ast_path)
            }
        }
    }

    fn fold_atom(&mut self, node: swc_atoms::Atom, ast_path: &mut AstKindPath) -> swc_atoms::Atom {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_atom(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_atom(self, node, ast_path),
        }
    }

    fn fold_auto_accessor(
        &mut self,
        node: AutoAccessor,
        ast_path: &mut AstKindPath,
    ) -> AutoAccessor {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_auto_accessor(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_auto_accessor(self, node, ast_path)
            }
        }
    }

    fn fold_await_expr(&mut self, node: AwaitExpr, ast_path: &mut AstKindPath) -> AwaitExpr {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_await_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_await_expr(self, node, ast_path),
        }
    }

    fn fold_big_int(&mut self, node: BigInt, ast_path: &mut AstKindPath) -> BigInt {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_big_int(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_big_int(self, node, ast_path),
        }
    }

    fn fold_big_int_value(&mut self, node: BigIntValue, ast_path: &mut AstKindPath) -> BigIntValue {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_big_int_value(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_big_int_value(self, node, ast_path)
            }
        }
    }

    fn fold_bin_expr(&mut self, node: BinExpr, ast_path: &mut AstKindPath) -> BinExpr {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_bin_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_bin_expr(self, node, ast_path),
        }
    }

    fn fold_binary_op(&mut self, node: BinaryOp, ast_path: &mut AstKindPath) -> BinaryOp {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_binary_op(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_binary_op(self, node, ast_path),
        }
    }

    fn fold_binding_ident(
        &mut self,
        node: BindingIdent,
        ast_path: &mut AstKindPath,
    ) -> BindingIdent {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_binding_ident(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_binding_ident(self, node, ast_path)
            }
        }
    }

    fn fold_block_stmt(&mut self, node: BlockStmt, ast_path: &mut AstKindPath) -> BlockStmt {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_block_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_block_stmt(self, node, ast_path),
        }
    }

    fn fold_block_stmt_or_expr(
        &mut self,
        node: BlockStmtOrExpr,
        ast_path: &mut AstKindPath,
    ) -> BlockStmtOrExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_block_stmt_or_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_block_stmt_or_expr(self, node, ast_path)
            }
        }
    }

    fn fold_bool(&mut self, node: Bool, ast_path: &mut AstKindPath) -> Bool {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_bool(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_bool(self, node, ast_path),
        }
    }

    fn fold_break_stmt(&mut self, node: BreakStmt, ast_path: &mut AstKindPath) -> BreakStmt {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_break_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_break_stmt(self, node, ast_path),
        }
    }

    fn fold_call_expr(&mut self, node: CallExpr, ast_path: &mut AstKindPath) -> CallExpr {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_call_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_call_expr(self, node, ast_path),
        }
    }

    fn fold_callee(&mut self, node: Callee, ast_path: &mut AstKindPath) -> Callee {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_callee(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_callee(self, node, ast_path),
        }
    }

    fn fold_catch_clause(&mut self, node: CatchClause, ast_path: &mut AstKindPath) -> CatchClause {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_catch_clause(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_catch_clause(self, node, ast_path)
            }
        }
    }

    fn fold_class(&mut self, node: Class, ast_path: &mut AstKindPath) -> Class {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_class(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_class(self, node, ast_path),
        }
    }

    fn fold_class_decl(&mut self, node: ClassDecl, ast_path: &mut AstKindPath) -> ClassDecl {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_class_decl(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_class_decl(self, node, ast_path),
        }
    }

    fn fold_class_expr(&mut self, node: ClassExpr, ast_path: &mut AstKindPath) -> ClassExpr {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_class_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_class_expr(self, node, ast_path),
        }
    }

    fn fold_class_member(&mut self, node: ClassMember, ast_path: &mut AstKindPath) -> ClassMember {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_class_member(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_class_member(self, node, ast_path)
            }
        }
    }

    fn fold_class_members(
        &mut self,
        node: Vec<ClassMember>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ClassMember> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_class_members(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_class_members(self, node, ast_path)
            }
        }
    }

    fn fold_class_method(&mut self, node: ClassMethod, ast_path: &mut AstKindPath) -> ClassMethod {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_class_method(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_class_method(self, node, ast_path)
            }
        }
    }

    fn fold_class_prop(&mut self, node: ClassProp, ast_path: &mut AstKindPath) -> ClassProp {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_class_prop(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_class_prop(self, node, ast_path),
        }
    }

    fn fold_computed_prop_name(
        &mut self,
        node: ComputedPropName,
        ast_path: &mut AstKindPath,
    ) -> ComputedPropName {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_computed_prop_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_computed_prop_name(self, node, ast_path)
            }
        }
    }

    fn fold_cond_expr(&mut self, node: CondExpr, ast_path: &mut AstKindPath) -> CondExpr {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_cond_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_cond_expr(self, node, ast_path),
        }
    }

    fn fold_constructor(&mut self, node: Constructor, ast_path: &mut AstKindPath) -> Constructor {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_constructor(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_constructor(self, node, ast_path)
            }
        }
    }

    fn fold_continue_stmt(
        &mut self,
        node: ContinueStmt,
        ast_path: &mut AstKindPath,
    ) -> ContinueStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_continue_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_continue_stmt(self, node, ast_path)
            }
        }
    }

    fn fold_debugger_stmt(
        &mut self,
        node: DebuggerStmt,
        ast_path: &mut AstKindPath,
    ) -> DebuggerStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_debugger_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_debugger_stmt(self, node, ast_path)
            }
        }
    }

    fn fold_decl(&mut self, node: Decl, ast_path: &mut AstKindPath) -> Decl {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_decl(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_decl(self, node, ast_path),
        }
    }

    fn fold_decorator(&mut self, node: Decorator, ast_path: &mut AstKindPath) -> Decorator {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_decorator(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_decorator(self, node, ast_path),
        }
    }

    fn fold_decorators(
        &mut self,
        node: Vec<Decorator>,
        ast_path: &mut AstKindPath,
    ) -> Vec<Decorator> {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_decorators(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_decorators(self, node, ast_path),
        }
    }

    fn fold_default_decl(&mut self, node: DefaultDecl, ast_path: &mut AstKindPath) -> DefaultDecl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_default_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_default_decl(self, node, ast_path)
            }
        }
    }

    fn fold_do_while_stmt(&mut self, node: DoWhileStmt, ast_path: &mut AstKindPath) -> DoWhileStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_do_while_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_do_while_stmt(self, node, ast_path)
            }
        }
    }

    fn fold_empty_stmt(&mut self, node: EmptyStmt, ast_path: &mut AstKindPath) -> EmptyStmt {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_empty_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_empty_stmt(self, node, ast_path),
        }
    }

    fn fold_es_version(&mut self, node: EsVersion, ast_path: &mut AstKindPath) -> EsVersion {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_es_version(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_es_version(self, node, ast_path),
        }
    }

    fn fold_export_all(&mut self, node: ExportAll, ast_path: &mut AstKindPath) -> ExportAll {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_export_all(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_export_all(self, node, ast_path),
        }
    }

    fn fold_export_decl(&mut self, node: ExportDecl, ast_path: &mut AstKindPath) -> ExportDecl {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_export_decl(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_export_decl(self, node, ast_path)
            }
        }
    }

    fn fold_export_default_decl(
        &mut self,
        node: ExportDefaultDecl,
        ast_path: &mut AstKindPath,
    ) -> ExportDefaultDecl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_export_default_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_export_default_decl(self, node, ast_path)
            }
        }
    }

    fn fold_export_default_expr(
        &mut self,
        node: ExportDefaultExpr,
        ast_path: &mut AstKindPath,
    ) -> ExportDefaultExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_export_default_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_export_default_expr(self, node, ast_path)
            }
        }
    }

    fn fold_export_default_specifier(
        &mut self,
        node: ExportDefaultSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ExportDefaultSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_export_default_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_export_default_specifier(self, node, ast_path)
            }
        }
    }

    fn fold_export_named_specifier(
        &mut self,
        node: ExportNamedSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ExportNamedSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_export_named_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_export_named_specifier(self, node, ast_path)
            }
        }
    }

    fn fold_export_namespace_specifier(
        &mut self,
        node: ExportNamespaceSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ExportNamespaceSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_export_namespace_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_export_namespace_specifier(self, node, ast_path)
            }
        }
    }

    fn fold_export_specifier(
        &mut self,
        node: ExportSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ExportSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_export_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_export_specifier(self, node, ast_path)
            }
        }
    }

    fn fold_export_specifiers(
        &mut self,
        node: Vec<ExportSpecifier>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ExportSpecifier> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_export_specifiers(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_export_specifiers(self, node, ast_path)
            }
        }
    }

    fn fold_expr(&mut self, node: Expr, ast_path: &mut AstKindPath) -> Expr {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_expr(self, node, ast_path),
        }
    }

    fn fold_expr_or_spread(
        &mut self,
        node: ExprOrSpread,
        ast_path: &mut AstKindPath,
    ) -> ExprOrSpread {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_expr_or_spread(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_expr_or_spread(self, node, ast_path)
            }
        }
    }

    fn fold_expr_or_spreads(
        &mut self,
        node: Vec<ExprOrSpread>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ExprOrSpread> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_expr_or_spreads(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_expr_or_spreads(self, node, ast_path)
            }
        }
    }

    fn fold_expr_stmt(&mut self, node: ExprStmt, ast_path: &mut AstKindPath) -> ExprStmt {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_expr_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_expr_stmt(self, node, ast_path),
        }
    }

    fn fold_exprs(&mut self, node: Vec<Box<Expr>>, ast_path: &mut AstKindPath) -> Vec<Box<Expr>> {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_exprs(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_exprs(self, node, ast_path),
        }
    }

    fn fold_fn_decl(&mut self, node: FnDecl, ast_path: &mut AstKindPath) -> FnDecl {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_fn_decl(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_fn_decl(self, node, ast_path),
        }
    }

    fn fold_fn_expr(&mut self, node: FnExpr, ast_path: &mut AstKindPath) -> FnExpr {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_fn_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_fn_expr(self, node, ast_path),
        }
    }

    fn fold_for_head(&mut self, node: ForHead, ast_path: &mut AstKindPath) -> ForHead {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_for_head(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_for_head(self, node, ast_path),
        }
    }

    fn fold_for_in_stmt(&mut self, node: ForInStmt, ast_path: &mut AstKindPath) -> ForInStmt {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_for_in_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_for_in_stmt(self, node, ast_path)
            }
        }
    }

    fn fold_for_of_stmt(&mut self, node: ForOfStmt, ast_path: &mut AstKindPath) -> ForOfStmt {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_for_of_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_for_of_stmt(self, node, ast_path)
            }
        }
    }

    fn fold_for_stmt(&mut self, node: ForStmt, ast_path: &mut AstKindPath) -> ForStmt {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_for_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_for_stmt(self, node, ast_path),
        }
    }

    fn fold_function(&mut self, node: Function, ast_path: &mut AstKindPath) -> Function {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_function(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_function(self, node, ast_path),
        }
    }

    fn fold_getter_prop(&mut self, node: GetterProp, ast_path: &mut AstKindPath) -> GetterProp {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_getter_prop(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_getter_prop(self, node, ast_path)
            }
        }
    }

    fn fold_ident(&mut self, node: Ident, ast_path: &mut AstKindPath) -> Ident {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_ident(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_ident(self, node, ast_path),
        }
    }

    fn fold_ident_name(&mut self, node: IdentName, ast_path: &mut AstKindPath) -> IdentName {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_ident_name(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_ident_name(self, node, ast_path),
        }
    }

    fn fold_if_stmt(&mut self, node: IfStmt, ast_path: &mut AstKindPath) -> IfStmt {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_if_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_if_stmt(self, node, ast_path),
        }
    }

    fn fold_import(&mut self, node: Import, ast_path: &mut AstKindPath) -> Import {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_import(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_import(self, node, ast_path),
        }
    }

    fn fold_import_decl(&mut self, node: ImportDecl, ast_path: &mut AstKindPath) -> ImportDecl {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_import_decl(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_import_decl(self, node, ast_path)
            }
        }
    }

    fn fold_import_default_specifier(
        &mut self,
        node: ImportDefaultSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ImportDefaultSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_import_default_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_import_default_specifier(self, node, ast_path)
            }
        }
    }

    fn fold_import_named_specifier(
        &mut self,
        node: ImportNamedSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ImportNamedSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_import_named_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_import_named_specifier(self, node, ast_path)
            }
        }
    }

    fn fold_import_phase(&mut self, node: ImportPhase, ast_path: &mut AstKindPath) -> ImportPhase {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_import_phase(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_import_phase(self, node, ast_path)
            }
        }
    }

    fn fold_import_specifier(
        &mut self,
        node: ImportSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ImportSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_import_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_import_specifier(self, node, ast_path)
            }
        }
    }

    fn fold_import_specifiers(
        &mut self,
        node: Vec<ImportSpecifier>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ImportSpecifier> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_import_specifiers(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_import_specifiers(self, node, ast_path)
            }
        }
    }

    fn fold_import_star_as_specifier(
        &mut self,
        node: ImportStarAsSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ImportStarAsSpecifier {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_import_star_as_specifier(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_import_star_as_specifier(self, node, ast_path)
            }
        }
    }

    fn fold_import_with(&mut self, node: ImportWith, ast_path: &mut AstKindPath) -> ImportWith {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_import_with(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_import_with(self, node, ast_path)
            }
        }
    }

    fn fold_import_with_item(
        &mut self,
        node: ImportWithItem,
        ast_path: &mut AstKindPath,
    ) -> ImportWithItem {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_import_with_item(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_import_with_item(self, node, ast_path)
            }
        }
    }

    fn fold_import_with_items(
        &mut self,
        node: Vec<ImportWithItem>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ImportWithItem> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_import_with_items(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_import_with_items(self, node, ast_path)
            }
        }
    }

    fn fold_invalid(&mut self, node: Invalid, ast_path: &mut AstKindPath) -> Invalid {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_invalid(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_invalid(self, node, ast_path),
        }
    }

    fn fold_jsx_attr(&mut self, node: JSXAttr, ast_path: &mut AstKindPath) -> JSXAttr {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_jsx_attr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_jsx_attr(self, node, ast_path),
        }
    }

    fn fold_jsx_attr_name(&mut self, node: JSXAttrName, ast_path: &mut AstKindPath) -> JSXAttrName {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_attr_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_attr_name(self, node, ast_path)
            }
        }
    }

    fn fold_jsx_attr_or_spread(
        &mut self,
        node: JSXAttrOrSpread,
        ast_path: &mut AstKindPath,
    ) -> JSXAttrOrSpread {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_attr_or_spread(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_attr_or_spread(self, node, ast_path)
            }
        }
    }

    fn fold_jsx_attr_or_spreads(
        &mut self,
        node: Vec<JSXAttrOrSpread>,
        ast_path: &mut AstKindPath,
    ) -> Vec<JSXAttrOrSpread> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_attr_or_spreads(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_attr_or_spreads(self, node, ast_path)
            }
        }
    }

    fn fold_jsx_attr_value(
        &mut self,
        node: JSXAttrValue,
        ast_path: &mut AstKindPath,
    ) -> JSXAttrValue {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_attr_value(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_attr_value(self, node, ast_path)
            }
        }
    }

    fn fold_jsx_closing_element(
        &mut self,
        node: JSXClosingElement,
        ast_path: &mut AstKindPath,
    ) -> JSXClosingElement {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_closing_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_closing_element(self, node, ast_path)
            }
        }
    }

    fn fold_jsx_closing_fragment(
        &mut self,
        node: JSXClosingFragment,
        ast_path: &mut AstKindPath,
    ) -> JSXClosingFragment {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_closing_fragment(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_closing_fragment(self, node, ast_path)
            }
        }
    }

    fn fold_jsx_element(&mut self, node: JSXElement, ast_path: &mut AstKindPath) -> JSXElement {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_jsx_element(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_element(self, node, ast_path)
            }
        }
    }

    fn fold_jsx_element_child(
        &mut self,
        node: JSXElementChild,
        ast_path: &mut AstKindPath,
    ) -> JSXElementChild {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_element_child(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_element_child(self, node, ast_path)
            }
        }
    }

    fn fold_jsx_element_childs(
        &mut self,
        node: Vec<JSXElementChild>,
        ast_path: &mut AstKindPath,
    ) -> Vec<JSXElementChild> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_element_childs(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_element_childs(self, node, ast_path)
            }
        }
    }

    fn fold_jsx_element_name(
        &mut self,
        node: JSXElementName,
        ast_path: &mut AstKindPath,
    ) -> JSXElementName {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_element_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_element_name(self, node, ast_path)
            }
        }
    }

    fn fold_jsx_empty_expr(
        &mut self,
        node: JSXEmptyExpr,
        ast_path: &mut AstKindPath,
    ) -> JSXEmptyExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_empty_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_empty_expr(self, node, ast_path)
            }
        }
    }

    fn fold_jsx_expr(&mut self, node: JSXExpr, ast_path: &mut AstKindPath) -> JSXExpr {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_jsx_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_jsx_expr(self, node, ast_path),
        }
    }

    fn fold_jsx_expr_container(
        &mut self,
        node: JSXExprContainer,
        ast_path: &mut AstKindPath,
    ) -> JSXExprContainer {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_expr_container(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_expr_container(self, node, ast_path)
            }
        }
    }

    fn fold_jsx_fragment(&mut self, node: JSXFragment, ast_path: &mut AstKindPath) -> JSXFragment {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_fragment(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_fragment(self, node, ast_path)
            }
        }
    }

    fn fold_jsx_member_expr(
        &mut self,
        node: JSXMemberExpr,
        ast_path: &mut AstKindPath,
    ) -> JSXMemberExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_member_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_member_expr(self, node, ast_path)
            }
        }
    }

    fn fold_jsx_namespaced_name(
        &mut self,
        node: JSXNamespacedName,
        ast_path: &mut AstKindPath,
    ) -> JSXNamespacedName {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_namespaced_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_namespaced_name(self, node, ast_path)
            }
        }
    }

    fn fold_jsx_object(&mut self, node: JSXObject, ast_path: &mut AstKindPath) -> JSXObject {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_jsx_object(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_jsx_object(self, node, ast_path),
        }
    }

    fn fold_jsx_opening_element(
        &mut self,
        node: JSXOpeningElement,
        ast_path: &mut AstKindPath,
    ) -> JSXOpeningElement {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_opening_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_opening_element(self, node, ast_path)
            }
        }
    }

    fn fold_jsx_opening_fragment(
        &mut self,
        node: JSXOpeningFragment,
        ast_path: &mut AstKindPath,
    ) -> JSXOpeningFragment {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_opening_fragment(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_opening_fragment(self, node, ast_path)
            }
        }
    }

    fn fold_jsx_spread_child(
        &mut self,
        node: JSXSpreadChild,
        ast_path: &mut AstKindPath,
    ) -> JSXSpreadChild {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_jsx_spread_child(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_jsx_spread_child(self, node, ast_path)
            }
        }
    }

    fn fold_jsx_text(&mut self, node: JSXText, ast_path: &mut AstKindPath) -> JSXText {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_jsx_text(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_jsx_text(self, node, ast_path),
        }
    }

    fn fold_key(&mut self, node: Key, ast_path: &mut AstKindPath) -> Key {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_key(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_key(self, node, ast_path),
        }
    }

    fn fold_key_value_pat_prop(
        &mut self,
        node: KeyValuePatProp,
        ast_path: &mut AstKindPath,
    ) -> KeyValuePatProp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_key_value_pat_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_key_value_pat_prop(self, node, ast_path)
            }
        }
    }

    fn fold_key_value_prop(
        &mut self,
        node: KeyValueProp,
        ast_path: &mut AstKindPath,
    ) -> KeyValueProp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_key_value_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_key_value_prop(self, node, ast_path)
            }
        }
    }

    fn fold_labeled_stmt(&mut self, node: LabeledStmt, ast_path: &mut AstKindPath) -> LabeledStmt {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_labeled_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_labeled_stmt(self, node, ast_path)
            }
        }
    }

    fn fold_lit(&mut self, node: Lit, ast_path: &mut AstKindPath) -> Lit {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_lit(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_lit(self, node, ast_path),
        }
    }

    fn fold_member_expr(&mut self, node: MemberExpr, ast_path: &mut AstKindPath) -> MemberExpr {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_member_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_member_expr(self, node, ast_path)
            }
        }
    }

    fn fold_member_prop(&mut self, node: MemberProp, ast_path: &mut AstKindPath) -> MemberProp {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_member_prop(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_member_prop(self, node, ast_path)
            }
        }
    }

    fn fold_meta_prop_expr(
        &mut self,
        node: MetaPropExpr,
        ast_path: &mut AstKindPath,
    ) -> MetaPropExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_meta_prop_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_meta_prop_expr(self, node, ast_path)
            }
        }
    }

    fn fold_meta_prop_kind(
        &mut self,
        node: MetaPropKind,
        ast_path: &mut AstKindPath,
    ) -> MetaPropKind {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_meta_prop_kind(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_meta_prop_kind(self, node, ast_path)
            }
        }
    }

    fn fold_method_kind(&mut self, node: MethodKind, ast_path: &mut AstKindPath) -> MethodKind {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_method_kind(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_method_kind(self, node, ast_path)
            }
        }
    }

    fn fold_method_prop(&mut self, node: MethodProp, ast_path: &mut AstKindPath) -> MethodProp {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_method_prop(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_method_prop(self, node, ast_path)
            }
        }
    }

    fn fold_module(&mut self, node: Module, ast_path: &mut AstKindPath) -> Module {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_module(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_module(self, node, ast_path),
        }
    }

    fn fold_module_decl(&mut self, node: ModuleDecl, ast_path: &mut AstKindPath) -> ModuleDecl {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_module_decl(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_module_decl(self, node, ast_path)
            }
        }
    }

    fn fold_module_export_name(
        &mut self,
        node: ModuleExportName,
        ast_path: &mut AstKindPath,
    ) -> ModuleExportName {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_module_export_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_module_export_name(self, node, ast_path)
            }
        }
    }

    fn fold_module_item(&mut self, node: ModuleItem, ast_path: &mut AstKindPath) -> ModuleItem {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_module_item(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_module_item(self, node, ast_path)
            }
        }
    }

    fn fold_module_items(
        &mut self,
        node: Vec<ModuleItem>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ModuleItem> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_module_items(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_module_items(self, node, ast_path)
            }
        }
    }

    fn fold_named_export(&mut self, node: NamedExport, ast_path: &mut AstKindPath) -> NamedExport {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_named_export(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_named_export(self, node, ast_path)
            }
        }
    }

    fn fold_new_expr(&mut self, node: NewExpr, ast_path: &mut AstKindPath) -> NewExpr {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_new_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_new_expr(self, node, ast_path),
        }
    }

    fn fold_null(&mut self, node: Null, ast_path: &mut AstKindPath) -> Null {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_null(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_null(self, node, ast_path),
        }
    }

    fn fold_number(&mut self, node: Number, ast_path: &mut AstKindPath) -> Number {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_number(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_number(self, node, ast_path),
        }
    }

    fn fold_object_lit(&mut self, node: ObjectLit, ast_path: &mut AstKindPath) -> ObjectLit {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_object_lit(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_object_lit(self, node, ast_path),
        }
    }

    fn fold_object_pat(&mut self, node: ObjectPat, ast_path: &mut AstKindPath) -> ObjectPat {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_object_pat(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_object_pat(self, node, ast_path),
        }
    }

    fn fold_object_pat_prop(
        &mut self,
        node: ObjectPatProp,
        ast_path: &mut AstKindPath,
    ) -> ObjectPatProp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_object_pat_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_object_pat_prop(self, node, ast_path)
            }
        }
    }

    fn fold_object_pat_props(
        &mut self,
        node: Vec<ObjectPatProp>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ObjectPatProp> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_object_pat_props(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_object_pat_props(self, node, ast_path)
            }
        }
    }

    fn fold_opt_accessibility(
        &mut self,
        node: Option<Accessibility>,
        ast_path: &mut AstKindPath,
    ) -> Option<Accessibility> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_accessibility(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_accessibility(self, node, ast_path)
            }
        }
    }

    fn fold_opt_atom(
        &mut self,
        node: Option<swc_atoms::Atom>,
        ast_path: &mut AstKindPath,
    ) -> Option<swc_atoms::Atom> {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_opt_atom(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_opt_atom(self, node, ast_path),
        }
    }

    fn fold_opt_block_stmt(
        &mut self,
        node: Option<BlockStmt>,
        ast_path: &mut AstKindPath,
    ) -> Option<BlockStmt> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_block_stmt(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_block_stmt(self, node, ast_path)
            }
        }
    }

    fn fold_opt_call(&mut self, node: OptCall, ast_path: &mut AstKindPath) -> OptCall {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_opt_call(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_opt_call(self, node, ast_path),
        }
    }

    fn fold_opt_catch_clause(
        &mut self,
        node: Option<CatchClause>,
        ast_path: &mut AstKindPath,
    ) -> Option<CatchClause> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_catch_clause(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_catch_clause(self, node, ast_path)
            }
        }
    }

    fn fold_opt_chain_base(
        &mut self,
        node: OptChainBase,
        ast_path: &mut AstKindPath,
    ) -> OptChainBase {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_chain_base(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_chain_base(self, node, ast_path)
            }
        }
    }

    fn fold_opt_chain_expr(
        &mut self,
        node: OptChainExpr,
        ast_path: &mut AstKindPath,
    ) -> OptChainExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_chain_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_chain_expr(self, node, ast_path)
            }
        }
    }

    fn fold_opt_expr(
        &mut self,
        node: Option<Box<Expr>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<Expr>> {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_opt_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_opt_expr(self, node, ast_path),
        }
    }

    fn fold_opt_expr_or_spread(
        &mut self,
        node: Option<ExprOrSpread>,
        ast_path: &mut AstKindPath,
    ) -> Option<ExprOrSpread> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_expr_or_spread(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_expr_or_spread(self, node, ast_path)
            }
        }
    }

    fn fold_opt_expr_or_spreads(
        &mut self,
        node: Option<Vec<ExprOrSpread>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Vec<ExprOrSpread>> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_expr_or_spreads(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_expr_or_spreads(self, node, ast_path)
            }
        }
    }

    fn fold_opt_ident(&mut self, node: Option<Ident>, ast_path: &mut AstKindPath) -> Option<Ident> {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_opt_ident(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_opt_ident(self, node, ast_path),
        }
    }

    fn fold_opt_jsx_attr_value(
        &mut self,
        node: Option<JSXAttrValue>,
        ast_path: &mut AstKindPath,
    ) -> Option<JSXAttrValue> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_jsx_attr_value(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_jsx_attr_value(self, node, ast_path)
            }
        }
    }

    fn fold_opt_jsx_closing_element(
        &mut self,
        node: Option<JSXClosingElement>,
        ast_path: &mut AstKindPath,
    ) -> Option<JSXClosingElement> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_jsx_closing_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_jsx_closing_element(self, node, ast_path)
            }
        }
    }

    fn fold_opt_module_export_name(
        &mut self,
        node: Option<ModuleExportName>,
        ast_path: &mut AstKindPath,
    ) -> Option<ModuleExportName> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_module_export_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_module_export_name(self, node, ast_path)
            }
        }
    }

    fn fold_opt_module_items(
        &mut self,
        node: Option<Vec<ModuleItem>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Vec<ModuleItem>> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_module_items(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_module_items(self, node, ast_path)
            }
        }
    }

    fn fold_opt_object_lit(
        &mut self,
        node: Option<Box<ObjectLit>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<ObjectLit>> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_object_lit(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_object_lit(self, node, ast_path)
            }
        }
    }

    fn fold_opt_pat(&mut self, node: Option<Pat>, ast_path: &mut AstKindPath) -> Option<Pat> {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_opt_pat(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_opt_pat(self, node, ast_path),
        }
    }

    fn fold_opt_span(
        &mut self,
        node: Option<swc_common::Span>,
        ast_path: &mut AstKindPath,
    ) -> Option<swc_common::Span> {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_opt_span(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_opt_span(self, node, ast_path),
        }
    }

    fn fold_opt_stmt(
        &mut self,
        node: Option<Box<Stmt>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<Stmt>> {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_opt_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_opt_stmt(self, node, ast_path),
        }
    }

    fn fold_opt_str(
        &mut self,
        node: Option<Box<Str>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<Str>> {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_opt_str(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_opt_str(self, node, ast_path),
        }
    }

    fn fold_opt_true_plus_minus(
        &mut self,
        node: Option<TruePlusMinus>,
        ast_path: &mut AstKindPath,
    ) -> Option<TruePlusMinus> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_true_plus_minus(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_true_plus_minus(self, node, ast_path)
            }
        }
    }

    fn fold_opt_ts_entity_name(
        &mut self,
        node: Option<TsEntityName>,
        ast_path: &mut AstKindPath,
    ) -> Option<TsEntityName> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_ts_entity_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_ts_entity_name(self, node, ast_path)
            }
        }
    }

    fn fold_opt_ts_namespace_body(
        &mut self,
        node: Option<TsNamespaceBody>,
        ast_path: &mut AstKindPath,
    ) -> Option<TsNamespaceBody> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_ts_namespace_body(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_ts_namespace_body(self, node, ast_path)
            }
        }
    }

    fn fold_opt_ts_type(
        &mut self,
        node: Option<Box<TsType>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<TsType>> {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_opt_ts_type(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_ts_type(self, node, ast_path)
            }
        }
    }

    fn fold_opt_ts_type_ann(
        &mut self,
        node: Option<Box<TsTypeAnn>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<TsTypeAnn>> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_ts_type_ann(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_ts_type_ann(self, node, ast_path)
            }
        }
    }

    fn fold_opt_ts_type_param_decl(
        &mut self,
        node: Option<Box<TsTypeParamDecl>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<TsTypeParamDecl>> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_ts_type_param_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_ts_type_param_decl(self, node, ast_path)
            }
        }
    }

    fn fold_opt_ts_type_param_instantiation(
        &mut self,
        node: Option<Box<TsTypeParamInstantiation>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<TsTypeParamInstantiation>> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_ts_type_param_instantiation(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_ts_type_param_instantiation(self, node, ast_path)
            }
        }
    }

    fn fold_opt_var_decl_or_expr(
        &mut self,
        node: Option<VarDeclOrExpr>,
        ast_path: &mut AstKindPath,
    ) -> Option<VarDeclOrExpr> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_var_decl_or_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_var_decl_or_expr(self, node, ast_path)
            }
        }
    }

    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        node: Vec<Option<ExprOrSpread>>,
        ast_path: &mut AstKindPath,
    ) -> Vec<Option<ExprOrSpread>> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_vec_expr_or_spreads(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_vec_expr_or_spreads(self, node, ast_path)
            }
        }
    }

    fn fold_opt_vec_pats(
        &mut self,
        node: Vec<Option<Pat>>,
        ast_path: &mut AstKindPath,
    ) -> Vec<Option<Pat>> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_opt_vec_pats(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_opt_vec_pats(self, node, ast_path)
            }
        }
    }

    fn fold_param(&mut self, node: Param, ast_path: &mut AstKindPath) -> Param {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_param(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_param(self, node, ast_path),
        }
    }

    fn fold_param_or_ts_param_prop(
        &mut self,
        node: ParamOrTsParamProp,
        ast_path: &mut AstKindPath,
    ) -> ParamOrTsParamProp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_param_or_ts_param_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_param_or_ts_param_prop(self, node, ast_path)
            }
        }
    }

    fn fold_param_or_ts_param_props(
        &mut self,
        node: Vec<ParamOrTsParamProp>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ParamOrTsParamProp> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_param_or_ts_param_props(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_param_or_ts_param_props(self, node, ast_path)
            }
        }
    }

    fn fold_params(&mut self, node: Vec<Param>, ast_path: &mut AstKindPath) -> Vec<Param> {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_params(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_params(self, node, ast_path),
        }
    }

    fn fold_paren_expr(&mut self, node: ParenExpr, ast_path: &mut AstKindPath) -> ParenExpr {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_paren_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_paren_expr(self, node, ast_path),
        }
    }

    fn fold_pat(&mut self, node: Pat, ast_path: &mut AstKindPath) -> Pat {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_pat(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_pat(self, node, ast_path),
        }
    }

    fn fold_pats(&mut self, node: Vec<Pat>, ast_path: &mut AstKindPath) -> Vec<Pat> {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_pats(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_pats(self, node, ast_path),
        }
    }

    fn fold_private_method(
        &mut self,
        node: PrivateMethod,
        ast_path: &mut AstKindPath,
    ) -> PrivateMethod {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_private_method(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_private_method(self, node, ast_path)
            }
        }
    }

    fn fold_private_name(&mut self, node: PrivateName, ast_path: &mut AstKindPath) -> PrivateName {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_private_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_private_name(self, node, ast_path)
            }
        }
    }

    fn fold_private_prop(&mut self, node: PrivateProp, ast_path: &mut AstKindPath) -> PrivateProp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_private_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_private_prop(self, node, ast_path)
            }
        }
    }

    fn fold_program(&mut self, node: Program, ast_path: &mut AstKindPath) -> Program {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_program(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_program(self, node, ast_path),
        }
    }

    fn fold_prop(&mut self, node: Prop, ast_path: &mut AstKindPath) -> Prop {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_prop(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_prop(self, node, ast_path),
        }
    }

    fn fold_prop_name(&mut self, node: PropName, ast_path: &mut AstKindPath) -> PropName {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_prop_name(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_prop_name(self, node, ast_path),
        }
    }

    fn fold_prop_or_spread(
        &mut self,
        node: PropOrSpread,
        ast_path: &mut AstKindPath,
    ) -> PropOrSpread {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_prop_or_spread(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_prop_or_spread(self, node, ast_path)
            }
        }
    }

    fn fold_prop_or_spreads(
        &mut self,
        node: Vec<PropOrSpread>,
        ast_path: &mut AstKindPath,
    ) -> Vec<PropOrSpread> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_prop_or_spreads(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_prop_or_spreads(self, node, ast_path)
            }
        }
    }

    fn fold_regex(&mut self, node: Regex, ast_path: &mut AstKindPath) -> Regex {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_regex(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_regex(self, node, ast_path),
        }
    }

    fn fold_reserved_unused(
        &mut self,
        node: ReservedUnused,
        ast_path: &mut AstKindPath,
    ) -> ReservedUnused {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_reserved_unused(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_reserved_unused(self, node, ast_path)
            }
        }
    }

    fn fold_rest_pat(&mut self, node: RestPat, ast_path: &mut AstKindPath) -> RestPat {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_rest_pat(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_rest_pat(self, node, ast_path),
        }
    }

    fn fold_return_stmt(&mut self, node: ReturnStmt, ast_path: &mut AstKindPath) -> ReturnStmt {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_return_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_return_stmt(self, node, ast_path)
            }
        }
    }

    fn fold_script(&mut self, node: Script, ast_path: &mut AstKindPath) -> Script {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_script(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_script(self, node, ast_path),
        }
    }

    fn fold_seq_expr(&mut self, node: SeqExpr, ast_path: &mut AstKindPath) -> SeqExpr {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_seq_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_seq_expr(self, node, ast_path),
        }
    }

    fn fold_setter_prop(&mut self, node: SetterProp, ast_path: &mut AstKindPath) -> SetterProp {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_setter_prop(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_setter_prop(self, node, ast_path)
            }
        }
    }

    fn fold_simple_assign_target(
        &mut self,
        node: SimpleAssignTarget,
        ast_path: &mut AstKindPath,
    ) -> SimpleAssignTarget {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_simple_assign_target(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_simple_assign_target(self, node, ast_path)
            }
        }
    }

    fn fold_span(
        &mut self,
        node: swc_common::Span,
        ast_path: &mut AstKindPath,
    ) -> swc_common::Span {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_span(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_span(self, node, ast_path),
        }
    }

    fn fold_spread_element(
        &mut self,
        node: SpreadElement,
        ast_path: &mut AstKindPath,
    ) -> SpreadElement {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_spread_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_spread_element(self, node, ast_path)
            }
        }
    }

    fn fold_static_block(&mut self, node: StaticBlock, ast_path: &mut AstKindPath) -> StaticBlock {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_static_block(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_static_block(self, node, ast_path)
            }
        }
    }

    fn fold_stmt(&mut self, node: Stmt, ast_path: &mut AstKindPath) -> Stmt {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_stmt(self, node, ast_path),
        }
    }

    fn fold_stmts(&mut self, node: Vec<Stmt>, ast_path: &mut AstKindPath) -> Vec<Stmt> {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_stmts(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_stmts(self, node, ast_path),
        }
    }

    fn fold_str(&mut self, node: Str, ast_path: &mut AstKindPath) -> Str {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_str(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_str(self, node, ast_path),
        }
    }

    fn fold_super(&mut self, node: Super, ast_path: &mut AstKindPath) -> Super {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_super(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_super(self, node, ast_path),
        }
    }

    fn fold_super_prop(&mut self, node: SuperProp, ast_path: &mut AstKindPath) -> SuperProp {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_super_prop(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_super_prop(self, node, ast_path),
        }
    }

    fn fold_super_prop_expr(
        &mut self,
        node: SuperPropExpr,
        ast_path: &mut AstKindPath,
    ) -> SuperPropExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_super_prop_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_super_prop_expr(self, node, ast_path)
            }
        }
    }

    fn fold_switch_case(&mut self, node: SwitchCase, ast_path: &mut AstKindPath) -> SwitchCase {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_switch_case(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_switch_case(self, node, ast_path)
            }
        }
    }

    fn fold_switch_cases(
        &mut self,
        node: Vec<SwitchCase>,
        ast_path: &mut AstKindPath,
    ) -> Vec<SwitchCase> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_switch_cases(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_switch_cases(self, node, ast_path)
            }
        }
    }

    fn fold_switch_stmt(&mut self, node: SwitchStmt, ast_path: &mut AstKindPath) -> SwitchStmt {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_switch_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_switch_stmt(self, node, ast_path)
            }
        }
    }

    fn fold_syntax_context(
        &mut self,
        node: swc_common::SyntaxContext,
        ast_path: &mut AstKindPath,
    ) -> swc_common::SyntaxContext {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_syntax_context(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_syntax_context(self, node, ast_path)
            }
        }
    }

    fn fold_tagged_tpl(&mut self, node: TaggedTpl, ast_path: &mut AstKindPath) -> TaggedTpl {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_tagged_tpl(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_tagged_tpl(self, node, ast_path),
        }
    }

    fn fold_this_expr(&mut self, node: ThisExpr, ast_path: &mut AstKindPath) -> ThisExpr {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_this_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_this_expr(self, node, ast_path),
        }
    }

    fn fold_throw_stmt(&mut self, node: ThrowStmt, ast_path: &mut AstKindPath) -> ThrowStmt {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_throw_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_throw_stmt(self, node, ast_path),
        }
    }

    fn fold_tpl(&mut self, node: Tpl, ast_path: &mut AstKindPath) -> Tpl {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_tpl(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_tpl(self, node, ast_path),
        }
    }

    fn fold_tpl_element(&mut self, node: TplElement, ast_path: &mut AstKindPath) -> TplElement {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_tpl_element(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_tpl_element(self, node, ast_path)
            }
        }
    }

    fn fold_tpl_elements(
        &mut self,
        node: Vec<TplElement>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TplElement> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_tpl_elements(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_tpl_elements(self, node, ast_path)
            }
        }
    }

    fn fold_true_plus_minus(
        &mut self,
        node: TruePlusMinus,
        ast_path: &mut AstKindPath,
    ) -> TruePlusMinus {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_true_plus_minus(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_true_plus_minus(self, node, ast_path)
            }
        }
    }

    fn fold_try_stmt(&mut self, node: TryStmt, ast_path: &mut AstKindPath) -> TryStmt {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_try_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_try_stmt(self, node, ast_path),
        }
    }

    fn fold_ts_array_type(&mut self, node: TsArrayType, ast_path: &mut AstKindPath) -> TsArrayType {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_array_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_array_type(self, node, ast_path)
            }
        }
    }

    fn fold_ts_as_expr(&mut self, node: TsAsExpr, ast_path: &mut AstKindPath) -> TsAsExpr {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_ts_as_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_ts_as_expr(self, node, ast_path),
        }
    }

    fn fold_ts_call_signature_decl(
        &mut self,
        node: TsCallSignatureDecl,
        ast_path: &mut AstKindPath,
    ) -> TsCallSignatureDecl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_call_signature_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_call_signature_decl(self, node, ast_path)
            }
        }
    }

    fn fold_ts_conditional_type(
        &mut self,
        node: TsConditionalType,
        ast_path: &mut AstKindPath,
    ) -> TsConditionalType {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_conditional_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_conditional_type(self, node, ast_path)
            }
        }
    }

    fn fold_ts_const_assertion(
        &mut self,
        node: TsConstAssertion,
        ast_path: &mut AstKindPath,
    ) -> TsConstAssertion {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_const_assertion(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_const_assertion(self, node, ast_path)
            }
        }
    }

    fn fold_ts_construct_signature_decl(
        &mut self,
        node: TsConstructSignatureDecl,
        ast_path: &mut AstKindPath,
    ) -> TsConstructSignatureDecl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_construct_signature_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_construct_signature_decl(self, node, ast_path)
            }
        }
    }

    fn fold_ts_constructor_type(
        &mut self,
        node: TsConstructorType,
        ast_path: &mut AstKindPath,
    ) -> TsConstructorType {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_constructor_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_constructor_type(self, node, ast_path)
            }
        }
    }

    fn fold_ts_entity_name(
        &mut self,
        node: TsEntityName,
        ast_path: &mut AstKindPath,
    ) -> TsEntityName {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_entity_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_entity_name(self, node, ast_path)
            }
        }
    }

    fn fold_ts_enum_decl(&mut self, node: TsEnumDecl, ast_path: &mut AstKindPath) -> TsEnumDecl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_enum_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_enum_decl(self, node, ast_path)
            }
        }
    }

    fn fold_ts_enum_member(
        &mut self,
        node: TsEnumMember,
        ast_path: &mut AstKindPath,
    ) -> TsEnumMember {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_enum_member(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_enum_member(self, node, ast_path)
            }
        }
    }

    fn fold_ts_enum_member_id(
        &mut self,
        node: TsEnumMemberId,
        ast_path: &mut AstKindPath,
    ) -> TsEnumMemberId {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_enum_member_id(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_enum_member_id(self, node, ast_path)
            }
        }
    }

    fn fold_ts_enum_members(
        &mut self,
        node: Vec<TsEnumMember>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsEnumMember> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_enum_members(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_enum_members(self, node, ast_path)
            }
        }
    }

    fn fold_ts_export_assignment(
        &mut self,
        node: TsExportAssignment,
        ast_path: &mut AstKindPath,
    ) -> TsExportAssignment {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_export_assignment(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_export_assignment(self, node, ast_path)
            }
        }
    }

    fn fold_ts_expr_with_type_args(
        &mut self,
        node: TsExprWithTypeArgs,
        ast_path: &mut AstKindPath,
    ) -> TsExprWithTypeArgs {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_expr_with_type_args(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_expr_with_type_args(self, node, ast_path)
            }
        }
    }

    fn fold_ts_expr_with_type_argss(
        &mut self,
        node: Vec<TsExprWithTypeArgs>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsExprWithTypeArgs> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_expr_with_type_argss(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_expr_with_type_argss(self, node, ast_path)
            }
        }
    }

    fn fold_ts_external_module_ref(
        &mut self,
        node: TsExternalModuleRef,
        ast_path: &mut AstKindPath,
    ) -> TsExternalModuleRef {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_external_module_ref(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_external_module_ref(self, node, ast_path)
            }
        }
    }

    fn fold_ts_fn_or_constructor_type(
        &mut self,
        node: TsFnOrConstructorType,
        ast_path: &mut AstKindPath,
    ) -> TsFnOrConstructorType {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_fn_or_constructor_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_fn_or_constructor_type(self, node, ast_path)
            }
        }
    }

    fn fold_ts_fn_param(&mut self, node: TsFnParam, ast_path: &mut AstKindPath) -> TsFnParam {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_ts_fn_param(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_fn_param(self, node, ast_path)
            }
        }
    }

    fn fold_ts_fn_params(
        &mut self,
        node: Vec<TsFnParam>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsFnParam> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_fn_params(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_fn_params(self, node, ast_path)
            }
        }
    }

    fn fold_ts_fn_type(&mut self, node: TsFnType, ast_path: &mut AstKindPath) -> TsFnType {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_ts_fn_type(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_ts_fn_type(self, node, ast_path),
        }
    }

    fn fold_ts_getter_signature(
        &mut self,
        node: TsGetterSignature,
        ast_path: &mut AstKindPath,
    ) -> TsGetterSignature {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_getter_signature(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_getter_signature(self, node, ast_path)
            }
        }
    }

    fn fold_ts_import_equals_decl(
        &mut self,
        node: TsImportEqualsDecl,
        ast_path: &mut AstKindPath,
    ) -> TsImportEqualsDecl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_import_equals_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_import_equals_decl(self, node, ast_path)
            }
        }
    }

    fn fold_ts_import_type(
        &mut self,
        node: TsImportType,
        ast_path: &mut AstKindPath,
    ) -> TsImportType {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_import_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_import_type(self, node, ast_path)
            }
        }
    }

    fn fold_ts_index_signature(
        &mut self,
        node: TsIndexSignature,
        ast_path: &mut AstKindPath,
    ) -> TsIndexSignature {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_index_signature(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_index_signature(self, node, ast_path)
            }
        }
    }

    fn fold_ts_indexed_access_type(
        &mut self,
        node: TsIndexedAccessType,
        ast_path: &mut AstKindPath,
    ) -> TsIndexedAccessType {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_indexed_access_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_indexed_access_type(self, node, ast_path)
            }
        }
    }

    fn fold_ts_infer_type(&mut self, node: TsInferType, ast_path: &mut AstKindPath) -> TsInferType {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_infer_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_infer_type(self, node, ast_path)
            }
        }
    }

    fn fold_ts_instantiation(
        &mut self,
        node: TsInstantiation,
        ast_path: &mut AstKindPath,
    ) -> TsInstantiation {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_instantiation(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_instantiation(self, node, ast_path)
            }
        }
    }

    fn fold_ts_interface_body(
        &mut self,
        node: TsInterfaceBody,
        ast_path: &mut AstKindPath,
    ) -> TsInterfaceBody {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_interface_body(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_interface_body(self, node, ast_path)
            }
        }
    }

    fn fold_ts_interface_decl(
        &mut self,
        node: TsInterfaceDecl,
        ast_path: &mut AstKindPath,
    ) -> TsInterfaceDecl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_interface_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_interface_decl(self, node, ast_path)
            }
        }
    }

    fn fold_ts_intersection_type(
        &mut self,
        node: TsIntersectionType,
        ast_path: &mut AstKindPath,
    ) -> TsIntersectionType {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_intersection_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_intersection_type(self, node, ast_path)
            }
        }
    }

    fn fold_ts_keyword_type(
        &mut self,
        node: TsKeywordType,
        ast_path: &mut AstKindPath,
    ) -> TsKeywordType {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_keyword_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_keyword_type(self, node, ast_path)
            }
        }
    }

    fn fold_ts_keyword_type_kind(
        &mut self,
        node: TsKeywordTypeKind,
        ast_path: &mut AstKindPath,
    ) -> TsKeywordTypeKind {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_keyword_type_kind(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_keyword_type_kind(self, node, ast_path)
            }
        }
    }

    fn fold_ts_lit(&mut self, node: TsLit, ast_path: &mut AstKindPath) -> TsLit {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_ts_lit(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_ts_lit(self, node, ast_path),
        }
    }

    fn fold_ts_lit_type(&mut self, node: TsLitType, ast_path: &mut AstKindPath) -> TsLitType {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_ts_lit_type(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_lit_type(self, node, ast_path)
            }
        }
    }

    fn fold_ts_mapped_type(
        &mut self,
        node: TsMappedType,
        ast_path: &mut AstKindPath,
    ) -> TsMappedType {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_mapped_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_mapped_type(self, node, ast_path)
            }
        }
    }

    fn fold_ts_method_signature(
        &mut self,
        node: TsMethodSignature,
        ast_path: &mut AstKindPath,
    ) -> TsMethodSignature {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_method_signature(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_method_signature(self, node, ast_path)
            }
        }
    }

    fn fold_ts_module_block(
        &mut self,
        node: TsModuleBlock,
        ast_path: &mut AstKindPath,
    ) -> TsModuleBlock {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_module_block(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_module_block(self, node, ast_path)
            }
        }
    }

    fn fold_ts_module_decl(
        &mut self,
        node: TsModuleDecl,
        ast_path: &mut AstKindPath,
    ) -> TsModuleDecl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_module_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_module_decl(self, node, ast_path)
            }
        }
    }

    fn fold_ts_module_name(
        &mut self,
        node: TsModuleName,
        ast_path: &mut AstKindPath,
    ) -> TsModuleName {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_module_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_module_name(self, node, ast_path)
            }
        }
    }

    fn fold_ts_module_ref(&mut self, node: TsModuleRef, ast_path: &mut AstKindPath) -> TsModuleRef {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_module_ref(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_module_ref(self, node, ast_path)
            }
        }
    }

    fn fold_ts_namespace_body(
        &mut self,
        node: TsNamespaceBody,
        ast_path: &mut AstKindPath,
    ) -> TsNamespaceBody {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_namespace_body(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_namespace_body(self, node, ast_path)
            }
        }
    }

    fn fold_ts_namespace_decl(
        &mut self,
        node: TsNamespaceDecl,
        ast_path: &mut AstKindPath,
    ) -> TsNamespaceDecl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_namespace_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_namespace_decl(self, node, ast_path)
            }
        }
    }

    fn fold_ts_namespace_export_decl(
        &mut self,
        node: TsNamespaceExportDecl,
        ast_path: &mut AstKindPath,
    ) -> TsNamespaceExportDecl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_namespace_export_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_namespace_export_decl(self, node, ast_path)
            }
        }
    }

    fn fold_ts_non_null_expr(
        &mut self,
        node: TsNonNullExpr,
        ast_path: &mut AstKindPath,
    ) -> TsNonNullExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_non_null_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_non_null_expr(self, node, ast_path)
            }
        }
    }

    fn fold_ts_optional_type(
        &mut self,
        node: TsOptionalType,
        ast_path: &mut AstKindPath,
    ) -> TsOptionalType {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_optional_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_optional_type(self, node, ast_path)
            }
        }
    }

    fn fold_ts_param_prop(&mut self, node: TsParamProp, ast_path: &mut AstKindPath) -> TsParamProp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_param_prop(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_param_prop(self, node, ast_path)
            }
        }
    }

    fn fold_ts_param_prop_param(
        &mut self,
        node: TsParamPropParam,
        ast_path: &mut AstKindPath,
    ) -> TsParamPropParam {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_param_prop_param(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_param_prop_param(self, node, ast_path)
            }
        }
    }

    fn fold_ts_parenthesized_type(
        &mut self,
        node: TsParenthesizedType,
        ast_path: &mut AstKindPath,
    ) -> TsParenthesizedType {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_parenthesized_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_parenthesized_type(self, node, ast_path)
            }
        }
    }

    fn fold_ts_property_signature(
        &mut self,
        node: TsPropertySignature,
        ast_path: &mut AstKindPath,
    ) -> TsPropertySignature {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_property_signature(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_property_signature(self, node, ast_path)
            }
        }
    }

    fn fold_ts_qualified_name(
        &mut self,
        node: TsQualifiedName,
        ast_path: &mut AstKindPath,
    ) -> TsQualifiedName {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_qualified_name(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_qualified_name(self, node, ast_path)
            }
        }
    }

    fn fold_ts_rest_type(&mut self, node: TsRestType, ast_path: &mut AstKindPath) -> TsRestType {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_rest_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_rest_type(self, node, ast_path)
            }
        }
    }

    fn fold_ts_satisfies_expr(
        &mut self,
        node: TsSatisfiesExpr,
        ast_path: &mut AstKindPath,
    ) -> TsSatisfiesExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_satisfies_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_satisfies_expr(self, node, ast_path)
            }
        }
    }

    fn fold_ts_setter_signature(
        &mut self,
        node: TsSetterSignature,
        ast_path: &mut AstKindPath,
    ) -> TsSetterSignature {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_setter_signature(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_setter_signature(self, node, ast_path)
            }
        }
    }

    fn fold_ts_this_type(&mut self, node: TsThisType, ast_path: &mut AstKindPath) -> TsThisType {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_this_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_this_type(self, node, ast_path)
            }
        }
    }

    fn fold_ts_this_type_or_ident(
        &mut self,
        node: TsThisTypeOrIdent,
        ast_path: &mut AstKindPath,
    ) -> TsThisTypeOrIdent {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_this_type_or_ident(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_this_type_or_ident(self, node, ast_path)
            }
        }
    }

    fn fold_ts_tpl_lit_type(
        &mut self,
        node: TsTplLitType,
        ast_path: &mut AstKindPath,
    ) -> TsTplLitType {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_tpl_lit_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_tpl_lit_type(self, node, ast_path)
            }
        }
    }

    fn fold_ts_tuple_element(
        &mut self,
        node: TsTupleElement,
        ast_path: &mut AstKindPath,
    ) -> TsTupleElement {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_tuple_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_tuple_element(self, node, ast_path)
            }
        }
    }

    fn fold_ts_tuple_elements(
        &mut self,
        node: Vec<TsTupleElement>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsTupleElement> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_tuple_elements(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_tuple_elements(self, node, ast_path)
            }
        }
    }

    fn fold_ts_tuple_type(&mut self, node: TsTupleType, ast_path: &mut AstKindPath) -> TsTupleType {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_tuple_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_tuple_type(self, node, ast_path)
            }
        }
    }

    fn fold_ts_type(&mut self, node: TsType, ast_path: &mut AstKindPath) -> TsType {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_ts_type(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_ts_type(self, node, ast_path),
        }
    }

    fn fold_ts_type_alias_decl(
        &mut self,
        node: TsTypeAliasDecl,
        ast_path: &mut AstKindPath,
    ) -> TsTypeAliasDecl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_type_alias_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_type_alias_decl(self, node, ast_path)
            }
        }
    }

    fn fold_ts_type_ann(&mut self, node: TsTypeAnn, ast_path: &mut AstKindPath) -> TsTypeAnn {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_ts_type_ann(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_type_ann(self, node, ast_path)
            }
        }
    }

    fn fold_ts_type_assertion(
        &mut self,
        node: TsTypeAssertion,
        ast_path: &mut AstKindPath,
    ) -> TsTypeAssertion {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_type_assertion(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_type_assertion(self, node, ast_path)
            }
        }
    }

    fn fold_ts_type_element(
        &mut self,
        node: TsTypeElement,
        ast_path: &mut AstKindPath,
    ) -> TsTypeElement {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_type_element(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_type_element(self, node, ast_path)
            }
        }
    }

    fn fold_ts_type_elements(
        &mut self,
        node: Vec<TsTypeElement>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsTypeElement> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_type_elements(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_type_elements(self, node, ast_path)
            }
        }
    }

    fn fold_ts_type_lit(&mut self, node: TsTypeLit, ast_path: &mut AstKindPath) -> TsTypeLit {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_ts_type_lit(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_type_lit(self, node, ast_path)
            }
        }
    }

    fn fold_ts_type_operator(
        &mut self,
        node: TsTypeOperator,
        ast_path: &mut AstKindPath,
    ) -> TsTypeOperator {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_type_operator(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_type_operator(self, node, ast_path)
            }
        }
    }

    fn fold_ts_type_operator_op(
        &mut self,
        node: TsTypeOperatorOp,
        ast_path: &mut AstKindPath,
    ) -> TsTypeOperatorOp {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_type_operator_op(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_type_operator_op(self, node, ast_path)
            }
        }
    }

    fn fold_ts_type_param(&mut self, node: TsTypeParam, ast_path: &mut AstKindPath) -> TsTypeParam {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_type_param(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_type_param(self, node, ast_path)
            }
        }
    }

    fn fold_ts_type_param_decl(
        &mut self,
        node: TsTypeParamDecl,
        ast_path: &mut AstKindPath,
    ) -> TsTypeParamDecl {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_type_param_decl(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_type_param_decl(self, node, ast_path)
            }
        }
    }

    fn fold_ts_type_param_instantiation(
        &mut self,
        node: TsTypeParamInstantiation,
        ast_path: &mut AstKindPath,
    ) -> TsTypeParamInstantiation {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_type_param_instantiation(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_type_param_instantiation(self, node, ast_path)
            }
        }
    }

    fn fold_ts_type_params(
        &mut self,
        node: Vec<TsTypeParam>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsTypeParam> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_type_params(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_type_params(self, node, ast_path)
            }
        }
    }

    fn fold_ts_type_predicate(
        &mut self,
        node: TsTypePredicate,
        ast_path: &mut AstKindPath,
    ) -> TsTypePredicate {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_type_predicate(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_type_predicate(self, node, ast_path)
            }
        }
    }

    fn fold_ts_type_query(&mut self, node: TsTypeQuery, ast_path: &mut AstKindPath) -> TsTypeQuery {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_type_query(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_type_query(self, node, ast_path)
            }
        }
    }

    fn fold_ts_type_query_expr(
        &mut self,
        node: TsTypeQueryExpr,
        ast_path: &mut AstKindPath,
    ) -> TsTypeQueryExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_type_query_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_type_query_expr(self, node, ast_path)
            }
        }
    }

    fn fold_ts_type_ref(&mut self, node: TsTypeRef, ast_path: &mut AstKindPath) -> TsTypeRef {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_ts_type_ref(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_type_ref(self, node, ast_path)
            }
        }
    }

    fn fold_ts_types(
        &mut self,
        node: Vec<Box<TsType>>,
        ast_path: &mut AstKindPath,
    ) -> Vec<Box<TsType>> {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_ts_types(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_ts_types(self, node, ast_path),
        }
    }

    fn fold_ts_union_or_intersection_type(
        &mut self,
        node: TsUnionOrIntersectionType,
        ast_path: &mut AstKindPath,
    ) -> TsUnionOrIntersectionType {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_union_or_intersection_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_union_or_intersection_type(self, node, ast_path)
            }
        }
    }

    fn fold_ts_union_type(&mut self, node: TsUnionType, ast_path: &mut AstKindPath) -> TsUnionType {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_ts_union_type(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_ts_union_type(self, node, ast_path)
            }
        }
    }

    fn fold_unary_expr(&mut self, node: UnaryExpr, ast_path: &mut AstKindPath) -> UnaryExpr {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_unary_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_unary_expr(self, node, ast_path),
        }
    }

    fn fold_unary_op(&mut self, node: UnaryOp, ast_path: &mut AstKindPath) -> UnaryOp {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_unary_op(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_unary_op(self, node, ast_path),
        }
    }

    fn fold_update_expr(&mut self, node: UpdateExpr, ast_path: &mut AstKindPath) -> UpdateExpr {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_update_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_update_expr(self, node, ast_path)
            }
        }
    }

    fn fold_update_op(&mut self, node: UpdateOp, ast_path: &mut AstKindPath) -> UpdateOp {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_update_op(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_update_op(self, node, ast_path),
        }
    }

    fn fold_using_decl(&mut self, node: UsingDecl, ast_path: &mut AstKindPath) -> UsingDecl {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_using_decl(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_using_decl(self, node, ast_path),
        }
    }

    fn fold_var_decl(&mut self, node: VarDecl, ast_path: &mut AstKindPath) -> VarDecl {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_var_decl(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_var_decl(self, node, ast_path),
        }
    }

    fn fold_var_decl_kind(&mut self, node: VarDeclKind, ast_path: &mut AstKindPath) -> VarDeclKind {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_var_decl_kind(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_var_decl_kind(self, node, ast_path)
            }
        }
    }

    fn fold_var_decl_or_expr(
        &mut self,
        node: VarDeclOrExpr,
        ast_path: &mut AstKindPath,
    ) -> VarDeclOrExpr {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_var_decl_or_expr(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_var_decl_or_expr(self, node, ast_path)
            }
        }
    }

    fn fold_var_declarator(
        &mut self,
        node: VarDeclarator,
        ast_path: &mut AstKindPath,
    ) -> VarDeclarator {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_var_declarator(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_var_declarator(self, node, ast_path)
            }
        }
    }

    fn fold_var_declarators(
        &mut self,
        node: Vec<VarDeclarator>,
        ast_path: &mut AstKindPath,
    ) -> Vec<VarDeclarator> {
        match self {
            swc_visit::Either::Left(visitor) => {
                FoldAstPath::fold_var_declarators(self, node, ast_path)
            }
            swc_visit::Either::Right(visitor) => {
                FoldAstPath::fold_var_declarators(self, node, ast_path)
            }
        }
    }

    fn fold_while_stmt(&mut self, node: WhileStmt, ast_path: &mut AstKindPath) -> WhileStmt {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_while_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_while_stmt(self, node, ast_path),
        }
    }

    fn fold_with_stmt(&mut self, node: WithStmt, ast_path: &mut AstKindPath) -> WithStmt {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_with_stmt(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_with_stmt(self, node, ast_path),
        }
    }

    fn fold_yield_expr(&mut self, node: YieldExpr, ast_path: &mut AstKindPath) -> YieldExpr {
        match self {
            swc_visit::Either::Left(visitor) => FoldAstPath::fold_yield_expr(self, node, ast_path),
            swc_visit::Either::Right(visitor) => FoldAstPath::fold_yield_expr(self, node, ast_path),
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V> FoldAstPath for ::swc_visit::Optional<V>
where
    V: FoldAstPath,
{
    fn fold_accessibility(
        &mut self,
        node: Accessibility,
        ast_path: &mut AstKindPath,
    ) -> Accessibility {
        if self.enabled {
            FoldAstPath::fold_accessibility(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_array_lit(&mut self, node: ArrayLit, ast_path: &mut AstKindPath) -> ArrayLit {
        if self.enabled {
            FoldAstPath::fold_array_lit(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_array_pat(&mut self, node: ArrayPat, ast_path: &mut AstKindPath) -> ArrayPat {
        if self.enabled {
            FoldAstPath::fold_array_pat(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_arrow_expr(&mut self, node: ArrowExpr, ast_path: &mut AstKindPath) -> ArrowExpr {
        if self.enabled {
            FoldAstPath::fold_arrow_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_assign_expr(&mut self, node: AssignExpr, ast_path: &mut AstKindPath) -> AssignExpr {
        if self.enabled {
            FoldAstPath::fold_assign_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_assign_op(&mut self, node: AssignOp, ast_path: &mut AstKindPath) -> AssignOp {
        if self.enabled {
            FoldAstPath::fold_assign_op(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_assign_pat(&mut self, node: AssignPat, ast_path: &mut AstKindPath) -> AssignPat {
        if self.enabled {
            FoldAstPath::fold_assign_pat(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_assign_pat_prop(
        &mut self,
        node: AssignPatProp,
        ast_path: &mut AstKindPath,
    ) -> AssignPatProp {
        if self.enabled {
            FoldAstPath::fold_assign_pat_prop(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_assign_prop(&mut self, node: AssignProp, ast_path: &mut AstKindPath) -> AssignProp {
        if self.enabled {
            FoldAstPath::fold_assign_prop(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_assign_target(
        &mut self,
        node: AssignTarget,
        ast_path: &mut AstKindPath,
    ) -> AssignTarget {
        if self.enabled {
            FoldAstPath::fold_assign_target(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_assign_target_pat(
        &mut self,
        node: AssignTargetPat,
        ast_path: &mut AstKindPath,
    ) -> AssignTargetPat {
        if self.enabled {
            FoldAstPath::fold_assign_target_pat(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_atom(&mut self, node: swc_atoms::Atom, ast_path: &mut AstKindPath) -> swc_atoms::Atom {
        if self.enabled {
            FoldAstPath::fold_atom(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_auto_accessor(
        &mut self,
        node: AutoAccessor,
        ast_path: &mut AstKindPath,
    ) -> AutoAccessor {
        if self.enabled {
            FoldAstPath::fold_auto_accessor(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_await_expr(&mut self, node: AwaitExpr, ast_path: &mut AstKindPath) -> AwaitExpr {
        if self.enabled {
            FoldAstPath::fold_await_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_big_int(&mut self, node: BigInt, ast_path: &mut AstKindPath) -> BigInt {
        if self.enabled {
            FoldAstPath::fold_big_int(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_big_int_value(&mut self, node: BigIntValue, ast_path: &mut AstKindPath) -> BigIntValue {
        if self.enabled {
            FoldAstPath::fold_big_int_value(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_bin_expr(&mut self, node: BinExpr, ast_path: &mut AstKindPath) -> BinExpr {
        if self.enabled {
            FoldAstPath::fold_bin_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_binary_op(&mut self, node: BinaryOp, ast_path: &mut AstKindPath) -> BinaryOp {
        if self.enabled {
            FoldAstPath::fold_binary_op(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_binding_ident(
        &mut self,
        node: BindingIdent,
        ast_path: &mut AstKindPath,
    ) -> BindingIdent {
        if self.enabled {
            FoldAstPath::fold_binding_ident(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_block_stmt(&mut self, node: BlockStmt, ast_path: &mut AstKindPath) -> BlockStmt {
        if self.enabled {
            FoldAstPath::fold_block_stmt(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_block_stmt_or_expr(
        &mut self,
        node: BlockStmtOrExpr,
        ast_path: &mut AstKindPath,
    ) -> BlockStmtOrExpr {
        if self.enabled {
            FoldAstPath::fold_block_stmt_or_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_bool(&mut self, node: Bool, ast_path: &mut AstKindPath) -> Bool {
        if self.enabled {
            FoldAstPath::fold_bool(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_break_stmt(&mut self, node: BreakStmt, ast_path: &mut AstKindPath) -> BreakStmt {
        if self.enabled {
            FoldAstPath::fold_break_stmt(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_call_expr(&mut self, node: CallExpr, ast_path: &mut AstKindPath) -> CallExpr {
        if self.enabled {
            FoldAstPath::fold_call_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_callee(&mut self, node: Callee, ast_path: &mut AstKindPath) -> Callee {
        if self.enabled {
            FoldAstPath::fold_callee(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_catch_clause(&mut self, node: CatchClause, ast_path: &mut AstKindPath) -> CatchClause {
        if self.enabled {
            FoldAstPath::fold_catch_clause(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_class(&mut self, node: Class, ast_path: &mut AstKindPath) -> Class {
        if self.enabled {
            FoldAstPath::fold_class(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_class_decl(&mut self, node: ClassDecl, ast_path: &mut AstKindPath) -> ClassDecl {
        if self.enabled {
            FoldAstPath::fold_class_decl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_class_expr(&mut self, node: ClassExpr, ast_path: &mut AstKindPath) -> ClassExpr {
        if self.enabled {
            FoldAstPath::fold_class_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_class_member(&mut self, node: ClassMember, ast_path: &mut AstKindPath) -> ClassMember {
        if self.enabled {
            FoldAstPath::fold_class_member(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_class_members(
        &mut self,
        node: Vec<ClassMember>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ClassMember> {
        if self.enabled {
            FoldAstPath::fold_class_members(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_class_method(&mut self, node: ClassMethod, ast_path: &mut AstKindPath) -> ClassMethod {
        if self.enabled {
            FoldAstPath::fold_class_method(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_class_prop(&mut self, node: ClassProp, ast_path: &mut AstKindPath) -> ClassProp {
        if self.enabled {
            FoldAstPath::fold_class_prop(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_computed_prop_name(
        &mut self,
        node: ComputedPropName,
        ast_path: &mut AstKindPath,
    ) -> ComputedPropName {
        if self.enabled {
            FoldAstPath::fold_computed_prop_name(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_cond_expr(&mut self, node: CondExpr, ast_path: &mut AstKindPath) -> CondExpr {
        if self.enabled {
            FoldAstPath::fold_cond_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_constructor(&mut self, node: Constructor, ast_path: &mut AstKindPath) -> Constructor {
        if self.enabled {
            FoldAstPath::fold_constructor(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_continue_stmt(
        &mut self,
        node: ContinueStmt,
        ast_path: &mut AstKindPath,
    ) -> ContinueStmt {
        if self.enabled {
            FoldAstPath::fold_continue_stmt(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_debugger_stmt(
        &mut self,
        node: DebuggerStmt,
        ast_path: &mut AstKindPath,
    ) -> DebuggerStmt {
        if self.enabled {
            FoldAstPath::fold_debugger_stmt(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_decl(&mut self, node: Decl, ast_path: &mut AstKindPath) -> Decl {
        if self.enabled {
            FoldAstPath::fold_decl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_decorator(&mut self, node: Decorator, ast_path: &mut AstKindPath) -> Decorator {
        if self.enabled {
            FoldAstPath::fold_decorator(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_decorators(
        &mut self,
        node: Vec<Decorator>,
        ast_path: &mut AstKindPath,
    ) -> Vec<Decorator> {
        if self.enabled {
            FoldAstPath::fold_decorators(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_default_decl(&mut self, node: DefaultDecl, ast_path: &mut AstKindPath) -> DefaultDecl {
        if self.enabled {
            FoldAstPath::fold_default_decl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_do_while_stmt(&mut self, node: DoWhileStmt, ast_path: &mut AstKindPath) -> DoWhileStmt {
        if self.enabled {
            FoldAstPath::fold_do_while_stmt(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_empty_stmt(&mut self, node: EmptyStmt, ast_path: &mut AstKindPath) -> EmptyStmt {
        if self.enabled {
            FoldAstPath::fold_empty_stmt(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_es_version(&mut self, node: EsVersion, ast_path: &mut AstKindPath) -> EsVersion {
        if self.enabled {
            FoldAstPath::fold_es_version(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_export_all(&mut self, node: ExportAll, ast_path: &mut AstKindPath) -> ExportAll {
        if self.enabled {
            FoldAstPath::fold_export_all(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_export_decl(&mut self, node: ExportDecl, ast_path: &mut AstKindPath) -> ExportDecl {
        if self.enabled {
            FoldAstPath::fold_export_decl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_export_default_decl(
        &mut self,
        node: ExportDefaultDecl,
        ast_path: &mut AstKindPath,
    ) -> ExportDefaultDecl {
        if self.enabled {
            FoldAstPath::fold_export_default_decl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_export_default_expr(
        &mut self,
        node: ExportDefaultExpr,
        ast_path: &mut AstKindPath,
    ) -> ExportDefaultExpr {
        if self.enabled {
            FoldAstPath::fold_export_default_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_export_default_specifier(
        &mut self,
        node: ExportDefaultSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ExportDefaultSpecifier {
        if self.enabled {
            FoldAstPath::fold_export_default_specifier(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_export_named_specifier(
        &mut self,
        node: ExportNamedSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ExportNamedSpecifier {
        if self.enabled {
            FoldAstPath::fold_export_named_specifier(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_export_namespace_specifier(
        &mut self,
        node: ExportNamespaceSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ExportNamespaceSpecifier {
        if self.enabled {
            FoldAstPath::fold_export_namespace_specifier(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_export_specifier(
        &mut self,
        node: ExportSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ExportSpecifier {
        if self.enabled {
            FoldAstPath::fold_export_specifier(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_export_specifiers(
        &mut self,
        node: Vec<ExportSpecifier>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ExportSpecifier> {
        if self.enabled {
            FoldAstPath::fold_export_specifiers(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_expr(&mut self, node: Expr, ast_path: &mut AstKindPath) -> Expr {
        if self.enabled {
            FoldAstPath::fold_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_expr_or_spread(
        &mut self,
        node: ExprOrSpread,
        ast_path: &mut AstKindPath,
    ) -> ExprOrSpread {
        if self.enabled {
            FoldAstPath::fold_expr_or_spread(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_expr_or_spreads(
        &mut self,
        node: Vec<ExprOrSpread>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ExprOrSpread> {
        if self.enabled {
            FoldAstPath::fold_expr_or_spreads(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_expr_stmt(&mut self, node: ExprStmt, ast_path: &mut AstKindPath) -> ExprStmt {
        if self.enabled {
            FoldAstPath::fold_expr_stmt(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_exprs(&mut self, node: Vec<Box<Expr>>, ast_path: &mut AstKindPath) -> Vec<Box<Expr>> {
        if self.enabled {
            FoldAstPath::fold_exprs(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_fn_decl(&mut self, node: FnDecl, ast_path: &mut AstKindPath) -> FnDecl {
        if self.enabled {
            FoldAstPath::fold_fn_decl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_fn_expr(&mut self, node: FnExpr, ast_path: &mut AstKindPath) -> FnExpr {
        if self.enabled {
            FoldAstPath::fold_fn_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_for_head(&mut self, node: ForHead, ast_path: &mut AstKindPath) -> ForHead {
        if self.enabled {
            FoldAstPath::fold_for_head(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_for_in_stmt(&mut self, node: ForInStmt, ast_path: &mut AstKindPath) -> ForInStmt {
        if self.enabled {
            FoldAstPath::fold_for_in_stmt(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_for_of_stmt(&mut self, node: ForOfStmt, ast_path: &mut AstKindPath) -> ForOfStmt {
        if self.enabled {
            FoldAstPath::fold_for_of_stmt(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_for_stmt(&mut self, node: ForStmt, ast_path: &mut AstKindPath) -> ForStmt {
        if self.enabled {
            FoldAstPath::fold_for_stmt(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_function(&mut self, node: Function, ast_path: &mut AstKindPath) -> Function {
        if self.enabled {
            FoldAstPath::fold_function(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_getter_prop(&mut self, node: GetterProp, ast_path: &mut AstKindPath) -> GetterProp {
        if self.enabled {
            FoldAstPath::fold_getter_prop(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ident(&mut self, node: Ident, ast_path: &mut AstKindPath) -> Ident {
        if self.enabled {
            FoldAstPath::fold_ident(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ident_name(&mut self, node: IdentName, ast_path: &mut AstKindPath) -> IdentName {
        if self.enabled {
            FoldAstPath::fold_ident_name(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_if_stmt(&mut self, node: IfStmt, ast_path: &mut AstKindPath) -> IfStmt {
        if self.enabled {
            FoldAstPath::fold_if_stmt(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_import(&mut self, node: Import, ast_path: &mut AstKindPath) -> Import {
        if self.enabled {
            FoldAstPath::fold_import(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_import_decl(&mut self, node: ImportDecl, ast_path: &mut AstKindPath) -> ImportDecl {
        if self.enabled {
            FoldAstPath::fold_import_decl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_import_default_specifier(
        &mut self,
        node: ImportDefaultSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ImportDefaultSpecifier {
        if self.enabled {
            FoldAstPath::fold_import_default_specifier(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_import_named_specifier(
        &mut self,
        node: ImportNamedSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ImportNamedSpecifier {
        if self.enabled {
            FoldAstPath::fold_import_named_specifier(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_import_phase(&mut self, node: ImportPhase, ast_path: &mut AstKindPath) -> ImportPhase {
        if self.enabled {
            FoldAstPath::fold_import_phase(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_import_specifier(
        &mut self,
        node: ImportSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ImportSpecifier {
        if self.enabled {
            FoldAstPath::fold_import_specifier(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_import_specifiers(
        &mut self,
        node: Vec<ImportSpecifier>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ImportSpecifier> {
        if self.enabled {
            FoldAstPath::fold_import_specifiers(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_import_star_as_specifier(
        &mut self,
        node: ImportStarAsSpecifier,
        ast_path: &mut AstKindPath,
    ) -> ImportStarAsSpecifier {
        if self.enabled {
            FoldAstPath::fold_import_star_as_specifier(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_import_with(&mut self, node: ImportWith, ast_path: &mut AstKindPath) -> ImportWith {
        if self.enabled {
            FoldAstPath::fold_import_with(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_import_with_item(
        &mut self,
        node: ImportWithItem,
        ast_path: &mut AstKindPath,
    ) -> ImportWithItem {
        if self.enabled {
            FoldAstPath::fold_import_with_item(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_import_with_items(
        &mut self,
        node: Vec<ImportWithItem>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ImportWithItem> {
        if self.enabled {
            FoldAstPath::fold_import_with_items(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_invalid(&mut self, node: Invalid, ast_path: &mut AstKindPath) -> Invalid {
        if self.enabled {
            FoldAstPath::fold_invalid(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_attr(&mut self, node: JSXAttr, ast_path: &mut AstKindPath) -> JSXAttr {
        if self.enabled {
            FoldAstPath::fold_jsx_attr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_attr_name(&mut self, node: JSXAttrName, ast_path: &mut AstKindPath) -> JSXAttrName {
        if self.enabled {
            FoldAstPath::fold_jsx_attr_name(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_attr_or_spread(
        &mut self,
        node: JSXAttrOrSpread,
        ast_path: &mut AstKindPath,
    ) -> JSXAttrOrSpread {
        if self.enabled {
            FoldAstPath::fold_jsx_attr_or_spread(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_attr_or_spreads(
        &mut self,
        node: Vec<JSXAttrOrSpread>,
        ast_path: &mut AstKindPath,
    ) -> Vec<JSXAttrOrSpread> {
        if self.enabled {
            FoldAstPath::fold_jsx_attr_or_spreads(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_attr_value(
        &mut self,
        node: JSXAttrValue,
        ast_path: &mut AstKindPath,
    ) -> JSXAttrValue {
        if self.enabled {
            FoldAstPath::fold_jsx_attr_value(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_closing_element(
        &mut self,
        node: JSXClosingElement,
        ast_path: &mut AstKindPath,
    ) -> JSXClosingElement {
        if self.enabled {
            FoldAstPath::fold_jsx_closing_element(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_closing_fragment(
        &mut self,
        node: JSXClosingFragment,
        ast_path: &mut AstKindPath,
    ) -> JSXClosingFragment {
        if self.enabled {
            FoldAstPath::fold_jsx_closing_fragment(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_element(&mut self, node: JSXElement, ast_path: &mut AstKindPath) -> JSXElement {
        if self.enabled {
            FoldAstPath::fold_jsx_element(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_element_child(
        &mut self,
        node: JSXElementChild,
        ast_path: &mut AstKindPath,
    ) -> JSXElementChild {
        if self.enabled {
            FoldAstPath::fold_jsx_element_child(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_element_childs(
        &mut self,
        node: Vec<JSXElementChild>,
        ast_path: &mut AstKindPath,
    ) -> Vec<JSXElementChild> {
        if self.enabled {
            FoldAstPath::fold_jsx_element_childs(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_element_name(
        &mut self,
        node: JSXElementName,
        ast_path: &mut AstKindPath,
    ) -> JSXElementName {
        if self.enabled {
            FoldAstPath::fold_jsx_element_name(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_empty_expr(
        &mut self,
        node: JSXEmptyExpr,
        ast_path: &mut AstKindPath,
    ) -> JSXEmptyExpr {
        if self.enabled {
            FoldAstPath::fold_jsx_empty_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_expr(&mut self, node: JSXExpr, ast_path: &mut AstKindPath) -> JSXExpr {
        if self.enabled {
            FoldAstPath::fold_jsx_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_expr_container(
        &mut self,
        node: JSXExprContainer,
        ast_path: &mut AstKindPath,
    ) -> JSXExprContainer {
        if self.enabled {
            FoldAstPath::fold_jsx_expr_container(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_fragment(&mut self, node: JSXFragment, ast_path: &mut AstKindPath) -> JSXFragment {
        if self.enabled {
            FoldAstPath::fold_jsx_fragment(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_member_expr(
        &mut self,
        node: JSXMemberExpr,
        ast_path: &mut AstKindPath,
    ) -> JSXMemberExpr {
        if self.enabled {
            FoldAstPath::fold_jsx_member_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_namespaced_name(
        &mut self,
        node: JSXNamespacedName,
        ast_path: &mut AstKindPath,
    ) -> JSXNamespacedName {
        if self.enabled {
            FoldAstPath::fold_jsx_namespaced_name(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_object(&mut self, node: JSXObject, ast_path: &mut AstKindPath) -> JSXObject {
        if self.enabled {
            FoldAstPath::fold_jsx_object(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_opening_element(
        &mut self,
        node: JSXOpeningElement,
        ast_path: &mut AstKindPath,
    ) -> JSXOpeningElement {
        if self.enabled {
            FoldAstPath::fold_jsx_opening_element(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_opening_fragment(
        &mut self,
        node: JSXOpeningFragment,
        ast_path: &mut AstKindPath,
    ) -> JSXOpeningFragment {
        if self.enabled {
            FoldAstPath::fold_jsx_opening_fragment(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_spread_child(
        &mut self,
        node: JSXSpreadChild,
        ast_path: &mut AstKindPath,
    ) -> JSXSpreadChild {
        if self.enabled {
            FoldAstPath::fold_jsx_spread_child(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_jsx_text(&mut self, node: JSXText, ast_path: &mut AstKindPath) -> JSXText {
        if self.enabled {
            FoldAstPath::fold_jsx_text(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_key(&mut self, node: Key, ast_path: &mut AstKindPath) -> Key {
        if self.enabled {
            FoldAstPath::fold_key(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_key_value_pat_prop(
        &mut self,
        node: KeyValuePatProp,
        ast_path: &mut AstKindPath,
    ) -> KeyValuePatProp {
        if self.enabled {
            FoldAstPath::fold_key_value_pat_prop(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_key_value_prop(
        &mut self,
        node: KeyValueProp,
        ast_path: &mut AstKindPath,
    ) -> KeyValueProp {
        if self.enabled {
            FoldAstPath::fold_key_value_prop(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_labeled_stmt(&mut self, node: LabeledStmt, ast_path: &mut AstKindPath) -> LabeledStmt {
        if self.enabled {
            FoldAstPath::fold_labeled_stmt(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_lit(&mut self, node: Lit, ast_path: &mut AstKindPath) -> Lit {
        if self.enabled {
            FoldAstPath::fold_lit(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_member_expr(&mut self, node: MemberExpr, ast_path: &mut AstKindPath) -> MemberExpr {
        if self.enabled {
            FoldAstPath::fold_member_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_member_prop(&mut self, node: MemberProp, ast_path: &mut AstKindPath) -> MemberProp {
        if self.enabled {
            FoldAstPath::fold_member_prop(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_meta_prop_expr(
        &mut self,
        node: MetaPropExpr,
        ast_path: &mut AstKindPath,
    ) -> MetaPropExpr {
        if self.enabled {
            FoldAstPath::fold_meta_prop_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_meta_prop_kind(
        &mut self,
        node: MetaPropKind,
        ast_path: &mut AstKindPath,
    ) -> MetaPropKind {
        if self.enabled {
            FoldAstPath::fold_meta_prop_kind(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_method_kind(&mut self, node: MethodKind, ast_path: &mut AstKindPath) -> MethodKind {
        if self.enabled {
            FoldAstPath::fold_method_kind(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_method_prop(&mut self, node: MethodProp, ast_path: &mut AstKindPath) -> MethodProp {
        if self.enabled {
            FoldAstPath::fold_method_prop(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_module(&mut self, node: Module, ast_path: &mut AstKindPath) -> Module {
        if self.enabled {
            FoldAstPath::fold_module(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_module_decl(&mut self, node: ModuleDecl, ast_path: &mut AstKindPath) -> ModuleDecl {
        if self.enabled {
            FoldAstPath::fold_module_decl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_module_export_name(
        &mut self,
        node: ModuleExportName,
        ast_path: &mut AstKindPath,
    ) -> ModuleExportName {
        if self.enabled {
            FoldAstPath::fold_module_export_name(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_module_item(&mut self, node: ModuleItem, ast_path: &mut AstKindPath) -> ModuleItem {
        if self.enabled {
            FoldAstPath::fold_module_item(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_module_items(
        &mut self,
        node: Vec<ModuleItem>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ModuleItem> {
        if self.enabled {
            FoldAstPath::fold_module_items(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_named_export(&mut self, node: NamedExport, ast_path: &mut AstKindPath) -> NamedExport {
        if self.enabled {
            FoldAstPath::fold_named_export(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_new_expr(&mut self, node: NewExpr, ast_path: &mut AstKindPath) -> NewExpr {
        if self.enabled {
            FoldAstPath::fold_new_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_null(&mut self, node: Null, ast_path: &mut AstKindPath) -> Null {
        if self.enabled {
            FoldAstPath::fold_null(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_number(&mut self, node: Number, ast_path: &mut AstKindPath) -> Number {
        if self.enabled {
            FoldAstPath::fold_number(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_object_lit(&mut self, node: ObjectLit, ast_path: &mut AstKindPath) -> ObjectLit {
        if self.enabled {
            FoldAstPath::fold_object_lit(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_object_pat(&mut self, node: ObjectPat, ast_path: &mut AstKindPath) -> ObjectPat {
        if self.enabled {
            FoldAstPath::fold_object_pat(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_object_pat_prop(
        &mut self,
        node: ObjectPatProp,
        ast_path: &mut AstKindPath,
    ) -> ObjectPatProp {
        if self.enabled {
            FoldAstPath::fold_object_pat_prop(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_object_pat_props(
        &mut self,
        node: Vec<ObjectPatProp>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ObjectPatProp> {
        if self.enabled {
            FoldAstPath::fold_object_pat_props(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_accessibility(
        &mut self,
        node: Option<Accessibility>,
        ast_path: &mut AstKindPath,
    ) -> Option<Accessibility> {
        if self.enabled {
            FoldAstPath::fold_opt_accessibility(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_atom(
        &mut self,
        node: Option<swc_atoms::Atom>,
        ast_path: &mut AstKindPath,
    ) -> Option<swc_atoms::Atom> {
        if self.enabled {
            FoldAstPath::fold_opt_atom(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_block_stmt(
        &mut self,
        node: Option<BlockStmt>,
        ast_path: &mut AstKindPath,
    ) -> Option<BlockStmt> {
        if self.enabled {
            FoldAstPath::fold_opt_block_stmt(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_call(&mut self, node: OptCall, ast_path: &mut AstKindPath) -> OptCall {
        if self.enabled {
            FoldAstPath::fold_opt_call(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_catch_clause(
        &mut self,
        node: Option<CatchClause>,
        ast_path: &mut AstKindPath,
    ) -> Option<CatchClause> {
        if self.enabled {
            FoldAstPath::fold_opt_catch_clause(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_chain_base(
        &mut self,
        node: OptChainBase,
        ast_path: &mut AstKindPath,
    ) -> OptChainBase {
        if self.enabled {
            FoldAstPath::fold_opt_chain_base(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_chain_expr(
        &mut self,
        node: OptChainExpr,
        ast_path: &mut AstKindPath,
    ) -> OptChainExpr {
        if self.enabled {
            FoldAstPath::fold_opt_chain_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_expr(
        &mut self,
        node: Option<Box<Expr>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<Expr>> {
        if self.enabled {
            FoldAstPath::fold_opt_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_expr_or_spread(
        &mut self,
        node: Option<ExprOrSpread>,
        ast_path: &mut AstKindPath,
    ) -> Option<ExprOrSpread> {
        if self.enabled {
            FoldAstPath::fold_opt_expr_or_spread(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_expr_or_spreads(
        &mut self,
        node: Option<Vec<ExprOrSpread>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Vec<ExprOrSpread>> {
        if self.enabled {
            FoldAstPath::fold_opt_expr_or_spreads(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_ident(&mut self, node: Option<Ident>, ast_path: &mut AstKindPath) -> Option<Ident> {
        if self.enabled {
            FoldAstPath::fold_opt_ident(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_jsx_attr_value(
        &mut self,
        node: Option<JSXAttrValue>,
        ast_path: &mut AstKindPath,
    ) -> Option<JSXAttrValue> {
        if self.enabled {
            FoldAstPath::fold_opt_jsx_attr_value(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_jsx_closing_element(
        &mut self,
        node: Option<JSXClosingElement>,
        ast_path: &mut AstKindPath,
    ) -> Option<JSXClosingElement> {
        if self.enabled {
            FoldAstPath::fold_opt_jsx_closing_element(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_module_export_name(
        &mut self,
        node: Option<ModuleExportName>,
        ast_path: &mut AstKindPath,
    ) -> Option<ModuleExportName> {
        if self.enabled {
            FoldAstPath::fold_opt_module_export_name(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_module_items(
        &mut self,
        node: Option<Vec<ModuleItem>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Vec<ModuleItem>> {
        if self.enabled {
            FoldAstPath::fold_opt_module_items(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_object_lit(
        &mut self,
        node: Option<Box<ObjectLit>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<ObjectLit>> {
        if self.enabled {
            FoldAstPath::fold_opt_object_lit(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_pat(&mut self, node: Option<Pat>, ast_path: &mut AstKindPath) -> Option<Pat> {
        if self.enabled {
            FoldAstPath::fold_opt_pat(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_span(
        &mut self,
        node: Option<swc_common::Span>,
        ast_path: &mut AstKindPath,
    ) -> Option<swc_common::Span> {
        if self.enabled {
            FoldAstPath::fold_opt_span(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_stmt(
        &mut self,
        node: Option<Box<Stmt>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<Stmt>> {
        if self.enabled {
            FoldAstPath::fold_opt_stmt(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_str(
        &mut self,
        node: Option<Box<Str>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<Str>> {
        if self.enabled {
            FoldAstPath::fold_opt_str(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_true_plus_minus(
        &mut self,
        node: Option<TruePlusMinus>,
        ast_path: &mut AstKindPath,
    ) -> Option<TruePlusMinus> {
        if self.enabled {
            FoldAstPath::fold_opt_true_plus_minus(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_ts_entity_name(
        &mut self,
        node: Option<TsEntityName>,
        ast_path: &mut AstKindPath,
    ) -> Option<TsEntityName> {
        if self.enabled {
            FoldAstPath::fold_opt_ts_entity_name(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_ts_namespace_body(
        &mut self,
        node: Option<TsNamespaceBody>,
        ast_path: &mut AstKindPath,
    ) -> Option<TsNamespaceBody> {
        if self.enabled {
            FoldAstPath::fold_opt_ts_namespace_body(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_ts_type(
        &mut self,
        node: Option<Box<TsType>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<TsType>> {
        if self.enabled {
            FoldAstPath::fold_opt_ts_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_ts_type_ann(
        &mut self,
        node: Option<Box<TsTypeAnn>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<TsTypeAnn>> {
        if self.enabled {
            FoldAstPath::fold_opt_ts_type_ann(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_ts_type_param_decl(
        &mut self,
        node: Option<Box<TsTypeParamDecl>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<TsTypeParamDecl>> {
        if self.enabled {
            FoldAstPath::fold_opt_ts_type_param_decl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_ts_type_param_instantiation(
        &mut self,
        node: Option<Box<TsTypeParamInstantiation>>,
        ast_path: &mut AstKindPath,
    ) -> Option<Box<TsTypeParamInstantiation>> {
        if self.enabled {
            FoldAstPath::fold_opt_ts_type_param_instantiation(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_var_decl_or_expr(
        &mut self,
        node: Option<VarDeclOrExpr>,
        ast_path: &mut AstKindPath,
    ) -> Option<VarDeclOrExpr> {
        if self.enabled {
            FoldAstPath::fold_opt_var_decl_or_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_vec_expr_or_spreads(
        &mut self,
        node: Vec<Option<ExprOrSpread>>,
        ast_path: &mut AstKindPath,
    ) -> Vec<Option<ExprOrSpread>> {
        if self.enabled {
            FoldAstPath::fold_opt_vec_expr_or_spreads(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_opt_vec_pats(
        &mut self,
        node: Vec<Option<Pat>>,
        ast_path: &mut AstKindPath,
    ) -> Vec<Option<Pat>> {
        if self.enabled {
            FoldAstPath::fold_opt_vec_pats(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_param(&mut self, node: Param, ast_path: &mut AstKindPath) -> Param {
        if self.enabled {
            FoldAstPath::fold_param(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_param_or_ts_param_prop(
        &mut self,
        node: ParamOrTsParamProp,
        ast_path: &mut AstKindPath,
    ) -> ParamOrTsParamProp {
        if self.enabled {
            FoldAstPath::fold_param_or_ts_param_prop(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_param_or_ts_param_props(
        &mut self,
        node: Vec<ParamOrTsParamProp>,
        ast_path: &mut AstKindPath,
    ) -> Vec<ParamOrTsParamProp> {
        if self.enabled {
            FoldAstPath::fold_param_or_ts_param_props(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_params(&mut self, node: Vec<Param>, ast_path: &mut AstKindPath) -> Vec<Param> {
        if self.enabled {
            FoldAstPath::fold_params(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_paren_expr(&mut self, node: ParenExpr, ast_path: &mut AstKindPath) -> ParenExpr {
        if self.enabled {
            FoldAstPath::fold_paren_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_pat(&mut self, node: Pat, ast_path: &mut AstKindPath) -> Pat {
        if self.enabled {
            FoldAstPath::fold_pat(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_pats(&mut self, node: Vec<Pat>, ast_path: &mut AstKindPath) -> Vec<Pat> {
        if self.enabled {
            FoldAstPath::fold_pats(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_private_method(
        &mut self,
        node: PrivateMethod,
        ast_path: &mut AstKindPath,
    ) -> PrivateMethod {
        if self.enabled {
            FoldAstPath::fold_private_method(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_private_name(&mut self, node: PrivateName, ast_path: &mut AstKindPath) -> PrivateName {
        if self.enabled {
            FoldAstPath::fold_private_name(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_private_prop(&mut self, node: PrivateProp, ast_path: &mut AstKindPath) -> PrivateProp {
        if self.enabled {
            FoldAstPath::fold_private_prop(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_program(&mut self, node: Program, ast_path: &mut AstKindPath) -> Program {
        if self.enabled {
            FoldAstPath::fold_program(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_prop(&mut self, node: Prop, ast_path: &mut AstKindPath) -> Prop {
        if self.enabled {
            FoldAstPath::fold_prop(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_prop_name(&mut self, node: PropName, ast_path: &mut AstKindPath) -> PropName {
        if self.enabled {
            FoldAstPath::fold_prop_name(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_prop_or_spread(
        &mut self,
        node: PropOrSpread,
        ast_path: &mut AstKindPath,
    ) -> PropOrSpread {
        if self.enabled {
            FoldAstPath::fold_prop_or_spread(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_prop_or_spreads(
        &mut self,
        node: Vec<PropOrSpread>,
        ast_path: &mut AstKindPath,
    ) -> Vec<PropOrSpread> {
        if self.enabled {
            FoldAstPath::fold_prop_or_spreads(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_regex(&mut self, node: Regex, ast_path: &mut AstKindPath) -> Regex {
        if self.enabled {
            FoldAstPath::fold_regex(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_reserved_unused(
        &mut self,
        node: ReservedUnused,
        ast_path: &mut AstKindPath,
    ) -> ReservedUnused {
        if self.enabled {
            FoldAstPath::fold_reserved_unused(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_rest_pat(&mut self, node: RestPat, ast_path: &mut AstKindPath) -> RestPat {
        if self.enabled {
            FoldAstPath::fold_rest_pat(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_return_stmt(&mut self, node: ReturnStmt, ast_path: &mut AstKindPath) -> ReturnStmt {
        if self.enabled {
            FoldAstPath::fold_return_stmt(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_script(&mut self, node: Script, ast_path: &mut AstKindPath) -> Script {
        if self.enabled {
            FoldAstPath::fold_script(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_seq_expr(&mut self, node: SeqExpr, ast_path: &mut AstKindPath) -> SeqExpr {
        if self.enabled {
            FoldAstPath::fold_seq_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_setter_prop(&mut self, node: SetterProp, ast_path: &mut AstKindPath) -> SetterProp {
        if self.enabled {
            FoldAstPath::fold_setter_prop(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_simple_assign_target(
        &mut self,
        node: SimpleAssignTarget,
        ast_path: &mut AstKindPath,
    ) -> SimpleAssignTarget {
        if self.enabled {
            FoldAstPath::fold_simple_assign_target(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_span(
        &mut self,
        node: swc_common::Span,
        ast_path: &mut AstKindPath,
    ) -> swc_common::Span {
        if self.enabled {
            FoldAstPath::fold_span(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_spread_element(
        &mut self,
        node: SpreadElement,
        ast_path: &mut AstKindPath,
    ) -> SpreadElement {
        if self.enabled {
            FoldAstPath::fold_spread_element(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_static_block(&mut self, node: StaticBlock, ast_path: &mut AstKindPath) -> StaticBlock {
        if self.enabled {
            FoldAstPath::fold_static_block(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_stmt(&mut self, node: Stmt, ast_path: &mut AstKindPath) -> Stmt {
        if self.enabled {
            FoldAstPath::fold_stmt(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_stmts(&mut self, node: Vec<Stmt>, ast_path: &mut AstKindPath) -> Vec<Stmt> {
        if self.enabled {
            FoldAstPath::fold_stmts(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_str(&mut self, node: Str, ast_path: &mut AstKindPath) -> Str {
        if self.enabled {
            FoldAstPath::fold_str(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_super(&mut self, node: Super, ast_path: &mut AstKindPath) -> Super {
        if self.enabled {
            FoldAstPath::fold_super(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_super_prop(&mut self, node: SuperProp, ast_path: &mut AstKindPath) -> SuperProp {
        if self.enabled {
            FoldAstPath::fold_super_prop(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_super_prop_expr(
        &mut self,
        node: SuperPropExpr,
        ast_path: &mut AstKindPath,
    ) -> SuperPropExpr {
        if self.enabled {
            FoldAstPath::fold_super_prop_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_switch_case(&mut self, node: SwitchCase, ast_path: &mut AstKindPath) -> SwitchCase {
        if self.enabled {
            FoldAstPath::fold_switch_case(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_switch_cases(
        &mut self,
        node: Vec<SwitchCase>,
        ast_path: &mut AstKindPath,
    ) -> Vec<SwitchCase> {
        if self.enabled {
            FoldAstPath::fold_switch_cases(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_switch_stmt(&mut self, node: SwitchStmt, ast_path: &mut AstKindPath) -> SwitchStmt {
        if self.enabled {
            FoldAstPath::fold_switch_stmt(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_syntax_context(
        &mut self,
        node: swc_common::SyntaxContext,
        ast_path: &mut AstKindPath,
    ) -> swc_common::SyntaxContext {
        if self.enabled {
            FoldAstPath::fold_syntax_context(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_tagged_tpl(&mut self, node: TaggedTpl, ast_path: &mut AstKindPath) -> TaggedTpl {
        if self.enabled {
            FoldAstPath::fold_tagged_tpl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_this_expr(&mut self, node: ThisExpr, ast_path: &mut AstKindPath) -> ThisExpr {
        if self.enabled {
            FoldAstPath::fold_this_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_throw_stmt(&mut self, node: ThrowStmt, ast_path: &mut AstKindPath) -> ThrowStmt {
        if self.enabled {
            FoldAstPath::fold_throw_stmt(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_tpl(&mut self, node: Tpl, ast_path: &mut AstKindPath) -> Tpl {
        if self.enabled {
            FoldAstPath::fold_tpl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_tpl_element(&mut self, node: TplElement, ast_path: &mut AstKindPath) -> TplElement {
        if self.enabled {
            FoldAstPath::fold_tpl_element(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_tpl_elements(
        &mut self,
        node: Vec<TplElement>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TplElement> {
        if self.enabled {
            FoldAstPath::fold_tpl_elements(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_true_plus_minus(
        &mut self,
        node: TruePlusMinus,
        ast_path: &mut AstKindPath,
    ) -> TruePlusMinus {
        if self.enabled {
            FoldAstPath::fold_true_plus_minus(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_try_stmt(&mut self, node: TryStmt, ast_path: &mut AstKindPath) -> TryStmt {
        if self.enabled {
            FoldAstPath::fold_try_stmt(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_array_type(&mut self, node: TsArrayType, ast_path: &mut AstKindPath) -> TsArrayType {
        if self.enabled {
            FoldAstPath::fold_ts_array_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_as_expr(&mut self, node: TsAsExpr, ast_path: &mut AstKindPath) -> TsAsExpr {
        if self.enabled {
            FoldAstPath::fold_ts_as_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_call_signature_decl(
        &mut self,
        node: TsCallSignatureDecl,
        ast_path: &mut AstKindPath,
    ) -> TsCallSignatureDecl {
        if self.enabled {
            FoldAstPath::fold_ts_call_signature_decl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_conditional_type(
        &mut self,
        node: TsConditionalType,
        ast_path: &mut AstKindPath,
    ) -> TsConditionalType {
        if self.enabled {
            FoldAstPath::fold_ts_conditional_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_const_assertion(
        &mut self,
        node: TsConstAssertion,
        ast_path: &mut AstKindPath,
    ) -> TsConstAssertion {
        if self.enabled {
            FoldAstPath::fold_ts_const_assertion(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_construct_signature_decl(
        &mut self,
        node: TsConstructSignatureDecl,
        ast_path: &mut AstKindPath,
    ) -> TsConstructSignatureDecl {
        if self.enabled {
            FoldAstPath::fold_ts_construct_signature_decl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_constructor_type(
        &mut self,
        node: TsConstructorType,
        ast_path: &mut AstKindPath,
    ) -> TsConstructorType {
        if self.enabled {
            FoldAstPath::fold_ts_constructor_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_entity_name(
        &mut self,
        node: TsEntityName,
        ast_path: &mut AstKindPath,
    ) -> TsEntityName {
        if self.enabled {
            FoldAstPath::fold_ts_entity_name(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_enum_decl(&mut self, node: TsEnumDecl, ast_path: &mut AstKindPath) -> TsEnumDecl {
        if self.enabled {
            FoldAstPath::fold_ts_enum_decl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_enum_member(
        &mut self,
        node: TsEnumMember,
        ast_path: &mut AstKindPath,
    ) -> TsEnumMember {
        if self.enabled {
            FoldAstPath::fold_ts_enum_member(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_enum_member_id(
        &mut self,
        node: TsEnumMemberId,
        ast_path: &mut AstKindPath,
    ) -> TsEnumMemberId {
        if self.enabled {
            FoldAstPath::fold_ts_enum_member_id(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_enum_members(
        &mut self,
        node: Vec<TsEnumMember>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsEnumMember> {
        if self.enabled {
            FoldAstPath::fold_ts_enum_members(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_export_assignment(
        &mut self,
        node: TsExportAssignment,
        ast_path: &mut AstKindPath,
    ) -> TsExportAssignment {
        if self.enabled {
            FoldAstPath::fold_ts_export_assignment(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_expr_with_type_args(
        &mut self,
        node: TsExprWithTypeArgs,
        ast_path: &mut AstKindPath,
    ) -> TsExprWithTypeArgs {
        if self.enabled {
            FoldAstPath::fold_ts_expr_with_type_args(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_expr_with_type_argss(
        &mut self,
        node: Vec<TsExprWithTypeArgs>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsExprWithTypeArgs> {
        if self.enabled {
            FoldAstPath::fold_ts_expr_with_type_argss(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_external_module_ref(
        &mut self,
        node: TsExternalModuleRef,
        ast_path: &mut AstKindPath,
    ) -> TsExternalModuleRef {
        if self.enabled {
            FoldAstPath::fold_ts_external_module_ref(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_fn_or_constructor_type(
        &mut self,
        node: TsFnOrConstructorType,
        ast_path: &mut AstKindPath,
    ) -> TsFnOrConstructorType {
        if self.enabled {
            FoldAstPath::fold_ts_fn_or_constructor_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_fn_param(&mut self, node: TsFnParam, ast_path: &mut AstKindPath) -> TsFnParam {
        if self.enabled {
            FoldAstPath::fold_ts_fn_param(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_fn_params(
        &mut self,
        node: Vec<TsFnParam>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsFnParam> {
        if self.enabled {
            FoldAstPath::fold_ts_fn_params(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_fn_type(&mut self, node: TsFnType, ast_path: &mut AstKindPath) -> TsFnType {
        if self.enabled {
            FoldAstPath::fold_ts_fn_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_getter_signature(
        &mut self,
        node: TsGetterSignature,
        ast_path: &mut AstKindPath,
    ) -> TsGetterSignature {
        if self.enabled {
            FoldAstPath::fold_ts_getter_signature(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_import_equals_decl(
        &mut self,
        node: TsImportEqualsDecl,
        ast_path: &mut AstKindPath,
    ) -> TsImportEqualsDecl {
        if self.enabled {
            FoldAstPath::fold_ts_import_equals_decl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_import_type(
        &mut self,
        node: TsImportType,
        ast_path: &mut AstKindPath,
    ) -> TsImportType {
        if self.enabled {
            FoldAstPath::fold_ts_import_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_index_signature(
        &mut self,
        node: TsIndexSignature,
        ast_path: &mut AstKindPath,
    ) -> TsIndexSignature {
        if self.enabled {
            FoldAstPath::fold_ts_index_signature(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_indexed_access_type(
        &mut self,
        node: TsIndexedAccessType,
        ast_path: &mut AstKindPath,
    ) -> TsIndexedAccessType {
        if self.enabled {
            FoldAstPath::fold_ts_indexed_access_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_infer_type(&mut self, node: TsInferType, ast_path: &mut AstKindPath) -> TsInferType {
        if self.enabled {
            FoldAstPath::fold_ts_infer_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_instantiation(
        &mut self,
        node: TsInstantiation,
        ast_path: &mut AstKindPath,
    ) -> TsInstantiation {
        if self.enabled {
            FoldAstPath::fold_ts_instantiation(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_interface_body(
        &mut self,
        node: TsInterfaceBody,
        ast_path: &mut AstKindPath,
    ) -> TsInterfaceBody {
        if self.enabled {
            FoldAstPath::fold_ts_interface_body(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_interface_decl(
        &mut self,
        node: TsInterfaceDecl,
        ast_path: &mut AstKindPath,
    ) -> TsInterfaceDecl {
        if self.enabled {
            FoldAstPath::fold_ts_interface_decl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_intersection_type(
        &mut self,
        node: TsIntersectionType,
        ast_path: &mut AstKindPath,
    ) -> TsIntersectionType {
        if self.enabled {
            FoldAstPath::fold_ts_intersection_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_keyword_type(
        &mut self,
        node: TsKeywordType,
        ast_path: &mut AstKindPath,
    ) -> TsKeywordType {
        if self.enabled {
            FoldAstPath::fold_ts_keyword_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_keyword_type_kind(
        &mut self,
        node: TsKeywordTypeKind,
        ast_path: &mut AstKindPath,
    ) -> TsKeywordTypeKind {
        if self.enabled {
            FoldAstPath::fold_ts_keyword_type_kind(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_lit(&mut self, node: TsLit, ast_path: &mut AstKindPath) -> TsLit {
        if self.enabled {
            FoldAstPath::fold_ts_lit(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_lit_type(&mut self, node: TsLitType, ast_path: &mut AstKindPath) -> TsLitType {
        if self.enabled {
            FoldAstPath::fold_ts_lit_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_mapped_type(
        &mut self,
        node: TsMappedType,
        ast_path: &mut AstKindPath,
    ) -> TsMappedType {
        if self.enabled {
            FoldAstPath::fold_ts_mapped_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_method_signature(
        &mut self,
        node: TsMethodSignature,
        ast_path: &mut AstKindPath,
    ) -> TsMethodSignature {
        if self.enabled {
            FoldAstPath::fold_ts_method_signature(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_module_block(
        &mut self,
        node: TsModuleBlock,
        ast_path: &mut AstKindPath,
    ) -> TsModuleBlock {
        if self.enabled {
            FoldAstPath::fold_ts_module_block(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_module_decl(
        &mut self,
        node: TsModuleDecl,
        ast_path: &mut AstKindPath,
    ) -> TsModuleDecl {
        if self.enabled {
            FoldAstPath::fold_ts_module_decl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_module_name(
        &mut self,
        node: TsModuleName,
        ast_path: &mut AstKindPath,
    ) -> TsModuleName {
        if self.enabled {
            FoldAstPath::fold_ts_module_name(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_module_ref(&mut self, node: TsModuleRef, ast_path: &mut AstKindPath) -> TsModuleRef {
        if self.enabled {
            FoldAstPath::fold_ts_module_ref(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_namespace_body(
        &mut self,
        node: TsNamespaceBody,
        ast_path: &mut AstKindPath,
    ) -> TsNamespaceBody {
        if self.enabled {
            FoldAstPath::fold_ts_namespace_body(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_namespace_decl(
        &mut self,
        node: TsNamespaceDecl,
        ast_path: &mut AstKindPath,
    ) -> TsNamespaceDecl {
        if self.enabled {
            FoldAstPath::fold_ts_namespace_decl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_namespace_export_decl(
        &mut self,
        node: TsNamespaceExportDecl,
        ast_path: &mut AstKindPath,
    ) -> TsNamespaceExportDecl {
        if self.enabled {
            FoldAstPath::fold_ts_namespace_export_decl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_non_null_expr(
        &mut self,
        node: TsNonNullExpr,
        ast_path: &mut AstKindPath,
    ) -> TsNonNullExpr {
        if self.enabled {
            FoldAstPath::fold_ts_non_null_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_optional_type(
        &mut self,
        node: TsOptionalType,
        ast_path: &mut AstKindPath,
    ) -> TsOptionalType {
        if self.enabled {
            FoldAstPath::fold_ts_optional_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_param_prop(&mut self, node: TsParamProp, ast_path: &mut AstKindPath) -> TsParamProp {
        if self.enabled {
            FoldAstPath::fold_ts_param_prop(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_param_prop_param(
        &mut self,
        node: TsParamPropParam,
        ast_path: &mut AstKindPath,
    ) -> TsParamPropParam {
        if self.enabled {
            FoldAstPath::fold_ts_param_prop_param(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_parenthesized_type(
        &mut self,
        node: TsParenthesizedType,
        ast_path: &mut AstKindPath,
    ) -> TsParenthesizedType {
        if self.enabled {
            FoldAstPath::fold_ts_parenthesized_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_property_signature(
        &mut self,
        node: TsPropertySignature,
        ast_path: &mut AstKindPath,
    ) -> TsPropertySignature {
        if self.enabled {
            FoldAstPath::fold_ts_property_signature(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_qualified_name(
        &mut self,
        node: TsQualifiedName,
        ast_path: &mut AstKindPath,
    ) -> TsQualifiedName {
        if self.enabled {
            FoldAstPath::fold_ts_qualified_name(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_rest_type(&mut self, node: TsRestType, ast_path: &mut AstKindPath) -> TsRestType {
        if self.enabled {
            FoldAstPath::fold_ts_rest_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_satisfies_expr(
        &mut self,
        node: TsSatisfiesExpr,
        ast_path: &mut AstKindPath,
    ) -> TsSatisfiesExpr {
        if self.enabled {
            FoldAstPath::fold_ts_satisfies_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_setter_signature(
        &mut self,
        node: TsSetterSignature,
        ast_path: &mut AstKindPath,
    ) -> TsSetterSignature {
        if self.enabled {
            FoldAstPath::fold_ts_setter_signature(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_this_type(&mut self, node: TsThisType, ast_path: &mut AstKindPath) -> TsThisType {
        if self.enabled {
            FoldAstPath::fold_ts_this_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_this_type_or_ident(
        &mut self,
        node: TsThisTypeOrIdent,
        ast_path: &mut AstKindPath,
    ) -> TsThisTypeOrIdent {
        if self.enabled {
            FoldAstPath::fold_ts_this_type_or_ident(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_tpl_lit_type(
        &mut self,
        node: TsTplLitType,
        ast_path: &mut AstKindPath,
    ) -> TsTplLitType {
        if self.enabled {
            FoldAstPath::fold_ts_tpl_lit_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_tuple_element(
        &mut self,
        node: TsTupleElement,
        ast_path: &mut AstKindPath,
    ) -> TsTupleElement {
        if self.enabled {
            FoldAstPath::fold_ts_tuple_element(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_tuple_elements(
        &mut self,
        node: Vec<TsTupleElement>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsTupleElement> {
        if self.enabled {
            FoldAstPath::fold_ts_tuple_elements(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_tuple_type(&mut self, node: TsTupleType, ast_path: &mut AstKindPath) -> TsTupleType {
        if self.enabled {
            FoldAstPath::fold_ts_tuple_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_type(&mut self, node: TsType, ast_path: &mut AstKindPath) -> TsType {
        if self.enabled {
            FoldAstPath::fold_ts_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_type_alias_decl(
        &mut self,
        node: TsTypeAliasDecl,
        ast_path: &mut AstKindPath,
    ) -> TsTypeAliasDecl {
        if self.enabled {
            FoldAstPath::fold_ts_type_alias_decl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_type_ann(&mut self, node: TsTypeAnn, ast_path: &mut AstKindPath) -> TsTypeAnn {
        if self.enabled {
            FoldAstPath::fold_ts_type_ann(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_type_assertion(
        &mut self,
        node: TsTypeAssertion,
        ast_path: &mut AstKindPath,
    ) -> TsTypeAssertion {
        if self.enabled {
            FoldAstPath::fold_ts_type_assertion(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_type_element(
        &mut self,
        node: TsTypeElement,
        ast_path: &mut AstKindPath,
    ) -> TsTypeElement {
        if self.enabled {
            FoldAstPath::fold_ts_type_element(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_type_elements(
        &mut self,
        node: Vec<TsTypeElement>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsTypeElement> {
        if self.enabled {
            FoldAstPath::fold_ts_type_elements(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_type_lit(&mut self, node: TsTypeLit, ast_path: &mut AstKindPath) -> TsTypeLit {
        if self.enabled {
            FoldAstPath::fold_ts_type_lit(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_type_operator(
        &mut self,
        node: TsTypeOperator,
        ast_path: &mut AstKindPath,
    ) -> TsTypeOperator {
        if self.enabled {
            FoldAstPath::fold_ts_type_operator(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_type_operator_op(
        &mut self,
        node: TsTypeOperatorOp,
        ast_path: &mut AstKindPath,
    ) -> TsTypeOperatorOp {
        if self.enabled {
            FoldAstPath::fold_ts_type_operator_op(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_type_param(&mut self, node: TsTypeParam, ast_path: &mut AstKindPath) -> TsTypeParam {
        if self.enabled {
            FoldAstPath::fold_ts_type_param(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_type_param_decl(
        &mut self,
        node: TsTypeParamDecl,
        ast_path: &mut AstKindPath,
    ) -> TsTypeParamDecl {
        if self.enabled {
            FoldAstPath::fold_ts_type_param_decl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_type_param_instantiation(
        &mut self,
        node: TsTypeParamInstantiation,
        ast_path: &mut AstKindPath,
    ) -> TsTypeParamInstantiation {
        if self.enabled {
            FoldAstPath::fold_ts_type_param_instantiation(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_type_params(
        &mut self,
        node: Vec<TsTypeParam>,
        ast_path: &mut AstKindPath,
    ) -> Vec<TsTypeParam> {
        if self.enabled {
            FoldAstPath::fold_ts_type_params(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_type_predicate(
        &mut self,
        node: TsTypePredicate,
        ast_path: &mut AstKindPath,
    ) -> TsTypePredicate {
        if self.enabled {
            FoldAstPath::fold_ts_type_predicate(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_type_query(&mut self, node: TsTypeQuery, ast_path: &mut AstKindPath) -> TsTypeQuery {
        if self.enabled {
            FoldAstPath::fold_ts_type_query(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_type_query_expr(
        &mut self,
        node: TsTypeQueryExpr,
        ast_path: &mut AstKindPath,
    ) -> TsTypeQueryExpr {
        if self.enabled {
            FoldAstPath::fold_ts_type_query_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_type_ref(&mut self, node: TsTypeRef, ast_path: &mut AstKindPath) -> TsTypeRef {
        if self.enabled {
            FoldAstPath::fold_ts_type_ref(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_types(
        &mut self,
        node: Vec<Box<TsType>>,
        ast_path: &mut AstKindPath,
    ) -> Vec<Box<TsType>> {
        if self.enabled {
            FoldAstPath::fold_ts_types(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_union_or_intersection_type(
        &mut self,
        node: TsUnionOrIntersectionType,
        ast_path: &mut AstKindPath,
    ) -> TsUnionOrIntersectionType {
        if self.enabled {
            FoldAstPath::fold_ts_union_or_intersection_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_ts_union_type(&mut self, node: TsUnionType, ast_path: &mut AstKindPath) -> TsUnionType {
        if self.enabled {
            FoldAstPath::fold_ts_union_type(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_unary_expr(&mut self, node: UnaryExpr, ast_path: &mut AstKindPath) -> UnaryExpr {
        if self.enabled {
            FoldAstPath::fold_unary_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_unary_op(&mut self, node: UnaryOp, ast_path: &mut AstKindPath) -> UnaryOp {
        if self.enabled {
            FoldAstPath::fold_unary_op(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_update_expr(&mut self, node: UpdateExpr, ast_path: &mut AstKindPath) -> UpdateExpr {
        if self.enabled {
            FoldAstPath::fold_update_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_update_op(&mut self, node: UpdateOp, ast_path: &mut AstKindPath) -> UpdateOp {
        if self.enabled {
            FoldAstPath::fold_update_op(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_using_decl(&mut self, node: UsingDecl, ast_path: &mut AstKindPath) -> UsingDecl {
        if self.enabled {
            FoldAstPath::fold_using_decl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_var_decl(&mut self, node: VarDecl, ast_path: &mut AstKindPath) -> VarDecl {
        if self.enabled {
            FoldAstPath::fold_var_decl(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_var_decl_kind(&mut self, node: VarDeclKind, ast_path: &mut AstKindPath) -> VarDeclKind {
        if self.enabled {
            FoldAstPath::fold_var_decl_kind(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_var_decl_or_expr(
        &mut self,
        node: VarDeclOrExpr,
        ast_path: &mut AstKindPath,
    ) -> VarDeclOrExpr {
        if self.enabled {
            FoldAstPath::fold_var_decl_or_expr(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_var_declarator(
        &mut self,
        node: VarDeclarator,
        ast_path: &mut AstKindPath,
    ) -> VarDeclarator {
        if self.enabled {
            FoldAstPath::fold_var_declarator(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_var_declarators(
        &mut self,
        node: Vec<VarDeclarator>,
        ast_path: &mut AstKindPath,
    ) -> Vec<VarDeclarator> {
        if self.enabled {
            FoldAstPath::fold_var_declarators(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_while_stmt(&mut self, node: WhileStmt, ast_path: &mut AstKindPath) -> WhileStmt {
        if self.enabled {
            FoldAstPath::fold_while_stmt(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_with_stmt(&mut self, node: WithStmt, ast_path: &mut AstKindPath) -> WithStmt {
        if self.enabled {
            FoldAstPath::fold_with_stmt(self, node, ast_path)
        } else {
            node
        }
    }

    fn fold_yield_expr(&mut self, node: YieldExpr, ast_path: &mut AstKindPath) -> YieldExpr {
        if self.enabled {
            FoldAstPath::fold_yield_expr(self, node, ast_path)
        } else {
            node
        }
    }
}
#[doc = r" A trait implemented for types that can be visited using a visitor."]
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
pub trait FoldWithAstPath<V: ?Sized + FoldAstPath> {
    #[doc = r" Calls a visitor method (visitor.fold_xxx) with self."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self;
    #[doc = r" Visit children nodes of `self`` with `visitor`."]
    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self;
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Accessibility {
    #[doc = "Calls [FoldAstPath`::fold_accessibility`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_accessibility(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Accessibility::Public => Accessibility::Public,
            Accessibility::Protected => Accessibility::Protected,
            Accessibility::Private => Accessibility::Private,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ArrayLit {
    #[doc = "Calls [FoldAstPath`::fold_array_lit`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_array_lit(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ArrayLit { span, elems } => {
                let elems = <Vec<Option<ExprOrSpread>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    elems, visitor, ast_path,
                );
                ArrayLit { span, elems }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ArrayPat {
    #[doc = "Calls [FoldAstPath`::fold_array_pat`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_array_pat(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ArrayPat {
                span,
                elems,
                optional,
                type_ann,
            } => {
                let elems = <Vec<Option<Pat>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    elems, visitor, ast_path,
                );
                let type_ann = <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                ArrayPat {
                    span,
                    elems,
                    optional,
                    type_ann,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ArrowExpr {
    #[doc = "Calls [FoldAstPath`::fold_arrow_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_arrow_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ArrowExpr {
                span,
                ctxt,
                params,
                body,
                is_async,
                is_generator,
                type_params,
                return_type,
            } => {
                let params =
                    <Vec<Pat> as FoldWithAstPath<V>>::fold_with_ast_path(params, visitor, ast_path);
                let body = <Box<BlockStmtOrExpr> as FoldWithAstPath<V>>::fold_with_ast_path(
                    body, visitor, ast_path,
                );
                let type_params =
                    <Option<Box<TsTypeParamDecl>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_params,
                        visitor,
                        ast_path,
                    );
                let return_type =
                    <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        return_type,
                        visitor,
                        ast_path,
                    );
                ArrowExpr {
                    span,
                    ctxt,
                    params,
                    body,
                    is_async,
                    is_generator,
                    type_params,
                    return_type,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for AssignExpr {
    #[doc = "Calls [FoldAstPath`::fold_assign_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_assign_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            AssignExpr {
                span,
                op,
                left,
                right,
            } => {
                let op =
                    <AssignOp as FoldWithAstPath<V>>::fold_with_ast_path(op, visitor, ast_path);
                let left = <AssignTarget as FoldWithAstPath<V>>::fold_with_ast_path(
                    left, visitor, ast_path,
                );
                let right =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(right, visitor, ast_path);
                AssignExpr {
                    span,
                    op,
                    left,
                    right,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for AssignOp {
    #[doc = "Calls [FoldAstPath`::fold_assign_op`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_assign_op(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            AssignOp::Assign => AssignOp::Assign,
            AssignOp::AddAssign => AssignOp::AddAssign,
            AssignOp::SubAssign => AssignOp::SubAssign,
            AssignOp::MulAssign => AssignOp::MulAssign,
            AssignOp::DivAssign => AssignOp::DivAssign,
            AssignOp::ModAssign => AssignOp::ModAssign,
            AssignOp::LShiftAssign => AssignOp::LShiftAssign,
            AssignOp::RShiftAssign => AssignOp::RShiftAssign,
            AssignOp::ZeroFillRShiftAssign => AssignOp::ZeroFillRShiftAssign,
            AssignOp::BitOrAssign => AssignOp::BitOrAssign,
            AssignOp::BitXorAssign => AssignOp::BitXorAssign,
            AssignOp::BitAndAssign => AssignOp::BitAndAssign,
            AssignOp::ExpAssign => AssignOp::ExpAssign,
            AssignOp::AndAssign => AssignOp::AndAssign,
            AssignOp::OrAssign => AssignOp::OrAssign,
            AssignOp::NullishAssign => AssignOp::NullishAssign,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for AssignPat {
    #[doc = "Calls [FoldAstPath`::fold_assign_pat`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_assign_pat(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            AssignPat { span, left, right } => {
                let left =
                    <Box<Pat> as FoldWithAstPath<V>>::fold_with_ast_path(left, visitor, ast_path);
                let right =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(right, visitor, ast_path);
                AssignPat { span, left, right }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for AssignPatProp {
    #[doc = "Calls [FoldAstPath`::fold_assign_pat_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_assign_pat_prop(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            AssignPatProp { span, key, value } => {
                let key = <BindingIdent as FoldWithAstPath<V>>::fold_with_ast_path(
                    key, visitor, ast_path,
                );
                let value = <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    value, visitor, ast_path,
                );
                AssignPatProp { span, key, value }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for AssignProp {
    #[doc = "Calls [FoldAstPath`::fold_assign_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_assign_prop(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            AssignProp { span, key, value } => {
                let key = <Ident as FoldWithAstPath<V>>::fold_with_ast_path(key, visitor, ast_path);
                let value =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(value, visitor, ast_path);
                AssignProp { span, key, value }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for AssignTarget {
    #[doc = "Calls [FoldAstPath`::fold_assign_target`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_assign_target(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            AssignTarget::Simple { 0: _field_0 } => {
                let _field_0 = <SimpleAssignTarget as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                AssignTarget::Simple { 0: _field_0 }
            }
            AssignTarget::Pat { 0: _field_0 } => {
                let _field_0 = <AssignTargetPat as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                AssignTarget::Pat { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for AssignTargetPat {
    #[doc = "Calls [FoldAstPath`::fold_assign_target_pat`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_assign_target_pat(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            AssignTargetPat::Array { 0: _field_0 } => {
                let _field_0 = <ArrayPat as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                AssignTargetPat::Array { 0: _field_0 }
            }
            AssignTargetPat::Object { 0: _field_0 } => {
                let _field_0 = <ObjectPat as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                AssignTargetPat::Object { 0: _field_0 }
            }
            AssignTargetPat::Invalid { 0: _field_0 } => {
                let _field_0 = <Invalid as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                AssignTargetPat::Invalid { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for AutoAccessor {
    #[doc = "Calls [FoldAstPath`::fold_auto_accessor`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_auto_accessor(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            AutoAccessor {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_override,
                definite,
            } => {
                let key = <Key as FoldWithAstPath<V>>::fold_with_ast_path(key, visitor, ast_path);
                let value = <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    value, visitor, ast_path,
                );
                let type_ann = <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                let decorators = <Vec<Decorator> as FoldWithAstPath<V>>::fold_with_ast_path(
                    decorators, visitor, ast_path,
                );
                let accessibility =
                    <Option<Accessibility> as FoldWithAstPath<V>>::fold_with_ast_path(
                        accessibility,
                        visitor,
                        ast_path,
                    );
                AutoAccessor {
                    span,
                    key,
                    value,
                    type_ann,
                    is_static,
                    decorators,
                    accessibility,
                    is_abstract,
                    is_override,
                    definite,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for AwaitExpr {
    #[doc = "Calls [FoldAstPath`::fold_await_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_await_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            AwaitExpr { span, arg } => {
                let arg =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(arg, visitor, ast_path);
                AwaitExpr { span, arg }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for BigInt {
    #[doc = "Calls [FoldAstPath`::fold_big_int`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_big_int(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            BigInt { span, value, raw } => BigInt { span, value, raw },
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for BinExpr {
    #[doc = "Calls [FoldAstPath`::fold_bin_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_bin_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            BinExpr {
                span,
                op,
                left,
                right,
            } => {
                let op =
                    <BinaryOp as FoldWithAstPath<V>>::fold_with_ast_path(op, visitor, ast_path);
                let left =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(left, visitor, ast_path);
                let right =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(right, visitor, ast_path);
                BinExpr {
                    span,
                    op,
                    left,
                    right,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for BinaryOp {
    #[doc = "Calls [FoldAstPath`::fold_binary_op`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_binary_op(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            BinaryOp::EqEq => BinaryOp::EqEq,
            BinaryOp::NotEq => BinaryOp::NotEq,
            BinaryOp::EqEqEq => BinaryOp::EqEqEq,
            BinaryOp::NotEqEq => BinaryOp::NotEqEq,
            BinaryOp::Lt => BinaryOp::Lt,
            BinaryOp::LtEq => BinaryOp::LtEq,
            BinaryOp::Gt => BinaryOp::Gt,
            BinaryOp::GtEq => BinaryOp::GtEq,
            BinaryOp::LShift => BinaryOp::LShift,
            BinaryOp::RShift => BinaryOp::RShift,
            BinaryOp::ZeroFillRShift => BinaryOp::ZeroFillRShift,
            BinaryOp::Add => BinaryOp::Add,
            BinaryOp::Sub => BinaryOp::Sub,
            BinaryOp::Mul => BinaryOp::Mul,
            BinaryOp::Div => BinaryOp::Div,
            BinaryOp::Mod => BinaryOp::Mod,
            BinaryOp::BitOr => BinaryOp::BitOr,
            BinaryOp::BitXor => BinaryOp::BitXor,
            BinaryOp::BitAnd => BinaryOp::BitAnd,
            BinaryOp::LogicalOr => BinaryOp::LogicalOr,
            BinaryOp::LogicalAnd => BinaryOp::LogicalAnd,
            BinaryOp::In => BinaryOp::In,
            BinaryOp::InstanceOf => BinaryOp::InstanceOf,
            BinaryOp::Exp => BinaryOp::Exp,
            BinaryOp::NullishCoalescing => BinaryOp::NullishCoalescing,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for BindingIdent {
    #[doc = "Calls [FoldAstPath`::fold_binding_ident`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_binding_ident(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            BindingIdent { id, type_ann } => {
                let id = <Ident as FoldWithAstPath<V>>::fold_with_ast_path(id, visitor, ast_path);
                let type_ann = <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                BindingIdent { id, type_ann }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for BlockStmt {
    #[doc = "Calls [FoldAstPath`::fold_block_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_block_stmt(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            BlockStmt { span, ctxt, stmts } => {
                let stmts =
                    <Vec<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(stmts, visitor, ast_path);
                BlockStmt { span, ctxt, stmts }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for BlockStmtOrExpr {
    #[doc = "Calls [FoldAstPath`::fold_block_stmt_or_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_block_stmt_or_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            BlockStmtOrExpr::BlockStmt { 0: _field_0 } => {
                let _field_0 = <BlockStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                BlockStmtOrExpr::BlockStmt { 0: _field_0 }
            }
            BlockStmtOrExpr::Expr { 0: _field_0 } => {
                let _field_0 = <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                BlockStmtOrExpr::Expr { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Bool {
    #[doc = "Calls [FoldAstPath`::fold_bool`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_bool(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Bool { span, value } => Bool { span, value },
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for BreakStmt {
    #[doc = "Calls [FoldAstPath`::fold_break_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_break_stmt(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            BreakStmt { span, label } => {
                let label = <Option<Ident> as FoldWithAstPath<V>>::fold_with_ast_path(
                    label, visitor, ast_path,
                );
                BreakStmt { span, label }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for CallExpr {
    #[doc = "Calls [FoldAstPath`::fold_call_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_call_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            CallExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                let callee =
                    <Callee as FoldWithAstPath<V>>::fold_with_ast_path(callee, visitor, ast_path);
                let args = <Vec<ExprOrSpread> as FoldWithAstPath<V>>::fold_with_ast_path(
                    args, visitor, ast_path,
                );
                let type_args = < Option < Box < TsTypeParamInstantiation > > as FoldWithAstPath < V > > :: fold_with_ast_path (type_args , visitor , ast_path) ;
                CallExpr {
                    span,
                    ctxt,
                    callee,
                    args,
                    type_args,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Callee {
    #[doc = "Calls [FoldAstPath`::fold_callee`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_callee(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Callee::Super { 0: _field_0 } => {
                let _field_0 =
                    <Super as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                Callee::Super { 0: _field_0 }
            }
            Callee::Import { 0: _field_0 } => {
                let _field_0 =
                    <Import as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                Callee::Import { 0: _field_0 }
            }
            Callee::Expr { 0: _field_0 } => {
                let _field_0 = <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Callee::Expr { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for CatchClause {
    #[doc = "Calls [FoldAstPath`::fold_catch_clause`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_catch_clause(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            CatchClause { span, param, body } => {
                let param = <Option<Pat> as FoldWithAstPath<V>>::fold_with_ast_path(
                    param, visitor, ast_path,
                );
                let body =
                    <BlockStmt as FoldWithAstPath<V>>::fold_with_ast_path(body, visitor, ast_path);
                CatchClause { span, param, body }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Class {
    #[doc = "Calls [FoldAstPath`::fold_class`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_class(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Class {
                span,
                ctxt,
                decorators,
                body,
                super_class,
                is_abstract,
                type_params,
                super_type_params,
                implements,
            } => {
                let decorators = <Vec<Decorator> as FoldWithAstPath<V>>::fold_with_ast_path(
                    decorators, visitor, ast_path,
                );
                let body = <Vec<ClassMember> as FoldWithAstPath<V>>::fold_with_ast_path(
                    body, visitor, ast_path,
                );
                let super_class = <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    super_class,
                    visitor,
                    ast_path,
                );
                let type_params =
                    <Option<Box<TsTypeParamDecl>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_params,
                        visitor,
                        ast_path,
                    );
                let super_type_params = < Option < Box < TsTypeParamInstantiation > > as FoldWithAstPath < V > > :: fold_with_ast_path (super_type_params , visitor , ast_path) ;
                let implements =
                    <Vec<TsExprWithTypeArgs> as FoldWithAstPath<V>>::fold_with_ast_path(
                        implements, visitor, ast_path,
                    );
                Class {
                    span,
                    ctxt,
                    decorators,
                    body,
                    super_class,
                    is_abstract,
                    type_params,
                    super_type_params,
                    implements,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ClassDecl {
    #[doc = "Calls [FoldAstPath`::fold_class_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_class_decl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ClassDecl {
                ident,
                declare,
                class,
            } => {
                let ident =
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(ident, visitor, ast_path);
                let class = <Box<Class> as FoldWithAstPath<V>>::fold_with_ast_path(
                    class, visitor, ast_path,
                );
                ClassDecl {
                    ident,
                    declare,
                    class,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ClassExpr {
    #[doc = "Calls [FoldAstPath`::fold_class_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_class_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ClassExpr { ident, class } => {
                let ident = <Option<Ident> as FoldWithAstPath<V>>::fold_with_ast_path(
                    ident, visitor, ast_path,
                );
                let class = <Box<Class> as FoldWithAstPath<V>>::fold_with_ast_path(
                    class, visitor, ast_path,
                );
                ClassExpr { ident, class }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ClassMember {
    #[doc = "Calls [FoldAstPath`::fold_class_member`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_class_member(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ClassMember::Constructor { 0: _field_0 } => {
                let _field_0 = <Constructor as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ClassMember::Constructor { 0: _field_0 }
            }
            ClassMember::Method { 0: _field_0 } => ClassMember::Method { 0: _field_0 },
            ClassMember::PrivateMethod { 0: _field_0 } => {
                ClassMember::PrivateMethod { 0: _field_0 }
            }
            ClassMember::ClassProp { 0: _field_0 } => {
                let _field_0 = <ClassProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ClassMember::ClassProp { 0: _field_0 }
            }
            ClassMember::PrivateProp { 0: _field_0 } => {
                let _field_0 = <PrivateProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ClassMember::PrivateProp { 0: _field_0 }
            }
            ClassMember::TsIndexSignature { 0: _field_0 } => {
                let _field_0 = <TsIndexSignature as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ClassMember::TsIndexSignature { 0: _field_0 }
            }
            ClassMember::Empty { 0: _field_0 } => {
                let _field_0 = <EmptyStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ClassMember::Empty { 0: _field_0 }
            }
            ClassMember::StaticBlock { 0: _field_0 } => {
                let _field_0 = <StaticBlock as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ClassMember::StaticBlock { 0: _field_0 }
            }
            ClassMember::AutoAccessor { 0: _field_0 } => {
                let _field_0 = <AutoAccessor as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ClassMember::AutoAccessor { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ClassProp {
    #[doc = "Calls [FoldAstPath`::fold_class_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_class_prop(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ClassProp {
                span,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_abstract,
                is_optional,
                is_override,
                readonly,
                declare,
                definite,
            } => {
                let key =
                    <PropName as FoldWithAstPath<V>>::fold_with_ast_path(key, visitor, ast_path);
                let value = <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    value, visitor, ast_path,
                );
                let type_ann = <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                let decorators = <Vec<Decorator> as FoldWithAstPath<V>>::fold_with_ast_path(
                    decorators, visitor, ast_path,
                );
                let accessibility =
                    <Option<Accessibility> as FoldWithAstPath<V>>::fold_with_ast_path(
                        accessibility,
                        visitor,
                        ast_path,
                    );
                ClassProp {
                    span,
                    key,
                    value,
                    type_ann,
                    is_static,
                    decorators,
                    accessibility,
                    is_abstract,
                    is_optional,
                    is_override,
                    readonly,
                    declare,
                    definite,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ComputedPropName {
    #[doc = "Calls [FoldAstPath`::fold_computed_prop_name`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_computed_prop_name(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ComputedPropName { span, expr } => {
                let expr =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(expr, visitor, ast_path);
                ComputedPropName { span, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for CondExpr {
    #[doc = "Calls [FoldAstPath`::fold_cond_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_cond_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            CondExpr {
                span,
                test,
                cons,
                alt,
            } => {
                let test =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(test, visitor, ast_path);
                let cons =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(cons, visitor, ast_path);
                let alt =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(alt, visitor, ast_path);
                CondExpr {
                    span,
                    test,
                    cons,
                    alt,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Constructor {
    #[doc = "Calls [FoldAstPath`::fold_constructor`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_constructor(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Constructor {
                span,
                ctxt,
                key,
                params,
                body,
                accessibility,
                is_optional,
            } => {
                let key =
                    <PropName as FoldWithAstPath<V>>::fold_with_ast_path(key, visitor, ast_path);
                let params = <Vec<ParamOrTsParamProp> as FoldWithAstPath<V>>::fold_with_ast_path(
                    params, visitor, ast_path,
                );
                let body = <Option<BlockStmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                    body, visitor, ast_path,
                );
                let accessibility =
                    <Option<Accessibility> as FoldWithAstPath<V>>::fold_with_ast_path(
                        accessibility,
                        visitor,
                        ast_path,
                    );
                Constructor {
                    span,
                    ctxt,
                    key,
                    params,
                    body,
                    accessibility,
                    is_optional,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ContinueStmt {
    #[doc = "Calls [FoldAstPath`::fold_continue_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_continue_stmt(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ContinueStmt { span, label } => {
                let label = <Option<Ident> as FoldWithAstPath<V>>::fold_with_ast_path(
                    label, visitor, ast_path,
                );
                ContinueStmt { span, label }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for DebuggerStmt {
    #[doc = "Calls [FoldAstPath`::fold_debugger_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_debugger_stmt(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            DebuggerStmt { span } => DebuggerStmt { span },
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Decl {
    #[doc = "Calls [FoldAstPath`::fold_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_decl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Decl::Class { 0: _field_0 } => {
                let _field_0 = <ClassDecl as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Decl::Class { 0: _field_0 }
            }
            Decl::Fn { 0: _field_0 } => {
                let _field_0 =
                    <FnDecl as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                Decl::Fn { 0: _field_0 }
            }
            Decl::Var { 0: _field_0 } => {
                let _field_0 = <Box<VarDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Decl::Var { 0: _field_0 }
            }
            Decl::Using { 0: _field_0 } => {
                let _field_0 = <Box<UsingDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Decl::Using { 0: _field_0 }
            }
            Decl::TsInterface { 0: _field_0 } => {
                let _field_0 = <Box<TsInterfaceDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Decl::TsInterface { 0: _field_0 }
            }
            Decl::TsTypeAlias { 0: _field_0 } => {
                let _field_0 = <Box<TsTypeAliasDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Decl::TsTypeAlias { 0: _field_0 }
            }
            Decl::TsEnum { 0: _field_0 } => {
                let _field_0 = <Box<TsEnumDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Decl::TsEnum { 0: _field_0 }
            }
            Decl::TsModule { 0: _field_0 } => {
                let _field_0 = <Box<TsModuleDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Decl::TsModule { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Decorator {
    #[doc = "Calls [FoldAstPath`::fold_decorator`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_decorator(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Decorator { span, expr } => {
                let expr =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(expr, visitor, ast_path);
                Decorator { span, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for DefaultDecl {
    #[doc = "Calls [FoldAstPath`::fold_default_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_default_decl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            DefaultDecl::Class { 0: _field_0 } => {
                let _field_0 = <ClassExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                DefaultDecl::Class { 0: _field_0 }
            }
            DefaultDecl::Fn { 0: _field_0 } => {
                let _field_0 =
                    <FnExpr as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                DefaultDecl::Fn { 0: _field_0 }
            }
            DefaultDecl::TsInterfaceDecl { 0: _field_0 } => {
                let _field_0 = <Box<TsInterfaceDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                DefaultDecl::TsInterfaceDecl { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for DoWhileStmt {
    #[doc = "Calls [FoldAstPath`::fold_do_while_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_do_while_stmt(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            DoWhileStmt { span, test, body } => {
                let test =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(test, visitor, ast_path);
                let body =
                    <Box<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(body, visitor, ast_path);
                DoWhileStmt { span, test, body }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for EmptyStmt {
    #[doc = "Calls [FoldAstPath`::fold_empty_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_empty_stmt(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            EmptyStmt { span } => EmptyStmt { span },
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for EsVersion {
    #[doc = "Calls [FoldAstPath`::fold_es_version`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_es_version(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            EsVersion::Es3 => EsVersion::Es3,
            EsVersion::Es5 => EsVersion::Es5,
            EsVersion::Es2015 => EsVersion::Es2015,
            EsVersion::Es2016 => EsVersion::Es2016,
            EsVersion::Es2017 => EsVersion::Es2017,
            EsVersion::Es2018 => EsVersion::Es2018,
            EsVersion::Es2019 => EsVersion::Es2019,
            EsVersion::Es2020 => EsVersion::Es2020,
            EsVersion::Es2021 => EsVersion::Es2021,
            EsVersion::Es2022 => EsVersion::Es2022,
            EsVersion::EsNext => EsVersion::EsNext,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ExportAll {
    #[doc = "Calls [FoldAstPath`::fold_export_all`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_export_all(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ExportAll {
                span,
                src,
                type_only,
                with,
            } => {
                let src =
                    <Box<Str> as FoldWithAstPath<V>>::fold_with_ast_path(src, visitor, ast_path);
                let with = <Option<Box<ObjectLit>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    with, visitor, ast_path,
                );
                ExportAll {
                    span,
                    src,
                    type_only,
                    with,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ExportDecl {
    #[doc = "Calls [FoldAstPath`::fold_export_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_export_decl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ExportDecl { span, decl } => {
                let decl =
                    <Decl as FoldWithAstPath<V>>::fold_with_ast_path(decl, visitor, ast_path);
                ExportDecl { span, decl }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ExportDefaultDecl {
    #[doc = "Calls [FoldAstPath`::fold_export_default_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_export_default_decl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ExportDefaultDecl { span, decl } => {
                let decl = <DefaultDecl as FoldWithAstPath<V>>::fold_with_ast_path(
                    decl, visitor, ast_path,
                );
                ExportDefaultDecl { span, decl }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ExportDefaultExpr {
    #[doc = "Calls [FoldAstPath`::fold_export_default_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_export_default_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ExportDefaultExpr { span, expr } => {
                let expr =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(expr, visitor, ast_path);
                ExportDefaultExpr { span, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ExportDefaultSpecifier {
    #[doc = "Calls [FoldAstPath`::fold_export_default_specifier`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_export_default_specifier(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ExportDefaultSpecifier { exported } => {
                let exported =
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(exported, visitor, ast_path);
                ExportDefaultSpecifier { exported }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ExportNamedSpecifier {
    #[doc = "Calls [FoldAstPath`::fold_export_named_specifier`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_export_named_specifier(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ExportNamedSpecifier {
                span,
                orig,
                exported,
                is_type_only,
            } => {
                let orig = <ModuleExportName as FoldWithAstPath<V>>::fold_with_ast_path(
                    orig, visitor, ast_path,
                );
                let exported = <Option<ModuleExportName> as FoldWithAstPath<V>>::fold_with_ast_path(
                    exported, visitor, ast_path,
                );
                ExportNamedSpecifier {
                    span,
                    orig,
                    exported,
                    is_type_only,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ExportNamespaceSpecifier {
    #[doc = "Calls [FoldAstPath`::fold_export_namespace_specifier`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_export_namespace_specifier(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ExportNamespaceSpecifier { span, name } => {
                let name = <ModuleExportName as FoldWithAstPath<V>>::fold_with_ast_path(
                    name, visitor, ast_path,
                );
                ExportNamespaceSpecifier { span, name }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ExportSpecifier {
    #[doc = "Calls [FoldAstPath`::fold_export_specifier`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_export_specifier(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ExportSpecifier::Namespace { 0: _field_0 } => {
                let _field_0 = <ExportNamespaceSpecifier as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ExportSpecifier::Namespace { 0: _field_0 }
            }
            ExportSpecifier::Default { 0: _field_0 } => {
                let _field_0 = <ExportDefaultSpecifier as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ExportSpecifier::Default { 0: _field_0 }
            }
            ExportSpecifier::Named { 0: _field_0 } => {
                let _field_0 = <ExportNamedSpecifier as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ExportSpecifier::Named { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Expr {
    #[doc = "Calls [FoldAstPath`::fold_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Expr::This { 0: _field_0 } => {
                let _field_0 = <ThisExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::This { 0: _field_0 }
            }
            Expr::Array { 0: _field_0 } => {
                let _field_0 = <ArrayLit as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::Array { 0: _field_0 }
            }
            Expr::Object { 0: _field_0 } => {
                let _field_0 = <ObjectLit as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::Object { 0: _field_0 }
            }
            Expr::Fn { 0: _field_0 } => {
                let _field_0 =
                    <FnExpr as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                Expr::Fn { 0: _field_0 }
            }
            Expr::Unary { 0: _field_0 } => {
                let _field_0 = <UnaryExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::Unary { 0: _field_0 }
            }
            Expr::Update { 0: _field_0 } => {
                let _field_0 = <UpdateExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::Update { 0: _field_0 }
            }
            Expr::Bin { 0: _field_0 } => {
                let _field_0 = <BinExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::Bin { 0: _field_0 }
            }
            Expr::Assign { 0: _field_0 } => {
                let _field_0 = <AssignExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::Assign { 0: _field_0 }
            }
            Expr::Member { 0: _field_0 } => {
                let _field_0 = <MemberExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::Member { 0: _field_0 }
            }
            Expr::SuperProp { 0: _field_0 } => {
                let _field_0 = <SuperPropExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::SuperProp { 0: _field_0 }
            }
            Expr::Cond { 0: _field_0 } => {
                let _field_0 = <CondExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::Cond { 0: _field_0 }
            }
            Expr::Call { 0: _field_0 } => {
                let _field_0 = <CallExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::Call { 0: _field_0 }
            }
            Expr::New { 0: _field_0 } => {
                let _field_0 = <NewExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::New { 0: _field_0 }
            }
            Expr::Seq { 0: _field_0 } => {
                let _field_0 = <SeqExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::Seq { 0: _field_0 }
            }
            Expr::Ident { 0: _field_0 } => {
                let _field_0 =
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                Expr::Ident { 0: _field_0 }
            }
            Expr::Lit { 0: _field_0 } => {
                let _field_0 =
                    <Lit as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                Expr::Lit { 0: _field_0 }
            }
            Expr::Tpl { 0: _field_0 } => {
                let _field_0 =
                    <Tpl as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                Expr::Tpl { 0: _field_0 }
            }
            Expr::TaggedTpl { 0: _field_0 } => {
                let _field_0 = <TaggedTpl as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::TaggedTpl { 0: _field_0 }
            }
            Expr::Arrow { 0: _field_0 } => {
                let _field_0 = <ArrowExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::Arrow { 0: _field_0 }
            }
            Expr::Class { 0: _field_0 } => {
                let _field_0 = <ClassExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::Class { 0: _field_0 }
            }
            Expr::Yield { 0: _field_0 } => {
                let _field_0 = <YieldExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::Yield { 0: _field_0 }
            }
            Expr::MetaProp { 0: _field_0 } => {
                let _field_0 = <MetaPropExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::MetaProp { 0: _field_0 }
            }
            Expr::Await { 0: _field_0 } => {
                let _field_0 = <AwaitExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::Await { 0: _field_0 }
            }
            Expr::Paren { 0: _field_0 } => {
                let _field_0 = <ParenExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::Paren { 0: _field_0 }
            }
            Expr::JSXMember { 0: _field_0 } => {
                let _field_0 = <JSXMemberExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::JSXMember { 0: _field_0 }
            }
            Expr::JSXNamespacedName { 0: _field_0 } => {
                let _field_0 = <JSXNamespacedName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::JSXNamespacedName { 0: _field_0 }
            }
            Expr::JSXEmpty { 0: _field_0 } => {
                let _field_0 = <JSXEmptyExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::JSXEmpty { 0: _field_0 }
            }
            Expr::JSXElement { 0: _field_0 } => {
                let _field_0 = <Box<JSXElement> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::JSXElement { 0: _field_0 }
            }
            Expr::JSXFragment { 0: _field_0 } => {
                let _field_0 = <JSXFragment as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::JSXFragment { 0: _field_0 }
            }
            Expr::TsTypeAssertion { 0: _field_0 } => {
                let _field_0 = <TsTypeAssertion as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::TsTypeAssertion { 0: _field_0 }
            }
            Expr::TsConstAssertion { 0: _field_0 } => {
                let _field_0 = <TsConstAssertion as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::TsConstAssertion { 0: _field_0 }
            }
            Expr::TsNonNull { 0: _field_0 } => {
                let _field_0 = <TsNonNullExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::TsNonNull { 0: _field_0 }
            }
            Expr::TsAs { 0: _field_0 } => {
                let _field_0 = <TsAsExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::TsAs { 0: _field_0 }
            }
            Expr::TsInstantiation { 0: _field_0 } => {
                let _field_0 = <TsInstantiation as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::TsInstantiation { 0: _field_0 }
            }
            Expr::TsSatisfies { 0: _field_0 } => {
                let _field_0 = <TsSatisfiesExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::TsSatisfies { 0: _field_0 }
            }
            Expr::PrivateName { 0: _field_0 } => {
                let _field_0 = <PrivateName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::PrivateName { 0: _field_0 }
            }
            Expr::OptChain { 0: _field_0 } => {
                let _field_0 = <OptChainExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::OptChain { 0: _field_0 }
            }
            Expr::Invalid { 0: _field_0 } => {
                let _field_0 = <Invalid as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Expr::Invalid { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ExprOrSpread {
    #[doc = "Calls [FoldAstPath`::fold_expr_or_spread`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_expr_or_spread(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ExprOrSpread { spread, expr } => {
                let expr =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(expr, visitor, ast_path);
                ExprOrSpread { spread, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ExprStmt {
    #[doc = "Calls [FoldAstPath`::fold_expr_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_expr_stmt(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ExprStmt { span, expr } => {
                let expr =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(expr, visitor, ast_path);
                ExprStmt { span, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for FnDecl {
    #[doc = "Calls [FoldAstPath`::fold_fn_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_fn_decl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            FnDecl {
                ident,
                declare,
                function,
            } => {
                let ident =
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(ident, visitor, ast_path);
                let function = <Box<Function> as FoldWithAstPath<V>>::fold_with_ast_path(
                    function, visitor, ast_path,
                );
                FnDecl {
                    ident,
                    declare,
                    function,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for FnExpr {
    #[doc = "Calls [FoldAstPath`::fold_fn_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_fn_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            FnExpr { ident, function } => {
                let ident = <Option<Ident> as FoldWithAstPath<V>>::fold_with_ast_path(
                    ident, visitor, ast_path,
                );
                let function = <Box<Function> as FoldWithAstPath<V>>::fold_with_ast_path(
                    function, visitor, ast_path,
                );
                FnExpr { ident, function }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ForHead {
    #[doc = "Calls [FoldAstPath`::fold_for_head`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_for_head(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ForHead::VarDecl { 0: _field_0 } => {
                let _field_0 = <Box<VarDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ForHead::VarDecl { 0: _field_0 }
            }
            ForHead::UsingDecl { 0: _field_0 } => {
                let _field_0 = <Box<UsingDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ForHead::UsingDecl { 0: _field_0 }
            }
            ForHead::Pat { 0: _field_0 } => {
                let _field_0 = <Box<Pat> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ForHead::Pat { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ForInStmt {
    #[doc = "Calls [FoldAstPath`::fold_for_in_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_for_in_stmt(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ForInStmt {
                span,
                left,
                right,
                body,
            } => {
                let left =
                    <ForHead as FoldWithAstPath<V>>::fold_with_ast_path(left, visitor, ast_path);
                let right =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(right, visitor, ast_path);
                let body =
                    <Box<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(body, visitor, ast_path);
                ForInStmt {
                    span,
                    left,
                    right,
                    body,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ForOfStmt {
    #[doc = "Calls [FoldAstPath`::fold_for_of_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_for_of_stmt(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ForOfStmt {
                span,
                is_await,
                left,
                right,
                body,
            } => {
                let left =
                    <ForHead as FoldWithAstPath<V>>::fold_with_ast_path(left, visitor, ast_path);
                let right =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(right, visitor, ast_path);
                let body =
                    <Box<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(body, visitor, ast_path);
                ForOfStmt {
                    span,
                    is_await,
                    left,
                    right,
                    body,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ForStmt {
    #[doc = "Calls [FoldAstPath`::fold_for_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_for_stmt(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ForStmt {
                span,
                init,
                test,
                update,
                body,
            } => {
                let init = <Option<VarDeclOrExpr> as FoldWithAstPath<V>>::fold_with_ast_path(
                    init, visitor, ast_path,
                );
                let test = <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    test, visitor, ast_path,
                );
                let update = <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    update, visitor, ast_path,
                );
                let body =
                    <Box<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(body, visitor, ast_path);
                ForStmt {
                    span,
                    init,
                    test,
                    update,
                    body,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Function {
    #[doc = "Calls [FoldAstPath`::fold_function`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_function(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Function {
                params,
                decorators,
                span,
                ctxt,
                body,
                is_generator,
                is_async,
                type_params,
                return_type,
            } => {
                let params = <Vec<Param> as FoldWithAstPath<V>>::fold_with_ast_path(
                    params, visitor, ast_path,
                );
                let decorators = <Vec<Decorator> as FoldWithAstPath<V>>::fold_with_ast_path(
                    decorators, visitor, ast_path,
                );
                let body = <Option<BlockStmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                    body, visitor, ast_path,
                );
                let type_params =
                    <Option<Box<TsTypeParamDecl>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_params,
                        visitor,
                        ast_path,
                    );
                let return_type =
                    <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        return_type,
                        visitor,
                        ast_path,
                    );
                Function {
                    params,
                    decorators,
                    span,
                    ctxt,
                    body,
                    is_generator,
                    is_async,
                    type_params,
                    return_type,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for GetterProp {
    #[doc = "Calls [FoldAstPath`::fold_getter_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_getter_prop(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            GetterProp {
                span,
                key,
                type_ann,
                body,
            } => {
                let key =
                    <PropName as FoldWithAstPath<V>>::fold_with_ast_path(key, visitor, ast_path);
                let type_ann = <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                let body = <Option<BlockStmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                    body, visitor, ast_path,
                );
                GetterProp {
                    span,
                    key,
                    type_ann,
                    body,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Ident {
    #[doc = "Calls [FoldAstPath`::fold_ident`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ident(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Ident {
                span,
                ctxt,
                sym,
                optional,
            } => Ident {
                span,
                ctxt,
                sym,
                optional,
            },
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for IdentName {
    #[doc = "Calls [FoldAstPath`::fold_ident_name`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ident_name(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            IdentName { span, sym } => IdentName { span, sym },
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for IfStmt {
    #[doc = "Calls [FoldAstPath`::fold_if_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_if_stmt(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            IfStmt {
                span,
                test,
                cons,
                alt,
            } => {
                let test =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(test, visitor, ast_path);
                let cons =
                    <Box<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(cons, visitor, ast_path);
                let alt = <Option<Box<Stmt>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    alt, visitor, ast_path,
                );
                IfStmt {
                    span,
                    test,
                    cons,
                    alt,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Import {
    #[doc = "Calls [FoldAstPath`::fold_import`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Import { span, phase } => {
                let phase = <ImportPhase as FoldWithAstPath<V>>::fold_with_ast_path(
                    phase, visitor, ast_path,
                );
                Import { span, phase }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ImportDecl {
    #[doc = "Calls [FoldAstPath`::fold_import_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import_decl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ImportDecl {
                span,
                specifiers,
                src,
                type_only,
                with,
                phase,
            } => {
                let specifiers = <Vec<ImportSpecifier> as FoldWithAstPath<V>>::fold_with_ast_path(
                    specifiers, visitor, ast_path,
                );
                let src =
                    <Box<Str> as FoldWithAstPath<V>>::fold_with_ast_path(src, visitor, ast_path);
                let with = <Option<Box<ObjectLit>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    with, visitor, ast_path,
                );
                let phase = <ImportPhase as FoldWithAstPath<V>>::fold_with_ast_path(
                    phase, visitor, ast_path,
                );
                ImportDecl {
                    span,
                    specifiers,
                    src,
                    type_only,
                    with,
                    phase,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ImportDefaultSpecifier {
    #[doc = "Calls [FoldAstPath`::fold_import_default_specifier`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import_default_specifier(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ImportDefaultSpecifier { span, local } => {
                let local =
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(local, visitor, ast_path);
                ImportDefaultSpecifier { span, local }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ImportNamedSpecifier {
    #[doc = "Calls [FoldAstPath`::fold_import_named_specifier`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import_named_specifier(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ImportNamedSpecifier {
                span,
                local,
                imported,
                is_type_only,
            } => {
                let local =
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(local, visitor, ast_path);
                let imported = <Option<ModuleExportName> as FoldWithAstPath<V>>::fold_with_ast_path(
                    imported, visitor, ast_path,
                );
                ImportNamedSpecifier {
                    span,
                    local,
                    imported,
                    is_type_only,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ImportPhase {
    #[doc = "Calls [FoldAstPath`::fold_import_phase`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import_phase(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ImportPhase::Evaluation => ImportPhase::Evaluation,
            ImportPhase::Source => ImportPhase::Source,
            ImportPhase::Defer => ImportPhase::Defer,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ImportSpecifier {
    #[doc = "Calls [FoldAstPath`::fold_import_specifier`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import_specifier(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ImportSpecifier::Named { 0: _field_0 } => {
                let _field_0 = <ImportNamedSpecifier as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ImportSpecifier::Named { 0: _field_0 }
            }
            ImportSpecifier::Default { 0: _field_0 } => {
                let _field_0 = <ImportDefaultSpecifier as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ImportSpecifier::Default { 0: _field_0 }
            }
            ImportSpecifier::Namespace { 0: _field_0 } => {
                let _field_0 = <ImportStarAsSpecifier as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ImportSpecifier::Namespace { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ImportStarAsSpecifier {
    #[doc = "Calls [FoldAstPath`::fold_import_star_as_specifier`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import_star_as_specifier(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ImportStarAsSpecifier { span, local } => {
                let local =
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(local, visitor, ast_path);
                ImportStarAsSpecifier { span, local }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ImportWith {
    #[doc = "Calls [FoldAstPath`::fold_import_with`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import_with(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ImportWith { span, values } => {
                let values = <Vec<ImportWithItem> as FoldWithAstPath<V>>::fold_with_ast_path(
                    values, visitor, ast_path,
                );
                ImportWith { span, values }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ImportWithItem {
    #[doc = "Calls [FoldAstPath`::fold_import_with_item`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import_with_item(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ImportWithItem { key, value } => {
                let key =
                    <IdentName as FoldWithAstPath<V>>::fold_with_ast_path(key, visitor, ast_path);
                let value =
                    <Str as FoldWithAstPath<V>>::fold_with_ast_path(value, visitor, ast_path);
                ImportWithItem { key, value }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Invalid {
    #[doc = "Calls [FoldAstPath`::fold_invalid`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_invalid(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Invalid { span } => Invalid { span },
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXAttr {
    #[doc = "Calls [FoldAstPath`::fold_jsx_attr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_attr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXAttr { span, name, value } => {
                let name = <JSXAttrName as FoldWithAstPath<V>>::fold_with_ast_path(
                    name, visitor, ast_path,
                );
                let value = <Option<JSXAttrValue> as FoldWithAstPath<V>>::fold_with_ast_path(
                    value, visitor, ast_path,
                );
                JSXAttr { span, name, value }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXAttrName {
    #[doc = "Calls [FoldAstPath`::fold_jsx_attr_name`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_attr_name(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXAttrName::Ident { 0: _field_0 } => {
                let _field_0 = <IdentName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                JSXAttrName::Ident { 0: _field_0 }
            }
            JSXAttrName::JSXNamespacedName { 0: _field_0 } => {
                let _field_0 = <JSXNamespacedName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                JSXAttrName::JSXNamespacedName { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXAttrOrSpread {
    #[doc = "Calls [FoldAstPath`::fold_jsx_attr_or_spread`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_attr_or_spread(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXAttrOrSpread::JSXAttr { 0: _field_0 } => {
                let _field_0 = <JSXAttr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                JSXAttrOrSpread::JSXAttr { 0: _field_0 }
            }
            JSXAttrOrSpread::SpreadElement { 0: _field_0 } => {
                let _field_0 = <SpreadElement as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                JSXAttrOrSpread::SpreadElement { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXAttrValue {
    #[doc = "Calls [FoldAstPath`::fold_jsx_attr_value`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_attr_value(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXAttrValue::Lit { 0: _field_0 } => {
                let _field_0 =
                    <Lit as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                JSXAttrValue::Lit { 0: _field_0 }
            }
            JSXAttrValue::JSXExprContainer { 0: _field_0 } => {
                let _field_0 = <JSXExprContainer as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                JSXAttrValue::JSXExprContainer { 0: _field_0 }
            }
            JSXAttrValue::JSXElement { 0: _field_0 } => {
                let _field_0 = <Box<JSXElement> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                JSXAttrValue::JSXElement { 0: _field_0 }
            }
            JSXAttrValue::JSXFragment { 0: _field_0 } => {
                let _field_0 = <JSXFragment as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                JSXAttrValue::JSXFragment { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXClosingElement {
    #[doc = "Calls [FoldAstPath`::fold_jsx_closing_element`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_closing_element(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXClosingElement { span, name } => {
                let name = <JSXElementName as FoldWithAstPath<V>>::fold_with_ast_path(
                    name, visitor, ast_path,
                );
                JSXClosingElement { span, name }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXClosingFragment {
    #[doc = "Calls [FoldAstPath`::fold_jsx_closing_fragment`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_closing_fragment(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXClosingFragment { span } => JSXClosingFragment { span },
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXElement {
    #[doc = "Calls [FoldAstPath`::fold_jsx_element`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_element(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXElement {
                span,
                opening,
                children,
                closing,
            } => {
                let opening = <JSXOpeningElement as FoldWithAstPath<V>>::fold_with_ast_path(
                    opening, visitor, ast_path,
                );
                let children = <Vec<JSXElementChild> as FoldWithAstPath<V>>::fold_with_ast_path(
                    children, visitor, ast_path,
                );
                let closing = <Option<JSXClosingElement> as FoldWithAstPath<V>>::fold_with_ast_path(
                    closing, visitor, ast_path,
                );
                JSXElement {
                    span,
                    opening,
                    children,
                    closing,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXElementChild {
    #[doc = "Calls [FoldAstPath`::fold_jsx_element_child`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_element_child(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXElementChild::JSXText { 0: _field_0 } => {
                let _field_0 = <JSXText as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                JSXElementChild::JSXText { 0: _field_0 }
            }
            JSXElementChild::JSXExprContainer { 0: _field_0 } => {
                let _field_0 = <JSXExprContainer as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                JSXElementChild::JSXExprContainer { 0: _field_0 }
            }
            JSXElementChild::JSXSpreadChild { 0: _field_0 } => {
                let _field_0 = <JSXSpreadChild as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                JSXElementChild::JSXSpreadChild { 0: _field_0 }
            }
            JSXElementChild::JSXElement { 0: _field_0 } => {
                let _field_0 = <Box<JSXElement> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                JSXElementChild::JSXElement { 0: _field_0 }
            }
            JSXElementChild::JSXFragment { 0: _field_0 } => {
                let _field_0 = <JSXFragment as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                JSXElementChild::JSXFragment { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXElementName {
    #[doc = "Calls [FoldAstPath`::fold_jsx_element_name`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_element_name(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXElementName::Ident { 0: _field_0 } => {
                let _field_0 =
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                JSXElementName::Ident { 0: _field_0 }
            }
            JSXElementName::JSXMemberExpr { 0: _field_0 } => {
                let _field_0 = <JSXMemberExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                JSXElementName::JSXMemberExpr { 0: _field_0 }
            }
            JSXElementName::JSXNamespacedName { 0: _field_0 } => {
                let _field_0 = <JSXNamespacedName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                JSXElementName::JSXNamespacedName { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXEmptyExpr {
    #[doc = "Calls [FoldAstPath`::fold_jsx_empty_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_empty_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXEmptyExpr { span } => JSXEmptyExpr { span },
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXExpr {
    #[doc = "Calls [FoldAstPath`::fold_jsx_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXExpr::JSXEmptyExpr { 0: _field_0 } => {
                let _field_0 = <JSXEmptyExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                JSXExpr::JSXEmptyExpr { 0: _field_0 }
            }
            JSXExpr::Expr { 0: _field_0 } => {
                let _field_0 = <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                JSXExpr::Expr { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXExprContainer {
    #[doc = "Calls [FoldAstPath`::fold_jsx_expr_container`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_expr_container(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXExprContainer { span, expr } => {
                let expr =
                    <JSXExpr as FoldWithAstPath<V>>::fold_with_ast_path(expr, visitor, ast_path);
                JSXExprContainer { span, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXFragment {
    #[doc = "Calls [FoldAstPath`::fold_jsx_fragment`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_fragment(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXFragment {
                span,
                opening,
                children,
                closing,
            } => {
                let opening = <JSXOpeningFragment as FoldWithAstPath<V>>::fold_with_ast_path(
                    opening, visitor, ast_path,
                );
                let children = <Vec<JSXElementChild> as FoldWithAstPath<V>>::fold_with_ast_path(
                    children, visitor, ast_path,
                );
                let closing = <JSXClosingFragment as FoldWithAstPath<V>>::fold_with_ast_path(
                    closing, visitor, ast_path,
                );
                JSXFragment {
                    span,
                    opening,
                    children,
                    closing,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXMemberExpr {
    #[doc = "Calls [FoldAstPath`::fold_jsx_member_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_member_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXMemberExpr { span, obj, prop } => {
                let obj =
                    <JSXObject as FoldWithAstPath<V>>::fold_with_ast_path(obj, visitor, ast_path);
                let prop =
                    <IdentName as FoldWithAstPath<V>>::fold_with_ast_path(prop, visitor, ast_path);
                JSXMemberExpr { span, obj, prop }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXNamespacedName {
    #[doc = "Calls [FoldAstPath`::fold_jsx_namespaced_name`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_namespaced_name(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXNamespacedName { span, ns, name } => {
                let ns =
                    <IdentName as FoldWithAstPath<V>>::fold_with_ast_path(ns, visitor, ast_path);
                let name =
                    <IdentName as FoldWithAstPath<V>>::fold_with_ast_path(name, visitor, ast_path);
                JSXNamespacedName { span, ns, name }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXObject {
    #[doc = "Calls [FoldAstPath`::fold_jsx_object`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_object(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXObject::JSXMemberExpr { 0: _field_0 } => {
                let _field_0 = <Box<JSXMemberExpr> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                JSXObject::JSXMemberExpr { 0: _field_0 }
            }
            JSXObject::Ident { 0: _field_0 } => {
                let _field_0 =
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                JSXObject::Ident { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXOpeningElement {
    #[doc = "Calls [FoldAstPath`::fold_jsx_opening_element`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_opening_element(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXOpeningElement {
                name,
                span,
                attrs,
                self_closing,
                type_args,
            } => {
                let name = <JSXElementName as FoldWithAstPath<V>>::fold_with_ast_path(
                    name, visitor, ast_path,
                );
                let attrs = <Vec<JSXAttrOrSpread> as FoldWithAstPath<V>>::fold_with_ast_path(
                    attrs, visitor, ast_path,
                );
                let type_args = < Option < Box < TsTypeParamInstantiation > > as FoldWithAstPath < V > > :: fold_with_ast_path (type_args , visitor , ast_path) ;
                JSXOpeningElement {
                    name,
                    span,
                    attrs,
                    self_closing,
                    type_args,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXOpeningFragment {
    #[doc = "Calls [FoldAstPath`::fold_jsx_opening_fragment`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_opening_fragment(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXOpeningFragment { span } => JSXOpeningFragment { span },
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXSpreadChild {
    #[doc = "Calls [FoldAstPath`::fold_jsx_spread_child`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_spread_child(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXSpreadChild { span, expr } => {
                let expr =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(expr, visitor, ast_path);
                JSXSpreadChild { span, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for JSXText {
    #[doc = "Calls [FoldAstPath`::fold_jsx_text`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_text(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            JSXText { span, value, raw } => JSXText { span, value, raw },
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Key {
    #[doc = "Calls [FoldAstPath`::fold_key`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_key(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Key::Private { 0: _field_0 } => {
                let _field_0 = <PrivateName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Key::Private { 0: _field_0 }
            }
            Key::Public { 0: _field_0 } => {
                let _field_0 = <PropName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Key::Public { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for KeyValuePatProp {
    #[doc = "Calls [FoldAstPath`::fold_key_value_pat_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_key_value_pat_prop(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            KeyValuePatProp { key, value } => {
                let key =
                    <PropName as FoldWithAstPath<V>>::fold_with_ast_path(key, visitor, ast_path);
                let value =
                    <Box<Pat> as FoldWithAstPath<V>>::fold_with_ast_path(value, visitor, ast_path);
                KeyValuePatProp { key, value }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for KeyValueProp {
    #[doc = "Calls [FoldAstPath`::fold_key_value_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_key_value_prop(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            KeyValueProp { key, value } => {
                let key =
                    <PropName as FoldWithAstPath<V>>::fold_with_ast_path(key, visitor, ast_path);
                let value =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(value, visitor, ast_path);
                KeyValueProp { key, value }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for LabeledStmt {
    #[doc = "Calls [FoldAstPath`::fold_labeled_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_labeled_stmt(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            LabeledStmt { span, label, body } => {
                let label =
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(label, visitor, ast_path);
                let body =
                    <Box<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(body, visitor, ast_path);
                LabeledStmt { span, label, body }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Lit {
    #[doc = "Calls [FoldAstPath`::fold_lit`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_lit(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Lit::Str { 0: _field_0 } => {
                let _field_0 =
                    <Str as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                Lit::Str { 0: _field_0 }
            }
            Lit::Bool { 0: _field_0 } => {
                let _field_0 =
                    <Bool as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                Lit::Bool { 0: _field_0 }
            }
            Lit::Null { 0: _field_0 } => {
                let _field_0 =
                    <Null as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                Lit::Null { 0: _field_0 }
            }
            Lit::Num { 0: _field_0 } => {
                let _field_0 =
                    <Number as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                Lit::Num { 0: _field_0 }
            }
            Lit::BigInt { 0: _field_0 } => {
                let _field_0 =
                    <BigInt as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                Lit::BigInt { 0: _field_0 }
            }
            Lit::Regex { 0: _field_0 } => {
                let _field_0 =
                    <Regex as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                Lit::Regex { 0: _field_0 }
            }
            Lit::JSXText { 0: _field_0 } => {
                let _field_0 = <JSXText as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Lit::JSXText { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for MemberExpr {
    #[doc = "Calls [FoldAstPath`::fold_member_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_member_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            MemberExpr { span, obj, prop } => {
                let obj =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(obj, visitor, ast_path);
                let prop =
                    <MemberProp as FoldWithAstPath<V>>::fold_with_ast_path(prop, visitor, ast_path);
                MemberExpr { span, obj, prop }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for MemberProp {
    #[doc = "Calls [FoldAstPath`::fold_member_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_member_prop(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            MemberProp::Ident { 0: _field_0 } => {
                let _field_0 = <IdentName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                MemberProp::Ident { 0: _field_0 }
            }
            MemberProp::PrivateName { 0: _field_0 } => {
                let _field_0 = <PrivateName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                MemberProp::PrivateName { 0: _field_0 }
            }
            MemberProp::Computed { 0: _field_0 } => {
                let _field_0 = <ComputedPropName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                MemberProp::Computed { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for MetaPropExpr {
    #[doc = "Calls [FoldAstPath`::fold_meta_prop_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_meta_prop_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            MetaPropExpr { span, kind } => {
                let kind = <MetaPropKind as FoldWithAstPath<V>>::fold_with_ast_path(
                    kind, visitor, ast_path,
                );
                MetaPropExpr { span, kind }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for MetaPropKind {
    #[doc = "Calls [FoldAstPath`::fold_meta_prop_kind`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_meta_prop_kind(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            MetaPropKind::NewTarget => MetaPropKind::NewTarget,
            MetaPropKind::ImportMeta => MetaPropKind::ImportMeta,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for MethodKind {
    #[doc = "Calls [FoldAstPath`::fold_method_kind`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_method_kind(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            MethodKind::Method => MethodKind::Method,
            MethodKind::Getter => MethodKind::Getter,
            MethodKind::Setter => MethodKind::Setter,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for MethodProp {
    #[doc = "Calls [FoldAstPath`::fold_method_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_method_prop(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            MethodProp { key, function } => {
                let key =
                    <PropName as FoldWithAstPath<V>>::fold_with_ast_path(key, visitor, ast_path);
                let function = <Box<Function> as FoldWithAstPath<V>>::fold_with_ast_path(
                    function, visitor, ast_path,
                );
                MethodProp { key, function }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Module {
    #[doc = "Calls [FoldAstPath`::fold_module`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_module(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Module {
                span,
                body,
                shebang,
            } => {
                let body = <Vec<ModuleItem> as FoldWithAstPath<V>>::fold_with_ast_path(
                    body, visitor, ast_path,
                );
                Module {
                    span,
                    body,
                    shebang,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ModuleDecl {
    #[doc = "Calls [FoldAstPath`::fold_module_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_module_decl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ModuleDecl::Import { 0: _field_0 } => {
                let _field_0 = <ImportDecl as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ModuleDecl::Import { 0: _field_0 }
            }
            ModuleDecl::ExportDecl { 0: _field_0 } => {
                let _field_0 = <ExportDecl as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ModuleDecl::ExportDecl { 0: _field_0 }
            }
            ModuleDecl::ExportNamed { 0: _field_0 } => {
                let _field_0 = <NamedExport as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ModuleDecl::ExportNamed { 0: _field_0 }
            }
            ModuleDecl::ExportDefaultDecl { 0: _field_0 } => {
                let _field_0 = <ExportDefaultDecl as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ModuleDecl::ExportDefaultDecl { 0: _field_0 }
            }
            ModuleDecl::ExportDefaultExpr { 0: _field_0 } => {
                let _field_0 = <ExportDefaultExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ModuleDecl::ExportDefaultExpr { 0: _field_0 }
            }
            ModuleDecl::ExportAll { 0: _field_0 } => {
                let _field_0 = <ExportAll as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ModuleDecl::ExportAll { 0: _field_0 }
            }
            ModuleDecl::TsImportEquals { 0: _field_0 } => {
                let _field_0 = <Box<TsImportEqualsDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ModuleDecl::TsImportEquals { 0: _field_0 }
            }
            ModuleDecl::TsExportAssignment { 0: _field_0 } => {
                let _field_0 = <TsExportAssignment as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ModuleDecl::TsExportAssignment { 0: _field_0 }
            }
            ModuleDecl::TsNamespaceExport { 0: _field_0 } => {
                let _field_0 = <TsNamespaceExportDecl as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ModuleDecl::TsNamespaceExport { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ModuleExportName {
    #[doc = "Calls [FoldAstPath`::fold_module_export_name`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_module_export_name(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ModuleExportName::Ident { 0: _field_0 } => {
                let _field_0 =
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                ModuleExportName::Ident { 0: _field_0 }
            }
            ModuleExportName::Str { 0: _field_0 } => {
                let _field_0 =
                    <Str as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                ModuleExportName::Str { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ModuleItem {
    #[doc = "Calls [FoldAstPath`::fold_module_item`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_module_item(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ModuleItem::ModuleDecl { 0: _field_0 } => {
                let _field_0 = <ModuleDecl as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ModuleItem::ModuleDecl { 0: _field_0 }
            }
            ModuleItem::Stmt { 0: _field_0 } => {
                let _field_0 =
                    <Stmt as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                ModuleItem::Stmt { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for NamedExport {
    #[doc = "Calls [FoldAstPath`::fold_named_export`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_named_export(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            NamedExport {
                span,
                specifiers,
                src,
                type_only,
                with,
            } => {
                let specifiers = <Vec<ExportSpecifier> as FoldWithAstPath<V>>::fold_with_ast_path(
                    specifiers, visitor, ast_path,
                );
                let src = <Option<Box<Str>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    src, visitor, ast_path,
                );
                let with = <Option<Box<ObjectLit>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    with, visitor, ast_path,
                );
                NamedExport {
                    span,
                    specifiers,
                    src,
                    type_only,
                    with,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for NewExpr {
    #[doc = "Calls [FoldAstPath`::fold_new_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_new_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            NewExpr {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                let callee = <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                    callee, visitor, ast_path,
                );
                let args = <Option<Vec<ExprOrSpread>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    args, visitor, ast_path,
                );
                let type_args = < Option < Box < TsTypeParamInstantiation > > as FoldWithAstPath < V > > :: fold_with_ast_path (type_args , visitor , ast_path) ;
                NewExpr {
                    span,
                    ctxt,
                    callee,
                    args,
                    type_args,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Null {
    #[doc = "Calls [FoldAstPath`::fold_null`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_null(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Null { span } => Null { span },
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Number {
    #[doc = "Calls [FoldAstPath`::fold_number`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_number(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Number { span, value, raw } => Number { span, value, raw },
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ObjectLit {
    #[doc = "Calls [FoldAstPath`::fold_object_lit`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_object_lit(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ObjectLit { span, props } => {
                let props = <Vec<PropOrSpread> as FoldWithAstPath<V>>::fold_with_ast_path(
                    props, visitor, ast_path,
                );
                ObjectLit { span, props }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ObjectPat {
    #[doc = "Calls [FoldAstPath`::fold_object_pat`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_object_pat(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ObjectPat {
                span,
                props,
                optional,
                type_ann,
            } => {
                let props = <Vec<ObjectPatProp> as FoldWithAstPath<V>>::fold_with_ast_path(
                    props, visitor, ast_path,
                );
                let type_ann = <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                ObjectPat {
                    span,
                    props,
                    optional,
                    type_ann,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ObjectPatProp {
    #[doc = "Calls [FoldAstPath`::fold_object_pat_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_object_pat_prop(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ObjectPatProp::KeyValue { 0: _field_0 } => {
                let _field_0 = <KeyValuePatProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ObjectPatProp::KeyValue { 0: _field_0 }
            }
            ObjectPatProp::Assign { 0: _field_0 } => {
                let _field_0 = <AssignPatProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ObjectPatProp::Assign { 0: _field_0 }
            }
            ObjectPatProp::Rest { 0: _field_0 } => {
                let _field_0 = <RestPat as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ObjectPatProp::Rest { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for OptCall {
    #[doc = "Calls [FoldAstPath`::fold_opt_call`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_call(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            OptCall {
                span,
                ctxt,
                callee,
                args,
                type_args,
            } => {
                let callee = <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                    callee, visitor, ast_path,
                );
                let args = <Vec<ExprOrSpread> as FoldWithAstPath<V>>::fold_with_ast_path(
                    args, visitor, ast_path,
                );
                let type_args = < Option < Box < TsTypeParamInstantiation > > as FoldWithAstPath < V > > :: fold_with_ast_path (type_args , visitor , ast_path) ;
                OptCall {
                    span,
                    ctxt,
                    callee,
                    args,
                    type_args,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for OptChainBase {
    #[doc = "Calls [FoldAstPath`::fold_opt_chain_base`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_chain_base(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            OptChainBase::Member { 0: _field_0 } => {
                let _field_0 = <MemberExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                OptChainBase::Member { 0: _field_0 }
            }
            OptChainBase::Call { 0: _field_0 } => {
                let _field_0 = <OptCall as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                OptChainBase::Call { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for OptChainExpr {
    #[doc = "Calls [FoldAstPath`::fold_opt_chain_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_chain_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            OptChainExpr {
                span,
                optional,
                base,
            } => {
                let base = <Box<OptChainBase> as FoldWithAstPath<V>>::fold_with_ast_path(
                    base, visitor, ast_path,
                );
                OptChainExpr {
                    span,
                    optional,
                    base,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Param {
    #[doc = "Calls [FoldAstPath`::fold_param`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_param(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Param {
                span,
                decorators,
                pat,
            } => {
                let decorators = <Vec<Decorator> as FoldWithAstPath<V>>::fold_with_ast_path(
                    decorators, visitor, ast_path,
                );
                let pat = <Pat as FoldWithAstPath<V>>::fold_with_ast_path(pat, visitor, ast_path);
                Param {
                    span,
                    decorators,
                    pat,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ParamOrTsParamProp {
    #[doc = "Calls [FoldAstPath`::fold_param_or_ts_param_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_param_or_ts_param_prop(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ParamOrTsParamProp::TsParamProp { 0: _field_0 } => {
                let _field_0 = <TsParamProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                ParamOrTsParamProp::TsParamProp { 0: _field_0 }
            }
            ParamOrTsParamProp::Param { 0: _field_0 } => {
                let _field_0 =
                    <Param as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                ParamOrTsParamProp::Param { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ParenExpr {
    #[doc = "Calls [FoldAstPath`::fold_paren_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_paren_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ParenExpr { span, expr } => {
                let expr =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(expr, visitor, ast_path);
                ParenExpr { span, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Pat {
    #[doc = "Calls [FoldAstPath`::fold_pat`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_pat(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Pat::Ident { 0: _field_0 } => {
                let _field_0 = <BindingIdent as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Pat::Ident { 0: _field_0 }
            }
            Pat::Array { 0: _field_0 } => {
                let _field_0 = <ArrayPat as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Pat::Array { 0: _field_0 }
            }
            Pat::Rest { 0: _field_0 } => {
                let _field_0 = <RestPat as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Pat::Rest { 0: _field_0 }
            }
            Pat::Object { 0: _field_0 } => {
                let _field_0 = <ObjectPat as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Pat::Object { 0: _field_0 }
            }
            Pat::Assign { 0: _field_0 } => {
                let _field_0 = <AssignPat as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Pat::Assign { 0: _field_0 }
            }
            Pat::Invalid { 0: _field_0 } => {
                let _field_0 = <Invalid as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Pat::Invalid { 0: _field_0 }
            }
            Pat::Expr { 0: _field_0 } => {
                let _field_0 = <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Pat::Expr { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for PrivateName {
    #[doc = "Calls [FoldAstPath`::fold_private_name`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_private_name(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            PrivateName { span, name } => PrivateName { span, name },
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for PrivateProp {
    #[doc = "Calls [FoldAstPath`::fold_private_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_private_prop(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            PrivateProp {
                span,
                ctxt,
                key,
                value,
                type_ann,
                is_static,
                decorators,
                accessibility,
                is_optional,
                is_override,
                readonly,
                definite,
            } => {
                let key =
                    <PrivateName as FoldWithAstPath<V>>::fold_with_ast_path(key, visitor, ast_path);
                let value = <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    value, visitor, ast_path,
                );
                let type_ann = <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                let decorators = <Vec<Decorator> as FoldWithAstPath<V>>::fold_with_ast_path(
                    decorators, visitor, ast_path,
                );
                let accessibility =
                    <Option<Accessibility> as FoldWithAstPath<V>>::fold_with_ast_path(
                        accessibility,
                        visitor,
                        ast_path,
                    );
                PrivateProp {
                    span,
                    ctxt,
                    key,
                    value,
                    type_ann,
                    is_static,
                    decorators,
                    accessibility,
                    is_optional,
                    is_override,
                    readonly,
                    definite,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Program {
    #[doc = "Calls [FoldAstPath`::fold_program`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_program(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Program::Module { 0: _field_0 } => {
                let _field_0 =
                    <Module as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                Program::Module { 0: _field_0 }
            }
            Program::Script { 0: _field_0 } => {
                let _field_0 =
                    <Script as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                Program::Script { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Prop {
    #[doc = "Calls [FoldAstPath`::fold_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_prop(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Prop::Shorthand { 0: _field_0 } => {
                let _field_0 =
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                Prop::Shorthand { 0: _field_0 }
            }
            Prop::KeyValue { 0: _field_0 } => {
                let _field_0 = <KeyValueProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Prop::KeyValue { 0: _field_0 }
            }
            Prop::Assign { 0: _field_0 } => {
                let _field_0 = <AssignProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Prop::Assign { 0: _field_0 }
            }
            Prop::Getter { 0: _field_0 } => {
                let _field_0 = <GetterProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Prop::Getter { 0: _field_0 }
            }
            Prop::Setter { 0: _field_0 } => {
                let _field_0 = <SetterProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Prop::Setter { 0: _field_0 }
            }
            Prop::Method { 0: _field_0 } => {
                let _field_0 = <MethodProp as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Prop::Method { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for PropName {
    #[doc = "Calls [FoldAstPath`::fold_prop_name`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_prop_name(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            PropName::Ident { 0: _field_0 } => {
                let _field_0 = <IdentName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                PropName::Ident { 0: _field_0 }
            }
            PropName::Str { 0: _field_0 } => {
                let _field_0 =
                    <Str as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                PropName::Str { 0: _field_0 }
            }
            PropName::Num { 0: _field_0 } => {
                let _field_0 =
                    <Number as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                PropName::Num { 0: _field_0 }
            }
            PropName::Computed { 0: _field_0 } => {
                let _field_0 = <ComputedPropName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                PropName::Computed { 0: _field_0 }
            }
            PropName::BigInt { 0: _field_0 } => {
                let _field_0 =
                    <BigInt as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                PropName::BigInt { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for PropOrSpread {
    #[doc = "Calls [FoldAstPath`::fold_prop_or_spread`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_prop_or_spread(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            PropOrSpread::Spread { 0: _field_0 } => {
                let _field_0 = <SpreadElement as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                PropOrSpread::Spread { 0: _field_0 }
            }
            PropOrSpread::Prop { 0: _field_0 } => {
                let _field_0 = <Box<Prop> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                PropOrSpread::Prop { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Regex {
    #[doc = "Calls [FoldAstPath`::fold_regex`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_regex(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Regex { span, exp, flags } => Regex { span, exp, flags },
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ReservedUnused {
    #[doc = "Calls [FoldAstPath`::fold_reserved_unused`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_reserved_unused(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ReservedUnused { span, body } => {
                let body = <Option<Vec<ModuleItem>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    body, visitor, ast_path,
                );
                ReservedUnused { span, body }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for RestPat {
    #[doc = "Calls [FoldAstPath`::fold_rest_pat`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_rest_pat(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            RestPat {
                span,
                dot3_token,
                arg,
                type_ann,
            } => {
                let arg =
                    <Box<Pat> as FoldWithAstPath<V>>::fold_with_ast_path(arg, visitor, ast_path);
                let type_ann = <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                RestPat {
                    span,
                    dot3_token,
                    arg,
                    type_ann,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ReturnStmt {
    #[doc = "Calls [FoldAstPath`::fold_return_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_return_stmt(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ReturnStmt { span, arg } => {
                let arg = <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    arg, visitor, ast_path,
                );
                ReturnStmt { span, arg }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Script {
    #[doc = "Calls [FoldAstPath`::fold_script`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_script(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Script {
                span,
                body,
                shebang,
            } => {
                let body =
                    <Vec<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(body, visitor, ast_path);
                Script {
                    span,
                    body,
                    shebang,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for SeqExpr {
    #[doc = "Calls [FoldAstPath`::fold_seq_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_seq_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            SeqExpr { span, exprs } => {
                let exprs = <Vec<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    exprs, visitor, ast_path,
                );
                SeqExpr { span, exprs }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for SetterProp {
    #[doc = "Calls [FoldAstPath`::fold_setter_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_setter_prop(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            SetterProp {
                span,
                key,
                this_param,
                param,
                body,
            } => {
                let key =
                    <PropName as FoldWithAstPath<V>>::fold_with_ast_path(key, visitor, ast_path);
                let this_param = <Option<Pat> as FoldWithAstPath<V>>::fold_with_ast_path(
                    this_param, visitor, ast_path,
                );
                let param =
                    <Box<Pat> as FoldWithAstPath<V>>::fold_with_ast_path(param, visitor, ast_path);
                let body = <Option<BlockStmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                    body, visitor, ast_path,
                );
                SetterProp {
                    span,
                    key,
                    this_param,
                    param,
                    body,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for SimpleAssignTarget {
    #[doc = "Calls [FoldAstPath`::fold_simple_assign_target`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_simple_assign_target(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            SimpleAssignTarget::Ident { 0: _field_0 } => {
                let _field_0 = <BindingIdent as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                SimpleAssignTarget::Ident { 0: _field_0 }
            }
            SimpleAssignTarget::Member { 0: _field_0 } => {
                let _field_0 = <MemberExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                SimpleAssignTarget::Member { 0: _field_0 }
            }
            SimpleAssignTarget::SuperProp { 0: _field_0 } => {
                let _field_0 = <SuperPropExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                SimpleAssignTarget::SuperProp { 0: _field_0 }
            }
            SimpleAssignTarget::Paren { 0: _field_0 } => {
                let _field_0 = <ParenExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                SimpleAssignTarget::Paren { 0: _field_0 }
            }
            SimpleAssignTarget::OptChain { 0: _field_0 } => {
                let _field_0 = <OptChainExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                SimpleAssignTarget::OptChain { 0: _field_0 }
            }
            SimpleAssignTarget::TsAs { 0: _field_0 } => {
                let _field_0 = <TsAsExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                SimpleAssignTarget::TsAs { 0: _field_0 }
            }
            SimpleAssignTarget::TsSatisfies { 0: _field_0 } => {
                let _field_0 = <TsSatisfiesExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                SimpleAssignTarget::TsSatisfies { 0: _field_0 }
            }
            SimpleAssignTarget::TsNonNull { 0: _field_0 } => {
                let _field_0 = <TsNonNullExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                SimpleAssignTarget::TsNonNull { 0: _field_0 }
            }
            SimpleAssignTarget::TsTypeAssertion { 0: _field_0 } => {
                let _field_0 = <TsTypeAssertion as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                SimpleAssignTarget::TsTypeAssertion { 0: _field_0 }
            }
            SimpleAssignTarget::TsInstantiation { 0: _field_0 } => {
                let _field_0 = <TsInstantiation as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                SimpleAssignTarget::TsInstantiation { 0: _field_0 }
            }
            SimpleAssignTarget::Invalid { 0: _field_0 } => {
                let _field_0 = <Invalid as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                SimpleAssignTarget::Invalid { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for SpreadElement {
    #[doc = "Calls [FoldAstPath`::fold_spread_element`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_spread_element(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            SpreadElement { dot3_token, expr } => {
                let expr =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(expr, visitor, ast_path);
                SpreadElement { dot3_token, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for StaticBlock {
    #[doc = "Calls [FoldAstPath`::fold_static_block`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_static_block(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            StaticBlock { span, body } => {
                let body =
                    <BlockStmt as FoldWithAstPath<V>>::fold_with_ast_path(body, visitor, ast_path);
                StaticBlock { span, body }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Stmt {
    #[doc = "Calls [FoldAstPath`::fold_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_stmt(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Stmt::Block { 0: _field_0 } => {
                let _field_0 = <BlockStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Stmt::Block { 0: _field_0 }
            }
            Stmt::Empty { 0: _field_0 } => {
                let _field_0 = <EmptyStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Stmt::Empty { 0: _field_0 }
            }
            Stmt::Debugger { 0: _field_0 } => {
                let _field_0 = <DebuggerStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Stmt::Debugger { 0: _field_0 }
            }
            Stmt::With { 0: _field_0 } => {
                let _field_0 = <WithStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Stmt::With { 0: _field_0 }
            }
            Stmt::Return { 0: _field_0 } => {
                let _field_0 = <ReturnStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Stmt::Return { 0: _field_0 }
            }
            Stmt::Labeled { 0: _field_0 } => {
                let _field_0 = <LabeledStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Stmt::Labeled { 0: _field_0 }
            }
            Stmt::Break { 0: _field_0 } => {
                let _field_0 = <BreakStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Stmt::Break { 0: _field_0 }
            }
            Stmt::Continue { 0: _field_0 } => {
                let _field_0 = <ContinueStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Stmt::Continue { 0: _field_0 }
            }
            Stmt::If { 0: _field_0 } => {
                let _field_0 =
                    <IfStmt as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                Stmt::If { 0: _field_0 }
            }
            Stmt::Switch { 0: _field_0 } => {
                let _field_0 = <SwitchStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Stmt::Switch { 0: _field_0 }
            }
            Stmt::Throw { 0: _field_0 } => {
                let _field_0 = <ThrowStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Stmt::Throw { 0: _field_0 }
            }
            Stmt::Try { 0: _field_0 } => {
                let _field_0 = <Box<TryStmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Stmt::Try { 0: _field_0 }
            }
            Stmt::While { 0: _field_0 } => {
                let _field_0 = <WhileStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Stmt::While { 0: _field_0 }
            }
            Stmt::DoWhile { 0: _field_0 } => {
                let _field_0 = <DoWhileStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Stmt::DoWhile { 0: _field_0 }
            }
            Stmt::For { 0: _field_0 } => {
                let _field_0 = <ForStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Stmt::For { 0: _field_0 }
            }
            Stmt::ForIn { 0: _field_0 } => {
                let _field_0 = <ForInStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Stmt::ForIn { 0: _field_0 }
            }
            Stmt::ForOf { 0: _field_0 } => {
                let _field_0 = <ForOfStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Stmt::ForOf { 0: _field_0 }
            }
            Stmt::Decl { 0: _field_0 } => {
                let _field_0 =
                    <Decl as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                Stmt::Decl { 0: _field_0 }
            }
            Stmt::Expr { 0: _field_0 } => {
                let _field_0 = <ExprStmt as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                Stmt::Expr { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Str {
    #[doc = "Calls [FoldAstPath`::fold_str`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_str(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Str { span, value, raw } => Str { span, value, raw },
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Super {
    #[doc = "Calls [FoldAstPath`::fold_super`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_super(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Super { span } => Super { span },
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for SuperProp {
    #[doc = "Calls [FoldAstPath`::fold_super_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_super_prop(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            SuperProp::Ident { 0: _field_0 } => {
                let _field_0 = <IdentName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                SuperProp::Ident { 0: _field_0 }
            }
            SuperProp::Computed { 0: _field_0 } => {
                let _field_0 = <ComputedPropName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                SuperProp::Computed { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for SuperPropExpr {
    #[doc = "Calls [FoldAstPath`::fold_super_prop_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_super_prop_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            SuperPropExpr { span, obj, prop } => {
                let obj = <Super as FoldWithAstPath<V>>::fold_with_ast_path(obj, visitor, ast_path);
                let prop =
                    <SuperProp as FoldWithAstPath<V>>::fold_with_ast_path(prop, visitor, ast_path);
                SuperPropExpr { span, obj, prop }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for SwitchCase {
    #[doc = "Calls [FoldAstPath`::fold_switch_case`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_switch_case(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            SwitchCase { span, test, cons } => {
                let test = <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    test, visitor, ast_path,
                );
                let cons =
                    <Vec<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(cons, visitor, ast_path);
                SwitchCase { span, test, cons }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for SwitchStmt {
    #[doc = "Calls [FoldAstPath`::fold_switch_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_switch_stmt(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            SwitchStmt {
                span,
                discriminant,
                cases,
            } => {
                let discriminant = <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                    discriminant,
                    visitor,
                    ast_path,
                );
                let cases = <Vec<SwitchCase> as FoldWithAstPath<V>>::fold_with_ast_path(
                    cases, visitor, ast_path,
                );
                SwitchStmt {
                    span,
                    discriminant,
                    cases,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TaggedTpl {
    #[doc = "Calls [FoldAstPath`::fold_tagged_tpl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_tagged_tpl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TaggedTpl {
                span,
                ctxt,
                tag,
                type_params,
                tpl,
            } => {
                let tag =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(tag, visitor, ast_path);
                let type_params = < Option < Box < TsTypeParamInstantiation > > as FoldWithAstPath < V > > :: fold_with_ast_path (type_params , visitor , ast_path) ;
                let tpl =
                    <Box<Tpl> as FoldWithAstPath<V>>::fold_with_ast_path(tpl, visitor, ast_path);
                TaggedTpl {
                    span,
                    ctxt,
                    tag,
                    type_params,
                    tpl,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ThisExpr {
    #[doc = "Calls [FoldAstPath`::fold_this_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_this_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ThisExpr { span } => ThisExpr { span },
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ThrowStmt {
    #[doc = "Calls [FoldAstPath`::fold_throw_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_throw_stmt(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            ThrowStmt { span, arg } => {
                let arg =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(arg, visitor, ast_path);
                ThrowStmt { span, arg }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Tpl {
    #[doc = "Calls [FoldAstPath`::fold_tpl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_tpl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            Tpl {
                span,
                exprs,
                quasis,
            } => {
                let exprs = <Vec<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    exprs, visitor, ast_path,
                );
                let quasis = <Vec<TplElement> as FoldWithAstPath<V>>::fold_with_ast_path(
                    quasis, visitor, ast_path,
                );
                Tpl {
                    span,
                    exprs,
                    quasis,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TplElement {
    #[doc = "Calls [FoldAstPath`::fold_tpl_element`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_tpl_element(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TplElement {
                span,
                tail,
                cooked,
                raw,
            } => TplElement {
                span,
                tail,
                cooked,
                raw,
            },
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TruePlusMinus {
    #[doc = "Calls [FoldAstPath`::fold_true_plus_minus`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_true_plus_minus(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TruePlusMinus::True => TruePlusMinus::True,
            TruePlusMinus::Plus => TruePlusMinus::Plus,
            TruePlusMinus::Minus => TruePlusMinus::Minus,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TryStmt {
    #[doc = "Calls [FoldAstPath`::fold_try_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_try_stmt(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TryStmt {
                span,
                block,
                handler,
                finalizer,
            } => {
                let block =
                    <BlockStmt as FoldWithAstPath<V>>::fold_with_ast_path(block, visitor, ast_path);
                let handler = <Option<CatchClause> as FoldWithAstPath<V>>::fold_with_ast_path(
                    handler, visitor, ast_path,
                );
                let finalizer = <Option<BlockStmt> as FoldWithAstPath<V>>::fold_with_ast_path(
                    finalizer, visitor, ast_path,
                );
                TryStmt {
                    span,
                    block,
                    handler,
                    finalizer,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsArrayType {
    #[doc = "Calls [FoldAstPath`::fold_ts_array_type`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_array_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsArrayType { span, elem_type } => {
                let elem_type = <Box<TsType> as FoldWithAstPath<V>>::fold_with_ast_path(
                    elem_type, visitor, ast_path,
                );
                TsArrayType { span, elem_type }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsAsExpr {
    #[doc = "Calls [FoldAstPath`::fold_ts_as_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_as_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsAsExpr {
                span,
                expr,
                type_ann,
            } => {
                let expr =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(expr, visitor, ast_path);
                let type_ann = <Box<TsType> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                TsAsExpr {
                    span,
                    expr,
                    type_ann,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsCallSignatureDecl {
    #[doc = "Calls [FoldAstPath`::fold_ts_call_signature_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_call_signature_decl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsCallSignatureDecl {
                span,
                params,
                type_ann,
                type_params,
            } => {
                let params = <Vec<TsFnParam> as FoldWithAstPath<V>>::fold_with_ast_path(
                    params, visitor, ast_path,
                );
                let type_ann = <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                let type_params =
                    <Option<Box<TsTypeParamDecl>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_params,
                        visitor,
                        ast_path,
                    );
                TsCallSignatureDecl {
                    span,
                    params,
                    type_ann,
                    type_params,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsConditionalType {
    #[doc = "Calls [FoldAstPath`::fold_ts_conditional_type`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_conditional_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsConditionalType {
                span,
                check_type,
                extends_type,
                true_type,
                false_type,
            } => {
                let check_type = <Box<TsType> as FoldWithAstPath<V>>::fold_with_ast_path(
                    check_type, visitor, ast_path,
                );
                let extends_type = <Box<TsType> as FoldWithAstPath<V>>::fold_with_ast_path(
                    extends_type,
                    visitor,
                    ast_path,
                );
                let true_type = <Box<TsType> as FoldWithAstPath<V>>::fold_with_ast_path(
                    true_type, visitor, ast_path,
                );
                let false_type = <Box<TsType> as FoldWithAstPath<V>>::fold_with_ast_path(
                    false_type, visitor, ast_path,
                );
                TsConditionalType {
                    span,
                    check_type,
                    extends_type,
                    true_type,
                    false_type,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsConstAssertion {
    #[doc = "Calls [FoldAstPath`::fold_ts_const_assertion`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_const_assertion(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsConstAssertion { span, expr } => {
                let expr =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(expr, visitor, ast_path);
                TsConstAssertion { span, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsConstructSignatureDecl {
    #[doc = "Calls [FoldAstPath`::fold_ts_construct_signature_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_construct_signature_decl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsConstructSignatureDecl {
                span,
                params,
                type_ann,
                type_params,
            } => {
                let params = <Vec<TsFnParam> as FoldWithAstPath<V>>::fold_with_ast_path(
                    params, visitor, ast_path,
                );
                let type_ann = <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                let type_params =
                    <Option<Box<TsTypeParamDecl>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_params,
                        visitor,
                        ast_path,
                    );
                TsConstructSignatureDecl {
                    span,
                    params,
                    type_ann,
                    type_params,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsConstructorType {
    #[doc = "Calls [FoldAstPath`::fold_ts_constructor_type`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_constructor_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsConstructorType {
                span,
                params,
                type_params,
                type_ann,
                is_abstract,
            } => {
                let params = <Vec<TsFnParam> as FoldWithAstPath<V>>::fold_with_ast_path(
                    params, visitor, ast_path,
                );
                let type_params =
                    <Option<Box<TsTypeParamDecl>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_params,
                        visitor,
                        ast_path,
                    );
                let type_ann = <Box<TsTypeAnn> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                TsConstructorType {
                    span,
                    params,
                    type_params,
                    type_ann,
                    is_abstract,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsEntityName {
    #[doc = "Calls [FoldAstPath`::fold_ts_entity_name`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_entity_name(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsEntityName::TsQualifiedName { 0: _field_0 } => {
                let _field_0 = <Box<TsQualifiedName> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsEntityName::TsQualifiedName { 0: _field_0 }
            }
            TsEntityName::Ident { 0: _field_0 } => {
                let _field_0 =
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                TsEntityName::Ident { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsEnumDecl {
    #[doc = "Calls [FoldAstPath`::fold_ts_enum_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_enum_decl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsEnumDecl {
                span,
                declare,
                is_const,
                id,
                members,
            } => {
                let id = <Ident as FoldWithAstPath<V>>::fold_with_ast_path(id, visitor, ast_path);
                let members = <Vec<TsEnumMember> as FoldWithAstPath<V>>::fold_with_ast_path(
                    members, visitor, ast_path,
                );
                TsEnumDecl {
                    span,
                    declare,
                    is_const,
                    id,
                    members,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsEnumMember {
    #[doc = "Calls [FoldAstPath`::fold_ts_enum_member`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_enum_member(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsEnumMember { span, id, init } => {
                let id = <TsEnumMemberId as FoldWithAstPath<V>>::fold_with_ast_path(
                    id, visitor, ast_path,
                );
                let init = <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    init, visitor, ast_path,
                );
                TsEnumMember { span, id, init }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsEnumMemberId {
    #[doc = "Calls [FoldAstPath`::fold_ts_enum_member_id`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_enum_member_id(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsEnumMemberId::Ident { 0: _field_0 } => {
                let _field_0 =
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                TsEnumMemberId::Ident { 0: _field_0 }
            }
            TsEnumMemberId::Str { 0: _field_0 } => {
                let _field_0 =
                    <Str as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                TsEnumMemberId::Str { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsExportAssignment {
    #[doc = "Calls [FoldAstPath`::fold_ts_export_assignment`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_export_assignment(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsExportAssignment { span, expr } => {
                let expr =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(expr, visitor, ast_path);
                TsExportAssignment { span, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsExprWithTypeArgs {
    #[doc = "Calls [FoldAstPath`::fold_ts_expr_with_type_args`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_expr_with_type_args(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsExprWithTypeArgs {
                span,
                expr,
                type_args,
            } => {
                let expr =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(expr, visitor, ast_path);
                let type_args = < Option < Box < TsTypeParamInstantiation > > as FoldWithAstPath < V > > :: fold_with_ast_path (type_args , visitor , ast_path) ;
                TsExprWithTypeArgs {
                    span,
                    expr,
                    type_args,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsExternalModuleRef {
    #[doc = "Calls [FoldAstPath`::fold_ts_external_module_ref`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_external_module_ref(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsExternalModuleRef { span, expr } => {
                let expr = <Str as FoldWithAstPath<V>>::fold_with_ast_path(expr, visitor, ast_path);
                TsExternalModuleRef { span, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsFnOrConstructorType {
    #[doc = "Calls [FoldAstPath`::fold_ts_fn_or_constructor_type`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_fn_or_constructor_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsFnOrConstructorType::TsFnType { 0: _field_0 } => {
                let _field_0 = <TsFnType as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsFnOrConstructorType::TsFnType { 0: _field_0 }
            }
            TsFnOrConstructorType::TsConstructorType { 0: _field_0 } => {
                let _field_0 = <TsConstructorType as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsFnOrConstructorType::TsConstructorType { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsFnParam {
    #[doc = "Calls [FoldAstPath`::fold_ts_fn_param`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_fn_param(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsFnParam::Ident { 0: _field_0 } => {
                let _field_0 = <BindingIdent as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsFnParam::Ident { 0: _field_0 }
            }
            TsFnParam::Array { 0: _field_0 } => {
                let _field_0 = <ArrayPat as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsFnParam::Array { 0: _field_0 }
            }
            TsFnParam::Rest { 0: _field_0 } => {
                let _field_0 = <RestPat as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsFnParam::Rest { 0: _field_0 }
            }
            TsFnParam::Object { 0: _field_0 } => {
                let _field_0 = <ObjectPat as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsFnParam::Object { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsFnType {
    #[doc = "Calls [FoldAstPath`::fold_ts_fn_type`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_fn_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsFnType {
                span,
                params,
                type_params,
                type_ann,
            } => {
                let params = <Vec<TsFnParam> as FoldWithAstPath<V>>::fold_with_ast_path(
                    params, visitor, ast_path,
                );
                let type_params =
                    <Option<Box<TsTypeParamDecl>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_params,
                        visitor,
                        ast_path,
                    );
                let type_ann = <Box<TsTypeAnn> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                TsFnType {
                    span,
                    params,
                    type_params,
                    type_ann,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsGetterSignature {
    #[doc = "Calls [FoldAstPath`::fold_ts_getter_signature`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_getter_signature(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsGetterSignature {
                span,
                key,
                computed,
                type_ann,
            } => {
                let key =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(key, visitor, ast_path);
                let type_ann = <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                TsGetterSignature {
                    span,
                    key,
                    computed,
                    type_ann,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsImportEqualsDecl {
    #[doc = "Calls [FoldAstPath`::fold_ts_import_equals_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_import_equals_decl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsImportEqualsDecl {
                span,
                is_export,
                is_type_only,
                id,
                module_ref,
            } => {
                let id = <Ident as FoldWithAstPath<V>>::fold_with_ast_path(id, visitor, ast_path);
                let module_ref = <TsModuleRef as FoldWithAstPath<V>>::fold_with_ast_path(
                    module_ref, visitor, ast_path,
                );
                TsImportEqualsDecl {
                    span,
                    is_export,
                    is_type_only,
                    id,
                    module_ref,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsImportType {
    #[doc = "Calls [FoldAstPath`::fold_ts_import_type`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_import_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsImportType {
                span,
                arg,
                qualifier,
                type_args,
            } => {
                let arg = <Str as FoldWithAstPath<V>>::fold_with_ast_path(arg, visitor, ast_path);
                let qualifier = <Option<TsEntityName> as FoldWithAstPath<V>>::fold_with_ast_path(
                    qualifier, visitor, ast_path,
                );
                let type_args = < Option < Box < TsTypeParamInstantiation > > as FoldWithAstPath < V > > :: fold_with_ast_path (type_args , visitor , ast_path) ;
                TsImportType {
                    span,
                    arg,
                    qualifier,
                    type_args,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsIndexSignature {
    #[doc = "Calls [FoldAstPath`::fold_ts_index_signature`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_index_signature(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsIndexSignature {
                params,
                type_ann,
                readonly,
                is_static,
                span,
            } => {
                let params = <Vec<TsFnParam> as FoldWithAstPath<V>>::fold_with_ast_path(
                    params, visitor, ast_path,
                );
                let type_ann = <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                TsIndexSignature {
                    params,
                    type_ann,
                    readonly,
                    is_static,
                    span,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsIndexedAccessType {
    #[doc = "Calls [FoldAstPath`::fold_ts_indexed_access_type`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_indexed_access_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsIndexedAccessType {
                span,
                readonly,
                obj_type,
                index_type,
            } => {
                let obj_type = <Box<TsType> as FoldWithAstPath<V>>::fold_with_ast_path(
                    obj_type, visitor, ast_path,
                );
                let index_type = <Box<TsType> as FoldWithAstPath<V>>::fold_with_ast_path(
                    index_type, visitor, ast_path,
                );
                TsIndexedAccessType {
                    span,
                    readonly,
                    obj_type,
                    index_type,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsInferType {
    #[doc = "Calls [FoldAstPath`::fold_ts_infer_type`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_infer_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsInferType { span, type_param } => {
                let type_param = <TsTypeParam as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_param, visitor, ast_path,
                );
                TsInferType { span, type_param }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsInstantiation {
    #[doc = "Calls [FoldAstPath`::fold_ts_instantiation`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_instantiation(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsInstantiation {
                span,
                expr,
                type_args,
            } => {
                let expr =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(expr, visitor, ast_path);
                let type_args =
                    <Box<TsTypeParamInstantiation> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_args, visitor, ast_path,
                    );
                TsInstantiation {
                    span,
                    expr,
                    type_args,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsInterfaceBody {
    #[doc = "Calls [FoldAstPath`::fold_ts_interface_body`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_interface_body(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsInterfaceBody { span, body } => {
                let body = <Vec<TsTypeElement> as FoldWithAstPath<V>>::fold_with_ast_path(
                    body, visitor, ast_path,
                );
                TsInterfaceBody { span, body }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsInterfaceDecl {
    #[doc = "Calls [FoldAstPath`::fold_ts_interface_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_interface_decl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsInterfaceDecl {
                span,
                id,
                declare,
                type_params,
                extends,
                body,
            } => {
                let id = <Ident as FoldWithAstPath<V>>::fold_with_ast_path(id, visitor, ast_path);
                let type_params =
                    <Option<Box<TsTypeParamDecl>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_params,
                        visitor,
                        ast_path,
                    );
                let extends = <Vec<TsExprWithTypeArgs> as FoldWithAstPath<V>>::fold_with_ast_path(
                    extends, visitor, ast_path,
                );
                let body = <TsInterfaceBody as FoldWithAstPath<V>>::fold_with_ast_path(
                    body, visitor, ast_path,
                );
                TsInterfaceDecl {
                    span,
                    id,
                    declare,
                    type_params,
                    extends,
                    body,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsIntersectionType {
    #[doc = "Calls [FoldAstPath`::fold_ts_intersection_type`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_intersection_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsIntersectionType { span, types } => {
                let types = <Vec<Box<TsType>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    types, visitor, ast_path,
                );
                TsIntersectionType { span, types }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsKeywordType {
    #[doc = "Calls [FoldAstPath`::fold_ts_keyword_type`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_keyword_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsKeywordType { span, kind } => {
                let kind = <TsKeywordTypeKind as FoldWithAstPath<V>>::fold_with_ast_path(
                    kind, visitor, ast_path,
                );
                TsKeywordType { span, kind }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsKeywordTypeKind {
    #[doc = "Calls [FoldAstPath`::fold_ts_keyword_type_kind`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_keyword_type_kind(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsKeywordTypeKind::TsAnyKeyword => TsKeywordTypeKind::TsAnyKeyword,
            TsKeywordTypeKind::TsUnknownKeyword => TsKeywordTypeKind::TsUnknownKeyword,
            TsKeywordTypeKind::TsNumberKeyword => TsKeywordTypeKind::TsNumberKeyword,
            TsKeywordTypeKind::TsObjectKeyword => TsKeywordTypeKind::TsObjectKeyword,
            TsKeywordTypeKind::TsBooleanKeyword => TsKeywordTypeKind::TsBooleanKeyword,
            TsKeywordTypeKind::TsBigIntKeyword => TsKeywordTypeKind::TsBigIntKeyword,
            TsKeywordTypeKind::TsStringKeyword => TsKeywordTypeKind::TsStringKeyword,
            TsKeywordTypeKind::TsSymbolKeyword => TsKeywordTypeKind::TsSymbolKeyword,
            TsKeywordTypeKind::TsVoidKeyword => TsKeywordTypeKind::TsVoidKeyword,
            TsKeywordTypeKind::TsUndefinedKeyword => TsKeywordTypeKind::TsUndefinedKeyword,
            TsKeywordTypeKind::TsNullKeyword => TsKeywordTypeKind::TsNullKeyword,
            TsKeywordTypeKind::TsNeverKeyword => TsKeywordTypeKind::TsNeverKeyword,
            TsKeywordTypeKind::TsIntrinsicKeyword => TsKeywordTypeKind::TsIntrinsicKeyword,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsLit {
    #[doc = "Calls [FoldAstPath`::fold_ts_lit`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_lit(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsLit::Number { 0: _field_0 } => {
                let _field_0 =
                    <Number as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                TsLit::Number { 0: _field_0 }
            }
            TsLit::Str { 0: _field_0 } => {
                let _field_0 =
                    <Str as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                TsLit::Str { 0: _field_0 }
            }
            TsLit::Bool { 0: _field_0 } => {
                let _field_0 =
                    <Bool as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                TsLit::Bool { 0: _field_0 }
            }
            TsLit::BigInt { 0: _field_0 } => {
                let _field_0 =
                    <BigInt as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                TsLit::BigInt { 0: _field_0 }
            }
            TsLit::Tpl { 0: _field_0 } => {
                let _field_0 = <TsTplLitType as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsLit::Tpl { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsLitType {
    #[doc = "Calls [FoldAstPath`::fold_ts_lit_type`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_lit_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsLitType { span, lit } => {
                let lit = <TsLit as FoldWithAstPath<V>>::fold_with_ast_path(lit, visitor, ast_path);
                TsLitType { span, lit }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsMappedType {
    #[doc = "Calls [FoldAstPath`::fold_ts_mapped_type`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_mapped_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsMappedType {
                span,
                readonly,
                type_param,
                name_type,
                optional,
                type_ann,
            } => {
                let readonly = <Option<TruePlusMinus> as FoldWithAstPath<V>>::fold_with_ast_path(
                    readonly, visitor, ast_path,
                );
                let type_param = <TsTypeParam as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_param, visitor, ast_path,
                );
                let name_type = <Option<Box<TsType>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    name_type, visitor, ast_path,
                );
                let optional = <Option<TruePlusMinus> as FoldWithAstPath<V>>::fold_with_ast_path(
                    optional, visitor, ast_path,
                );
                let type_ann = <Option<Box<TsType>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                TsMappedType {
                    span,
                    readonly,
                    type_param,
                    name_type,
                    optional,
                    type_ann,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsMethodSignature {
    #[doc = "Calls [FoldAstPath`::fold_ts_method_signature`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_method_signature(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsMethodSignature {
                span,
                key,
                computed,
                optional,
                params,
                type_ann,
                type_params,
            } => {
                let key =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(key, visitor, ast_path);
                let params = <Vec<TsFnParam> as FoldWithAstPath<V>>::fold_with_ast_path(
                    params, visitor, ast_path,
                );
                let type_ann = <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                let type_params =
                    <Option<Box<TsTypeParamDecl>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_params,
                        visitor,
                        ast_path,
                    );
                TsMethodSignature {
                    span,
                    key,
                    computed,
                    optional,
                    params,
                    type_ann,
                    type_params,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsModuleBlock {
    #[doc = "Calls [FoldAstPath`::fold_ts_module_block`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_module_block(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsModuleBlock { span, body } => {
                let body = <Vec<ModuleItem> as FoldWithAstPath<V>>::fold_with_ast_path(
                    body, visitor, ast_path,
                );
                TsModuleBlock { span, body }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsModuleDecl {
    #[doc = "Calls [FoldAstPath`::fold_ts_module_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_module_decl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsModuleDecl {
                span,
                declare,
                global,
                id,
                body,
            } => {
                let id =
                    <TsModuleName as FoldWithAstPath<V>>::fold_with_ast_path(id, visitor, ast_path);
                let body = <Option<TsNamespaceBody> as FoldWithAstPath<V>>::fold_with_ast_path(
                    body, visitor, ast_path,
                );
                TsModuleDecl {
                    span,
                    declare,
                    global,
                    id,
                    body,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsModuleName {
    #[doc = "Calls [FoldAstPath`::fold_ts_module_name`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_module_name(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsModuleName::Ident { 0: _field_0 } => {
                let _field_0 =
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                TsModuleName::Ident { 0: _field_0 }
            }
            TsModuleName::Str { 0: _field_0 } => {
                let _field_0 =
                    <Str as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                TsModuleName::Str { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsModuleRef {
    #[doc = "Calls [FoldAstPath`::fold_ts_module_ref`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_module_ref(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsModuleRef::TsEntityName { 0: _field_0 } => {
                let _field_0 = <TsEntityName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsModuleRef::TsEntityName { 0: _field_0 }
            }
            TsModuleRef::TsExternalModuleRef { 0: _field_0 } => {
                let _field_0 = <TsExternalModuleRef as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsModuleRef::TsExternalModuleRef { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsNamespaceBody {
    #[doc = "Calls [FoldAstPath`::fold_ts_namespace_body`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_namespace_body(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsNamespaceBody::TsModuleBlock { 0: _field_0 } => {
                let _field_0 = <TsModuleBlock as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsNamespaceBody::TsModuleBlock { 0: _field_0 }
            }
            TsNamespaceBody::TsNamespaceDecl { 0: _field_0 } => {
                let _field_0 = <TsNamespaceDecl as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsNamespaceBody::TsNamespaceDecl { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsNamespaceDecl {
    #[doc = "Calls [FoldAstPath`::fold_ts_namespace_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_namespace_decl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsNamespaceDecl {
                span,
                declare,
                global,
                id,
                body,
            } => {
                let id = <Ident as FoldWithAstPath<V>>::fold_with_ast_path(id, visitor, ast_path);
                let body = <Box<TsNamespaceBody> as FoldWithAstPath<V>>::fold_with_ast_path(
                    body, visitor, ast_path,
                );
                TsNamespaceDecl {
                    span,
                    declare,
                    global,
                    id,
                    body,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsNamespaceExportDecl {
    #[doc = "Calls [FoldAstPath`::fold_ts_namespace_export_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_namespace_export_decl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsNamespaceExportDecl { span, id } => {
                let id = <Ident as FoldWithAstPath<V>>::fold_with_ast_path(id, visitor, ast_path);
                TsNamespaceExportDecl { span, id }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsNonNullExpr {
    #[doc = "Calls [FoldAstPath`::fold_ts_non_null_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_non_null_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsNonNullExpr { span, expr } => {
                let expr =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(expr, visitor, ast_path);
                TsNonNullExpr { span, expr }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsOptionalType {
    #[doc = "Calls [FoldAstPath`::fold_ts_optional_type`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_optional_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsOptionalType { span, type_ann } => {
                let type_ann = <Box<TsType> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                TsOptionalType { span, type_ann }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsParamProp {
    #[doc = "Calls [FoldAstPath`::fold_ts_param_prop`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_param_prop(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsParamProp {
                span,
                decorators,
                accessibility,
                is_override,
                readonly,
                param,
            } => {
                let decorators = <Vec<Decorator> as FoldWithAstPath<V>>::fold_with_ast_path(
                    decorators, visitor, ast_path,
                );
                let accessibility =
                    <Option<Accessibility> as FoldWithAstPath<V>>::fold_with_ast_path(
                        accessibility,
                        visitor,
                        ast_path,
                    );
                let param = <TsParamPropParam as FoldWithAstPath<V>>::fold_with_ast_path(
                    param, visitor, ast_path,
                );
                TsParamProp {
                    span,
                    decorators,
                    accessibility,
                    is_override,
                    readonly,
                    param,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsParamPropParam {
    #[doc = "Calls [FoldAstPath`::fold_ts_param_prop_param`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_param_prop_param(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsParamPropParam::Ident { 0: _field_0 } => {
                let _field_0 = <BindingIdent as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsParamPropParam::Ident { 0: _field_0 }
            }
            TsParamPropParam::Assign { 0: _field_0 } => {
                let _field_0 = <AssignPat as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsParamPropParam::Assign { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsParenthesizedType {
    #[doc = "Calls [FoldAstPath`::fold_ts_parenthesized_type`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_parenthesized_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsParenthesizedType { span, type_ann } => {
                let type_ann = <Box<TsType> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                TsParenthesizedType { span, type_ann }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsPropertySignature {
    #[doc = "Calls [FoldAstPath`::fold_ts_property_signature`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_property_signature(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsPropertySignature {
                span,
                readonly,
                key,
                computed,
                optional,
                type_ann,
            } => {
                let key =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(key, visitor, ast_path);
                let type_ann = <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                TsPropertySignature {
                    span,
                    readonly,
                    key,
                    computed,
                    optional,
                    type_ann,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsQualifiedName {
    #[doc = "Calls [FoldAstPath`::fold_ts_qualified_name`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_qualified_name(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsQualifiedName { span, left, right } => {
                let left = <TsEntityName as FoldWithAstPath<V>>::fold_with_ast_path(
                    left, visitor, ast_path,
                );
                let right =
                    <IdentName as FoldWithAstPath<V>>::fold_with_ast_path(right, visitor, ast_path);
                TsQualifiedName { span, left, right }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsRestType {
    #[doc = "Calls [FoldAstPath`::fold_ts_rest_type`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_rest_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsRestType { span, type_ann } => {
                let type_ann = <Box<TsType> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                TsRestType { span, type_ann }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsSatisfiesExpr {
    #[doc = "Calls [FoldAstPath`::fold_ts_satisfies_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_satisfies_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsSatisfiesExpr {
                span,
                expr,
                type_ann,
            } => {
                let expr =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(expr, visitor, ast_path);
                let type_ann = <Box<TsType> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                TsSatisfiesExpr {
                    span,
                    expr,
                    type_ann,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsSetterSignature {
    #[doc = "Calls [FoldAstPath`::fold_ts_setter_signature`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_setter_signature(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsSetterSignature {
                span,
                key,
                computed,
                param,
            } => {
                let key =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(key, visitor, ast_path);
                let param =
                    <TsFnParam as FoldWithAstPath<V>>::fold_with_ast_path(param, visitor, ast_path);
                TsSetterSignature {
                    span,
                    key,
                    computed,
                    param,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsThisType {
    #[doc = "Calls [FoldAstPath`::fold_ts_this_type`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_this_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsThisType { span } => TsThisType { span },
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsThisTypeOrIdent {
    #[doc = "Calls [FoldAstPath`::fold_ts_this_type_or_ident`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_this_type_or_ident(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsThisTypeOrIdent::TsThisType { 0: _field_0 } => {
                let _field_0 = <TsThisType as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsThisTypeOrIdent::TsThisType { 0: _field_0 }
            }
            TsThisTypeOrIdent::Ident { 0: _field_0 } => {
                let _field_0 =
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(_field_0, visitor, ast_path);
                TsThisTypeOrIdent::Ident { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsTplLitType {
    #[doc = "Calls [FoldAstPath`::fold_ts_tpl_lit_type`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_tpl_lit_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsTplLitType {
                span,
                types,
                quasis,
            } => {
                let types = <Vec<Box<TsType>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    types, visitor, ast_path,
                );
                let quasis = <Vec<TplElement> as FoldWithAstPath<V>>::fold_with_ast_path(
                    quasis, visitor, ast_path,
                );
                TsTplLitType {
                    span,
                    types,
                    quasis,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsTupleElement {
    #[doc = "Calls [FoldAstPath`::fold_ts_tuple_element`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_tuple_element(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsTupleElement { span, label, ty } => {
                let label = <Option<Pat> as FoldWithAstPath<V>>::fold_with_ast_path(
                    label, visitor, ast_path,
                );
                let ty =
                    <Box<TsType> as FoldWithAstPath<V>>::fold_with_ast_path(ty, visitor, ast_path);
                TsTupleElement { span, label, ty }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsTupleType {
    #[doc = "Calls [FoldAstPath`::fold_ts_tuple_type`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_tuple_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsTupleType { span, elem_types } => {
                let elem_types = <Vec<TsTupleElement> as FoldWithAstPath<V>>::fold_with_ast_path(
                    elem_types, visitor, ast_path,
                );
                TsTupleType { span, elem_types }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsType {
    #[doc = "Calls [FoldAstPath`::fold_ts_type`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsType::TsKeywordType { 0: _field_0 } => {
                let _field_0 = <TsKeywordType as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsType::TsKeywordType { 0: _field_0 }
            }
            TsType::TsThisType { 0: _field_0 } => {
                let _field_0 = <TsThisType as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsType::TsThisType { 0: _field_0 }
            }
            TsType::TsFnOrConstructorType { 0: _field_0 } => {
                let _field_0 = <TsFnOrConstructorType as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsType::TsFnOrConstructorType { 0: _field_0 }
            }
            TsType::TsTypeRef { 0: _field_0 } => {
                let _field_0 = <TsTypeRef as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsType::TsTypeRef { 0: _field_0 }
            }
            TsType::TsTypeQuery { 0: _field_0 } => {
                let _field_0 = <TsTypeQuery as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsType::TsTypeQuery { 0: _field_0 }
            }
            TsType::TsTypeLit { 0: _field_0 } => {
                let _field_0 = <TsTypeLit as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsType::TsTypeLit { 0: _field_0 }
            }
            TsType::TsArrayType { 0: _field_0 } => {
                let _field_0 = <TsArrayType as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsType::TsArrayType { 0: _field_0 }
            }
            TsType::TsTupleType { 0: _field_0 } => {
                let _field_0 = <TsTupleType as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsType::TsTupleType { 0: _field_0 }
            }
            TsType::TsOptionalType { 0: _field_0 } => {
                let _field_0 = <TsOptionalType as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsType::TsOptionalType { 0: _field_0 }
            }
            TsType::TsRestType { 0: _field_0 } => {
                let _field_0 = <TsRestType as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsType::TsRestType { 0: _field_0 }
            }
            TsType::TsUnionOrIntersectionType { 0: _field_0 } => {
                let _field_0 =
                    <TsUnionOrIntersectionType as FoldWithAstPath<V>>::fold_with_ast_path(
                        _field_0, visitor, ast_path,
                    );
                TsType::TsUnionOrIntersectionType { 0: _field_0 }
            }
            TsType::TsConditionalType { 0: _field_0 } => {
                let _field_0 = <TsConditionalType as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsType::TsConditionalType { 0: _field_0 }
            }
            TsType::TsInferType { 0: _field_0 } => {
                let _field_0 = <TsInferType as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsType::TsInferType { 0: _field_0 }
            }
            TsType::TsParenthesizedType { 0: _field_0 } => {
                let _field_0 = <TsParenthesizedType as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsType::TsParenthesizedType { 0: _field_0 }
            }
            TsType::TsTypeOperator { 0: _field_0 } => {
                let _field_0 = <TsTypeOperator as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsType::TsTypeOperator { 0: _field_0 }
            }
            TsType::TsIndexedAccessType { 0: _field_0 } => {
                let _field_0 = <TsIndexedAccessType as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsType::TsIndexedAccessType { 0: _field_0 }
            }
            TsType::TsMappedType { 0: _field_0 } => {
                let _field_0 = <TsMappedType as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsType::TsMappedType { 0: _field_0 }
            }
            TsType::TsLitType { 0: _field_0 } => {
                let _field_0 = <TsLitType as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsType::TsLitType { 0: _field_0 }
            }
            TsType::TsTypePredicate { 0: _field_0 } => {
                let _field_0 = <TsTypePredicate as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsType::TsTypePredicate { 0: _field_0 }
            }
            TsType::TsImportType { 0: _field_0 } => {
                let _field_0 = <TsImportType as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsType::TsImportType { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsTypeAliasDecl {
    #[doc = "Calls [FoldAstPath`::fold_ts_type_alias_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_type_alias_decl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsTypeAliasDecl {
                span,
                declare,
                id,
                type_params,
                type_ann,
            } => {
                let id = <Ident as FoldWithAstPath<V>>::fold_with_ast_path(id, visitor, ast_path);
                let type_params =
                    <Option<Box<TsTypeParamDecl>> as FoldWithAstPath<V>>::fold_with_ast_path(
                        type_params,
                        visitor,
                        ast_path,
                    );
                let type_ann = <Box<TsType> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                TsTypeAliasDecl {
                    span,
                    declare,
                    id,
                    type_params,
                    type_ann,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsTypeAnn {
    #[doc = "Calls [FoldAstPath`::fold_ts_type_ann`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_type_ann(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsTypeAnn { span, type_ann } => {
                let type_ann = <Box<TsType> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                TsTypeAnn { span, type_ann }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsTypeAssertion {
    #[doc = "Calls [FoldAstPath`::fold_ts_type_assertion`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_type_assertion(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsTypeAssertion {
                span,
                expr,
                type_ann,
            } => {
                let expr =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(expr, visitor, ast_path);
                let type_ann = <Box<TsType> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                TsTypeAssertion {
                    span,
                    expr,
                    type_ann,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsTypeElement {
    #[doc = "Calls [FoldAstPath`::fold_ts_type_element`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_type_element(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsTypeElement::TsCallSignatureDecl { 0: _field_0 } => {
                let _field_0 = <TsCallSignatureDecl as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsTypeElement::TsCallSignatureDecl { 0: _field_0 }
            }
            TsTypeElement::TsConstructSignatureDecl { 0: _field_0 } => {
                let _field_0 = <TsConstructSignatureDecl as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsTypeElement::TsConstructSignatureDecl { 0: _field_0 }
            }
            TsTypeElement::TsPropertySignature { 0: _field_0 } => {
                let _field_0 = <TsPropertySignature as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsTypeElement::TsPropertySignature { 0: _field_0 }
            }
            TsTypeElement::TsGetterSignature { 0: _field_0 } => {
                let _field_0 = <TsGetterSignature as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsTypeElement::TsGetterSignature { 0: _field_0 }
            }
            TsTypeElement::TsSetterSignature { 0: _field_0 } => {
                let _field_0 = <TsSetterSignature as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsTypeElement::TsSetterSignature { 0: _field_0 }
            }
            TsTypeElement::TsMethodSignature { 0: _field_0 } => {
                let _field_0 = <TsMethodSignature as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsTypeElement::TsMethodSignature { 0: _field_0 }
            }
            TsTypeElement::TsIndexSignature { 0: _field_0 } => {
                let _field_0 = <TsIndexSignature as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsTypeElement::TsIndexSignature { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsTypeLit {
    #[doc = "Calls [FoldAstPath`::fold_ts_type_lit`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_type_lit(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsTypeLit { span, members } => {
                let members = <Vec<TsTypeElement> as FoldWithAstPath<V>>::fold_with_ast_path(
                    members, visitor, ast_path,
                );
                TsTypeLit { span, members }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsTypeOperator {
    #[doc = "Calls [FoldAstPath`::fold_ts_type_operator`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_type_operator(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsTypeOperator { span, op, type_ann } => {
                let op = <TsTypeOperatorOp as FoldWithAstPath<V>>::fold_with_ast_path(
                    op, visitor, ast_path,
                );
                let type_ann = <Box<TsType> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                TsTypeOperator { span, op, type_ann }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsTypeOperatorOp {
    #[doc = "Calls [FoldAstPath`::fold_ts_type_operator_op`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_type_operator_op(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsTypeOperatorOp::KeyOf => TsTypeOperatorOp::KeyOf,
            TsTypeOperatorOp::Unique => TsTypeOperatorOp::Unique,
            TsTypeOperatorOp::ReadOnly => TsTypeOperatorOp::ReadOnly,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsTypeParam {
    #[doc = "Calls [FoldAstPath`::fold_ts_type_param`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_type_param(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsTypeParam {
                span,
                name,
                is_in,
                is_out,
                is_const,
                constraint,
                default,
            } => {
                let name =
                    <Ident as FoldWithAstPath<V>>::fold_with_ast_path(name, visitor, ast_path);
                let constraint = <Option<Box<TsType>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    constraint, visitor, ast_path,
                );
                let default = <Option<Box<TsType>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    default, visitor, ast_path,
                );
                TsTypeParam {
                    span,
                    name,
                    is_in,
                    is_out,
                    is_const,
                    constraint,
                    default,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsTypeParamDecl {
    #[doc = "Calls [FoldAstPath`::fold_ts_type_param_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_type_param_decl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsTypeParamDecl { span, params } => {
                let params = <Vec<TsTypeParam> as FoldWithAstPath<V>>::fold_with_ast_path(
                    params, visitor, ast_path,
                );
                TsTypeParamDecl { span, params }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsTypeParamInstantiation {
    #[doc = "Calls [FoldAstPath`::fold_ts_type_param_instantiation`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_type_param_instantiation(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsTypeParamInstantiation { span, params } => {
                let params = <Vec<Box<TsType>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    params, visitor, ast_path,
                );
                TsTypeParamInstantiation { span, params }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsTypePredicate {
    #[doc = "Calls [FoldAstPath`::fold_ts_type_predicate`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_type_predicate(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsTypePredicate {
                span,
                asserts,
                param_name,
                type_ann,
            } => {
                let param_name = <TsThisTypeOrIdent as FoldWithAstPath<V>>::fold_with_ast_path(
                    param_name, visitor, ast_path,
                );
                let type_ann = <Option<Box<TsTypeAnn>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_ann, visitor, ast_path,
                );
                TsTypePredicate {
                    span,
                    asserts,
                    param_name,
                    type_ann,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsTypeQuery {
    #[doc = "Calls [FoldAstPath`::fold_ts_type_query`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_type_query(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsTypeQuery {
                span,
                expr_name,
                type_args,
            } => {
                let expr_name = <TsTypeQueryExpr as FoldWithAstPath<V>>::fold_with_ast_path(
                    expr_name, visitor, ast_path,
                );
                let type_args = < Option < Box < TsTypeParamInstantiation > > as FoldWithAstPath < V > > :: fold_with_ast_path (type_args , visitor , ast_path) ;
                TsTypeQuery {
                    span,
                    expr_name,
                    type_args,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsTypeQueryExpr {
    #[doc = "Calls [FoldAstPath`::fold_ts_type_query_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_type_query_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsTypeQueryExpr::TsEntityName { 0: _field_0 } => {
                let _field_0 = <TsEntityName as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsTypeQueryExpr::TsEntityName { 0: _field_0 }
            }
            TsTypeQueryExpr::Import { 0: _field_0 } => {
                let _field_0 = <TsImportType as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsTypeQueryExpr::Import { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsTypeRef {
    #[doc = "Calls [FoldAstPath`::fold_ts_type_ref`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_type_ref(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsTypeRef {
                span,
                type_name,
                type_params,
            } => {
                let type_name = <TsEntityName as FoldWithAstPath<V>>::fold_with_ast_path(
                    type_name, visitor, ast_path,
                );
                let type_params = < Option < Box < TsTypeParamInstantiation > > as FoldWithAstPath < V > > :: fold_with_ast_path (type_params , visitor , ast_path) ;
                TsTypeRef {
                    span,
                    type_name,
                    type_params,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsUnionOrIntersectionType {
    #[doc = "Calls [FoldAstPath`::fold_ts_union_or_intersection_type`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_union_or_intersection_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsUnionOrIntersectionType::TsUnionType { 0: _field_0 } => {
                let _field_0 = <TsUnionType as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsUnionOrIntersectionType::TsUnionType { 0: _field_0 }
            }
            TsUnionOrIntersectionType::TsIntersectionType { 0: _field_0 } => {
                let _field_0 = <TsIntersectionType as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                TsUnionOrIntersectionType::TsIntersectionType { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for TsUnionType {
    #[doc = "Calls [FoldAstPath`::fold_ts_union_type`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_union_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            TsUnionType { span, types } => {
                let types = <Vec<Box<TsType>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    types, visitor, ast_path,
                );
                TsUnionType { span, types }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for UnaryExpr {
    #[doc = "Calls [FoldAstPath`::fold_unary_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_unary_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            UnaryExpr { span, op, arg } => {
                let op = <UnaryOp as FoldWithAstPath<V>>::fold_with_ast_path(op, visitor, ast_path);
                let arg =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(arg, visitor, ast_path);
                UnaryExpr { span, op, arg }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for UnaryOp {
    #[doc = "Calls [FoldAstPath`::fold_unary_op`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_unary_op(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            UnaryOp::Minus => UnaryOp::Minus,
            UnaryOp::Plus => UnaryOp::Plus,
            UnaryOp::Bang => UnaryOp::Bang,
            UnaryOp::Tilde => UnaryOp::Tilde,
            UnaryOp::TypeOf => UnaryOp::TypeOf,
            UnaryOp::Void => UnaryOp::Void,
            UnaryOp::Delete => UnaryOp::Delete,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for UpdateExpr {
    #[doc = "Calls [FoldAstPath`::fold_update_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_update_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            UpdateExpr {
                span,
                op,
                prefix,
                arg,
            } => {
                let op =
                    <UpdateOp as FoldWithAstPath<V>>::fold_with_ast_path(op, visitor, ast_path);
                let arg =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(arg, visitor, ast_path);
                UpdateExpr {
                    span,
                    op,
                    prefix,
                    arg,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for UpdateOp {
    #[doc = "Calls [FoldAstPath`::fold_update_op`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_update_op(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            UpdateOp::PlusPlus => UpdateOp::PlusPlus,
            UpdateOp::MinusMinus => UpdateOp::MinusMinus,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for UsingDecl {
    #[doc = "Calls [FoldAstPath`::fold_using_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_using_decl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            UsingDecl {
                span,
                is_await,
                decls,
            } => {
                let decls = <Vec<VarDeclarator> as FoldWithAstPath<V>>::fold_with_ast_path(
                    decls, visitor, ast_path,
                );
                UsingDecl {
                    span,
                    is_await,
                    decls,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for VarDecl {
    #[doc = "Calls [FoldAstPath`::fold_var_decl`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_var_decl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            VarDecl {
                span,
                ctxt,
                kind,
                declare,
                decls,
            } => {
                let kind = <VarDeclKind as FoldWithAstPath<V>>::fold_with_ast_path(
                    kind, visitor, ast_path,
                );
                let decls = <Vec<VarDeclarator> as FoldWithAstPath<V>>::fold_with_ast_path(
                    decls, visitor, ast_path,
                );
                VarDecl {
                    span,
                    ctxt,
                    kind,
                    declare,
                    decls,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for VarDeclKind {
    #[doc = "Calls [FoldAstPath`::fold_var_decl_kind`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_var_decl_kind(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            VarDeclKind::Var => VarDeclKind::Var,
            VarDeclKind::Let => VarDeclKind::Let,
            VarDeclKind::Const => VarDeclKind::Const,
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for VarDeclOrExpr {
    #[doc = "Calls [FoldAstPath`::fold_var_decl_or_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_var_decl_or_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            VarDeclOrExpr::VarDecl { 0: _field_0 } => {
                let _field_0 = <Box<VarDecl> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                VarDeclOrExpr::VarDecl { 0: _field_0 }
            }
            VarDeclOrExpr::Expr { 0: _field_0 } => {
                let _field_0 = <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(
                    _field_0, visitor, ast_path,
                );
                VarDeclOrExpr::Expr { 0: _field_0 }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for VarDeclarator {
    #[doc = "Calls [FoldAstPath`::fold_var_declarator`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_var_declarator(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            VarDeclarator {
                span,
                name,
                init,
                definite,
            } => {
                let name = <Pat as FoldWithAstPath<V>>::fold_with_ast_path(name, visitor, ast_path);
                let init = <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    init, visitor, ast_path,
                );
                VarDeclarator {
                    span,
                    name,
                    init,
                    definite,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for WhileStmt {
    #[doc = "Calls [FoldAstPath`::fold_while_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_while_stmt(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            WhileStmt { span, test, body } => {
                let test =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(test, visitor, ast_path);
                let body =
                    <Box<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(body, visitor, ast_path);
                WhileStmt { span, test, body }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for WithStmt {
    #[doc = "Calls [FoldAstPath`::fold_with_stmt`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_with_stmt(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            WithStmt { span, obj, body } => {
                let obj =
                    <Box<Expr> as FoldWithAstPath<V>>::fold_with_ast_path(obj, visitor, ast_path);
                let body =
                    <Box<Stmt> as FoldWithAstPath<V>>::fold_with_ast_path(body, visitor, ast_path);
                WithStmt { span, obj, body }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for YieldExpr {
    #[doc = "Calls [FoldAstPath`::fold_yield_expr`] with `self`."]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_yield_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        match self {
            YieldExpr {
                span,
                arg,
                delegate,
            } => {
                let arg = <Option<Box<Expr>> as FoldWithAstPath<V>>::fold_with_ast_path(
                    arg, visitor, ast_path,
                );
                YieldExpr {
                    span,
                    arg,
                    delegate,
                }
            }
        }
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for swc_atoms::Atom {
    #[doc = "Calls [FoldAstPath`::fold_atom`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_atom(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for BigIntValue {
    #[doc = "Calls [FoldAstPath`::fold_big_int_value`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_big_int_value(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<ClassMember> {
    #[doc = "Calls [FoldAstPath`::fold_class_members`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_class_members(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <ClassMember as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for ClassMethod {
    #[doc = "Calls [FoldAstPath`::fold_class_method`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_class_method(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<Decorator> {
    #[doc = "Calls [FoldAstPath`::fold_decorators`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_decorators(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <Decorator as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<ExportSpecifier> {
    #[doc = "Calls [FoldAstPath`::fold_export_specifiers`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_export_specifiers(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <ExportSpecifier as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<ExprOrSpread> {
    #[doc = "Calls [FoldAstPath`::fold_expr_or_spreads`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_expr_or_spreads(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <ExprOrSpread as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<Box<Expr>> {
    #[doc = "Calls [FoldAstPath`::fold_exprs`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_exprs(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <Box<Expr> as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<ImportSpecifier> {
    #[doc = "Calls [FoldAstPath`::fold_import_specifiers`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import_specifiers(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <ImportSpecifier as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<ImportWithItem> {
    #[doc = "Calls [FoldAstPath`::fold_import_with_items`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_import_with_items(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <ImportWithItem as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<JSXAttrOrSpread> {
    #[doc = "Calls [FoldAstPath`::fold_jsx_attr_or_spreads`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_attr_or_spreads(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <JSXAttrOrSpread as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<JSXElementChild> {
    #[doc = "Calls [FoldAstPath`::fold_jsx_element_childs`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_jsx_element_childs(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <JSXElementChild as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<ModuleItem> {
    #[doc = "Calls [FoldAstPath`::fold_module_items`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_module_items(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <ModuleItem as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<ObjectPatProp> {
    #[doc = "Calls [FoldAstPath`::fold_object_pat_props`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_object_pat_props(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <ObjectPatProp as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<Accessibility> {
    #[doc = "Calls [FoldAstPath`::fold_opt_accessibility`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_accessibility(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| <Accessibility as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path))
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<swc_atoms::Atom> {
    #[doc = "Calls [FoldAstPath`::fold_opt_atom`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_atom(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <swc_atoms::Atom as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<BlockStmt> {
    #[doc = "Calls [FoldAstPath`::fold_opt_block_stmt`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_block_stmt(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| <BlockStmt as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path))
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<CatchClause> {
    #[doc = "Calls [FoldAstPath`::fold_opt_catch_clause`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_catch_clause(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| <CatchClause as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path))
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<Box<Expr>> {
    #[doc = "Calls [FoldAstPath`::fold_opt_expr`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| <Box<Expr> as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path))
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<ExprOrSpread> {
    #[doc = "Calls [FoldAstPath`::fold_opt_expr_or_spread`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_expr_or_spread(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| <ExprOrSpread as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path))
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<Vec<ExprOrSpread>> {
    #[doc = "Calls [FoldAstPath`::fold_opt_expr_or_spreads`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_expr_or_spreads(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <Vec<ExprOrSpread> as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<Ident> {
    #[doc = "Calls [FoldAstPath`::fold_opt_ident`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_ident(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| <Ident as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path))
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<JSXAttrValue> {
    #[doc = "Calls [FoldAstPath`::fold_opt_jsx_attr_value`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_jsx_attr_value(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| <JSXAttrValue as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path))
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<JSXClosingElement> {
    #[doc = "Calls [FoldAstPath`::fold_opt_jsx_closing_element`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_jsx_closing_element(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <JSXClosingElement as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<ModuleExportName> {
    #[doc = "Calls [FoldAstPath`::fold_opt_module_export_name`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_module_export_name(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <ModuleExportName as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<Vec<ModuleItem>> {
    #[doc = "Calls [FoldAstPath`::fold_opt_module_items`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_module_items(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <Vec<ModuleItem> as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<Box<ObjectLit>> {
    #[doc = "Calls [FoldAstPath`::fold_opt_object_lit`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_object_lit(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <Box<ObjectLit> as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<Pat> {
    #[doc = "Calls [FoldAstPath`::fold_opt_pat`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_pat(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| <Pat as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path))
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<swc_common::Span> {
    #[doc = "Calls [FoldAstPath`::fold_opt_span`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_span(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <swc_common::Span as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<Box<Stmt>> {
    #[doc = "Calls [FoldAstPath`::fold_opt_stmt`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_stmt(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| <Box<Stmt> as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path))
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<Box<Str>> {
    #[doc = "Calls [FoldAstPath`::fold_opt_str`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_str(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| <Box<Str> as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path))
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<TruePlusMinus> {
    #[doc = "Calls [FoldAstPath`::fold_opt_true_plus_minus`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_true_plus_minus(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| <TruePlusMinus as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path))
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<TsEntityName> {
    #[doc = "Calls [FoldAstPath`::fold_opt_ts_entity_name`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_ts_entity_name(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| <TsEntityName as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path))
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<TsNamespaceBody> {
    #[doc = "Calls [FoldAstPath`::fold_opt_ts_namespace_body`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_ts_namespace_body(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <TsNamespaceBody as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<Box<TsType>> {
    #[doc = "Calls [FoldAstPath`::fold_opt_ts_type`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_ts_type(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| <Box<TsType> as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path))
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<Box<TsTypeAnn>> {
    #[doc = "Calls [FoldAstPath`::fold_opt_ts_type_ann`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_ts_type_ann(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <Box<TsTypeAnn> as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<Box<TsTypeParamDecl>> {
    #[doc = "Calls [FoldAstPath`::fold_opt_ts_type_param_decl`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_ts_type_param_decl(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <Box<TsTypeParamDecl> as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path)
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<Box<TsTypeParamInstantiation>> {
    #[doc = "Calls [FoldAstPath`::fold_opt_ts_type_param_instantiation`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_ts_type_param_instantiation(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| {
            <Box<TsTypeParamInstantiation> as FoldWithAstPath<V>>::fold_with(
                inner, visitor, ast_path,
            )
        })
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Option<VarDeclOrExpr> {
    #[doc = "Calls [FoldAstPath`::fold_opt_var_decl_or_expr`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_var_decl_or_expr(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.map(|inner| <VarDeclOrExpr as FoldWithAstPath<V>>::fold_with(inner, visitor, ast_path))
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<Option<ExprOrSpread>> {
    #[doc = "Calls [FoldAstPath`::fold_opt_vec_expr_or_spreads`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_vec_expr_or_spreads(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| {
                <Option<ExprOrSpread> as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path)
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<Option<Pat>> {
    #[doc = "Calls [FoldAstPath`::fold_opt_vec_pats`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_opt_vec_pats(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <Option<Pat> as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<ParamOrTsParamProp> {
    #[doc = "Calls [FoldAstPath`::fold_param_or_ts_param_props`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_param_or_ts_param_props(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| {
                <ParamOrTsParamProp as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path)
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<Param> {
    #[doc = "Calls [FoldAstPath`::fold_params`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_params(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <Param as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<Pat> {
    #[doc = "Calls [FoldAstPath`::fold_pats`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_pats(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <Pat as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for PrivateMethod {
    #[doc = "Calls [FoldAstPath`::fold_private_method`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_private_method(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<PropOrSpread> {
    #[doc = "Calls [FoldAstPath`::fold_prop_or_spreads`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_prop_or_spreads(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <PropOrSpread as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for swc_common::Span {
    #[doc = "Calls [FoldAstPath`::fold_span`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_span(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<Stmt> {
    #[doc = "Calls [FoldAstPath`::fold_stmts`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_stmts(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <Stmt as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<SwitchCase> {
    #[doc = "Calls [FoldAstPath`::fold_switch_cases`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_switch_cases(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <SwitchCase as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for swc_common::SyntaxContext {
    #[doc = "Calls [FoldAstPath`::fold_syntax_context`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_syntax_context(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<TplElement> {
    #[doc = "Calls [FoldAstPath`::fold_tpl_elements`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_tpl_elements(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <TplElement as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<TsEnumMember> {
    #[doc = "Calls [FoldAstPath`::fold_ts_enum_members`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_enum_members(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <TsEnumMember as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<TsExprWithTypeArgs> {
    #[doc = "Calls [FoldAstPath`::fold_ts_expr_with_type_argss`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_expr_with_type_argss(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| {
                <TsExprWithTypeArgs as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path)
            })
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<TsFnParam> {
    #[doc = "Calls [FoldAstPath`::fold_ts_fn_params`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_fn_params(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <TsFnParam as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<TsTupleElement> {
    #[doc = "Calls [FoldAstPath`::fold_ts_tuple_elements`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_tuple_elements(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <TsTupleElement as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<TsTypeElement> {
    #[doc = "Calls [FoldAstPath`::fold_ts_type_elements`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_type_elements(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <TsTypeElement as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<TsTypeParam> {
    #[doc = "Calls [FoldAstPath`::fold_ts_type_params`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_type_params(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <TsTypeParam as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<Box<TsType>> {
    #[doc = "Calls [FoldAstPath`::fold_ts_types`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_ts_types(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <Box<TsType> as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V: ?Sized + FoldAstPath> FoldWithAstPath<V> for Vec<VarDeclarator> {
    #[doc = "Calls [FoldAstPath`::fold_var_declarators`] with `self`. (Extra impl)"]
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        <V as FoldAstPath>::fold_var_declarators(visitor, self, ast_path)
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        self.into_iter()
            .map(|item| <VarDeclarator as FoldWithAstPath<V>>::fold_with(item, visitor, ast_path))
            .collect()
    }
}
#[cfg(any(docsrs, feature = "path"))]
#[cfg_attr(docsrs, doc(cfg(feature = "path")))]
impl<V, T> FoldWithAstPath<V> for std::boxed::Box<T>
where
    V: ?Sized + FoldAstPath,
    T: FoldWithAstPath<V>,
{
    fn fold_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        let v = <T as FoldWithAstPath<V>>::fold_with_ast_path(*self, visitor, ast_path);
        let v = std::boxed::Box::new(v);
        v
    }

    fn fold_children_with_ast_path(self, visitor: &mut V, ast_path: &mut AstKindPath) -> Self {
        let v = <T as FoldWithAstPath<V>>::fold_children_with_ast_path(*self, visitor, ast_path);
        let v = std::boxed::Box::new(v);
        v
    }
}
#[cfg(feature = "path")]
pub type AstKindPath = swc_visit::AstKindPath<AstParentKind>;
#[cfg(feature = "path")]
pub type AstNodePath<'ast> = swc_visit::AstNodePath<AstParentNodeRef<'ast>>;
#[cfg(feature = "path")]
pub mod fields {
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum AccessibilityField {
        #[doc = "Represents [`Accessibility::Public`]"]
        Public,
        #[doc = "Represents [`Accessibility::Protected`]"]
        Protected,
        #[doc = "Represents [`Accessibility::Private`]"]
        Private,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ArrayLitField {
        #[doc = "Represents [`ArrayLit::span`]"]
        Span,
        #[doc = "Represents [`ArrayLit::elems`]"]
        Elems(usize),
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ArrayPatField {
        #[doc = "Represents [`ArrayPat::span`]"]
        Span,
        #[doc = "Represents [`ArrayPat::elems`]"]
        Elems(usize),
        #[doc = "Represents [`ArrayPat::optional`]"]
        Optional,
        #[doc = "Represents [`ArrayPat::type_ann`]"]
        TypeAnn,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ArrowExprField {
        #[doc = "Represents [`ArrowExpr::span`]"]
        Span,
        #[doc = "Represents [`ArrowExpr::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`ArrowExpr::params`]"]
        Params(usize),
        #[doc = "Represents [`ArrowExpr::body`]"]
        Body,
        #[doc = "Represents [`ArrowExpr::is_async`]"]
        IsAsync,
        #[doc = "Represents [`ArrowExpr::is_generator`]"]
        IsGenerator,
        #[doc = "Represents [`ArrowExpr::type_params`]"]
        TypeParams,
        #[doc = "Represents [`ArrowExpr::return_type`]"]
        ReturnType,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum AssignExprField {
        #[doc = "Represents [`AssignExpr::span`]"]
        Span,
        #[doc = "Represents [`AssignExpr::op`]"]
        Op,
        #[doc = "Represents [`AssignExpr::left`]"]
        Left,
        #[doc = "Represents [`AssignExpr::right`]"]
        Right,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum AssignOpField {
        #[doc = "Represents [`AssignOp::Assign`]"]
        Assign,
        #[doc = "Represents [`AssignOp::AddAssign`]"]
        AddAssign,
        #[doc = "Represents [`AssignOp::SubAssign`]"]
        SubAssign,
        #[doc = "Represents [`AssignOp::MulAssign`]"]
        MulAssign,
        #[doc = "Represents [`AssignOp::DivAssign`]"]
        DivAssign,
        #[doc = "Represents [`AssignOp::ModAssign`]"]
        ModAssign,
        #[doc = "Represents [`AssignOp::LShiftAssign`]"]
        LshiftAssign,
        #[doc = "Represents [`AssignOp::RShiftAssign`]"]
        RshiftAssign,
        #[doc = "Represents [`AssignOp::ZeroFillRShiftAssign`]"]
        ZeroFillRShiftAssign,
        #[doc = "Represents [`AssignOp::BitOrAssign`]"]
        BitOrAssign,
        #[doc = "Represents [`AssignOp::BitXorAssign`]"]
        BitXorAssign,
        #[doc = "Represents [`AssignOp::BitAndAssign`]"]
        BitAndAssign,
        #[doc = "Represents [`AssignOp::ExpAssign`]"]
        ExpAssign,
        #[doc = "Represents [`AssignOp::AndAssign`]"]
        AndAssign,
        #[doc = "Represents [`AssignOp::OrAssign`]"]
        OrAssign,
        #[doc = "Represents [`AssignOp::NullishAssign`]"]
        NullishAssign,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum AssignPatField {
        #[doc = "Represents [`AssignPat::span`]"]
        Span,
        #[doc = "Represents [`AssignPat::left`]"]
        Left,
        #[doc = "Represents [`AssignPat::right`]"]
        Right,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum AssignPatPropField {
        #[doc = "Represents [`AssignPatProp::span`]"]
        Span,
        #[doc = "Represents [`AssignPatProp::key`]"]
        Key,
        #[doc = "Represents [`AssignPatProp::value`]"]
        Value,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum AssignPropField {
        #[doc = "Represents [`AssignProp::span`]"]
        Span,
        #[doc = "Represents [`AssignProp::key`]"]
        Key,
        #[doc = "Represents [`AssignProp::value`]"]
        Value,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum AssignTargetField {
        #[doc = "Represents [`AssignTarget::Simple`]"]
        Simple,
        #[doc = "Represents [`AssignTarget::Pat`]"]
        Pat,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum AssignTargetPatField {
        #[doc = "Represents [`AssignTargetPat::Array`]"]
        Array,
        #[doc = "Represents [`AssignTargetPat::Object`]"]
        Object,
        #[doc = "Represents [`AssignTargetPat::Invalid`]"]
        Invalid,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum AutoAccessorField {
        #[doc = "Represents [`AutoAccessor::span`]"]
        Span,
        #[doc = "Represents [`AutoAccessor::key`]"]
        Key,
        #[doc = "Represents [`AutoAccessor::value`]"]
        Value,
        #[doc = "Represents [`AutoAccessor::type_ann`]"]
        TypeAnn,
        #[doc = "Represents [`AutoAccessor::is_static`]"]
        IsStatic,
        #[doc = "Represents [`AutoAccessor::decorators`]"]
        Decorators(usize),
        #[doc = "Represents [`AutoAccessor::accessibility`]"]
        Accessibility,
        #[doc = "Represents [`AutoAccessor::is_abstract`]"]
        IsAbstract,
        #[doc = "Represents [`AutoAccessor::is_override`]"]
        IsOverride,
        #[doc = "Represents [`AutoAccessor::definite`]"]
        Definite,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum AwaitExprField {
        #[doc = "Represents [`AwaitExpr::span`]"]
        Span,
        #[doc = "Represents [`AwaitExpr::arg`]"]
        Arg,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum BigIntField {
        #[doc = "Represents [`BigInt::span`]"]
        Span,
        #[doc = "Represents [`BigInt::value`]"]
        Value,
        #[doc = "Represents [`BigInt::raw`]"]
        Raw,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum BinExprField {
        #[doc = "Represents [`BinExpr::span`]"]
        Span,
        #[doc = "Represents [`BinExpr::op`]"]
        Op,
        #[doc = "Represents [`BinExpr::left`]"]
        Left,
        #[doc = "Represents [`BinExpr::right`]"]
        Right,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum BinaryOpField {
        #[doc = "Represents [`BinaryOp::EqEq`]"]
        EqEq,
        #[doc = "Represents [`BinaryOp::NotEq`]"]
        NotEq,
        #[doc = "Represents [`BinaryOp::EqEqEq`]"]
        EqEqEq,
        #[doc = "Represents [`BinaryOp::NotEqEq`]"]
        NotEqEq,
        #[doc = "Represents [`BinaryOp::Lt`]"]
        Lt,
        #[doc = "Represents [`BinaryOp::LtEq`]"]
        LtEq,
        #[doc = "Represents [`BinaryOp::Gt`]"]
        Gt,
        #[doc = "Represents [`BinaryOp::GtEq`]"]
        GtEq,
        #[doc = "Represents [`BinaryOp::LShift`]"]
        Lshift,
        #[doc = "Represents [`BinaryOp::RShift`]"]
        Rshift,
        #[doc = "Represents [`BinaryOp::ZeroFillRShift`]"]
        ZeroFillRShift,
        #[doc = "Represents [`BinaryOp::Add`]"]
        Add,
        #[doc = "Represents [`BinaryOp::Sub`]"]
        Sub,
        #[doc = "Represents [`BinaryOp::Mul`]"]
        Mul,
        #[doc = "Represents [`BinaryOp::Div`]"]
        Div,
        #[doc = "Represents [`BinaryOp::Mod`]"]
        Mod,
        #[doc = "Represents [`BinaryOp::BitOr`]"]
        BitOr,
        #[doc = "Represents [`BinaryOp::BitXor`]"]
        BitXor,
        #[doc = "Represents [`BinaryOp::BitAnd`]"]
        BitAnd,
        #[doc = "Represents [`BinaryOp::LogicalOr`]"]
        LogicalOr,
        #[doc = "Represents [`BinaryOp::LogicalAnd`]"]
        LogicalAnd,
        #[doc = "Represents [`BinaryOp::In`]"]
        In,
        #[doc = "Represents [`BinaryOp::InstanceOf`]"]
        InstanceOf,
        #[doc = "Represents [`BinaryOp::Exp`]"]
        Exp,
        #[doc = "Represents [`BinaryOp::NullishCoalescing`]"]
        NullishCoalescing,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum BindingIdentField {
        #[doc = "Represents [`BindingIdent::id`]"]
        Id,
        #[doc = "Represents [`BindingIdent::type_ann`]"]
        TypeAnn,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum BlockStmtField {
        #[doc = "Represents [`BlockStmt::span`]"]
        Span,
        #[doc = "Represents [`BlockStmt::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`BlockStmt::stmts`]"]
        Stmts(usize),
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum BlockStmtOrExprField {
        #[doc = "Represents [`BlockStmtOrExpr::BlockStmt`]"]
        BlockStmt,
        #[doc = "Represents [`BlockStmtOrExpr::Expr`]"]
        Expr,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum BoolField {
        #[doc = "Represents [`Bool::span`]"]
        Span,
        #[doc = "Represents [`Bool::value`]"]
        Value,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum BreakStmtField {
        #[doc = "Represents [`BreakStmt::span`]"]
        Span,
        #[doc = "Represents [`BreakStmt::label`]"]
        Label,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum CallExprField {
        #[doc = "Represents [`CallExpr::span`]"]
        Span,
        #[doc = "Represents [`CallExpr::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`CallExpr::callee`]"]
        Callee,
        #[doc = "Represents [`CallExpr::args`]"]
        Args(usize),
        #[doc = "Represents [`CallExpr::type_args`]"]
        TypeArgs,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum CalleeField {
        #[doc = "Represents [`Callee::Super`]"]
        Super,
        #[doc = "Represents [`Callee::Import`]"]
        Import,
        #[doc = "Represents [`Callee::Expr`]"]
        Expr,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum CatchClauseField {
        #[doc = "Represents [`CatchClause::span`]"]
        Span,
        #[doc = "Represents [`CatchClause::param`]"]
        Param,
        #[doc = "Represents [`CatchClause::body`]"]
        Body,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ClassField {
        #[doc = "Represents [`Class::span`]"]
        Span,
        #[doc = "Represents [`Class::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`Class::decorators`]"]
        Decorators(usize),
        #[doc = "Represents [`Class::body`]"]
        Body(usize),
        #[doc = "Represents [`Class::super_class`]"]
        SuperClass,
        #[doc = "Represents [`Class::is_abstract`]"]
        IsAbstract,
        #[doc = "Represents [`Class::type_params`]"]
        TypeParams,
        #[doc = "Represents [`Class::super_type_params`]"]
        SuperTypeParams,
        #[doc = "Represents [`Class::implements`]"]
        Implements(usize),
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ClassDeclField {
        #[doc = "Represents [`ClassDecl::ident`]"]
        Ident,
        #[doc = "Represents [`ClassDecl::declare`]"]
        Declare,
        #[doc = "Represents [`ClassDecl::class`]"]
        Class,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ClassExprField {
        #[doc = "Represents [`ClassExpr::ident`]"]
        Ident,
        #[doc = "Represents [`ClassExpr::class`]"]
        Class,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ClassMemberField {
        #[doc = "Represents [`ClassMember::Constructor`]"]
        Constructor,
        #[doc = "Represents [`ClassMember::Method`]"]
        Method,
        #[doc = "Represents [`ClassMember::PrivateMethod`]"]
        PrivateMethod,
        #[doc = "Represents [`ClassMember::ClassProp`]"]
        ClassProp,
        #[doc = "Represents [`ClassMember::PrivateProp`]"]
        PrivateProp,
        #[doc = "Represents [`ClassMember::TsIndexSignature`]"]
        TsIndexSignature,
        #[doc = "Represents [`ClassMember::Empty`]"]
        Empty,
        #[doc = "Represents [`ClassMember::StaticBlock`]"]
        StaticBlock,
        #[doc = "Represents [`ClassMember::AutoAccessor`]"]
        AutoAccessor,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ClassPropField {
        #[doc = "Represents [`ClassProp::span`]"]
        Span,
        #[doc = "Represents [`ClassProp::key`]"]
        Key,
        #[doc = "Represents [`ClassProp::value`]"]
        Value,
        #[doc = "Represents [`ClassProp::type_ann`]"]
        TypeAnn,
        #[doc = "Represents [`ClassProp::is_static`]"]
        IsStatic,
        #[doc = "Represents [`ClassProp::decorators`]"]
        Decorators(usize),
        #[doc = "Represents [`ClassProp::accessibility`]"]
        Accessibility,
        #[doc = "Represents [`ClassProp::is_abstract`]"]
        IsAbstract,
        #[doc = "Represents [`ClassProp::is_optional`]"]
        IsOptional,
        #[doc = "Represents [`ClassProp::is_override`]"]
        IsOverride,
        #[doc = "Represents [`ClassProp::readonly`]"]
        Readonly,
        #[doc = "Represents [`ClassProp::declare`]"]
        Declare,
        #[doc = "Represents [`ClassProp::definite`]"]
        Definite,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ComputedPropNameField {
        #[doc = "Represents [`ComputedPropName::span`]"]
        Span,
        #[doc = "Represents [`ComputedPropName::expr`]"]
        Expr,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum CondExprField {
        #[doc = "Represents [`CondExpr::span`]"]
        Span,
        #[doc = "Represents [`CondExpr::test`]"]
        Test,
        #[doc = "Represents [`CondExpr::cons`]"]
        Cons,
        #[doc = "Represents [`CondExpr::alt`]"]
        Alt,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ConstructorField {
        #[doc = "Represents [`Constructor::span`]"]
        Span,
        #[doc = "Represents [`Constructor::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`Constructor::key`]"]
        Key,
        #[doc = "Represents [`Constructor::params`]"]
        Params(usize),
        #[doc = "Represents [`Constructor::body`]"]
        Body,
        #[doc = "Represents [`Constructor::accessibility`]"]
        Accessibility,
        #[doc = "Represents [`Constructor::is_optional`]"]
        IsOptional,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ContinueStmtField {
        #[doc = "Represents [`ContinueStmt::span`]"]
        Span,
        #[doc = "Represents [`ContinueStmt::label`]"]
        Label,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum DebuggerStmtField {
        #[doc = "Represents [`DebuggerStmt::span`]"]
        Span,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum DeclField {
        #[doc = "Represents [`Decl::Class`]"]
        Class,
        #[doc = "Represents [`Decl::Fn`]"]
        Fn,
        #[doc = "Represents [`Decl::Var`]"]
        Var,
        #[doc = "Represents [`Decl::Using`]"]
        Using,
        #[doc = "Represents [`Decl::TsInterface`]"]
        TsInterface,
        #[doc = "Represents [`Decl::TsTypeAlias`]"]
        TsTypeAlias,
        #[doc = "Represents [`Decl::TsEnum`]"]
        TsEnum,
        #[doc = "Represents [`Decl::TsModule`]"]
        TsModule,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum DecoratorField {
        #[doc = "Represents [`Decorator::span`]"]
        Span,
        #[doc = "Represents [`Decorator::expr`]"]
        Expr,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum DefaultDeclField {
        #[doc = "Represents [`DefaultDecl::Class`]"]
        Class,
        #[doc = "Represents [`DefaultDecl::Fn`]"]
        Fn,
        #[doc = "Represents [`DefaultDecl::TsInterfaceDecl`]"]
        TsInterfaceDecl,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum DoWhileStmtField {
        #[doc = "Represents [`DoWhileStmt::span`]"]
        Span,
        #[doc = "Represents [`DoWhileStmt::test`]"]
        Test,
        #[doc = "Represents [`DoWhileStmt::body`]"]
        Body,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum EmptyStmtField {
        #[doc = "Represents [`EmptyStmt::span`]"]
        Span,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum EsVersionField {
        #[doc = "Represents [`EsVersion::Es3`]"]
        Es3,
        #[doc = "Represents [`EsVersion::Es5`]"]
        Es5,
        #[doc = "Represents [`EsVersion::Es2015`]"]
        Es2015,
        #[doc = "Represents [`EsVersion::Es2016`]"]
        Es2016,
        #[doc = "Represents [`EsVersion::Es2017`]"]
        Es2017,
        #[doc = "Represents [`EsVersion::Es2018`]"]
        Es2018,
        #[doc = "Represents [`EsVersion::Es2019`]"]
        Es2019,
        #[doc = "Represents [`EsVersion::Es2020`]"]
        Es2020,
        #[doc = "Represents [`EsVersion::Es2021`]"]
        Es2021,
        #[doc = "Represents [`EsVersion::Es2022`]"]
        Es2022,
        #[doc = "Represents [`EsVersion::EsNext`]"]
        EsNext,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ExportAllField {
        #[doc = "Represents [`ExportAll::span`]"]
        Span,
        #[doc = "Represents [`ExportAll::src`]"]
        Src,
        #[doc = "Represents [`ExportAll::type_only`]"]
        TypeOnly,
        #[doc = "Represents [`ExportAll::with`]"]
        With,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ExportDeclField {
        #[doc = "Represents [`ExportDecl::span`]"]
        Span,
        #[doc = "Represents [`ExportDecl::decl`]"]
        Decl,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ExportDefaultDeclField {
        #[doc = "Represents [`ExportDefaultDecl::span`]"]
        Span,
        #[doc = "Represents [`ExportDefaultDecl::decl`]"]
        Decl,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ExportDefaultExprField {
        #[doc = "Represents [`ExportDefaultExpr::span`]"]
        Span,
        #[doc = "Represents [`ExportDefaultExpr::expr`]"]
        Expr,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ExportDefaultSpecifierField {
        #[doc = "Represents [`ExportDefaultSpecifier::exported`]"]
        Exported,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ExportNamedSpecifierField {
        #[doc = "Represents [`ExportNamedSpecifier::span`]"]
        Span,
        #[doc = "Represents [`ExportNamedSpecifier::orig`]"]
        Orig,
        #[doc = "Represents [`ExportNamedSpecifier::exported`]"]
        Exported,
        #[doc = "Represents [`ExportNamedSpecifier::is_type_only`]"]
        IsTypeOnly,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ExportNamespaceSpecifierField {
        #[doc = "Represents [`ExportNamespaceSpecifier::span`]"]
        Span,
        #[doc = "Represents [`ExportNamespaceSpecifier::name`]"]
        Name,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ExportSpecifierField {
        #[doc = "Represents [`ExportSpecifier::Namespace`]"]
        Namespace,
        #[doc = "Represents [`ExportSpecifier::Default`]"]
        Default,
        #[doc = "Represents [`ExportSpecifier::Named`]"]
        Named,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ExprField {
        #[doc = "Represents [`Expr::This`]"]
        This,
        #[doc = "Represents [`Expr::Array`]"]
        Array,
        #[doc = "Represents [`Expr::Object`]"]
        Object,
        #[doc = "Represents [`Expr::Fn`]"]
        Fn,
        #[doc = "Represents [`Expr::Unary`]"]
        Unary,
        #[doc = "Represents [`Expr::Update`]"]
        Update,
        #[doc = "Represents [`Expr::Bin`]"]
        Bin,
        #[doc = "Represents [`Expr::Assign`]"]
        Assign,
        #[doc = "Represents [`Expr::Member`]"]
        Member,
        #[doc = "Represents [`Expr::SuperProp`]"]
        SuperProp,
        #[doc = "Represents [`Expr::Cond`]"]
        Cond,
        #[doc = "Represents [`Expr::Call`]"]
        Call,
        #[doc = "Represents [`Expr::New`]"]
        New,
        #[doc = "Represents [`Expr::Seq`]"]
        Seq,
        #[doc = "Represents [`Expr::Ident`]"]
        Ident,
        #[doc = "Represents [`Expr::Lit`]"]
        Lit,
        #[doc = "Represents [`Expr::Tpl`]"]
        Tpl,
        #[doc = "Represents [`Expr::TaggedTpl`]"]
        TaggedTpl,
        #[doc = "Represents [`Expr::Arrow`]"]
        Arrow,
        #[doc = "Represents [`Expr::Class`]"]
        Class,
        #[doc = "Represents [`Expr::Yield`]"]
        Yield,
        #[doc = "Represents [`Expr::MetaProp`]"]
        MetaProp,
        #[doc = "Represents [`Expr::Await`]"]
        Await,
        #[doc = "Represents [`Expr::Paren`]"]
        Paren,
        #[doc = "Represents [`Expr::JSXMember`]"]
        Jsxmember,
        #[doc = "Represents [`Expr::JSXNamespacedName`]"]
        JsxnamespacedName,
        #[doc = "Represents [`Expr::JSXEmpty`]"]
        Jsxempty,
        #[doc = "Represents [`Expr::JSXElement`]"]
        Jsxelement,
        #[doc = "Represents [`Expr::JSXFragment`]"]
        Jsxfragment,
        #[doc = "Represents [`Expr::TsTypeAssertion`]"]
        TsTypeAssertion,
        #[doc = "Represents [`Expr::TsConstAssertion`]"]
        TsConstAssertion,
        #[doc = "Represents [`Expr::TsNonNull`]"]
        TsNonNull,
        #[doc = "Represents [`Expr::TsAs`]"]
        TsAs,
        #[doc = "Represents [`Expr::TsInstantiation`]"]
        TsInstantiation,
        #[doc = "Represents [`Expr::TsSatisfies`]"]
        TsSatisfies,
        #[doc = "Represents [`Expr::PrivateName`]"]
        PrivateName,
        #[doc = "Represents [`Expr::OptChain`]"]
        OptChain,
        #[doc = "Represents [`Expr::Invalid`]"]
        Invalid,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ExprOrSpreadField {
        #[doc = "Represents [`ExprOrSpread::spread`]"]
        Spread,
        #[doc = "Represents [`ExprOrSpread::expr`]"]
        Expr,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ExprStmtField {
        #[doc = "Represents [`ExprStmt::span`]"]
        Span,
        #[doc = "Represents [`ExprStmt::expr`]"]
        Expr,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum FnDeclField {
        #[doc = "Represents [`FnDecl::ident`]"]
        Ident,
        #[doc = "Represents [`FnDecl::declare`]"]
        Declare,
        #[doc = "Represents [`FnDecl::function`]"]
        Function,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum FnExprField {
        #[doc = "Represents [`FnExpr::ident`]"]
        Ident,
        #[doc = "Represents [`FnExpr::function`]"]
        Function,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ForHeadField {
        #[doc = "Represents [`ForHead::VarDecl`]"]
        VarDecl,
        #[doc = "Represents [`ForHead::UsingDecl`]"]
        UsingDecl,
        #[doc = "Represents [`ForHead::Pat`]"]
        Pat,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ForInStmtField {
        #[doc = "Represents [`ForInStmt::span`]"]
        Span,
        #[doc = "Represents [`ForInStmt::left`]"]
        Left,
        #[doc = "Represents [`ForInStmt::right`]"]
        Right,
        #[doc = "Represents [`ForInStmt::body`]"]
        Body,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ForOfStmtField {
        #[doc = "Represents [`ForOfStmt::span`]"]
        Span,
        #[doc = "Represents [`ForOfStmt::is_await`]"]
        IsAwait,
        #[doc = "Represents [`ForOfStmt::left`]"]
        Left,
        #[doc = "Represents [`ForOfStmt::right`]"]
        Right,
        #[doc = "Represents [`ForOfStmt::body`]"]
        Body,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ForStmtField {
        #[doc = "Represents [`ForStmt::span`]"]
        Span,
        #[doc = "Represents [`ForStmt::init`]"]
        Init,
        #[doc = "Represents [`ForStmt::test`]"]
        Test,
        #[doc = "Represents [`ForStmt::update`]"]
        Update,
        #[doc = "Represents [`ForStmt::body`]"]
        Body,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum FunctionField {
        #[doc = "Represents [`Function::params`]"]
        Params(usize),
        #[doc = "Represents [`Function::decorators`]"]
        Decorators(usize),
        #[doc = "Represents [`Function::span`]"]
        Span,
        #[doc = "Represents [`Function::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`Function::body`]"]
        Body,
        #[doc = "Represents [`Function::is_generator`]"]
        IsGenerator,
        #[doc = "Represents [`Function::is_async`]"]
        IsAsync,
        #[doc = "Represents [`Function::type_params`]"]
        TypeParams,
        #[doc = "Represents [`Function::return_type`]"]
        ReturnType,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum GetterPropField {
        #[doc = "Represents [`GetterProp::span`]"]
        Span,
        #[doc = "Represents [`GetterProp::key`]"]
        Key,
        #[doc = "Represents [`GetterProp::type_ann`]"]
        TypeAnn,
        #[doc = "Represents [`GetterProp::body`]"]
        Body,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum IdentField {
        #[doc = "Represents [`Ident::span`]"]
        Span,
        #[doc = "Represents [`Ident::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`Ident::sym`]"]
        Sym,
        #[doc = "Represents [`Ident::optional`]"]
        Optional,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum IdentNameField {
        #[doc = "Represents [`IdentName::span`]"]
        Span,
        #[doc = "Represents [`IdentName::sym`]"]
        Sym,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum IfStmtField {
        #[doc = "Represents [`IfStmt::span`]"]
        Span,
        #[doc = "Represents [`IfStmt::test`]"]
        Test,
        #[doc = "Represents [`IfStmt::cons`]"]
        Cons,
        #[doc = "Represents [`IfStmt::alt`]"]
        Alt,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ImportField {
        #[doc = "Represents [`Import::span`]"]
        Span,
        #[doc = "Represents [`Import::phase`]"]
        Phase,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ImportDeclField {
        #[doc = "Represents [`ImportDecl::span`]"]
        Span,
        #[doc = "Represents [`ImportDecl::specifiers`]"]
        Specifiers(usize),
        #[doc = "Represents [`ImportDecl::src`]"]
        Src,
        #[doc = "Represents [`ImportDecl::type_only`]"]
        TypeOnly,
        #[doc = "Represents [`ImportDecl::with`]"]
        With,
        #[doc = "Represents [`ImportDecl::phase`]"]
        Phase,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ImportDefaultSpecifierField {
        #[doc = "Represents [`ImportDefaultSpecifier::span`]"]
        Span,
        #[doc = "Represents [`ImportDefaultSpecifier::local`]"]
        Local,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ImportNamedSpecifierField {
        #[doc = "Represents [`ImportNamedSpecifier::span`]"]
        Span,
        #[doc = "Represents [`ImportNamedSpecifier::local`]"]
        Local,
        #[doc = "Represents [`ImportNamedSpecifier::imported`]"]
        Imported,
        #[doc = "Represents [`ImportNamedSpecifier::is_type_only`]"]
        IsTypeOnly,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ImportPhaseField {
        #[doc = "Represents [`ImportPhase::Evaluation`]"]
        Evaluation,
        #[doc = "Represents [`ImportPhase::Source`]"]
        Source,
        #[doc = "Represents [`ImportPhase::Defer`]"]
        Defer,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ImportSpecifierField {
        #[doc = "Represents [`ImportSpecifier::Named`]"]
        Named,
        #[doc = "Represents [`ImportSpecifier::Default`]"]
        Default,
        #[doc = "Represents [`ImportSpecifier::Namespace`]"]
        Namespace,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ImportStarAsSpecifierField {
        #[doc = "Represents [`ImportStarAsSpecifier::span`]"]
        Span,
        #[doc = "Represents [`ImportStarAsSpecifier::local`]"]
        Local,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ImportWithField {
        #[doc = "Represents [`ImportWith::span`]"]
        Span,
        #[doc = "Represents [`ImportWith::values`]"]
        Values(usize),
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ImportWithItemField {
        #[doc = "Represents [`ImportWithItem::key`]"]
        Key,
        #[doc = "Represents [`ImportWithItem::value`]"]
        Value,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum InvalidField {
        #[doc = "Represents [`Invalid::span`]"]
        Span,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum JSXAttrField {
        #[doc = "Represents [`JSXAttr::span`]"]
        Span,
        #[doc = "Represents [`JSXAttr::name`]"]
        Name,
        #[doc = "Represents [`JSXAttr::value`]"]
        Value,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum JSXAttrNameField {
        #[doc = "Represents [`JSXAttrName::Ident`]"]
        Ident,
        #[doc = "Represents [`JSXAttrName::JSXNamespacedName`]"]
        JsxnamespacedName,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum JSXAttrOrSpreadField {
        #[doc = "Represents [`JSXAttrOrSpread::JSXAttr`]"]
        Jsxattr,
        #[doc = "Represents [`JSXAttrOrSpread::SpreadElement`]"]
        SpreadElement,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum JSXAttrValueField {
        #[doc = "Represents [`JSXAttrValue::Lit`]"]
        Lit,
        #[doc = "Represents [`JSXAttrValue::JSXExprContainer`]"]
        JsxexprContainer,
        #[doc = "Represents [`JSXAttrValue::JSXElement`]"]
        Jsxelement,
        #[doc = "Represents [`JSXAttrValue::JSXFragment`]"]
        Jsxfragment,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum JSXClosingElementField {
        #[doc = "Represents [`JSXClosingElement::span`]"]
        Span,
        #[doc = "Represents [`JSXClosingElement::name`]"]
        Name,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum JSXClosingFragmentField {
        #[doc = "Represents [`JSXClosingFragment::span`]"]
        Span,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum JSXElementField {
        #[doc = "Represents [`JSXElement::span`]"]
        Span,
        #[doc = "Represents [`JSXElement::opening`]"]
        Opening,
        #[doc = "Represents [`JSXElement::children`]"]
        Children(usize),
        #[doc = "Represents [`JSXElement::closing`]"]
        Closing,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum JSXElementChildField {
        #[doc = "Represents [`JSXElementChild::JSXText`]"]
        Jsxtext,
        #[doc = "Represents [`JSXElementChild::JSXExprContainer`]"]
        JsxexprContainer,
        #[doc = "Represents [`JSXElementChild::JSXSpreadChild`]"]
        JsxspreadChild,
        #[doc = "Represents [`JSXElementChild::JSXElement`]"]
        Jsxelement,
        #[doc = "Represents [`JSXElementChild::JSXFragment`]"]
        Jsxfragment,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum JSXElementNameField {
        #[doc = "Represents [`JSXElementName::Ident`]"]
        Ident,
        #[doc = "Represents [`JSXElementName::JSXMemberExpr`]"]
        JsxmemberExpr,
        #[doc = "Represents [`JSXElementName::JSXNamespacedName`]"]
        JsxnamespacedName,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum JSXEmptyExprField {
        #[doc = "Represents [`JSXEmptyExpr::span`]"]
        Span,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum JSXExprField {
        #[doc = "Represents [`JSXExpr::JSXEmptyExpr`]"]
        JsxemptyExpr,
        #[doc = "Represents [`JSXExpr::Expr`]"]
        Expr,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum JSXExprContainerField {
        #[doc = "Represents [`JSXExprContainer::span`]"]
        Span,
        #[doc = "Represents [`JSXExprContainer::expr`]"]
        Expr,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum JSXFragmentField {
        #[doc = "Represents [`JSXFragment::span`]"]
        Span,
        #[doc = "Represents [`JSXFragment::opening`]"]
        Opening,
        #[doc = "Represents [`JSXFragment::children`]"]
        Children(usize),
        #[doc = "Represents [`JSXFragment::closing`]"]
        Closing,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum JSXMemberExprField {
        #[doc = "Represents [`JSXMemberExpr::span`]"]
        Span,
        #[doc = "Represents [`JSXMemberExpr::obj`]"]
        Obj,
        #[doc = "Represents [`JSXMemberExpr::prop`]"]
        Prop,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum JSXNamespacedNameField {
        #[doc = "Represents [`JSXNamespacedName::span`]"]
        Span,
        #[doc = "Represents [`JSXNamespacedName::ns`]"]
        Ns,
        #[doc = "Represents [`JSXNamespacedName::name`]"]
        Name,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum JSXObjectField {
        #[doc = "Represents [`JSXObject::JSXMemberExpr`]"]
        JsxmemberExpr,
        #[doc = "Represents [`JSXObject::Ident`]"]
        Ident,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum JSXOpeningElementField {
        #[doc = "Represents [`JSXOpeningElement::name`]"]
        Name,
        #[doc = "Represents [`JSXOpeningElement::span`]"]
        Span,
        #[doc = "Represents [`JSXOpeningElement::attrs`]"]
        Attrs(usize),
        #[doc = "Represents [`JSXOpeningElement::self_closing`]"]
        SelfClosing,
        #[doc = "Represents [`JSXOpeningElement::type_args`]"]
        TypeArgs,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum JSXOpeningFragmentField {
        #[doc = "Represents [`JSXOpeningFragment::span`]"]
        Span,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum JSXSpreadChildField {
        #[doc = "Represents [`JSXSpreadChild::span`]"]
        Span,
        #[doc = "Represents [`JSXSpreadChild::expr`]"]
        Expr,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum JSXTextField {
        #[doc = "Represents [`JSXText::span`]"]
        Span,
        #[doc = "Represents [`JSXText::value`]"]
        Value,
        #[doc = "Represents [`JSXText::raw`]"]
        Raw,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum KeyField {
        #[doc = "Represents [`Key::Private`]"]
        Private,
        #[doc = "Represents [`Key::Public`]"]
        Public,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum KeyValuePatPropField {
        #[doc = "Represents [`KeyValuePatProp::key`]"]
        Key,
        #[doc = "Represents [`KeyValuePatProp::value`]"]
        Value,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum KeyValuePropField {
        #[doc = "Represents [`KeyValueProp::key`]"]
        Key,
        #[doc = "Represents [`KeyValueProp::value`]"]
        Value,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum LabeledStmtField {
        #[doc = "Represents [`LabeledStmt::span`]"]
        Span,
        #[doc = "Represents [`LabeledStmt::label`]"]
        Label,
        #[doc = "Represents [`LabeledStmt::body`]"]
        Body,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum LitField {
        #[doc = "Represents [`Lit::Str`]"]
        Str,
        #[doc = "Represents [`Lit::Bool`]"]
        Bool,
        #[doc = "Represents [`Lit::Null`]"]
        Null,
        #[doc = "Represents [`Lit::Num`]"]
        Num,
        #[doc = "Represents [`Lit::BigInt`]"]
        BigInt,
        #[doc = "Represents [`Lit::Regex`]"]
        Regex,
        #[doc = "Represents [`Lit::JSXText`]"]
        Jsxtext,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum MemberExprField {
        #[doc = "Represents [`MemberExpr::span`]"]
        Span,
        #[doc = "Represents [`MemberExpr::obj`]"]
        Obj,
        #[doc = "Represents [`MemberExpr::prop`]"]
        Prop,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum MemberPropField {
        #[doc = "Represents [`MemberProp::Ident`]"]
        Ident,
        #[doc = "Represents [`MemberProp::PrivateName`]"]
        PrivateName,
        #[doc = "Represents [`MemberProp::Computed`]"]
        Computed,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum MetaPropExprField {
        #[doc = "Represents [`MetaPropExpr::span`]"]
        Span,
        #[doc = "Represents [`MetaPropExpr::kind`]"]
        Kind,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum MetaPropKindField {
        #[doc = "Represents [`MetaPropKind::NewTarget`]"]
        NewTarget,
        #[doc = "Represents [`MetaPropKind::ImportMeta`]"]
        ImportMeta,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum MethodKindField {
        #[doc = "Represents [`MethodKind::Method`]"]
        Method,
        #[doc = "Represents [`MethodKind::Getter`]"]
        Getter,
        #[doc = "Represents [`MethodKind::Setter`]"]
        Setter,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum MethodPropField {
        #[doc = "Represents [`MethodProp::key`]"]
        Key,
        #[doc = "Represents [`MethodProp::function`]"]
        Function,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ModuleField {
        #[doc = "Represents [`Module::span`]"]
        Span,
        #[doc = "Represents [`Module::body`]"]
        Body(usize),
        #[doc = "Represents [`Module::shebang`]"]
        Shebang,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ModuleDeclField {
        #[doc = "Represents [`ModuleDecl::Import`]"]
        Import,
        #[doc = "Represents [`ModuleDecl::ExportDecl`]"]
        ExportDecl,
        #[doc = "Represents [`ModuleDecl::ExportNamed`]"]
        ExportNamed,
        #[doc = "Represents [`ModuleDecl::ExportDefaultDecl`]"]
        ExportDefaultDecl,
        #[doc = "Represents [`ModuleDecl::ExportDefaultExpr`]"]
        ExportDefaultExpr,
        #[doc = "Represents [`ModuleDecl::ExportAll`]"]
        ExportAll,
        #[doc = "Represents [`ModuleDecl::TsImportEquals`]"]
        TsImportEquals,
        #[doc = "Represents [`ModuleDecl::TsExportAssignment`]"]
        TsExportAssignment,
        #[doc = "Represents [`ModuleDecl::TsNamespaceExport`]"]
        TsNamespaceExport,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ModuleExportNameField {
        #[doc = "Represents [`ModuleExportName::Ident`]"]
        Ident,
        #[doc = "Represents [`ModuleExportName::Str`]"]
        Str,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ModuleItemField {
        #[doc = "Represents [`ModuleItem::ModuleDecl`]"]
        ModuleDecl,
        #[doc = "Represents [`ModuleItem::Stmt`]"]
        Stmt,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum NamedExportField {
        #[doc = "Represents [`NamedExport::span`]"]
        Span,
        #[doc = "Represents [`NamedExport::specifiers`]"]
        Specifiers(usize),
        #[doc = "Represents [`NamedExport::src`]"]
        Src,
        #[doc = "Represents [`NamedExport::type_only`]"]
        TypeOnly,
        #[doc = "Represents [`NamedExport::with`]"]
        With,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum NewExprField {
        #[doc = "Represents [`NewExpr::span`]"]
        Span,
        #[doc = "Represents [`NewExpr::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`NewExpr::callee`]"]
        Callee,
        #[doc = "Represents [`NewExpr::args`]"]
        Args,
        #[doc = "Represents [`NewExpr::type_args`]"]
        TypeArgs,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum NullField {
        #[doc = "Represents [`Null::span`]"]
        Span,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum NumberField {
        #[doc = "Represents [`Number::span`]"]
        Span,
        #[doc = "Represents [`Number::value`]"]
        Value,
        #[doc = "Represents [`Number::raw`]"]
        Raw,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ObjectLitField {
        #[doc = "Represents [`ObjectLit::span`]"]
        Span,
        #[doc = "Represents [`ObjectLit::props`]"]
        Props(usize),
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ObjectPatField {
        #[doc = "Represents [`ObjectPat::span`]"]
        Span,
        #[doc = "Represents [`ObjectPat::props`]"]
        Props(usize),
        #[doc = "Represents [`ObjectPat::optional`]"]
        Optional,
        #[doc = "Represents [`ObjectPat::type_ann`]"]
        TypeAnn,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ObjectPatPropField {
        #[doc = "Represents [`ObjectPatProp::KeyValue`]"]
        KeyValue,
        #[doc = "Represents [`ObjectPatProp::Assign`]"]
        Assign,
        #[doc = "Represents [`ObjectPatProp::Rest`]"]
        Rest,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum OptCallField {
        #[doc = "Represents [`OptCall::span`]"]
        Span,
        #[doc = "Represents [`OptCall::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`OptCall::callee`]"]
        Callee,
        #[doc = "Represents [`OptCall::args`]"]
        Args(usize),
        #[doc = "Represents [`OptCall::type_args`]"]
        TypeArgs,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum OptChainBaseField {
        #[doc = "Represents [`OptChainBase::Member`]"]
        Member,
        #[doc = "Represents [`OptChainBase::Call`]"]
        Call,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum OptChainExprField {
        #[doc = "Represents [`OptChainExpr::span`]"]
        Span,
        #[doc = "Represents [`OptChainExpr::optional`]"]
        Optional,
        #[doc = "Represents [`OptChainExpr::base`]"]
        Base,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ParamField {
        #[doc = "Represents [`Param::span`]"]
        Span,
        #[doc = "Represents [`Param::decorators`]"]
        Decorators(usize),
        #[doc = "Represents [`Param::pat`]"]
        Pat,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ParamOrTsParamPropField {
        #[doc = "Represents [`ParamOrTsParamProp::TsParamProp`]"]
        TsParamProp,
        #[doc = "Represents [`ParamOrTsParamProp::Param`]"]
        Param,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ParenExprField {
        #[doc = "Represents [`ParenExpr::span`]"]
        Span,
        #[doc = "Represents [`ParenExpr::expr`]"]
        Expr,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum PatField {
        #[doc = "Represents [`Pat::Ident`]"]
        Ident,
        #[doc = "Represents [`Pat::Array`]"]
        Array,
        #[doc = "Represents [`Pat::Rest`]"]
        Rest,
        #[doc = "Represents [`Pat::Object`]"]
        Object,
        #[doc = "Represents [`Pat::Assign`]"]
        Assign,
        #[doc = "Represents [`Pat::Invalid`]"]
        Invalid,
        #[doc = "Represents [`Pat::Expr`]"]
        Expr,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum PrivateNameField {
        #[doc = "Represents [`PrivateName::span`]"]
        Span,
        #[doc = "Represents [`PrivateName::name`]"]
        Name,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum PrivatePropField {
        #[doc = "Represents [`PrivateProp::span`]"]
        Span,
        #[doc = "Represents [`PrivateProp::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`PrivateProp::key`]"]
        Key,
        #[doc = "Represents [`PrivateProp::value`]"]
        Value,
        #[doc = "Represents [`PrivateProp::type_ann`]"]
        TypeAnn,
        #[doc = "Represents [`PrivateProp::is_static`]"]
        IsStatic,
        #[doc = "Represents [`PrivateProp::decorators`]"]
        Decorators(usize),
        #[doc = "Represents [`PrivateProp::accessibility`]"]
        Accessibility,
        #[doc = "Represents [`PrivateProp::is_optional`]"]
        IsOptional,
        #[doc = "Represents [`PrivateProp::is_override`]"]
        IsOverride,
        #[doc = "Represents [`PrivateProp::readonly`]"]
        Readonly,
        #[doc = "Represents [`PrivateProp::definite`]"]
        Definite,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ProgramField {
        #[doc = "Represents [`Program::Module`]"]
        Module,
        #[doc = "Represents [`Program::Script`]"]
        Script,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum PropField {
        #[doc = "Represents [`Prop::Shorthand`]"]
        Shorthand,
        #[doc = "Represents [`Prop::KeyValue`]"]
        KeyValue,
        #[doc = "Represents [`Prop::Assign`]"]
        Assign,
        #[doc = "Represents [`Prop::Getter`]"]
        Getter,
        #[doc = "Represents [`Prop::Setter`]"]
        Setter,
        #[doc = "Represents [`Prop::Method`]"]
        Method,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum PropNameField {
        #[doc = "Represents [`PropName::Ident`]"]
        Ident,
        #[doc = "Represents [`PropName::Str`]"]
        Str,
        #[doc = "Represents [`PropName::Num`]"]
        Num,
        #[doc = "Represents [`PropName::Computed`]"]
        Computed,
        #[doc = "Represents [`PropName::BigInt`]"]
        BigInt,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum PropOrSpreadField {
        #[doc = "Represents [`PropOrSpread::Spread`]"]
        Spread,
        #[doc = "Represents [`PropOrSpread::Prop`]"]
        Prop,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum RegexField {
        #[doc = "Represents [`Regex::span`]"]
        Span,
        #[doc = "Represents [`Regex::exp`]"]
        Exp,
        #[doc = "Represents [`Regex::flags`]"]
        Flags,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ReservedUnusedField {
        #[doc = "Represents [`ReservedUnused::span`]"]
        Span,
        #[doc = "Represents [`ReservedUnused::body`]"]
        Body,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum RestPatField {
        #[doc = "Represents [`RestPat::span`]"]
        Span,
        #[doc = "Represents [`RestPat::dot3_token`]"]
        Dot3Token,
        #[doc = "Represents [`RestPat::arg`]"]
        Arg,
        #[doc = "Represents [`RestPat::type_ann`]"]
        TypeAnn,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ReturnStmtField {
        #[doc = "Represents [`ReturnStmt::span`]"]
        Span,
        #[doc = "Represents [`ReturnStmt::arg`]"]
        Arg,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ScriptField {
        #[doc = "Represents [`Script::span`]"]
        Span,
        #[doc = "Represents [`Script::body`]"]
        Body(usize),
        #[doc = "Represents [`Script::shebang`]"]
        Shebang,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum SeqExprField {
        #[doc = "Represents [`SeqExpr::span`]"]
        Span,
        #[doc = "Represents [`SeqExpr::exprs`]"]
        Exprs(usize),
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum SetterPropField {
        #[doc = "Represents [`SetterProp::span`]"]
        Span,
        #[doc = "Represents [`SetterProp::key`]"]
        Key,
        #[doc = "Represents [`SetterProp::this_param`]"]
        ThisParam,
        #[doc = "Represents [`SetterProp::param`]"]
        Param,
        #[doc = "Represents [`SetterProp::body`]"]
        Body,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum SimpleAssignTargetField {
        #[doc = "Represents [`SimpleAssignTarget::Ident`]"]
        Ident,
        #[doc = "Represents [`SimpleAssignTarget::Member`]"]
        Member,
        #[doc = "Represents [`SimpleAssignTarget::SuperProp`]"]
        SuperProp,
        #[doc = "Represents [`SimpleAssignTarget::Paren`]"]
        Paren,
        #[doc = "Represents [`SimpleAssignTarget::OptChain`]"]
        OptChain,
        #[doc = "Represents [`SimpleAssignTarget::TsAs`]"]
        TsAs,
        #[doc = "Represents [`SimpleAssignTarget::TsSatisfies`]"]
        TsSatisfies,
        #[doc = "Represents [`SimpleAssignTarget::TsNonNull`]"]
        TsNonNull,
        #[doc = "Represents [`SimpleAssignTarget::TsTypeAssertion`]"]
        TsTypeAssertion,
        #[doc = "Represents [`SimpleAssignTarget::TsInstantiation`]"]
        TsInstantiation,
        #[doc = "Represents [`SimpleAssignTarget::Invalid`]"]
        Invalid,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum SpreadElementField {
        #[doc = "Represents [`SpreadElement::dot3_token`]"]
        Dot3Token,
        #[doc = "Represents [`SpreadElement::expr`]"]
        Expr,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum StaticBlockField {
        #[doc = "Represents [`StaticBlock::span`]"]
        Span,
        #[doc = "Represents [`StaticBlock::body`]"]
        Body,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum StmtField {
        #[doc = "Represents [`Stmt::Block`]"]
        Block,
        #[doc = "Represents [`Stmt::Empty`]"]
        Empty,
        #[doc = "Represents [`Stmt::Debugger`]"]
        Debugger,
        #[doc = "Represents [`Stmt::With`]"]
        With,
        #[doc = "Represents [`Stmt::Return`]"]
        Return,
        #[doc = "Represents [`Stmt::Labeled`]"]
        Labeled,
        #[doc = "Represents [`Stmt::Break`]"]
        Break,
        #[doc = "Represents [`Stmt::Continue`]"]
        Continue,
        #[doc = "Represents [`Stmt::If`]"]
        If,
        #[doc = "Represents [`Stmt::Switch`]"]
        Switch,
        #[doc = "Represents [`Stmt::Throw`]"]
        Throw,
        #[doc = "Represents [`Stmt::Try`]"]
        Try,
        #[doc = "Represents [`Stmt::While`]"]
        While,
        #[doc = "Represents [`Stmt::DoWhile`]"]
        DoWhile,
        #[doc = "Represents [`Stmt::For`]"]
        For,
        #[doc = "Represents [`Stmt::ForIn`]"]
        ForIn,
        #[doc = "Represents [`Stmt::ForOf`]"]
        ForOf,
        #[doc = "Represents [`Stmt::Decl`]"]
        Decl,
        #[doc = "Represents [`Stmt::Expr`]"]
        Expr,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum StrField {
        #[doc = "Represents [`Str::span`]"]
        Span,
        #[doc = "Represents [`Str::value`]"]
        Value,
        #[doc = "Represents [`Str::raw`]"]
        Raw,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum SuperField {
        #[doc = "Represents [`Super::span`]"]
        Span,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum SuperPropField {
        #[doc = "Represents [`SuperProp::Ident`]"]
        Ident,
        #[doc = "Represents [`SuperProp::Computed`]"]
        Computed,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum SuperPropExprField {
        #[doc = "Represents [`SuperPropExpr::span`]"]
        Span,
        #[doc = "Represents [`SuperPropExpr::obj`]"]
        Obj,
        #[doc = "Represents [`SuperPropExpr::prop`]"]
        Prop,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum SwitchCaseField {
        #[doc = "Represents [`SwitchCase::span`]"]
        Span,
        #[doc = "Represents [`SwitchCase::test`]"]
        Test,
        #[doc = "Represents [`SwitchCase::cons`]"]
        Cons(usize),
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum SwitchStmtField {
        #[doc = "Represents [`SwitchStmt::span`]"]
        Span,
        #[doc = "Represents [`SwitchStmt::discriminant`]"]
        Discriminant,
        #[doc = "Represents [`SwitchStmt::cases`]"]
        Cases(usize),
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TaggedTplField {
        #[doc = "Represents [`TaggedTpl::span`]"]
        Span,
        #[doc = "Represents [`TaggedTpl::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`TaggedTpl::tag`]"]
        Tag,
        #[doc = "Represents [`TaggedTpl::type_params`]"]
        TypeParams,
        #[doc = "Represents [`TaggedTpl::tpl`]"]
        Tpl,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ThisExprField {
        #[doc = "Represents [`ThisExpr::span`]"]
        Span,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum ThrowStmtField {
        #[doc = "Represents [`ThrowStmt::span`]"]
        Span,
        #[doc = "Represents [`ThrowStmt::arg`]"]
        Arg,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TplField {
        #[doc = "Represents [`Tpl::span`]"]
        Span,
        #[doc = "Represents [`Tpl::exprs`]"]
        Exprs(usize),
        #[doc = "Represents [`Tpl::quasis`]"]
        Quasis(usize),
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TplElementField {
        #[doc = "Represents [`TplElement::span`]"]
        Span,
        #[doc = "Represents [`TplElement::tail`]"]
        Tail,
        #[doc = "Represents [`TplElement::cooked`]"]
        Cooked,
        #[doc = "Represents [`TplElement::raw`]"]
        Raw,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TruePlusMinusField {
        #[doc = "Represents [`TruePlusMinus::True`]"]
        True,
        #[doc = "Represents [`TruePlusMinus::Plus`]"]
        Plus,
        #[doc = "Represents [`TruePlusMinus::Minus`]"]
        Minus,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TryStmtField {
        #[doc = "Represents [`TryStmt::span`]"]
        Span,
        #[doc = "Represents [`TryStmt::block`]"]
        Block,
        #[doc = "Represents [`TryStmt::handler`]"]
        Handler,
        #[doc = "Represents [`TryStmt::finalizer`]"]
        Finalizer,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsArrayTypeField {
        #[doc = "Represents [`TsArrayType::span`]"]
        Span,
        #[doc = "Represents [`TsArrayType::elem_type`]"]
        ElemType,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsAsExprField {
        #[doc = "Represents [`TsAsExpr::span`]"]
        Span,
        #[doc = "Represents [`TsAsExpr::expr`]"]
        Expr,
        #[doc = "Represents [`TsAsExpr::type_ann`]"]
        TypeAnn,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsCallSignatureDeclField {
        #[doc = "Represents [`TsCallSignatureDecl::span`]"]
        Span,
        #[doc = "Represents [`TsCallSignatureDecl::params`]"]
        Params(usize),
        #[doc = "Represents [`TsCallSignatureDecl::type_ann`]"]
        TypeAnn,
        #[doc = "Represents [`TsCallSignatureDecl::type_params`]"]
        TypeParams,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsConditionalTypeField {
        #[doc = "Represents [`TsConditionalType::span`]"]
        Span,
        #[doc = "Represents [`TsConditionalType::check_type`]"]
        CheckType,
        #[doc = "Represents [`TsConditionalType::extends_type`]"]
        ExtendsType,
        #[doc = "Represents [`TsConditionalType::true_type`]"]
        TrueType,
        #[doc = "Represents [`TsConditionalType::false_type`]"]
        FalseType,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsConstAssertionField {
        #[doc = "Represents [`TsConstAssertion::span`]"]
        Span,
        #[doc = "Represents [`TsConstAssertion::expr`]"]
        Expr,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsConstructSignatureDeclField {
        #[doc = "Represents [`TsConstructSignatureDecl::span`]"]
        Span,
        #[doc = "Represents [`TsConstructSignatureDecl::params`]"]
        Params(usize),
        #[doc = "Represents [`TsConstructSignatureDecl::type_ann`]"]
        TypeAnn,
        #[doc = "Represents [`TsConstructSignatureDecl::type_params`]"]
        TypeParams,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsConstructorTypeField {
        #[doc = "Represents [`TsConstructorType::span`]"]
        Span,
        #[doc = "Represents [`TsConstructorType::params`]"]
        Params(usize),
        #[doc = "Represents [`TsConstructorType::type_params`]"]
        TypeParams,
        #[doc = "Represents [`TsConstructorType::type_ann`]"]
        TypeAnn,
        #[doc = "Represents [`TsConstructorType::is_abstract`]"]
        IsAbstract,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsEntityNameField {
        #[doc = "Represents [`TsEntityName::TsQualifiedName`]"]
        TsQualifiedName,
        #[doc = "Represents [`TsEntityName::Ident`]"]
        Ident,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsEnumDeclField {
        #[doc = "Represents [`TsEnumDecl::span`]"]
        Span,
        #[doc = "Represents [`TsEnumDecl::declare`]"]
        Declare,
        #[doc = "Represents [`TsEnumDecl::is_const`]"]
        IsConst,
        #[doc = "Represents [`TsEnumDecl::id`]"]
        Id,
        #[doc = "Represents [`TsEnumDecl::members`]"]
        Members(usize),
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsEnumMemberField {
        #[doc = "Represents [`TsEnumMember::span`]"]
        Span,
        #[doc = "Represents [`TsEnumMember::id`]"]
        Id,
        #[doc = "Represents [`TsEnumMember::init`]"]
        Init,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsEnumMemberIdField {
        #[doc = "Represents [`TsEnumMemberId::Ident`]"]
        Ident,
        #[doc = "Represents [`TsEnumMemberId::Str`]"]
        Str,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsExportAssignmentField {
        #[doc = "Represents [`TsExportAssignment::span`]"]
        Span,
        #[doc = "Represents [`TsExportAssignment::expr`]"]
        Expr,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsExprWithTypeArgsField {
        #[doc = "Represents [`TsExprWithTypeArgs::span`]"]
        Span,
        #[doc = "Represents [`TsExprWithTypeArgs::expr`]"]
        Expr,
        #[doc = "Represents [`TsExprWithTypeArgs::type_args`]"]
        TypeArgs,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsExternalModuleRefField {
        #[doc = "Represents [`TsExternalModuleRef::span`]"]
        Span,
        #[doc = "Represents [`TsExternalModuleRef::expr`]"]
        Expr,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsFnOrConstructorTypeField {
        #[doc = "Represents [`TsFnOrConstructorType::TsFnType`]"]
        TsFnType,
        #[doc = "Represents [`TsFnOrConstructorType::TsConstructorType`]"]
        TsConstructorType,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsFnParamField {
        #[doc = "Represents [`TsFnParam::Ident`]"]
        Ident,
        #[doc = "Represents [`TsFnParam::Array`]"]
        Array,
        #[doc = "Represents [`TsFnParam::Rest`]"]
        Rest,
        #[doc = "Represents [`TsFnParam::Object`]"]
        Object,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsFnTypeField {
        #[doc = "Represents [`TsFnType::span`]"]
        Span,
        #[doc = "Represents [`TsFnType::params`]"]
        Params(usize),
        #[doc = "Represents [`TsFnType::type_params`]"]
        TypeParams,
        #[doc = "Represents [`TsFnType::type_ann`]"]
        TypeAnn,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsGetterSignatureField {
        #[doc = "Represents [`TsGetterSignature::span`]"]
        Span,
        #[doc = "Represents [`TsGetterSignature::key`]"]
        Key,
        #[doc = "Represents [`TsGetterSignature::computed`]"]
        Computed,
        #[doc = "Represents [`TsGetterSignature::type_ann`]"]
        TypeAnn,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsImportEqualsDeclField {
        #[doc = "Represents [`TsImportEqualsDecl::span`]"]
        Span,
        #[doc = "Represents [`TsImportEqualsDecl::is_export`]"]
        IsExport,
        #[doc = "Represents [`TsImportEqualsDecl::is_type_only`]"]
        IsTypeOnly,
        #[doc = "Represents [`TsImportEqualsDecl::id`]"]
        Id,
        #[doc = "Represents [`TsImportEqualsDecl::module_ref`]"]
        ModuleRef,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsImportTypeField {
        #[doc = "Represents [`TsImportType::span`]"]
        Span,
        #[doc = "Represents [`TsImportType::arg`]"]
        Arg,
        #[doc = "Represents [`TsImportType::qualifier`]"]
        Qualifier,
        #[doc = "Represents [`TsImportType::type_args`]"]
        TypeArgs,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsIndexSignatureField {
        #[doc = "Represents [`TsIndexSignature::params`]"]
        Params(usize),
        #[doc = "Represents [`TsIndexSignature::type_ann`]"]
        TypeAnn,
        #[doc = "Represents [`TsIndexSignature::readonly`]"]
        Readonly,
        #[doc = "Represents [`TsIndexSignature::is_static`]"]
        IsStatic,
        #[doc = "Represents [`TsIndexSignature::span`]"]
        Span,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsIndexedAccessTypeField {
        #[doc = "Represents [`TsIndexedAccessType::span`]"]
        Span,
        #[doc = "Represents [`TsIndexedAccessType::readonly`]"]
        Readonly,
        #[doc = "Represents [`TsIndexedAccessType::obj_type`]"]
        ObjType,
        #[doc = "Represents [`TsIndexedAccessType::index_type`]"]
        IndexType,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsInferTypeField {
        #[doc = "Represents [`TsInferType::span`]"]
        Span,
        #[doc = "Represents [`TsInferType::type_param`]"]
        TypeParam,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsInstantiationField {
        #[doc = "Represents [`TsInstantiation::span`]"]
        Span,
        #[doc = "Represents [`TsInstantiation::expr`]"]
        Expr,
        #[doc = "Represents [`TsInstantiation::type_args`]"]
        TypeArgs,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsInterfaceBodyField {
        #[doc = "Represents [`TsInterfaceBody::span`]"]
        Span,
        #[doc = "Represents [`TsInterfaceBody::body`]"]
        Body(usize),
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsInterfaceDeclField {
        #[doc = "Represents [`TsInterfaceDecl::span`]"]
        Span,
        #[doc = "Represents [`TsInterfaceDecl::id`]"]
        Id,
        #[doc = "Represents [`TsInterfaceDecl::declare`]"]
        Declare,
        #[doc = "Represents [`TsInterfaceDecl::type_params`]"]
        TypeParams,
        #[doc = "Represents [`TsInterfaceDecl::extends`]"]
        Extends(usize),
        #[doc = "Represents [`TsInterfaceDecl::body`]"]
        Body,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsIntersectionTypeField {
        #[doc = "Represents [`TsIntersectionType::span`]"]
        Span,
        #[doc = "Represents [`TsIntersectionType::types`]"]
        Types(usize),
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsKeywordTypeField {
        #[doc = "Represents [`TsKeywordType::span`]"]
        Span,
        #[doc = "Represents [`TsKeywordType::kind`]"]
        Kind,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsKeywordTypeKindField {
        #[doc = "Represents [`TsKeywordTypeKind::TsAnyKeyword`]"]
        TsAnyKeyword,
        #[doc = "Represents [`TsKeywordTypeKind::TsUnknownKeyword`]"]
        TsUnknownKeyword,
        #[doc = "Represents [`TsKeywordTypeKind::TsNumberKeyword`]"]
        TsNumberKeyword,
        #[doc = "Represents [`TsKeywordTypeKind::TsObjectKeyword`]"]
        TsObjectKeyword,
        #[doc = "Represents [`TsKeywordTypeKind::TsBooleanKeyword`]"]
        TsBooleanKeyword,
        #[doc = "Represents [`TsKeywordTypeKind::TsBigIntKeyword`]"]
        TsBigIntKeyword,
        #[doc = "Represents [`TsKeywordTypeKind::TsStringKeyword`]"]
        TsStringKeyword,
        #[doc = "Represents [`TsKeywordTypeKind::TsSymbolKeyword`]"]
        TsSymbolKeyword,
        #[doc = "Represents [`TsKeywordTypeKind::TsVoidKeyword`]"]
        TsVoidKeyword,
        #[doc = "Represents [`TsKeywordTypeKind::TsUndefinedKeyword`]"]
        TsUndefinedKeyword,
        #[doc = "Represents [`TsKeywordTypeKind::TsNullKeyword`]"]
        TsNullKeyword,
        #[doc = "Represents [`TsKeywordTypeKind::TsNeverKeyword`]"]
        TsNeverKeyword,
        #[doc = "Represents [`TsKeywordTypeKind::TsIntrinsicKeyword`]"]
        TsIntrinsicKeyword,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsLitField {
        #[doc = "Represents [`TsLit::Number`]"]
        Number,
        #[doc = "Represents [`TsLit::Str`]"]
        Str,
        #[doc = "Represents [`TsLit::Bool`]"]
        Bool,
        #[doc = "Represents [`TsLit::BigInt`]"]
        BigInt,
        #[doc = "Represents [`TsLit::Tpl`]"]
        Tpl,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsLitTypeField {
        #[doc = "Represents [`TsLitType::span`]"]
        Span,
        #[doc = "Represents [`TsLitType::lit`]"]
        Lit,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsMappedTypeField {
        #[doc = "Represents [`TsMappedType::span`]"]
        Span,
        #[doc = "Represents [`TsMappedType::readonly`]"]
        Readonly,
        #[doc = "Represents [`TsMappedType::type_param`]"]
        TypeParam,
        #[doc = "Represents [`TsMappedType::name_type`]"]
        NameType,
        #[doc = "Represents [`TsMappedType::optional`]"]
        Optional,
        #[doc = "Represents [`TsMappedType::type_ann`]"]
        TypeAnn,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsMethodSignatureField {
        #[doc = "Represents [`TsMethodSignature::span`]"]
        Span,
        #[doc = "Represents [`TsMethodSignature::key`]"]
        Key,
        #[doc = "Represents [`TsMethodSignature::computed`]"]
        Computed,
        #[doc = "Represents [`TsMethodSignature::optional`]"]
        Optional,
        #[doc = "Represents [`TsMethodSignature::params`]"]
        Params(usize),
        #[doc = "Represents [`TsMethodSignature::type_ann`]"]
        TypeAnn,
        #[doc = "Represents [`TsMethodSignature::type_params`]"]
        TypeParams,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsModuleBlockField {
        #[doc = "Represents [`TsModuleBlock::span`]"]
        Span,
        #[doc = "Represents [`TsModuleBlock::body`]"]
        Body(usize),
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsModuleDeclField {
        #[doc = "Represents [`TsModuleDecl::span`]"]
        Span,
        #[doc = "Represents [`TsModuleDecl::declare`]"]
        Declare,
        #[doc = "Represents [`TsModuleDecl::global`]"]
        Global,
        #[doc = "Represents [`TsModuleDecl::id`]"]
        Id,
        #[doc = "Represents [`TsModuleDecl::body`]"]
        Body,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsModuleNameField {
        #[doc = "Represents [`TsModuleName::Ident`]"]
        Ident,
        #[doc = "Represents [`TsModuleName::Str`]"]
        Str,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsModuleRefField {
        #[doc = "Represents [`TsModuleRef::TsEntityName`]"]
        TsEntityName,
        #[doc = "Represents [`TsModuleRef::TsExternalModuleRef`]"]
        TsExternalModuleRef,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsNamespaceBodyField {
        #[doc = "Represents [`TsNamespaceBody::TsModuleBlock`]"]
        TsModuleBlock,
        #[doc = "Represents [`TsNamespaceBody::TsNamespaceDecl`]"]
        TsNamespaceDecl,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsNamespaceDeclField {
        #[doc = "Represents [`TsNamespaceDecl::span`]"]
        Span,
        #[doc = "Represents [`TsNamespaceDecl::declare`]"]
        Declare,
        #[doc = "Represents [`TsNamespaceDecl::global`]"]
        Global,
        #[doc = "Represents [`TsNamespaceDecl::id`]"]
        Id,
        #[doc = "Represents [`TsNamespaceDecl::body`]"]
        Body,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsNamespaceExportDeclField {
        #[doc = "Represents [`TsNamespaceExportDecl::span`]"]
        Span,
        #[doc = "Represents [`TsNamespaceExportDecl::id`]"]
        Id,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsNonNullExprField {
        #[doc = "Represents [`TsNonNullExpr::span`]"]
        Span,
        #[doc = "Represents [`TsNonNullExpr::expr`]"]
        Expr,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsOptionalTypeField {
        #[doc = "Represents [`TsOptionalType::span`]"]
        Span,
        #[doc = "Represents [`TsOptionalType::type_ann`]"]
        TypeAnn,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsParamPropField {
        #[doc = "Represents [`TsParamProp::span`]"]
        Span,
        #[doc = "Represents [`TsParamProp::decorators`]"]
        Decorators(usize),
        #[doc = "Represents [`TsParamProp::accessibility`]"]
        Accessibility,
        #[doc = "Represents [`TsParamProp::is_override`]"]
        IsOverride,
        #[doc = "Represents [`TsParamProp::readonly`]"]
        Readonly,
        #[doc = "Represents [`TsParamProp::param`]"]
        Param,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsParamPropParamField {
        #[doc = "Represents [`TsParamPropParam::Ident`]"]
        Ident,
        #[doc = "Represents [`TsParamPropParam::Assign`]"]
        Assign,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsParenthesizedTypeField {
        #[doc = "Represents [`TsParenthesizedType::span`]"]
        Span,
        #[doc = "Represents [`TsParenthesizedType::type_ann`]"]
        TypeAnn,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsPropertySignatureField {
        #[doc = "Represents [`TsPropertySignature::span`]"]
        Span,
        #[doc = "Represents [`TsPropertySignature::readonly`]"]
        Readonly,
        #[doc = "Represents [`TsPropertySignature::key`]"]
        Key,
        #[doc = "Represents [`TsPropertySignature::computed`]"]
        Computed,
        #[doc = "Represents [`TsPropertySignature::optional`]"]
        Optional,
        #[doc = "Represents [`TsPropertySignature::type_ann`]"]
        TypeAnn,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsQualifiedNameField {
        #[doc = "Represents [`TsQualifiedName::span`]"]
        Span,
        #[doc = "Represents [`TsQualifiedName::left`]"]
        Left,
        #[doc = "Represents [`TsQualifiedName::right`]"]
        Right,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsRestTypeField {
        #[doc = "Represents [`TsRestType::span`]"]
        Span,
        #[doc = "Represents [`TsRestType::type_ann`]"]
        TypeAnn,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsSatisfiesExprField {
        #[doc = "Represents [`TsSatisfiesExpr::span`]"]
        Span,
        #[doc = "Represents [`TsSatisfiesExpr::expr`]"]
        Expr,
        #[doc = "Represents [`TsSatisfiesExpr::type_ann`]"]
        TypeAnn,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsSetterSignatureField {
        #[doc = "Represents [`TsSetterSignature::span`]"]
        Span,
        #[doc = "Represents [`TsSetterSignature::key`]"]
        Key,
        #[doc = "Represents [`TsSetterSignature::computed`]"]
        Computed,
        #[doc = "Represents [`TsSetterSignature::param`]"]
        Param,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsThisTypeField {
        #[doc = "Represents [`TsThisType::span`]"]
        Span,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsThisTypeOrIdentField {
        #[doc = "Represents [`TsThisTypeOrIdent::TsThisType`]"]
        TsThisType,
        #[doc = "Represents [`TsThisTypeOrIdent::Ident`]"]
        Ident,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsTplLitTypeField {
        #[doc = "Represents [`TsTplLitType::span`]"]
        Span,
        #[doc = "Represents [`TsTplLitType::types`]"]
        Types(usize),
        #[doc = "Represents [`TsTplLitType::quasis`]"]
        Quasis(usize),
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsTupleElementField {
        #[doc = "Represents [`TsTupleElement::span`]"]
        Span,
        #[doc = "Represents [`TsTupleElement::label`]"]
        Label,
        #[doc = "Represents [`TsTupleElement::ty`]"]
        Ty,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsTupleTypeField {
        #[doc = "Represents [`TsTupleType::span`]"]
        Span,
        #[doc = "Represents [`TsTupleType::elem_types`]"]
        ElemTypes(usize),
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsTypeField {
        #[doc = "Represents [`TsType::TsKeywordType`]"]
        TsKeywordType,
        #[doc = "Represents [`TsType::TsThisType`]"]
        TsThisType,
        #[doc = "Represents [`TsType::TsFnOrConstructorType`]"]
        TsFnOrConstructorType,
        #[doc = "Represents [`TsType::TsTypeRef`]"]
        TsTypeRef,
        #[doc = "Represents [`TsType::TsTypeQuery`]"]
        TsTypeQuery,
        #[doc = "Represents [`TsType::TsTypeLit`]"]
        TsTypeLit,
        #[doc = "Represents [`TsType::TsArrayType`]"]
        TsArrayType,
        #[doc = "Represents [`TsType::TsTupleType`]"]
        TsTupleType,
        #[doc = "Represents [`TsType::TsOptionalType`]"]
        TsOptionalType,
        #[doc = "Represents [`TsType::TsRestType`]"]
        TsRestType,
        #[doc = "Represents [`TsType::TsUnionOrIntersectionType`]"]
        TsUnionOrIntersectionType,
        #[doc = "Represents [`TsType::TsConditionalType`]"]
        TsConditionalType,
        #[doc = "Represents [`TsType::TsInferType`]"]
        TsInferType,
        #[doc = "Represents [`TsType::TsParenthesizedType`]"]
        TsParenthesizedType,
        #[doc = "Represents [`TsType::TsTypeOperator`]"]
        TsTypeOperator,
        #[doc = "Represents [`TsType::TsIndexedAccessType`]"]
        TsIndexedAccessType,
        #[doc = "Represents [`TsType::TsMappedType`]"]
        TsMappedType,
        #[doc = "Represents [`TsType::TsLitType`]"]
        TsLitType,
        #[doc = "Represents [`TsType::TsTypePredicate`]"]
        TsTypePredicate,
        #[doc = "Represents [`TsType::TsImportType`]"]
        TsImportType,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsTypeAliasDeclField {
        #[doc = "Represents [`TsTypeAliasDecl::span`]"]
        Span,
        #[doc = "Represents [`TsTypeAliasDecl::declare`]"]
        Declare,
        #[doc = "Represents [`TsTypeAliasDecl::id`]"]
        Id,
        #[doc = "Represents [`TsTypeAliasDecl::type_params`]"]
        TypeParams,
        #[doc = "Represents [`TsTypeAliasDecl::type_ann`]"]
        TypeAnn,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsTypeAnnField {
        #[doc = "Represents [`TsTypeAnn::span`]"]
        Span,
        #[doc = "Represents [`TsTypeAnn::type_ann`]"]
        TypeAnn,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsTypeAssertionField {
        #[doc = "Represents [`TsTypeAssertion::span`]"]
        Span,
        #[doc = "Represents [`TsTypeAssertion::expr`]"]
        Expr,
        #[doc = "Represents [`TsTypeAssertion::type_ann`]"]
        TypeAnn,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsTypeElementField {
        #[doc = "Represents [`TsTypeElement::TsCallSignatureDecl`]"]
        TsCallSignatureDecl,
        #[doc = "Represents [`TsTypeElement::TsConstructSignatureDecl`]"]
        TsConstructSignatureDecl,
        #[doc = "Represents [`TsTypeElement::TsPropertySignature`]"]
        TsPropertySignature,
        #[doc = "Represents [`TsTypeElement::TsGetterSignature`]"]
        TsGetterSignature,
        #[doc = "Represents [`TsTypeElement::TsSetterSignature`]"]
        TsSetterSignature,
        #[doc = "Represents [`TsTypeElement::TsMethodSignature`]"]
        TsMethodSignature,
        #[doc = "Represents [`TsTypeElement::TsIndexSignature`]"]
        TsIndexSignature,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsTypeLitField {
        #[doc = "Represents [`TsTypeLit::span`]"]
        Span,
        #[doc = "Represents [`TsTypeLit::members`]"]
        Members(usize),
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsTypeOperatorField {
        #[doc = "Represents [`TsTypeOperator::span`]"]
        Span,
        #[doc = "Represents [`TsTypeOperator::op`]"]
        Op,
        #[doc = "Represents [`TsTypeOperator::type_ann`]"]
        TypeAnn,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsTypeOperatorOpField {
        #[doc = "Represents [`TsTypeOperatorOp::KeyOf`]"]
        KeyOf,
        #[doc = "Represents [`TsTypeOperatorOp::Unique`]"]
        Unique,
        #[doc = "Represents [`TsTypeOperatorOp::ReadOnly`]"]
        ReadOnly,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsTypeParamField {
        #[doc = "Represents [`TsTypeParam::span`]"]
        Span,
        #[doc = "Represents [`TsTypeParam::name`]"]
        Name,
        #[doc = "Represents [`TsTypeParam::is_in`]"]
        IsIn,
        #[doc = "Represents [`TsTypeParam::is_out`]"]
        IsOut,
        #[doc = "Represents [`TsTypeParam::is_const`]"]
        IsConst,
        #[doc = "Represents [`TsTypeParam::constraint`]"]
        Constraint,
        #[doc = "Represents [`TsTypeParam::default`]"]
        Default,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsTypeParamDeclField {
        #[doc = "Represents [`TsTypeParamDecl::span`]"]
        Span,
        #[doc = "Represents [`TsTypeParamDecl::params`]"]
        Params(usize),
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsTypeParamInstantiationField {
        #[doc = "Represents [`TsTypeParamInstantiation::span`]"]
        Span,
        #[doc = "Represents [`TsTypeParamInstantiation::params`]"]
        Params(usize),
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsTypePredicateField {
        #[doc = "Represents [`TsTypePredicate::span`]"]
        Span,
        #[doc = "Represents [`TsTypePredicate::asserts`]"]
        Asserts,
        #[doc = "Represents [`TsTypePredicate::param_name`]"]
        ParamName,
        #[doc = "Represents [`TsTypePredicate::type_ann`]"]
        TypeAnn,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsTypeQueryField {
        #[doc = "Represents [`TsTypeQuery::span`]"]
        Span,
        #[doc = "Represents [`TsTypeQuery::expr_name`]"]
        ExprName,
        #[doc = "Represents [`TsTypeQuery::type_args`]"]
        TypeArgs,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsTypeQueryExprField {
        #[doc = "Represents [`TsTypeQueryExpr::TsEntityName`]"]
        TsEntityName,
        #[doc = "Represents [`TsTypeQueryExpr::Import`]"]
        Import,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsTypeRefField {
        #[doc = "Represents [`TsTypeRef::span`]"]
        Span,
        #[doc = "Represents [`TsTypeRef::type_name`]"]
        TypeName,
        #[doc = "Represents [`TsTypeRef::type_params`]"]
        TypeParams,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsUnionOrIntersectionTypeField {
        #[doc = "Represents [`TsUnionOrIntersectionType::TsUnionType`]"]
        TsUnionType,
        #[doc = "Represents [`TsUnionOrIntersectionType::TsIntersectionType`]"]
        TsIntersectionType,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum TsUnionTypeField {
        #[doc = "Represents [`TsUnionType::span`]"]
        Span,
        #[doc = "Represents [`TsUnionType::types`]"]
        Types(usize),
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum UnaryExprField {
        #[doc = "Represents [`UnaryExpr::span`]"]
        Span,
        #[doc = "Represents [`UnaryExpr::op`]"]
        Op,
        #[doc = "Represents [`UnaryExpr::arg`]"]
        Arg,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum UnaryOpField {
        #[doc = "Represents [`UnaryOp::Minus`]"]
        Minus,
        #[doc = "Represents [`UnaryOp::Plus`]"]
        Plus,
        #[doc = "Represents [`UnaryOp::Bang`]"]
        Bang,
        #[doc = "Represents [`UnaryOp::Tilde`]"]
        Tilde,
        #[doc = "Represents [`UnaryOp::TypeOf`]"]
        TypeOf,
        #[doc = "Represents [`UnaryOp::Void`]"]
        Void,
        #[doc = "Represents [`UnaryOp::Delete`]"]
        Delete,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum UpdateExprField {
        #[doc = "Represents [`UpdateExpr::span`]"]
        Span,
        #[doc = "Represents [`UpdateExpr::op`]"]
        Op,
        #[doc = "Represents [`UpdateExpr::prefix`]"]
        Prefix,
        #[doc = "Represents [`UpdateExpr::arg`]"]
        Arg,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum UpdateOpField {
        #[doc = "Represents [`UpdateOp::PlusPlus`]"]
        PlusPlus,
        #[doc = "Represents [`UpdateOp::MinusMinus`]"]
        MinusMinus,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum UsingDeclField {
        #[doc = "Represents [`UsingDecl::span`]"]
        Span,
        #[doc = "Represents [`UsingDecl::is_await`]"]
        IsAwait,
        #[doc = "Represents [`UsingDecl::decls`]"]
        Decls(usize),
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum VarDeclField {
        #[doc = "Represents [`VarDecl::span`]"]
        Span,
        #[doc = "Represents [`VarDecl::ctxt`]"]
        Ctxt,
        #[doc = "Represents [`VarDecl::kind`]"]
        Kind,
        #[doc = "Represents [`VarDecl::declare`]"]
        Declare,
        #[doc = "Represents [`VarDecl::decls`]"]
        Decls(usize),
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum VarDeclKindField {
        #[doc = "Represents [`VarDeclKind::Var`]"]
        Var,
        #[doc = "Represents [`VarDeclKind::Let`]"]
        Let,
        #[doc = "Represents [`VarDeclKind::Const`]"]
        Const,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum VarDeclOrExprField {
        #[doc = "Represents [`VarDeclOrExpr::VarDecl`]"]
        VarDecl,
        #[doc = "Represents [`VarDeclOrExpr::Expr`]"]
        Expr,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum VarDeclaratorField {
        #[doc = "Represents [`VarDeclarator::span`]"]
        Span,
        #[doc = "Represents [`VarDeclarator::name`]"]
        Name,
        #[doc = "Represents [`VarDeclarator::init`]"]
        Init,
        #[doc = "Represents [`VarDeclarator::definite`]"]
        Definite,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum WhileStmtField {
        #[doc = "Represents [`WhileStmt::span`]"]
        Span,
        #[doc = "Represents [`WhileStmt::test`]"]
        Test,
        #[doc = "Represents [`WhileStmt::body`]"]
        Body,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum WithStmtField {
        #[doc = "Represents [`WithStmt::span`]"]
        Span,
        #[doc = "Represents [`WithStmt::obj`]"]
        Obj,
        #[doc = "Represents [`WithStmt::body`]"]
        Body,
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub enum YieldExprField {
        #[doc = "Represents [`YieldExpr::span`]"]
        Span,
        #[doc = "Represents [`YieldExpr::arg`]"]
        Arg,
        #[doc = "Represents [`YieldExpr::delegate`]"]
        Delegate,
    }
}
