/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */
function EventDispatcher() {
}
Object.assign(EventDispatcher.prototype, {
    addEventListener: function(type, listener) {
        if (this._listeners === undefined) this._listeners = {
        };
        const listeners = this._listeners;
        if (listeners[type] === undefined) listeners[type] = [];
        if (listeners[type].indexOf(listener) === -1) listeners[type].push(listener);
    },
    hasEventListener: function(type, listener) {
        if (this._listeners === undefined) return false;
        const listeners = this._listeners;
        return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
    },
    removeEventListener: function(type, listener) {
        if (this._listeners === undefined) return;
        const listeners = this._listeners;
        const listenerArray = listeners[type];
        if (listenerArray !== undefined) {
            const index = listenerArray.indexOf(listener);
            if (index !== -1) listenerArray.splice(index, 1);
        }
    },
    dispatchEvent: function(event) {
        if (this._listeners === undefined) return;
        const listeners = this._listeners;
        const listenerArray = listeners[event.type];
        if (listenerArray !== undefined) {
            event.target = this;
            // Make a copy, in case listeners are removed while iterating.
            const array = listenerArray.slice(0);
            for(let i = 0, l = array.length; i < l; i++)array[i].call(this, event);
        }
    }
});
const EventDispatcher1 = EventDispatcher;
class Vector4 {
    get width() {
        return this.z;
    }
    set width(value) {
        this.z = value;
    }
    get height() {
        return this.w;
    }
    set height(value) {
        this.w = value;
    }
    set(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        this.w = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setZ(z) {
        this.z = z;
        return this;
    }
    setW(w) {
        this.w = w;
        return this;
    }
    setComponent(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            case 3:
                this.w = value;
                break;
            default:
                throw new Error('index is out of range: ' + index);
        }
        return this;
    }
    getComponent(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error('index is out of range: ' + index);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w !== undefined ? v.w : 1;
        return this;
    }
    add(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;
        return this;
    }
    sub(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
    }
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
    }
    applyMatrix4(m) {
        const x = this.x, y = this.y, z = this.z, w = this.w;
        const e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
        return this;
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
    }
    setAxisAngleFromQuaternion(q) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
        // q is assumed to be normalized
        this.w = 2 * Math.acos(q.w);
        const s = Math.sqrt(1 - q.w * q.w);
        if (s < 0.0001) {
            this.x = 1;
            this.y = 0;
            this.z = 0;
        } else {
            this.x = q.x / s;
            this.y = q.y / s;
            this.z = q.z / s;
        }
        return this;
    }
    setAxisAngleFromRotationMatrix(m) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        let angle, x, y, z; // variables for result
        const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
            // singularity found
            // first check for identity matrix which must have +1 for all terms
            // in leading diagonal and zero in other terms
            if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
                // this singularity is identity matrix so angle = 0
                this.set(1, 0, 0, 0);
                return this; // zero angle, arbitrary axis
            }
            // otherwise this singularity is angle = 180
            angle = Math.PI;
            const xx = (m11 + 1) / 2;
            const yy = (m22 + 1) / 2;
            const zz = (m33 + 1) / 2;
            const xy = (m12 + m21) / 4;
            const xz = (m13 + m31) / 4;
            const yz = (m23 + m32) / 4;
            if (xx > yy && xx > zz) {
                // m11 is the largest diagonal term
                if (xx < epsilon) {
                    x = 0;
                    y = 0.707106781;
                    z = 0.707106781;
                } else {
                    x = Math.sqrt(xx);
                    y = xy / x;
                    z = xz / x;
                }
            } else if (yy > zz) {
                // m22 is the largest diagonal term
                if (yy < epsilon) {
                    x = 0.707106781;
                    y = 0;
                    z = 0.707106781;
                } else {
                    y = Math.sqrt(yy);
                    x = xy / y;
                    z = yz / y;
                }
            } else // m33 is the largest diagonal term so base result on this
            if (zz < epsilon) {
                x = 0.707106781;
                y = 0.707106781;
                z = 0;
            } else {
                z = Math.sqrt(zz);
                x = xz / z;
                y = yz / z;
            }
            this.set(x, y, z, angle);
            return this; // return 180 deg rotation
        }
        // as we have reached here there are no singularities so we can handle normally
        let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize
        if (Math.abs(s) < 0.001) s = 1;
        // prevent divide by zero, should not happen if matrix is orthogonal and should be
        // caught by singularity test above, but I've left it in just in case
        this.x = (m32 - m23) / s;
        this.y = (m13 - m31) / s;
        this.z = (m21 - m12) / s;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        this.w = Math.min(this.w, v.w);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        this.w = Math.max(this.w, v.w);
        return this;
    }
    clamp(min, max) {
        // assumes min < max, componentwise
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        this.w = Math.max(min.w, Math.min(max.w, this.w));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        this.w = Math.max(minVal, Math.min(maxVal, this.w));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
    }
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        this.w = v1.w + (v2.w - v1.w) * alpha;
        return this;
    }
    equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    }
    fromArray(array, offset) {
        if (offset === undefined) offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
    }
    toArray(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        this.w = attribute.getW(index);
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        this.w = Math.random();
        return this;
    }
    constructor(x1 = 0, y1 = 0, z1 = 0, w1 = 1){
        this.x = x1;
        this.y = y1;
        this.z = z1;
        this.w = w1;
    }
}
Vector4.prototype.isVector4 = true;
const Vector41 = Vector4;
/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
function WebGLRenderTarget(width, height, options) {
    this.width = width;
    this.height = height;
    this.scissor = new Vector41(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector41(0, 0, width, height);
    options = options || {
    };
    this.texture = new Texture1(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.image = {
    };
    this.texture.image.width = width;
    this.texture.image.height = height;
    this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
    this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
}
WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher1.prototype), {
    constructor: WebGLRenderTarget,
    isWebGLRenderTarget: true,
    setSize: function(width, height) {
        if (this.width !== width || this.height !== height) {
            this.width = width;
            this.height = height;
            this.texture.image.width = width;
            this.texture.image.height = height;
            this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.width = source.width;
        this.height = source.height;
        this.viewport.copy(source.viewport);
        this.texture = source.texture.clone();
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.depthTexture = source.depthTexture;
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
});
const WebGLRenderTarget1 = WebGLRenderTarget;
function WebGLMultisampleRenderTarget(width, height, options) {
    WebGLRenderTarget1.call(this, width, height, options);
    this.samples = 4;
}
WebGLMultisampleRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget1.prototype), {
    constructor: WebGLMultisampleRenderTarget,
    isWebGLMultisampleRenderTarget: true,
    copy: function(source) {
        WebGLRenderTarget1.prototype.copy.call(this, source);
        this.samples = source.samples;
        return this;
    }
});
const WebGLMultisampleRenderTarget1 = WebGLMultisampleRenderTarget;
export { WebGLMultisampleRenderTarget1 as WebGLMultisampleRenderTarget };
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const FlatShading = 1;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;
const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const CubeUVRefractionMapping = 307;
const RepeatWrapping = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedShort565Type = 1019;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const RGBEFormat = RGBAFormat;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBIntegerFormat = 1032;
const RGBAIntegerFormat = 1033;
const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const LinearEncoding = 3000;
const sRGBEncoding = 3001;
const GammaEncoding = 3007;
const RGBEEncoding = 3002;
const LogLuvEncoding = 3003;
const RGBM7Encoding = 3004;
const RGBM16Encoding = 3005;
const RGBDEncoding = 3006;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;
const KeepStencilOp = 7680;
const AlwaysStencilFunc = 519;
const StaticDrawUsage = 35044;
const _box = new Box31();
function Sphere(center, radius) {
    this.center = center !== undefined ? center : new Vector31();
    this.radius = radius !== undefined ? radius : -1;
}
Object.assign(Sphere.prototype, {
    set: function(center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
    },
    setFromPoints: function(points, optionalCenter) {
        const center = this.center;
        if (optionalCenter !== undefined) center.copy(optionalCenter);
        else _box.setFromPoints(points).getCenter(center);
        let maxRadiusSq = 0;
        for(let i = 0, il = points.length; i < il; i++)maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
        this.radius = Math.sqrt(maxRadiusSq);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
    },
    isEmpty: function() {
        return this.radius < 0;
    },
    makeEmpty: function() {
        this.center.set(0, 0, 0);
        this.radius = -1;
        return this;
    },
    containsPoint: function(point) {
        return point.distanceToSquared(this.center) <= this.radius * this.radius;
    },
    distanceToPoint: function(point) {
        return point.distanceTo(this.center) - this.radius;
    },
    intersectsSphere: function(sphere) {
        const radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    },
    intersectsBox: function(box) {
        return box.intersectsSphere(this);
    },
    intersectsPlane: function(plane) {
        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    },
    clampPoint: function(point, target) {
        const deltaLengthSq = this.center.distanceToSquared(point);
        if (target === undefined) {
            console.warn('THREE.Sphere: .clampPoint() target is now required');
            target = new Vector31();
        }
        target.copy(point);
        if (deltaLengthSq > this.radius * this.radius) {
            target.sub(this.center).normalize();
            target.multiplyScalar(this.radius).add(this.center);
        }
        return target;
    },
    getBoundingBox: function(target) {
        if (target === undefined) {
            console.warn('THREE.Sphere: .getBoundingBox() target is now required');
            target = new Box31();
        }
        if (this.isEmpty()) {
            // Empty sphere produces empty bounding box
            target.makeEmpty();
            return target;
        }
        target.set(this.center, this.center);
        target.expandByScalar(this.radius);
        return target;
    },
    applyMatrix4: function(matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
    },
    translate: function(offset) {
        this.center.add(offset);
        return this;
    },
    equals: function(sphere) {
        return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
});
const Sphere1 = Sphere;
const _vector1 = new Vector31();
const _segCenter = new Vector31();
const _segDir = new Vector31();
const _diff = new Vector31();
const _edge1 = new Vector31();
const _edge2 = new Vector31();
const _normal = new Vector31();
class Ray {
    set(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
    }
    at(t, target) {
        if (target === undefined) {
            console.warn('THREE.Ray: .at() target is now required');
            target = new Vector31();
        }
        return target.copy(this.direction).multiplyScalar(t).add(this.origin);
    }
    lookAt(v) {
        this.direction.copy(v).sub(this.origin).normalize();
        return this;
    }
    recast(t) {
        this.origin.copy(this.at(t, _vector1));
        return this;
    }
    closestPointToPoint(point, target) {
        if (target === undefined) {
            console.warn('THREE.Ray: .closestPointToPoint() target is now required');
            target = new Vector31();
        }
        target.subVectors(point, this.origin);
        const directionDistance = target.dot(this.direction);
        if (directionDistance < 0) return target.copy(this.origin);
        return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    }
    distanceToPoint(point) {
        return Math.sqrt(this.distanceSqToPoint(point));
    }
    distanceSqToPoint(point) {
        const directionDistance = _vector1.subVectors(point, this.origin).dot(this.direction);
        // point behind the ray
        if (directionDistance < 0) return this.origin.distanceToSquared(point);
        _vector1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        return _vector1.distanceToSquared(point);
    }
    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
        // It returns the min distance between the ray and the segment
        // defined by v0 and v1
        // It can also set two optional targets :
        // - The closest point on the ray
        // - The closest point on the segment
        _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
        _segDir.copy(v1).sub(v0).normalize();
        _diff.copy(this.origin).sub(_segCenter);
        const segExtent = v0.distanceTo(v1) * 0.5;
        const a01 = -this.direction.dot(_segDir);
        const b0 = _diff.dot(this.direction);
        const b1 = -_diff.dot(_segDir);
        const c = _diff.lengthSq();
        const det = Math.abs(1 - a01 * a01);
        let s0, s1, sqrDist, extDet;
        if (det > 0) {
            // The ray and segment are not parallel.
            s0 = a01 * b1 - b0;
            s1 = a01 * b0 - b1;
            extDet = segExtent * det;
            if (s0 >= 0) {
                if (s1 >= -extDet) {
                    if (s1 <= extDet) {
                        // region 0
                        // Minimum at interior points of ray and segment.
                        const invDet = 1 / det;
                        s0 *= invDet;
                        s1 *= invDet;
                        sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                    } else {
                        // region 1
                        s1 = segExtent;
                        s0 = Math.max(0, -(a01 * s1 + b0));
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                } else {
                    // region 5
                    s1 = -segExtent;
                    s0 = Math.max(0, -(a01 * s1 + b0));
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                }
            } else if (s1 <= -extDet) {
                // region 4
                s0 = Math.max(0, -(-a01 * segExtent + b0));
                s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            } else if (s1 <= extDet) {
                // region 3
                s0 = 0;
                s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = s1 * (s1 + 2 * b1) + c;
            } else {
                // region 2
                s0 = Math.max(0, -(a01 * segExtent + b0));
                s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
        } else {
            // Ray and segment are parallel.
            s1 = a01 > 0 ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
        if (optionalPointOnRay) optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
        if (optionalPointOnSegment) optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
        return sqrDist;
    }
    intersectSphere(sphere, target) {
        _vector1.subVectors(sphere.center, this.origin);
        const tca = _vector1.dot(this.direction);
        const d2 = _vector1.dot(_vector1) - tca * tca;
        const radius2 = sphere.radius * sphere.radius;
        if (d2 > radius2) return null;
        const thc = Math.sqrt(radius2 - d2);
        // t0 = first intersect point - entrance on front of sphere
        const t0 = tca - thc;
        // t1 = second intersect point - exit point on back of sphere
        const t1 = tca + thc;
        // test to see if both t0 and t1 are behind the ray - if so, return null
        if (t0 < 0 && t1 < 0) return null;
        // test to see if t0 is behind the ray:
        // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
        // in order to always return an intersect point that is in front of the ray.
        if (t0 < 0) return this.at(t1, target);
        // else t0 is in front of the ray, so return the first collision point scaled by t0
        return this.at(t0, target);
    }
    intersectsSphere(sphere) {
        return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    }
    distanceToPlane(plane) {
        const denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {
            // line is coplanar, return origin
            if (plane.distanceToPoint(this.origin) === 0) return 0;
            // Null is preferable to undefined since undefined means.... it is undefined
            return null;
        }
        const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        // Return if the ray never intersects the plane
        return t >= 0 ? t : null;
    }
    intersectPlane(plane, target) {
        const t = this.distanceToPlane(plane);
        if (t === null) return null;
        return this.at(t, target);
    }
    intersectsPlane(plane) {
        // check if the ray lies on the plane first
        const distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) return true;
        const denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) return true;
        // ray origin is behind the plane (and is pointing behind it)
        return false;
    }
    intersectBox(box, target) {
        let tmin, tmax, tymin, tymax, tzmin, tzmax;
        const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
        const origin = this.origin;
        if (invdirx >= 0) {
            tmin = (box.min.x - origin.x) * invdirx;
            tmax = (box.max.x - origin.x) * invdirx;
        } else {
            tmin = (box.max.x - origin.x) * invdirx;
            tmax = (box.min.x - origin.x) * invdirx;
        }
        if (invdiry >= 0) {
            tymin = (box.min.y - origin.y) * invdiry;
            tymax = (box.max.y - origin.y) * invdiry;
        } else {
            tymin = (box.max.y - origin.y) * invdiry;
            tymax = (box.min.y - origin.y) * invdiry;
        }
        if (tmin > tymax || tymin > tmax) return null;
        // These lines also handle the case where tmin or tmax is NaN
        // (result of 0 * Infinity). x !== x returns true if x is NaN
        if (tymin > tmin || tmin !== tmin) tmin = tymin;
        if (tymax < tmax || tmax !== tmax) tmax = tymax;
        if (invdirz >= 0) {
            tzmin = (box.min.z - origin.z) * invdirz;
            tzmax = (box.max.z - origin.z) * invdirz;
        } else {
            tzmin = (box.max.z - origin.z) * invdirz;
            tzmax = (box.min.z - origin.z) * invdirz;
        }
        if (tmin > tzmax || tzmin > tmax) return null;
        if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
        //return point closest to the ray (positive side)
        if (tmax < 0) return null;
        return this.at(tmin >= 0 ? tmin : tmax, target);
    }
    intersectsBox(box) {
        return this.intersectBox(box, _vector1) !== null;
    }
    intersectTriangle(a, b, c, backfaceCulling, target) {
        // Compute the offset origin, edges, and normal.
        // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
        _edge1.subVectors(b, a);
        _edge2.subVectors(c, a);
        _normal.crossVectors(_edge1, _edge2);
        // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
        // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
        //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
        //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
        //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
        let DdN = this.direction.dot(_normal);
        let sign;
        if (DdN > 0) {
            if (backfaceCulling) return null;
        } else if (DdN < 0) {
        } else return null;
        _diff.subVectors(this.origin, a);
        const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
        // b1 < 0, no intersection
        if (DdQxE2 < 0) return null;
        const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
        // b2 < 0, no intersection
        if (DdE1xQ < 0) return null;
        // b1+b2 > 1, no intersection
        if (DdQxE2 + DdE1xQ > DdN) return null;
        // Line intersects triangle, check if ray does.
        const QdN = -sign * _diff.dot(_normal);
        // t < 0, no intersection
        if (QdN < 0) return null;
        // Ray intersects triangle.
        return this.at(QdN / DdN, target);
    }
    applyMatrix4(matrix4) {
        this.origin.applyMatrix4(matrix4);
        this.direction.transformDirection(matrix4);
        return this;
    }
    equals(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
    constructor(origin1, direction1){
        this.origin = origin1 !== undefined ? origin1 : new Vector31();
        this.direction = direction1 !== undefined ? direction1 : new Vector31(0, 0, -1);
    }
}
const Ray1 = Ray;
const _v0 = new Vector31();
const _v11 = new Vector31();
const _v2 = new Vector31();
const _v3 = new Vector31();
const _vab = new Vector31();
const _vac = new Vector31();
const _vbc = new Vector31();
const _vap = new Vector31();
const _vbp = new Vector31();
const _vcp = new Vector31();
function Triangle(a, b, c) {
    this.a = a !== undefined ? a : new Vector31();
    this.b = b !== undefined ? b : new Vector31();
    this.c = c !== undefined ? c : new Vector31();
}
Object.assign(Triangle, {
    getNormal: function(a, b, c, target) {
        if (target === undefined) {
            console.warn('THREE.Triangle: .getNormal() target is now required');
            target = new Vector31();
        }
        target.subVectors(c, b);
        _v0.subVectors(a, b);
        target.cross(_v0);
        const targetLengthSq = target.lengthSq();
        if (targetLengthSq > 0) return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
        return target.set(0, 0, 0);
    },
    // static/instance method to calculate barycentric coordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
    getBarycoord: function(point, a, b, c, target) {
        _v0.subVectors(c, a);
        _v11.subVectors(b, a);
        _v2.subVectors(point, a);
        const dot00 = _v0.dot(_v0);
        const dot01 = _v0.dot(_v11);
        const dot02 = _v0.dot(_v2);
        const dot11 = _v11.dot(_v11);
        const dot12 = _v11.dot(_v2);
        const denom = dot00 * dot11 - dot01 * dot01;
        if (target === undefined) {
            console.warn('THREE.Triangle: .getBarycoord() target is now required');
            target = new Vector31();
        }
        // collinear or singular triangle
        if (denom === 0) // arbitrary location outside of triangle?
        // not sure if this is the best idea, maybe should be returning undefined
        return target.set(-2, -1, -1);
        const invDenom = 1 / denom;
        const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        // barycentric coordinates must always sum to 1
        return target.set(1 - u - v, v, u);
    },
    containsPoint: function(point, a, b, c) {
        Triangle.getBarycoord(point, a, b, c, _v3);
        return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
    },
    getUV: function(point, p1, p2, p3, uv1, uv2, uv3, target) {
        this.getBarycoord(point, p1, p2, p3, _v3);
        target.set(0, 0);
        target.addScaledVector(uv1, _v3.x);
        target.addScaledVector(uv2, _v3.y);
        target.addScaledVector(uv3, _v3.z);
        return target;
    },
    isFrontFacing: function(a, b, c, direction1) {
        _v0.subVectors(c, b);
        _v11.subVectors(a, b);
        // strictly front facing
        return _v0.cross(_v11).dot(direction1) < 0 ? true : false;
    }
});
Object.assign(Triangle.prototype, {
    set: function(a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this;
    },
    setFromPointsAndIndices: function(points, i0, i1, i2) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i2]);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
    },
    getArea: function() {
        _v0.subVectors(this.c, this.b);
        _v11.subVectors(this.a, this.b);
        return _v0.cross(_v11).length() * 0.5;
    },
    getMidpoint: function(target) {
        if (target === undefined) {
            console.warn('THREE.Triangle: .getMidpoint() target is now required');
            target = new Vector31();
        }
        return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    },
    getNormal: function(target) {
        return Triangle.getNormal(this.a, this.b, this.c, target);
    },
    getPlane: function(target) {
        if (target === undefined) {
            console.warn('THREE.Triangle: .getPlane() target is now required');
            target = new Plane1();
        }
        return target.setFromCoplanarPoints(this.a, this.b, this.c);
    },
    getBarycoord: function(point, target) {
        return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
    },
    getUV: function(point, uv1, uv2, uv3, target) {
        return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
    },
    containsPoint: function(point) {
        return Triangle.containsPoint(point, this.a, this.b, this.c);
    },
    isFrontFacing: function(direction1) {
        return Triangle.isFrontFacing(this.a, this.b, this.c, direction1);
    },
    intersectsBox: function(box) {
        return box.intersectsTriangle(this);
    },
    closestPointToPoint: function(p, target) {
        if (target === undefined) {
            console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
            target = new Vector31();
        }
        const a = this.a, b = this.b, c = this.c;
        let v, w1;
        // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
        // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
        // under the accompanying license; see chapter 5.1.5 for detailed explanation.
        // basically, we're distinguishing which of the voronoi regions of the triangle
        // the point lies in with the minimum amount of redundant computation.
        _vab.subVectors(b, a);
        _vac.subVectors(c, a);
        _vap.subVectors(p, a);
        const d1 = _vab.dot(_vap);
        const d2 = _vac.dot(_vap);
        if (d1 <= 0 && d2 <= 0) // vertex region of A; barycentric coords (1, 0, 0)
        return target.copy(a);
        _vbp.subVectors(p, b);
        const d3 = _vab.dot(_vbp);
        const d4 = _vac.dot(_vbp);
        if (d3 >= 0 && d4 <= d3) // vertex region of B; barycentric coords (0, 1, 0)
        return target.copy(b);
        const vc = d1 * d4 - d3 * d2;
        if (vc <= 0 && d1 >= 0 && d3 <= 0) {
            v = d1 / (d1 - d3);
            // edge region of AB; barycentric coords (1-v, v, 0)
            return target.copy(a).addScaledVector(_vab, v);
        }
        _vcp.subVectors(p, c);
        const d5 = _vab.dot(_vcp);
        const d6 = _vac.dot(_vcp);
        if (d6 >= 0 && d5 <= d6) // vertex region of C; barycentric coords (0, 0, 1)
        return target.copy(c);
        const vb = d5 * d2 - d1 * d6;
        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
            w1 = d2 / (d2 - d6);
            // edge region of AC; barycentric coords (1-w, 0, w)
            return target.copy(a).addScaledVector(_vac, w1);
        }
        const va = d3 * d6 - d5 * d4;
        if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
            _vbc.subVectors(c, b);
            w1 = (d4 - d3) / (d4 - d3 + (d5 - d6));
            // edge region of BC; barycentric coords (0, 1-w, w)
            return target.copy(b).addScaledVector(_vbc, w1); // edge region of BC
        }
        // face region
        const denom = 1 / (va + vb + vc);
        // u = va * denom
        v = vb * denom;
        w1 = vc * denom;
        return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w1);
    },
    equals: function(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
});
const Triangle1 = Triangle;
class Face3 {
    clone() {
        return new this.constructor().copy(this);
    }
    copy(source) {
        this.a = source.a;
        this.b = source.b;
        this.c = source.c;
        this.normal.copy(source.normal);
        this.color.copy(source.color);
        this.materialIndex = source.materialIndex;
        for(let i = 0, il = source.vertexNormals.length; i < il; i++)this.vertexNormals[i] = source.vertexNormals[i].clone();
        for(let i = 0, il = source.vertexColors.length; i < il; i++)this.vertexColors[i] = source.vertexColors[i].clone();
        return this;
    }
    constructor(a1, b1, c1, normal1, color9, materialIndex){
        this.a = a1;
        this.b = b1;
        this.c = c1;
        this.normal = normal1 && normal1.isVector3 ? normal1 : new Vector31();
        this.vertexNormals = Array.isArray(normal1) ? normal1 : [];
        this.color = color9 && color9.isColor ? color9 : new Color1();
        this.vertexColors = Array.isArray(color9) ? color9 : [];
        this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
    }
}
const Face31 = Face3;
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */
function MeshBasicMaterial(parameters) {
    Material1.call(this);
    this.type = 'MeshBasicMaterial';
    this.color = new Color1(16777215); // emissive
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.setValues(parameters);
}
MeshBasicMaterial.prototype = Object.create(Material1.prototype);
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
MeshBasicMaterial.prototype.copy = function(source) {
    Material1.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    return this;
};
const MeshBasicMaterial1 = MeshBasicMaterial;
const _inverseMatrix = new Matrix41();
const _ray = new Ray1();
const _sphere = new Sphere1();
const _vA = new Vector31();
const _vB = new Vector31();
const _vC = new Vector31();
const _tempA = new Vector31();
const _tempB = new Vector31();
const _tempC = new Vector31();
const _morphA = new Vector31();
const _morphB = new Vector31();
const _morphC = new Vector31();
const _uvA = new Vector21();
const _uvB = new Vector21();
const _uvC = new Vector21();
const _intersectionPoint = new Vector31();
const _intersectionPointWorld = new Vector31();
function Mesh(geometry, material) {
    Object3D1.call(this);
    this.type = 'Mesh';
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry1();
    this.material = material !== undefined ? material : new MeshBasicMaterial1();
    this.updateMorphTargets();
}
Mesh.prototype = Object.assign(Object.create(Object3D1.prototype), {
    constructor: Mesh,
    isMesh: true,
    copy: function(source) {
        Object3D1.prototype.copy.call(this, source);
        if (source.morphTargetInfluences !== undefined) this.morphTargetInfluences = source.morphTargetInfluences.slice();
        if (source.morphTargetDictionary !== undefined) this.morphTargetDictionary = Object.assign({
        }, source.morphTargetDictionary);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    },
    updateMorphTargets: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {
                    };
                    for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
    },
    raycast: function(raycaster, intersects) {
        const geometry = this.geometry;
        const material = this.material;
        const matrixWorld = this.matrixWorld;
        if (material === undefined) return;
        // Checking boundingSphere distance to ray
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere.copy(geometry.boundingSphere);
        _sphere.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere(_sphere) === false) return;
        //
        _inverseMatrix.getInverse(matrixWorld);
        _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
        // Check boundingBox before continuing
        if (geometry.boundingBox !== null) {
            if (_ray.intersectsBox(geometry.boundingBox) === false) return;
        }
        let intersection;
        if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const position = geometry.attributes.position;
            const morphPosition = geometry.morphAttributes.position;
            const morphTargetsRelative = geometry.morphTargetsRelative;
            const uv = geometry.attributes.uv;
            const uv2 = geometry.attributes.uv2;
            const groups = geometry.groups;
            const drawRange = geometry.drawRange;
            if (index !== null) {
                // indexed buffer geometry
                if (Array.isArray(material)) for(let i = 0, il = groups.length; i < il; i++){
                    const group = groups[i];
                    const groupMaterial = material[group.materialIndex];
                    const start = Math.max(group.start, drawRange.start);
                    const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                    for(let j = start, jl = end; j < jl; j += 3){
                        const a1 = index.getX(j);
                        const b1 = index.getX(j + 1);
                        const c1 = index.getX(j + 2);
                        intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a1, b1, c1);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
                            intersection.face.materialIndex = group.materialIndex;
                            intersects.push(intersection);
                        }
                    }
                }
                else {
                    const start = Math.max(0, drawRange.start);
                    const end = Math.min(index.count, drawRange.start + drawRange.count);
                    for(let i1 = start, il1 = end; i1 < il1; i1 += 3){
                        const a1 = index.getX(i1);
                        const b1 = index.getX(i1 + 1);
                        const c1 = index.getX(i1 + 2);
                        intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a1, b1, c1);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(i1 / 3); // triangle number in indexed buffer semantics
                            intersects.push(intersection);
                        }
                    }
                }
            } else if (position !== undefined) {
                // non-indexed buffer geometry
                if (Array.isArray(material)) for(let i = 0, il = groups.length; i < il; i++){
                    const group = groups[i];
                    const groupMaterial = material[group.materialIndex];
                    const start = Math.max(group.start, drawRange.start);
                    const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                    for(let j = start, jl = end; j < jl; j += 3){
                        const a1 = j;
                        const b1 = j + 1;
                        const c1 = j + 2;
                        intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a1, b1, c1);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics
                            intersection.face.materialIndex = group.materialIndex;
                            intersects.push(intersection);
                        }
                    }
                }
                else {
                    const start = Math.max(0, drawRange.start);
                    const end = Math.min(position.count, drawRange.start + drawRange.count);
                    for(let i1 = start, il1 = end; i1 < il1; i1 += 3){
                        const a1 = i1;
                        const b1 = i1 + 1;
                        const c1 = i1 + 2;
                        intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a1, b1, c1);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(i1 / 3); // triangle number in non-indexed buffer semantics
                            intersects.push(intersection);
                        }
                    }
                }
            }
        } else if (geometry.isGeometry) {
            const isMultiMaterial = Array.isArray(material);
            const vertices = geometry.vertices;
            const faces = geometry.faces;
            let uvs;
            const faceVertexUvs = geometry.faceVertexUvs[0];
            if (faceVertexUvs.length > 0) uvs = faceVertexUvs;
            for(let f = 0, fl = faces.length; f < fl; f++){
                const face = faces[f];
                const faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
                if (faceMaterial === undefined) continue;
                const fvA = vertices[face.a];
                const fvB = vertices[face.b];
                const fvC = vertices[face.c];
                intersection = checkIntersection(this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint);
                if (intersection) {
                    if (uvs && uvs[f]) {
                        const uvs_f = uvs[f];
                        _uvA.copy(uvs_f[0]);
                        _uvB.copy(uvs_f[1]);
                        _uvC.copy(uvs_f[2]);
                        intersection.uv = Triangle1.getUV(_intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector21());
                    }
                    intersection.face = face;
                    intersection.faceIndex = f;
                    intersects.push(intersection);
                }
            }
        }
    }
});
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
    let intersect;
    if (material.side === BackSide) intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    else intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
    if (intersect === null) return null;
    _intersectionPointWorld.copy(point);
    _intersectionPointWorld.applyMatrix4(object.matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far) return null;
    return {
        distance: distance,
        point: _intersectionPointWorld.clone(),
        object: object
    };
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a1, b1, c1) {
    _vA.fromBufferAttribute(position, a1);
    _vB.fromBufferAttribute(position, b1);
    _vC.fromBufferAttribute(position, c1);
    const morphInfluences = object.morphTargetInfluences;
    if (material.morphTargets && morphPosition && morphInfluences) {
        _morphA.set(0, 0, 0);
        _morphB.set(0, 0, 0);
        _morphC.set(0, 0, 0);
        for(let i = 0, il = morphPosition.length; i < il; i++){
            const influence = morphInfluences[i];
            const morphAttribute = morphPosition[i];
            if (influence === 0) continue;
            _tempA.fromBufferAttribute(morphAttribute, a1);
            _tempB.fromBufferAttribute(morphAttribute, b1);
            _tempC.fromBufferAttribute(morphAttribute, c1);
            if (morphTargetsRelative) {
                _morphA.addScaledVector(_tempA, influence);
                _morphB.addScaledVector(_tempB, influence);
                _morphC.addScaledVector(_tempC, influence);
            } else {
                _morphA.addScaledVector(_tempA.sub(_vA), influence);
                _morphB.addScaledVector(_tempB.sub(_vB), influence);
                _morphC.addScaledVector(_tempC.sub(_vC), influence);
            }
        }
        _vA.add(_morphA);
        _vB.add(_morphB);
        _vC.add(_morphC);
    }
    if (object.isSkinnedMesh) {
        object.boneTransform(a1, _vA);
        object.boneTransform(b1, _vB);
        object.boneTransform(c1, _vC);
    }
    const intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);
    if (intersection) {
        if (uv) {
            _uvA.fromBufferAttribute(uv, a1);
            _uvB.fromBufferAttribute(uv, b1);
            _uvC.fromBufferAttribute(uv, c1);
            intersection.uv = Triangle1.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector21());
        }
        if (uv2) {
            _uvA.fromBufferAttribute(uv2, a1);
            _uvB.fromBufferAttribute(uv2, b1);
            _uvC.fromBufferAttribute(uv2, c1);
            intersection.uv2 = Triangle1.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector21());
        }
        const face = new Face31(a1, b1, c1);
        Triangle1.getNormal(_vA, _vB, _vC, face.normal);
        intersection.face = face;
    }
    return intersection;
}
const Mesh1 = Mesh;
// BoxBufferGeometry
class BoxBufferGeometry extends BufferGeometry1 {
    constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1){
        super();
        this.type = 'BoxBufferGeometry';
        this.parameters = {
            width: width,
            height: height,
            depth: depth,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            depthSegments: depthSegments
        };
        const scope = this;
        // segments
        widthSegments = Math.floor(widthSegments);
        heightSegments = Math.floor(heightSegments);
        depthSegments = Math.floor(depthSegments);
        // buffers
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        // helper variables
        let numberOfVertices = 0;
        let groupStart = 0;
        // build each side of the box geometry
        buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
        buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx
        buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
        buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny
        buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
        buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
        // build geometry
        this.setIndex(indices);
        this.setAttribute('position', new Float32BufferAttribute1(vertices, 3));
        this.setAttribute('normal', new Float32BufferAttribute1(normals, 3));
        this.setAttribute('uv', new Float32BufferAttribute1(uvs, 2));
        function buildPlane(u, v, w1, udir, vdir, width1, height1, depth1, gridX, gridY, materialIndex1) {
            const segmentWidth = width1 / gridX;
            const segmentHeight = height1 / gridY;
            const widthHalf = width1 / 2;
            const heightHalf = height1 / 2;
            const depthHalf = depth1 / 2;
            const gridX1 = gridX + 1;
            const gridY1 = gridY + 1;
            let vertexCounter = 0;
            let groupCount = 0;
            const vector = new Vector31();
            // generate vertices, normals and uvs
            for(let iy = 0; iy < gridY1; iy++){
                const y1 = iy * segmentHeight - heightHalf;
                for(let ix = 0; ix < gridX1; ix++){
                    const x1 = ix * segmentWidth - widthHalf;
                    // set values to correct vector component
                    vector[u] = x1 * udir;
                    vector[v] = y1 * vdir;
                    vector[w1] = depthHalf;
                    // now apply vector to vertex buffer
                    vertices.push(vector.x, vector.y, vector.z);
                    // set values to correct vector component
                    vector[u] = 0;
                    vector[v] = 0;
                    vector[w1] = depth1 > 0 ? 1 : -1;
                    // now apply vector to normal buffer
                    normals.push(vector.x, vector.y, vector.z);
                    // uvs
                    uvs.push(ix / gridX);
                    uvs.push(1 - iy / gridY);
                    // counters
                    vertexCounter += 1;
                }
            }
            // indices
            // 1. you need three indices to draw a single face
            // 2. a single segment consists of two faces
            // 3. so we need to generate six (2*3) indices per segment
            for(let iy = 0; iy < gridY; iy++)for(let ix = 0; ix < gridX; ix++){
                const a1 = numberOfVertices + ix + gridX1 * iy;
                const b1 = numberOfVertices + ix + gridX1 * (iy + 1);
                const c1 = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                const d = numberOfVertices + (ix + 1) + gridX1 * iy;
                // faces
                indices.push(a1, b1, d);
                indices.push(b1, c1, d);
                // increase counter
                groupCount += 6;
            }
            // add a group to the geometry. this will ensure multi material support
            scope.addGroup(groupStart, groupCount, materialIndex1);
            // calculate new start value for groups
            groupStart += groupCount;
            // update total number of vertices
            numberOfVertices += vertexCounter;
        }
    }
}
const BoxBufferGeometry1 = BoxBufferGeometry;
function cloneUniforms(src) {
    const dst = {
    };
    for(const u in src){
        dst[u] = {
        };
        for(const p in src[u]){
            const property = src[u][p];
            if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) dst[u][p] = property.clone();
            else if (Array.isArray(property)) dst[u][p] = property.slice();
            else dst[u][p] = property;
        }
    }
    return dst;
}
function mergeUniforms(uniforms) {
    const merged = {
    };
    for(let u = 0; u < uniforms.length; u++){
        const tmp = cloneUniforms(uniforms[u]);
        for(const p in tmp)merged[p] = tmp[p];
    }
    return merged;
}
// Legacy
const UniformsUtils = {
    clone: cloneUniforms,
    merge: mergeUniforms
};
const UniformsUtils1 = UniformsUtils;
const default_vertex = /* glsl */
`\nvoid main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`;
const default_fragment = /* glsl */
`\nvoid main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}\n`;
/**
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */
function ShaderMaterial2(parameters) {
    Material1.call(this);
    this.type = 'ShaderMaterial';
    this.defines = {
    };
    this.uniforms = {
    };
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false; // set to use scene fog
    this.lights = false; // set to use scene lights
    this.clipping = false; // set to use user-defined clipping planes
    this.skinning = false; // set to use skinning attribute streams
    this.morphTargets = false; // set to use morph targets
    this.morphNormals = false; // set to use morph normals
    this.extensions = {
        derivatives: false,
        fragDepth: false,
        drawBuffers: false,
        shaderTextureLOD: false
    };
    // When rendered geometry doesn't include these attributes but the material does,
    // use these default values in WebGL. This avoids errors when buffer data is missing.
    this.defaultAttributeValues = {
        'color': [
            1,
            1,
            1
        ],
        'uv': [
            0,
            0
        ],
        'uv2': [
            0,
            0
        ]
    };
    this.index0AttributeName = undefined;
    this.uniformsNeedUpdate = false;
    if (parameters !== undefined) {
        if (parameters.attributes !== undefined) console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
        this.setValues(parameters);
    }
}
ShaderMaterial2.prototype = Object.create(Material1.prototype);
ShaderMaterial2.prototype.constructor = ShaderMaterial2;
ShaderMaterial2.prototype.isShaderMaterial = true;
ShaderMaterial2.prototype.copy = function(source) {
    Material1.prototype.copy.call(this, source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.defines = Object.assign({
    }, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.extensions = Object.assign({
    }, source.extensions);
    return this;
};
ShaderMaterial2.prototype.toJSON = function(meta) {
    const data = Material1.prototype.toJSON.call(this, meta);
    data.uniforms = {
    };
    for(const name in this.uniforms){
        const uniform = this.uniforms[name];
        const value = uniform.value;
        if (value && value.isTexture) data.uniforms[name] = {
            type: 't',
            value: value.toJSON(meta).uuid
        };
        else if (value && value.isColor) data.uniforms[name] = {
            type: 'c',
            value: value.getHex()
        };
        else if (value && value.isVector2) data.uniforms[name] = {
            type: 'v2',
            value: value.toArray()
        };
        else if (value && value.isVector3) data.uniforms[name] = {
            type: 'v3',
            value: value.toArray()
        };
        else if (value && value.isVector4) data.uniforms[name] = {
            type: 'v4',
            value: value.toArray()
        };
        else if (value && value.isMatrix3) data.uniforms[name] = {
            type: 'm3',
            value: value.toArray()
        };
        else if (value && value.isMatrix4) data.uniforms[name] = {
            type: 'm4',
            value: value.toArray()
        };
        else data.uniforms[name] = {
            value: value
        };
    }
    if (Object.keys(this.defines).length > 0) data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    const extensions = {
    };
    for(const key in this.extensions)if (this.extensions[key] === true) extensions[key] = true;
    if (Object.keys(extensions).length > 0) data.extensions = extensions;
    return data;
};
const ShaderMaterial1 = ShaderMaterial2;
class Quaternion {
    static slerp(qa, qb, qm, t) {
        return qm.copy(qa).slerp(qb, t);
    }
    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
        // fuzz-free, array-based Quaternion SLERP operation
        let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
        dst[dstOffset] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
    }
    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
        const x0 = src0[srcOffset0];
        const y0 = src0[srcOffset0 + 1];
        const z0 = src0[srcOffset0 + 2];
        const w0 = src0[srcOffset0 + 3];
        const x1 = src1[srcOffset1];
        const y1 = src1[srcOffset1 + 1];
        const z1 = src1[srcOffset1 + 2];
        const w1 = src1[srcOffset1 + 3];
        dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
        dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
        dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
        dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
        return dst;
    }
    get x() {
        return this._x;
    }
    set x(value) {
        this._x = value;
        this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(value) {
        this._y = value;
        this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(value) {
        this._z = value;
        this._onChangeCallback();
    }
    get w() {
        return this._w;
    }
    set w(value) {
        this._w = value;
        this._onChangeCallback();
    }
    set(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this._onChangeCallback();
        return this;
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this._onChangeCallback();
        return this;
    }
    setFromEuler(euler, update) {
        if (!(euler && euler.isEuler)) throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
        const x2 = euler._x, y2 = euler._y, z2 = euler._z, order = euler._order;
        // http://www.mathworks.com/matlabcentral/fileexchange/
        // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
        //	content/SpinCalc.m
        const cos = Math.cos;
        const sin = Math.sin;
        const c1 = cos(x2 / 2);
        const c2 = cos(y2 / 2);
        const c3 = cos(z2 / 2);
        const s1 = sin(x2 / 2);
        const s2 = sin(y2 / 2);
        const s3 = sin(z2 / 2);
        switch(order){
            case 'XYZ':
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                break;
            case 'YXZ':
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                break;
            case 'ZXY':
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                break;
            case 'ZYX':
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                break;
            case 'YZX':
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                break;
            case 'XZY':
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                break;
            default:
                console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
        }
        if (update !== false) this._onChangeCallback();
        return this;
    }
    setFromAxisAngle(axis, angle) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
        // assumes axis is normalized
        const halfAngle = angle / 2, s = Math.sin(halfAngle);
        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos(halfAngle);
        this._onChangeCallback();
        return this;
    }
    setFromRotationMatrix(m) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
        if (trace > 0) {
            const s = 0.5 / Math.sqrt(trace + 1);
            this._w = 0.25 / s;
            this._x = (m32 - m23) * s;
            this._y = (m13 - m31) * s;
            this._z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
            const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
            this._w = (m32 - m23) / s;
            this._x = 0.25 * s;
            this._y = (m12 + m21) / s;
            this._z = (m13 + m31) / s;
        } else if (m22 > m33) {
            const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
            this._w = (m13 - m31) / s;
            this._x = (m12 + m21) / s;
            this._y = 0.25 * s;
            this._z = (m23 + m32) / s;
        } else {
            const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
            this._w = (m21 - m12) / s;
            this._x = (m13 + m31) / s;
            this._y = (m23 + m32) / s;
            this._z = 0.25 * s;
        }
        this._onChangeCallback();
        return this;
    }
    setFromUnitVectors(vFrom, vTo) {
        // assumes direction vectors vFrom and vTo are normalized
        const EPS = 0.000001;
        let r = vFrom.dot(vTo) + 1;
        if (r < EPS) {
            r = 0;
            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                this._x = -vFrom.y;
                this._y = vFrom.x;
                this._z = 0;
                this._w = r;
            } else {
                this._x = 0;
                this._y = -vFrom.z;
                this._z = vFrom.y;
                this._w = r;
            }
        } else {
            // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
            this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
            this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
            this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
            this._w = r;
        }
        return this.normalize();
    }
    angleTo(q) {
        return 2 * Math.acos(Math.abs(MathUtils1.clamp(this.dot(q), -1, 1)));
    }
    rotateTowards(q, step) {
        const angle = this.angleTo(q);
        if (angle === 0) return this;
        const t = Math.min(1, step / angle);
        this.slerp(q, t);
        return this;
    }
    identity() {
        return this.set(0, 0, 0, 1);
    }
    inverse() {
        // quaternion is assumed to have unit length
        return this.conjugate();
    }
    conjugate() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._onChangeCallback();
        return this;
    }
    dot(v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
        let l = this.length();
        if (l === 0) {
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;
        } else {
            l = 1 / l;
            this._x = this._x * l;
            this._y = this._y * l;
            this._z = this._z * l;
            this._w = this._w * l;
        }
        this._onChangeCallback();
        return this;
    }
    multiply(q, p) {
        if (p !== undefined) {
            console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
            return this.multiplyQuaternions(q, p);
        }
        return this.multiplyQuaternions(this, q);
    }
    premultiply(q) {
        return this.multiplyQuaternions(q, this);
    }
    multiplyQuaternions(a, b) {
        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
        const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
        const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this._onChangeCallback();
        return this;
    }
    slerp(qb, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(qb);
        const x2 = this._x, y2 = this._y, z2 = this._z, w2 = this._w;
        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
        let cosHalfTheta = w2 * qb._w + x2 * qb._x + y2 * qb._y + z2 * qb._z;
        if (cosHalfTheta < 0) {
            this._w = -qb._w;
            this._x = -qb._x;
            this._y = -qb._y;
            this._z = -qb._z;
        } else this.copy(qb);
        if (cosHalfTheta >= 1) {
            this._w = w2;
            this._x = x2;
            this._y = y2;
            this._z = z2;
            return this;
        }
        const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
        if (sqrSinHalfTheta <= Number.EPSILON) {
            const s = 1 - t;
            this._w = s * w2 + t * this._w;
            this._x = s * x2 + t * this._x;
            this._y = s * y2 + t * this._y;
            this._z = s * z2 + t * this._z;
            this.normalize();
            this._onChangeCallback();
            return this;
        }
        const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
        const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this._w = w2 * ratioA + this._w * ratioB;
        this._x = x2 * ratioA + this._x * ratioB;
        this._y = y2 * ratioA + this._y * ratioB;
        this._z = z2 * ratioA + this._z * ratioB;
        this._onChangeCallback();
        return this;
    }
    equals(quaternion) {
        return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    }
    fromArray(array, offset) {
        if (offset === undefined) offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onChangeCallback();
        return this;
    }
    toArray(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
    }
    fromBufferAttribute(attribute, index) {
        this._x = attribute.getX(index);
        this._y = attribute.getY(index);
        this._z = attribute.getZ(index);
        this._w = attribute.getW(index);
        return this;
    }
    _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
    }
    _onChangeCallback() {
    }
    constructor(x2 = 0, y2 = 0, z2 = 0, w2 = 1){
        this._x = x2;
        this._y = y2;
        this._z = z2;
        this._w = w2;
    }
}
Quaternion.prototype.isQuaternion = true;
const Quaternion1 = Quaternion;
class Matrix4 {
    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        const te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
    }
    identity() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    }
    clone() {
        return new Matrix4().fromArray(this.elements);
    }
    copy(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        te[9] = me[9];
        te[10] = me[10];
        te[11] = me[11];
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        te[15] = me[15];
        return this;
    }
    copyPosition(m) {
        const te = this.elements, me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
    }
    makeBasis(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
    }
    extractRotation(m) {
        // this method does not support reflection matrices
        const te = this.elements;
        const me = m.elements;
        const scaleX = 1 / _v12.setFromMatrixColumn(m, 0).length();
        const scaleY = 1 / _v12.setFromMatrixColumn(m, 1).length();
        const scaleZ = 1 / _v12.setFromMatrixColumn(m, 2).length();
        te[0] = me[0] * scaleX;
        te[1] = me[1] * scaleX;
        te[2] = me[2] * scaleX;
        te[3] = 0;
        te[4] = me[4] * scaleY;
        te[5] = me[5] * scaleY;
        te[6] = me[6] * scaleY;
        te[7] = 0;
        te[8] = me[8] * scaleZ;
        te[9] = me[9] * scaleZ;
        te[10] = me[10] * scaleZ;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    }
    makeRotationFromEuler(euler) {
        if (!(euler && euler.isEuler)) console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
        const te = this.elements;
        const x3 = euler.x, y3 = euler.y, z3 = euler.z;
        const a2 = Math.cos(x3), b2 = Math.sin(x3);
        const c1 = Math.cos(y3), d = Math.sin(y3);
        const e = Math.cos(z3), f = Math.sin(z3);
        if (euler.order === 'XYZ') {
            const ae = a2 * e, af = a2 * f, be = b2 * e, bf = b2 * f;
            te[0] = c1 * e;
            te[4] = -c1 * f;
            te[8] = d;
            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b2 * c1;
            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a2 * c1;
        } else if (euler.order === 'YXZ') {
            const ce = c1 * e, cf = c1 * f, de = d * e, df = d * f;
            te[0] = ce + df * b2;
            te[4] = de * b2 - cf;
            te[8] = a2 * d;
            te[1] = a2 * f;
            te[5] = a2 * e;
            te[9] = -b2;
            te[2] = cf * b2 - de;
            te[6] = df + ce * b2;
            te[10] = a2 * c1;
        } else if (euler.order === 'ZXY') {
            const ce = c1 * e, cf = c1 * f, de = d * e, df = d * f;
            te[0] = ce - df * b2;
            te[4] = -a2 * f;
            te[8] = de + cf * b2;
            te[1] = cf + de * b2;
            te[5] = a2 * e;
            te[9] = df - ce * b2;
            te[2] = -a2 * d;
            te[6] = b2;
            te[10] = a2 * c1;
        } else if (euler.order === 'ZYX') {
            const ae = a2 * e, af = a2 * f, be = b2 * e, bf = b2 * f;
            te[0] = c1 * e;
            te[4] = be * d - af;
            te[8] = ae * d + bf;
            te[1] = c1 * f;
            te[5] = bf * d + ae;
            te[9] = af * d - be;
            te[2] = -d;
            te[6] = b2 * c1;
            te[10] = a2 * c1;
        } else if (euler.order === 'YZX') {
            const ac = a2 * c1, ad = a2 * d, bc = b2 * c1, bd = b2 * d;
            te[0] = c1 * e;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;
            te[1] = f;
            te[5] = a2 * e;
            te[9] = -b2 * e;
            te[2] = -d * e;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
        } else if (euler.order === 'XZY') {
            const ac = a2 * c1, ad = a2 * d, bc = b2 * c1, bd = b2 * d;
            te[0] = c1 * e;
            te[4] = -f;
            te[8] = d * e;
            te[1] = ac * f + bd;
            te[5] = a2 * e;
            te[9] = ad * f - bc;
            te[2] = bc * f - ad;
            te[6] = b2 * e;
            te[10] = bd * f + ac;
        }
        // bottom row
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        // last column
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    }
    makeRotationFromQuaternion(q) {
        return this.compose(_zero, q, _one);
    }
    lookAt(eye, target, up) {
        const te = this.elements;
        _z.subVectors(eye, target);
        if (_z.lengthSq() === 0) // eye and target are in the same position
        _z.z = 1;
        _z.normalize();
        _x.crossVectors(up, _z);
        if (_x.lengthSq() === 0) {
            // up and z are parallel
            if (Math.abs(up.z) === 1) _z.x += 0.0001;
            else _z.z += 0.0001;
            _z.normalize();
            _x.crossVectors(up, _z);
        }
        _x.normalize();
        _y.crossVectors(_z, _x);
        te[0] = _x.x;
        te[4] = _y.x;
        te[8] = _z.x;
        te[1] = _x.y;
        te[5] = _y.y;
        te[9] = _z.y;
        te[2] = _x.z;
        te[6] = _y.z;
        te[10] = _z.z;
        return this;
    }
    multiply(m, n) {
        if (n !== undefined) {
            console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
            return this.multiplyMatrices(m, n);
        }
        return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
        return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
        const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
        const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
        const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
        const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
        const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
        const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
        const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
    }
    multiplyScalar(s) {
        const te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
    }
    determinant() {
        const te = this.elements;
        const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
        const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
        const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
        const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
        //TODO: make this more efficient
        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
        return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    }
    transpose() {
        const te = this.elements;
        let tmp;
        tmp = te[1];
        te[1] = te[4];
        te[4] = tmp;
        tmp = te[2];
        te[2] = te[8];
        te[8] = tmp;
        tmp = te[6];
        te[6] = te[9];
        te[9] = tmp;
        tmp = te[3];
        te[3] = te[12];
        te[12] = tmp;
        tmp = te[7];
        te[7] = te[13];
        te[13] = tmp;
        tmp = te[11];
        te[11] = te[14];
        te[14] = tmp;
        return this;
    }
    setPosition(x, y, z) {
        const te = this.elements;
        if (x.isVector3) {
            te[12] = x.x;
            te[13] = x.y;
            te[14] = x.z;
        } else {
            te[12] = x;
            te[13] = y;
            te[14] = z;
        }
        return this;
    }
    getInverse(m, throwOnDegenerate) {
        if (throwOnDegenerate !== undefined) console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");
        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
        const te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
        te[4] = t12 * detInv;
        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
        te[8] = t13 * detInv;
        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
        te[12] = t14 * detInv;
        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
        return this;
    }
    scale(v) {
        const te = this.elements;
        const x3 = v.x, y3 = v.y, z3 = v.z;
        te[0] *= x3;
        te[4] *= y3;
        te[8] *= z3;
        te[1] *= x3;
        te[5] *= y3;
        te[9] *= z3;
        te[2] *= x3;
        te[6] *= y3;
        te[10] *= z3;
        te[3] *= x3;
        te[7] *= y3;
        te[11] *= z3;
        return this;
    }
    getMaxScaleOnAxis() {
        const te = this.elements;
        const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    }
    makeTranslation(x, y, z) {
        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
    }
    makeRotationX(theta) {
        const c1 = Math.cos(theta), s = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c1, -s, 0, 0, s, c1, 0, 0, 0, 0, 1);
        return this;
    }
    makeRotationY(theta) {
        const c1 = Math.cos(theta), s = Math.sin(theta);
        this.set(c1, 0, s, 0, 0, 1, 0, 0, -s, 0, c1, 0, 0, 0, 0, 1);
        return this;
    }
    makeRotationZ(theta) {
        const c1 = Math.cos(theta), s = Math.sin(theta);
        this.set(c1, -s, 0, 0, s, c1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    }
    makeRotationAxis(axis, angle) {
        // Based on http://www.gamedev.net/reference/articles/article1199.asp
        const c1 = Math.cos(angle);
        const s = Math.sin(angle);
        const t = 1 - c1;
        const x3 = axis.x, y3 = axis.y, z3 = axis.z;
        const tx = t * x3, ty = t * y3;
        this.set(tx * x3 + c1, tx * y3 - s * z3, tx * z3 + s * y3, 0, tx * y3 + s * z3, ty * y3 + c1, ty * z3 - s * x3, 0, tx * z3 - s * y3, ty * z3 + s * x3, t * z3 * z3 + c1, 0, 0, 0, 0, 1);
        return this;
    }
    makeScale(x, y, z) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
    }
    makeShear(x, y, z) {
        this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
        return this;
    }
    compose(position, quaternion, scale) {
        const te = this.elements;
        const x3 = quaternion._x, y3 = quaternion._y, z3 = quaternion._z, w3 = quaternion._w;
        const x21 = x3 + x3, y21 = y3 + y3, z21 = z3 + z3;
        const xx = x3 * x21, xy = x3 * y21, xz = x3 * z21;
        const yy = y3 * y21, yz = y3 * z21, zz = z3 * z21;
        const wx = w3 * x21, wy = w3 * y21, wz = w3 * z21;
        const sx = scale.x, sy = scale.y, sz = scale.z;
        te[0] = (1 - (yy + zz)) * sx;
        te[1] = (xy + wz) * sx;
        te[2] = (xz - wy) * sx;
        te[3] = 0;
        te[4] = (xy - wz) * sy;
        te[5] = (1 - (xx + zz)) * sy;
        te[6] = (yz + wx) * sy;
        te[7] = 0;
        te[8] = (xz + wy) * sz;
        te[9] = (yz - wx) * sz;
        te[10] = (1 - (xx + yy)) * sz;
        te[11] = 0;
        te[12] = position.x;
        te[13] = position.y;
        te[14] = position.z;
        te[15] = 1;
        return this;
    }
    decompose(position, quaternion, scale) {
        const te = this.elements;
        let sx = _v12.set(te[0], te[1], te[2]).length();
        const sy = _v12.set(te[4], te[5], te[6]).length();
        const sz = _v12.set(te[8], te[9], te[10]).length();
        // if determine is negative, we need to invert one scale
        const det = this.determinant();
        if (det < 0) sx = -sx;
        position.x = te[12];
        position.y = te[13];
        position.z = te[14];
        // scale the rotation part
        _m1.copy(this);
        const invSX = 1 / sx;
        const invSY = 1 / sy;
        const invSZ = 1 / sz;
        _m1.elements[0] *= invSX;
        _m1.elements[1] *= invSX;
        _m1.elements[2] *= invSX;
        _m1.elements[4] *= invSY;
        _m1.elements[5] *= invSY;
        _m1.elements[6] *= invSY;
        _m1.elements[8] *= invSZ;
        _m1.elements[9] *= invSZ;
        _m1.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix(_m1);
        scale.x = sx;
        scale.y = sy;
        scale.z = sz;
        return this;
    }
    makePerspective(left, right, top, bottom, near, far) {
        if (far === undefined) console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
        const te = this.elements;
        const x3 = 2 * near / (right - left);
        const y3 = 2 * near / (top - bottom);
        const a2 = (right + left) / (right - left);
        const b2 = (top + bottom) / (top - bottom);
        const c1 = -(far + near) / (far - near);
        const d = -2 * far * near / (far - near);
        te[0] = x3;
        te[4] = 0;
        te[8] = a2;
        te[12] = 0;
        te[1] = 0;
        te[5] = y3;
        te[9] = b2;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c1;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
    }
    makeOrthographic(left, right, top, bottom, near, far) {
        const te = this.elements;
        const w3 = 1 / (right - left);
        const h = 1 / (top - bottom);
        const p = 1 / (far - near);
        const x3 = (right + left) * w3;
        const y3 = (top + bottom) * h;
        const z3 = (far + near) * p;
        te[0] = 2 * w3;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x3;
        te[1] = 0;
        te[5] = 2 * h;
        te[9] = 0;
        te[13] = -y3;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 * p;
        te[14] = -z3;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
    }
    equals(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for(let i = 0; i < 16; i++)if (te[i] !== me[i]) return false;
        return true;
    }
    fromArray(array, offset) {
        if (offset === undefined) offset = 0;
        for(let i = 0; i < 16; i++)this.elements[i] = array[i + offset];
        return this;
    }
    toArray(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
    }
    constructor(){
        this.elements = [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ];
        if (arguments.length > 0) console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
    }
}
Matrix4.prototype.isMatrix4 = true;
const _v12 = new Vector31();
const _m1 = new Matrix4();
const _zero = new Vector31(0, 0, 0);
const _one = new Vector31(1, 1, 1);
const _x = new Vector31();
const _y = new Vector31();
const _z = new Vector31();
const Matrix41 = Matrix4;
const _lut = [];
for(let i = 0; i < 256; i++)_lut[i] = (i < 16 ? '0' : '') + i.toString(16);
let _seed = 1234567;
const MathUtils = {
    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,
    generateUUID: function() {
        // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
        const d0 = Math.random() * 4294967295 | 0;
        const d1 = Math.random() * 4294967295 | 0;
        const d2 = Math.random() * 4294967295 | 0;
        const d3 = Math.random() * 4294967295 | 0;
        const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + '-' + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + '-' + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + '-' + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + '-' + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
        // .toUpperCase() here flattens concatenated strings to save heap memory space.
        return uuid.toUpperCase();
    },
    clamp: function(value, min, max) {
        return Math.max(min, Math.min(max, value));
    },
    // compute euclidian modulo of m % n
    // https://en.wikipedia.org/wiki/Modulo_operation
    euclideanModulo: function(n, m) {
        return (n % m + m) % m;
    },
    // Linear mapping from range <a1, a2> to range <b1, b2>
    mapLinear: function(x3, a11, a2, b11, b2) {
        return b11 + (x3 - a11) * (b2 - b11) / (a2 - a11);
    },
    // https://en.wikipedia.org/wiki/Linear_interpolation
    lerp: function(x3, y3, t) {
        return (1 - t) * x3 + t * y3;
    },
    // http://en.wikipedia.org/wiki/Smoothstep
    smoothstep: function(x3, min, max) {
        if (x3 <= min) return 0;
        if (x3 >= max) return 1;
        x3 = (x3 - min) / (max - min);
        return x3 * x3 * (3 - 2 * x3);
    },
    smootherstep: function(x3, min, max) {
        if (x3 <= min) return 0;
        if (x3 >= max) return 1;
        x3 = (x3 - min) / (max - min);
        return x3 * x3 * x3 * (x3 * (x3 * 6 - 15) + 10);
    },
    // Random integer from <low, high> interval
    randInt: function(low, high) {
        return low + Math.floor(Math.random() * (high - low + 1));
    },
    // Random float from <low, high> interval
    randFloat: function(low, high) {
        return low + Math.random() * (high - low);
    },
    // Random float from <-range/2, range/2> interval
    randFloatSpread: function(range) {
        return range * (0.5 - Math.random());
    },
    // Deterministic pseudo-random float in the interval [ 0, 1 ]
    seededRandom: function(s) {
        if (s !== undefined) _seed = s % 2147483647;
        // Park-Miller algorithm
        _seed = _seed * 16807 % 2147483647;
        return (_seed - 1) / 2147483646;
    },
    degToRad: function(degrees) {
        return degrees * MathUtils.DEG2RAD;
    },
    radToDeg: function(radians) {
        return radians * MathUtils.RAD2DEG;
    },
    isPowerOfTwo: function(value) {
        return (value & value - 1) === 0 && value !== 0;
    },
    ceilPowerOfTwo: function(value) {
        return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
    },
    floorPowerOfTwo: function(value) {
        return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
    },
    setQuaternionFromProperEuler: function(q, a2, b2, c1, order) {
        // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
        // rotations are applied to the axes in the order specified by 'order'
        // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
        // angles are in radians
        const cos = Math.cos;
        const sin = Math.sin;
        const c2 = cos(b2 / 2);
        const s2 = sin(b2 / 2);
        const c13 = cos((a2 + c1) / 2);
        const s13 = sin((a2 + c1) / 2);
        const c1_3 = cos((a2 - c1) / 2);
        const s1_3 = sin((a2 - c1) / 2);
        const c3_1 = cos((c1 - a2) / 2);
        const s3_1 = sin((c1 - a2) / 2);
        switch(order){
            case 'XYX':
                q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
                break;
            case 'YZY':
                q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
                break;
            case 'ZXZ':
                q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
                break;
            case 'XZX':
                q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
                break;
            case 'YXY':
                q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
                break;
            case 'ZYZ':
                q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
                break;
            default:
                console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
        }
    }
};
const MathUtils1 = MathUtils;
class Euler {
    get x() {
        return this._x;
    }
    set x(value) {
        this._x = value;
        this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(value) {
        this._y = value;
        this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(value) {
        this._z = value;
        this._onChangeCallback();
    }
    get order() {
        return this._order;
    }
    set order(value) {
        this._order = value;
        this._onChangeCallback();
    }
    set(x, y, z, order) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;
        this._onChangeCallback();
        return this;
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this._onChangeCallback();
        return this;
    }
    setFromRotationMatrix(m, order, update) {
        const clamp = MathUtils1.clamp;
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        const te = m.elements;
        const m11 = te[0], m12 = te[4], m13 = te[8];
        const m21 = te[1], m22 = te[5], m23 = te[9];
        const m31 = te[2], m32 = te[6], m33 = te[10];
        order = order || this._order;
        switch(order){
            case 'XYZ':
                this._y = Math.asin(clamp(m13, -1, 1));
                if (Math.abs(m13) < 0.9999999) {
                    this._x = Math.atan2(-m23, m33);
                    this._z = Math.atan2(-m12, m11);
                } else {
                    this._x = Math.atan2(m32, m22);
                    this._z = 0;
                }
                break;
            case 'YXZ':
                this._x = Math.asin(-clamp(m23, -1, 1));
                if (Math.abs(m23) < 0.9999999) {
                    this._y = Math.atan2(m13, m33);
                    this._z = Math.atan2(m21, m22);
                } else {
                    this._y = Math.atan2(-m31, m11);
                    this._z = 0;
                }
                break;
            case 'ZXY':
                this._x = Math.asin(clamp(m32, -1, 1));
                if (Math.abs(m32) < 0.9999999) {
                    this._y = Math.atan2(-m31, m33);
                    this._z = Math.atan2(-m12, m22);
                } else {
                    this._y = 0;
                    this._z = Math.atan2(m21, m11);
                }
                break;
            case 'ZYX':
                this._y = Math.asin(-clamp(m31, -1, 1));
                if (Math.abs(m31) < 0.9999999) {
                    this._x = Math.atan2(m32, m33);
                    this._z = Math.atan2(m21, m11);
                } else {
                    this._x = 0;
                    this._z = Math.atan2(-m12, m22);
                }
                break;
            case 'YZX':
                this._z = Math.asin(clamp(m21, -1, 1));
                if (Math.abs(m21) < 0.9999999) {
                    this._x = Math.atan2(-m23, m22);
                    this._y = Math.atan2(-m31, m11);
                } else {
                    this._x = 0;
                    this._y = Math.atan2(m13, m33);
                }
                break;
            case 'XZY':
                this._z = Math.asin(-clamp(m12, -1, 1));
                if (Math.abs(m12) < 0.9999999) {
                    this._x = Math.atan2(m32, m22);
                    this._y = Math.atan2(m13, m11);
                } else {
                    this._x = Math.atan2(-m23, m33);
                    this._y = 0;
                }
                break;
            default:
                console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
        }
        this._order = order;
        if (update !== false) this._onChangeCallback();
        return this;
    }
    setFromQuaternion(q, order, update) {
        _matrix.makeRotationFromQuaternion(q);
        return this.setFromRotationMatrix(_matrix, order, update);
    }
    setFromVector3(v, order) {
        return this.set(v.x, v.y, v.z, order || this._order);
    }
    reorder(newOrder) {
        // WARNING: this discards revolution information -bhouston
        _quaternion2.setFromEuler(this);
        return this.setFromQuaternion(_quaternion2, newOrder);
    }
    equals(euler) {
        return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    }
    fromArray(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== undefined) this._order = array[3];
        this._onChangeCallback();
        return this;
    }
    toArray(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
    }
    toVector3(optionalResult) {
        if (optionalResult) return optionalResult.set(this._x, this._y, this._z);
        else return new Vector31(this._x, this._y, this._z);
    }
    _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
    }
    _onChangeCallback() {
    }
    constructor(x3 = 0, y3 = 0, z3 = 0, order1 = Euler.DefaultOrder){
        this._x = x3;
        this._y = y3;
        this._z = z3;
        this._order = order1;
    }
}
Euler.DefaultOrder = 'XYZ';
Euler.RotationOrders = [
    'XYZ',
    'YZX',
    'ZXY',
    'XZY',
    'YXZ',
    'ZYX'
];
Euler.prototype.isEuler = true;
const _matrix = new Matrix41();
const _quaternion2 = new Quaternion1();
const Euler1 = Euler;
class Layers {
    set(channel) {
        this.mask = 1 << channel | 0;
    }
    enable(channel) {
        this.mask |= 1 << channel | 0;
    }
    enableAll() {
        this.mask = -1;
    }
    toggle(channel) {
        this.mask ^= 1 << channel | 0;
    }
    disable(channel) {
        this.mask &= ~(1 << channel | 0);
    }
    disableAll() {
        this.mask = 0;
    }
    test(layers) {
        return (this.mask & layers.mask) !== 0;
    }
    constructor(){
        this.mask = 1;
    }
}
const Layers1 = Layers;
class Matrix3 {
    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        const te = this.elements;
        te[0] = n11;
        te[1] = n21;
        te[2] = n31;
        te[3] = n12;
        te[4] = n22;
        te[5] = n32;
        te[6] = n13;
        te[7] = n23;
        te[8] = n33;
        return this;
    }
    identity() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
    }
    clone() {
        return new this.constructor().fromArray(this.elements);
    }
    copy(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrix3Column(this, 0);
        yAxis.setFromMatrix3Column(this, 1);
        zAxis.setFromMatrix3Column(this, 2);
        return this;
    }
    setFromMatrix4(m) {
        const me = m.elements;
        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
        return this;
    }
    multiply(m) {
        return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
        return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[3], a13 = ae[6];
        const a21 = ae[1], a22 = ae[4], a23 = ae[7];
        const a31 = ae[2], a32 = ae[5], a33 = ae[8];
        const b11 = be[0], b12 = be[3], b13 = be[6];
        const b21 = be[1], b22 = be[4], b23 = be[7];
        const b31 = be[2], b32 = be[5], b33 = be[8];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
    }
    multiplyScalar(s) {
        const te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
    }
    determinant() {
        const te = this.elements;
        const a2 = te[0], b2 = te[1], c1 = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i1 = te[8];
        return a2 * e * i1 - a2 * f * h - b2 * d * i1 + b2 * f * g + c1 * d * h - c1 * e * g;
    }
    getInverse(matrix, throwOnDegenerate) {
        if (throwOnDegenerate !== undefined) console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
        const me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
    }
    transpose() {
        let tmp;
        const m = this.elements;
        tmp = m[1];
        m[1] = m[3];
        m[3] = tmp;
        tmp = m[2];
        m[2] = m[6];
        m[6] = tmp;
        tmp = m[5];
        m[5] = m[7];
        m[7] = tmp;
        return this;
    }
    getNormalMatrix(matrix4) {
        return this.setFromMatrix4(matrix4).getInverse(this).transpose();
    }
    transposeIntoArray(r) {
        const m = this.elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
    }
    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
        const c1 = Math.cos(rotation);
        const s = Math.sin(rotation);
        this.set(sx * c1, sx * s, -sx * (c1 * cx + s * cy) + cx + tx, -sy * s, sy * c1, -sy * (-s * cx + c1 * cy) + cy + ty, 0, 0, 1);
    }
    scale(sx, sy) {
        const te = this.elements;
        te[0] *= sx;
        te[3] *= sx;
        te[6] *= sx;
        te[1] *= sy;
        te[4] *= sy;
        te[7] *= sy;
        return this;
    }
    rotate(theta) {
        const c1 = Math.cos(theta);
        const s = Math.sin(theta);
        const te = this.elements;
        const a11 = te[0], a12 = te[3], a13 = te[6];
        const a21 = te[1], a22 = te[4], a23 = te[7];
        te[0] = c1 * a11 + s * a21;
        te[3] = c1 * a12 + s * a22;
        te[6] = c1 * a13 + s * a23;
        te[1] = -s * a11 + c1 * a21;
        te[4] = -s * a12 + c1 * a22;
        te[7] = -s * a13 + c1 * a23;
        return this;
    }
    translate(tx, ty) {
        const te = this.elements;
        te[0] += tx * te[2];
        te[3] += tx * te[5];
        te[6] += tx * te[8];
        te[1] += ty * te[2];
        te[4] += ty * te[5];
        te[7] += ty * te[8];
        return this;
    }
    equals(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for(let i1 = 0; i1 < 9; i1++)if (te[i1] !== me[i1]) return false;
        return true;
    }
    fromArray(array, offset) {
        if (offset === undefined) offset = 0;
        for(let i1 = 0; i1 < 9; i1++)this.elements[i1] = array[i1 + offset];
        return this;
    }
    toArray(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
    }
    constructor(){
        this.elements = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ];
        if (arguments.length > 0) console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
    }
}
Matrix3.prototype.isMatrix3 = true;
const Matrix31 = Matrix3;
let _object3DId = 0;
const _v13 = new Vector31();
const _q1 = new Quaternion1();
const _m11 = new Matrix41();
const _target = new Vector31();
const _position = new Vector31();
const _scale = new Vector31();
const _quaternion1 = new Quaternion1();
const _xAxis = new Vector31(1, 0, 0);
const _yAxis = new Vector31(0, 1, 0);
const _zAxis = new Vector31(0, 0, 1);
const _addedEvent = {
    type: 'added'
};
const _removedEvent = {
    type: 'removed'
};
function Object3D() {
    Object.defineProperty(this, 'id', {
        value: _object3DId++
    });
    this.uuid = MathUtils1.generateUUID();
    this.name = '';
    this.type = 'Object3D';
    this.parent = null;
    this.children = [];
    this.up = Object3D.DefaultUp.clone();
    const position = new Vector31();
    const rotation = new Euler1();
    const quaternion = new Quaternion1();
    const scale = new Vector31(1, 1, 1);
    function onRotationChange() {
        quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
        rotation.setFromQuaternion(quaternion, undefined, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
        position: {
            configurable: true,
            enumerable: true,
            value: position
        },
        rotation: {
            configurable: true,
            enumerable: true,
            value: rotation
        },
        quaternion: {
            configurable: true,
            enumerable: true,
            value: quaternion
        },
        scale: {
            configurable: true,
            enumerable: true,
            value: scale
        },
        modelViewMatrix: {
            value: new Matrix41()
        },
        normalMatrix: {
            value: new Matrix31()
        }
    });
    this.matrix = new Matrix41();
    this.matrixWorld = new Matrix41();
    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers1();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.userData = {
    };
}
Object3D.DefaultUp = new Vector31(0, 1, 0);
Object3D.DefaultMatrixAutoUpdate = true;
Object3D.prototype = Object.assign(Object.create(EventDispatcher1.prototype), {
    constructor: Object3D,
    isObject3D: true,
    onBeforeRender: function() {
    },
    onAfterRender: function() {
    },
    applyMatrix4: function(matrix) {
        if (this.matrixAutoUpdate) this.updateMatrix();
        this.matrix.premultiply(matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    applyQuaternion: function(q) {
        this.quaternion.premultiply(q);
        return this;
    },
    setRotationFromAxisAngle: function(axis, angle) {
        // assumes axis is normalized
        this.quaternion.setFromAxisAngle(axis, angle);
    },
    setRotationFromEuler: function(euler) {
        this.quaternion.setFromEuler(euler, true);
    },
    setRotationFromMatrix: function(m) {
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
        this.quaternion.setFromRotationMatrix(m);
    },
    setRotationFromQuaternion: function(q) {
        // assumes q is normalized
        this.quaternion.copy(q);
    },
    rotateOnAxis: function(axis, angle) {
        // rotate object on axis in object space
        // axis is assumed to be normalized
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(_q1);
        return this;
    },
    rotateOnWorldAxis: function(axis, angle) {
        // rotate object on axis in world space
        // axis is assumed to be normalized
        // method assumes no rotated parent
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.premultiply(_q1);
        return this;
    },
    rotateX: function(angle) {
        return this.rotateOnAxis(_xAxis, angle);
    },
    rotateY: function(angle) {
        return this.rotateOnAxis(_yAxis, angle);
    },
    rotateZ: function(angle) {
        return this.rotateOnAxis(_zAxis, angle);
    },
    translateOnAxis: function(axis, distance) {
        // translate object by distance along axis in object space
        // axis is assumed to be normalized
        _v13.copy(axis).applyQuaternion(this.quaternion);
        this.position.add(_v13.multiplyScalar(distance));
        return this;
    },
    translateX: function(distance) {
        return this.translateOnAxis(_xAxis, distance);
    },
    translateY: function(distance) {
        return this.translateOnAxis(_yAxis, distance);
    },
    translateZ: function(distance) {
        return this.translateOnAxis(_zAxis, distance);
    },
    localToWorld: function(vector) {
        return vector.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function(vector) {
        return vector.applyMatrix4(_m11.getInverse(this.matrixWorld));
    },
    lookAt: function(x4, y4, z4) {
        // This method does not support objects having non-uniformly-scaled parent(s)
        if (x4.isVector3) _target.copy(x4);
        else _target.set(x4, y4, z4);
        const parent = this.parent;
        this.updateWorldMatrix(true, false);
        _position.setFromMatrixPosition(this.matrixWorld);
        if (this.isCamera || this.isLight) _m11.lookAt(_position, _target, this.up);
        else _m11.lookAt(_target, _position, this.up);
        this.quaternion.setFromRotationMatrix(_m11);
        if (parent) {
            _m11.extractRotation(parent.matrixWorld);
            _q1.setFromRotationMatrix(_m11);
            this.quaternion.premultiply(_q1.inverse());
        }
    },
    add: function(object) {
        if (arguments.length > 1) {
            for(let i1 = 0; i1 < arguments.length; i1++)this.add(arguments[i1]);
            return this;
        }
        if (object === this) {
            console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
            return this;
        }
        if (object && object.isObject3D) {
            if (object.parent !== null) object.parent.remove(object);
            object.parent = this;
            this.children.push(object);
            object.dispatchEvent(_addedEvent);
        } else console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
        return this;
    },
    remove: function(object) {
        if (arguments.length > 1) {
            for(let i1 = 0; i1 < arguments.length; i1++)this.remove(arguments[i1]);
            return this;
        }
        const index = this.children.indexOf(object);
        if (index !== -1) {
            object.parent = null;
            this.children.splice(index, 1);
            object.dispatchEvent(_removedEvent);
        }
        return this;
    },
    attach: function(object) {
        // adds object as a child of this, while maintaining the object's world transform
        this.updateWorldMatrix(true, false);
        _m11.getInverse(this.matrixWorld);
        if (object.parent !== null) {
            object.parent.updateWorldMatrix(true, false);
            _m11.multiply(object.parent.matrixWorld);
        }
        object.applyMatrix4(_m11);
        object.updateWorldMatrix(false, false);
        this.add(object);
        return this;
    },
    getObjectById: function(id) {
        return this.getObjectByProperty('id', id);
    },
    getObjectByName: function(name) {
        return this.getObjectByProperty('name', name);
    },
    getObjectByProperty: function(name, value) {
        if (this[name] === value) return this;
        for(let i1 = 0, l = this.children.length; i1 < l; i1++){
            const child = this.children[i1];
            const object = child.getObjectByProperty(name, value);
            if (object !== undefined) return object;
        }
        return undefined;
    },
    getWorldPosition: function(target) {
        if (target === undefined) {
            console.warn('THREE.Object3D: .getWorldPosition() target is now required');
            target = new Vector31();
        }
        this.updateMatrixWorld(true);
        return target.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function(target) {
        if (target === undefined) {
            console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
            target = new Quaternion1();
        }
        this.updateMatrixWorld(true);
        this.matrixWorld.decompose(_position, target, _scale);
        return target;
    },
    getWorldScale: function(target) {
        if (target === undefined) {
            console.warn('THREE.Object3D: .getWorldScale() target is now required');
            target = new Vector31();
        }
        this.updateMatrixWorld(true);
        this.matrixWorld.decompose(_position, _quaternion1, target);
        return target;
    },
    getWorldDirection: function(target) {
        if (target === undefined) {
            console.warn('THREE.Object3D: .getWorldDirection() target is now required');
            target = new Vector31();
        }
        this.updateMatrixWorld(true);
        const e = this.matrixWorld.elements;
        return target.set(e[8], e[9], e[10]).normalize();
    },
    raycast: function() {
    },
    traverse: function(callback) {
        callback(this);
        const children = this.children;
        for(let i1 = 0, l = children.length; i1 < l; i1++)children[i1].traverse(callback);
    },
    traverseVisible: function(callback) {
        if (this.visible === false) return;
        callback(this);
        const children = this.children;
        for(let i1 = 0, l = children.length; i1 < l; i1++)children[i1].traverseVisible(callback);
    },
    traverseAncestors: function(callback) {
        const parent = this.parent;
        if (parent !== null) {
            callback(parent);
            parent.traverseAncestors(callback);
        }
    },
    updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
    },
    updateMatrixWorld: function(force) {
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || force) {
            if (this.parent === null) this.matrixWorld.copy(this.matrix);
            else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            this.matrixWorldNeedsUpdate = false;
            force = true;
        }
        // update children
        const children = this.children;
        for(let i1 = 0, l = children.length; i1 < l; i1++)children[i1].updateMatrixWorld(force);
    },
    updateWorldMatrix: function(updateParents, updateChildren) {
        const parent = this.parent;
        if (updateParents === true && parent !== null) parent.updateWorldMatrix(true, false);
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.parent === null) this.matrixWorld.copy(this.matrix);
        else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        // update children
        if (updateChildren === true) {
            const children = this.children;
            for(let i1 = 0, l = children.length; i1 < l; i1++)children[i1].updateWorldMatrix(false, true);
        }
    },
    toJSON: function(meta) {
        // meta is a string when called from JSON.stringify
        const isRootObject = meta === undefined || typeof meta === 'string';
        const output = {
        };
        // meta is a hash used to collect geometries, materials.
        // not providing it implies that this is the root object
        // being serialized.
        if (isRootObject) {
            // initialize meta obj
            meta = {
                geometries: {
                },
                materials: {
                },
                textures: {
                },
                images: {
                },
                shapes: {
                }
            };
            output.metadata = {
                version: 4.5,
                type: 'Object',
                generator: 'Object3D.toJSON'
            };
        }
        // standard Object3D serialization
        const object = {
        };
        object.uuid = this.uuid;
        object.type = this.type;
        if (this.name !== '') object.name = this.name;
        if (this.castShadow === true) object.castShadow = true;
        if (this.receiveShadow === true) object.receiveShadow = true;
        if (this.visible === false) object.visible = false;
        if (this.frustumCulled === false) object.frustumCulled = false;
        if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
        if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
        object.layers = this.layers.mask;
        object.matrix = this.matrix.toArray();
        if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
        // object specific properties
        if (this.isInstancedMesh) {
            object.type = 'InstancedMesh';
            object.count = this.count;
            object.instanceMatrix = this.instanceMatrix.toJSON();
        }
        //
        function serialize(library, element) {
            if (library[element.uuid] === undefined) library[element.uuid] = element.toJSON(meta);
            return element.uuid;
        }
        if (this.isMesh || this.isLine || this.isPoints) {
            object.geometry = serialize(meta.geometries, this.geometry);
            const parameters = this.geometry.parameters;
            if (parameters !== undefined && parameters.shapes !== undefined) {
                const shapes = parameters.shapes;
                if (Array.isArray(shapes)) for(let i1 = 0, l = shapes.length; i1 < l; i1++){
                    const shape = shapes[i1];
                    serialize(meta.shapes, shape);
                }
                else serialize(meta.shapes, shapes);
            }
        }
        if (this.material !== undefined) {
            if (Array.isArray(this.material)) {
                const uuids = [];
                for(let i1 = 0, l = this.material.length; i1 < l; i1++)uuids.push(serialize(meta.materials, this.material[i1]));
                object.material = uuids;
            } else object.material = serialize(meta.materials, this.material);
        }
        //
        if (this.children.length > 0) {
            object.children = [];
            for(let i1 = 0; i1 < this.children.length; i1++)object.children.push(this.children[i1].toJSON(meta).object);
        }
        if (isRootObject) {
            const geometries = extractFromCache(meta.geometries);
            const materials = extractFromCache(meta.materials);
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            const shapes = extractFromCache(meta.shapes);
            if (geometries.length > 0) output.geometries = geometries;
            if (materials.length > 0) output.materials = materials;
            if (textures.length > 0) output.textures = textures;
            if (images.length > 0) output.images = images;
            if (shapes.length > 0) output.shapes = shapes;
        }
        output.object = object;
        var cache;
        return output;
    },
    clone: function(recursive) {
        return new this.constructor().copy(this, recursive);
    },
    copy: function(source, recursive) {
        if (recursive === undefined) recursive = true;
        this.name = source.name;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.rotation.order = source.rotation.order;
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.layers.mask = source.layers.mask;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) for(let i1 = 0; i1 < source.children.length; i1++){
            const child = source.children[i1];
            this.add(child.clone());
        }
        return this;
    }
});
const Object3D1 = Object3D;
class Vector3 {
    set(x, y, z) {
        if (z === undefined) z = this.z; // sprite.scale.set(x,y)
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setZ(z) {
        this.z = z;
        return this;
    }
    setComponent(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            default:
                throw new Error('index is out of range: ' + index);
        }
        return this;
    }
    getComponent(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error('index is out of range: ' + index);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    }
    add(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        return this;
    }
    sub(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
    }
    multiply(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
            return this.multiplyVectors(v, w);
        }
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
    }
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
    }
    multiplyVectors(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
    }
    applyEuler(euler) {
        if (!(euler && euler.isEuler)) console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
        return this.applyQuaternion(_quaternion3.setFromEuler(euler));
    }
    applyAxisAngle(axis, angle) {
        return this.applyQuaternion(_quaternion3.setFromAxisAngle(axis, angle));
    }
    applyMatrix3(m) {
        const x4 = this.x, y4 = this.y, z4 = this.z;
        const e = m.elements;
        this.x = e[0] * x4 + e[3] * y4 + e[6] * z4;
        this.y = e[1] * x4 + e[4] * y4 + e[7] * z4;
        this.z = e[2] * x4 + e[5] * y4 + e[8] * z4;
        return this;
    }
    applyNormalMatrix(m) {
        return this.applyMatrix3(m).normalize();
    }
    applyMatrix4(m) {
        const x4 = this.x, y4 = this.y, z4 = this.z;
        const e = m.elements;
        const w3 = 1 / (e[3] * x4 + e[7] * y4 + e[11] * z4 + e[15]);
        this.x = (e[0] * x4 + e[4] * y4 + e[8] * z4 + e[12]) * w3;
        this.y = (e[1] * x4 + e[5] * y4 + e[9] * z4 + e[13]) * w3;
        this.z = (e[2] * x4 + e[6] * y4 + e[10] * z4 + e[14]) * w3;
        return this;
    }
    applyQuaternion(q) {
        const x4 = this.x, y4 = this.y, z4 = this.z;
        const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
        // calculate quat * vector
        const ix = qw * x4 + qy * z4 - qz * y4;
        const iy = qw * y4 + qz * x4 - qx * z4;
        const iz = qw * z4 + qx * y4 - qy * x4;
        const iw = -qx * x4 - qy * y4 - qz * z4;
        // calculate result * inverse quat
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
    }
    project(camera) {
        return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
    }
    unproject(camera) {
        return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
    }
    transformDirection(m) {
        // input: THREE.Matrix4 affine matrix
        // vector interpreted as a direction
        const x4 = this.x, y4 = this.y, z4 = this.z;
        const e = m.elements;
        this.x = e[0] * x4 + e[4] * y4 + e[8] * z4;
        this.y = e[1] * x4 + e[5] * y4 + e[9] * z4;
        this.z = e[2] * x4 + e[6] * y4 + e[10] * z4;
        return this.normalize();
    }
    divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        return this;
    }
    clamp(min, max) {
        // assumes min < max, componentwise
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
    }
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    }
    // TODO lengthSquared?
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        return this;
    }
    cross(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
            return this.crossVectors(v, w);
        }
        return this.crossVectors(this, v);
    }
    crossVectors(a, b) {
        const ax = a.x, ay = a.y, az = a.z;
        const bx = b.x, by = b.y, bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
    }
    projectOnVector(v) {
        const denominator = v.lengthSq();
        if (denominator === 0) return this.set(0, 0, 0);
        const scalar = v.dot(this) / denominator;
        return this.copy(v).multiplyScalar(scalar);
    }
    projectOnPlane(planeNormal) {
        _vector2.copy(this).projectOnVector(planeNormal);
        return this.sub(_vector2);
    }
    reflect(normal) {
        // reflect incident vector off plane orthogonal to normal
        // normal is assumed to have unit length
        return this.sub(_vector2.copy(normal).multiplyScalar(2 * this.dot(normal)));
    }
    angleTo(v) {
        const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
        if (denominator === 0) return Math.PI / 2;
        const theta = this.dot(v) / denominator;
        // clamp, to handle numerical problems
        return Math.acos(MathUtils1.clamp(theta, -1, 1));
    }
    distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
        const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
    }
    manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    }
    setFromSpherical(s) {
        return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    }
    setFromSphericalCoords(radius, phi, theta) {
        const sinPhiRadius = Math.sin(phi) * radius;
        this.x = sinPhiRadius * Math.sin(theta);
        this.y = Math.cos(phi) * radius;
        this.z = sinPhiRadius * Math.cos(theta);
        return this;
    }
    setFromCylindrical(c) {
        return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    }
    setFromCylindricalCoords(radius, theta, y) {
        this.x = radius * Math.sin(theta);
        this.y = y;
        this.z = radius * Math.cos(theta);
        return this;
    }
    setFromMatrixPosition(m) {
        const e = m.elements;
        this.x = e[12];
        this.y = e[13];
        this.z = e[14];
        return this;
    }
    setFromMatrixScale(m) {
        const sx = this.setFromMatrixColumn(m, 0).length();
        const sy = this.setFromMatrixColumn(m, 1).length();
        const sz = this.setFromMatrixColumn(m, 2).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
    }
    setFromMatrixColumn(m, index) {
        return this.fromArray(m.elements, index * 4);
    }
    setFromMatrix3Column(m, index) {
        return this.fromArray(m.elements, index * 3);
    }
    equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z;
    }
    fromArray(array, offset) {
        if (offset === undefined) offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
    }
    toArray(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        return this;
    }
    constructor(x4 = 0, y4 = 0, z4 = 0){
        this.x = x4;
        this.y = y4;
        this.z = z4;
    }
}
Vector3.prototype.isVector3 = true;
const _vector2 = new Vector3();
const _quaternion3 = new Quaternion1();
const Vector31 = Vector3;
function PerspectiveCamera(fov, aspect, near, far) {
    Camera1.call(this);
    this.type = 'PerspectiveCamera';
    this.fov = fov !== undefined ? fov : 50;
    this.zoom = 1;
    this.near = near !== undefined ? near : 0.1;
    this.far = far !== undefined ? far : 2000;
    this.focus = 10;
    this.aspect = aspect !== undefined ? aspect : 1;
    this.view = null;
    this.filmGauge = 35; // width of the film (default in millimeters)
    this.filmOffset = 0; // horizontal film offset (same unit as gauge)
    this.updateProjectionMatrix();
}
PerspectiveCamera.prototype = Object.assign(Object.create(Camera1.prototype), {
    constructor: PerspectiveCamera,
    isPerspectiveCamera: true,
    copy: function(source, recursive) {
        Camera1.prototype.copy.call(this, source, recursive);
        this.fov = source.fov;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.aspect = source.aspect;
        this.view = source.view === null ? null : Object.assign({
        }, source.view);
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset;
        return this;
    },
    /**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
    setFocalLength: function(focalLength) {
        // see http://www.bobatkins.com/photography/technical/field_of_view.html
        const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
        this.fov = MathUtils1.RAD2DEG * 2 * Math.atan(vExtentSlope);
        this.updateProjectionMatrix();
    },
    /**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
    getFocalLength: function() {
        const vExtentSlope = Math.tan(MathUtils1.DEG2RAD * 0.5 * this.fov);
        return 0.5 * this.getFilmHeight() / vExtentSlope;
    },
    getEffectiveFOV: function() {
        return MathUtils1.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils1.DEG2RAD * 0.5 * this.fov) / this.zoom);
    },
    getFilmWidth: function() {
        // film not completely covered in portrait format (aspect < 1)
        return this.filmGauge * Math.min(this.aspect, 1);
    },
    getFilmHeight: function() {
        // film not completely covered in landscape format (aspect > 1)
        return this.filmGauge / Math.max(this.aspect, 1);
    },
    /**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
    setViewOffset: function(fullWidth, fullHeight, x5, y5, width1, height1) {
        this.aspect = fullWidth / fullHeight;
        if (this.view === null) this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        };
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x5;
        this.view.offsetY = y5;
        this.view.width = width1;
        this.view.height = height1;
        this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
        if (this.view !== null) this.view.enabled = false;
        this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
        const near = this.near;
        let top = near * Math.tan(MathUtils1.DEG2RAD * 0.5 * this.fov) / this.zoom;
        let height1 = 2 * top;
        let width1 = this.aspect * height1;
        let left = -0.5 * width1;
        const view = this.view;
        if (this.view !== null && this.view.enabled) {
            const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
            left += view.offsetX * width1 / fullWidth;
            top -= view.offsetY * height1 / fullHeight;
            width1 *= view.width / fullWidth;
            height1 *= view.height / fullHeight;
        }
        const skew = this.filmOffset;
        if (skew !== 0) left += near * skew / this.getFilmWidth();
        this.projectionMatrix.makePerspective(left, left + width1, top, top - height1, near, this.far);
        this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(meta) {
        const data = Object3D1.prototype.toJSON.call(this, meta);
        data.object.fov = this.fov;
        data.object.zoom = this.zoom;
        data.object.near = this.near;
        data.object.far = this.far;
        data.object.focus = this.focus;
        data.object.aspect = this.aspect;
        if (this.view !== null) data.object.view = Object.assign({
        }, this.view);
        data.object.filmGauge = this.filmGauge;
        data.object.filmOffset = this.filmOffset;
        return data;
    }
});
const PerspectiveCamera1 = PerspectiveCamera;
const fov = 90, aspect = 1;
function CubeCamera(near, far, renderTarget) {
    Object3D1.call(this);
    this.type = 'CubeCamera';
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
        console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
        return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera1(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector31(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera1(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector31(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera1(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector31(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera1(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector31(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera1(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector31(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera1(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector31(0, 0, -1));
    this.add(cameraNZ);
    this.update = function(renderer, scene) {
        if (this.parent === null) this.updateMatrixWorld();
        const currentXrEnabled = renderer.xr.enabled;
        const currentRenderTarget = renderer.getRenderTarget();
        renderer.xr.enabled = false;
        const generateMipmaps = renderTarget.texture.generateMipmaps;
        renderTarget.texture.generateMipmaps = false;
        renderer.setRenderTarget(renderTarget, 0);
        renderer.render(scene, cameraPX);
        renderer.setRenderTarget(renderTarget, 1);
        renderer.render(scene, cameraNX);
        renderer.setRenderTarget(renderTarget, 2);
        renderer.render(scene, cameraPY);
        renderer.setRenderTarget(renderTarget, 3);
        renderer.render(scene, cameraNY);
        renderer.setRenderTarget(renderTarget, 4);
        renderer.render(scene, cameraPZ);
        renderTarget.texture.generateMipmaps = generateMipmaps;
        renderer.setRenderTarget(renderTarget, 5);
        renderer.render(scene, cameraNZ);
        renderer.setRenderTarget(currentRenderTarget);
        renderer.xr.enabled = currentXrEnabled;
    };
    this.clear = function(renderer, color1, depth1, stencil) {
        const currentRenderTarget = renderer.getRenderTarget();
        for(let i1 = 0; i1 < 6; i1++){
            renderer.setRenderTarget(renderTarget, i1);
            renderer.clear(color1, depth1, stencil);
        }
        renderer.setRenderTarget(currentRenderTarget);
    };
}
CubeCamera.prototype = Object.create(Object3D1.prototype);
CubeCamera.prototype.constructor = CubeCamera;
const CubeCamera1 = CubeCamera;
function WebGLCubeRenderTarget(size, options, dummy) {
    if (Number.isInteger(options)) {
        console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');
    }
    WebGLRenderTarget1.call(this, size, size, options);
    this.texture.isWebGLCubeRenderTargetTexture = true; // HACK Why is texture not a CubeTexture?
}
WebGLCubeRenderTarget.prototype = Object.create(WebGLRenderTarget1.prototype);
WebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;
WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.format = RGBAFormat; // see #18859
    this.texture.encoding = texture.encoding;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: /* glsl */
        `\n\n			varying vec3 vWorldDirection;\n\n			vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n				return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n			}\n\n			void main() {\n\n				vWorldDirection = transformDirection( position, modelMatrix );\n\n				#include <begin_vertex>\n				#include <project_vertex>\n\n			}\n		`,
        fragmentShader: /* glsl */
        `\n\n			uniform sampler2D tEquirect;\n\n			varying vec3 vWorldDirection;\n\n			#include <common>\n\n			void main() {\n\n				vec3 direction = normalize( vWorldDirection );\n\n				vec2 sampleUV = equirectUv( direction );\n\n				gl_FragColor = texture2D( tEquirect, sampleUV );\n\n			}\n		`
    };
    const geometry = new BoxBufferGeometry1(5, 5, 5);
    const material = new ShaderMaterial1({
        name: 'CubemapFromEquirect',
        uniforms: cloneUniforms(shader.uniforms),
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader,
        side: BackSide,
        blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh1(geometry, material);
    const currentMinFilter = texture.minFilter;
    const currentRenderList = renderer.getRenderList();
    const currentRenderTarget = renderer.getRenderTarget();
    const currentRenderState = renderer.getRenderState();
    // Avoid blurred poles
    if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
    const camera = new CubeCamera1(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    renderer.setRenderTarget(currentRenderTarget);
    renderer.setRenderList(currentRenderList);
    renderer.setRenderState(currentRenderState);
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
};
const WebGLCubeRenderTarget1 = WebGLCubeRenderTarget;
export { WebGLCubeRenderTarget1 as WebGLCubeRenderTarget };
let _canvas;
const ImageUtils = {
    getDataURL: function(image) {
        if (/^data:/i.test(image.src)) return image.src;
        if (typeof HTMLCanvasElement == 'undefined') return image.src;
        let canvas;
        if (image instanceof HTMLCanvasElement) canvas = image;
        else {
            if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
            _canvas.width = image.width;
            _canvas.height = image.height;
            const context = _canvas.getContext('2d');
            if (image instanceof ImageData) context.putImageData(image, 0, 0);
            else context.drawImage(image, 0, 0, image.width, image.height);
        }
        if (canvas.width > 2048 || canvas.height > 2048) return canvas.toDataURL('image/jpeg', 0.6);
        else return canvas.toDataURL('image/png');
    }
};
const ImageUtils1 = ImageUtils;
let textureId = 0;
function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    Object.defineProperty(this, 'id', {
        value: textureId++
    });
    this.uuid = MathUtils1.generateUUID();
    this.name = '';
    this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
    this.mipmaps = [];
    this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
    this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
    this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
    this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    this.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;
    this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
    this.format = format !== undefined ? format : RGBAFormat;
    this.internalFormat = null;
    this.type = type !== undefined ? type : UnsignedByteType;
    this.offset = new Vector21(0, 0);
    this.repeat = new Vector21(1, 1);
    this.center = new Vector21(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix31();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
    // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
    //
    // Also changing the encoding after already used by a Material will not automatically make the Material
    // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
    this.encoding = encoding !== undefined ? encoding : LinearEncoding;
    this.version = 0;
    this.onUpdate = null;
}
Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.prototype = Object.assign(Object.create(EventDispatcher1.prototype), {
    constructor: Texture,
    isTexture: true,
    updateMatrix: function() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.name = source.name;
        this.image = source.image;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.internalFormat = source.internalFormat;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.center.copy(source.center);
        this.rotation = source.rotation;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrix.copy(source.matrix);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        this.encoding = source.encoding;
        return this;
    },
    toJSON: function(meta) {
        const isRootObject = meta === undefined || typeof meta === 'string';
        if (!isRootObject && meta.textures[this.uuid] !== undefined) return meta.textures[this.uuid];
        const output = {
            metadata: {
                version: 4.5,
                type: 'Texture',
                generator: 'Texture.toJSON'
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [
                this.repeat.x,
                this.repeat.y
            ],
            offset: [
                this.offset.x,
                this.offset.y
            ],
            center: [
                this.center.x,
                this.center.y
            ],
            rotation: this.rotation,
            wrap: [
                this.wrapS,
                this.wrapT
            ],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        if (this.image !== undefined) {
            // TODO: Move to THREE.Image
            const image = this.image;
            if (image.uuid === undefined) image.uuid = MathUtils1.generateUUID(); // UGH
            if (!isRootObject && meta.images[image.uuid] === undefined) {
                let url;
                if (Array.isArray(image)) {
                    // process array of images e.g. CubeTexture
                    url = [];
                    for(let i1 = 0, l = image.length; i1 < l; i1++)url.push(ImageUtils1.getDataURL(image[i1]));
                } else // process single image
                url = ImageUtils1.getDataURL(image);
                meta.images[image.uuid] = {
                    uuid: image.uuid,
                    url: url
                };
            }
            output.image = image.uuid;
        }
        if (!isRootObject) meta.textures[this.uuid] = output;
        return output;
    },
    dispose: function() {
        this.dispatchEvent({
            type: 'dispose'
        });
    },
    transformUv: function(uv) {
        if (this.mapping !== UVMapping) return uv;
        uv.applyMatrix3(this.matrix);
        if (uv.x < 0 || uv.x > 1) switch(this.wrapS){
            case RepeatWrapping:
                uv.x = uv.x - Math.floor(uv.x);
                break;
            case ClampToEdgeWrapping:
                uv.x = uv.x < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.x) % 2) === 1) uv.x = Math.ceil(uv.x) - uv.x;
                else uv.x = uv.x - Math.floor(uv.x);
                break;
        }
        if (uv.y < 0 || uv.y > 1) switch(this.wrapT){
            case RepeatWrapping:
                uv.y = uv.y - Math.floor(uv.y);
                break;
            case ClampToEdgeWrapping:
                uv.y = uv.y < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.y) % 2) === 1) uv.y = Math.ceil(uv.y) - uv.y;
                else uv.y = uv.y - Math.floor(uv.y);
                break;
        }
        if (this.flipY) uv.y = 1 - uv.y;
        return uv;
    }
});
Object.defineProperty(Texture.prototype, "needsUpdate", {
    set: function(value) {
        if (value === true) this.version++;
    }
});
const Texture1 = Texture;
function WebGLRenderTarget2(width1, height1, options) {
    this.width = width1;
    this.height = height1;
    this.scissor = new Vector41(0, 0, width1, height1);
    this.scissorTest = false;
    this.viewport = new Vector41(0, 0, width1, height1);
    options = options || {
    };
    this.texture = new Texture1(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.image = {
    };
    this.texture.image.width = width1;
    this.texture.image.height = height1;
    this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
    this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
    this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
}
WebGLRenderTarget2.prototype = Object.assign(Object.create(EventDispatcher1.prototype), {
    constructor: WebGLRenderTarget2,
    isWebGLRenderTarget: true,
    setSize: function(width1, height1) {
        if (this.width !== width1 || this.height !== height1) {
            this.width = width1;
            this.height = height1;
            this.texture.image.width = width1;
            this.texture.image.height = height1;
            this.dispose();
        }
        this.viewport.set(0, 0, width1, height1);
        this.scissor.set(0, 0, width1, height1);
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.width = source.width;
        this.height = source.height;
        this.viewport.copy(source.viewport);
        this.texture = source.texture.clone();
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.depthTexture = source.depthTexture;
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
});
const WebGLRenderTarget1 = WebGLRenderTarget2;
export { WebGLRenderTarget1 as WebGLRenderTarget };
function DataTexture(data, width1, height1, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    Texture1.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {
        data: data || null,
        width: width1 || 1,
        height: height1 || 1
    };
    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
}
DataTexture.prototype = Object.create(Texture1.prototype);
DataTexture.prototype.constructor = DataTexture;
DataTexture.prototype.isDataTexture = true;
const DataTexture1 = DataTexture;
const _vector11 = new Vector31();
const _vector21 = new Vector31();
const _normalMatrix = new Matrix31();
function Plane(normal2, constant) {
    // normal is assumed to be normalized
    this.normal = normal2 !== undefined ? normal2 : new Vector31(1, 0, 0);
    this.constant = constant !== undefined ? constant : 0;
}
Object.assign(Plane.prototype, {
    isPlane: true,
    set: function(normal2, constant) {
        this.normal.copy(normal2);
        this.constant = constant;
        return this;
    },
    setComponents: function(x5, y5, z5, w3) {
        this.normal.set(x5, y5, z5);
        this.constant = w3;
        return this;
    },
    setFromNormalAndCoplanarPoint: function(normal2, point) {
        this.normal.copy(normal2);
        this.constant = -point.dot(this.normal);
        return this;
    },
    setFromCoplanarPoints: function(a2, b2, c2) {
        const normal2 = _vector11.subVectors(c2, b2).cross(_vector21.subVectors(a2, b2)).normalize();
        // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
        this.setFromNormalAndCoplanarPoint(normal2, a2);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
    },
    normalize: function() {
        // Note: will lead to a divide by zero if the plane is invalid.
        const inverseNormalLength = 1 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
    },
    negate: function() {
        this.constant *= -1;
        this.normal.negate();
        return this;
    },
    distanceToPoint: function(point) {
        return this.normal.dot(point) + this.constant;
    },
    distanceToSphere: function(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
    },
    projectPoint: function(point, target) {
        if (target === undefined) {
            console.warn('THREE.Plane: .projectPoint() target is now required');
            target = new Vector31();
        }
        return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
    },
    intersectLine: function(line, target) {
        if (target === undefined) {
            console.warn('THREE.Plane: .intersectLine() target is now required');
            target = new Vector31();
        }
        const direction1 = line.delta(_vector11);
        const denominator = this.normal.dot(direction1);
        if (denominator === 0) {
            // line is coplanar, return origin
            if (this.distanceToPoint(line.start) === 0) return target.copy(line.start);
            // Unsure if this is the correct method to handle this case.
            return undefined;
        }
        const t = -(line.start.dot(this.normal) + this.constant) / denominator;
        if (t < 0 || t > 1) return undefined;
        return target.copy(direction1).multiplyScalar(t).add(line.start);
    },
    intersectsLine: function(line) {
        // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
        const startSign = this.distanceToPoint(line.start);
        const endSign = this.distanceToPoint(line.end);
        return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    },
    intersectsBox: function(box) {
        return box.intersectsPlane(this);
    },
    intersectsSphere: function(sphere) {
        return sphere.intersectsPlane(this);
    },
    coplanarPoint: function(target) {
        if (target === undefined) {
            console.warn('THREE.Plane: .coplanarPoint() target is now required');
            target = new Vector31();
        }
        return target.copy(this.normal).multiplyScalar(-this.constant);
    },
    applyMatrix4: function(matrix, optionalNormalMatrix) {
        const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
        const referencePoint = this.coplanarPoint(_vector11).applyMatrix4(matrix);
        const normal2 = this.normal.applyMatrix3(normalMatrix).normalize();
        this.constant = -referencePoint.dot(normal2);
        return this;
    },
    translate: function(offset) {
        this.constant -= offset.dot(this.normal);
        return this;
    },
    equals: function(plane) {
        return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
});
const Plane1 = Plane;
const _sphere1 = new Sphere1();
const _vector3 = new Vector31();
function Frustum(p0, p1, p2, p3, p4, p5) {
    this.planes = [
        p0 !== undefined ? p0 : new Plane1(),
        p1 !== undefined ? p1 : new Plane1(),
        p2 !== undefined ? p2 : new Plane1(),
        p3 !== undefined ? p3 : new Plane1(),
        p4 !== undefined ? p4 : new Plane1(),
        p5 !== undefined ? p5 : new Plane1()
    ];
}
Object.assign(Frustum.prototype, {
    set: function(p0, p1, p2, p3, p4, p5) {
        const planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(frustum) {
        const planes = this.planes;
        for(let i1 = 0; i1 < 6; i1++)planes[i1].copy(frustum.planes[i1]);
        return this;
    },
    setFromProjectionMatrix: function(m) {
        const planes = this.planes;
        const me = m.elements;
        const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
        const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
        const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
        const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
    },
    intersectsObject: function(object) {
        const geometry = object.geometry;
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
        return this.intersectsSphere(_sphere1);
    },
    intersectsSprite: function(sprite) {
        _sphere1.center.set(0, 0, 0);
        _sphere1.radius = 0.7071067811865476;
        _sphere1.applyMatrix4(sprite.matrixWorld);
        return this.intersectsSphere(_sphere1);
    },
    intersectsSphere: function(sphere) {
        const planes = this.planes;
        const center = sphere.center;
        const negRadius = -sphere.radius;
        for(let i1 = 0; i1 < 6; i1++){
            const distance = planes[i1].distanceToPoint(center);
            if (distance < negRadius) return false;
        }
        return true;
    },
    intersectsBox: function(box) {
        const planes = this.planes;
        for(let i1 = 0; i1 < 6; i1++){
            const plane = planes[i1];
            // corner at max distance
            _vector3.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            _vector3.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            _vector3.z = plane.normal.z > 0 ? box.max.z : box.min.z;
            if (plane.distanceToPoint(_vector3) < 0) return false;
        }
        return true;
    },
    containsPoint: function(point) {
        const planes = this.planes;
        for(let i1 = 0; i1 < 6; i1++)if (planes[i1].distanceToPoint(point) < 0) return false;
        return true;
    }
});
const Frustum1 = Frustum;
const _colorKeywords = {
    'aliceblue': 15792383,
    'antiquewhite': 16444375,
    'aqua': 65535,
    'aquamarine': 8388564,
    'azure': 15794175,
    'beige': 16119260,
    'bisque': 16770244,
    'black': 0,
    'blanchedalmond': 16772045,
    'blue': 255,
    'blueviolet': 9055202,
    'brown': 10824234,
    'burlywood': 14596231,
    'cadetblue': 6266528,
    'chartreuse': 8388352,
    'chocolate': 13789470,
    'coral': 16744272,
    'cornflowerblue': 6591981,
    'cornsilk': 16775388,
    'crimson': 14423100,
    'cyan': 65535,
    'darkblue': 139,
    'darkcyan': 35723,
    'darkgoldenrod': 12092939,
    'darkgray': 11119017,
    'darkgreen': 25600,
    'darkgrey': 11119017,
    'darkkhaki': 12433259,
    'darkmagenta': 9109643,
    'darkolivegreen': 5597999,
    'darkorange': 16747520,
    'darkorchid': 10040012,
    'darkred': 9109504,
    'darksalmon': 15308410,
    'darkseagreen': 9419919,
    'darkslateblue': 4734347,
    'darkslategray': 3100495,
    'darkslategrey': 3100495,
    'darkturquoise': 52945,
    'darkviolet': 9699539,
    'deeppink': 16716947,
    'deepskyblue': 49151,
    'dimgray': 6908265,
    'dimgrey': 6908265,
    'dodgerblue': 2003199,
    'firebrick': 11674146,
    'floralwhite': 16775920,
    'forestgreen': 2263842,
    'fuchsia': 16711935,
    'gainsboro': 14474460,
    'ghostwhite': 16316671,
    'gold': 16766720,
    'goldenrod': 14329120,
    'gray': 8421504,
    'green': 32768,
    'greenyellow': 11403055,
    'grey': 8421504,
    'honeydew': 15794160,
    'hotpink': 16738740,
    'indianred': 13458524,
    'indigo': 4915330,
    'ivory': 16777200,
    'khaki': 15787660,
    'lavender': 15132410,
    'lavenderblush': 16773365,
    'lawngreen': 8190976,
    'lemonchiffon': 16775885,
    'lightblue': 11393254,
    'lightcoral': 15761536,
    'lightcyan': 14745599,
    'lightgoldenrodyellow': 16448210,
    'lightgray': 13882323,
    'lightgreen': 9498256,
    'lightgrey': 13882323,
    'lightpink': 16758465,
    'lightsalmon': 16752762,
    'lightseagreen': 2142890,
    'lightskyblue': 8900346,
    'lightslategray': 7833753,
    'lightslategrey': 7833753,
    'lightsteelblue': 11584734,
    'lightyellow': 16777184,
    'lime': 65280,
    'limegreen': 3329330,
    'linen': 16445670,
    'magenta': 16711935,
    'maroon': 8388608,
    'mediumaquamarine': 6737322,
    'mediumblue': 205,
    'mediumorchid': 12211667,
    'mediumpurple': 9662683,
    'mediumseagreen': 3978097,
    'mediumslateblue': 8087790,
    'mediumspringgreen': 64154,
    'mediumturquoise': 4772300,
    'mediumvioletred': 13047173,
    'midnightblue': 1644912,
    'mintcream': 16121850,
    'mistyrose': 16770273,
    'moccasin': 16770229,
    'navajowhite': 16768685,
    'navy': 128,
    'oldlace': 16643558,
    'olive': 8421376,
    'olivedrab': 7048739,
    'orange': 16753920,
    'orangered': 16729344,
    'orchid': 14315734,
    'palegoldenrod': 15657130,
    'palegreen': 10025880,
    'paleturquoise': 11529966,
    'palevioletred': 14381203,
    'papayawhip': 16773077,
    'peachpuff': 16767673,
    'peru': 13468991,
    'pink': 16761035,
    'plum': 14524637,
    'powderblue': 11591910,
    'purple': 8388736,
    'rebeccapurple': 6697881,
    'red': 16711680,
    'rosybrown': 12357519,
    'royalblue': 4286945,
    'saddlebrown': 9127187,
    'salmon': 16416882,
    'sandybrown': 16032864,
    'seagreen': 3050327,
    'seashell': 16774638,
    'sienna': 10506797,
    'silver': 12632256,
    'skyblue': 8900331,
    'slateblue': 6970061,
    'slategray': 7372944,
    'slategrey': 7372944,
    'snow': 16775930,
    'springgreen': 65407,
    'steelblue': 4620980,
    'tan': 13808780,
    'teal': 32896,
    'thistle': 14204888,
    'tomato': 16737095,
    'turquoise': 4251856,
    'violet': 15631086,
    'wheat': 16113331,
    'white': 16777215,
    'whitesmoke': 16119285,
    'yellow': 16776960,
    'yellowgreen': 10145074
};
const _hslA = {
    h: 0,
    s: 0,
    l: 0
};
const _hslB = {
    h: 0,
    s: 0,
    l: 0
};
function Color(r, g, b2) {
    if (g === undefined && b2 === undefined) // r is THREE.Color, hex or string
    return this.set(r);
    return this.setRGB(r, g, b2);
}
function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 0.5) return q;
    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
    return p;
}
function SRGBToLinear(c2) {
    return c2 < 0.04045 ? c2 * 0.0773993808 : Math.pow(c2 * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c2) {
    return c2 < 0.0031308 ? c2 * 12.92 : 1.055 * Math.pow(c2, 0.41666) - 0.055;
}
Object.assign(Color.prototype, {
    isColor: true,
    r: 1,
    g: 1,
    b: 1,
    set: function(value) {
        if (value && value.isColor) this.copy(value);
        else if (typeof value === 'number') this.setHex(value);
        else if (typeof value === 'string') this.setStyle(value);
        return this;
    },
    setScalar: function(scalar) {
        this.r = scalar;
        this.g = scalar;
        this.b = scalar;
        return this;
    },
    setHex: function(hex) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        return this;
    },
    setRGB: function(r, g, b2) {
        this.r = r;
        this.g = g;
        this.b = b2;
        return this;
    },
    setHSL: function(h, s, l) {
        // h,s,l ranges are in 0.0 - 1.0
        h = MathUtils1.euclideanModulo(h, 1);
        s = MathUtils1.clamp(s, 0, 1);
        l = MathUtils1.clamp(l, 0, 1);
        if (s === 0) this.r = this.g = this.b = l;
        else {
            const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
            const q = 2 * l - p;
            this.r = hue2rgb(q, p, h + 1 / 3);
            this.g = hue2rgb(q, p, h);
            this.b = hue2rgb(q, p, h - 1 / 3);
        }
        return this;
    },
    setStyle: function(style) {
        function handleAlpha(string) {
            if (string === undefined) return;
            if (parseFloat(string) < 1) console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
        }
        let m;
        if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
            // rgb / hsl
            let color1;
            const name = m[1];
            const components = m[2];
            switch(name){
                case 'rgb':
                case 'rgba':
                    if (color1 = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        // rgb(255,0,0) rgba(255,0,0,0.5)
                        this.r = Math.min(255, parseInt(color1[1], 10)) / 255;
                        this.g = Math.min(255, parseInt(color1[2], 10)) / 255;
                        this.b = Math.min(255, parseInt(color1[3], 10)) / 255;
                        handleAlpha(color1[5]);
                        return this;
                    }
                    if (color1 = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                        this.r = Math.min(100, parseInt(color1[1], 10)) / 100;
                        this.g = Math.min(100, parseInt(color1[2], 10)) / 100;
                        this.b = Math.min(100, parseInt(color1[3], 10)) / 100;
                        handleAlpha(color1[5]);
                        return this;
                    }
                    break;
                case 'hsl':
                case 'hsla':
                    if (color1 = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                        const h = parseFloat(color1[1]) / 360;
                        const s = parseInt(color1[2], 10) / 100;
                        const l = parseInt(color1[3], 10) / 100;
                        handleAlpha(color1[5]);
                        return this.setHSL(h, s, l);
                    }
                    break;
            }
        } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
            // hex color
            const hex = m[1];
            const size = hex.length;
            if (size === 3) {
                // #ff0
                this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                return this;
            } else if (size === 6) {
                // #ff0000
                this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                return this;
            }
        }
        if (style && style.length > 0) return this.setColorName(style);
        return this;
    },
    setColorName: function(style) {
        // color keywords
        const hex = _colorKeywords[style];
        if (hex !== undefined) // red
        this.setHex(hex);
        else // unknown color
        console.warn('THREE.Color: Unknown color ' + style);
        return this;
    },
    clone: function() {
        return new this.constructor(this.r, this.g, this.b);
    },
    copy: function(color1) {
        this.r = color1.r;
        this.g = color1.g;
        this.b = color1.b;
        return this;
    },
    copyGammaToLinear: function(color1, gammaFactor) {
        if (gammaFactor === undefined) gammaFactor = 2;
        this.r = Math.pow(color1.r, gammaFactor);
        this.g = Math.pow(color1.g, gammaFactor);
        this.b = Math.pow(color1.b, gammaFactor);
        return this;
    },
    copyLinearToGamma: function(color1, gammaFactor) {
        if (gammaFactor === undefined) gammaFactor = 2;
        const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
        this.r = Math.pow(color1.r, safeInverse);
        this.g = Math.pow(color1.g, safeInverse);
        this.b = Math.pow(color1.b, safeInverse);
        return this;
    },
    convertGammaToLinear: function(gammaFactor) {
        this.copyGammaToLinear(this, gammaFactor);
        return this;
    },
    convertLinearToGamma: function(gammaFactor) {
        this.copyLinearToGamma(this, gammaFactor);
        return this;
    },
    copySRGBToLinear: function(color1) {
        this.r = SRGBToLinear(color1.r);
        this.g = SRGBToLinear(color1.g);
        this.b = SRGBToLinear(color1.b);
        return this;
    },
    copyLinearToSRGB: function(color1) {
        this.r = LinearToSRGB(color1.r);
        this.g = LinearToSRGB(color1.g);
        this.b = LinearToSRGB(color1.b);
        return this;
    },
    convertSRGBToLinear: function() {
        this.copySRGBToLinear(this);
        return this;
    },
    convertLinearToSRGB: function() {
        this.copyLinearToSRGB(this);
        return this;
    },
    getHex: function() {
        return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
    },
    getHexString: function() {
        return ('000000' + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function(target) {
        // h,s,l ranges are in 0.0 - 1.0
        if (target === undefined) {
            console.warn('THREE.Color: .getHSL() target is now required');
            target = {
                h: 0,
                s: 0,
                l: 0
            };
        }
        const r = this.r, g = this.g, b2 = this.b;
        const max = Math.max(r, g, b2);
        const min = Math.min(r, g, b2);
        let hue, saturation;
        const lightness = (min + max) / 2;
        if (min === max) {
            hue = 0;
            saturation = 0;
        } else {
            const delta = max - min;
            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
            switch(max){
                case r:
                    hue = (g - b2) / delta + (g < b2 ? 6 : 0);
                    break;
                case g:
                    hue = (b2 - r) / delta + 2;
                    break;
                case b2:
                    hue = (r - g) / delta + 4;
                    break;
            }
            hue /= 6;
        }
        target.h = hue;
        target.s = saturation;
        target.l = lightness;
        return target;
    },
    getStyle: function() {
        return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
    },
    offsetHSL: function(h, s, l) {
        this.getHSL(_hslA);
        _hslA.h += h;
        _hslA.s += s;
        _hslA.l += l;
        this.setHSL(_hslA.h, _hslA.s, _hslA.l);
        return this;
    },
    add: function(color1) {
        this.r += color1.r;
        this.g += color1.g;
        this.b += color1.b;
        return this;
    },
    addColors: function(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
    },
    addScalar: function(s) {
        this.r += s;
        this.g += s;
        this.b += s;
        return this;
    },
    sub: function(color1) {
        this.r = Math.max(0, this.r - color1.r);
        this.g = Math.max(0, this.g - color1.g);
        this.b = Math.max(0, this.b - color1.b);
        return this;
    },
    multiply: function(color1) {
        this.r *= color1.r;
        this.g *= color1.g;
        this.b *= color1.b;
        return this;
    },
    multiplyScalar: function(s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;
        return this;
    },
    lerp: function(color1, alpha) {
        this.r += (color1.r - this.r) * alpha;
        this.g += (color1.g - this.g) * alpha;
        this.b += (color1.b - this.b) * alpha;
        return this;
    },
    lerpHSL: function(color1, alpha) {
        this.getHSL(_hslA);
        color1.getHSL(_hslB);
        const h = MathUtils1.lerp(_hslA.h, _hslB.h, alpha);
        const s = MathUtils1.lerp(_hslA.s, _hslB.s, alpha);
        const l = MathUtils1.lerp(_hslA.l, _hslB.l, alpha);
        this.setHSL(h, s, l);
        return this;
    },
    equals: function(c2) {
        return c2.r === this.r && c2.g === this.g && c2.b === this.b;
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        this.r = array[offset];
        this.g = array[offset + 1];
        this.b = array[offset + 2];
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
    },
    fromBufferAttribute: function(attribute, index) {
        this.r = attribute.getX(index);
        this.g = attribute.getY(index);
        this.b = attribute.getZ(index);
        if (attribute.normalized === true) {
            // assuming Uint8Array
            this.r /= 255;
            this.g /= 255;
            this.b /= 255;
        }
        return this;
    },
    toJSON: function() {
        return this.getHex();
    }
});
Color.NAMES = _colorKeywords;
const Color1 = Color;
class Vector2 {
    get width() {
        return this.x;
    }
    set width(value) {
        this.x = value;
    }
    get height() {
        return this.y;
    }
    set height(value) {
        this.y = value;
    }
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setComponent(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            default:
                throw new Error('index is out of range: ' + index);
        }
        return this;
    }
    getComponent(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error('index is out of range: ' + index);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    }
    add(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
    }
    sub(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
    }
    multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
    }
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
    }
    divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
    }
    applyMatrix3(m) {
        const x5 = this.x, y5 = this.y;
        const e = m.elements;
        this.x = e[0] * x5 + e[3] * y5 + e[6];
        this.y = e[1] * x5 + e[4] * y5 + e[7];
        return this;
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
    }
    clamp(min, max) {
        // assumes min < max, componentwise
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
    }
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y;
    }
    cross(v) {
        return this.x * v.y - this.y * v.x;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    angle() {
        // computes the angle in radians with respect to the positive x-axis
        const angle = Math.atan2(-this.y, -this.x) + Math.PI;
        return angle;
    }
    distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
        const dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
    }
    manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        return this;
    }
    equals(v) {
        return v.x === this.x && v.y === this.y;
    }
    fromArray(array, offset) {
        if (offset === undefined) offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
    }
    toArray(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        return this;
    }
    rotateAround(center, angle) {
        const c2 = Math.cos(angle), s = Math.sin(angle);
        const x5 = this.x - center.x;
        const y5 = this.y - center.y;
        this.x = x5 * c2 - y5 * s + center.x;
        this.y = x5 * s + y5 * c2 + center.y;
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        return this;
    }
    constructor(x5 = 0, y5 = 0){
        this.x = x5;
        this.y = y5;
    }
}
Vector2.prototype.isVector2 = true;
const Vector21 = Vector2;
/**
 * Uniforms library for shared webgl shaders
 */
const UniformsLib = {
    common: {
        diffuse: {
            value: new Color1(15658734)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new Matrix31()
        },
        uv2Transform: {
            value: new Matrix31()
        },
        alphaMap: {
            value: null
        }
    },
    specularmap: {
        specularMap: {
            value: null
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        refractionRatio: {
            value: 0.98
        },
        maxMipLevel: {
            value: 0
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new Vector21(1, 1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 0.00025
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2000
        },
        fogColor: {
            value: new Color1(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {
                },
                color: {
                }
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {
                },
                shadowNormalBias: {
                },
                shadowRadius: {
                },
                shadowMapSize: {
                }
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {
                },
                position: {
                },
                direction: {
                },
                distance: {
                },
                coneCos: {
                },
                penumbraCos: {
                },
                decay: {
                }
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {
                },
                shadowNormalBias: {
                },
                shadowRadius: {
                },
                shadowMapSize: {
                }
            }
        },
        spotShadowMap: {
            value: []
        },
        spotShadowMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {
                },
                position: {
                },
                decay: {
                },
                distance: {
                }
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {
                },
                shadowNormalBias: {
                },
                shadowRadius: {
                },
                shadowMapSize: {
                },
                shadowCameraNear: {
                },
                shadowCameraFar: {
                }
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {
                },
                skyColor: {
                },
                groundColor: {
                }
            }
        },
        // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
        rectAreaLights: {
            value: [],
            properties: {
                color: {
                },
                position: {
                },
                width: {
                },
                height: {
                }
            }
        }
    },
    points: {
        diffuse: {
            value: new Color1(15658734)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        uvTransform: {
            value: new Matrix31()
        }
    },
    sprite: {
        diffuse: {
            value: new Color1(15658734)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new Vector21(0.5, 0.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        uvTransform: {
            value: new Matrix31()
        }
    }
};
const UniformsLib1 = UniformsLib;
import { WebGLAnimation } from './webgl/WebGLAnimation.js';
function WebGLAttributes(gl, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    const buffers = new WeakMap();
    function createBuffer(attribute, bufferType) {
        const array = attribute.array;
        const usage = attribute.usage;
        const buffer = gl.createBuffer();
        gl.bindBuffer(bufferType, buffer);
        gl.bufferData(bufferType, array, usage);
        attribute.onUploadCallback();
        let type = gl.FLOAT;
        if (array instanceof Float32Array) type = gl.FLOAT;
        else if (array instanceof Float64Array) console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
        else if (array instanceof Uint16Array) type = gl.UNSIGNED_SHORT;
        else if (array instanceof Int16Array) type = gl.SHORT;
        else if (array instanceof Uint32Array) type = gl.UNSIGNED_INT;
        else if (array instanceof Int32Array) type = gl.INT;
        else if (array instanceof Int8Array) type = gl.BYTE;
        else if (array instanceof Uint8Array) type = gl.UNSIGNED_BYTE;
        return {
            buffer: buffer,
            type: type,
            bytesPerElement: array.BYTES_PER_ELEMENT,
            version: attribute.version
        };
    }
    function updateBuffer(buffer, attribute, bufferType) {
        const array = attribute.array;
        const updateRange = attribute.updateRange;
        gl.bindBuffer(bufferType, buffer);
        if (updateRange.count === -1) // Not using update ranges
        gl.bufferSubData(bufferType, 0, array);
        else {
            if (isWebGL2) gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
            else gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
            updateRange.count = -1; // reset range
        }
    }
    //
    function get(attribute) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        return buffers.get(attribute);
    }
    function remove(attribute) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        const data = buffers.get(attribute);
        if (data) {
            gl.deleteBuffer(data.buffer);
            buffers.delete(attribute);
        }
    }
    function update(attribute, bufferType) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        const data = buffers.get(attribute);
        if (data === undefined) buffers.set(attribute, createBuffer(attribute, bufferType));
        else if (data.version < attribute.version) {
            updateBuffer(data.buffer, attribute, bufferType);
            data.version = attribute.version;
        }
    }
    return {
        get: get,
        remove: remove,
        update: update
    };
}
const WebGLAttributes1 = WebGLAttributes;
// PlaneBufferGeometry
class PlaneBufferGeometry extends BufferGeometry1 {
    constructor(width1, height1, widthSegments1, heightSegments1){
        super();
        this.type = 'PlaneBufferGeometry';
        this.parameters = {
            width: width1,
            height: height1,
            widthSegments: widthSegments1,
            heightSegments: heightSegments1
        };
        width1 = width1 || 1;
        height1 = height1 || 1;
        const width_half = width1 / 2;
        const height_half = height1 / 2;
        const gridX = Math.floor(widthSegments1) || 1;
        const gridY = Math.floor(heightSegments1) || 1;
        const gridX1 = gridX + 1;
        const gridY1 = gridY + 1;
        const segment_width = width1 / gridX;
        const segment_height = height1 / gridY;
        // buffers
        const indices1 = [];
        const vertices1 = [];
        const normals1 = [];
        const uvs1 = [];
        // generate vertices, normals and uvs
        for(let iy = 0; iy < gridY1; iy++){
            const y6 = iy * segment_height - height_half;
            for(let ix = 0; ix < gridX1; ix++){
                const x6 = ix * segment_width - width_half;
                vertices1.push(x6, -y6, 0);
                normals1.push(0, 0, 1);
                uvs1.push(ix / gridX);
                uvs1.push(1 - iy / gridY);
            }
        }
        // indices
        for(let iy = 0; iy < gridY; iy++)for(let ix = 0; ix < gridX; ix++){
            const a2 = ix + gridX1 * iy;
            const b2 = ix + gridX1 * (iy + 1);
            const c2 = ix + 1 + gridX1 * (iy + 1);
            const d = ix + 1 + gridX1 * iy;
            // faces
            indices1.push(a2, b2, d);
            indices1.push(b2, c2, d);
        }
        // build geometry
        this.setIndex(indices1);
        this.setAttribute('position', new Float32BufferAttribute1(vertices1, 3));
        this.setAttribute('normal', new Float32BufferAttribute1(normals1, 3));
        this.setAttribute('uv', new Float32BufferAttribute1(uvs1, 2));
    }
}
const PlaneBufferGeometry1 = PlaneBufferGeometry;
const alphamap_fragment = /* glsl */
`\n#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n`;
const alphamap_pars_fragment = /* glsl */
`\n#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n`;
const alphatest_fragment = /* glsl */
`\n#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n`;
const aomap_fragment = /* glsl */
`\n#ifdef USE_AOMAP\n\n	// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\n	#endif\n\n#endif\n`;
const aomap_pars_fragment = /* glsl */
`\n#ifdef USE_AOMAP\n\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n\n#endif\n`;
const begin_vertex = /* glsl */
`\nvec3 transformed = vec3( position );\n`;
const beginnormal_vertex = /* glsl */
`\nvec3 objectNormal = vec3( normal );\n\n#ifdef USE_TANGENT\n\n	vec3 objectTangent = vec3( tangent.xyz );\n\n#endif\n`;
const bsdfs = /* glsl */
`\n\n// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via 'environmentBRDF' from "Physically Based Shading on Mobile"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n	vec4 r = roughness * c0 + c1;\n\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n}\n\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n	// based upon Frostbite 3 Moving to Physically-based Rendering\n	// page 32, equation 26: E[window1]\n	// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n	// this is intended to be used on spot and point lights who are represented as luminous intensity\n	// but who must be converted to luminous irradiance for surface lighting calculation\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\n	if( cutoffDistance > 0.0 ) {\n\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n	}\n\n	return distanceFalloff;\n\n#else\n\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n	}\n\n	return 1.0;\n\n#endif\n\n}\n\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\n	return RECIPROCAL_PI * diffuseColor;\n\n} // validated\n\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\n	// Original approximation by Christophe Schlick '94\n	// float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n	// Optimized variant (presented by Epic at SIGGRAPH '13)\n	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n} // validated\n\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\n	// See F_Schlick\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\n	return Fr * fresnel + F0;\n\n}\n\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (34)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is "roughness squared" in Disneys reparameterization\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n	// geometry term (normalized) = G(l)G(v) / 4(nl)(nv)\n	// also see #12151\n\n	float a2 = pow2( alpha );\n\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\n	return 1.0 / ( gl * gv );\n\n} // validated\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n	float a2 = pow2( alpha );\n\n	// dotNL and dotNV are explicitly swapped. This is not a mistake.\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n	return 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is "roughness squared" in Disneys reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n	float a2 = pow2( alpha );\n\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n	return RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\n	float alpha = pow2( roughness ); // UE4's roughness\n\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n	vec3 F = F_Schlick( specularColor, dotLH );\n\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n	float D = D_GGX( alpha, dotNH );\n\n	return F * ( G * D );\n\n} // validated\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n\n	float dotNV = saturate( dot( N, V ) );\n\n	// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\n	uv = uv * LUT_SCALE + LUT_BIAS;\n\n	return uv;\n\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\n	// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n	// An approximation of the form factor of a horizon-clipped rectangle.\n\n	float l = length( f );\n\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\n	float x = dot( v1, v2 );\n\n	float y = abs( x );\n\n	// rational polynomial approximation to theta / sin( theta ) / 2PI\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\n	return cross( v1, v2 ) * theta_sintheta;\n\n}\n\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\n	// bail if point is on back side of plane of light\n	// assumes ccw winding order of light vertices\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\n	// construct orthonormal basis around N\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\n	// compute transform\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\n	// transform rect\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\n	// project rect onto sphere\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n\n	// calculate vector form factor\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\n	// adjust for horizon clipping\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n/*\n	// alternate method of adjusting for horizon clipping (see referece)\n	// refactoring required\n	float len = length( vectorFormFactor );\n	float z = vectorFormFactor.z / len;\n\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n\n	// tabulated horizon-clipped sphere, apparently...\n	vec2 uv = vec2( z * 0.5 + 0.5, len );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n\n	float scale = texture2D( ltc_2, uv ).w;\n\n	float result = len * scale;\n*/\n\n	return vec3( result );\n\n}\n\n// End Rect Area Light\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\n	float dotNV = saturate( dot( normal, viewDir ) );\n\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\n	return specularColor * brdf.x + brdf.y;\n\n} // validated\n\n// Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"\n// Approximates multiscattering in order to preserve energy.\n// http://www.jcgt.org/published/0008/01/03/\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21\n	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n\n	// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n	return 0.25;\n\n}\n\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n	//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n	//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n	vec3 F = F_Schlick( specularColor, dotLH );\n\n	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n	float D = D_BlinnPhong( shininess, dotNH );\n\n	return F * ( G * D );\n\n} // validated\n\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\n\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n\n#if defined( USE_SHEEN )\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L94\nfloat D_Charlie(float roughness, float NoH) {\n	// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125); // 2^(-14/2), so sin2h^2 > 0 in fp16\n	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L136\nfloat V_Neubelt(float NoV, float NoL) {\n	// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\n\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n\n}\n\n#endif\n`;
const bumpmap_pars_fragment = /* glsl */
`\n#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n	// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n	// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\n	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n`;
const clipping_planes_fragment = /* glsl */
`\n#if NUM_CLIPPING_PLANES > 0\n\n	vec4 plane;\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\n	}\n	#pragma unroll_loop_end\n\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\n		bool clipped = true;\n\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\n		}\n		#pragma unroll_loop_end\n\n		if ( clipped ) discard;\n\n	#endif\n\n#endif\n`;
const clipping_planes_pars_fragment = /* glsl */
`\n#if NUM_CLIPPING_PLANES > 0\n\n	varying vec3 vClipPosition;\n\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n\n#endif\n`;
const clipping_planes_pars_vertex = /* glsl */
`\n#if NUM_CLIPPING_PLANES > 0\n\n	varying vec3 vClipPosition;\n\n#endif\n`;
const clipping_planes_vertex = /* glsl */
`\n#if NUM_CLIPPING_PLANES > 0\n\n	vClipPosition = - mvPosition.xyz;\n\n#endif\n`;
const color_fragment = /* glsl */
`\n#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif\n`;
const color_pars_fragment = /* glsl */
`\n#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n`;
const color_pars_vertex = /* glsl */
`\n#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\n	varying vec3 vColor;\n\n#endif\n`;
const color_vertex = /* glsl */
`\n#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\n	vColor = vec3( 1.0 );\n\n#endif\n\n#ifdef USE_COLOR\n\n	vColor.xyz *= color.xyz;\n\n#endif\n\n#ifdef USE_INSTANCING_COLOR\n\n	vColor.xyz *= instanceColor.xyz;\n\n#endif\n`;
const common = /* glsl */
`\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n\n#ifndef saturate\n// <tonemapping_pars_fragment> may have defined saturate() already\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\n\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\n\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n	// dir can be either a direction vector or a normal vector\n	// upper-left 3x3 of matrix is assumed to be orthogonal\n\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	float distance = dot( planeNormal, point - pointOnPlane );\n\n	return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nmat3 transposeMat3( const in mat3 m ) {\n\n	mat3 tmp;\n\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n	return tmp;\n\n}\n\n// https://en.wikipedia.org/wiki/Relative_luminance\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\n	return dot( weights, color.rgb );\n\n}\n\nbool isPerspectiveMatrix( mat4 m ) {\n\n	return m[ 2 ][ 3 ] == - 1.0;\n\n}\n\nvec2 equirectUv( in vec3 dir ) {\n\n	// dir is assumed to be unit length\n\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n	return vec2( u, v );\n\n}\n`;
const cube_uv_reflection_fragment = /* glsl */
`\n#ifdef ENVMAP_TYPE_CUBE_UV\n\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n\n	// These shader functions convert between the UV coordinates of a single face of\n	// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n	// sampling a textureCube (not generally normalized ).\n\n	float getFace( vec3 direction ) {\n\n		vec3 absDirection = abs( direction );\n\n		float face = - 1.0;\n\n		if ( absDirection.x > absDirection.z ) {\n\n			if ( absDirection.x > absDirection.y )\n\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n\n			else\n\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n\n		} else {\n\n			if ( absDirection.z > absDirection.y )\n\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n\n			else\n\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n\n		}\n\n		return face;\n\n	}\n\n	// RH coordinate system; PMREM face-indexing convention\n	vec2 getUV( vec3 direction, float face ) {\n\n		vec2 uv;\n\n		if ( face == 0.0 ) {\n\n			uv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x\n\n		} else if ( face == 1.0 ) {\n\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y\n\n		} else if ( face == 2.0 ) {\n\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z\n\n		} else if ( face == 3.0 ) {\n\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x\n\n		} else if ( face == 4.0 ) {\n\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y\n\n		} else {\n\n			uv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z\n\n		}\n\n		return 0.5 * ( uv + 1.0 );\n\n	}\n\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\n		float face = getFace( direction );\n\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n\n		float faceSize = exp2( mipInt );\n\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\n		vec2 f = fract( uv );\n\n		uv += 0.5 - f;\n\n		if ( face > 2.0 ) {\n\n			uv.y += faceSize;\n\n			face -= 3.0;\n\n		}\n\n		uv.x += face * faceSize;\n\n		if ( mipInt < cubeUV_maxMipLevel ) {\n\n			uv.y += 2.0 * cubeUV_maxTileSize;\n\n		}\n\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\n		uv *= texelSize;\n\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\n		uv.x += texelSize;\n\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\n		uv.y += texelSize;\n\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\n		uv.x -= texelSize;\n\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\n		vec3 tm = mix( tl, tr, f.x );\n\n		vec3 bm = mix( bl, br, f.x );\n\n		return mix( tm, bm, f.y );\n\n	}\n\n	// These defines must match with PMREMGenerator\n\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n\n	float roughnessToMip( float roughness ) {\n\n		float mip = 0.0;\n\n		if ( roughness >= r1 ) {\n\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\n		} else if ( roughness >= r4 ) {\n\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\n		} else if ( roughness >= r5 ) {\n\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\n		} else if ( roughness >= r6 ) {\n\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\n		} else {\n\n			mip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25\n		}\n\n		return mip;\n\n	}\n\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\n		float mipF = fract( mip );\n\n		float mipInt = floor( mip );\n\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\n		if ( mipF == 0.0 ) {\n\n			return vec4( color0, 1.0 );\n\n		} else {\n\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n\n		}\n\n	}\n\n#endif\n`;
const defaultnormal_vertex = /* glsl */
`\nvec3 transformedNormal = objectNormal;\n\n#ifdef USE_INSTANCING\n\n	// this is in lieu of a per-instance normal-matrix\n	// shear transforms in the instance matrix are not supported\n\n	mat3 m = mat3( instanceMatrix );\n\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\n	transformedNormal = m * transformedNormal;\n\n#endif\n\ntransformedNormal = normalMatrix * transformedNormal;\n\n#ifdef FLIP_SIDED\n\n	transformedNormal = - transformedNormal;\n\n#endif\n\n#ifdef USE_TANGENT\n\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n	#ifdef FLIP_SIDED\n\n		transformedTangent = - transformedTangent;\n\n	#endif\n\n#endif\n`;
const displacementmap_pars_vertex = /* glsl */
`\n#ifdef USE_DISPLACEMENTMAP\n\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n\n#endif\n`;
const displacementmap_vertex = /* glsl */
`\n#ifdef USE_DISPLACEMENTMAP\n\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n\n#endif\n`;
const emissivemap_fragment = /* glsl */
`\n#ifdef USE_EMISSIVEMAP\n\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n	totalEmissiveRadiance *= emissiveColor.rgb;\n\n#endif\n`;
const emissivemap_pars_fragment = /* glsl */
`\n#ifdef USE_EMISSIVEMAP\n\n	uniform sampler2D emissiveMap;\n\n#endif\n`;
const encodings_fragment = /* glsl */
`\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n`;
const encodings_pars_fragment = /* glsl */
`\n// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\n\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\n\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\n\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\n\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\n\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\n\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\n\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n	// return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\n\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\n\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	// NOTE: The implementation with min causes the shader to not compile on\n	// a common Alcatel A502DL in Chrome 78/Android 8.1. Some research suggests \n	// that the chipset is Mediatek MT6739 w/ IMG PowerVR GE8100 GPU.\n	// D = min( floor( D ) / 255.0, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\n\n// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n\n// M matrix, for encoding\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\n\n// Inverse M matrix, for decoding\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}\n`;
const envmap_fragment = /* glsl */
`\n#ifdef USE_ENVMAP\n\n	#ifdef ENV_WORLDPOS\n\n		vec3 cameraToFrag;\n\n		if ( isOrthographic ) {\n\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\n		} else {\n\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n\n		}\n\n		// Transforming Normal Vectors with the Inverse Transformation\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\n	#else\n\n		vec4 envColor = vec4( 0.0 );\n\n	#endif\n\n	#ifndef ENVMAP_TYPE_CUBE_UV\n\n		envColor = envMapTexelToLinear( envColor );\n\n	#endif\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n`;
const envmap_common_pars_fragment = /* glsl */
`\n#ifdef USE_ENVMAP\n\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif\n`;
const envmap_pars_fragment = /* glsl */
`\n#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		#define ENV_WORLDPOS\n\n	#endif\n\n	#ifdef ENV_WORLDPOS\n\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n\n#endif\n`;
const envmap_pars_vertex = /* glsl */
`\n#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\n		#define ENV_WORLDPOS\n\n	#endif\n\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n\n	#else\n\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n\n	#endif\n\n#endif\n`;
const envmap_vertex = /* glsl */
`\n#ifdef USE_ENVMAP\n\n	#ifdef ENV_WORLDPOS\n\n		vWorldPosition = worldPosition.xyz;\n\n	#else\n\n		vec3 cameraToVertex;\n\n		if ( isOrthographic ) {\n\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\n		} else {\n\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n		}\n\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vReflect = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#endif\n\n#endif\n`;
const fog_vertex = /* glsl */
`\n#ifdef USE_FOG\n\n	fogDepth = - mvPosition.z;\n\n#endif\n`;
const fog_pars_vertex = /* glsl */
`\n#ifdef USE_FOG\n\n	varying float fogDepth;\n\n#endif\n`;
const fog_fragment = /* glsl */
`\n#ifdef USE_FOG\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\n	#endif\n\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\n#endif\n`;
const fog_pars_fragment = /* glsl */
`\n#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n	varying float fogDepth;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n\n	#endif\n\n#endif\n`;
const gradientmap_pars_fragment = /* glsl */
`\n\n#ifdef USE_GRADIENTMAP\n\n	uniform sampler2D gradientMap;\n\n#endif\n\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\n	// dotNL will be from -1.0 to 1.0\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\n	#ifdef USE_GRADIENTMAP\n\n		return texture2D( gradientMap, coord ).rgb;\n\n	#else\n\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\n	#endif\n\n}\n`;
const lightmap_fragment = /* glsl */
`\n#ifdef USE_LIGHTMAP\n\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage\n\n#endif\n`;
const lightmap_pars_fragment = /* glsl */
`\n#ifdef USE_LIGHTMAP\n\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n\n#endif\n`;
const lights_lambert_vertex = /* glsl */
`\nvec3 diffuse = vec3( 1.0 );\n\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\n\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\n\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\n\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\n\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n\n#ifdef DOUBLE_SIDED\n\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n\n#endif\n\n#if NUM_POINT_LIGHTS > 0\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n		#endif\n\n	}\n	#pragma unroll_loop_end\n\n#endif\n\n#if NUM_SPOT_LIGHTS > 0\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n		#endif\n	}\n	#pragma unroll_loop_end\n\n#endif\n\n/*\n#if NUM_RECT_AREA_LIGHTS > 0\n\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n		// TODO (abelnation): implement\n\n	}\n\n#endif\n*/\n\n#if NUM_DIR_LIGHTS > 0\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n		#endif\n\n	}\n	#pragma unroll_loop_end\n\n#endif\n\n#if NUM_HEMI_LIGHTS > 0\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n		#ifdef DOUBLE_SIDED\n\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\n		#endif\n\n	}\n	#pragma unroll_loop_end\n\n#endif\n`;
const lights_pars_begin = /* glsl */
`\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\n\n// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\n	// normal is assumed to have unit length\n\n	float x = normal.x, y = normal.y, z = normal.z;\n\n	// band 0\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n\n	// band 1\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\n	// band 2\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\n	return result;\n\n}\n\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\n	return irradiance;\n\n}\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n	vec3 irradiance = ambientLightColor;\n\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n		irradiance *= PI;\n\n	#endif\n\n	return irradiance;\n\n}\n\n#if NUM_DIR_LIGHTS > 0\n\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n\n	}\n\n#endif\n\n\n#if NUM_POINT_LIGHTS > 0\n\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\n	// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n\n		float lightDistance = length( lVector );\n\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n\n	}\n\n#endif\n\n\n#if NUM_SPOT_LIGHTS > 0\n\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\n	// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n\n		if ( angleCos > spotLight.coneCos ) {\n\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n\n		} else {\n\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n\n		}\n	}\n\n#endif\n\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n\n	// Pre-computed values of LinearTransformedCosine approximation of BRDF\n	// BRDF approximation Texture is 64x64\n	uniform sampler2D ltc_1; // RGBA Float\n	uniform sampler2D ltc_2; // RGBA Float\n\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n\n#endif\n\n\n#if NUM_HEMI_LIGHTS > 0\n\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n			irradiance *= PI;\n\n		#endif\n\n		return irradiance;\n\n	}\n\n#endif\n`;
const envmap_physical_pars_fragment = /* glsl */
`\n#if defined( USE_ENVMAP )\n\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n\n	vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\n\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n		#ifdef ENVMAP_TYPE_CUBE\n\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\n			// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n			// of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n\n			#ifdef TEXTURE_LOD_EXT\n\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\n			#else\n\n				// force the bias high to get the last LOD level as it is the most blurred.\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\n			#endif\n\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\n		#else\n\n			vec4 envMapColor = vec4( 0.0 );\n\n		#endif\n\n		return PI * envMapColor.rgb * envMapIntensity;\n\n	}\n\n	// Trowbridge-Reitz distribution to Mip level, following the logic of http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\n		float maxMIPLevelScalar = float( maxMIPLevel );\n\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\n		// clamp to allowable LOD ranges.\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n	}\n\n	vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( -viewDir, normal );\n\n			// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\n		#else\n\n			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\n		#endif\n\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\n		#ifdef ENVMAP_TYPE_CUBE\n\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\n			#ifdef TEXTURE_LOD_EXT\n\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\n			#else\n\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\n			#endif\n\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\n		#endif\n\n		return envMapColor.rgb * envMapIntensity;\n\n	}\n\n#endif\n`;
const lights_toon_fragment = /* glsl */
`\nToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\n`;
const lights_toon_pars_fragment = /* glsl */
`\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n\n\nstruct ToonMaterial {\n\n	vec3 diffuseColor;\n\n};\n\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n		irradiance *= PI; // punctual light\n\n	#endif\n\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n\n#define Material_LightProbeLOD( material )	(0)\n`;
const lights_phong_fragment = /* glsl */
`\nBlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n`;
const lights_phong_pars_fragment = /* glsl */
`\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n\n\nstruct BlinnPhongMaterial {\n\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n\n};\n\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n		irradiance *= PI; // punctual light\n\n	#endif\n\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n\n#define Material_LightProbeLOD( material )	(0)\n`;
const lights_physical_fragment = /* glsl */
`\nPhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\n\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\n\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.\nmaterial.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n\n#ifdef REFLECTIVITY\n\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\n#else\n\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n\n#endif\n\n#ifdef CLEARCOAT\n\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n\n	#ifdef USE_CLEARCOATMAP\n\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\n	#endif\n\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\n	#endif\n\n	material.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model\n	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n\n#endif\n\n#ifdef USE_SHEEN\n\n	material.sheenColor = sheen;\n\n#endif\n`;
const lights_physical_pars_fragment = /* glsl */
`\nstruct PhysicalMaterial {\n\n	vec3 diffuseColor;\n	float specularRoughness;\n	vec3 specularColor;\n\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n\n};\n\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n// Clear coat directional hemishperical reflectance (this approximation should be improved)\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n\n}\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction\n		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n\n		// LTC Fresnel Approximation by Stephen Hill\n		// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\n	}\n\n#endif\n\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n	vec3 irradiance = dotNL * directLight.color;\n\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n		irradiance *= PI; // punctual light\n\n	#endif\n\n	#ifdef CLEARCOAT\n\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n			ccIrradiance *= PI; // punctual light\n\n		#endif\n\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\n	#else\n\n		float clearcoatDHR = 0.0;\n\n	#endif\n\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\n	#ifdef CLEARCOAT\n\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\n	#else\n\n		float clearcoatDHR = 0.0;\n\n	#endif\n\n	float clearcoatInv = 1.0 - clearcoatDHR;\n\n	// Both indirect specular and indirect diffuse light accumulate here\n\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\n}\n\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\n\n// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n`;
const lights_fragment_begin = /* glsl */
`\n/**\n * This is a template that can be used to light a material, it uses pluggable\n * RenderEquations (RE)for specific lighting scenarios.\n *\n * Instructions for use:\n * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???\n * - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n *\n * TODO:\n * - Add area light support.\n * - Add sphere light support.\n * - Add diffuse light probe (irradiance cubemap) support.\n */\n\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n#ifdef CLEARCOAT\n\n	geometry.clearcoatNormal = clearcoatNormal;\n\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n		pointLight = pointLights[ i ];\n\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n\n		RE_Direct( directLight, geometry, material, reflectedLight );\n\n	}\n	#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n		spotLight = spotLights[ i ];\n\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n\n		RE_Direct( directLight, geometry, material, reflectedLight );\n\n	}\n	#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n		directionalLight = directionalLights[ i ];\n\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n\n		RE_Direct( directLight, geometry, material, reflectedLight );\n\n	}\n	#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n	RectAreaLight rectAreaLight;\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n	}\n	#pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n	vec3 iblIrradiance = vec3( 0.0 );\n\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n\n	#if ( NUM_HEMI_LIGHTS > 0 )\n\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n		}\n		#pragma unroll_loop_end\n\n	#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif\n`;
const lights_fragment_maps = /* glsl */
`\n#if defined( RE_IndirectDiffuse )\n\n	#ifdef USE_LIGHTMAP\n\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n			lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\n\n		#endif\n\n		irradiance += lightMapIrradiance;\n\n	#endif\n\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\n		iblIrradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );\n\n	#endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n	radiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\n	#ifdef CLEARCOAT\n\n		clearcoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\n	#endif\n\n#endif\n`;
const lights_fragment_end = /* glsl */
`\n#if defined( RE_IndirectDiffuse )\n\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n\n#endif\n`;
const logdepthbuf_fragment = /* glsl */
`\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n	// Doing a strict comparison with == 1.0 can cause noise artifacts\n	// on some platforms. See issue #17623.\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n\n#endif\n`;
const logdepthbuf_pars_fragment = /* glsl */
`\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n\n#endif\n`;
const logdepthbuf_pars_vertex = /* glsl */
`\n#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n		varying float vIsPerspective;\n\n	#else\n\n		uniform float logDepthBufFC;\n\n	#endif\n\n#endif\n`;
const logdepthbuf_vertex = /* glsl */
`\n#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\n	#else\n\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\n			gl_Position.z *= gl_Position.w;\n\n		}\n\n	#endif\n\n#endif\n`;
const map_fragment = /* glsl */
`\n#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n\n#endif\n`;
const map_pars_fragment = /* glsl */
`\n#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif\n`;
const map_particle_fragment = /* glsl */
`\n#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\n#endif\n\n#ifdef USE_MAP\n\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n\n#endif\n\n#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n\n#endif\n`;
const map_particle_pars_fragment = /* glsl */
`\n#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\n	uniform mat3 uvTransform;\n\n#endif\n\n#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif\n\n#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n`;
const metalnessmap_fragment = /* glsl */
`\nfloat metalnessFactor = metalness;\n\n#ifdef USE_METALNESSMAP\n\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n	// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n	metalnessFactor *= texelMetalness.b;\n\n#endif\n`;
const metalnessmap_pars_fragment = /* glsl */
`\n#ifdef USE_METALNESSMAP\n\n	uniform sampler2D metalnessMap;\n\n#endif\n`;
const morphnormal_vertex = /* glsl */
`\n#ifdef USE_MORPHNORMALS\n\n	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)\n	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\n#endif\n`;
const morphtarget_pars_vertex = /* glsl */
`\n#ifdef USE_MORPHTARGETS\n\n	uniform float morphTargetBaseInfluence;\n\n	#ifndef USE_MORPHNORMALS\n\n		uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n		uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif\n`;
const morphtarget_vertex = /* glsl */
`\n#ifdef USE_MORPHTARGETS\n\n	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)\n	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\n	#endif\n\n#endif\n`;
const normal_fragment_begin = /* glsl */
`\n#ifdef FLAT_SHADED\n\n	// Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#else\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n	#endif\n\n	#ifdef USE_TANGENT\n\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n\n		#ifdef DOUBLE_SIDED\n\n			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n		#endif\n\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n\n		#endif\n\n	#endif\n\n#endif\n\n// non perturbed normal for clearcoat among others\n\nvec3 geometryNormal = normal;\n\n`;
const normal_fragment_maps = /* glsl */
`\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n	#ifdef FLIP_SIDED\n\n		normal = - normal;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n	#endif\n\n	normal = normalize( normalMatrix * normal );\n\n#elif defined( TANGENTSPACE_NORMALMAP )\n\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n\n	#ifdef USE_TANGENT\n\n		normal = normalize( vTBN * mapN );\n\n	#else\n\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\n	#endif\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n`;
const normalmap_pars_fragment = /* glsl */
`\n#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n#endif\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n	uniform mat3 normalMatrix;\n\n#endif\n\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\n	// Per-Pixel Tangent Space Normal Mapping\n	// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\n		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n		vec3 N = normalize( surf_norm );\n\n		mat3 tsn = mat3( S, T, N );\n\n		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n`;
const clearcoat_normal_fragment_begin = /* glsl */
`\n#ifdef CLEARCOAT\n\n	vec3 clearcoatNormal = geometryNormal;\n\n#endif\n`;
const clearcoat_normal_fragment_maps = /* glsl */
`\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n\n	#ifdef USE_TANGENT\n\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n\n	#else\n\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\n	#endif\n\n#endif\n`;
const clearcoat_pars_fragment = /* glsl */
`\n\n#ifdef USE_CLEARCOATMAP\n\n	uniform sampler2D clearcoatMap;\n\n#endif\n\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n	uniform sampler2D clearcoatRoughnessMap;\n\n#endif\n\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n\n#endif\n`;
const packing = /* glsl */
`\nvec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8; // tidy overflow\n	return r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\n\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n`;
const premultiplied_alpha_fragment = /* glsl */
`\n#ifdef PREMULTIPLIED_ALPHA\n\n	// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\n	gl_FragColor.rgb *= gl_FragColor.a;\n\n#endif\n`;
const project_vertex = /* glsl */
`\nvec4 mvPosition = vec4( transformed, 1.0 );\n\n#ifdef USE_INSTANCING\n\n	mvPosition = instanceMatrix * mvPosition;\n\n#endif\n\nmvPosition = modelViewMatrix * mvPosition;\n\ngl_Position = projectionMatrix * mvPosition;\n`;
const dithering_fragment = /* glsl */
`\n#ifdef DITHERING\n\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\n#endif\n`;
const dithering_pars_fragment = /* glsl */
`\n#ifdef DITHERING\n\n	// based on https://www.shadertoy.com/view/MslGR8\n	vec3 dithering( vec3 color ) {\n		//Calculate grid position\n		float grid_position = rand( gl_FragCoord.xy );\n\n		//Shift the individual colors differently, thus making it even harder to see the dithering pattern\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\n		//modify shift acording to grid position.\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\n		//shift the color by dither_shift\n		return color + dither_shift_RGB;\n	}\n\n#endif\n`;
const roughnessmap_fragment = /* glsl */
`\nfloat roughnessFactor = roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n	// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n	roughnessFactor *= texelRoughness.g;\n\n#endif\n`;
const roughnessmap_pars_fragment = /* glsl */
`\n#ifdef USE_ROUGHNESSMAP\n\n	uniform sampler2D roughnessMap;\n\n#endif\n`;
const shadowmap_pars_fragment = /* glsl */
`\n#ifdef USE_SHADOWMAP\n\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n	#endif\n\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\n	#endif\n\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\n	#endif\n\n	/*\n	#if NUM_RECT_AREA_LIGHTS > 0\n\n		// TODO (abelnation): create uniforms for area light shadows\n\n	#endif\n	*/\n\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n	}\n\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n	}\n\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n		float occlusion = 1.0;\n\n		vec2 distribution = texture2DDistribution( shadow, uv );\n\n		float hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n		if (hard_shadow != 1.0 ) {\n\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n		}\n		return occlusion;\n\n	}\n\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n		float shadow = 1.0;\n\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n\n		// if ( something && something ) breaks ATI OpenGL shader compiler\n		// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n		#if defined( SHADOWMAP_TYPE_PCF )\n\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n\n		#elif defined( SHADOWMAP_TYPE_VSM )\n\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n		#else // no percentage-closer filtering:\n\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n		#endif\n\n		}\n\n		return shadow;\n\n	}\n\n	// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n	// vector suitable for 2D texture mapping. This code uses the following layout for the\n	// 2D texture:\n	//\n	// xzXZ\n	//  y Y\n	//\n	// Y - Positive y direction\n	// y - Negative y direction\n	// X - Positive x direction\n	// x - Negative x direction\n	// Z - Positive z direction\n	// z - Negative z direction\n	//\n	// Source and test bed:\n	// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n		// Number of texels to avoid at the edge of each square\n\n		vec3 absV = abs( v );\n\n		// Intersect unit cube\n\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n\n		// Apply scale to avoid seams\n\n		// two texels less per square (one texel will do for NEAREST)\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n		// Unwrap\n\n		// space: -1 ... 1 range for each square\n		//\n		// #X##		dim    := ( 4 , 2 )\n		//  # #		center := ( 1 , 1 )\n\n		vec2 planar = v.xy;\n\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n\n		if ( absV.z >= almostOne ) {\n\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n\n		} else if ( absV.x >= almostOne ) {\n\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n\n		} else if ( absV.y >= almostOne ) {\n\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n\n		}\n\n		// Transform to UV space\n\n		// scale := 0.5 / dim\n		// translate := ( center + 0.5 ) / dim\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n	}\n\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n		// for point lights, the uniform @vShadowCoord is re-purposed to hold\n		// the vector from the light to the world-space position of the fragment.\n		vec3 lightToPosition = shadowCoord.xyz;\n\n		// dp = normalized distance from light to fragment position\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n		dp += shadowBias;\n\n		// bd3D = base direction 3D\n		vec3 bd3D = normalize( lightToPosition );\n\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n\n		#else // no percentage-closer filtering\n\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n		#endif\n\n	}\n\n#endif\n`;
const shadowmap_pars_vertex = /* glsl */
`\n#ifdef USE_SHADOWMAP\n\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n	#endif\n\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\n	#endif\n\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\n	#endif\n\n	/*\n	#if NUM_RECT_AREA_LIGHTS > 0\n\n		// TODO (abelnation): uniforms for area light shadows\n\n	#endif\n	*/\n\n#endif\n`;
const shadowmap_vertex = /* glsl */
`\n#ifdef USE_SHADOWMAP\n\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\n		// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n\n	#endif\n\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\n	}\n	#pragma unroll_loop_end\n\n	#endif\n\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\n	}\n	#pragma unroll_loop_end\n\n	#endif\n\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\n	}\n	#pragma unroll_loop_end\n\n	#endif\n\n	/*\n	#if NUM_RECT_AREA_LIGHTS > 0\n\n		// TODO (abelnation): update vAreaShadowCoord with area light info\n\n	#endif\n	*/\n\n#endif\n`;
const shadowmask_pars_fragment = /* glsl */
`\nfloat getShadowMask() {\n\n	float shadow = 1.0;\n\n	#ifdef USE_SHADOWMAP\n\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n\n	DirectionalLightShadow directionalLight;\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n	}\n	#pragma unroll_loop_end\n\n	#endif\n\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n	SpotLightShadow spotLight;\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\n	}\n	#pragma unroll_loop_end\n\n	#endif\n\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n\n	PointLightShadow pointLight;\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\n	}\n	#pragma unroll_loop_end\n\n	#endif\n\n	/*\n	#if NUM_RECT_AREA_LIGHTS > 0\n\n		// TODO (abelnation): update shadow for Area light\n\n	#endif\n	*/\n\n	#endif\n\n	return shadow;\n\n}\n`;
const skinbase_vertex = /* glsl */
`\n#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif\n`;
const skinning_pars_vertex = /* glsl */
`\n#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n`;
const skinning_vertex = /* glsl */
`\n#ifdef USE_SKINNING\n\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n\n#endif\n`;
const skinnormal_vertex = /* glsl */
`\n#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n	#ifdef USE_TANGENT\n\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n	#endif\n\n#endif\n`;
const specularmap_fragment = /* glsl */
`\nfloat specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif\n`;
const specularmap_pars_fragment = /* glsl */
`\n#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif\n`;
const tonemapping_fragment = /* glsl */
`\n#if defined( TONE_MAPPING )\n\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\n#endif\n`;
const tonemapping_pars_fragment = /* glsl */
`\n#ifndef saturate\n// <common> may have defined saturate() already\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n\nuniform float toneMappingExposure;\n\n// exposure only\nvec3 LinearToneMapping( vec3 color ) {\n\n	return toneMappingExposure * color;\n\n}\n\n// source: https://www.cs.utah.edu/~reinhard/cdrom/\nvec3 ReinhardToneMapping( vec3 color ) {\n\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n\n}\n\n// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\n	// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n\n}\n\n// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\nvec3 RRTAndODTFit( vec3 v ) {\n\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n\n}\n\n// this implementation of ACES is modified to accommodate a brighter viewing environment.\n// the scale factor of 1/0.6 is subjective. see discussion in #19621.\n\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\n	// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ), // transposed from source\n		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n\n	// ODT_SAT => XYZ => D60_2_D65 => sRGB\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ), // transposed from source\n		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n\n	color *= toneMappingExposure / 0.6;\n\n	color = ACESInputMat * color;\n\n	// Apply RRT and ODT\n	color = RRTAndODTFit( color );\n\n	color = ACESOutputMat * color;\n\n	// Clamp to [0, 1]\n	return saturate( color );\n\n}\n\nvec3 CustomToneMapping( vec3 color ) { return color; }\n`;
const transmissionmap_fragment = /* glsl */
`\n#ifdef USE_TRANSMISSIONMAP\n\n	totalTransmission *= texture2D( transmissionMap, vUv ).r;\n\n#endif\n`;
const transmissionmap_pars_fragment = /* glsl */
`\n#ifdef USE_TRANSMISSIONMAP\n\n	uniform sampler2D transmissionMap;\n\n#endif\n`;
const uv_pars_fragment = /* glsl */
`\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\n	varying vec2 vUv;\n\n#endif\n`;
const uv_pars_vertex = /* glsl */
`\n#ifdef USE_UV\n\n	#ifdef UVS_VERTEX_ONLY\n\n		vec2 vUv;\n\n	#else\n\n		varying vec2 vUv;\n\n	#endif\n\n	uniform mat3 uvTransform;\n\n#endif\n`;
const uv_vertex = /* glsl */
`\n#ifdef USE_UV\n\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n#endif\n`;
const uv2_pars_fragment = /* glsl */
`\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	varying vec2 vUv2;\n\n#endif\n`;
const uv2_pars_vertex = /* glsl */
`\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n\n	uniform mat3 uv2Transform;\n\n#endif\n`;
const uv2_vertex = /* glsl */
`\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n\n#endif\n`;
const worldpos_vertex = /* glsl */
`\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\n	vec4 worldPosition = vec4( transformed, 1.0 );\n\n	#ifdef USE_INSTANCING\n\n		worldPosition = instanceMatrix * worldPosition;\n\n	#endif\n\n	worldPosition = modelMatrix * worldPosition;\n\n#endif\n`;
const background_frag = /* glsl */
`\nuniform sampler2D t2D;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n	vec4 texColor = texture2D( t2D, vUv );\n\n	gl_FragColor = mapTexelToLinear( texColor );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n\n}\n`;
const background_vert = /* glsl */
`\nvarying vec2 vUv;\nuniform mat3 uvTransform;\n\nvoid main() {\n\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n\n}\n`;
const cube_frag = /* glsl */
`\n#include <envmap_common_pars_fragment>\nuniform float opacity;\n\nvarying vec3 vWorldDirection;\n\n#include <cube_uv_reflection_fragment>\n\nvoid main() {\n\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n\n}\n`;
const cube_vert = /* glsl */
`\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n	vWorldDirection = transformDirection( position, modelMatrix );\n\n	#include <begin_vertex>\n	#include <project_vertex>\n\n	gl_Position.z = gl_Position.w; // set z to camera.far\n\n}\n`;
const depth_frag = /* glsl */
`\n#if DEPTH_PACKING == 3200\n\n	uniform float opacity;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n\n	vec4 diffuseColor = vec4( 1.0 );\n\n	#if DEPTH_PACKING == 3200\n\n		diffuseColor.a = opacity;\n\n	#endif\n\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n\n	#include <logdepthbuf_fragment>\n\n	// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n	#if DEPTH_PACKING == 3200\n\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\n	#elif DEPTH_PACKING == 3201\n\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n\n	#endif\n\n}\n`;
const depth_vert = /* glsl */
`\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.\n// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for\n// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n	#include <uv_vertex>\n\n	#include <skinbase_vertex>\n\n	#ifdef USE_DISPLACEMENTMAP\n\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n\n	#endif\n\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n\n	vHighPrecisionZW = gl_Position.zw;\n\n}\n`;
const distanceRGBA_frag = /* glsl */
`\n#define DISTANCE\n\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main () {\n\n	#include <clipping_planes_fragment>\n\n	vec4 diffuseColor = vec4( 1.0 );\n\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist ); // clamp to [ 0, 1 ]\n\n	gl_FragColor = packDepthToRGBA( dist );\n\n}\n`;
const distanceRGBA_vert = /* glsl */
`\n#define DISTANCE\n\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	#include <uv_vertex>\n\n	#include <skinbase_vertex>\n\n	#ifdef USE_DISPLACEMENTMAP\n\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n\n	#endif\n\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n\n	vWorldPosition = worldPosition.xyz;\n\n}\n`;
const equirect_frag = /* glsl */
`\nuniform sampler2D tEquirect;\n\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n	vec3 direction = normalize( vWorldDirection );\n\n	vec2 sampleUV = equirectUv( direction );\n\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n\n	gl_FragColor = mapTexelToLinear( texColor );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n\n}\n`;
const equirect_vert = /* glsl */
`\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n	vWorldDirection = transformDirection( position, modelMatrix );\n\n	#include <begin_vertex>\n	#include <project_vertex>\n\n}\n`;
const linedashed_frag = /* glsl */
`\nuniform vec3 diffuse;\nuniform float opacity;\n\nuniform float dashSize;\nuniform float totalSize;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n\n		discard;\n\n	}\n\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n\n	outgoingLight = diffuseColor.rgb; // simple shader\n\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n\n}\n`;
const linedashed_vert = /* glsl */
`\nuniform float scale;\nattribute float lineDistance;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	vLineDistance = scale * lineDistance;\n\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n\n}\n`;
const meshbasic_frag = /* glsl */
`\nuniform vec3 diffuse;\nuniform float opacity;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n\n	vec4 diffuseColor = vec4( diffuse, opacity );\n\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n	// accumulation (baked indirect lighting only)\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\n	#else\n\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n\n	#endif\n\n	// modulation\n	#include <aomap_fragment>\n\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n	#include <envmap_fragment>\n\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n\n}\n`;
const meshbasic_vert = /* glsl */
`\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n\n	#ifdef USE_ENVMAP\n\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n\n	#endif\n\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n\n}\n`;
const meshlambert_frag = /* glsl */
`\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n\n	// accumulation\n\n	#ifdef DOUBLE_SIDED\n\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\n	#else\n\n		reflectedLight.indirectDiffuse += vIndirectFront;\n\n	#endif\n\n	#include <lightmap_fragment>\n\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\n	#ifdef DOUBLE_SIDED\n\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\n	#else\n\n		reflectedLight.directDiffuse = vLightFront;\n\n	#endif\n\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\n	// modulation\n\n	#include <aomap_fragment>\n\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n	#include <envmap_fragment>\n\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}\n`;
const meshlambert_vert = /* glsl */
`\n#define LAMBERT\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}\n`;
const meshmatcap_frag = /* glsl */
`\n#define MATCAP\n\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n\n	vec4 diffuseColor = vec4( diffuse, opacity );\n\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\n	#ifdef USE_MATCAP\n\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n\n	#else\n\n		vec4 matcapColor = vec4( 1.0 );\n\n	#endif\n\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n\n}\n`;
const meshmatcap_vert = /* glsl */
`\n#define MATCAP\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n\n	#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n		vNormal = normalize( transformedNormal );\n\n	#endif\n\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n\n	vViewPosition = - mvPosition.xyz;\n\n}\n`;
const meshtoon_frag = /* glsl */
`\n#define TOON\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n\n	// accumulation\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n\n	// modulation\n	#include <aomap_fragment>\n\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n\n}\n`;
const meshtoon_vert = /* glsl */
`\n#define TOON\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n	vNormal = normalize( transformedNormal );\n\n#endif\n\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n\n	vViewPosition = - mvPosition.xyz;\n\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n\n}\n`;
const meshphong_frag = /* glsl */
`\n#define PHONG\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n\n	// accumulation\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n\n	// modulation\n	#include <aomap_fragment>\n\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n	#include <envmap_fragment>\n\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n\n}\n`;
const meshphong_vert = /* glsl */
`\n#define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n	vNormal = normalize( transformedNormal );\n\n#endif\n\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n\n	vViewPosition = - mvPosition.xyz;\n\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n\n}\n`;
const meshphysical_frag = /* glsl */
`\n#define STANDARD\n\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n	#define TRANSMISSION\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef TRANSMISSION\n	uniform float transmission;\n#endif\n\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n	#ifdef USE_TANGENT\n\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n\n	#endif\n\n#endif\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n\n	#ifdef TRANSMISSION\n		float totalTransmission = transmission;\n	#endif\n\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <transmissionmap_fragment>\n\n	// accumulation\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n\n	// modulation\n	#include <aomap_fragment>\n\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n	// this is a stub for the transmission model\n	#ifdef TRANSMISSION\n		diffuseColor.a *= saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n	#endif\n\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n\n}\n`;
const meshphysical_vert = /* glsl */
`\n#define STANDARD\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n	#ifdef USE_TANGENT\n\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n\n	#endif\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n	vNormal = normalize( transformedNormal );\n\n	#ifdef USE_TANGENT\n\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n	#endif\n\n#endif\n\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n\n	vViewPosition = - mvPosition.xyz;\n\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n\n}\n`;
const normal_frag = /* glsl */
`\n#define NORMAL\n\nuniform float opacity;\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n	varying vec3 vViewPosition;\n\n#endif\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n	#ifdef USE_TANGENT\n\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n\n	#endif\n\n#endif\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\n}\n`;
const normal_vert = /* glsl */
`\n#define NORMAL\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n	varying vec3 vViewPosition;\n\n#endif\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n	#ifdef USE_TANGENT\n\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n\n	#endif\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	#include <uv_vertex>\n\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n	vNormal = normalize( transformedNormal );\n\n	#ifdef USE_TANGENT\n\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n	#endif\n\n#endif\n\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n	vViewPosition = - mvPosition.xyz;\n\n#endif\n\n}\n`;
const points_frag = /* glsl */
`\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n\n	outgoingLight = diffuseColor.rgb;\n\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n\n}\n`;
const points_vert = /* glsl */
`\nuniform float size;\nuniform float scale;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n\n	gl_PointSize = size;\n\n	#ifdef USE_SIZEATTENUATION\n\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\n	#endif\n\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n\n}\n`;
const shadow_frag = /* glsl */
`\nuniform vec3 color;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n\nvoid main() {\n\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n\n}\n`;
const shadow_vert = /* glsl */
`\n#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n\nvoid main() {\n\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n\n}\n`;
const sprite_frag = /* glsl */
`\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n\n	outgoingLight = diffuseColor.rgb;\n\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n\n}\n`;
const sprite_vert = /* glsl */
`\nuniform float rotation;\nuniform vec2 center;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	#include <uv_vertex>\n\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n	#ifndef USE_SIZEATTENUATION\n\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\n		if ( isPerspective ) scale *= - mvPosition.z;\n\n	#endif\n\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\n	mvPosition.xy += rotatedPosition;\n\n	gl_Position = projectionMatrix * mvPosition;\n\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n\n}\n`;
const ShaderChunk = {
    alphamap_fragment: alphamap_fragment,
    alphamap_pars_fragment: alphamap_pars_fragment,
    alphatest_fragment: alphatest_fragment,
    aomap_fragment: aomap_fragment,
    aomap_pars_fragment: aomap_pars_fragment,
    begin_vertex: begin_vertex,
    beginnormal_vertex: beginnormal_vertex,
    bsdfs: bsdfs,
    bumpmap_pars_fragment: bumpmap_pars_fragment,
    clipping_planes_fragment: clipping_planes_fragment,
    clipping_planes_pars_fragment: clipping_planes_pars_fragment,
    clipping_planes_pars_vertex: clipping_planes_pars_vertex,
    clipping_planes_vertex: clipping_planes_vertex,
    color_fragment: color_fragment,
    color_pars_fragment: color_pars_fragment,
    color_pars_vertex: color_pars_vertex,
    color_vertex: color_vertex,
    common: common,
    cube_uv_reflection_fragment: cube_uv_reflection_fragment,
    defaultnormal_vertex: defaultnormal_vertex,
    displacementmap_pars_vertex: displacementmap_pars_vertex,
    displacementmap_vertex: displacementmap_vertex,
    emissivemap_fragment: emissivemap_fragment,
    emissivemap_pars_fragment: emissivemap_pars_fragment,
    encodings_fragment: encodings_fragment,
    encodings_pars_fragment: encodings_pars_fragment,
    envmap_fragment: envmap_fragment,
    envmap_common_pars_fragment: envmap_common_pars_fragment,
    envmap_pars_fragment: envmap_pars_fragment,
    envmap_pars_vertex: envmap_pars_vertex,
    envmap_physical_pars_fragment: envmap_physical_pars_fragment,
    envmap_vertex: envmap_vertex,
    fog_vertex: fog_vertex,
    fog_pars_vertex: fog_pars_vertex,
    fog_fragment: fog_fragment,
    fog_pars_fragment: fog_pars_fragment,
    gradientmap_pars_fragment: gradientmap_pars_fragment,
    lightmap_fragment: lightmap_fragment,
    lightmap_pars_fragment: lightmap_pars_fragment,
    lights_lambert_vertex: lights_lambert_vertex,
    lights_pars_begin: lights_pars_begin,
    lights_toon_fragment: lights_toon_fragment,
    lights_toon_pars_fragment: lights_toon_pars_fragment,
    lights_phong_fragment: lights_phong_fragment,
    lights_phong_pars_fragment: lights_phong_pars_fragment,
    lights_physical_fragment: lights_physical_fragment,
    lights_physical_pars_fragment: lights_physical_pars_fragment,
    lights_fragment_begin: lights_fragment_begin,
    lights_fragment_maps: lights_fragment_maps,
    lights_fragment_end: lights_fragment_end,
    logdepthbuf_fragment: logdepthbuf_fragment,
    logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
    logdepthbuf_vertex: logdepthbuf_vertex,
    map_fragment: map_fragment,
    map_pars_fragment: map_pars_fragment,
    map_particle_fragment: map_particle_fragment,
    map_particle_pars_fragment: map_particle_pars_fragment,
    metalnessmap_fragment: metalnessmap_fragment,
    metalnessmap_pars_fragment: metalnessmap_pars_fragment,
    morphnormal_vertex: morphnormal_vertex,
    morphtarget_pars_vertex: morphtarget_pars_vertex,
    morphtarget_vertex: morphtarget_vertex,
    normal_fragment_begin: normal_fragment_begin,
    normal_fragment_maps: normal_fragment_maps,
    normalmap_pars_fragment: normalmap_pars_fragment,
    clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment: clearcoat_pars_fragment,
    packing: packing,
    premultiplied_alpha_fragment: premultiplied_alpha_fragment,
    project_vertex: project_vertex,
    dithering_fragment: dithering_fragment,
    dithering_pars_fragment: dithering_pars_fragment,
    roughnessmap_fragment: roughnessmap_fragment,
    roughnessmap_pars_fragment: roughnessmap_pars_fragment,
    shadowmap_pars_fragment: shadowmap_pars_fragment,
    shadowmap_pars_vertex: shadowmap_pars_vertex,
    shadowmap_vertex: shadowmap_vertex,
    shadowmask_pars_fragment: shadowmask_pars_fragment,
    skinbase_vertex: skinbase_vertex,
    skinning_pars_vertex: skinning_pars_vertex,
    skinning_vertex: skinning_vertex,
    skinnormal_vertex: skinnormal_vertex,
    specularmap_fragment: specularmap_fragment,
    specularmap_pars_fragment: specularmap_pars_fragment,
    tonemapping_fragment: tonemapping_fragment,
    tonemapping_pars_fragment: tonemapping_pars_fragment,
    transmissionmap_fragment: transmissionmap_fragment,
    transmissionmap_pars_fragment: transmissionmap_pars_fragment,
    uv_pars_fragment: uv_pars_fragment,
    uv_pars_vertex: uv_pars_vertex,
    uv_vertex: uv_vertex,
    uv2_pars_fragment: uv2_pars_fragment,
    uv2_pars_vertex: uv2_pars_vertex,
    uv2_vertex: uv2_vertex,
    worldpos_vertex: worldpos_vertex,
    background_frag: background_frag,
    background_vert: background_vert,
    cube_frag: cube_frag,
    cube_vert: cube_vert,
    depth_frag: depth_frag,
    depth_vert: depth_vert,
    distanceRGBA_frag: distanceRGBA_frag,
    distanceRGBA_vert: distanceRGBA_vert,
    equirect_frag: equirect_frag,
    equirect_vert: equirect_vert,
    linedashed_frag: linedashed_frag,
    linedashed_vert: linedashed_vert,
    meshbasic_frag: meshbasic_frag,
    meshbasic_vert: meshbasic_vert,
    meshlambert_frag: meshlambert_frag,
    meshlambert_vert: meshlambert_vert,
    meshmatcap_frag: meshmatcap_frag,
    meshmatcap_vert: meshmatcap_vert,
    meshtoon_frag: meshtoon_frag,
    meshtoon_vert: meshtoon_vert,
    meshphong_frag: meshphong_frag,
    meshphong_vert: meshphong_vert,
    meshphysical_frag: meshphysical_frag,
    meshphysical_vert: meshphysical_vert,
    normal_frag: normal_frag,
    normal_vert: normal_vert,
    points_frag: points_frag,
    points_vert: points_vert,
    shadow_frag: shadow_frag,
    shadow_vert: shadow_vert,
    sprite_frag: sprite_frag,
    sprite_vert: sprite_vert
};
const ShaderLib = {
    basic: {
        uniforms: mergeUniforms([
            UniformsLib1.common,
            UniformsLib1.specularmap,
            UniformsLib1.envmap,
            UniformsLib1.aomap,
            UniformsLib1.lightmap,
            UniformsLib1.fog
        ]),
        vertexShader: ShaderChunk.meshbasic_vert,
        fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
        uniforms: mergeUniforms([
            UniformsLib1.common,
            UniformsLib1.specularmap,
            UniformsLib1.envmap,
            UniformsLib1.aomap,
            UniformsLib1.lightmap,
            UniformsLib1.emissivemap,
            UniformsLib1.fog,
            UniformsLib1.lights,
            {
                emissive: {
                    value: new Color1(0)
                }
            }
        ]),
        vertexShader: ShaderChunk.meshlambert_vert,
        fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
        uniforms: mergeUniforms([
            UniformsLib1.common,
            UniformsLib1.specularmap,
            UniformsLib1.envmap,
            UniformsLib1.aomap,
            UniformsLib1.lightmap,
            UniformsLib1.emissivemap,
            UniformsLib1.bumpmap,
            UniformsLib1.normalmap,
            UniformsLib1.displacementmap,
            UniformsLib1.fog,
            UniformsLib1.lights,
            {
                emissive: {
                    value: new Color1(0)
                },
                specular: {
                    value: new Color1(1118481)
                },
                shininess: {
                    value: 30
                }
            }
        ]),
        vertexShader: ShaderChunk.meshphong_vert,
        fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
        uniforms: mergeUniforms([
            UniformsLib1.common,
            UniformsLib1.envmap,
            UniformsLib1.aomap,
            UniformsLib1.lightmap,
            UniformsLib1.emissivemap,
            UniformsLib1.bumpmap,
            UniformsLib1.normalmap,
            UniformsLib1.displacementmap,
            UniformsLib1.roughnessmap,
            UniformsLib1.metalnessmap,
            UniformsLib1.fog,
            UniformsLib1.lights,
            {
                emissive: {
                    value: new Color1(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }
        ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    },
    toon: {
        uniforms: mergeUniforms([
            UniformsLib1.common,
            UniformsLib1.aomap,
            UniformsLib1.lightmap,
            UniformsLib1.emissivemap,
            UniformsLib1.bumpmap,
            UniformsLib1.normalmap,
            UniformsLib1.displacementmap,
            UniformsLib1.gradientmap,
            UniformsLib1.fog,
            UniformsLib1.lights,
            {
                emissive: {
                    value: new Color1(0)
                }
            }
        ]),
        vertexShader: ShaderChunk.meshtoon_vert,
        fragmentShader: ShaderChunk.meshtoon_frag
    },
    matcap: {
        uniforms: mergeUniforms([
            UniformsLib1.common,
            UniformsLib1.bumpmap,
            UniformsLib1.normalmap,
            UniformsLib1.displacementmap,
            UniformsLib1.fog,
            {
                matcap: {
                    value: null
                }
            }
        ]),
        vertexShader: ShaderChunk.meshmatcap_vert,
        fragmentShader: ShaderChunk.meshmatcap_frag
    },
    points: {
        uniforms: mergeUniforms([
            UniformsLib1.points,
            UniformsLib1.fog
        ]),
        vertexShader: ShaderChunk.points_vert,
        fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
        uniforms: mergeUniforms([
            UniformsLib1.common,
            UniformsLib1.fog,
            {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }
        ]),
        vertexShader: ShaderChunk.linedashed_vert,
        fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
        uniforms: mergeUniforms([
            UniformsLib1.common,
            UniformsLib1.displacementmap
        ]),
        vertexShader: ShaderChunk.depth_vert,
        fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
        uniforms: mergeUniforms([
            UniformsLib1.common,
            UniformsLib1.bumpmap,
            UniformsLib1.normalmap,
            UniformsLib1.displacementmap,
            {
                opacity: {
                    value: 1
                }
            }
        ]),
        vertexShader: ShaderChunk.normal_vert,
        fragmentShader: ShaderChunk.normal_frag
    },
    sprite: {
        uniforms: mergeUniforms([
            UniformsLib1.sprite,
            UniformsLib1.fog
        ]),
        vertexShader: ShaderChunk.sprite_vert,
        fragmentShader: ShaderChunk.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new Matrix31()
            },
            t2D: {
                value: null
            }
        },
        vertexShader: ShaderChunk.background_vert,
        fragmentShader: ShaderChunk.background_frag
    },
    /* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */
    cube: {
        uniforms: mergeUniforms([
            UniformsLib1.envmap,
            {
                opacity: {
                    value: 1
                }
            }
        ]),
        vertexShader: ShaderChunk.cube_vert,
        fragmentShader: ShaderChunk.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: ShaderChunk.equirect_vert,
        fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
        uniforms: mergeUniforms([
            UniformsLib1.common,
            UniformsLib1.displacementmap,
            {
                referencePosition: {
                    value: new Vector31()
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1000
                }
            }
        ]),
        vertexShader: ShaderChunk.distanceRGBA_vert,
        fragmentShader: ShaderChunk.distanceRGBA_frag
    },
    shadow: {
        uniforms: mergeUniforms([
            UniformsLib1.lights,
            UniformsLib1.fog,
            {
                color: {
                    value: new Color1(0)
                },
                opacity: {
                    value: 1
                }
            }, 
        ]),
        vertexShader: ShaderChunk.shadow_vert,
        fragmentShader: ShaderChunk.shadow_frag
    }
};
ShaderLib.physical = {
    uniforms: mergeUniforms([
        ShaderLib.standard.uniforms,
        {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatNormalScale: {
                value: new Vector21(1, 1)
            },
            clearcoatNormalMap: {
                value: null
            },
            sheen: {
                value: new Color1(0)
            },
            transmission: {
                value: 0
            },
            transmissionMap: {
                value: null
            }
        }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
};
const ShaderLib1 = ShaderLib;
function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
    const clearColor = new Color1(0);
    let clearAlpha = 0;
    let planeMesh;
    let boxMesh;
    let currentBackground = null;
    let currentBackgroundVersion = 0;
    let currentTonemapping = null;
    function render(renderList, scene, camera, forceClear) {
        let background = scene.isScene === true ? scene.background : null;
        if (background && background.isTexture) background = cubemaps.get(background);
        // Ignore background in AR
        // TODO: Reconsider this.
        const xr = renderer.xr;
        const session = xr.getSession && xr.getSession();
        if (session && session.environmentBlendMode === 'additive') background = null;
        if (background === null) setClear(clearColor, clearAlpha);
        else if (background && background.isColor) {
            setClear(background, 1);
        }
        if (renderer.autoClear || forceClear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
        if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.isWebGLCubeRenderTargetTexture || background.mapping === CubeUVReflectionMapping)) {
            if (boxMesh === undefined) {
                boxMesh = new Mesh1(new BoxBufferGeometry1(1, 1, 1), new ShaderMaterial1({
                    name: 'BackgroundCubeMaterial',
                    uniforms: cloneUniforms(ShaderLib1.cube.uniforms),
                    vertexShader: ShaderLib1.cube.vertexShader,
                    fragmentShader: ShaderLib1.cube.fragmentShader,
                    side: BackSide,
                    depthTest: false,
                    depthWrite: false,
                    fog: false
                }));
                boxMesh.geometry.deleteAttribute('normal');
                boxMesh.geometry.deleteAttribute('uv');
                boxMesh.onBeforeRender = function(renderer1, scene1, camera1) {
                    this.matrixWorld.copyPosition(camera1.matrixWorld);
                };
                // enable code injection for non-built-in material
                Object.defineProperty(boxMesh.material, 'envMap', {
                    get: function() {
                        return this.uniforms.envMap.value;
                    }
                });
                objects.update(boxMesh);
            }
            if (background.isWebGLCubeRenderTarget) // TODO Deprecate
            background = background.texture;
            boxMesh.material.uniforms.envMap.value = background;
            boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture ? -1 : 1;
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                boxMesh.material.needsUpdate = true;
                currentBackgroundVersion = background.version;
                currentTonemapping = renderer.toneMapping;
            }
            // push to the pre-sorted opaque render list
            renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
        } else if (background && background.isTexture) {
            if (planeMesh === undefined) {
                planeMesh = new Mesh1(new PlaneBufferGeometry1(2, 2), new ShaderMaterial1({
                    name: 'BackgroundMaterial',
                    uniforms: cloneUniforms(ShaderLib1.background.uniforms),
                    vertexShader: ShaderLib1.background.vertexShader,
                    fragmentShader: ShaderLib1.background.fragmentShader,
                    side: FrontSide,
                    depthTest: false,
                    depthWrite: false,
                    fog: false
                }));
                planeMesh.geometry.deleteAttribute('normal');
                // enable code injection for non-built-in material
                Object.defineProperty(planeMesh.material, 'map', {
                    get: function() {
                        return this.uniforms.t2D.value;
                    }
                });
                objects.update(planeMesh);
            }
            planeMesh.material.uniforms.t2D.value = background;
            if (background.matrixAutoUpdate === true) background.updateMatrix();
            planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                planeMesh.material.needsUpdate = true;
                currentBackground = background;
                currentBackgroundVersion = background.version;
                currentTonemapping = renderer.toneMapping;
            }
            // push to the pre-sorted opaque render list
            renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
        }
    }
    function setClear(color1, alpha) {
        state.buffers.color.setClear(color1.r, color1.g, color1.b, alpha, premultipliedAlpha);
    }
    return {
        getClearColor: function() {
            return clearColor;
        },
        setClearColor: function(color1, alpha) {
            clearColor.set(color1);
            clearAlpha = alpha !== undefined ? alpha : 1;
            setClear(clearColor, clearAlpha);
        },
        getClearAlpha: function() {
            return clearAlpha;
        },
        setClearAlpha: function(alpha) {
            clearAlpha = alpha;
            setClear(clearColor, clearAlpha);
        },
        render: render
    };
}
const WebGLBackground1 = WebGLBackground;
function WebGLBindingStates(gl, extensions, attributes, capabilities) {
    const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    const extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
    const vaoAvailable = capabilities.isWebGL2 || extension !== null;
    const bindingStates = {
    };
    const defaultState = createBindingState(null);
    let currentState = defaultState;
    function setup(object, material, program, geometry, index) {
        let updateBuffers = false;
        if (vaoAvailable) {
            const state = getBindingState(geometry, program, material);
            if (currentState !== state) {
                currentState = state;
                bindVertexArrayObject(currentState.object);
            }
            updateBuffers = needsUpdate(geometry, index);
            if (updateBuffers) saveCache(geometry, index);
        } else {
            const wireframe = material.wireframe === true;
            if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
                currentState.geometry = geometry.id;
                currentState.program = program.id;
                currentState.wireframe = wireframe;
                updateBuffers = true;
            }
        }
        if (object.isInstancedMesh === true) updateBuffers = true;
        if (index !== null) attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
        if (updateBuffers) {
            setupVertexAttributes(object, material, program, geometry);
            if (index !== null) gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
        }
    }
    function createVertexArrayObject() {
        if (capabilities.isWebGL2) return gl.createVertexArray();
        return extension.createVertexArrayOES();
    }
    function bindVertexArrayObject(vao) {
        if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
        return extension.bindVertexArrayOES(vao);
    }
    function deleteVertexArrayObject(vao) {
        if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
        return extension.deleteVertexArrayOES(vao);
    }
    function getBindingState(geometry, program, material) {
        const wireframe = material.wireframe === true;
        let programMap = bindingStates[geometry.id];
        if (programMap === undefined) {
            programMap = {
            };
            bindingStates[geometry.id] = programMap;
        }
        let stateMap = programMap[program.id];
        if (stateMap === undefined) {
            stateMap = {
            };
            programMap[program.id] = stateMap;
        }
        let state = stateMap[wireframe];
        if (state === undefined) {
            state = createBindingState(createVertexArrayObject());
            stateMap[wireframe] = state;
        }
        return state;
    }
    function createBindingState(vao) {
        const newAttributes = [];
        const enabledAttributes = [];
        const attributeDivisors = [];
        for(let i1 = 0; i1 < maxVertexAttributes; i1++){
            newAttributes[i1] = 0;
            enabledAttributes[i1] = 0;
            attributeDivisors[i1] = 0;
        }
        return {
            // for backward compatibility on non-VAO support browser
            geometry: null,
            program: null,
            wireframe: false,
            newAttributes: newAttributes,
            enabledAttributes: enabledAttributes,
            attributeDivisors: attributeDivisors,
            object: vao,
            attributes: {
            },
            index: null
        };
    }
    function needsUpdate(geometry, index) {
        const cachedAttributes = currentState.attributes;
        const geometryAttributes = geometry.attributes;
        if (Object.keys(cachedAttributes).length !== Object.keys(geometryAttributes).length) return true;
        for(const key in geometryAttributes){
            const cachedAttribute = cachedAttributes[key];
            const geometryAttribute = geometryAttributes[key];
            if (cachedAttribute === undefined) return true;
            if (cachedAttribute.attribute !== geometryAttribute) return true;
            if (cachedAttribute.data !== geometryAttribute.data) return true;
        }
        if (currentState.index !== index) return true;
        return false;
    }
    function saveCache(geometry, index) {
        const cache = {
        };
        const attributes1 = geometry.attributes;
        for(const key in attributes1){
            const attribute = attributes1[key];
            const data = {
            };
            data.attribute = attribute;
            if (attribute.data) data.data = attribute.data;
            cache[key] = data;
        }
        currentState.attributes = cache;
        currentState.index = index;
    }
    function initAttributes() {
        const newAttributes = currentState.newAttributes;
        for(let i1 = 0, il = newAttributes.length; i1 < il; i1++)newAttributes[i1] = 0;
    }
    function enableAttribute(attribute) {
        enableAttributeAndDivisor(attribute, 0);
    }
    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
        const newAttributes = currentState.newAttributes;
        const enabledAttributes = currentState.enabledAttributes;
        const attributeDivisors = currentState.attributeDivisors;
        newAttributes[attribute] = 1;
        if (enabledAttributes[attribute] === 0) {
            gl.enableVertexAttribArray(attribute);
            enabledAttributes[attribute] = 1;
        }
        if (attributeDivisors[attribute] !== meshPerAttribute) {
            const extension1 = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
            extension1[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
            attributeDivisors[attribute] = meshPerAttribute;
        }
    }
    function disableUnusedAttributes() {
        const newAttributes = currentState.newAttributes;
        const enabledAttributes = currentState.enabledAttributes;
        for(let i1 = 0, il = enabledAttributes.length; i1 < il; i1++)if (enabledAttributes[i1] !== newAttributes[i1]) {
            gl.disableVertexAttribArray(i1);
            enabledAttributes[i1] = 0;
        }
    }
    function vertexAttribPointer(index, size, type, normalized, stride, offset) {
        if (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) gl.vertexAttribIPointer(index, size, type, stride, offset);
        else gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
    function setupVertexAttributes(object, material, program, geometry) {
        if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
            if (extensions.get('ANGLE_instanced_arrays') === null) return;
        }
        initAttributes();
        const geometryAttributes = geometry.attributes;
        const programAttributes = program.getAttributes();
        const materialDefaultAttributeValues = material.defaultAttributeValues;
        for(const name in programAttributes){
            const programAttribute = programAttributes[name];
            if (programAttribute >= 0) {
                const geometryAttribute = geometryAttributes[name];
                if (geometryAttribute !== undefined) {
                    const normalized = geometryAttribute.normalized;
                    const size = geometryAttribute.itemSize;
                    const attribute = attributes.get(geometryAttribute);
                    // TODO Attribute may not be available on context restore
                    if (attribute === undefined) continue;
                    const buffer = attribute.buffer;
                    const type = attribute.type;
                    const bytesPerElement = attribute.bytesPerElement;
                    if (geometryAttribute.isInterleavedBufferAttribute) {
                        const data = geometryAttribute.data;
                        const stride = data.stride;
                        const offset = geometryAttribute.offset;
                        if (data && data.isInstancedInterleavedBuffer) {
                            enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
                            if (geometry._maxInstanceCount === undefined) geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                        } else enableAttribute(programAttribute);
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                        vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
                    } else {
                        if (geometryAttribute.isInstancedBufferAttribute) {
                            enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
                            if (geometry._maxInstanceCount === undefined) geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                        } else enableAttribute(programAttribute);
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                        vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
                    }
                } else if (name === 'instanceMatrix') {
                    const attribute = attributes.get(object.instanceMatrix);
                    // TODO Attribute may not be available on context restore
                    if (attribute === undefined) continue;
                    const buffer = attribute.buffer;
                    const type = attribute.type;
                    enableAttributeAndDivisor(programAttribute + 0, 1);
                    enableAttributeAndDivisor(programAttribute + 1, 1);
                    enableAttributeAndDivisor(programAttribute + 2, 1);
                    enableAttributeAndDivisor(programAttribute + 3, 1);
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
                    gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
                    gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
                    gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
                } else if (name === 'instanceColor') {
                    const attribute = attributes.get(object.instanceColor);
                    // TODO Attribute may not be available on context restore
                    if (attribute === undefined) continue;
                    const buffer = attribute.buffer;
                    const type = attribute.type;
                    enableAttributeAndDivisor(programAttribute, 1);
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);
                } else if (materialDefaultAttributeValues !== undefined) {
                    const value = materialDefaultAttributeValues[name];
                    if (value !== undefined) switch(value.length){
                        case 2:
                            gl.vertexAttrib2fv(programAttribute, value);
                            break;
                        case 3:
                            gl.vertexAttrib3fv(programAttribute, value);
                            break;
                        case 4:
                            gl.vertexAttrib4fv(programAttribute, value);
                            break;
                        default:
                            gl.vertexAttrib1fv(programAttribute, value);
                    }
                }
            }
        }
        disableUnusedAttributes();
    }
    function dispose() {
        reset();
        for(const geometryId in bindingStates){
            const programMap = bindingStates[geometryId];
            for(const programId in programMap){
                const stateMap = programMap[programId];
                for(const wireframe in stateMap){
                    deleteVertexArrayObject(stateMap[wireframe].object);
                    delete stateMap[wireframe];
                }
                delete programMap[programId];
            }
            delete bindingStates[geometryId];
        }
    }
    function releaseStatesOfGeometry(geometry) {
        if (bindingStates[geometry.id] === undefined) return;
        const programMap = bindingStates[geometry.id];
        for(const programId in programMap){
            const stateMap = programMap[programId];
            for(const wireframe in stateMap){
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
            }
            delete programMap[programId];
        }
        delete bindingStates[geometry.id];
    }
    function releaseStatesOfProgram(program) {
        for(const geometryId in bindingStates){
            const programMap = bindingStates[geometryId];
            if (programMap[program.id] === undefined) continue;
            const stateMap = programMap[program.id];
            for(const wireframe in stateMap){
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
            }
            delete programMap[program.id];
        }
    }
    function reset() {
        resetDefaultState();
        if (currentState === defaultState) return;
        currentState = defaultState;
        bindVertexArrayObject(currentState.object);
    }
    // for backward-compatilibity
    function resetDefaultState() {
        defaultState.geometry = null;
        defaultState.program = null;
        defaultState.wireframe = false;
    }
    return {
        setup: setup,
        reset: reset,
        resetDefaultState: resetDefaultState,
        dispose: dispose,
        releaseStatesOfGeometry: releaseStatesOfGeometry,
        releaseStatesOfProgram: releaseStatesOfProgram,
        initAttributes: initAttributes,
        enableAttribute: enableAttribute,
        disableUnusedAttributes: disableUnusedAttributes
    };
}
const WebGLBindingStates1 = WebGLBindingStates;
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
    }
    function render(start, count) {
        gl.drawArrays(mode, start, count);
        info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
        if (primcount === 0) return;
        let extension, methodName;
        if (isWebGL2) {
        } else {
            extension = extensions.get('ANGLE_instanced_arrays');
            if (extension === null) {
                console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
        }
        extension[methodName](mode, start, count, primcount);
        info.update(count, mode, primcount);
    }
    //
    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;
}
const WebGLBufferRenderer1 = WebGLBufferRenderer;
function WebGLCapabilities(gl, extensions, parameters) {
    let maxAnisotropy;
    function getMaxAnisotropy() {
        if (maxAnisotropy !== undefined) return maxAnisotropy;
        const extension = extensions.get('EXT_texture_filter_anisotropic');
        if (extension !== null) maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        else maxAnisotropy = 0;
        return maxAnisotropy;
    }
    function getMaxPrecision(precision) {
        if (precision === 'highp') {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) return 'highp';
        }
        if (precision === 'mediump') {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) return 'mediump';
        }
        return 'lowp';
    }
    /* eslint-disable no-undef */
    const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
    /* eslint-enable no-undef */
    let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
    const maxPrecision = getMaxPrecision(precision);
    if (maxPrecision !== precision) {
        console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
        precision = maxPrecision;
    }
    const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
    const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
    const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
    const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
    const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
    const vertexTextures = maxVertexTextures > 0;
    const floatFragmentTextures = isWebGL2 || !!extensions.get('OES_texture_float');
    const floatVertexTextures = vertexTextures && floatFragmentTextures;
    const maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
    return {
        isWebGL2: isWebGL2,
        getMaxAnisotropy: getMaxAnisotropy,
        getMaxPrecision: getMaxPrecision,
        precision: precision,
        logarithmicDepthBuffer: logarithmicDepthBuffer,
        maxTextures: maxTextures,
        maxVertexTextures: maxVertexTextures,
        maxTextureSize: maxTextureSize,
        maxCubemapSize: maxCubemapSize,
        maxAttributes: maxAttributes,
        maxVertexUniforms: maxVertexUniforms,
        maxVaryings: maxVaryings,
        maxFragmentUniforms: maxFragmentUniforms,
        vertexTextures: vertexTextures,
        floatFragmentTextures: floatFragmentTextures,
        floatVertexTextures: floatVertexTextures,
        maxSamples: maxSamples
    };
}
const WebGLCapabilities1 = WebGLCapabilities;
function WebGLClipping() {
    const scope1 = this;
    let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
    const plane = new Plane1(), viewNormalMatrix = new Matrix31(), uniform = {
        value: null,
        needsUpdate: false
    };
    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;
    this.init = function(planes, enableLocalClipping, camera) {
        const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
        // run another frame in order to reset the state:
        numGlobalPlanes !== 0 || localClippingEnabled;
        localClippingEnabled = enableLocalClipping;
        globalState = projectPlanes(planes, camera, 0);
        numGlobalPlanes = planes.length;
        return enabled;
    };
    this.beginShadows = function() {
        renderingShadows = true;
        projectPlanes(null);
    };
    this.endShadows = function() {
        renderingShadows = false;
        resetGlobalState();
    };
    this.setState = function(planes, clipIntersection, clipShadows, camera, cache, fromCache) {
        if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
            // there's no local clipping
            if (renderingShadows) // there's no global clipping
            projectPlanes(null);
            else resetGlobalState();
        } else {
            const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
            let dstArray = cache.clippingState || null;
            uniform.value = dstArray; // ensure unique state
            dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
            for(let i1 = 0; i1 !== lGlobal; ++i1)dstArray[i1] = globalState[i1];
            cache.clippingState = dstArray;
            this.numIntersection = clipIntersection ? this.numPlanes : 0;
            this.numPlanes += nGlobal;
        }
    };
    function resetGlobalState() {
        if (uniform.value !== globalState) {
            uniform.value = globalState;
            uniform.needsUpdate = numGlobalPlanes > 0;
        }
        scope1.numPlanes = numGlobalPlanes;
        scope1.numIntersection = 0;
    }
    function projectPlanes(planes, camera, dstOffset, skipTransform) {
        const nPlanes = planes !== null ? planes.length : 0;
        let dstArray = null;
        if (nPlanes !== 0) {
            dstArray = uniform.value;
            if (skipTransform !== true || dstArray === null) {
                const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
                viewNormalMatrix.getNormalMatrix(viewMatrix);
                if (dstArray === null || dstArray.length < flatSize) dstArray = new Float32Array(flatSize);
                for(let i1 = 0, i4 = dstOffset; i1 !== nPlanes; ++i1, i4 += 4){
                    plane.copy(planes[i1]).applyMatrix4(viewMatrix, viewNormalMatrix);
                    plane.normal.toArray(dstArray, i4);
                    dstArray[i4 + 3] = plane.constant;
                }
            }
            uniform.value = dstArray;
            uniform.needsUpdate = true;
        }
        scope1.numPlanes = nPlanes;
        scope1.numIntersection = 0;
        return dstArray;
    }
}
const WebGLClipping1 = WebGLClipping;
const fov = 90, aspect = 1;
function CubeCamera2(near, far, renderTarget) {
    Object3D1.call(this);
    this.type = 'CubeCamera';
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
        console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
        return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera1(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector31(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera1(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector31(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera1(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector31(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera1(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector31(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera1(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector31(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera1(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector31(0, 0, -1));
    this.add(cameraNZ);
    this.update = function(renderer, scene) {
        if (this.parent === null) this.updateMatrixWorld();
        const currentXrEnabled = renderer.xr.enabled;
        const currentRenderTarget = renderer.getRenderTarget();
        renderer.xr.enabled = false;
        const generateMipmaps = renderTarget.texture.generateMipmaps;
        renderTarget.texture.generateMipmaps = false;
        renderer.setRenderTarget(renderTarget, 0);
        renderer.render(scene, cameraPX);
        renderer.setRenderTarget(renderTarget, 1);
        renderer.render(scene, cameraNX);
        renderer.setRenderTarget(renderTarget, 2);
        renderer.render(scene, cameraPY);
        renderer.setRenderTarget(renderTarget, 3);
        renderer.render(scene, cameraNY);
        renderer.setRenderTarget(renderTarget, 4);
        renderer.render(scene, cameraPZ);
        renderTarget.texture.generateMipmaps = generateMipmaps;
        renderer.setRenderTarget(renderTarget, 5);
        renderer.render(scene, cameraNZ);
        renderer.setRenderTarget(currentRenderTarget);
        renderer.xr.enabled = currentXrEnabled;
    };
    this.clear = function(renderer, color1, depth1, stencil) {
        const currentRenderTarget = renderer.getRenderTarget();
        for(let i1 = 0; i1 < 6; i1++){
            renderer.setRenderTarget(renderTarget, i1);
            renderer.clear(color1, depth1, stencil);
        }
        renderer.setRenderTarget(currentRenderTarget);
    };
}
CubeCamera2.prototype = Object.create(Object3D1.prototype);
CubeCamera2.prototype.constructor = CubeCamera2;
const CubeCamera1 = CubeCamera2;
function WebGLCubeRenderTarget2(size, options, dummy) {
    if (Number.isInteger(options)) {
        console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');
        options = dummy;
    }
    WebGLRenderTarget1.call(this, size, size, options);
    this.texture.isWebGLCubeRenderTargetTexture = true;
}
WebGLCubeRenderTarget2.prototype = Object.create(WebGLRenderTarget1.prototype);
WebGLCubeRenderTarget2.prototype.constructor = WebGLCubeRenderTarget2;
WebGLCubeRenderTarget2.prototype.isWebGLCubeRenderTarget = true;
WebGLCubeRenderTarget2.prototype.fromEquirectangularTexture = function(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.format = RGBAFormat;
    this.texture.encoding = texture.encoding;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: `\n\n			varying vec3 vWorldDirection;\n\n			vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n				return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n			}\n\n			void main() {\n\n				vWorldDirection = transformDirection( position, modelMatrix );\n\n				#include <begin_vertex>\n				#include <project_vertex>\n\n			}\n		`,
        fragmentShader: `\n\n			uniform sampler2D tEquirect;\n\n			varying vec3 vWorldDirection;\n\n			#include <common>\n\n			void main() {\n\n				vec3 direction = normalize( vWorldDirection );\n\n				vec2 sampleUV = equirectUv( direction );\n\n				gl_FragColor = texture2D( tEquirect, sampleUV );\n\n			}\n		`
    };
    const geometry = new BoxBufferGeometry1(5, 5, 5);
    const material = new ShaderMaterial1({
        name: 'CubemapFromEquirect',
        uniforms: cloneUniforms(shader.uniforms),
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader,
        side: BackSide,
        blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh1(geometry, material);
    const currentMinFilter = texture.minFilter;
    const currentRenderList = renderer.getRenderList();
    const currentRenderTarget = renderer.getRenderTarget();
    const currentRenderState = renderer.getRenderState();
    if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
    const camera = new CubeCamera1(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    renderer.setRenderTarget(currentRenderTarget);
    renderer.setRenderList(currentRenderList);
    renderer.setRenderState(currentRenderState);
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
};
const WebGLCubeRenderTarget1 = WebGLCubeRenderTarget2;
function WebGLCubeMaps(renderer) {
    let cubemaps = new WeakMap();
    function mapTextureMapping(texture, mapping) {
        if (mapping === EquirectangularReflectionMapping) texture.mapping = CubeReflectionMapping;
        else if (mapping === EquirectangularRefractionMapping) texture.mapping = CubeRefractionMapping;
        return texture;
    }
    function get(texture) {
        if (texture && texture.isTexture) {
            const mapping = texture.mapping;
            if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
                if (cubemaps.has(texture)) {
                    const cubemap = cubemaps.get(texture).texture;
                    return mapTextureMapping(cubemap, texture.mapping);
                } else {
                    const image = texture.image;
                    if (image && image.height > 0) {
                        const renderTarget = new WebGLCubeRenderTarget1(image.height / 2);
                        renderTarget.fromEquirectangularTexture(renderer, texture);
                        cubemaps.set(texture, renderTarget);
                        return mapTextureMapping(renderTarget.texture, texture.mapping);
                    } else // image not yet ready. try the conversion next frame
                    return null;
                }
            }
        }
        return texture;
    }
    function dispose() {
        cubemaps = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
const WebGLCubeMaps1 = WebGLCubeMaps;
function WebGLExtensions(gl) {
    const extensions = {
    };
    return {
        has: function(name) {
            if (extensions[name] !== undefined) return extensions[name];
            let extension;
            switch(name){
                case 'WEBGL_depth_texture':
                    extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
                    break;
                case 'EXT_texture_filter_anisotropic':
                    extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                    break;
                case 'WEBGL_compressed_texture_s3tc':
                    extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                    break;
                case 'WEBGL_compressed_texture_pvrtc':
                    extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                    break;
                default:
                    extension = gl.getExtension(name);
            }
            extensions[name] = extension;
            return !!extension;
        },
        get: function(name) {
            if (!this.has(name)) console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
            return extensions[name];
        }
    };
}
const WebGLExtensions1 = WebGLExtensions;
const _vector4 = new Vector31();
const _vector22 = new Vector21();
function BufferAttribute(array, itemSize, normalized) {
    if (Array.isArray(array)) throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    this.name = '';
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== undefined ? array.length / itemSize : 0;
    this.normalized = normalized === true;
    this.usage = StaticDrawUsage;
    this.updateRange = {
        offset: 0,
        count: -1
    };
    this.version = 0;
}
Object.defineProperty(BufferAttribute.prototype, 'needsUpdate', {
    set: function(value) {
        if (value === true) this.version++;
    }
});
Object.assign(BufferAttribute.prototype, {
    isBufferAttribute: true,
    onUploadCallback: function() {
    },
    setUsage: function(value) {
        this.usage = value;
        return this;
    },
    copy: function(source) {
        this.name = source.name;
        this.array = new source.array.constructor(source.array);
        this.itemSize = source.itemSize;
        this.count = source.count;
        this.normalized = source.normalized;
        this.usage = source.usage;
        return this;
    },
    copyAt: function(index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for(let i1 = 0, l = this.itemSize; i1 < l; i1++)this.array[index1 + i1] = attribute.array[index2 + i1];
        return this;
    },
    copyArray: function(array) {
        this.array.set(array);
        return this;
    },
    copyColorsArray: function(colors) {
        const array = this.array;
        let offset = 0;
        for(let i1 = 0, l = colors.length; i1 < l; i1++){
            let color1 = colors[i1];
            if (color1 === undefined) {
                console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i1);
                color1 = new Color1();
            }
            array[offset++] = color1.r;
            array[offset++] = color1.g;
            array[offset++] = color1.b;
        }
        return this;
    },
    copyVector2sArray: function(vectors) {
        const array = this.array;
        let offset = 0;
        for(let i1 = 0, l = vectors.length; i1 < l; i1++){
            let vector = vectors[i1];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i1);
                vector = new Vector21();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
        }
        return this;
    },
    copyVector3sArray: function(vectors) {
        const array = this.array;
        let offset = 0;
        for(let i1 = 0, l = vectors.length; i1 < l; i1++){
            let vector = vectors[i1];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i1);
                vector = new Vector31();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
        }
        return this;
    },
    copyVector4sArray: function(vectors) {
        const array = this.array;
        let offset = 0;
        for(let i1 = 0, l = vectors.length; i1 < l; i1++){
            let vector = vectors[i1];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i1);
                vector = new Vector41();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
            array[offset++] = vector.w;
        }
        return this;
    },
    applyMatrix3: function(m) {
        if (this.itemSize === 2) for(let i1 = 0, l = this.count; i1 < l; i1++){
            _vector22.fromBufferAttribute(this, i1);
            _vector22.applyMatrix3(m);
            this.setXY(i1, _vector22.x, _vector22.y);
        }
        else if (this.itemSize === 3) for(let i1 = 0, l = this.count; i1 < l; i1++){
            _vector4.fromBufferAttribute(this, i1);
            _vector4.applyMatrix3(m);
            this.setXYZ(i1, _vector4.x, _vector4.y, _vector4.z);
        }
        return this;
    },
    applyMatrix4: function(m) {
        for(let i1 = 0, l = this.count; i1 < l; i1++){
            _vector4.x = this.getX(i1);
            _vector4.y = this.getY(i1);
            _vector4.z = this.getZ(i1);
            _vector4.applyMatrix4(m);
            this.setXYZ(i1, _vector4.x, _vector4.y, _vector4.z);
        }
        return this;
    },
    applyNormalMatrix: function(m) {
        for(let i1 = 0, l = this.count; i1 < l; i1++){
            _vector4.x = this.getX(i1);
            _vector4.y = this.getY(i1);
            _vector4.z = this.getZ(i1);
            _vector4.applyNormalMatrix(m);
            this.setXYZ(i1, _vector4.x, _vector4.y, _vector4.z);
        }
        return this;
    },
    transformDirection: function(m) {
        for(let i1 = 0, l = this.count; i1 < l; i1++){
            _vector4.x = this.getX(i1);
            _vector4.y = this.getY(i1);
            _vector4.z = this.getZ(i1);
            _vector4.transformDirection(m);
            this.setXYZ(i1, _vector4.x, _vector4.y, _vector4.z);
        }
        return this;
    },
    set: function(value, offset) {
        if (offset === undefined) offset = 0;
        this.array.set(value, offset);
        return this;
    },
    getX: function(index) {
        return this.array[index * this.itemSize];
    },
    setX: function(index, x6) {
        this.array[index * this.itemSize] = x6;
        return this;
    },
    getY: function(index) {
        return this.array[index * this.itemSize + 1];
    },
    setY: function(index, y6) {
        this.array[index * this.itemSize + 1] = y6;
        return this;
    },
    getZ: function(index) {
        return this.array[index * this.itemSize + 2];
    },
    setZ: function(index, z5) {
        this.array[index * this.itemSize + 2] = z5;
        return this;
    },
    getW: function(index) {
        return this.array[index * this.itemSize + 3];
    },
    setW: function(index, w3) {
        this.array[index * this.itemSize + 3] = w3;
        return this;
    },
    setXY: function(index, x6, y6) {
        index *= this.itemSize;
        this.array[index + 0] = x6;
        this.array[index + 1] = y6;
        return this;
    },
    setXYZ: function(index, x6, y6, z5) {
        index *= this.itemSize;
        this.array[index + 0] = x6;
        this.array[index + 1] = y6;
        this.array[index + 2] = z5;
        return this;
    },
    setXYZW: function(index, x6, y6, z5, w3) {
        index *= this.itemSize;
        this.array[index + 0] = x6;
        this.array[index + 1] = y6;
        this.array[index + 2] = z5;
        this.array[index + 3] = w3;
        return this;
    },
    onUpload: function(callback) {
        this.onUploadCallback = callback;
        return this;
    },
    clone: function() {
        return new this.constructor(this.array, this.itemSize).copy(this);
    },
    toJSON: function() {
        return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized
        };
    }
});
//
function Int8BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
}
Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
function Uint8BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
}
Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}
Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
function Int16BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
}
Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
function Uint16BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
}
Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
function Int32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
}
Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
function Uint32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
}
Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
function Float32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
}
Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
function Float64BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
}
Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
//
const Float32BufferAttribute1 = Float32BufferAttribute, Uint32BufferAttribute1 = Uint32BufferAttribute, Uint16BufferAttribute1 = Uint16BufferAttribute, BufferAttribute1 = BufferAttribute;
const _points = [
    new Vector31(),
    new Vector31(),
    new Vector31(),
    new Vector31(),
    new Vector31(),
    new Vector31(),
    new Vector31(),
    new Vector31()
];
const _vector5 = new Vector31();
const _box1 = new Box32();
// triangle centered vertices
const _v01 = new Vector31();
const _v14 = new Vector31();
const _v21 = new Vector31();
// triangle edge vectors
const _f0 = new Vector31();
const _f1 = new Vector31();
const _f2 = new Vector31();
const _center = new Vector31();
const _extents = new Vector31();
const _triangleNormal = new Vector31();
const _testAxis = new Vector31();
function Box32(min, max) {
    this.min = min !== undefined ? min : new Vector31(Infinity, Infinity, Infinity);
    this.max = max !== undefined ? max : new Vector31(-Infinity, -Infinity, -Infinity);
}
Object.assign(Box32.prototype, {
    isBox3: true,
    set: function(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    },
    setFromArray: function(array) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for(let i1 = 0, l = array.length; i1 < l; i1 += 3){
            const x6 = array[i1];
            const y6 = array[i1 + 1];
            const z5 = array[i1 + 2];
            if (x6 < minX) minX = x6;
            if (y6 < minY) minY = y6;
            if (z5 < minZ) minZ = z5;
            if (x6 > maxX) maxX = x6;
            if (y6 > maxY) maxY = y6;
            if (z5 > maxZ) maxZ = z5;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
    },
    setFromBufferAttribute: function(attribute) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for(let i1 = 0, l = attribute.count; i1 < l; i1++){
            const x6 = attribute.getX(i1);
            const y6 = attribute.getY(i1);
            const z5 = attribute.getZ(i1);
            if (x6 < minX) minX = x6;
            if (y6 < minY) minY = y6;
            if (z5 < minZ) minZ = z5;
            if (x6 > maxX) maxX = x6;
            if (y6 > maxY) maxY = y6;
            if (z5 > maxZ) maxZ = z5;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
    },
    setFromPoints: function(points) {
        this.makeEmpty();
        for(let i1 = 0, il = points.length; i1 < il; i1++)this.expandByPoint(points[i1]);
        return this;
    },
    setFromCenterAndSize: function(center, size) {
        const halfSize = _vector5.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
    },
    setFromObject: function(object) {
        this.makeEmpty();
        return this.expandByObject(object);
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    },
    makeEmpty: function() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
    },
    isEmpty: function() {
        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    },
    getCenter: function(target) {
        if (target === undefined) {
            console.warn('THREE.Box3: .getCenter() target is now required');
            target = new Vector31();
        }
        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    getSize: function(target) {
        if (target === undefined) {
            console.warn('THREE.Box3: .getSize() target is now required');
            target = new Vector31();
        }
        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    },
    expandByPoint: function(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    },
    expandByVector: function(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    },
    expandByScalar: function(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    },
    expandByObject: function(object) {
        // Computes the world-axis-aligned bounding box of an object (including its children),
        // accounting for both the object's, and children's, world transforms
        object.updateWorldMatrix(false, false);
        const geometry = object.geometry;
        if (geometry !== undefined) {
            if (geometry.boundingBox === null) geometry.computeBoundingBox();
            _box1.copy(geometry.boundingBox);
            _box1.applyMatrix4(object.matrixWorld);
            this.union(_box1);
        }
        const children = object.children;
        for(let i1 = 0, l = children.length; i1 < l; i1++)this.expandByObject(children[i1]);
        return this;
    },
    containsPoint: function(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
    },
    containsBox: function(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    },
    getParameter: function(point, target) {
        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.
        if (target === undefined) {
            console.warn('THREE.Box3: .getParameter() target is now required');
            target = new Vector31();
        }
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    },
    intersectsBox: function(box) {
        // using 6 splitting planes to rule out intersections.
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
    },
    intersectsSphere: function(sphere) {
        // Find the point on the AABB closest to the sphere center.
        this.clampPoint(sphere.center, _vector5);
        // If that point is inside the sphere, the AABB and sphere intersect.
        return _vector5.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    },
    intersectsPlane: function(plane) {
        // We compute the minimum and maximum dot product values. If those values
        // are on the same side (back or front) of the plane, then there is no intersection.
        let min, max;
        if (plane.normal.x > 0) {
            min = plane.normal.x * this.min.x;
            max = plane.normal.x * this.max.x;
        } else {
            min = plane.normal.x * this.max.x;
            max = plane.normal.x * this.min.x;
        }
        if (plane.normal.y > 0) {
            min += plane.normal.y * this.min.y;
            max += plane.normal.y * this.max.y;
        } else {
            min += plane.normal.y * this.max.y;
            max += plane.normal.y * this.min.y;
        }
        if (plane.normal.z > 0) {
            min += plane.normal.z * this.min.z;
            max += plane.normal.z * this.max.z;
        } else {
            min += plane.normal.z * this.max.z;
            max += plane.normal.z * this.min.z;
        }
        return min <= -plane.constant && max >= -plane.constant;
    },
    intersectsTriangle: function(triangle) {
        if (this.isEmpty()) return false;
        // compute box center and extents
        this.getCenter(_center);
        _extents.subVectors(this.max, _center);
        // translate triangle to aabb origin
        _v01.subVectors(triangle.a, _center);
        _v14.subVectors(triangle.b, _center);
        _v21.subVectors(triangle.c, _center);
        // compute edge vectors for triangle
        _f0.subVectors(_v14, _v01);
        _f1.subVectors(_v21, _v14);
        _f2.subVectors(_v01, _v21);
        // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
        // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
        // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
        let axes = [
            0,
            -_f0.z,
            _f0.y,
            0,
            -_f1.z,
            _f1.y,
            0,
            -_f2.z,
            _f2.y,
            _f0.z,
            0,
            -_f0.x,
            _f1.z,
            0,
            -_f1.x,
            _f2.z,
            0,
            -_f2.x,
            -_f0.y,
            _f0.x,
            0,
            -_f1.y,
            _f1.x,
            0,
            -_f2.y,
            _f2.x,
            0
        ];
        if (!satForAxes(axes, _v01, _v14, _v21, _extents)) return false;
        // test 3 face normals from the aabb
        axes = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ];
        if (!satForAxes(axes, _v01, _v14, _v21, _extents)) return false;
        // finally testing the face normal of the triangle
        // use already existing triangle edge vectors here
        _triangleNormal.crossVectors(_f0, _f1);
        axes = [
            _triangleNormal.x,
            _triangleNormal.y,
            _triangleNormal.z
        ];
        return satForAxes(axes, _v01, _v14, _v21, _extents);
    },
    clampPoint: function(point, target) {
        if (target === undefined) {
            console.warn('THREE.Box3: .clampPoint() target is now required');
            target = new Vector31();
        }
        return target.copy(point).clamp(this.min, this.max);
    },
    distanceToPoint: function(point) {
        const clampedPoint = _vector5.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
    },
    getBoundingSphere: function(target) {
        if (target === undefined) console.error('THREE.Box3: .getBoundingSphere() target is now required');
        this.getCenter(target.center);
        target.radius = this.getSize(_vector5).length() * 0.5;
        return target;
    },
    intersect: function(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
        if (this.isEmpty()) this.makeEmpty();
        return this;
    },
    union: function(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    },
    applyMatrix4: function(matrix) {
        // transform of empty box is an empty box.
        if (this.isEmpty()) return this;
        // NOTE: I am using a binary pattern to specify all 2^3 combinations below
        _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111
        this.setFromPoints(_points);
        return this;
    },
    translate: function(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    },
    equals: function(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    }
});
function satForAxes(axes, v0, v1, v2, extents) {
    for(let i1 = 0, j = axes.length - 3; i1 <= j; i1 += 3){
        _testAxis.fromArray(axes, i1);
        // project the aabb onto the seperating axis
        const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
        // project all 3 vertices of the triangle onto the seperating axis
        const p0 = v0.dot(_testAxis);
        const p1 = v1.dot(_testAxis);
        const p2 = v2.dot(_testAxis);
        // actual test, basically see if either of the most extreme of the triangle points intersects r
        if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) // points of the projected triangle are outside the projected half-length of the aabb
        // the axis is seperating and we can exit
        return false;
    }
    return true;
}
const Box31 = Box32;
class DirectGeometry {
    computeGroups(geometry) {
        const groups = [];
        let group, i1;
        let materialIndex1 = undefined;
        const faces = geometry.faces;
        for(i1 = 0; i1 < faces.length; i1++){
            const face = faces[i1];
            // materials
            if (face.materialIndex !== materialIndex1) {
                materialIndex1 = face.materialIndex;
                if (group !== undefined) {
                    group.count = i1 * 3 - group.start;
                    groups.push(group);
                }
                group = {
                    start: i1 * 3,
                    materialIndex: materialIndex1
                };
            }
        }
        if (group !== undefined) {
            group.count = i1 * 3 - group.start;
            groups.push(group);
        }
        this.groups = groups;
    }
    fromGeometry(geometry) {
        const faces = geometry.faces;
        const vertices2 = geometry.vertices;
        const faceVertexUvs = geometry.faceVertexUvs;
        const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
        const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
        // morphs
        const morphTargets = geometry.morphTargets;
        const morphTargetsLength = morphTargets.length;
        let morphTargetsPosition;
        if (morphTargetsLength > 0) {
            morphTargetsPosition = [];
            for(let i1 = 0; i1 < morphTargetsLength; i1++)morphTargetsPosition[i1] = {
                name: morphTargets[i1].name,
                data: []
            };
            this.morphTargets.position = morphTargetsPosition;
        }
        const morphNormals = geometry.morphNormals;
        const morphNormalsLength = morphNormals.length;
        let morphTargetsNormal;
        if (morphNormalsLength > 0) {
            morphTargetsNormal = [];
            for(let i1 = 0; i1 < morphNormalsLength; i1++)morphTargetsNormal[i1] = {
                name: morphNormals[i1].name,
                data: []
            };
            this.morphTargets.normal = morphTargetsNormal;
        }
        // skins
        const skinIndices = geometry.skinIndices;
        const skinWeights = geometry.skinWeights;
        const hasSkinIndices = skinIndices.length === vertices2.length;
        const hasSkinWeights = skinWeights.length === vertices2.length;
        //
        if (vertices2.length > 0 && faces.length === 0) console.error('THREE.DirectGeometry: Faceless geometries are not supported.');
        for(let i1 = 0; i1 < faces.length; i1++){
            const face = faces[i1];
            this.vertices.push(vertices2[face.a], vertices2[face.b], vertices2[face.c]);
            const vertexNormals = face.vertexNormals;
            if (vertexNormals.length === 3) this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
            else {
                const normal2 = face.normal;
                this.normals.push(normal2, normal2, normal2);
            }
            const vertexColors = face.vertexColors;
            if (vertexColors.length === 3) this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
            else {
                const color1 = face.color;
                this.colors.push(color1, color1, color1);
            }
            if (hasFaceVertexUv === true) {
                const vertexUvs = faceVertexUvs[0][i1];
                if (vertexUvs !== undefined) this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                else {
                    console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i1);
                    this.uvs.push(new Vector21(), new Vector21(), new Vector21());
                }
            }
            if (hasFaceVertexUv2 === true) {
                const vertexUvs = faceVertexUvs[1][i1];
                if (vertexUvs !== undefined) this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                else {
                    console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i1);
                    this.uvs2.push(new Vector21(), new Vector21(), new Vector21());
                }
            }
            // morphs
            for(let j = 0; j < morphTargetsLength; j++){
                const morphTarget = morphTargets[j].vertices;
                morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
            }
            for(let j = 0; j < morphNormalsLength; j++){
                const morphNormal = morphNormals[j].vertexNormals[i1];
                morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
            }
            // skins
            if (hasSkinIndices) this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
            if (hasSkinWeights) this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
        }
        this.computeGroups(geometry);
        this.verticesNeedUpdate = geometry.verticesNeedUpdate;
        this.normalsNeedUpdate = geometry.normalsNeedUpdate;
        this.colorsNeedUpdate = geometry.colorsNeedUpdate;
        this.uvsNeedUpdate = geometry.uvsNeedUpdate;
        this.groupsNeedUpdate = geometry.groupsNeedUpdate;
        if (geometry.boundingSphere !== null) this.boundingSphere = geometry.boundingSphere.clone();
        if (geometry.boundingBox !== null) this.boundingBox = geometry.boundingBox.clone();
        return this;
    }
    constructor(){
        this.vertices = [];
        this.normals = [];
        this.colors = [];
        this.uvs = [];
        this.uvs2 = [];
        this.groups = [];
        this.morphTargets = {
        };
        this.skinWeights = [];
        this.skinIndices = [];
        // this.lineDistances = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        // update flags
        this.verticesNeedUpdate = false;
        this.normalsNeedUpdate = false;
        this.colorsNeedUpdate = false;
        this.uvsNeedUpdate = false;
        this.groupsNeedUpdate = false;
    }
}
const DirectGeometry1 = DirectGeometry;
function arrayMax(array) {
    if (array.length === 0) return -Infinity;
    let max = array[0];
    for(let i1 = 1, l = array.length; i1 < l; ++i1)if (array[i1] > max) max = array[i1];
    return max;
}
const arrayMax1 = arrayMax;
let _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id
const _m12 = new Matrix41();
const _obj = new Object3D1();
const _offset = new Vector31();
const _box2 = new Box31();
const _boxMorphTargets = new Box31();
const _vector6 = new Vector31();
function BufferGeometry() {
    Object.defineProperty(this, 'id', {
        value: _bufferGeometryId += 2
    });
    this.uuid = MathUtils1.generateUUID();
    this.name = '';
    this.type = 'BufferGeometry';
    this.index = null;
    this.attributes = {
    };
    this.morphAttributes = {
    };
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = {
        start: 0,
        count: Infinity
    };
    this.userData = {
    };
}
BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher1.prototype), {
    constructor: BufferGeometry,
    isBufferGeometry: true,
    getIndex: function() {
        return this.index;
    },
    setIndex: function(index) {
        if (Array.isArray(index)) this.index = new (arrayMax1(index) > 65535 ? Uint32BufferAttribute1 : Uint16BufferAttribute1)(index, 1);
        else this.index = index;
    },
    getAttribute: function(name) {
        return this.attributes[name];
    },
    setAttribute: function(name, attribute) {
        this.attributes[name] = attribute;
        return this;
    },
    deleteAttribute: function(name) {
        delete this.attributes[name];
        return this;
    },
    addGroup: function(start, count, materialIndex1) {
        this.groups.push({
            start: start,
            count: count,
            materialIndex: materialIndex1 !== undefined ? materialIndex1 : 0
        });
    },
    clearGroups: function() {
        this.groups = [];
    },
    setDrawRange: function(start, count) {
        this.drawRange.start = start;
        this.drawRange.count = count;
    },
    applyMatrix4: function(matrix) {
        const position = this.attributes.position;
        if (position !== undefined) {
            position.applyMatrix4(matrix);
            position.needsUpdate = true;
        }
        const normal2 = this.attributes.normal;
        if (normal2 !== undefined) {
            const normalMatrix = new Matrix31().getNormalMatrix(matrix);
            normal2.applyNormalMatrix(normalMatrix);
            normal2.needsUpdate = true;
        }
        const tangent = this.attributes.tangent;
        if (tangent !== undefined) {
            tangent.transformDirection(matrix);
            tangent.needsUpdate = true;
        }
        if (this.boundingBox !== null) this.computeBoundingBox();
        if (this.boundingSphere !== null) this.computeBoundingSphere();
        return this;
    },
    rotateX: function(angle) {
        // rotate geometry around world x-axis
        _m12.makeRotationX(angle);
        this.applyMatrix4(_m12);
        return this;
    },
    rotateY: function(angle) {
        // rotate geometry around world y-axis
        _m12.makeRotationY(angle);
        this.applyMatrix4(_m12);
        return this;
    },
    rotateZ: function(angle) {
        // rotate geometry around world z-axis
        _m12.makeRotationZ(angle);
        this.applyMatrix4(_m12);
        return this;
    },
    translate: function(x6, y6, z5) {
        // translate geometry
        _m12.makeTranslation(x6, y6, z5);
        this.applyMatrix4(_m12);
        return this;
    },
    scale: function(x6, y6, z5) {
        // scale geometry
        _m12.makeScale(x6, y6, z5);
        this.applyMatrix4(_m12);
        return this;
    },
    lookAt: function(vector) {
        _obj.lookAt(vector);
        _obj.updateMatrix();
        this.applyMatrix4(_obj.matrix);
        return this;
    },
    center: function() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(_offset).negate();
        this.translate(_offset.x, _offset.y, _offset.z);
        return this;
    },
    setFromObject: function(object) {
        // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
        const geometry = object.geometry;
        if (object.isPoints || object.isLine) {
            const positions = new Float32BufferAttribute1(geometry.vertices.length * 3, 3);
            const colors = new Float32BufferAttribute1(geometry.colors.length * 3, 3);
            this.setAttribute('position', positions.copyVector3sArray(geometry.vertices));
            this.setAttribute('color', colors.copyColorsArray(geometry.colors));
            if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
                const lineDistances = new Float32BufferAttribute1(geometry.lineDistances.length, 1);
                this.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
            }
            if (geometry.boundingSphere !== null) this.boundingSphere = geometry.boundingSphere.clone();
            if (geometry.boundingBox !== null) this.boundingBox = geometry.boundingBox.clone();
        } else if (object.isMesh) {
            if (geometry && geometry.isGeometry) this.fromGeometry(geometry);
        }
        return this;
    },
    setFromPoints: function(points) {
        const position = [];
        for(let i1 = 0, l = points.length; i1 < l; i1++){
            const point = points[i1];
            position.push(point.x, point.y, point.z || 0);
        }
        this.setAttribute('position', new Float32BufferAttribute1(position, 3));
        return this;
    },
    updateFromObject: function(object) {
        let geometry = object.geometry;
        if (object.isMesh) {
            let direct = geometry.__directGeometry;
            if (geometry.elementsNeedUpdate === true) {
                direct = undefined;
                geometry.elementsNeedUpdate = false;
            }
            if (direct === undefined) return this.fromGeometry(geometry);
            direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
            direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
            direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
            direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
            direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
            geometry.verticesNeedUpdate = false;
            geometry.normalsNeedUpdate = false;
            geometry.colorsNeedUpdate = false;
            geometry.uvsNeedUpdate = false;
            geometry.groupsNeedUpdate = false;
            geometry = direct;
        }
        if (geometry.verticesNeedUpdate === true) {
            const attribute = this.attributes.position;
            if (attribute !== undefined) {
                attribute.copyVector3sArray(geometry.vertices);
                attribute.needsUpdate = true;
            }
            geometry.verticesNeedUpdate = false;
        }
        if (geometry.normalsNeedUpdate === true) {
            const attribute = this.attributes.normal;
            if (attribute !== undefined) {
                attribute.copyVector3sArray(geometry.normals);
                attribute.needsUpdate = true;
            }
            geometry.normalsNeedUpdate = false;
        }
        if (geometry.colorsNeedUpdate === true) {
            const attribute = this.attributes.color;
            if (attribute !== undefined) {
                attribute.copyColorsArray(geometry.colors);
                attribute.needsUpdate = true;
            }
            geometry.colorsNeedUpdate = false;
        }
        if (geometry.uvsNeedUpdate) {
            const attribute = this.attributes.uv;
            if (attribute !== undefined) {
                attribute.copyVector2sArray(geometry.uvs);
                attribute.needsUpdate = true;
            }
            geometry.uvsNeedUpdate = false;
        }
        if (geometry.lineDistancesNeedUpdate) {
            const attribute = this.attributes.lineDistance;
            if (attribute !== undefined) {
                attribute.copyArray(geometry.lineDistances);
                attribute.needsUpdate = true;
            }
            geometry.lineDistancesNeedUpdate = false;
        }
        if (geometry.groupsNeedUpdate) {
            geometry.computeGroups(object.geometry);
            this.groups = geometry.groups;
            geometry.groupsNeedUpdate = false;
        }
        return this;
    },
    fromGeometry: function(geometry) {
        geometry.__directGeometry = new DirectGeometry1().fromGeometry(geometry);
        return this.fromDirectGeometry(geometry.__directGeometry);
    },
    fromDirectGeometry: function(geometry) {
        const positions = new Float32Array(geometry.vertices.length * 3);
        this.setAttribute('position', new BufferAttribute1(positions, 3).copyVector3sArray(geometry.vertices));
        if (geometry.normals.length > 0) {
            const normals2 = new Float32Array(geometry.normals.length * 3);
            this.setAttribute('normal', new BufferAttribute1(normals2, 3).copyVector3sArray(geometry.normals));
        }
        if (geometry.colors.length > 0) {
            const colors = new Float32Array(geometry.colors.length * 3);
            this.setAttribute('color', new BufferAttribute1(colors, 3).copyColorsArray(geometry.colors));
        }
        if (geometry.uvs.length > 0) {
            const uvs2 = new Float32Array(geometry.uvs.length * 2);
            this.setAttribute('uv', new BufferAttribute1(uvs2, 2).copyVector2sArray(geometry.uvs));
        }
        if (geometry.uvs2.length > 0) {
            const uvs2 = new Float32Array(geometry.uvs2.length * 2);
            this.setAttribute('uv2', new BufferAttribute1(uvs2, 2).copyVector2sArray(geometry.uvs2));
        }
        // groups
        this.groups = geometry.groups;
        // morphs
        for(const name in geometry.morphTargets){
            const array = [];
            const morphTargets = geometry.morphTargets[name];
            for(let i1 = 0, l = morphTargets.length; i1 < l; i1++){
                const morphTarget = morphTargets[i1];
                const attribute = new Float32BufferAttribute1(morphTarget.data.length * 3, 3);
                attribute.name = morphTarget.name;
                array.push(attribute.copyVector3sArray(morphTarget.data));
            }
            this.morphAttributes[name] = array;
        }
        // skinning
        if (geometry.skinIndices.length > 0) {
            const skinIndices = new Float32BufferAttribute1(geometry.skinIndices.length * 4, 4);
            this.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
        }
        if (geometry.skinWeights.length > 0) {
            const skinWeights = new Float32BufferAttribute1(geometry.skinWeights.length * 4, 4);
            this.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
        }
        //
        if (geometry.boundingSphere !== null) this.boundingSphere = geometry.boundingSphere.clone();
        if (geometry.boundingBox !== null) this.boundingBox = geometry.boundingBox.clone();
        return this;
    },
    computeBoundingBox: function() {
        if (this.boundingBox === null) this.boundingBox = new Box31();
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position !== undefined) {
            this.boundingBox.setFromBufferAttribute(position);
            // process morph attributes if present
            if (morphAttributesPosition) for(let i1 = 0, il = morphAttributesPosition.length; i1 < il; i1++){
                const morphAttribute = morphAttributesPosition[i1];
                _box2.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                    _vector6.addVectors(this.boundingBox.min, _box2.min);
                    this.boundingBox.expandByPoint(_vector6);
                    _vector6.addVectors(this.boundingBox.max, _box2.max);
                    this.boundingBox.expandByPoint(_vector6);
                } else {
                    this.boundingBox.expandByPoint(_box2.min);
                    this.boundingBox.expandByPoint(_box2.max);
                }
            }
        } else this.boundingBox.makeEmpty();
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    },
    computeBoundingSphere: function() {
        if (this.boundingSphere === null) this.boundingSphere = new Sphere1();
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position) {
            // first, find the center of the bounding sphere
            const center = this.boundingSphere.center;
            _box2.setFromBufferAttribute(position);
            // process morph attributes if present
            if (morphAttributesPosition) for(let i1 = 0, il = morphAttributesPosition.length; i1 < il; i1++){
                const morphAttribute = morphAttributesPosition[i1];
                _boxMorphTargets.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                    _vector6.addVectors(_box2.min, _boxMorphTargets.min);
                    _box2.expandByPoint(_vector6);
                    _vector6.addVectors(_box2.max, _boxMorphTargets.max);
                    _box2.expandByPoint(_vector6);
                } else {
                    _box2.expandByPoint(_boxMorphTargets.min);
                    _box2.expandByPoint(_boxMorphTargets.max);
                }
            }
            _box2.getCenter(center);
            // second, try to find a boundingSphere with a radius smaller than the
            // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
            let maxRadiusSq = 0;
            for(let i1 = 0, il = position.count; i1 < il; i1++){
                _vector6.fromBufferAttribute(position, i1);
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector6));
            }
            // process morph attributes if present
            if (morphAttributesPosition) for(let i1 = 0, il = morphAttributesPosition.length; i1 < il; i1++){
                const morphAttribute = morphAttributesPosition[i1];
                const morphTargetsRelative = this.morphTargetsRelative;
                for(let j = 0, jl = morphAttribute.count; j < jl; j++){
                    _vector6.fromBufferAttribute(morphAttribute, j);
                    if (morphTargetsRelative) {
                        _offset.fromBufferAttribute(position, j);
                        _vector6.add(_offset);
                    }
                    maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector6));
                }
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
    },
    computeFaceNormals: function() {
    },
    computeVertexNormals: function() {
        const index = this.index;
        const positionAttribute = this.getAttribute('position');
        if (positionAttribute !== undefined) {
            let normalAttribute = this.getAttribute('normal');
            if (normalAttribute === undefined) {
                normalAttribute = new BufferAttribute1(new Float32Array(positionAttribute.count * 3), 3);
                this.setAttribute('normal', normalAttribute);
            } else // reset existing normals to zero
            for(let i1 = 0, il = normalAttribute.count; i1 < il; i1++)normalAttribute.setXYZ(i1, 0, 0, 0);
            const pA = new Vector31(), pB = new Vector31(), pC = new Vector31();
            const nA = new Vector31(), nB = new Vector31(), nC = new Vector31();
            const cb = new Vector31(), ab = new Vector31();
            // indexed elements
            if (index) for(let i1 = 0, il = index.count; i1 < il; i1 += 3){
                const vA = index.getX(i1 + 0);
                const vB = index.getX(i1 + 1);
                const vC = index.getX(i1 + 2);
                pA.fromBufferAttribute(positionAttribute, vA);
                pB.fromBufferAttribute(positionAttribute, vB);
                pC.fromBufferAttribute(positionAttribute, vC);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                nA.fromBufferAttribute(normalAttribute, vA);
                nB.fromBufferAttribute(normalAttribute, vB);
                nC.fromBufferAttribute(normalAttribute, vC);
                nA.add(cb);
                nB.add(cb);
                nC.add(cb);
                normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
                normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
                normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
            }
            else // non-indexed elements (unconnected triangle soup)
            for(let i1 = 0, il = positionAttribute.count; i1 < il; i1 += 3){
                pA.fromBufferAttribute(positionAttribute, i1 + 0);
                pB.fromBufferAttribute(positionAttribute, i1 + 1);
                pC.fromBufferAttribute(positionAttribute, i1 + 2);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                normalAttribute.setXYZ(i1 + 0, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i1 + 1, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i1 + 2, cb.x, cb.y, cb.z);
            }
            this.normalizeNormals();
            normalAttribute.needsUpdate = true;
        }
    },
    merge: function(geometry, offset) {
        if (!(geometry && geometry.isBufferGeometry)) {
            console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
            return;
        }
        if (offset === undefined) {
            offset = 0;
            console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
        }
        const attributes = this.attributes;
        for(const key in attributes){
            if (geometry.attributes[key] === undefined) continue;
            const attribute1 = attributes[key];
            const attributeArray1 = attribute1.array;
            const attribute2 = geometry.attributes[key];
            const attributeArray2 = attribute2.array;
            const attributeOffset = attribute2.itemSize * offset;
            const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
            for(let i1 = 0, j = attributeOffset; i1 < length; (i1++, j++))attributeArray1[j] = attributeArray2[i1];
        }
        return this;
    },
    normalizeNormals: function() {
        const normals2 = this.attributes.normal;
        for(let i1 = 0, il = normals2.count; i1 < il; i1++){
            _vector6.fromBufferAttribute(normals2, i1);
            _vector6.normalize();
            normals2.setXYZ(i1, _vector6.x, _vector6.y, _vector6.z);
        }
    },
    toNonIndexed: function() {
        function convertBufferAttribute(attribute, indices2) {
            const array = attribute.array;
            const itemSize = attribute.itemSize;
            const normalized = attribute.normalized;
            const array2 = new array.constructor(indices2.length * itemSize);
            let index = 0, index2 = 0;
            for(let i1 = 0, l = indices2.length; i1 < l; i1++){
                index = indices2[i1] * itemSize;
                for(let j = 0; j < itemSize; j++)array2[index2++] = array[index++];
            }
            return new BufferAttribute1(array2, itemSize, normalized);
        }
        //
        if (this.index === null) {
            console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
            return this;
        }
        const geometry2 = new BufferGeometry();
        const indices2 = this.index.array;
        const attributes = this.attributes;
        // attributes
        for(const name in attributes){
            const attribute = attributes[name];
            const newAttribute = convertBufferAttribute(attribute, indices2);
            geometry2.setAttribute(name, newAttribute);
        }
        // morph attributes
        const morphAttributes = this.morphAttributes;
        for(const name in morphAttributes){
            const morphArray = [];
            const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes
            for(let i1 = 0, il = morphAttribute.length; i1 < il; i1++){
                const attribute = morphAttribute[i1];
                const newAttribute = convertBufferAttribute(attribute, indices2);
                morphArray.push(newAttribute);
            }
            geometry2.morphAttributes[name] = morphArray;
        }
        geometry2.morphTargetsRelative = this.morphTargetsRelative;
        // groups
        const groups = this.groups;
        for(let i1 = 0, l = groups.length; i1 < l; i1++){
            const group = groups[i1];
            geometry2.addGroup(group.start, group.count, group.materialIndex);
        }
        return geometry2;
    },
    toJSON: function() {
        const data = {
            metadata: {
                version: 4.5,
                type: 'BufferGeometry',
                generator: 'BufferGeometry.toJSON'
            }
        };
        // standard BufferGeometry serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '') data.name = this.name;
        if (Object.keys(this.userData).length > 0) data.userData = this.userData;
        if (this.parameters !== undefined) {
            const parameters = this.parameters;
            for(const key in parameters)if (parameters[key] !== undefined) data[key] = parameters[key];
            return data;
        }
        data.data = {
            attributes: {
            }
        };
        const index = this.index;
        if (index !== null) data.data.index = {
            type: index.array.constructor.name,
            array: Array.prototype.slice.call(index.array)
        };
        const attributes = this.attributes;
        for(const key in attributes){
            const attribute = attributes[key];
            const attributeData = attribute.toJSON(data.data);
            if (attribute.name !== '') attributeData.name = attribute.name;
            data.data.attributes[key] = attributeData;
        }
        const morphAttributes = {
        };
        let hasMorphAttributes = false;
        for(const key in this.morphAttributes){
            const attributeArray = this.morphAttributes[key];
            const array = [];
            for(let i1 = 0, il = attributeArray.length; i1 < il; i1++){
                const attribute = attributeArray[i1];
                const attributeData = attribute.toJSON(data.data);
                if (attribute.name !== '') attributeData.name = attribute.name;
                array.push(attributeData);
            }
            if (array.length > 0) {
                morphAttributes[key] = array;
                hasMorphAttributes = true;
            }
        }
        if (hasMorphAttributes) {
            data.data.morphAttributes = morphAttributes;
            data.data.morphTargetsRelative = this.morphTargetsRelative;
        }
        const groups = this.groups;
        if (groups.length > 0) data.data.groups = JSON.parse(JSON.stringify(groups));
        const boundingSphere = this.boundingSphere;
        if (boundingSphere !== null) data.data.boundingSphere = {
            center: boundingSphere.center.toArray(),
            radius: boundingSphere.radius
        };
        return data;
    },
    clone: function() {
        /*
		 // Handle primitives

		 const parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 const values = [];

		 for ( const key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 const geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */
        return new BufferGeometry().copy(this);
    },
    copy: function(source) {
        // reset
        this.index = null;
        this.attributes = {
        };
        this.morphAttributes = {
        };
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        // used for storing cloned, shared data
        const data = {
        };
        // name
        this.name = source.name;
        // index
        const index = source.index;
        if (index !== null) this.setIndex(index.clone(data));
        // attributes
        const attributes = source.attributes;
        for(const name in attributes){
            const attribute = attributes[name];
            this.setAttribute(name, attribute.clone(data));
        }
        // morph attributes
        const morphAttributes = source.morphAttributes;
        for(const name in morphAttributes){
            const array = [];
            const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes
            for(let i1 = 0, l = morphAttribute.length; i1 < l; i1++)array.push(morphAttribute[i1].clone(data));
            this.morphAttributes[name] = array;
        }
        this.morphTargetsRelative = source.morphTargetsRelative;
        // groups
        const groups = source.groups;
        for(let i1 = 0, l = groups.length; i1 < l; i1++){
            const group = groups[i1];
            this.addGroup(group.start, group.count, group.materialIndex);
        }
        // bounding box
        const boundingBox = source.boundingBox;
        if (boundingBox !== null) this.boundingBox = boundingBox.clone();
        // bounding sphere
        const boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) this.boundingSphere = boundingSphere.clone();
        // draw range
        this.drawRange.start = source.drawRange.start;
        this.drawRange.count = source.drawRange.count;
        // user data
        this.userData = source.userData;
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
});
const BufferGeometry1 = BufferGeometry;
function WebGLGeometries(gl, attributes, info, bindingStates) {
    const geometries = new WeakMap();
    const wireframeAttributes = new WeakMap();
    function onGeometryDispose(event) {
        const geometry = event.target;
        const buffergeometry = geometries.get(geometry);
        if (buffergeometry.index !== null) attributes.remove(buffergeometry.index);
        for(const name in buffergeometry.attributes)attributes.remove(buffergeometry.attributes[name]);
        geometry.removeEventListener('dispose', onGeometryDispose);
        geometries.delete(geometry);
        const attribute = wireframeAttributes.get(buffergeometry);
        if (attribute) {
            attributes.remove(attribute);
            wireframeAttributes.delete(buffergeometry);
        }
        bindingStates.releaseStatesOfGeometry(geometry);
        if (geometry.isInstancedBufferGeometry === true) delete geometry._maxInstanceCount;
        //
        info.memory.geometries--;
    }
    function get(object, geometry) {
        let buffergeometry = geometries.get(geometry);
        if (buffergeometry) return buffergeometry;
        geometry.addEventListener('dispose', onGeometryDispose);
        if (geometry.isBufferGeometry) buffergeometry = geometry;
        else if (geometry.isGeometry) {
            if (geometry._bufferGeometry === undefined) geometry._bufferGeometry = new BufferGeometry1().setFromObject(object);
            buffergeometry = geometry._bufferGeometry;
        }
        geometries.set(geometry, buffergeometry);
        info.memory.geometries++;
        return buffergeometry;
    }
    function update(geometry) {
        const geometryAttributes = geometry.attributes;
        // Updating index buffer in VAO now. See WebGLBindingStates.
        for(const name in geometryAttributes)attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
        // morph targets
        const morphAttributes = geometry.morphAttributes;
        for(const name in morphAttributes){
            const array = morphAttributes[name];
            for(let i1 = 0, l = array.length; i1 < l; i1++)attributes.update(array[i1], gl.ARRAY_BUFFER);
        }
    }
    function updateWireframeAttribute(geometry) {
        const indices2 = [];
        const geometryIndex = geometry.index;
        const geometryPosition = geometry.attributes.position;
        let version = 0;
        if (geometryIndex !== null) {
            const array = geometryIndex.array;
            version = geometryIndex.version;
            for(let i1 = 0, l = array.length; i1 < l; i1 += 3){
                const a2 = array[i1 + 0];
                const b2 = array[i1 + 1];
                const c2 = array[i1 + 2];
                indices2.push(a2, b2, b2, c2, c2, a2);
            }
        } else {
            const array = geometryPosition.array;
            version = geometryPosition.version;
            for(let i1 = 0, l = array.length / 3 - 1; i1 < l; i1 += 3){
                const a2 = i1 + 0;
                const b2 = i1 + 1;
                const c2 = i1 + 2;
                indices2.push(a2, b2, b2, c2, c2, a2);
            }
        }
        const attribute = new (arrayMax1(indices2) > 65535 ? Uint32BufferAttribute1 : Uint16BufferAttribute1)(indices2, 1);
        attribute.version = version;
        // Updating index buffer in VAO now. See WebGLBindingStates
        //
        const previousAttribute = wireframeAttributes.get(geometry);
        if (previousAttribute) attributes.remove(previousAttribute);
        //
        wireframeAttributes.set(geometry, attribute);
    }
    function getWireframeAttribute(geometry) {
        const currentAttribute = wireframeAttributes.get(geometry);
        if (currentAttribute) {
            const geometryIndex = geometry.index;
            if (geometryIndex !== null) // if the attribute is obsolete, create a new one
            {
                if (currentAttribute.version < geometryIndex.version) updateWireframeAttribute(geometry);
            }
        } else updateWireframeAttribute(geometry);
        return wireframeAttributes.get(geometry);
    }
    return {
        get: get,
        update: update,
        getWireframeAttribute: getWireframeAttribute
    };
}
const WebGLGeometries1 = WebGLGeometries;
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
        mode = value;
    }
    let type, bytesPerElement;
    function setIndex(value) {
        type = value.type;
        bytesPerElement = value.bytesPerElement;
    }
    function render(start, count) {
        gl.drawElements(mode, count, type, start * bytesPerElement);
        info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
        if (primcount === 0) return;
        let extension, methodName;
        if (isWebGL2) {
        } else {
            extension = extensions.get('ANGLE_instanced_arrays');
            if (extension === null) {
                console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
        }
        extension[methodName](mode, count, type, start * bytesPerElement, primcount);
        info.update(count, mode, primcount);
    }
    //
    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;
}
const WebGLIndexedBufferRenderer1 = WebGLIndexedBufferRenderer;
function WebGLInfo(gl) {
    const memory = {
        geometries: 0,
        textures: 0
    };
    const render = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function update(count, mode, instanceCount) {
        render.calls++;
        switch(mode){
            case gl.TRIANGLES:
                render.triangles += instanceCount * (count / 3);
                break;
            case gl.LINES:
                render.lines += instanceCount * (count / 2);
                break;
            case gl.LINE_STRIP:
                render.lines += instanceCount * (count - 1);
                break;
            case gl.LINE_LOOP:
                render.lines += instanceCount * count;
                break;
            case gl.POINTS:
                render.points += instanceCount * count;
                break;
            default:
                console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
                break;
        }
    }
    function reset() {
        render.frame++;
        render.calls = 0;
        render.triangles = 0;
        render.points = 0;
        render.lines = 0;
    }
    return {
        memory: memory,
        render: render,
        programs: null,
        autoReset: true,
        reset: reset,
        update: update
    };
}
const WebGLInfo1 = WebGLInfo;
function numericalSort(a2, b2) {
    return a2[0] - b2[0];
}
function absNumericalSort(a2, b2) {
    return Math.abs(b2[1]) - Math.abs(a2[1]);
}
function WebGLMorphtargets(gl) {
    const influencesList = {
    };
    const morphInfluences = new Float32Array(8);
    const workInfluences = [];
    for(let i1 = 0; i1 < 8; i1++)workInfluences[i1] = [
        i1,
        0
    ];
    function update(object, geometry, material, program) {
        const objectInfluences = object.morphTargetInfluences;
        // When object doesn't have morph target influences defined, we treat it as a 0-length array
        // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
        const length = objectInfluences === undefined ? 0 : objectInfluences.length;
        let influences = influencesList[geometry.id];
        if (influences === undefined) {
            // initialise list
            influences = [];
            for(let i11 = 0; i11 < length; i11++)influences[i11] = [
                i11,
                0
            ];
            influencesList[geometry.id] = influences;
        }
        // Collect influences
        for(let i11 = 0; i11 < length; i11++){
            const influence = influences[i11];
            influence[0] = i11;
            influence[1] = objectInfluences[i11];
        }
        influences.sort(absNumericalSort);
        for(let i11 = 0; i11 < 8; i11++)if (i11 < length && influences[i11][1]) {
            workInfluences[i11][0] = influences[i11][0];
            workInfluences[i11][1] = influences[i11][1];
        } else {
            workInfluences[i11][0] = Number.MAX_SAFE_INTEGER;
            workInfluences[i11][1] = 0;
        }
        workInfluences.sort(numericalSort);
        const morphTargets = material.morphTargets && geometry.morphAttributes.position;
        const morphNormals = material.morphNormals && geometry.morphAttributes.normal;
        let morphInfluencesSum = 0;
        for(let i11 = 0; i11 < 8; i11++){
            const influence = workInfluences[i11];
            const index = influence[0];
            const value = influence[1];
            if (index !== Number.MAX_SAFE_INTEGER && value) {
                if (morphTargets && geometry.getAttribute('morphTarget' + i11) !== morphTargets[index]) geometry.setAttribute('morphTarget' + i11, morphTargets[index]);
                if (morphNormals && geometry.getAttribute('morphNormal' + i11) !== morphNormals[index]) geometry.setAttribute('morphNormal' + i11, morphNormals[index]);
                morphInfluences[i11] = value;
            } else {
                if (morphTargets && geometry.getAttribute('morphTarget' + i11) !== undefined) geometry.deleteAttribute('morphTarget' + i11);
                if (morphNormals && geometry.getAttribute('morphNormal' + i11) !== undefined) geometry.deleteAttribute('morphNormal' + i11);
                morphInfluences[i11] = 0;
            }
        }
        // GLSL shader uses formula baseinfluence * base + sum(target * influence)
        // This allows us to switch between absolute morphs and relative morphs without changing shader code
        // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
        const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
        program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
    }
    return {
        update: update
    };
}
const WebGLMorphtargets1 = WebGLMorphtargets;
function WebGLObjects(gl, geometries, attributes, info) {
    let updateMap = new WeakMap();
    function update(object) {
        const frame = info.render.frame;
        const geometry = object.geometry;
        const buffergeometry = geometries.get(object, geometry);
        // Update once per frame
        if (updateMap.get(buffergeometry) !== frame) {
            if (geometry.isGeometry) buffergeometry.updateFromObject(object);
            geometries.update(buffergeometry);
            updateMap.set(buffergeometry, frame);
        }
        if (object.isInstancedMesh) {
            attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
            if (object.instanceColor !== null) attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
        }
        return buffergeometry;
    }
    function dispose() {
        updateMap = new WeakMap();
    }
    return {
        update: update,
        dispose: dispose
    };
}
const WebGLObjects1 = WebGLObjects;
function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    images = images !== undefined ? images : [];
    mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
    format = format !== undefined ? format : RGBFormat;
    Texture1.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.flipY = false;
}
CubeTexture.prototype = Object.create(Texture1.prototype);
CubeTexture.prototype.constructor = CubeTexture;
CubeTexture.prototype.isCubeTexture = true;
Object.defineProperty(CubeTexture.prototype, 'images', {
    get: function() {
        return this.image;
    },
    set: function(value) {
        this.image = value;
    }
});
const CubeTexture1 = CubeTexture;
function DataTexture2DArray(data, width2, height2, depth1) {
    Texture1.call(this, null);
    this.image = {
        data: data || null,
        width: width2 || 1,
        height: height2 || 1,
        depth: depth1 || 1
    };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
}
DataTexture2DArray.prototype = Object.create(Texture1.prototype);
DataTexture2DArray.prototype.constructor = DataTexture2DArray;
DataTexture2DArray.prototype.isDataTexture2DArray = true;
const DataTexture2DArray1 = DataTexture2DArray;
function DataTexture3D(data, width2, height2, depth1) {
    // We're going to add .setXXX() methods for setting properties later.
    // Users can still set in DataTexture3D directly.
    //
    //	const texture = new THREE.DataTexture3D( data, width, height, depth );
    // 	texture.anisotropy = 16;
    //
    // See #14839
    Texture1.call(this, null);
    this.image = {
        data: data || null,
        width: width2 || 1,
        height: height2 || 1,
        depth: depth1 || 1
    };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
}
DataTexture3D.prototype = Object.create(Texture1.prototype);
DataTexture3D.prototype.constructor = DataTexture3D;
DataTexture3D.prototype.isDataTexture3D = true;
const DataTexture3D1 = DataTexture3D;
const emptyTexture = new Texture1();
const emptyTexture2dArray = new DataTexture2DArray1();
const emptyTexture3d = new DataTexture3D1();
const emptyCubeTexture = new CubeTexture1();
// --- Utilities ---
// Array Caches (provide typed arrays for temporary by size)
const arrayCacheF32 = [];
const arrayCacheI32 = [];
// Float32Array caches used for uploading Matrix uniforms
const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4);
// Flattening for arrays of vectors and matrices
function flatten(array, nBlocks, blockSize) {
    const firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0) return array;
    // unoptimized: ! isNaN( firstElem )
    // see http://jacksondunstan.com/articles/983
    const n = nBlocks * blockSize;
    let r = arrayCacheF32[n];
    if (r === undefined) {
        r = new Float32Array(n);
        arrayCacheF32[n] = r;
    }
    if (nBlocks !== 0) {
        firstElem.toArray(r, 0);
        for(let i1 = 1, offset = 0; i1 !== nBlocks; ++i1){
            offset += blockSize;
            array[i1].toArray(r, offset);
        }
    }
    return r;
}
function arraysEqual(a2, b2) {
    if (a2.length !== b2.length) return false;
    for(let i1 = 0, l = a2.length; i1 < l; i1++)if (a2[i1] !== b2[i1]) return false;
    return true;
}
function copyArray(a2, b2) {
    for(let i1 = 0, l = b2.length; i1 < l; i1++)a2[i1] = b2[i1];
}
// Texture unit allocation
function allocTexUnits(textures, n) {
    let r = arrayCacheI32[n];
    if (r === undefined) {
        r = new Int32Array(n);
        arrayCacheI32[n] = r;
    }
    for(let i1 = 0; i1 !== n; ++i1)r[i1] = textures.allocateTextureUnit();
    return r;
}
// --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar
function setValueV1f(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1f(this.addr, v);
    cache[0] = v;
}
// Single float vector (from flat array or THREE.VectorN)
function setValueV2f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y) {
            gl.uniform2f(this.addr, v.x, v.y);
            cache[0] = v.x;
            cache[1] = v.y;
        }
    } else {
        if (arraysEqual(cache, v)) return;
        gl.uniform2fv(this.addr, v);
        copyArray(cache, v);
    }
}
function setValueV3f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
            gl.uniform3f(this.addr, v.x, v.y, v.z);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
        }
    } else if (v.r !== undefined) {
        if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
            gl.uniform3f(this.addr, v.r, v.g, v.b);
            cache[0] = v.r;
            cache[1] = v.g;
            cache[2] = v.b;
        }
    } else {
        if (arraysEqual(cache, v)) return;
        gl.uniform3fv(this.addr, v);
        copyArray(cache, v);
    }
}
function setValueV4f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
            gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
            cache[3] = v.w;
        }
    } else {
        if (arraysEqual(cache, v)) return;
        gl.uniform4fv(this.addr, v);
        copyArray(cache, v);
    }
}
// Single matrix (from flat array or MatrixN)
function setValueM2(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if (arraysEqual(cache, v)) return;
        gl.uniformMatrix2fv(this.addr, false, v);
        copyArray(cache, v);
    } else {
        if (arraysEqual(cache, elements)) return;
        mat2array.set(elements);
        gl.uniformMatrix2fv(this.addr, false, mat2array);
        copyArray(cache, elements);
    }
}
function setValueM3(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if (arraysEqual(cache, v)) return;
        gl.uniformMatrix3fv(this.addr, false, v);
        copyArray(cache, v);
    } else {
        if (arraysEqual(cache, elements)) return;
        mat3array.set(elements);
        gl.uniformMatrix3fv(this.addr, false, mat3array);
        copyArray(cache, elements);
    }
}
function setValueM4(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if (arraysEqual(cache, v)) return;
        gl.uniformMatrix4fv(this.addr, false, v);
        copyArray(cache, v);
    } else {
        if (arraysEqual(cache, elements)) return;
        mat4array.set(elements);
        gl.uniformMatrix4fv(this.addr, false, mat4array);
        copyArray(cache, elements);
    }
}
// Single texture (2D / Cube)
function setValueT1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.safeSetTexture2D(v || emptyTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.setTexture2DArray(v || emptyTexture2dArray, unit);
}
function setValueT3D1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.setTexture3D(v || emptyTexture3d, unit);
}
function setValueT6(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.safeSetTextureCube(v || emptyCubeTexture, unit);
}
// Integer / Boolean vectors or arrays thereof (always flat arrays)
function setValueV1i(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1i(this.addr, v);
    cache[0] = v;
}
function setValueV2i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform2iv(this.addr, v);
    copyArray(cache, v);
}
function setValueV3i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform3iv(this.addr, v);
    copyArray(cache, v);
}
function setValueV4i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform4iv(this.addr, v);
    copyArray(cache, v);
}
// uint
function setValueV1ui(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1ui(this.addr, v);
    cache[0] = v;
}
// Helper to pick the right setter for the singular case
function getSingularSetter(type) {
    switch(type){
        case 5126:
            return setValueV1f; // FLOAT
        case 35664:
            return setValueV2f; // _VEC2
        case 35665:
            return setValueV3f; // _VEC3
        case 35666:
            return setValueV4f; // _VEC4
        case 35674:
            return setValueM2; // _MAT2
        case 35675:
            return setValueM3; // _MAT3
        case 35676:
            return setValueM4; // _MAT4
        case 5124:
        case 35670:
            return setValueV1i; // INT, BOOL
        case 35667:
        case 35671:
            return setValueV2i; // _VEC2
        case 35668:
        case 35672:
            return setValueV3i; // _VEC3
        case 35669:
        case 35673:
            return setValueV4i; // _VEC4
        case 5125:
            return setValueV1ui; // UINT
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return setValueT1;
        case 35679:
        case 36299:
        case 36307:
            return setValueT3D1;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return setValueT6;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return setValueT2DArray1;
    }
}
// Array of scalars
function setValueV1fArray(gl, v) {
    gl.uniform1fv(this.addr, v);
}
// Integer / Boolean vectors or arrays thereof (always flat arrays)
function setValueV1iArray(gl, v) {
    gl.uniform1iv(this.addr, v);
}
function setValueV2iArray(gl, v) {
    gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
    gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
    gl.uniform4iv(this.addr, v);
}
// Array of vectors (flat or from THREE classes)
function setValueV2fArray(gl, v) {
    const data = flatten(v, this.size, 2);
    gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
    const data = flatten(v, this.size, 3);
    gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniform4fv(this.addr, data);
}
// Array of matrices (flat or from THREE clases)
function setValueM2Array(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
    const data = flatten(v, this.size, 9);
    gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
    const data = flatten(v, this.size, 16);
    gl.uniformMatrix4fv(this.addr, false, data);
}
// Array of textures (2D / Cube)
function setValueT1Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for(let i1 = 0; i1 !== n; ++i1)textures.safeSetTexture2D(v[i1] || emptyTexture, units[i1]);
}
function setValueT6Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for(let i1 = 0; i1 !== n; ++i1)textures.safeSetTextureCube(v[i1] || emptyCubeTexture, units[i1]);
}
// Helper to pick the right setter for a pure (bottom-level) array
function getPureArraySetter(type) {
    switch(type){
        case 5126:
            return setValueV1fArray; // FLOAT
        case 35664:
            return setValueV2fArray; // _VEC2
        case 35665:
            return setValueV3fArray; // _VEC3
        case 35666:
            return setValueV4fArray; // _VEC4
        case 35674:
            return setValueM2Array; // _MAT2
        case 35675:
            return setValueM3Array; // _MAT3
        case 35676:
            return setValueM4Array; // _MAT4
        case 5124:
        case 35670:
            return setValueV1iArray; // INT, BOOL
        case 35667:
        case 35671:
            return setValueV2iArray; // _VEC2
        case 35668:
        case 35672:
            return setValueV3iArray; // _VEC3
        case 35669:
        case 35673:
            return setValueV4iArray; // _VEC4
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return setValueT1Array;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return setValueT6Array;
    }
}
// --- Uniform Classes ---
function SingleUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.setValue = getSingularSetter(activeInfo.type);
}
function PureArrayUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
}
PureArrayUniform.prototype.updateCache = function(data) {
    const cache = this.cache;
    if (data instanceof Float32Array && cache.length !== data.length) this.cache = new Float32Array(data.length);
    copyArray(cache, data);
};
function StructuredUniform(id) {
    this.id = id;
    this.seq = [];
    this.map = {
    };
}
StructuredUniform.prototype.setValue = function(gl, value, textures) {
    const seq = this.seq;
    for(let i1 = 0, n = seq.length; i1 !== n; ++i1){
        const u = seq[i1];
        u.setValue(gl, value[u.id], textures);
    }
};
// --- Top-level ---
// Parser - builds up the property tree from the path strings
const RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.
function addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
    const path = activeInfo.name, pathLength = path.length;
    // reset RegExp object, because of the early exit of a previous run
    RePathPart.lastIndex = 0;
    while(true){
        const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
        let id = match[1];
        const idIsIndex = match[2] === ']', subscript = match[3];
        if (idIsIndex) id = id | 0; // convert to integer
        if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
            // bare name or "pure" bottom-level array "[0]" suffix
            addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
            break;
        } else {
            // step into inner node / create it in case it doesn't exist
            const map = container.map;
            let next = map[id];
            if (next === undefined) {
                next = new StructuredUniform(id);
                addUniform(container, next);
            }
            container = next;
        }
    }
}
// Root Container
function WebGLUniforms(gl, program) {
    this.seq = [];
    this.map = {
    };
    const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for(let i1 = 0; i1 < n; ++i1){
        const info = gl.getActiveUniform(program, i1), addr = gl.getUniformLocation(program, info.name);
        parseUniform(info, addr, this);
    }
}
WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
    const u = this.map[name];
    if (u !== undefined) u.setValue(gl, value, textures);
};
WebGLUniforms.prototype.setOptional = function(gl, object, name) {
    const v = object[name];
    if (v !== undefined) this.setValue(gl, name, v);
};
// Static interface
WebGLUniforms.upload = function(gl, seq, values, textures) {
    for(let i1 = 0, n = seq.length; i1 !== n; ++i1){
        const u = seq[i1], v = values[u.id];
        if (v.needsUpdate !== false) // note: always updating when .needsUpdate is undefined
        u.setValue(gl, v.value, textures);
    }
};
WebGLUniforms.seqWithValue = function(seq, values) {
    const r = [];
    for(let i1 = 0, n = seq.length; i1 !== n; ++i1){
        const u = seq[i1];
        if (u.id in values) r.push(u);
    }
    return r;
};
const WebGLUniforms1 = WebGLUniforms;
function WebGLShader1(gl, type, string) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    return shader;
}
const WebGLShader11 = WebGLShader1;
let programIdCount = 0;
function addLineNumbers(string) {
    const lines = string.split('\n');
    for(let i1 = 0; i1 < lines.length; i1++)lines[i1] = i1 + 1 + ': ' + lines[i1];
    return lines.join('\n');
}
function getEncodingComponents(encoding) {
    switch(encoding){
        case LinearEncoding:
            return [
                'Linear',
                '( value )'
            ];
        case sRGBEncoding:
            return [
                'sRGB',
                '( value )'
            ];
        case RGBEEncoding:
            return [
                'RGBE',
                '( value )'
            ];
        case RGBM7Encoding:
            return [
                'RGBM',
                '( value, 7.0 )'
            ];
        case RGBM16Encoding:
            return [
                'RGBM',
                '( value, 16.0 )'
            ];
        case RGBDEncoding:
            return [
                'RGBD',
                '( value, 256.0 )'
            ];
        case GammaEncoding:
            return [
                'Gamma',
                '( value, float( GAMMA_FACTOR ) )'
            ];
        case LogLuvEncoding:
            return [
                'LogLuv',
                '( value )'
            ];
        default:
            console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
            return [
                'Linear',
                '( value )'
            ];
    }
}
function getShaderErrors(gl, shader, type) {
    const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    const log = gl.getShaderInfoLog(shader).trim();
    if (status && log === '') return '';
    // --enable-privileged-webgl-extension
    // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
    const source = gl.getShaderSource(shader);
    return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers(source);
}
function getTexelDecodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
}
function getTexelEncodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
}
function getToneMappingFunction(functionName, toneMapping) {
    let toneMappingName;
    switch(toneMapping){
        case LinearToneMapping: break;
        case ReinhardToneMapping: break;
        case CineonToneMapping: break;
        case ACESFilmicToneMapping: break;
        case CustomToneMapping: break;
        default:
            console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
    }
    return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
}
function generateExtensions(parameters) {
    const chunks = [
        parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '',
        (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
        parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '',
        (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
    ];
    return chunks.filter(filterEmptyLine).join('\n');
}
function generateDefines(defines) {
    const chunks = [];
    for(const name in defines){
        const value = defines[name];
        if (value === false) continue;
        chunks.push('#define ' + name + ' ' + value);
    }
    return chunks.join('\n');
}
function fetchAttributeLocations(gl, program) {
    const attributes = {
    };
    const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for(let i1 = 0; i1 < n; i1++){
        const info = gl.getActiveAttrib(program, i1);
        const name = info.name;
        // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
        attributes[name] = gl.getAttribLocation(program, name);
    }
    return attributes;
}
function filterEmptyLine(string) {
    return string !== '';
}
function replaceLightNums(string, parameters) {
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
    return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
// Resolve Includes
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
    return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match, include) {
    const string = ShaderChunk[include];
    if (string === undefined) throw new Error('Can not resolve #include <' + include + '>');
    return resolveIncludes(string);
}
// Unroll Loops
const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;
function unrollLoops(string) {
    return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match, start, end, snippet) {
    console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');
    return loopReplacer(match, start, end, snippet);
}
function loopReplacer(match, start, end, snippet) {
    let string = '';
    for(let i1 = parseInt(start); i1 < parseInt(end); i1++)string += snippet.replace(/\[ i \]/g, '[ ' + i1 + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i1);
    return string;
}
//
function generatePrecision(parameters) {
    let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
    if (parameters.precision === "highp") precisionstring += "\n#define HIGH_PRECISION";
    else if (parameters.precision === "mediump") precisionstring += "\n#define MEDIUM_PRECISION";
    else if (parameters.precision === "lowp") precisionstring += "\n#define LOW_PRECISION";
    return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
    let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
    if (parameters.shadowMapType === PCFShadowMap) shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
    else if (parameters.shadowMapType === PCFSoftShadowMap) shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
    else if (parameters.shadowMapType === VSMShadowMap) shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
    return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
    let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    if (parameters.envMap) switch(parameters.envMapMode){
        case CubeReflectionMapping:
        case CubeRefractionMapping: break;
        case CubeUVReflectionMapping:
        case CubeUVRefractionMapping: break;
    }
    return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
    let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
    if (parameters.envMap) switch(parameters.envMapMode){
        case CubeRefractionMapping:
        case CubeUVRefractionMapping: break;
    }
    return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
    let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';
    if (parameters.envMap) switch(parameters.combine){
        case MultiplyOperation: break;
        case MixOperation: break;
        case AddOperation: break;
    }
    return envMapBlendingDefine;
}
function WebGLProgram1(renderer, cacheKey, parameters, bindingStates) {
    const gl = renderer.getContext();
    const defines = parameters.defines;
    let vertexShader = parameters.vertexShader;
    let fragmentShader = parameters.fragmentShader;
    const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
    const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
    const envMapModeDefine = generateEnvMapModeDefine(parameters);
    const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
    const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
    const customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
    const customDefines = generateDefines(defines);
    const program = gl.createProgram();
    let prefixVertex, prefixFragment;
    if (parameters.isRawShaderMaterial) {
        prefixVertex = [
            customDefines
        ].filter(filterEmptyLine).join('\n');
        if (prefixVertex.length > 0) prefixVertex += '\n';
        prefixFragment = [
            customExtensions,
            customDefines
        ].filter(filterEmptyLine).join('\n');
        if (prefixFragment.length > 0) prefixFragment += '\n';
    } else {
        prefixVertex = [
            generatePrecision(parameters),
            '#define SHADER_NAME ' + parameters.shaderName,
            customDefines,
            parameters.instancing ? '#define USE_INSTANCING' : '',
            parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
            parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
            '#define GAMMA_FACTOR ' + gammaFactorDefine,
            '#define MAX_BONES ' + parameters.maxBones,
            parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
            parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',
            parameters.map ? '#define USE_MAP' : '',
            parameters.envMap ? '#define USE_ENVMAP' : '',
            parameters.envMap ? '#define ' + envMapModeDefine : '',
            parameters.lightMap ? '#define USE_LIGHTMAP' : '',
            parameters.aoMap ? '#define USE_AOMAP' : '',
            parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
            parameters.bumpMap ? '#define USE_BUMPMAP' : '',
            parameters.normalMap ? '#define USE_NORMALMAP' : '',
            parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
            parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
            parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
            parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
            parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
            parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
            parameters.specularMap ? '#define USE_SPECULARMAP' : '',
            parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
            parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
            parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
            parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
            parameters.vertexTangents ? '#define USE_TANGENT' : '',
            parameters.vertexColors ? '#define USE_COLOR' : '',
            parameters.vertexUvs ? '#define USE_UV' : '',
            parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
            parameters.flatShading ? '#define FLAT_SHADED' : '',
            parameters.skinning ? '#define USE_SKINNING' : '',
            parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
            parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
            parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
            parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
            parameters.flipSided ? '#define FLIP_SIDED' : '',
            parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
            parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
            parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
            parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
            parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
            'uniform mat4 modelMatrix;',
            'uniform mat4 modelViewMatrix;',
            'uniform mat4 projectionMatrix;',
            'uniform mat4 viewMatrix;',
            'uniform mat3 normalMatrix;',
            'uniform vec3 cameraPosition;',
            'uniform bool isOrthographic;',
            '#ifdef USE_INSTANCING',
            '\tattribute mat4 instanceMatrix;',
            '#endif',
            '#ifdef USE_INSTANCING_COLOR',
            '\tattribute vec3 instanceColor;',
            '#endif',
            'attribute vec3 position;',
            'attribute vec3 normal;',
            'attribute vec2 uv;',
            '#ifdef USE_TANGENT',
            '\tattribute vec4 tangent;',
            '#endif',
            '#ifdef USE_COLOR',
            '\tattribute vec3 color;',
            '#endif',
            '#ifdef USE_MORPHTARGETS',
            '\tattribute vec3 morphTarget0;',
            '\tattribute vec3 morphTarget1;',
            '\tattribute vec3 morphTarget2;',
            '\tattribute vec3 morphTarget3;',
            '\t#ifdef USE_MORPHNORMALS',
            '\t\tattribute vec3 morphNormal0;',
            '\t\tattribute vec3 morphNormal1;',
            '\t\tattribute vec3 morphNormal2;',
            '\t\tattribute vec3 morphNormal3;',
            '\t#else',
            '\t\tattribute vec3 morphTarget4;',
            '\t\tattribute vec3 morphTarget5;',
            '\t\tattribute vec3 morphTarget6;',
            '\t\tattribute vec3 morphTarget7;',
            '\t#endif',
            '#endif',
            '#ifdef USE_SKINNING',
            '\tattribute vec4 skinIndex;',
            '\tattribute vec4 skinWeight;',
            '#endif',
            '\n'
        ].filter(filterEmptyLine).join('\n');
        prefixFragment = [
            customExtensions,
            generatePrecision(parameters),
            '#define SHADER_NAME ' + parameters.shaderName,
            customDefines,
            parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '',
            '#define GAMMA_FACTOR ' + gammaFactorDefine,
            parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
            parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',
            parameters.map ? '#define USE_MAP' : '',
            parameters.matcap ? '#define USE_MATCAP' : '',
            parameters.envMap ? '#define USE_ENVMAP' : '',
            parameters.envMap ? '#define ' + envMapTypeDefine : '',
            parameters.envMap ? '#define ' + envMapModeDefine : '',
            parameters.envMap ? '#define ' + envMapBlendingDefine : '',
            parameters.lightMap ? '#define USE_LIGHTMAP' : '',
            parameters.aoMap ? '#define USE_AOMAP' : '',
            parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
            parameters.bumpMap ? '#define USE_BUMPMAP' : '',
            parameters.normalMap ? '#define USE_NORMALMAP' : '',
            parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
            parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
            parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
            parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
            parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
            parameters.specularMap ? '#define USE_SPECULARMAP' : '',
            parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
            parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
            parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
            parameters.sheen ? '#define USE_SHEEN' : '',
            parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
            parameters.vertexTangents ? '#define USE_TANGENT' : '',
            parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
            parameters.vertexUvs ? '#define USE_UV' : '',
            parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
            parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',
            parameters.flatShading ? '#define FLAT_SHADED' : '',
            parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
            parameters.flipSided ? '#define FLIP_SIDED' : '',
            parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
            parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
            parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
            parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
            parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
            parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
            (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '',
            'uniform mat4 viewMatrix;',
            'uniform vec3 cameraPosition;',
            'uniform bool isOrthographic;',
            parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '',
            parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '',
            parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '',
            parameters.dithering ? '#define DITHERING' : '',
            ShaderChunk['encodings_pars_fragment'],
            parameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '',
            parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '',
            parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '',
            parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '',
            parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '',
            getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding),
            parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',
            '\n'
        ].filter(filterEmptyLine).join('\n');
    }
    vertexShader = resolveIncludes(vertexShader);
    vertexShader = replaceLightNums(vertexShader, parameters);
    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
    fragmentShader = resolveIncludes(fragmentShader);
    fragmentShader = replaceLightNums(fragmentShader, parameters);
    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
    vertexShader = unrollLoops(vertexShader);
    fragmentShader = unrollLoops(fragmentShader);
    if (parameters.isWebGL2 && !parameters.isRawShaderMaterial) {
        // GLSL 3.0 conversion
        prefixVertex = [
            '#version 300 es\n',
            '#define attribute in',
            '#define varying out',
            '#define texture2D texture'
        ].join('\n') + '\n' + prefixVertex;
        prefixFragment = [
            '#version 300 es\n',
            '#define varying in',
            'out highp vec4 pc_fragColor;',
            '#define gl_FragColor pc_fragColor',
            '#define gl_FragDepthEXT gl_FragDepth',
            '#define texture2D texture',
            '#define textureCube texture',
            '#define texture2DProj textureProj',
            '#define texture2DLodEXT textureLod',
            '#define texture2DProjLodEXT textureProjLod',
            '#define textureCubeLodEXT textureLod',
            '#define texture2DGradEXT textureGrad',
            '#define texture2DProjGradEXT textureProjGrad',
            '#define textureCubeGradEXT textureGrad'
        ].join('\n') + '\n' + prefixFragment;
    }
    const vertexGlsl = prefixVertex + vertexShader;
    const fragmentGlsl = prefixFragment + fragmentShader;
    // console.log( '*VERTEX*', vertexGlsl );
    // console.log( '*FRAGMENT*', fragmentGlsl );
    const glVertexShader = WebGLShader11(gl, gl.VERTEX_SHADER, vertexGlsl);
    const glFragmentShader = WebGLShader11(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
    gl.attachShader(program, glVertexShader);
    gl.attachShader(program, glFragmentShader);
    // Force a particular attribute to index 0.
    if (parameters.index0AttributeName !== undefined) gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
    else if (parameters.morphTargets === true) // programs with morphTargets displace position out of attribute 0
    gl.bindAttribLocation(program, 0, 'position');
    gl.linkProgram(program);
    // check for link errors
    if (renderer.debug.checkShaderErrors) {
        const programLog = gl.getProgramInfoLog(program).trim();
        const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
        const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
        let runnable = true;
        let haveDiagnostics = true;
        if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
            const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
            const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
            console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);
        } else if (programLog !== '') console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
        else if (vertexLog === '' || fragmentLog === '') haveDiagnostics = false;
        if (haveDiagnostics) this.diagnostics = {
            runnable: runnable,
            programLog: programLog,
            vertexShader: {
                log: vertexLog,
                prefix: prefixVertex
            },
            fragmentShader: {
                log: fragmentLog,
                prefix: prefixFragment
            }
        };
    }
    // Clean up
    // Crashes in iOS9 and iOS10. #18402
    // gl.detachShader( program, glVertexShader );
    // gl.detachShader( program, glFragmentShader );
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    // set up caching for uniform locations
    let cachedUniforms;
    this.getUniforms = function() {
        if (cachedUniforms === undefined) cachedUniforms = new WebGLUniforms1(gl, program);
        return cachedUniforms;
    };
    // set up caching for attribute locations
    let cachedAttributes;
    this.getAttributes = function() {
        if (cachedAttributes === undefined) cachedAttributes = fetchAttributeLocations(gl, program);
        return cachedAttributes;
    };
    // free resource
    this.destroy = function() {
        bindingStates.releaseStatesOfProgram(this);
        gl.deleteProgram(program);
        this.program = undefined;
    };
    //
    this.name = parameters.shaderName;
    this.id = programIdCount++;
    this.cacheKey = cacheKey;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
}
const WebGLProgram11 = WebGLProgram1;
function WebGLPrograms(renderer, cubemaps, extensions, capabilities, bindingStates) {
    const programs = [];
    const isWebGL2 = capabilities.isWebGL2;
    const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
    const floatVertexTextures = capabilities.floatVertexTextures;
    const maxVertexUniforms = capabilities.maxVertexUniforms;
    const vertexTextures = capabilities.vertexTextures;
    let precision = capabilities.precision;
    const shaderIDs = {
        MeshDepthMaterial: 'depth',
        MeshDistanceMaterial: 'distanceRGBA',
        MeshNormalMaterial: 'normal',
        MeshBasicMaterial: 'basic',
        MeshLambertMaterial: 'lambert',
        MeshPhongMaterial: 'phong',
        MeshToonMaterial: 'toon',
        MeshStandardMaterial: 'physical',
        MeshPhysicalMaterial: 'physical',
        MeshMatcapMaterial: 'matcap',
        LineBasicMaterial: 'basic',
        LineDashedMaterial: 'dashed',
        PointsMaterial: 'points',
        ShadowMaterial: 'shadow',
        SpriteMaterial: 'sprite'
    };
    const parameterNames = [
        "precision",
        "isWebGL2",
        "supportsVertexTextures",
        "outputEncoding",
        "instancing",
        "instancingColor",
        "map",
        "mapEncoding",
        "matcap",
        "matcapEncoding",
        "envMap",
        "envMapMode",
        "envMapEncoding",
        "envMapCubeUV",
        "lightMap",
        "lightMapEncoding",
        "aoMap",
        "emissiveMap",
        "emissiveMapEncoding",
        "bumpMap",
        "normalMap",
        "objectSpaceNormalMap",
        "tangentSpaceNormalMap",
        "clearcoatMap",
        "clearcoatRoughnessMap",
        "clearcoatNormalMap",
        "displacementMap",
        "specularMap",
        "roughnessMap",
        "metalnessMap",
        "gradientMap",
        "alphaMap",
        "combine",
        "vertexColors",
        "vertexTangents",
        "vertexUvs",
        "uvsVertexOnly",
        "fog",
        "useFog",
        "fogExp2",
        "flatShading",
        "sizeAttenuation",
        "logarithmicDepthBuffer",
        "skinning",
        "maxBones",
        "useVertexTexture",
        "morphTargets",
        "morphNormals",
        "maxMorphTargets",
        "maxMorphNormals",
        "premultipliedAlpha",
        "numDirLights",
        "numPointLights",
        "numSpotLights",
        "numHemiLights",
        "numRectAreaLights",
        "numDirLightShadows",
        "numPointLightShadows",
        "numSpotLightShadows",
        "shadowMapEnabled",
        "shadowMapType",
        "toneMapping",
        'physicallyCorrectLights',
        "alphaTest",
        "doubleSided",
        "flipSided",
        "numClippingPlanes",
        "numClipIntersection",
        "depthPacking",
        "dithering",
        "sheen",
        "transmissionMap"
    ];
    function allocateBones(object) {
        const skeleton = object.skeleton;
        const bones = skeleton.bones;
        if (floatVertexTextures) return 1024;
        else {
            // default for when object is not specified
            // ( for example when prebuilding shader to be used with multiple objects )
            //
            //  - leave some extra space for other uniforms
            //  - limit here is ANGLE's 254 max uniform vectors
            //    (up to 54 should be safe)
            const nVertexUniforms = maxVertexUniforms;
            const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
            const maxBones = Math.min(nVertexMatrices, bones.length);
            if (maxBones < bones.length) {
                console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
                return 0;
            }
            return maxBones;
        }
    }
    function getTextureEncodingFromMap(map) {
        let encoding;
        if (!map) encoding = LinearEncoding;
        else if (map.isTexture) encoding = map.encoding;
        else if (map.isWebGLRenderTarget) {
            console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
            encoding = map.texture.encoding;
        }
        return encoding;
    }
    function getParameters(material, lights, shadows, scene, nClipPlanes, nClipIntersection, object) {
        const fog = scene.fog;
        const environment = material.isMeshStandardMaterial ? scene.environment : null;
        const envMap = cubemaps.get(material.envMap || environment);
        const shaderID = shaderIDs[material.type];
        // heuristics to create shader parameters according to lights in the scene
        // (not to blow over maxLights budget)
        const maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
        if (material.precision !== null) {
            precision = capabilities.getMaxPrecision(material.precision);
            if (precision !== material.precision) console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
        }
        let vertexShader, fragmentShader;
        if (shaderID) {
            const shader = ShaderLib1[shaderID];
            vertexShader = shader.vertexShader;
            fragmentShader = shader.fragmentShader;
        } else {
            vertexShader = material.vertexShader;
            fragmentShader = material.fragmentShader;
        }
        const currentRenderTarget = renderer.getRenderTarget();
        const parameters = {
            isWebGL2: isWebGL2,
            shaderID: shaderID,
            shaderName: material.type,
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            defines: material.defines,
            isRawShaderMaterial: material.isRawShaderMaterial,
            isShaderMaterial: material.isShaderMaterial,
            precision: precision,
            instancing: object.isInstancedMesh === true,
            instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
            supportsVertexTextures: vertexTextures,
            outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
            map: !!material.map,
            mapEncoding: getTextureEncodingFromMap(material.map),
            matcap: !!material.matcap,
            matcapEncoding: getTextureEncodingFromMap(material.matcap),
            envMap: !!envMap,
            envMapMode: envMap && envMap.mapping,
            envMapEncoding: getTextureEncodingFromMap(envMap),
            envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
            lightMap: !!material.lightMap,
            lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
            aoMap: !!material.aoMap,
            emissiveMap: !!material.emissiveMap,
            emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
            bumpMap: !!material.bumpMap,
            normalMap: !!material.normalMap,
            objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
            tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
            clearcoatMap: !!material.clearcoatMap,
            clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
            clearcoatNormalMap: !!material.clearcoatNormalMap,
            displacementMap: !!material.displacementMap,
            roughnessMap: !!material.roughnessMap,
            metalnessMap: !!material.metalnessMap,
            specularMap: !!material.specularMap,
            alphaMap: !!material.alphaMap,
            gradientMap: !!material.gradientMap,
            sheen: !!material.sheen,
            transmissionMap: !!material.transmissionMap,
            combine: material.combine,
            vertexTangents: material.normalMap && material.vertexTangents,
            vertexColors: material.vertexColors,
            vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap,
            uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmissionMap) && !!material.displacementMap,
            fog: !!fog,
            useFog: material.fog,
            fogExp2: fog && fog.isFogExp2,
            flatShading: material.flatShading,
            sizeAttenuation: material.sizeAttenuation,
            logarithmicDepthBuffer: logarithmicDepthBuffer,
            skinning: material.skinning && maxBones > 0,
            maxBones: maxBones,
            useVertexTexture: floatVertexTextures,
            morphTargets: material.morphTargets,
            morphNormals: material.morphNormals,
            maxMorphTargets: renderer.maxMorphTargets,
            maxMorphNormals: renderer.maxMorphNormals,
            numDirLights: lights.directional.length,
            numPointLights: lights.point.length,
            numSpotLights: lights.spot.length,
            numRectAreaLights: lights.rectArea.length,
            numHemiLights: lights.hemi.length,
            numDirLightShadows: lights.directionalShadowMap.length,
            numPointLightShadows: lights.pointShadowMap.length,
            numSpotLightShadows: lights.spotShadowMap.length,
            numClippingPlanes: nClipPlanes,
            numClipIntersection: nClipIntersection,
            dithering: material.dithering,
            shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
            shadowMapType: renderer.shadowMap.type,
            toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
            physicallyCorrectLights: renderer.physicallyCorrectLights,
            premultipliedAlpha: material.premultipliedAlpha,
            alphaTest: material.alphaTest,
            doubleSided: material.side === DoubleSide,
            flipSided: material.side === BackSide,
            depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
            index0AttributeName: material.index0AttributeName,
            extensionDerivatives: material.extensions && material.extensions.derivatives,
            extensionFragDepth: material.extensions && material.extensions.fragDepth,
            extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
            extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: isWebGL2 || extensions.get('EXT_frag_depth') !== null,
            rendererExtensionDrawBuffers: isWebGL2 || extensions.get('WEBGL_draw_buffers') !== null,
            rendererExtensionShaderTextureLod: isWebGL2 || extensions.get('EXT_shader_texture_lod') !== null,
            customProgramCacheKey: material.customProgramCacheKey()
        };
        return parameters;
    }
    function getProgramCacheKey(parameters) {
        const array = [];
        if (parameters.shaderID) array.push(parameters.shaderID);
        else {
            array.push(parameters.fragmentShader);
            array.push(parameters.vertexShader);
        }
        if (parameters.defines !== undefined) for(const name in parameters.defines){
            array.push(name);
            array.push(parameters.defines[name]);
        }
        if (parameters.isRawShaderMaterial === undefined) {
            for(let i1 = 0; i1 < parameterNames.length; i1++)array.push(parameters[parameterNames[i1]]);
            array.push(renderer.outputEncoding);
            array.push(renderer.gammaFactor);
        }
        array.push(parameters.customProgramCacheKey);
        return array.join();
    }
    function getUniforms(material) {
        const shaderID = shaderIDs[material.type];
        let uniforms;
        if (shaderID) {
            const shader = ShaderLib1[shaderID];
            uniforms = UniformsUtils1.clone(shader.uniforms);
        } else uniforms = material.uniforms;
        return uniforms;
    }
    function acquireProgram(parameters, cacheKey) {
        let program;
        // Check if code has been already compiled
        for(let p = 0, pl = programs.length; p < pl; p++){
            const preexistingProgram = programs[p];
            if (preexistingProgram.cacheKey === cacheKey) {
                program = preexistingProgram;
                ++program.usedTimes;
                break;
            }
        }
        if (program === undefined) {
            program = new WebGLProgram11(renderer, cacheKey, parameters, bindingStates);
            programs.push(program);
        }
        return program;
    }
    function releaseProgram(program) {
        if ((--program.usedTimes) === 0) {
            // Remove from unordered set
            const i1 = programs.indexOf(program);
            programs[i1] = programs[programs.length - 1];
            programs.pop();
            // Free WebGL resources
            program.destroy();
        }
    }
    return {
        getParameters: getParameters,
        getProgramCacheKey: getProgramCacheKey,
        getUniforms: getUniforms,
        acquireProgram: acquireProgram,
        releaseProgram: releaseProgram,
        // Exposed for resource monitoring & error feedback via renderer.info:
        programs: programs
    };
}
const WebGLPrograms1 = WebGLPrograms;
function WebGLProperties() {
    let properties = new WeakMap();
    function get(object) {
        let map = properties.get(object);
        if (map === undefined) {
            map = {
            };
            properties.set(object, map);
        }
        return map;
    }
    function remove(object) {
        properties.delete(object);
    }
    function update(object, key, value) {
        properties.get(object)[key] = value;
    }
    function dispose() {
        properties = new WeakMap();
    }
    return {
        get: get,
        remove: remove,
        update: update,
        dispose: dispose
    };
}
const WebGLProperties1 = WebGLProperties;
function painterSortStable(a2, b2) {
    if (a2.groupOrder !== b2.groupOrder) return a2.groupOrder - b2.groupOrder;
    else if (a2.renderOrder !== b2.renderOrder) return a2.renderOrder - b2.renderOrder;
    else if (a2.program !== b2.program) return a2.program.id - b2.program.id;
    else if (a2.material.id !== b2.material.id) return a2.material.id - b2.material.id;
    else if (a2.z !== b2.z) return a2.z - b2.z;
    else return a2.id - b2.id;
}
function reversePainterSortStable(a2, b2) {
    if (a2.groupOrder !== b2.groupOrder) return a2.groupOrder - b2.groupOrder;
    else if (a2.renderOrder !== b2.renderOrder) return a2.renderOrder - b2.renderOrder;
    else if (a2.z !== b2.z) return b2.z - a2.z;
    else return a2.id - b2.id;
}
function WebGLRenderList(properties) {
    const renderItems = [];
    let renderItemsIndex = 0;
    const opaque = [];
    const transparent = [];
    const defaultProgram = {
        id: -1
    };
    function init() {
        opaque.length = 0;
        transparent.length = 0;
    }
    function getNextRenderItem(object, geometry, material, groupOrder, z5, group) {
        let renderItem = renderItems[renderItemsIndex];
        const materialProperties = properties.get(material);
        if (renderItem === undefined) {
            renderItem = {
                id: object.id,
                object: object,
                geometry: geometry,
                material: material,
                program: materialProperties.program || defaultProgram,
                groupOrder: groupOrder,
                renderOrder: object.renderOrder,
                z: z5,
                group: group
            };
            renderItems[renderItemsIndex] = renderItem;
        } else {
            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry;
            renderItem.material = material;
            renderItem.program = materialProperties.program || defaultProgram;
            renderItem.groupOrder = groupOrder;
            renderItem.renderOrder = object.renderOrder;
            renderItem.z = z5;
            renderItem.group = group;
        }
        renderItemsIndex++;
        return renderItem;
    }
    function push(object, geometry, material, groupOrder, z5, group) {
        const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z5, group);
        (material.transparent === true ? transparent : opaque).push(renderItem);
    }
    function unshift(object, geometry, material, groupOrder, z5, group) {
        const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z5, group);
        (material.transparent === true ? transparent : opaque).unshift(renderItem);
    }
    function sort(customOpaqueSort, customTransparentSort) {
        if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
        if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
    }
    function finish() {
        // Clear references from inactive renderItems in the list
        for(let i1 = renderItemsIndex, il = renderItems.length; i1 < il; i1++){
            const renderItem = renderItems[i1];
            if (renderItem.id === null) break;
            renderItem.id = null;
            renderItem.object = null;
            renderItem.geometry = null;
            renderItem.material = null;
            renderItem.program = null;
            renderItem.group = null;
        }
    }
    return {
        opaque: opaque,
        transparent: transparent,
        init: init,
        push: push,
        unshift: unshift,
        finish: finish,
        sort: sort
    };
}
function WebGLRenderLists(properties) {
    let lists = new WeakMap();
    function get(scene, camera) {
        const cameras = lists.get(scene);
        let list;
        if (cameras === undefined) {
            list = new WebGLRenderList(properties);
            lists.set(scene, new WeakMap());
            lists.get(scene).set(camera, list);
        } else {
            list = cameras.get(camera);
            if (list === undefined) {
                list = new WebGLRenderList(properties);
                cameras.set(camera, list);
            }
        }
        return list;
    }
    function dispose() {
        lists = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
const WebGLRenderLists1 = WebGLRenderLists;
function UniformsCache() {
    const lights = {
    };
    return {
        get: function(light) {
            if (lights[light.id] !== undefined) return lights[light.id];
            let uniforms;
            switch(light.type){
                case 'DirectionalLight':
                    uniforms = {
                        direction: new Vector31(),
                        color: new Color1()
                    };
                    break;
                case 'SpotLight':
                    uniforms = {
                        position: new Vector31(),
                        direction: new Vector31(),
                        color: new Color1(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case 'PointLight':
                    uniforms = {
                        position: new Vector31(),
                        color: new Color1(),
                        distance: 0,
                        decay: 0
                    };
                    break;
                case 'HemisphereLight':
                    uniforms = {
                        direction: new Vector31(),
                        skyColor: new Color1(),
                        groundColor: new Color1()
                    };
                    break;
                case 'RectAreaLight':
                    uniforms = {
                        color: new Color1(),
                        position: new Vector31(),
                        halfWidth: new Vector31(),
                        halfHeight: new Vector31()
                    };
                    break;
            }
            lights[light.id] = uniforms;
            return uniforms;
        }
    };
}
function ShadowUniformsCache() {
    const lights = {
    };
    return {
        get: function(light) {
            if (lights[light.id] !== undefined) return lights[light.id];
            let uniforms;
            switch(light.type){
                case 'DirectionalLight':
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector21()
                    };
                    break;
                case 'SpotLight':
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector21()
                    };
                    break;
                case 'PointLight':
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector21(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1000
                    };
                    break;
            }
            lights[light.id] = uniforms;
            return uniforms;
        }
    };
}
let nextVersion = 0;
function shadowCastingLightsFirst(lightA, lightB) {
    return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights() {
    const cache = new UniformsCache();
    const shadowCache = ShadowUniformsCache();
    const state = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
        },
        ambient: [
            0,
            0,
            0
        ],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadow: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: []
    };
    for(let i1 = 0; i1 < 9; i1++)state.probe.push(new Vector31());
    const vector3 = new Vector31();
    const matrix4 = new Matrix41();
    const matrix42 = new Matrix41();
    function setup(lights, shadows, camera) {
        let r = 0, g = 0, b2 = 0;
        for(let i11 = 0; i11 < 9; i11++)state.probe[i11].set(0, 0, 0);
        let directionalLength = 0;
        let pointLength = 0;
        let spotLength = 0;
        let rectAreaLength = 0;
        let hemiLength = 0;
        let numDirectionalShadows = 0;
        let numPointShadows = 0;
        let numSpotShadows = 0;
        const viewMatrix = camera.matrixWorldInverse;
        lights.sort(shadowCastingLightsFirst);
        for(let i11 = 0, l = lights.length; i11 < l; i11++){
            const light = lights[i11];
            const color1 = light.color;
            const intensity = light.intensity;
            const distance = light.distance;
            const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
            if (light.isAmbientLight) {
                r += color1.r * intensity;
                g += color1.g * intensity;
                b2 += color1.b * intensity;
            } else if (light.isLightProbe) for(let j = 0; j < 9; j++)state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
            else if (light.isDirectionalLight) {
                const uniforms = cache.get(light);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(vector3);
                uniforms.direction.transformDirection(viewMatrix);
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    state.directionalShadow[directionalLength] = shadowUniforms;
                    state.directionalShadowMap[directionalLength] = shadowMap;
                    state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                    numDirectionalShadows++;
                }
                state.directional[directionalLength] = uniforms;
                directionalLength++;
            } else if (light.isSpotLight) {
                const uniforms = cache.get(light);
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                uniforms.color.copy(color1).multiplyScalar(intensity);
                uniforms.distance = distance;
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(vector3);
                uniforms.direction.transformDirection(viewMatrix);
                uniforms.coneCos = Math.cos(light.angle);
                uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                uniforms.decay = light.decay;
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    state.spotShadow[spotLength] = shadowUniforms;
                    state.spotShadowMap[spotLength] = shadowMap;
                    state.spotShadowMatrix[spotLength] = light.shadow.matrix;
                    numSpotShadows++;
                }
                state.spot[spotLength] = uniforms;
                spotLength++;
            } else if (light.isRectAreaLight) {
                const uniforms = cache.get(light);
                // (a) intensity is the total visible light emitted
                //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
                // (b) intensity is the brightness of the light
                uniforms.color.copy(color1).multiplyScalar(intensity);
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                // extract local rotation of light to derive width/height half vectors
                matrix42.identity();
                matrix4.copy(light.matrixWorld);
                matrix4.premultiply(viewMatrix);
                matrix42.extractRotation(matrix4);
                uniforms.halfWidth.set(light.width * 0.5, 0, 0);
                uniforms.halfHeight.set(0, light.height * 0.5, 0);
                uniforms.halfWidth.applyMatrix4(matrix42);
                uniforms.halfHeight.applyMatrix4(matrix42);
                // TODO (abelnation): RectAreaLight distance?
                // uniforms.distance = distance;
                state.rectArea[rectAreaLength] = uniforms;
                rectAreaLength++;
            } else if (light.isPointLight) {
                const uniforms = cache.get(light);
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                uniforms.distance = light.distance;
                uniforms.decay = light.decay;
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    shadowUniforms.shadowCameraNear = shadow.camera.near;
                    shadowUniforms.shadowCameraFar = shadow.camera.far;
                    state.pointShadow[pointLength] = shadowUniforms;
                    state.pointShadowMap[pointLength] = shadowMap;
                    state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                    numPointShadows++;
                }
                state.point[pointLength] = uniforms;
                pointLength++;
            } else if (light.isHemisphereLight) {
                const uniforms = cache.get(light);
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                uniforms.direction.transformDirection(viewMatrix);
                uniforms.direction.normalize();
                uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
                state.hemi[hemiLength] = uniforms;
                hemiLength++;
            }
        }
        state.ambient[0] = r;
        state.ambient[1] = g;
        state.ambient[2] = b2;
        const hash = state.hash;
        if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
            state.directional.length = directionalLength;
            state.spot.length = spotLength;
            state.rectArea.length = rectAreaLength;
            state.point.length = pointLength;
            state.hemi.length = hemiLength;
            state.directionalShadow.length = numDirectionalShadows;
            state.directionalShadowMap.length = numDirectionalShadows;
            state.pointShadow.length = numPointShadows;
            state.pointShadowMap.length = numPointShadows;
            state.spotShadow.length = numSpotShadows;
            state.spotShadowMap.length = numSpotShadows;
            state.directionalShadowMatrix.length = numDirectionalShadows;
            state.pointShadowMatrix.length = numPointShadows;
            state.spotShadowMatrix.length = numSpotShadows;
            hash.directionalLength = directionalLength;
            hash.pointLength = pointLength;
            hash.spotLength = spotLength;
            hash.rectAreaLength = rectAreaLength;
            hash.hemiLength = hemiLength;
            hash.numDirectionalShadows = numDirectionalShadows;
            hash.numPointShadows = numPointShadows;
            hash.numSpotShadows = numSpotShadows;
            state.version = nextVersion++;
        }
    }
    return {
        setup: setup,
        state: state
    };
}
const WebGLLights1 = WebGLLights;
function WebGLRenderState() {
    const lights = new WebGLLights1();
    const lightsArray = [];
    const shadowsArray = [];
    function init() {
        lightsArray.length = 0;
        shadowsArray.length = 0;
    }
    function pushLight(light) {
        lightsArray.push(light);
    }
    function pushShadow(shadowLight) {
        shadowsArray.push(shadowLight);
    }
    function setupLights(camera) {
        lights.setup(lightsArray, shadowsArray, camera);
    }
    const state = {
        lightsArray: lightsArray,
        shadowsArray: shadowsArray,
        lights: lights
    };
    return {
        init: init,
        state: state,
        setupLights: setupLights,
        pushLight: pushLight,
        pushShadow: pushShadow
    };
}
function WebGLRenderStates() {
    let renderStates = new WeakMap();
    function get(scene, camera) {
        let renderState;
        if (renderStates.has(scene) === false) {
            renderState = new WebGLRenderState();
            renderStates.set(scene, new WeakMap());
            renderStates.get(scene).set(camera, renderState);
        } else if (renderStates.get(scene).has(camera) === false) {
            renderState = new WebGLRenderState();
            renderStates.get(scene).set(camera, renderState);
        } else renderState = renderStates.get(scene).get(camera);
        return renderState;
    }
    function dispose() {
        renderStates = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
const WebGLRenderStates1 = WebGLRenderStates;
let materialId = 0;
function Material2() {
    Object.defineProperty(this, 'id', {
        value: materialId++
    });
    this.uuid = MathUtils1.generateUUID();
    this.name = '';
    this.type = 'Material';
    this.fog = true;
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.flatShading = false;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null; // override the renderer's default precision for this material
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaTest = 0;
    this.premultipliedAlpha = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {
    };
    this.version = 0;
}
Material2.prototype = Object.assign(Object.create(EventDispatcher1.prototype), {
    constructor: Material2,
    isMaterial: true,
    onBeforeCompile: function() {
    },
    customProgramCacheKey: function() {
        return this.onBeforeCompile.toString();
    },
    setValues: function(values) {
        if (values === undefined) return;
        for(const key in values){
            const newValue = values[key];
            if (newValue === undefined) {
                console.warn("THREE.Material: '" + key + "' parameter is undefined.");
                continue;
            }
            // for backward compatability if shading is set in the constructor
            if (key === 'shading') {
                console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                this.flatShading = newValue === FlatShading ? true : false;
                continue;
            }
            const currentValue = this[key];
            if (currentValue === undefined) {
                console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                continue;
            }
            if (currentValue && currentValue.isColor) currentValue.set(newValue);
            else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) currentValue.copy(newValue);
            else this[key] = newValue;
        }
    },
    toJSON: function(meta) {
        const isRoot = meta === undefined || typeof meta === 'string';
        if (isRoot) meta = {
            textures: {
            },
            images: {
            }
        };
        const data = {
            metadata: {
                version: 4.5,
                type: 'Material',
                generator: 'Material.toJSON'
            }
        };
        // standard Material serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '') data.name = this.name;
        if (this.color && this.color.isColor) data.color = this.color.getHex();
        if (this.roughness !== undefined) data.roughness = this.roughness;
        if (this.metalness !== undefined) data.metalness = this.metalness;
        if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();
        if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
        if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
        if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
        if (this.shininess !== undefined) data.shininess = this.shininess;
        if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
        if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;
        if (this.clearcoatMap && this.clearcoatMap.isTexture) data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
        if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
        if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
            data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
            data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
        }
        if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
        if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
        if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
        if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;
        if (this.aoMap && this.aoMap.isTexture) {
            data.aoMap = this.aoMap.toJSON(meta).uuid;
            data.aoMapIntensity = this.aoMapIntensity;
        }
        if (this.bumpMap && this.bumpMap.isTexture) {
            data.bumpMap = this.bumpMap.toJSON(meta).uuid;
            data.bumpScale = this.bumpScale;
        }
        if (this.normalMap && this.normalMap.isTexture) {
            data.normalMap = this.normalMap.toJSON(meta).uuid;
            data.normalMapType = this.normalMapType;
            data.normalScale = this.normalScale.toArray();
        }
        if (this.displacementMap && this.displacementMap.isTexture) {
            data.displacementMap = this.displacementMap.toJSON(meta).uuid;
            data.displacementScale = this.displacementScale;
            data.displacementBias = this.displacementBias;
        }
        if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
        if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
        if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
        if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
        if (this.envMap && this.envMap.isTexture) {
            data.envMap = this.envMap.toJSON(meta).uuid;
            data.reflectivity = this.reflectivity; // Scale behind envMap
            data.refractionRatio = this.refractionRatio;
            if (this.combine !== undefined) data.combine = this.combine;
            if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
        }
        if (this.gradientMap && this.gradientMap.isTexture) data.gradientMap = this.gradientMap.toJSON(meta).uuid;
        if (this.size !== undefined) data.size = this.size;
        if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
        if (this.blending !== NormalBlending) data.blending = this.blending;
        if (this.flatShading === true) data.flatShading = this.flatShading;
        if (this.side !== FrontSide) data.side = this.side;
        if (this.vertexColors) data.vertexColors = true;
        if (this.opacity < 1) data.opacity = this.opacity;
        if (this.transparent === true) data.transparent = this.transparent;
        data.depthFunc = this.depthFunc;
        data.depthTest = this.depthTest;
        data.depthWrite = this.depthWrite;
        data.stencilWrite = this.stencilWrite;
        data.stencilWriteMask = this.stencilWriteMask;
        data.stencilFunc = this.stencilFunc;
        data.stencilRef = this.stencilRef;
        data.stencilFuncMask = this.stencilFuncMask;
        data.stencilFail = this.stencilFail;
        data.stencilZFail = this.stencilZFail;
        data.stencilZPass = this.stencilZPass;
        // rotation (SpriteMaterial)
        if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
        if (this.polygonOffset === true) data.polygonOffset = true;
        if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
        if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
        if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
        if (this.dashSize !== undefined) data.dashSize = this.dashSize;
        if (this.gapSize !== undefined) data.gapSize = this.gapSize;
        if (this.scale !== undefined) data.scale = this.scale;
        if (this.dithering === true) data.dithering = true;
        if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
        if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
        if (this.wireframe === true) data.wireframe = this.wireframe;
        if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
        if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
        if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
        if (this.morphTargets === true) data.morphTargets = true;
        if (this.morphNormals === true) data.morphNormals = true;
        if (this.skinning === true) data.skinning = true;
        if (this.visible === false) data.visible = false;
        if (this.toneMapped === false) data.toneMapped = false;
        if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData;
        // TODO: Copied from Object3D.toJSON
        function extractFromCache(cache) {
            const values = [];
            for(const key in cache){
                const data1 = cache[key];
                delete data1.metadata;
                values.push(data1);
            }
            return values;
        }
        if (isRoot) {
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            if (textures.length > 0) data.textures = textures;
            if (images.length > 0) data.images = images;
        }
        return data;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.name = source.name;
        this.fog = source.fog;
        this.blending = source.blending;
        this.side = source.side;
        this.flatShading = source.flatShading;
        this.vertexColors = source.vertexColors;
        this.opacity = source.opacity;
        this.transparent = source.transparent;
        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;
        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;
        this.stencilWriteMask = source.stencilWriteMask;
        this.stencilFunc = source.stencilFunc;
        this.stencilRef = source.stencilRef;
        this.stencilFuncMask = source.stencilFuncMask;
        this.stencilFail = source.stencilFail;
        this.stencilZFail = source.stencilZFail;
        this.stencilZPass = source.stencilZPass;
        this.stencilWrite = source.stencilWrite;
        const srcPlanes = source.clippingPlanes;
        let dstPlanes = null;
        if (srcPlanes !== null) {
            const n = srcPlanes.length;
            dstPlanes = new Array(n);
            for(let i1 = 0; i1 !== n; ++i1)dstPlanes[i1] = srcPlanes[i1].clone();
        }
        this.clippingPlanes = dstPlanes;
        this.clipIntersection = source.clipIntersection;
        this.clipShadows = source.clipShadows;
        this.shadowSide = source.shadowSide;
        this.colorWrite = source.colorWrite;
        this.precision = source.precision;
        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;
        this.dithering = source.dithering;
        this.alphaTest = source.alphaTest;
        this.premultipliedAlpha = source.premultipliedAlpha;
        this.visible = source.visible;
        this.toneMapped = source.toneMapped;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
});
Object.defineProperty(Material2.prototype, 'needsUpdate', {
    set: function(value) {
        if (value === true) this.version++;
    }
});
const Material1 = Material2;
/**
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */
function MeshDepthMaterial(parameters) {
    Material1.call(this);
    this.type = 'MeshDepthMaterial';
    this.depthPacking = BasicDepthPacking;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(parameters);
}
MeshDepthMaterial.prototype = Object.create(Material1.prototype);
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
MeshDepthMaterial.prototype.copy = function(source) {
    Material1.prototype.copy.call(this, source);
    this.depthPacking = source.depthPacking;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
};
const MeshDepthMaterial1 = MeshDepthMaterial;
/**
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */
function MeshDistanceMaterial(parameters) {
    Material1.call(this);
    this.type = 'MeshDistanceMaterial';
    this.referencePosition = new Vector31();
    this.nearDistance = 1;
    this.farDistance = 1000;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(parameters);
}
MeshDistanceMaterial.prototype = Object.create(Material1.prototype);
MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
MeshDistanceMaterial.prototype.copy = function(source) {
    Material1.prototype.copy.call(this, source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
};
const MeshDistanceMaterial1 = MeshDistanceMaterial;
const vsm_frag = /* glsl */
`\nuniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n\n#include <packing>\n\nvoid main() {\n\n	float mean = 0.0;\n	float squared_mean = 0.0;\n\n	// This seems totally useless but it's a crazy work around for a Adreno compiler bug\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\n	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\n		#ifdef HORIZONAL_PASS\n\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\n		#else\n\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n\n		#endif\n\n	}\n\n	mean = mean * HALF_SAMPLE_RATE;\n	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n\n	float std_dev = sqrt( squared_mean - mean * mean );\n\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n\n}\n`;
const vsm_vert = /* glsl */
`\nvoid main() {\n\n	gl_Position = vec4( position, 1.0 );\n\n}\n`;
function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
    let _frustum = new Frustum1();
    const _shadowMapSize = new Vector21(), _viewportSize = new Vector21(), _viewport = new Vector41(), _depthMaterials = [], _materialCache = {
    };
    const shadowSide = {
        0: BackSide,
        1: FrontSide,
        2: DoubleSide
    };
    const shadowMaterialVertical = new ShaderMaterial1({
        defines: {
            SAMPLE_RATE: 0.25,
            HALF_SAMPLE_RATE: 0.125
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new Vector21()
            },
            radius: {
                value: 4
            }
        },
        vertexShader: vsm_vert,
        fragmentShader: vsm_frag
    });
    const shadowMaterialHorizonal = shadowMaterialVertical.clone();
    shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;
    const fullScreenTri = new BufferGeometry1();
    fullScreenTri.setAttribute("position", new BufferAttribute1(new Float32Array([
        -1,
        -1,
        0.5,
        3,
        -1,
        0.5,
        -1,
        3,
        0.5
    ]), 3));
    const fullScreenMesh = new Mesh1(fullScreenTri, shadowMaterialVertical);
    const scope1 = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = PCFShadowMap;
    this.render = function(lights, scene, camera) {
        if (scope1.enabled === false) return;
        if (scope1.autoUpdate === false && scope1.needsUpdate === false) return;
        if (lights.length === 0) return;
        const currentRenderTarget = _renderer.getRenderTarget();
        const activeCubeFace = _renderer.getActiveCubeFace();
        const activeMipmapLevel = _renderer.getActiveMipmapLevel();
        const _state = _renderer.state;
        // Set GL state for depth map.
        _state.setBlending(NoBlending);
        _state.buffers.color.setClear(1, 1, 1, 1);
        _state.buffers.depth.setTest(true);
        _state.setScissorTest(false);
        // render depth map
        for(let i1 = 0, il = lights.length; i1 < il; i1++){
            const light = lights[i1];
            const shadow = light.shadow;
            if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
            if (shadow === undefined) {
                console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
                continue;
            }
            _shadowMapSize.copy(shadow.mapSize);
            const shadowFrameExtents = shadow.getFrameExtents();
            _shadowMapSize.multiply(shadowFrameExtents);
            _viewportSize.copy(shadow.mapSize);
            if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
                if (_shadowMapSize.x > maxTextureSize) {
                    _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
                    _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
                    shadow.mapSize.x = _viewportSize.x;
                }
                if (_shadowMapSize.y > maxTextureSize) {
                    _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
                    _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
                    shadow.mapSize.y = _viewportSize.y;
                }
            }
            if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
                const pars = {
                    minFilter: LinearFilter,
                    magFilter: LinearFilter,
                    format: RGBAFormat,
                    stencilBuffer: false
                };
                shadow.map = new WebGLRenderTarget1(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.map.texture.name = light.name + ".shadowMap";
                shadow.mapPass = new WebGLRenderTarget1(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.camera.updateProjectionMatrix();
            }
            if (shadow.map === null) {
                const pars = {
                    minFilter: NearestFilter,
                    magFilter: NearestFilter,
                    format: RGBAFormat,
                    stencilBuffer: false
                };
                shadow.map = new WebGLRenderTarget1(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.map.texture.name = light.name + ".shadowMap";
                shadow.camera.updateProjectionMatrix();
            }
            _renderer.setRenderTarget(shadow.map);
            _renderer.clear();
            const viewportCount = shadow.getViewportCount();
            for(let vp = 0; vp < viewportCount; vp++){
                const viewport = shadow.getViewport(vp);
                _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
                _state.viewport(_viewport);
                shadow.updateMatrices(light, vp);
                _frustum = shadow.getFrustum();
                renderObject(scene, camera, shadow.camera, light, this.type);
            }
            // do blur pass for VSM
            if (!shadow.isPointLightShadow && this.type === VSMShadowMap) VSMPass(shadow, camera);
            shadow.needsUpdate = false;
        }
        scope1.needsUpdate = false;
        _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };
    function VSMPass(shadow, camera) {
        const geometry = _objects.update(fullScreenMesh);
        // vertical pass
        shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
        shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialVertical.uniforms.radius.value = shadow.radius;
        _renderer.setRenderTarget(shadow.mapPass);
        _renderer.clear();
        _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
        // horizonal pass
        shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
        shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;
        _renderer.setRenderTarget(shadow.map);
        _renderer.clear();
        _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null);
    }
    function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
        const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
        let material = _depthMaterials[index];
        if (material === undefined) {
            material = new MeshDepthMaterial1({
                depthPacking: RGBADepthPacking,
                morphTargets: useMorphing,
                skinning: useSkinning
            });
            _depthMaterials[index] = material;
        }
        return material;
    }
    function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
        let result = null;
        let getMaterialVariant = getDepthMaterialVariant;
        let customMaterial = object.customDepthMaterial;
        if (light.isPointLight === true) {
            customMaterial = object.customDistanceMaterial;
        }
        if (customMaterial === undefined) {
            let useMorphing = false;
            if (material.morphTargets === true) useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
            let useSkinning = false;
            if (object.isSkinnedMesh === true) {
                if (material.skinning === true) useSkinning = true;
                else console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
            }
            const useInstancing = object.isInstancedMesh === true;
            result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
        } else result = customMaterial;
        if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
            // in this case we need a unique material instance reflecting the
            // appropriate state
            const keyA = result.uuid, keyB = material.uuid;
            let materialsForVariant = _materialCache[keyA];
            if (materialsForVariant === undefined) {
                materialsForVariant = {
                };
                _materialCache[keyA] = materialsForVariant;
            }
            let cachedMaterial = materialsForVariant[keyB];
            if (cachedMaterial === undefined) {
                cachedMaterial = result.clone();
                materialsForVariant[keyB] = cachedMaterial;
            }
            result = cachedMaterial;
        }
        result.visible = material.visible;
        result.wireframe = material.wireframe;
        if (type === VSMShadowMap) result.side = material.shadowSide !== null ? material.shadowSide : material.side;
        else result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
        result.clipShadows = material.clipShadows;
        result.clippingPlanes = material.clippingPlanes;
        result.clipIntersection = material.clipIntersection;
        result.wireframeLinewidth = material.wireframeLinewidth;
        result.linewidth = material.linewidth;
        if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
            result.referencePosition.setFromMatrixPosition(light.matrixWorld);
            result.nearDistance = shadowCameraNear;
            result.farDistance = shadowCameraFar;
        }
        return result;
    }
    function renderObject(object, camera, shadowCamera, light, type) {
        if (object.visible === false) return;
        const visible = object.layers.test(camera.layers);
        if (visible && (object.isMesh || object.isLine || object.isPoints)) {
            if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
                object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                const geometry = _objects.update(object);
                const material = object.material;
                if (Array.isArray(material)) {
                    const groups = geometry.groups;
                    for(let k = 0, kl = groups.length; k < kl; k++){
                        const group = groups[k];
                        const groupMaterial = material[group.materialIndex];
                        if (groupMaterial && groupMaterial.visible) {
                            const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                        }
                    }
                } else if (material.visible) {
                    const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
                    _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                }
            }
        }
        const children = object.children;
        for(let i1 = 0, l = children.length; i1 < l; i1++)renderObject(children[i1], camera, shadowCamera, light, type);
    }
}
const WebGLShadowMap1 = WebGLShadowMap;
function WebGLState(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function ColorBuffer() {
        let locked = false;
        const color1 = new Vector41();
        let currentColorMask = null;
        const currentColorClear = new Vector41(0, 0, 0, 0);
        return {
            setMask: function(colorMask) {
                if (currentColorMask !== colorMask && !locked) {
                    gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                    currentColorMask = colorMask;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(r, g, b2, a2, premultipliedAlpha) {
                if (premultipliedAlpha === true) {
                    r *= a2;
                    g *= a2;
                    b2 *= a2;
                }
                color1.set(r, g, b2, a2);
                if (currentColorClear.equals(color1) === false) {
                    gl.clearColor(r, g, b2, a2);
                    currentColorClear.copy(color1);
                }
            },
            reset: function() {
                locked = false;
                currentColorMask = null;
                currentColorClear.set(-1, 0, 0, 0); // set to invalid state
            }
        };
    }
    function DepthBuffer() {
        let locked = false;
        let currentDepthMask = null;
        let currentDepthFunc = null;
        let currentDepthClear = null;
        return {
            setTest: function(depthTest) {
                if (depthTest) enable(gl.DEPTH_TEST);
                else disable(gl.DEPTH_TEST);
            },
            setMask: function(depthMask) {
                if (currentDepthMask !== depthMask && !locked) {
                    gl.depthMask(depthMask);
                    currentDepthMask = depthMask;
                }
            },
            setFunc: function(depthFunc) {
                if (currentDepthFunc !== depthFunc) {
                    if (depthFunc) switch(depthFunc){
                        case NeverDepth:
                            gl.depthFunc(gl.NEVER);
                            break;
                        case AlwaysDepth:
                            gl.depthFunc(gl.ALWAYS);
                            break;
                        case LessDepth:
                            gl.depthFunc(gl.LESS);
                            break;
                        case LessEqualDepth:
                            gl.depthFunc(gl.LEQUAL);
                            break;
                        case EqualDepth:
                            gl.depthFunc(gl.EQUAL);
                            break;
                        case GreaterEqualDepth:
                            gl.depthFunc(gl.GEQUAL);
                            break;
                        case GreaterDepth:
                            gl.depthFunc(gl.GREATER);
                            break;
                        case NotEqualDepth:
                            gl.depthFunc(gl.NOTEQUAL);
                            break;
                        default:
                            gl.depthFunc(gl.LEQUAL);
                    }
                    else gl.depthFunc(gl.LEQUAL);
                    currentDepthFunc = depthFunc;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(depth1) {
                if (currentDepthClear !== depth1) {
                    gl.clearDepth(depth1);
                    currentDepthClear = depth1;
                }
            },
            reset: function() {
                locked = false;
                currentDepthMask = null;
                currentDepthFunc = null;
                currentDepthClear = null;
            }
        };
    }
    function StencilBuffer() {
        let locked = false;
        let currentStencilMask = null;
        let currentStencilFunc = null;
        let currentStencilRef = null;
        let currentStencilFuncMask = null;
        let currentStencilFail = null;
        let currentStencilZFail = null;
        let currentStencilZPass = null;
        let currentStencilClear = null;
        return {
            setTest: function(stencilTest) {
                if (!locked) {
                    if (stencilTest) enable(gl.STENCIL_TEST);
                    else disable(gl.STENCIL_TEST);
                }
            },
            setMask: function(stencilMask) {
                if (currentStencilMask !== stencilMask && !locked) {
                    gl.stencilMask(stencilMask);
                    currentStencilMask = stencilMask;
                }
            },
            setFunc: function(stencilFunc, stencilRef, stencilMask) {
                if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                    gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                    currentStencilFunc = stencilFunc;
                    currentStencilRef = stencilRef;
                    currentStencilFuncMask = stencilMask;
                }
            },
            setOp: function(stencilFail, stencilZFail, stencilZPass) {
                if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                    gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                    currentStencilFail = stencilFail;
                    currentStencilZFail = stencilZFail;
                    currentStencilZPass = stencilZPass;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(stencil) {
                if (currentStencilClear !== stencil) {
                    gl.clearStencil(stencil);
                    currentStencilClear = stencil;
                }
            },
            reset: function() {
                locked = false;
                currentStencilMask = null;
                currentStencilFunc = null;
                currentStencilRef = null;
                currentStencilFuncMask = null;
                currentStencilFail = null;
                currentStencilZFail = null;
                currentStencilZPass = null;
                currentStencilClear = null;
            }
        };
    }
    //
    const colorBuffer = new ColorBuffer();
    const depthBuffer = new DepthBuffer();
    const stencilBuffer = new StencilBuffer();
    let enabledCapabilities = {
    };
    let currentProgram = null;
    let currentBlendingEnabled = null;
    let currentBlending = null;
    let currentBlendEquation = null;
    let currentBlendSrc = null;
    let currentBlendDst = null;
    let currentBlendEquationAlpha = null;
    let currentBlendSrcAlpha = null;
    let currentBlendDstAlpha = null;
    let currentPremultipledAlpha = false;
    let currentFlipSided = null;
    let currentCullFace = null;
    let currentLineWidth = null;
    let currentPolygonOffsetFactor = null;
    let currentPolygonOffsetUnits = null;
    const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let lineWidthAvailable = false;
    let version = 0;
    const glVersion = gl.getParameter(gl.VERSION);
    if (glVersion.indexOf('WebGL') !== -1) {
        version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 1;
    } else if (glVersion.indexOf('OpenGL ES') !== -1) {
        version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 2;
    }
    let currentTextureSlot = null;
    let currentBoundTextures = {
    };
    const currentScissor = new Vector41();
    const currentViewport = new Vector41();
    function createTexture(type, target, count) {
        const data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
        const texture = gl.createTexture();
        gl.bindTexture(type, texture);
        gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        for(let i1 = 0; i1 < count; i1++)gl.texImage2D(target + i1, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        return texture;
    }
    const emptyTextures = {
    };
    emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
    emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
    // init
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(gl.DEPTH_TEST);
    depthBuffer.setFunc(LessEqualDepth);
    setFlipSided(false);
    setCullFace(CullFaceBack);
    enable(gl.CULL_FACE);
    setBlending(NoBlending);
    //
    function enable(id) {
        if (enabledCapabilities[id] !== true) {
            gl.enable(id);
            enabledCapabilities[id] = true;
        }
    }
    function disable(id) {
        if (enabledCapabilities[id] !== false) {
            gl.disable(id);
            enabledCapabilities[id] = false;
        }
    }
    function useProgram(program) {
        if (currentProgram !== program) {
            gl.useProgram(program);
            return true;
        }
        return false;
    }
    const equationToGL = {
        [AddEquation]: gl.FUNC_ADD,
        [SubtractEquation]: gl.FUNC_SUBTRACT,
        [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
    };
    if (isWebGL2) {
        equationToGL[MinEquation] = gl.MIN;
        equationToGL[MaxEquation] = gl.MAX;
    } else {
        const extension = extensions.get('EXT_blend_minmax');
        if (extension !== null) {
            equationToGL[MinEquation] = extension.MIN_EXT;
            equationToGL[MaxEquation] = extension.MAX_EXT;
        }
    }
    const factorToGL = {
        [ZeroFactor]: gl.ZERO,
        [OneFactor]: gl.ONE,
        [SrcColorFactor]: gl.SRC_COLOR,
        [SrcAlphaFactor]: gl.SRC_ALPHA,
        [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
        [DstColorFactor]: gl.DST_COLOR,
        [DstAlphaFactor]: gl.DST_ALPHA,
        [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
        [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
        [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
        [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
    };
    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
        if (blending === NoBlending) {
            if (currentBlendingEnabled) {
                disable(gl.BLEND);
                currentBlendingEnabled = false;
            }
            return;
        }
        if (!currentBlendingEnabled) {
            enable(gl.BLEND);
            currentBlendingEnabled = true;
        }
        if (blending !== CustomBlending) {
            if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
                if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
                    gl.blendEquation(gl.FUNC_ADD);
                    currentBlendEquation = AddEquation;
                    currentBlendEquationAlpha = AddEquation;
                }
                if (premultipliedAlpha) switch(blending){
                    case NormalBlending:
                        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                        break;
                    case AdditiveBlending:
                        gl.blendFunc(gl.ONE, gl.ONE);
                        break;
                    case SubtractiveBlending:
                        gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
                        break;
                    case MultiplyBlending:
                        gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
                        break;
                    default:
                        console.error('THREE.WebGLState: Invalid blending: ', blending);
                        break;
                }
                else switch(blending){
                    case NormalBlending:
                        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                        break;
                    case AdditiveBlending:
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                        break;
                    case SubtractiveBlending:
                        gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
                        break;
                    case MultiplyBlending:
                        gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                        break;
                    default:
                        console.error('THREE.WebGLState: Invalid blending: ', blending);
                        break;
                }
                currentBlendSrc = null;
                currentBlendDst = null;
                currentBlendSrcAlpha = null;
                currentBlendDstAlpha = null;
                currentBlending = blending;
                currentPremultipledAlpha = premultipliedAlpha;
            }
            return;
        }
        // custom blending
        blendEquationAlpha = blendEquationAlpha || blendEquation;
        blendSrcAlpha = blendSrcAlpha || blendSrc;
        blendDstAlpha = blendDstAlpha || blendDst;
        if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
            gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
            currentBlendEquation = blendEquation;
            currentBlendEquationAlpha = blendEquationAlpha;
        }
        if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
            gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
            currentBlendSrc = blendSrc;
            currentBlendDst = blendDst;
            currentBlendSrcAlpha = blendSrcAlpha;
            currentBlendDstAlpha = blendDstAlpha;
        }
        currentBlending = blending;
        currentPremultipledAlpha = null;
    }
    function setMaterial(material, frontFaceCW) {
        material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
        let flipSided = material.side === BackSide;
        if (frontFaceCW) flipSided = !flipSided;
        setFlipSided(flipSided);
        material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
        depthBuffer.setFunc(material.depthFunc);
        depthBuffer.setTest(material.depthTest);
        depthBuffer.setMask(material.depthWrite);
        colorBuffer.setMask(material.colorWrite);
        const stencilWrite = material.stencilWrite;
        stencilBuffer.setTest(stencilWrite);
        if (stencilWrite) {
            stencilBuffer.setMask(material.stencilWriteMask);
            stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
            stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
        }
        setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    }
    //
    function setFlipSided(flipSided) {
        if (currentFlipSided !== flipSided) {
            if (flipSided) gl.frontFace(gl.CW);
            else gl.frontFace(gl.CCW);
            currentFlipSided = flipSided;
        }
    }
    function setCullFace(cullFace) {
        if (cullFace !== CullFaceNone) {
            enable(gl.CULL_FACE);
            if (cullFace !== currentCullFace) {
                if (cullFace === CullFaceBack) gl.cullFace(gl.BACK);
                else if (cullFace === CullFaceFront) gl.cullFace(gl.FRONT);
                else gl.cullFace(gl.FRONT_AND_BACK);
            }
        } else disable(gl.CULL_FACE);
        currentCullFace = cullFace;
    }
    function setLineWidth(width2) {
        if (width2 !== currentLineWidth) {
            if (lineWidthAvailable) gl.lineWidth(width2);
        }
    }
    function setPolygonOffset(polygonOffset, factor, units) {
        if (polygonOffset) {
            enable(gl.POLYGON_OFFSET_FILL);
            if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
                gl.polygonOffset(factor, units);
                currentPolygonOffsetFactor = factor;
                currentPolygonOffsetUnits = units;
            }
        } else disable(gl.POLYGON_OFFSET_FILL);
    }
    function setScissorTest(scissorTest) {
        if (scissorTest) enable(gl.SCISSOR_TEST);
        else disable(gl.SCISSOR_TEST);
    }
    // texture
    function activeTexture(webglSlot) {
        if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;
        if (currentTextureSlot !== webglSlot) {
            gl.activeTexture(webglSlot);
        }
    }
    function bindTexture(webglType, webglTexture) {
        if (currentTextureSlot === null) activeTexture();
        let boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture === undefined) {
            boundTexture = {
                type: undefined,
                texture: undefined
            };
            currentBoundTextures[currentTextureSlot] = boundTexture;
        }
        if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
            gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
            boundTexture.type = webglType;
            boundTexture.texture = webglTexture;
        }
    }
    function unbindTexture() {
        const boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture !== undefined && boundTexture.type !== undefined) {
            gl.bindTexture(boundTexture.type, null);
            boundTexture.type = undefined;
            boundTexture.texture = undefined;
        }
    }
    function compressedTexImage2D() {
        try {
            gl.compressedTexImage2D.apply(gl, arguments);
        } catch (error) {
            console.error('THREE.WebGLState:', error);
        }
    }
    function texImage2D() {
        try {
            gl.texImage2D.apply(gl, arguments);
        } catch (error) {
            console.error('THREE.WebGLState:', error);
        }
    }
    function texImage3D() {
        try {
            gl.texImage3D.apply(gl, arguments);
        } catch (error) {
            console.error('THREE.WebGLState:', error);
        }
    }
    //
    function scissor(scissor1) {
        if (currentScissor.equals(scissor1) === false) {
            gl.scissor(scissor1.x, scissor1.y, scissor1.z, scissor1.w);
            currentScissor.copy(scissor1);
        }
    }
    function viewport(viewport1) {
        if (currentViewport.equals(viewport1) === false) {
            gl.viewport(viewport1.x, viewport1.y, viewport1.z, viewport1.w);
            currentViewport.copy(viewport1);
        }
    }
    //
    function reset() {
        enabledCapabilities = {
        };
        currentTextureSlot = null;
        currentBoundTextures = {
        };
        currentProgram = null;
        currentBlending = null;
        currentFlipSided = null;
        currentCullFace = null;
        colorBuffer.reset();
        depthBuffer.reset();
        stencilBuffer.reset();
    }
    return {
        buffers: {
            color: colorBuffer,
            depth: depthBuffer,
            stencil: stencilBuffer
        },
        enable: enable,
        disable: disable,
        useProgram: useProgram,
        setBlending: setBlending,
        setMaterial: setMaterial,
        setFlipSided: setFlipSided,
        setCullFace: setCullFace,
        setLineWidth: setLineWidth,
        setPolygonOffset: setPolygonOffset,
        setScissorTest: setScissorTest,
        activeTexture: activeTexture,
        bindTexture: bindTexture,
        unbindTexture: unbindTexture,
        compressedTexImage2D: compressedTexImage2D,
        texImage2D: texImage2D,
        texImage3D: texImage3D,
        scissor: scissor,
        viewport: viewport,
        reset: reset
    };
}
const WebGLState1 = WebGLState;
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
    const isWebGL2 = capabilities.isWebGL2;
    const maxTextures = capabilities.maxTextures;
    const maxCubemapSize = capabilities.maxCubemapSize;
    const maxTextureSize = capabilities.maxTextureSize;
    const maxSamples = capabilities.maxSamples;
    const _videoTextures = new WeakMap();
    let _canvas1;
    // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
    // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
    // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).
    let useOffscreenCanvas = false;
    try {
        useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch (err) {
    }
    function createCanvas(width2, height2) {
        // Use OffscreenCanvas when available. Specially needed in web workers
        return useOffscreenCanvas ? new OffscreenCanvas(width2, height2) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
    }
    function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
        let scale = 1;
        // handle case if texture exceeds max size
        if (image.width > maxSize || image.height > maxSize) scale = maxSize / Math.max(image.width, image.height);
        // only perform resize if necessary
        if (scale < 1 || needsPowerOfTwo === true) {
            // only perform resize for certain image types
            if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
                const floor = needsPowerOfTwo ? MathUtils1.floorPowerOfTwo : Math.floor;
                const width2 = floor(scale * image.width);
                const height2 = floor(scale * image.height);
                if (_canvas1 === undefined) _canvas1 = createCanvas(width2, height2);
                // cube textures can't reuse the same canvas
                const canvas = needsNewCanvas ? createCanvas(width2, height2) : _canvas1;
                canvas.width = width2;
                canvas.height = height2;
                const context = canvas.getContext('2d');
                context.drawImage(image, 0, 0, width2, height2);
                console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width2 + 'x' + height2 + ').');
                return canvas;
            } else {
                if ('data' in image) console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
                return image;
            }
        }
        return image;
    }
    function isPowerOfTwo(image) {
        return MathUtils1.isPowerOfTwo(image.width) && MathUtils1.isPowerOfTwo(image.height);
    }
    function textureNeedsPowerOfTwo(texture) {
        if (isWebGL2) return false;
        return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function textureNeedsGenerateMipmaps(texture, supportsMips) {
        return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function generateMipmap(target, texture, width2, height2) {
        _gl.generateMipmap(target);
        const textureProperties = properties.get(texture);
        // Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
        textureProperties.__maxMipLevel = Math.log(Math.max(width2, height2)) * Math.LOG2E;
    }
    function getInternalFormat(internalFormatName, glFormat, glType) {
        if (isWebGL2 === false) return glFormat;
        if (internalFormatName !== null) {
            if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
            console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
        }
        let internalFormat = glFormat;
        if (glFormat === _gl.RED) {
            if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
            if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
            if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
        }
        if (glFormat === _gl.RGB) {
            if (glType === _gl.FLOAT) internalFormat = _gl.RGB32F;
            if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGB16F;
            if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8;
        }
        if (glFormat === _gl.RGBA) {
            if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
            if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
            if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8;
        }
        if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) extensions.get('EXT_color_buffer_float');
        return internalFormat;
    }
    // Fallback filters for non-power-of-2 textures
    function filterFallback(f) {
        if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) return _gl.NEAREST;
        return _gl.LINEAR;
    }
    //
    function onTextureDispose(event) {
        const texture = event.target;
        texture.removeEventListener('dispose', onTextureDispose);
        deallocateTexture(texture);
        if (texture.isVideoTexture) _videoTextures.delete(texture);
        info.memory.textures--;
    }
    function onRenderTargetDispose(event) {
        const renderTarget = event.target;
        renderTarget.removeEventListener('dispose', onRenderTargetDispose);
        deallocateRenderTarget(renderTarget);
        info.memory.textures--;
    }
    //
    function deallocateTexture(texture) {
        const textureProperties = properties.get(texture);
        if (textureProperties.__webglInit === undefined) return;
        _gl.deleteTexture(textureProperties.__webglTexture);
        properties.remove(texture);
    }
    function deallocateRenderTarget(renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        const textureProperties = properties.get(renderTarget.texture);
        if (!renderTarget) return;
        if (textureProperties.__webglTexture !== undefined) _gl.deleteTexture(textureProperties.__webglTexture);
        if (renderTarget.depthTexture) renderTarget.depthTexture.dispose();
        if (renderTarget.isWebGLCubeRenderTarget) for(let i1 = 0; i1 < 6; i1++){
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i1]);
            if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i1]);
        }
        else {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
            if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
            if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
            if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
            if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
        }
        properties.remove(renderTarget.texture);
        properties.remove(renderTarget);
    }
    //
    let textureUnits = 0;
    function resetTextureUnits() {
        textureUnits = 0;
    }
    function allocateTextureUnit() {
        const textureUnit = textureUnits;
        if (textureUnit >= maxTextures) console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
        textureUnits += 1;
        return textureUnit;
    }
    //
    function setTexture2D(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.isVideoTexture) updateVideoTexture(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            const image = texture.image;
            if (image === undefined) console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
            else if (image.complete === false) console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
            else {
                uploadTexture(textureProperties, texture, slot);
                return;
            }
        }
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
    }
    function setTexture2DArray(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
        }
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture);
    }
    function setTexture3D(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
        }
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);
    }
    function setTextureCube(texture, slot) {
        if (texture.image.length !== 6) return;
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            initTexture(textureProperties, texture);
            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
            const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
            const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
            const cubeImage = [];
            for(let i1 = 0; i1 < 6; i1++)if (!isCompressed && !isDataTexture) cubeImage[i1] = resizeImage(texture.image[i1], false, true, maxCubemapSize);
            else cubeImage[i1] = isDataTexture ? texture.image[i1].image : texture.image[i1];
            const image = cubeImage[0], supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
            setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
            let mipmaps;
            if (isCompressed) {
                for(let i11 = 0; i11 < 6; i11++){
                    mipmaps = cubeImage[i11].mipmaps;
                    for(let j = 0; j < mipmaps.length; j++){
                        const mipmap = mipmaps[j];
                        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                            if (glFormat !== null) state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i11, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                            else console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
                        } else state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i11, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                }
                textureProperties.__maxMipLevel = mipmaps.length - 1;
            } else {
                mipmaps = texture.mipmaps;
                for(let i11 = 0; i11 < 6; i11++)if (isDataTexture) {
                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i11, 0, glInternalFormat, cubeImage[i11].width, cubeImage[i11].height, 0, glFormat, glType, cubeImage[i11].data);
                    for(let j = 0; j < mipmaps.length; j++){
                        const mipmap = mipmaps[j];
                        const mipmapImage = mipmap.image[i11].image;
                        state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i11, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                    }
                } else {
                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i11, 0, glInternalFormat, glFormat, glType, cubeImage[i11]);
                    for(let j = 0; j < mipmaps.length; j++){
                        const mipmap = mipmaps[j];
                        state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i11, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i11]);
                    }
                }
                textureProperties.__maxMipLevel = mipmaps.length;
            }
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) // We assume images for cube map have the same size.
            generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, image.width, image.height);
            textureProperties.__version = texture.version;
            if (texture.onUpdate) texture.onUpdate(texture);
        } else {
            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
        }
    }
    function setTextureCubeDynamic(texture, slot) {
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
    }
    const wrappingToGL = {
        [RepeatWrapping]: _gl.REPEAT,
        [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
        [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
    };
    const filterToGL = {
        [NearestFilter]: _gl.NEAREST,
        [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
        [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
        [LinearFilter]: _gl.LINEAR,
        [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
        [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
    };
    function setTextureParameters(textureType, texture, supportsMips) {
        if (supportsMips) {
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
            if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
        } else {
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
            if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
            if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
            if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
        }
        const extension = extensions.get('EXT_texture_filter_anisotropic');
        if (extension) {
            if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null) return;
            if (texture.type === HalfFloatType && (isWebGL2 || extensions.get('OES_texture_half_float_linear')) === null) return;
            if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                properties.get(texture).__currentAnisotropy = texture.anisotropy;
            }
        }
    }
    function initTexture(textureProperties, texture) {
        if (textureProperties.__webglInit === undefined) {
            textureProperties.__webglInit = true;
            texture.addEventListener('dispose', onTextureDispose);
            textureProperties.__webglTexture = _gl.createTexture();
            info.memory.textures++;
        }
    }
    function uploadTexture(textureProperties, texture, slot) {
        let textureType = _gl.TEXTURE_2D;
        if (texture.isDataTexture2DArray) textureType = _gl.TEXTURE_2D_ARRAY;
        if (texture.isDataTexture3D) textureType = _gl.TEXTURE_3D;
        initTexture(textureProperties, texture);
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(textureType, textureProperties.__webglTexture);
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
        const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
        const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
        const supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format);
        let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
        setTextureParameters(textureType, texture, supportsMips);
        let mipmap;
        const mipmaps = texture.mipmaps;
        if (texture.isDepthTexture) {
            // populate depth texture with dummy data
            glInternalFormat = _gl.DEPTH_COMPONENT;
            if (isWebGL2) {
                if (texture.type === FloatType) glInternalFormat = _gl.DEPTH_COMPONENT32F;
                else if (texture.type === UnsignedIntType) glInternalFormat = _gl.DEPTH_COMPONENT24;
                else if (texture.type === UnsignedInt248Type) glInternalFormat = _gl.DEPTH24_STENCIL8;
                else glInternalFormat = _gl.DEPTH_COMPONENT16; // WebGL2 requires sized internalformat for glTexImage2D
            } else if (texture.type === FloatType) console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
            // validation checks for WebGL 1
            if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
            // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
            // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
            {
                if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
                    console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
                    texture.type = UnsignedShortType;
                    glType = utils.convert(texture.type);
                }
            }
            if (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
                // Depth stencil textures need the DEPTH_STENCIL internal format
                // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                glInternalFormat = _gl.DEPTH_STENCIL;
                // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
                // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                if (texture.type !== UnsignedInt248Type) {
                    console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
                    texture.type = UnsignedInt248Type;
                    glType = utils.convert(texture.type);
                }
            }
            //
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
        } else if (texture.isDataTexture) {
            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels
            if (mipmaps.length > 0 && supportsMips) {
                for(let i1 = 0, il = mipmaps.length; i1 < il; i1++){
                    mipmap = mipmaps[i1];
                    state.texImage2D(_gl.TEXTURE_2D, i1, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
                texture.generateMipmaps = false;
                textureProperties.__maxMipLevel = mipmaps.length - 1;
            } else {
                state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
                textureProperties.__maxMipLevel = 0;
            }
        } else if (texture.isCompressedTexture) {
            for(let i1 = 0, il = mipmaps.length; i1 < il; i1++){
                mipmap = mipmaps[i1];
                if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                    if (glFormat !== null) state.compressedTexImage2D(_gl.TEXTURE_2D, i1, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                    else console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
                } else state.texImage2D(_gl.TEXTURE_2D, i1, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
            textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else if (texture.isDataTexture2DArray) {
            state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
            textureProperties.__maxMipLevel = 0;
        } else if (texture.isDataTexture3D) {
            state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
            textureProperties.__maxMipLevel = 0;
        } else // regular Texture (image, video, canvas)
        // use manually created mipmaps if available
        // if there are no manual mipmaps
        // set 0 level mipmap and then use GL to generate other mipmap levels
        if (mipmaps.length > 0 && supportsMips) {
            for(let i1 = 0, il = mipmaps.length; i1 < il; i1++){
                mipmap = mipmaps[i1];
                state.texImage2D(_gl.TEXTURE_2D, i1, glInternalFormat, glFormat, glType, mipmap);
            }
            texture.generateMipmaps = false;
            textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
            textureProperties.__maxMipLevel = 0;
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) generateMipmap(textureType, texture, image.width, image.height);
        textureProperties.__version = texture.version;
        if (texture.onUpdate) texture.onUpdate(texture);
    }
    // Render targets
    // Setup storage for target texture and bind it to correct framebuffer
    function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
        const glFormat = utils.convert(renderTarget.texture.format);
        const glType = utils.convert(renderTarget.texture.type);
        const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
        state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }
    // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
            let glInternalFormat = _gl.DEPTH_COMPONENT16;
            if (isMultisample) {
                const depthTexture = renderTarget.depthTexture;
                if (depthTexture && depthTexture.isDepthTexture) {
                    if (depthTexture.type === FloatType) glInternalFormat = _gl.DEPTH_COMPONENT32F;
                    else if (depthTexture.type === UnsignedIntType) glInternalFormat = _gl.DEPTH_COMPONENT24;
                }
                const samples = getRenderTargetSamples(renderTarget);
                _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            } else _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
        } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
            if (isMultisample) {
                const samples = getRenderTargetSamples(renderTarget);
                _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
            } else _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
        } else {
            const glFormat = utils.convert(renderTarget.texture.format);
            const glType = utils.convert(renderTarget.texture.type);
            const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
            if (isMultisample) {
                const samples = getRenderTargetSamples(renderTarget);
                _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            } else _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
        }
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
    }
    // Setup resources for a Depth Texture for a FBO (needs an extension)
    function setupDepthTexture(framebuffer, renderTarget) {
        const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
        if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
        // upload an empty depth texture with framebuffer size
        if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
            renderTarget.depthTexture.image.width = renderTarget.width;
            renderTarget.depthTexture.image.height = renderTarget.height;
            renderTarget.depthTexture.needsUpdate = true;
        }
        setTexture2D(renderTarget.depthTexture, 0);
        const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
        if (renderTarget.depthTexture.format === DepthFormat) _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
        else if (renderTarget.depthTexture.format === DepthStencilFormat) _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
        else throw new Error('Unknown depthTexture format');
    }
    // Setup GL resources for a non-texture depth buffer
    function setupDepthRenderbuffer(renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        const isCube = renderTarget.isWebGLCubeRenderTarget === true;
        if (renderTarget.depthTexture) {
            if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
            setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
        } else if (isCube) {
            renderTargetProperties.__webglDepthbuffer = [];
            for(let i1 = 0; i1 < 6; i1++){
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i1]);
                renderTargetProperties.__webglDepthbuffer[i1] = _gl.createRenderbuffer();
                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i1], renderTarget, false);
            }
        } else {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
            renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
        }
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }
    // Set up GL resources for the render target
    function setupRenderTarget(renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        const textureProperties = properties.get(renderTarget.texture);
        renderTarget.addEventListener('dispose', onRenderTargetDispose);
        textureProperties.__webglTexture = _gl.createTexture();
        info.memory.textures++;
        const isCube = renderTarget.isWebGLCubeRenderTarget === true;
        const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
        const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
        // Handles WebGL2 RGBFormat fallback - #18858
        if (isWebGL2 && renderTarget.texture.format === RGBFormat && (renderTarget.texture.type === FloatType || renderTarget.texture.type === HalfFloatType)) {
            renderTarget.texture.format = RGBAFormat;
            console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');
        }
        // Setup framebuffer
        if (isCube) {
            renderTargetProperties.__webglFramebuffer = [];
            for(let i1 = 0; i1 < 6; i1++)renderTargetProperties.__webglFramebuffer[i1] = _gl.createFramebuffer();
        } else {
            renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            if (isMultisample) {
                if (isWebGL2) {
                    renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
                    renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
                    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);
                    const glFormat = utils.convert(renderTarget.texture.format);
                    const glType = utils.convert(renderTarget.texture.type);
                    const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
                    const samples = getRenderTargetSamples(renderTarget);
                    _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
                    _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);
                    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
                    if (renderTarget.depthBuffer) {
                        renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                        setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
                    }
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
                } else console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
            }
        }
        // Setup color buffer
        if (isCube) {
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
            setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, supportsMips);
            for(let i1 = 0; i1 < 6; i1++)setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i1], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i1);
            if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) generateMipmap(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, renderTarget.width, renderTarget.height);
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
        } else {
            state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
            setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, supportsMips);
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
            if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) generateMipmap(_gl.TEXTURE_2D, renderTarget.texture, renderTarget.width, renderTarget.height);
            state.bindTexture(_gl.TEXTURE_2D, null);
        }
        // Setup depth and stencil buffers
        if (renderTarget.depthBuffer) setupDepthRenderbuffer(renderTarget);
    }
    function updateRenderTargetMipmap(renderTarget) {
        const texture = renderTarget.texture;
        const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
            const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
            const webglTexture = properties.get(texture).__webglTexture;
            state.bindTexture(target, webglTexture);
            generateMipmap(target, texture, renderTarget.width, renderTarget.height);
            state.bindTexture(target, null);
        }
    }
    function updateMultisampleRenderTarget(renderTarget) {
        if (renderTarget.isWebGLMultisampleRenderTarget) {
            if (isWebGL2) {
                const renderTargetProperties = properties.get(renderTarget);
                _gl.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
                _gl.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                const width2 = renderTarget.width;
                const height2 = renderTarget.height;
                let mask = _gl.COLOR_BUFFER_BIT;
                if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
                if (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
                _gl.blitFramebuffer(0, 0, width2, height2, 0, 0, width2, height2, mask, _gl.NEAREST);
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer); // see #18905
            } else console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
        }
    }
    function getRenderTargetSamples(renderTarget) {
        return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
    }
    function updateVideoTexture(texture) {
        const frame = info.render.frame;
        // Check the last frame we updated the VideoTexture
        if (_videoTextures.get(texture) !== frame) {
            _videoTextures.set(texture, frame);
            texture.update();
        }
    }
    // backwards compatibility
    let warnedTexture2D = false;
    let warnedTextureCube = false;
    function safeSetTexture2D(texture, slot) {
        if (texture && texture.isWebGLRenderTarget) {
            if (warnedTexture2D === false) {
                console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
            }
            texture = texture.texture;
        }
        setTexture2D(texture, slot);
    }
    function safeSetTextureCube(texture, slot) {
        if (texture && texture.isWebGLCubeRenderTarget) {
            if (warnedTextureCube === false) {
                console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
            }
            texture = texture.texture;
        }
        // currently relying on the fact that WebGLCubeRenderTarget.texture is a Texture and NOT a CubeTexture
        // TODO: unify these code paths
        if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) // CompressedTexture can have Array in image :/
        // this function alone should take care of cube textures
        setTextureCube(texture, slot);
        else // assumed: texture property of THREE.WebGLCubeRenderTarget
        setTextureCubeDynamic(texture, slot);
    }
    //
    this.allocateTextureUnit = allocateTextureUnit;
    this.resetTextureUnits = resetTextureUnits;
    this.setTexture2D = setTexture2D;
    this.setTexture2DArray = setTexture2DArray;
    this.setTexture3D = setTexture3D;
    this.setTextureCube = setTextureCube;
    this.setTextureCubeDynamic = setTextureCubeDynamic;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    this.safeSetTexture2D = safeSetTexture2D;
    this.safeSetTextureCube = safeSetTextureCube;
}
const WebGLTextures1 = WebGLTextures;
function WebGLUtils(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function convert(p) {
        let extension;
        if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
        if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
        if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
        if (p === UnsignedShort565Type) return gl.UNSIGNED_SHORT_5_6_5;
        if (p === ByteType) return gl.BYTE;
        if (p === ShortType) return gl.SHORT;
        if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
        if (p === IntType) return gl.INT;
        if (p === UnsignedIntType) return gl.UNSIGNED_INT;
        if (p === FloatType) return gl.FLOAT;
        if (p === HalfFloatType) {
            if (isWebGL2) return gl.HALF_FLOAT;
            extension = extensions.get('OES_texture_half_float');
            if (extension !== null) return extension.HALF_FLOAT_OES;
            else return null;
        }
        if (p === AlphaFormat) return gl.ALPHA;
        if (p === RGBFormat) return gl.RGB;
        if (p === RGBAFormat) return gl.RGBA;
        if (p === LuminanceFormat) return gl.LUMINANCE;
        if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
        if (p === DepthFormat) return gl.DEPTH_COMPONENT;
        if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
        if (p === RedFormat) return gl.RED;
        // WebGL2 formats.
        if (p === RedIntegerFormat) return gl.RED_INTEGER;
        if (p === RGFormat) return gl.RG;
        if (p === RGIntegerFormat) return gl.RG_INTEGER;
        if (p === RGBIntegerFormat) return gl.RGB_INTEGER;
        if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;
        if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
            extension = extensions.get('WEBGL_compressed_texture_s3tc');
            if (extension !== null) {
                if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
        }
        if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
            extension = extensions.get('WEBGL_compressed_texture_pvrtc');
            if (extension !== null) {
                if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
        }
        if (p === RGB_ETC1_Format) {
            extension = extensions.get('WEBGL_compressed_texture_etc1');
            if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;
            else return null;
        }
        if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
            extension = extensions.get('WEBGL_compressed_texture_etc');
            if (extension !== null) {
                if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;
                if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;
            }
        }
        if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
            extension = extensions.get('WEBGL_compressed_texture_astc');
            if (extension !== null) // TODO Complete?
            return p;
            else return null;
        }
        if (p === RGBA_BPTC_Format) {
            extension = extensions.get('EXT_texture_compression_bptc');
            if (extension !== null) // TODO Complete?
            return p;
            else return null;
        }
        if (p === UnsignedInt248Type) {
            if (isWebGL2) return gl.UNSIGNED_INT_24_8;
            extension = extensions.get('WEBGL_depth_texture');
            if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;
            else return null;
        }
    }
    return {
        convert: convert
    };
}
const WebGLUtils1 = WebGLUtils;
function ArrayCamera(array) {
    PerspectiveCamera1.call(this);
    this.cameras = array || [];
}
ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera1.prototype), {
    constructor: ArrayCamera,
    isArrayCamera: true
});
const ArrayCamera1 = ArrayCamera;
import { WebGLAnimation } from '../webgl/WebGLAnimation.js';
function Group() {
    Object3D1.call(this);
    this.type = 'Group';
}
Group.prototype = Object.assign(Object.create(Object3D1.prototype), {
    constructor: Group,
    isGroup: true
});
const Group1 = Group;
function WebXRController() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
}
Object.assign(WebXRController.prototype, {
    constructor: WebXRController,
    getHandSpace: function() {
        if (this._hand === null) {
            this._hand = new Group1();
            this._hand.matrixAutoUpdate = false;
            this._hand.visible = false;
            this._hand.joints = [];
            this._hand.inputState = {
                pinching: false
            };
            if (window.XRHand) for(let i1 = 0; i1 <= window.XRHand.LITTLE_PHALANX_TIP; i1++){
                // The transform of this joint will be updated with the joint pose on each frame
                const joint = new Group1();
                joint.matrixAutoUpdate = false;
                joint.visible = false;
                this._hand.joints.push(joint);
                // ??
                this._hand.add(joint);
            }
        }
        return this._hand;
    },
    getTargetRaySpace: function() {
        if (this._targetRay === null) {
            this._targetRay = new Group1();
            this._targetRay.matrixAutoUpdate = false;
            this._targetRay.visible = false;
        }
        return this._targetRay;
    },
    getGripSpace: function() {
        if (this._grip === null) {
            this._grip = new Group1();
            this._grip.matrixAutoUpdate = false;
            this._grip.visible = false;
        }
        return this._grip;
    },
    dispatchEvent: function(event) {
        if (this._targetRay !== null) this._targetRay.dispatchEvent(event);
        if (this._grip !== null) this._grip.dispatchEvent(event);
        if (this._hand !== null) this._hand.dispatchEvent(event);
        return this;
    },
    disconnect: function(inputSource) {
        this.dispatchEvent({
            type: 'disconnected',
            data: inputSource
        });
        if (this._targetRay !== null) this._targetRay.visible = false;
        if (this._grip !== null) this._grip.visible = false;
        if (this._hand !== null) this._hand.visible = false;
        return this;
    },
    update: function(inputSource, frame, referenceSpace) {
        let inputPose = null;
        let gripPose = null;
        let handPose = null;
        const targetRay = this._targetRay;
        const grip = this._grip;
        const hand = this._hand;
        if (inputSource) {
            if (hand && inputSource.hand) {
                handPose = true;
                for(let i1 = 0; i1 <= window.XRHand.LITTLE_PHALANX_TIP; i1++)if (inputSource.hand[i1]) {
                    // Update the joints groups with the XRJoint poses
                    const jointPose = frame.getJointPose(inputSource.hand[i1], referenceSpace);
                    const joint = hand.joints[i1];
                    if (jointPose !== null) {
                        joint.matrix.fromArray(jointPose.transform.matrix);
                        joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                        joint.jointRadius = jointPose.radius;
                    }
                    joint.visible = jointPose !== null;
                    // Custom events
                    // Check pinch
                    const indexTip = hand.joints[window.XRHand.INDEX_PHALANX_TIP];
                    const thumbTip = hand.joints[window.XRHand.THUMB_PHALANX_TIP];
                    const distance = indexTip.position.distanceTo(thumbTip.position);
                    const distanceToPinch = 0.02;
                    const threshold = 0.005;
                    if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
                        hand.inputState.pinching = false;
                        this.dispatchEvent({
                            type: "pinchend",
                            handedness: inputSource.handedness,
                            target: this
                        });
                    } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
                        hand.inputState.pinching = true;
                        this.dispatchEvent({
                            type: "pinchstart",
                            handedness: inputSource.handedness,
                            target: this
                        });
                    }
                }
            } else {
                if (targetRay !== null) {
                    inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
                    if (inputPose !== null) {
                        targetRay.matrix.fromArray(inputPose.transform.matrix);
                        targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
                    }
                }
                if (grip !== null && inputSource.gripSpace) {
                    gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
                    if (gripPose !== null) {
                        grip.matrix.fromArray(gripPose.transform.matrix);
                        grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                    }
                }
            }
        }
        if (targetRay !== null) targetRay.visible = inputPose !== null;
        if (grip !== null) grip.visible = gripPose !== null;
        if (hand !== null) hand.visible = handPose !== null;
        return this;
    }
});
const WebXRController1 = WebXRController;
function WebXRManager(renderer, gl) {
    const scope1 = this;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = 'local-floor';
    let pose = null;
    const controllers = [];
    const inputSourcesMap = new Map();
    //
    const cameraL = new PerspectiveCamera1();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector41();
    const cameraR = new PerspectiveCamera1();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector41();
    const cameras = [
        cameraL,
        cameraR
    ];
    const cameraVR = new ArrayCamera1();
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    //
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index) {
        let controller = controllers[index];
        if (controller === undefined) {
            controller = new WebXRController1();
            controllers[index] = controller;
        }
        return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index) {
        let controller = controllers[index];
        if (controller === undefined) {
            controller = new WebXRController1();
            controllers[index] = controller;
        }
        return controller.getGripSpace();
    };
    this.getHand = function(index) {
        let controller = controllers[index];
        if (controller === undefined) {
            controller = new WebXRController1();
            controllers[index] = controller;
        }
        return controller.getHandSpace();
    };
    //
    function onSessionEvent(event) {
        const controller = inputSourcesMap.get(event.inputSource);
        if (controller) controller.dispatchEvent({
            type: event.type
        });
    }
    function onSessionEnd() {
        inputSourcesMap.forEach(function(controller, inputSource) {
            controller.disconnect(inputSource);
        });
        inputSourcesMap.clear();
        //
        renderer.setFramebuffer(null);
        renderer.setRenderTarget(renderer.getRenderTarget()); // Hack #15830
        animation.stop();
        scope1.isPresenting = false;
        scope1.dispatchEvent({
            type: 'sessionend'
        });
    }
    function onRequestReferenceSpace(value) {
        animation.setContext(session);
        animation.start();
        scope1.isPresenting = true;
        scope1.dispatchEvent({
            type: 'sessionstart'
        });
    }
    this.setFramebufferScaleFactor = function(value) {
        framebufferScaleFactor = value;
        if (scope1.isPresenting === true) console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
    };
    this.setReferenceSpaceType = function(value) {
        referenceSpaceType = value;
        if (scope1.isPresenting === true) console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
    };
    this.getReferenceSpace = function() {
        return referenceSpace;
    };
    this.getSession = function() {
        return session;
    };
    this.setSession = function(value) {
        session = value;
        if (session !== null) {
            session.addEventListener('select', onSessionEvent);
            session.addEventListener('selectstart', onSessionEvent);
            session.addEventListener('selectend', onSessionEvent);
            session.addEventListener('squeeze', onSessionEvent);
            session.addEventListener('squeezestart', onSessionEvent);
            session.addEventListener('squeezeend', onSessionEvent);
            session.addEventListener('end', onSessionEnd);
            const attributes = gl.getContextAttributes();
            if (attributes.xrCompatible !== true) gl.makeXRCompatible();
            const layerInit = {
                antialias: attributes.antialias,
                alpha: attributes.alpha,
                depth: attributes.depth,
                stencil: attributes.stencil,
                framebufferScaleFactor: framebufferScaleFactor
            };
            // eslint-disable-next-line no-undef
            const baseLayer = new XRWebGLLayer(session, gl, layerInit);
            session.updateRenderState({
                baseLayer: baseLayer
            });
            session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace);
            //
            session.addEventListener('inputsourceschange', updateInputSources);
        }
    };
    function updateInputSources(event) {
        const inputSources = session.inputSources;
        // Assign inputSources to available controllers
        for(let i1 = 0; i1 < controllers.length; i1++)inputSourcesMap.set(inputSources[i1], controllers[i1]);
        // Notify disconnected
        for(let i1 = 0; i1 < event.removed.length; i1++){
            const inputSource = event.removed[i1];
            const controller = inputSourcesMap.get(inputSource);
            if (controller) {
                controller.dispatchEvent({
                    type: 'disconnected',
                    data: inputSource
                });
                inputSourcesMap.delete(inputSource);
            }
        }
        // Notify connected
        for(let i1 = 0; i1 < event.added.length; i1++){
            const inputSource = event.added[i1];
            const controller = inputSourcesMap.get(inputSource);
            if (controller) controller.dispatchEvent({
                type: 'connected',
                data: inputSource
            });
        }
    }
    //
    const cameraLPos = new Vector31();
    const cameraRPos = new Vector31();
    /**
	 * Assumes 2 cameras that are parallel and share an X-axis, and that
	 * the cameras' projection and world matrices have already been set.
	 * And that near and far planes are identical for both cameras.
	 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
	 */
    function setProjectionFromUnion(camera, cameraL1, cameraR1) {
        cameraLPos.setFromMatrixPosition(cameraL1.matrixWorld);
        cameraRPos.setFromMatrixPosition(cameraR1.matrixWorld);
        const ipd = cameraLPos.distanceTo(cameraRPos);
        const projL = cameraL1.projectionMatrix.elements;
        const projR = cameraR1.projectionMatrix.elements;
        // VR systems will have identical far and near planes, and
        // most likely identical top and bottom frustum extents.
        // Use the left camera for these values.
        const near = projL[14] / (projL[10] - 1);
        const far = projL[14] / (projL[10] + 1);
        const topFov = (projL[9] + 1) / projL[5];
        const bottomFov = (projL[9] - 1) / projL[5];
        const leftFov = (projL[8] - 1) / projL[0];
        const rightFov = (projR[8] + 1) / projR[0];
        const left = near * leftFov;
        const right = near * rightFov;
        // Calculate the new camera's position offset from the
        // left camera. xOffset should be roughly half `ipd`.
        const zOffset = ipd / (-leftFov + rightFov);
        const xOffset = zOffset * -leftFov;
        // TODO: Better way to apply this offset?
        cameraL1.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
        camera.translateX(xOffset);
        camera.translateZ(zOffset);
        camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
        // Find the union of the frustum values of the cameras and scale
        // the values so that the near plane's position does not change in world space,
        // although must now be relative to the new union camera.
        const near2 = near + zOffset;
        const far2 = far + zOffset;
        const left2 = left - xOffset;
        const right2 = right + (ipd - xOffset);
        const top2 = topFov * far / far2 * near2;
        const bottom2 = bottomFov * far / far2 * near2;
        camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
    }
    function updateCamera(camera, parent) {
        if (parent === null) camera.matrixWorld.copy(camera.matrix);
        else camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    }
    this.getCamera = function(camera) {
        cameraVR.near = cameraR.near = cameraL.near = camera.near;
        cameraVR.far = cameraR.far = cameraL.far = camera.far;
        if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
            // Note that the new renderState won't apply until the next frame. See #18320
            session.updateRenderState({
                depthNear: cameraVR.near,
                depthFar: cameraVR.far
            });
            _currentDepthNear = cameraVR.near;
            _currentDepthFar = cameraVR.far;
        }
        const parent = camera.parent;
        const cameras1 = cameraVR.cameras;
        updateCamera(cameraVR, parent);
        for(let i1 = 0; i1 < cameras1.length; i1++)updateCamera(cameras1[i1], parent);
        // update camera and its children
        camera.matrixWorld.copy(cameraVR.matrixWorld);
        const children = camera.children;
        for(let i1 = 0, l = children.length; i1 < l; i1++)children[i1].updateMatrixWorld(true);
        // update projection matrix for proper view frustum culling
        if (cameras1.length === 2) setProjectionFromUnion(cameraVR, cameraL, cameraR);
        else // assume single camera setup (AR)
        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
        return cameraVR;
    };
    // Animation Loop
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
        pose = frame.getViewerPose(referenceSpace);
        if (pose !== null) {
            const views = pose.views;
            const baseLayer = session.renderState.baseLayer;
            renderer.setFramebuffer(baseLayer.framebuffer);
            let cameraVRNeedsUpdate = false;
            // check if it's necessary to rebuild cameraVR's camera list
            if (views.length !== cameraVR.cameras.length) {
                cameraVR.cameras.length = 0;
            }
            for(let i1 = 0; i1 < views.length; i1++){
                const view = views[i1];
                const viewport = baseLayer.getViewport(view);
                const camera = cameras[i1];
                camera.matrix.fromArray(view.transform.matrix);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                if (i1 === 0) cameraVR.matrix.copy(camera.matrix);
                if (cameraVRNeedsUpdate === true) cameraVR.cameras.push(camera);
            }
        }
        //
        const inputSources = session.inputSources;
        for(let i1 = 0; i1 < controllers.length; i1++){
            const controller = controllers[i1];
            const inputSource = inputSources[i1];
            controller.update(inputSource, frame, referenceSpace);
        }
        if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
}
Object.assign(WebXRManager.prototype, EventDispatcher1.prototype);
const WebXRManager1 = WebXRManager;
function WebGLMaterials(properties) {
    function refreshFogUniforms(uniforms, fog) {
        uniforms.fogColor.value.copy(fog.color);
        if (fog.isFog) {
            uniforms.fogNear.value = fog.near;
            uniforms.fogFar.value = fog.far;
        } else if (fog.isFogExp2) uniforms.fogDensity.value = fog.density;
    }
    function refreshMaterialUniforms(uniforms, material, pixelRatio, height2) {
        if (material.isMeshBasicMaterial) refreshUniformsCommon(uniforms, material);
        else if (material.isMeshLambertMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsLambert(uniforms, material);
        } else if (material.isMeshToonMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsToon(uniforms, material);
        } else if (material.isMeshPhongMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsPhong(uniforms, material);
        } else if (material.isMeshStandardMaterial) {
            refreshUniformsCommon(uniforms, material);
            if (material.isMeshPhysicalMaterial) refreshUniformsPhysical(uniforms, material);
            else refreshUniformsStandard(uniforms, material);
        } else if (material.isMeshMatcapMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsMatcap(uniforms, material);
        } else if (material.isMeshDepthMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsDepth(uniforms, material);
        } else if (material.isMeshDistanceMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsDistance(uniforms, material);
        } else if (material.isMeshNormalMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsNormal(uniforms, material);
        } else if (material.isLineBasicMaterial) {
            refreshUniformsLine(uniforms, material);
            if (material.isLineDashedMaterial) refreshUniformsDash(uniforms, material);
        } else if (material.isPointsMaterial) refreshUniformsPoints(uniforms, material, pixelRatio, height2);
        else if (material.isSpriteMaterial) refreshUniformsSprites(uniforms, material);
        else if (material.isShadowMaterial) {
            uniforms.color.value.copy(material.color);
            uniforms.opacity.value = material.opacity;
        } else if (material.isShaderMaterial) material.uniformsNeedUpdate = false; // #15581
    }
    function refreshUniformsCommon(uniforms, material) {
        uniforms.opacity.value = material.opacity;
        if (material.color) uniforms.diffuse.value.copy(material.color);
        if (material.emissive) uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
        if (material.map) uniforms.map.value = material.map;
        if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
        if (material.specularMap) uniforms.specularMap.value = material.specularMap;
        const envMap = properties.get(material).envMap;
        if (envMap) {
            uniforms.envMap.value = envMap;
            uniforms.flipEnvMap.value = envMap.isCubeTexture ? -1 : 1;
            uniforms.reflectivity.value = material.reflectivity;
            uniforms.refractionRatio.value = material.refractionRatio;
            const maxMipLevel = properties.get(envMap).__maxMipLevel;
            if (maxMipLevel !== undefined) uniforms.maxMipLevel.value = maxMipLevel;
        }
        if (material.lightMap) {
            uniforms.lightMap.value = material.lightMap;
            uniforms.lightMapIntensity.value = material.lightMapIntensity;
        }
        if (material.aoMap) {
            uniforms.aoMap.value = material.aoMap;
            uniforms.aoMapIntensity.value = material.aoMapIntensity;
        }
        // uv repeat and offset setting priorities
        // 1. color map
        // 2. specular map
        // 3. normal map
        // 4. bump map
        // 5. alpha map
        // 6. emissive map
        let uvScaleMap;
        if (material.map) uvScaleMap = material.map;
        else if (material.specularMap) uvScaleMap = material.specularMap;
        else if (material.displacementMap) uvScaleMap = material.displacementMap;
        else if (material.normalMap) uvScaleMap = material.normalMap;
        else if (material.bumpMap) uvScaleMap = material.bumpMap;
        else if (material.roughnessMap) uvScaleMap = material.roughnessMap;
        else if (material.metalnessMap) uvScaleMap = material.metalnessMap;
        else if (material.alphaMap) uvScaleMap = material.alphaMap;
        else if (material.emissiveMap) uvScaleMap = material.emissiveMap;
        if (uvScaleMap !== undefined) {
            // backwards compatibility
            if (uvScaleMap.isWebGLRenderTarget) uvScaleMap = uvScaleMap.texture;
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
        // uv repeat and offset setting priorities for uv2
        // 1. ao map
        // 2. light map
        let uv2ScaleMap;
        if (material.aoMap) uv2ScaleMap = material.aoMap;
        else if (material.lightMap) uv2ScaleMap = material.lightMap;
        if (uv2ScaleMap !== undefined) {
            // backwards compatibility
            if (uv2ScaleMap.isWebGLRenderTarget) uv2ScaleMap = uv2ScaleMap.texture;
            if (uv2ScaleMap.matrixAutoUpdate === true) uv2ScaleMap.updateMatrix();
            uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
        }
    }
    function refreshUniformsLine(uniforms, material) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
    }
    function refreshUniformsDash(uniforms, material) {
        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;
    }
    function refreshUniformsPoints(uniforms, material, pixelRatio, height2) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size * pixelRatio;
        uniforms.scale.value = height2 * 0.5;
        if (material.map) uniforms.map.value = material.map;
        if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
        // uv repeat and offset setting priorities
        // 1. color map
        // 2. alpha map
        let uvScaleMap;
        if (material.map) uvScaleMap = material.map;
        else if (material.alphaMap) uvScaleMap = material.alphaMap;
        if (uvScaleMap !== undefined) {
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
    }
    function refreshUniformsSprites(uniforms, material) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
        uniforms.rotation.value = material.rotation;
        if (material.map) uniforms.map.value = material.map;
        if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
        // uv repeat and offset setting priorities
        // 1. color map
        // 2. alpha map
        let uvScaleMap;
        if (material.map) uvScaleMap = material.map;
        else if (material.alphaMap) uvScaleMap = material.alphaMap;
        if (uvScaleMap !== undefined) {
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
    }
    function refreshUniformsLambert(uniforms, material) {
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
    }
    function refreshUniformsPhong(uniforms, material) {
        uniforms.specular.value.copy(material.specular);
        uniforms.shininess.value = Math.max(material.shininess, 0.0001); // to prevent pow( 0.0, 0.0 )
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsToon(uniforms, material) {
        if (material.gradientMap) uniforms.gradientMap.value = material.gradientMap;
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsStandard(uniforms, material) {
        uniforms.roughness.value = material.roughness;
        uniforms.metalness.value = material.metalness;
        if (material.roughnessMap) uniforms.roughnessMap.value = material.roughnessMap;
        if (material.metalnessMap) uniforms.metalnessMap.value = material.metalnessMap;
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
        const envMap = properties.get(material).envMap;
        if (envMap) //uniforms.envMap.value = material.envMap; // part of uniforms common
        uniforms.envMapIntensity.value = material.envMapIntensity;
    }
    function refreshUniformsPhysical(uniforms, material) {
        refreshUniformsStandard(uniforms, material);
        uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common
        uniforms.clearcoat.value = material.clearcoat;
        uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
        if (material.sheen) uniforms.sheen.value.copy(material.sheen);
        if (material.clearcoatMap) uniforms.clearcoatMap.value = material.clearcoatMap;
        if (material.clearcoatRoughnessMap) uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        if (material.clearcoatNormalMap) {
            uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
            uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
            if (material.side === BackSide) uniforms.clearcoatNormalScale.value.negate();
        }
        uniforms.transmission.value = material.transmission;
        if (material.transmissionMap) uniforms.transmissionMap.value = material.transmissionMap;
    }
    function refreshUniformsMatcap(uniforms, material) {
        if (material.matcap) uniforms.matcap.value = material.matcap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsDepth(uniforms, material) {
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsDistance(uniforms, material) {
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
        uniforms.referencePosition.value.copy(material.referencePosition);
        uniforms.nearDistance.value = material.nearDistance;
        uniforms.farDistance.value = material.farDistance;
    }
    function refreshUniformsNormal(uniforms, material) {
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    return {
        refreshFogUniforms: refreshFogUniforms,
        refreshMaterialUniforms: refreshMaterialUniforms
    };
}
const WebGLMaterials1 = WebGLMaterials;
function WebGLRenderer(parameters) {
    parameters = parameters || {
    };
    const _canvas1 = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'), _context = parameters.context !== undefined ? parameters.context : null, _alpha = parameters.alpha !== undefined ? parameters.alpha : false, _depth = parameters.depth !== undefined ? parameters.depth : true, _stencil = parameters.stencil !== undefined ? parameters.stencil : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default', _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;
    let currentRenderList = null;
    let currentRenderState = null;
    // public properties
    this.domElement = _canvas1;
    // Debug configuration container
    this.debug = {
        /**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */
        checkShaderErrors: true
    };
    // clearing
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    // scene graph
    this.sortObjects = true;
    // user-defined clipping
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    // physically based shading
    this.gammaFactor = 2; // for backwards compatibility
    this.outputEncoding = LinearEncoding;
    // physical lights
    this.physicallyCorrectLights = false;
    // tone mapping
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    // morphs
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    // internal properties
    const _this = this;
    let _isContextLost = false;
    // internal state cache
    let _framebuffer = null;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentFramebuffer = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    let _currentArrayCamera = null;
    const _currentViewport = new Vector41();
    const _currentScissor = new Vector41();
    let _currentScissorTest = null;
    //
    let _width = _canvas1.width;
    let _height = _canvas1.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector41(0, 0, _width, _height);
    const _scissor = new Vector41(0, 0, _width, _height);
    let _scissorTest = false;
    // frustum
    const _frustum = new Frustum1();
    // clipping
    const _clipping = new WebGLClipping1();
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    // camera matrices cache
    const _projScreenMatrix = new Matrix41();
    const _vector31 = new Vector31();
    const _emptyScene = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: true
    };
    function getTargetPixelRatio() {
        return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    // initialize
    let _gl = _context;
    function getContext(contextNames, contextAttributes) {
        for(let i1 = 0; i1 < contextNames.length; i1++){
            const contextName = contextNames[i1];
            const context = _canvas1.getContext(contextName, contextAttributes);
            if (context !== null) return context;
        }
        return null;
    }
    try {
        const contextAttributes = {
            alpha: _alpha,
            depth: _depth,
            stencil: _stencil,
            antialias: _antialias,
            premultipliedAlpha: _premultipliedAlpha,
            preserveDrawingBuffer: _preserveDrawingBuffer,
            powerPreference: _powerPreference,
            failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
        };
        // event listeners must be registered before WebGL context is created, see #12753
        _canvas1.addEventListener('webglcontextlost', onContextLost, false);
        _canvas1.addEventListener('webglcontextrestored', onContextRestore, false);
        if (_gl === null) {
            const contextNames = [
                'webgl2',
                'webgl',
                'experimental-webgl'
            ];
            if (_this.isWebGL1Renderer === true) contextNames.shift();
            _gl = getContext(contextNames, contextAttributes);
            if (_gl === null) {
                if (getContext(contextNames)) throw new Error('Error creating WebGL context with your selected attributes.');
                else throw new Error('Error creating WebGL context.');
            }
        }
        // Some experimental-webgl implementations do not have getShaderPrecisionFormat
        if (_gl.getShaderPrecisionFormat === undefined) _gl.getShaderPrecisionFormat = function() {
            return {
                'rangeMin': 1,
                'rangeMax': 1,
                'precision': 1
            };
        };
    } catch (error) {
        console.error('THREE.WebGLRenderer: ' + error.message);
        throw error;
    }
    let extensions, capabilities, state, info;
    let properties, textures, cubemaps, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates;
    function initGLContext() {
        extensions = new WebGLExtensions1(_gl);
        capabilities = new WebGLCapabilities1(_gl, extensions, parameters);
        if (capabilities.isWebGL2 === false) {
            extensions.get('WEBGL_depth_texture');
            extensions.get('OES_texture_float');
            extensions.get('OES_texture_half_float');
            extensions.get('OES_texture_half_float_linear');
            extensions.get('OES_standard_derivatives');
            extensions.get('OES_element_index_uint');
            extensions.get('OES_vertex_array_object');
            extensions.get('ANGLE_instanced_arrays');
        }
        extensions.get('OES_texture_float_linear');
        utils = new WebGLUtils1(_gl, extensions, capabilities);
        state = new WebGLState1(_gl, extensions, capabilities);
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
        info = new WebGLInfo1(_gl);
        properties = new WebGLProperties1();
        textures = new WebGLTextures1(_gl, extensions, state, properties, capabilities, utils, info);
        cubemaps = new WebGLCubeMaps1(_this);
        attributes = new WebGLAttributes1(_gl, capabilities);
        bindingStates = new WebGLBindingStates1(_gl, extensions, attributes, capabilities);
        geometries = new WebGLGeometries1(_gl, attributes, info, bindingStates);
        objects = new WebGLObjects1(_gl, geometries, attributes, info);
        morphtargets = new WebGLMorphtargets1(_gl);
        programCache = new WebGLPrograms1(_this, cubemaps, extensions, capabilities, bindingStates);
        materials = new WebGLMaterials1(properties, cubemaps);
        renderLists = new WebGLRenderLists1(properties);
        renderStates = new WebGLRenderStates1();
        background = new WebGLBackground1(_this, cubemaps, state, objects, _premultipliedAlpha);
        bufferRenderer = new WebGLBufferRenderer1(_gl, extensions, info, capabilities);
        indexedBufferRenderer = new WebGLIndexedBufferRenderer1(_gl, extensions, info, capabilities);
        info.programs = programCache.programs;
        _this.capabilities = capabilities;
        _this.extensions = extensions;
        _this.properties = properties;
        _this.renderLists = renderLists;
        _this.state = state;
        _this.info = info;
    }
    initGLContext();
    // xr
    const xr = new WebXRManager1(_this, _gl);
    this.xr = xr;
    // shadow map
    const shadowMap = new WebGLShadowMap1(_this, objects, capabilities.maxTextureSize);
    this.shadowMap = shadowMap;
    // API
    this.getContext = function() {
        return _gl;
    };
    this.getContextAttributes = function() {
        return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
        const extension = extensions.get('WEBGL_lose_context');
        if (extension) extension.loseContext();
    };
    this.forceContextRestore = function() {
        const extension = extensions.get('WEBGL_lose_context');
        if (extension) extension.restoreContext();
    };
    this.getPixelRatio = function() {
        return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
        if (value === undefined) return;
        _pixelRatio = value;
        this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
        if (target === undefined) {
            console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');
            target = new Vector21();
        }
        return target.set(_width, _height);
    };
    this.setSize = function(width2, height2, updateStyle) {
        if (xr.isPresenting) {
            console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
            return;
        }
        _width = width2;
        _height = height2;
        _canvas1.width = Math.floor(width2 * _pixelRatio);
        _canvas1.height = Math.floor(height2 * _pixelRatio);
        if (updateStyle !== false) {
            _canvas1.style.width = width2 + 'px';
            _canvas1.style.height = height2 + 'px';
        }
        this.setViewport(0, 0, width2, height2);
    };
    this.getDrawingBufferSize = function(target) {
        if (target === undefined) {
            console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');
            target = new Vector21();
        }
        return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width2, height2, pixelRatio) {
        _width = width2;
        _height = height2;
        _pixelRatio = pixelRatio;
        _canvas1.width = Math.floor(width2 * pixelRatio);
        _canvas1.height = Math.floor(height2 * pixelRatio);
        this.setViewport(0, 0, width2, height2);
    };
    this.getCurrentViewport = function(target) {
        if (target === undefined) {
            console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');
            target = new Vector41();
        }
        return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
        return target.copy(_viewport);
    };
    this.setViewport = function(x6, y6, width2, height2) {
        if (x6.isVector4) _viewport.set(x6.x, x6.y, x6.z, x6.w);
        else _viewport.set(x6, y6, width2, height2);
        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissor = function(target) {
        return target.copy(_scissor);
    };
    this.setScissor = function(x6, y6, width2, height2) {
        if (x6.isVector4) _scissor.set(x6.x, x6.y, x6.z, x6.w);
        else _scissor.set(x6, y6, width2, height2);
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissorTest = function() {
        return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
        state.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
        _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
        _transparentSort = method;
    };
    // Clearing
    this.getClearColor = function() {
        return background.getClearColor();
    };
    this.setClearColor = function() {
        background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
        return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
        background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color1, depth1, stencil) {
        let bits = 0;
        if (color1 === undefined || color1) bits |= _gl.COLOR_BUFFER_BIT;
        if (depth1 === undefined || depth1) bits |= _gl.DEPTH_BUFFER_BIT;
        if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;
        _gl.clear(bits);
    };
    this.clearColor = function() {
        this.clear(true, false, false);
    };
    this.clearDepth = function() {
        this.clear(false, true, false);
    };
    this.clearStencil = function() {
        this.clear(false, false, true);
    };
    //
    this.dispose = function() {
        _canvas1.removeEventListener('webglcontextlost', onContextLost, false);
        _canvas1.removeEventListener('webglcontextrestored', onContextRestore, false);
        renderLists.dispose();
        renderStates.dispose();
        properties.dispose();
        cubemaps.dispose();
        objects.dispose();
        bindingStates.dispose();
        xr.dispose();
        animation.stop();
    };
    // Events
    function onContextLost(event) {
        event.preventDefault();
        console.log('THREE.WebGLRenderer: Context Lost.');
        _isContextLost = true;
    }
    function onContextRestore() {
        console.log('THREE.WebGLRenderer: Context Restored.');
        _isContextLost = false;
        initGLContext();
    }
    function onMaterialDispose(event) {
        const material = event.target;
        material.removeEventListener('dispose', onMaterialDispose);
        deallocateMaterial(material);
    }
    // Buffer deallocation
    function deallocateMaterial(material) {
        releaseMaterialProgramReference(material);
        properties.remove(material);
    }
    function releaseMaterialProgramReference(material) {
        const programInfo = properties.get(material).program;
        if (programInfo !== undefined) programCache.releaseProgram(programInfo);
    }
    // Buffer rendering
    function renderObjectImmediate(object, program) {
        object.render(function(object1) {
            _this.renderBufferImmediate(object1, program);
        });
    }
    this.renderBufferImmediate = function(object, program) {
        bindingStates.initAttributes();
        const buffers = properties.get(object);
        if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
        if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
        if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
        if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
        const programAttributes = program.getAttributes();
        if (object.hasPositions) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
            bindingStates.enableAttribute(programAttributes.position);
            _gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasNormals) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
            bindingStates.enableAttribute(programAttributes.normal);
            _gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasUvs) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
            bindingStates.enableAttribute(programAttributes.uv);
            _gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasColors) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
            bindingStates.enableAttribute(programAttributes.color);
            _gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0);
        }
        bindingStates.disableUnusedAttributes();
        _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
        object.count = 0;
    };
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
        if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)
        const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
        const program = setProgram(camera, scene, material, object);
        state.setMaterial(material, frontFaceCW);
        //
        let index = geometry.index;
        const position = geometry.attributes.position;
        //
        if (index === null) {
            if (position === undefined || position.count === 0) return;
        } else if (index.count === 0) return;
        //
        let rangeFactor = 1;
        if (material.wireframe === true) {
            index = geometries.getWireframeAttribute(geometry);
            rangeFactor = 2;
        }
        if (material.morphTargets || material.morphNormals) morphtargets.update(object, geometry, material, program);
        bindingStates.setup(object, material, program, geometry, index);
        let attribute;
        let renderer = bufferRenderer;
        if (index !== null) {
            attribute = attributes.get(index);
            renderer = indexedBufferRenderer;
            renderer.setIndex(attribute);
        }
        //
        const dataCount = index !== null ? index.count : position.count;
        const rangeStart = geometry.drawRange.start * rangeFactor;
        const rangeCount = geometry.drawRange.count * rangeFactor;
        const groupStart1 = group !== null ? group.start * rangeFactor : 0;
        const groupCount = group !== null ? group.count * rangeFactor : Infinity;
        const drawStart = Math.max(rangeStart, groupStart1);
        const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart1 + groupCount) - 1;
        const drawCount = Math.max(0, drawEnd - drawStart + 1);
        if (drawCount === 0) return;
        //
        if (object.isMesh) {
            if (material.wireframe === true) {
                state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                renderer.setMode(_gl.LINES);
            } else renderer.setMode(_gl.TRIANGLES);
        } else if (object.isLine) {
            let lineWidth = material.linewidth;
            if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material
            state.setLineWidth(lineWidth * getTargetPixelRatio());
            if (object.isLineSegments) renderer.setMode(_gl.LINES);
            else if (object.isLineLoop) renderer.setMode(_gl.LINE_LOOP);
            else renderer.setMode(_gl.LINE_STRIP);
        } else if (object.isPoints) renderer.setMode(_gl.POINTS);
        else if (object.isSprite) renderer.setMode(_gl.TRIANGLES);
        if (object.isInstancedMesh) renderer.renderInstances(drawStart, drawCount, object.count);
        else if (geometry.isInstancedBufferGeometry) {
            const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
            renderer.renderInstances(drawStart, drawCount, instanceCount);
        } else renderer.render(drawStart, drawCount);
    };
    // Compile
    this.compile = function(scene, camera) {
        currentRenderState = renderStates.get(scene, camera);
        currentRenderState.init();
        scene.traverse(function(object) {
            if (object.isLight) {
                currentRenderState.pushLight(object);
                if (object.castShadow) currentRenderState.pushShadow(object);
            }
        });
        currentRenderState.setupLights(camera);
        const compiled = new WeakMap();
        scene.traverse(function(object) {
            const material = object.material;
            if (material) {
                if (Array.isArray(material)) for(let i1 = 0; i1 < material.length; i1++){
                    const material2 = material[i1];
                    if (compiled.has(material2) === false) {
                        initMaterial(material2, scene, object);
                        compiled.set(material2);
                    }
                }
                else if (compiled.has(material) === false) {
                    initMaterial(material, scene, object);
                    compiled.set(material);
                }
            }
        });
    };
    // Animation Loop
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
        if (xr.isPresenting) return;
        if (onAnimationFrameCallback) onAnimationFrameCallback(time);
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof window !== 'undefined') animation.setContext(window);
    this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
        xr.setAnimationLoop(callback);
        callback === null ? animation.stop() : animation.start();
    };
    // Rendering
    this.render = function(scene, camera) {
        let renderTarget, forceClear;
        if (arguments[2] !== undefined) {
            console.warn('THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');
            renderTarget = arguments[2];
        }
        if (arguments[3] !== undefined) {
            console.warn('THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.');
            forceClear = arguments[3];
        }
        if (camera !== undefined && camera.isCamera !== true) {
            console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
            return;
        }
        if (_isContextLost === true) return;
        // reset caching for this frame
        bindingStates.resetDefaultState();
        _currentMaterialId = -1;
        _currentCamera = null;
        // update scene graph
        if (scene.autoUpdate === true) scene.updateMatrixWorld();
        // update camera matrices and frustum
        if (camera.parent === null) camera.updateMatrixWorld();
        if (xr.enabled === true && xr.isPresenting === true) camera = xr.getCamera(camera);
        //
        if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
        currentRenderState = renderStates.get(scene, camera);
        currentRenderState.init();
        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        _frustum.setFromProjectionMatrix(_projScreenMatrix);
        _localClippingEnabled = this.localClippingEnabled;
        _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
        currentRenderList = renderLists.get(scene, camera);
        currentRenderList.init();
        projectObject(scene, camera, 0, _this.sortObjects);
        currentRenderList.finish();
        if (_this.sortObjects === true) currentRenderList.sort(_opaqueSort, _transparentSort);
        //
        if (_clippingEnabled === true) _clipping.beginShadows();
        const shadowsArray = currentRenderState.state.shadowsArray;
        shadowMap.render(shadowsArray, scene, camera);
        currentRenderState.setupLights(camera);
        if (_clippingEnabled === true) _clipping.endShadows();
        //
        if (this.info.autoReset === true) this.info.reset();
        if (renderTarget !== undefined) this.setRenderTarget(renderTarget);
        //
        background.render(currentRenderList, scene, camera, forceClear);
        // render scene
        const opaqueObjects = currentRenderList.opaque;
        const transparentObjects = currentRenderList.transparent;
        if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
        if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);
        //
        if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);
        //
        if (_currentRenderTarget !== null) {
            // Generate mipmap if we're using any kind of mipmap filtering
            textures.updateRenderTargetMipmap(_currentRenderTarget);
            // resolve multisample renderbuffers to a single-sample texture if necessary
            textures.updateMultisampleRenderTarget(_currentRenderTarget);
        }
        // Ensure depth buffer writing is enabled so it can be cleared on next render
        state.buffers.depth.setTest(true);
        state.buffers.depth.setMask(true);
        state.buffers.color.setMask(true);
        state.setPolygonOffset(false);
        // _gl.finish();
        currentRenderList = null;
        currentRenderState = null;
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
        if (object.visible === false) return;
        const visible = object.layers.test(camera.layers);
        if (visible) {
            if (object.isGroup) groupOrder = object.renderOrder;
            else if (object.isLOD) {
                if (object.autoUpdate === true) object.update(camera);
            } else if (object.isLight) {
                currentRenderState.pushLight(object);
                if (object.castShadow) currentRenderState.pushShadow(object);
            } else if (object.isSprite) {
                if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                    if (sortObjects) _vector31.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    const geometry = objects.update(object);
                    const material = object.material;
                    if (material.visible) currentRenderList.push(object, geometry, material, groupOrder, _vector31.z, null);
                }
            } else if (object.isImmediateRenderObject) {
                if (sortObjects) _vector31.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                currentRenderList.push(object, null, object.material, groupOrder, _vector31.z, null);
            } else if (object.isMesh || object.isLine || object.isPoints) {
                if (object.isSkinnedMesh) // update skeleton only once in a frame
                {
                    if (object.skeleton.frame !== info.render.frame) {
                        object.skeleton.update();
                        object.skeleton.frame = info.render.frame;
                    }
                }
                if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                    if (sortObjects) _vector31.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    const geometry = objects.update(object);
                    const material = object.material;
                    if (Array.isArray(material)) {
                        const groups = geometry.groups;
                        for(let i1 = 0, l = groups.length; i1 < l; i1++){
                            const group = groups[i1];
                            const groupMaterial = material[group.materialIndex];
                            if (groupMaterial && groupMaterial.visible) currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector31.z, group);
                        }
                    } else if (material.visible) currentRenderList.push(object, geometry, material, groupOrder, _vector31.z, null);
                }
            }
        }
        const children = object.children;
        for(let i1 = 0, l = children.length; i1 < l; i1++)projectObject(children[i1], camera, groupOrder, sortObjects);
    }
    function renderObjects(renderList, scene, camera) {
        const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
        for(let i1 = 0, l = renderList.length; i1 < l; i1++){
            const renderItem = renderList[i1];
            const object = renderItem.object;
            const geometry = renderItem.geometry;
            const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
            const group = renderItem.group;
            if (camera.isArrayCamera) {
                _currentArrayCamera = camera;
                const cameras = camera.cameras;
                for(let j = 0, jl = cameras.length; j < jl; j++){
                    const camera2 = cameras[j];
                    if (object.layers.test(camera2.layers)) {
                        state.viewport(_currentViewport.copy(camera2.viewport));
                        currentRenderState.setupLights(camera2);
                        renderObject(object, scene, camera2, geometry, material, group);
                    }
                }
            } else {
                _currentArrayCamera = null;
                renderObject(object, scene, camera, geometry, material, group);
            }
        }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
        object.onBeforeRender(_this, scene, camera, geometry, material, group);
        currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
        if (object.isImmediateRenderObject) {
            const program = setProgram(camera, scene, material, object);
            state.setMaterial(material);
            bindingStates.reset();
            renderObjectImmediate(object, program);
        } else _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        object.onAfterRender(_this, scene, camera, geometry, material, group);
        currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
    }
    function initMaterial(material, scene, object) {
        if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...
        const materialProperties = properties.get(material);
        const lights = currentRenderState.state.lights;
        const shadowsArray = currentRenderState.state.shadowsArray;
        const lightsStateVersion = lights.state.version;
        const parameters1 = programCache.getParameters(material, lights.state, shadowsArray, scene, _clipping.numPlanes, _clipping.numIntersection, object);
        const programCacheKey = programCache.getProgramCacheKey(parameters1);
        let program = materialProperties.program;
        let programChange = true;
        if (program === undefined) // new material
        material.addEventListener('dispose', onMaterialDispose);
        else if (program.cacheKey !== programCacheKey) // changed glsl or parameters
        releaseMaterialProgramReference(material);
        else if (materialProperties.lightsStateVersion !== lightsStateVersion) {
            materialProperties.lightsStateVersion = lightsStateVersion;
            programChange = false;
        } else if (parameters1.shaderID !== undefined) // same glsl and uniform list
        return;
        else // only rebuild uniform list
        programChange = false;
        if (programChange) {
            parameters1.uniforms = programCache.getUniforms(material, parameters1);
            material.onBeforeCompile(parameters1, _this);
            program = programCache.acquireProgram(parameters1, programCacheKey);
            materialProperties.program = program;
            materialProperties.uniforms = parameters1.uniforms;
            materialProperties.outputEncoding = parameters1.outputEncoding;
        }
        const programAttributes = program.getAttributes();
        if (material.morphTargets) {
            material.numSupportedMorphTargets = 0;
            for(let i1 = 0; i1 < _this.maxMorphTargets; i1++)if (programAttributes['morphTarget' + i1] >= 0) material.numSupportedMorphTargets++;
        }
        if (material.morphNormals) {
            material.numSupportedMorphNormals = 0;
            for(let i1 = 0; i1 < _this.maxMorphNormals; i1++)if (programAttributes['morphNormal' + i1] >= 0) material.numSupportedMorphNormals++;
        }
        const uniforms = materialProperties.uniforms;
        if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
            materialProperties.numClippingPlanes = _clipping.numPlanes;
            materialProperties.numIntersection = _clipping.numIntersection;
            uniforms.clippingPlanes = _clipping.uniform;
        }
        materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
        materialProperties.fog = scene.fog;
        materialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);
        // store the light setup it was created for
        materialProperties.needsLights = materialNeedsLights(material);
        materialProperties.lightsStateVersion = lightsStateVersion;
        if (materialProperties.needsLights) {
            // wire up the material to this renderer's lighting state
            uniforms.ambientLightColor.value = lights.state.ambient;
            uniforms.lightProbe.value = lights.state.probe;
            uniforms.directionalLights.value = lights.state.directional;
            uniforms.directionalLightShadows.value = lights.state.directionalShadow;
            uniforms.spotLights.value = lights.state.spot;
            uniforms.spotLightShadows.value = lights.state.spotShadow;
            uniforms.rectAreaLights.value = lights.state.rectArea;
            uniforms.pointLights.value = lights.state.point;
            uniforms.pointLightShadows.value = lights.state.pointShadow;
            uniforms.hemisphereLights.value = lights.state.hemi;
            uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
            uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
            uniforms.spotShadowMap.value = lights.state.spotShadowMap;
            uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
            uniforms.pointShadowMap.value = lights.state.pointShadowMap;
            uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
        }
        const progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms1.seqWithValue(progUniforms.seq, uniforms);
        materialProperties.uniformsList = uniformsList;
    }
    function setProgram(camera, scene, material, object) {
        if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...
        textures.resetTextureUnits();
        const fog = scene.fog;
        const environment = material.isMeshStandardMaterial ? scene.environment : null;
        const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
        const envMap = cubemaps.get(material.envMap || environment);
        const materialProperties = properties.get(material);
        const lights = currentRenderState.state.lights;
        if (_clippingEnabled === true) {
            if (_localClippingEnabled === true || camera !== _currentCamera) {
                const useCache = camera === _currentCamera && material.id === _currentMaterialId;
                // we might want to call this function with some ClippingGroup
                // object instead of the material, once it becomes feasible
                // (#8465, #8379)
                _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
            }
        }
        if (material.version === materialProperties.__version) {
            if (materialProperties.program === undefined) initMaterial(material, scene, object);
            else if (material.fog && materialProperties.fog !== fog) initMaterial(material, scene, object);
            else if (materialProperties.environment !== environment) initMaterial(material, scene, object);
            else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) initMaterial(material, scene, object);
            else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) initMaterial(material, scene, object);
            else if (materialProperties.outputEncoding !== encoding) initMaterial(material, scene, object);
            else if (materialProperties.envMap !== envMap) initMaterial(material, scene, object);
        } else {
            initMaterial(material, scene, object);
            materialProperties.__version = material.version;
        }
        let refreshProgram = false;
        let refreshMaterial = false;
        let refreshLights = false;
        const program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
        if (state.useProgram(program.program)) {
            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;
        }
        if (material.id !== _currentMaterialId) {
            _currentMaterialId = material.id;
            refreshMaterial = true;
        }
        if (refreshProgram || _currentCamera !== camera) {
            p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);
            if (capabilities.logarithmicDepthBuffer) p_uniforms.setValue(_gl, 'logDepthBufFC', 2 / (Math.log(camera.far + 1) / Math.LN2));
            if (_currentCamera !== camera) {
                _currentCamera = camera;
                // lighting uniforms depend on the camera so enforce an update
                // now, in case this material supports lights - or later, when
                // the next material that does gets activated:
                refreshMaterial = true; // set to true on material change
                refreshLights = true; // remains set until update done
            }
            // load material specific uniforms
            // (shader material also gets them for the sake of genericity)
            if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
                const uCamPos = p_uniforms.map.cameraPosition;
                if (uCamPos !== undefined) uCamPos.setValue(_gl, _vector31.setFromMatrixPosition(camera.matrixWorld));
            }
            if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
            if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
        }
        // skinning uniforms must be set even if material didn't change
        // auto-setting of texture unit for bone texture must go before other textures
        // otherwise textures used for skinning can take over texture units reserved for other material textures
        if (material.skinning) {
            p_uniforms.setOptional(_gl, object, 'bindMatrix');
            p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
            const skeleton = object.skeleton;
            if (skeleton) {
                const bones = skeleton.bones;
                if (capabilities.floatVertexTextures) {
                    if (skeleton.boneTexture === undefined) {
                        // layout (1 matrix = 4 pixels)
                        //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
                        //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
                        //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
                        //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
                        //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
                        let size = Math.sqrt(bones.length * 4); // 4 pixels needed for 1 matrix
                        size = MathUtils1.ceilPowerOfTwo(size);
                        size = Math.max(size, 4);
                        const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
                        boneMatrices.set(skeleton.boneMatrices); // copy current values
                        const boneTexture = new DataTexture1(boneMatrices, size, size, RGBAFormat, FloatType);
                        skeleton.boneMatrices = boneMatrices;
                        skeleton.boneTexture = boneTexture;
                        skeleton.boneTextureSize = size;
                    }
                    p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
                    p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
                } else p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
            }
        }
        if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
            materialProperties.receiveShadow = object.receiveShadow;
            p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
        }
        if (refreshMaterial) {
            p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
            if (materialProperties.needsLights) // the current material requires lighting info
            // note: all lighting uniforms are always set correctly
            // they simply reference the renderer's state for their
            // values
            //
            // use the current material's .needsUpdate flags to set
            // the GL state when required
            markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
            // refresh uniforms common to several materials
            if (fog && material.fog) materials.refreshFogUniforms(m_uniforms, fog);
            materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height);
            // RectAreaLight Texture
            // TODO (mrdoob): Find a nicer implementation
            if (m_uniforms.ltc_1 !== undefined) m_uniforms.ltc_1.value = UniformsLib1.LTC_1;
            if (m_uniforms.ltc_2 !== undefined) m_uniforms.ltc_2.value = UniformsLib1.LTC_2;
            WebGLUniforms1.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
        }
        if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
            WebGLUniforms1.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
            material.uniformsNeedUpdate = false;
        }
        if (material.isSpriteMaterial) p_uniforms.setValue(_gl, 'center', object.center);
        // common matrices
        p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
        p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
        p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
        return program;
    }
    // If uniforms are marked as clean, they don't need to be loaded to the GPU.
    function markUniformsLightsNeedsUpdate(uniforms, value) {
        uniforms.ambientLightColor.needsUpdate = value;
        uniforms.lightProbe.needsUpdate = value;
        uniforms.directionalLights.needsUpdate = value;
        uniforms.directionalLightShadows.needsUpdate = value;
        uniforms.pointLights.needsUpdate = value;
        uniforms.pointLightShadows.needsUpdate = value;
        uniforms.spotLights.needsUpdate = value;
        uniforms.spotLightShadows.needsUpdate = value;
        uniforms.rectAreaLights.needsUpdate = value;
        uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
        return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    //
    this.setFramebuffer = function(value) {
        if (_framebuffer !== value && _currentRenderTarget === null) _gl.bindFramebuffer(_gl.FRAMEBUFFER, value);
        _framebuffer = value;
    };
    this.getActiveCubeFace = function() {
        return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
        return _currentActiveMipmapLevel;
    };
    this.getRenderList = function() {
        return currentRenderList;
    };
    this.setRenderList = function(renderList) {
        currentRenderList = renderList;
    };
    this.getRenderState = function() {
        return currentRenderState;
    };
    this.setRenderState = function(renderState) {
        currentRenderState = renderState;
    };
    this.getRenderTarget = function() {
        return _currentRenderTarget;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace, activeMipmapLevel) {
        _currentRenderTarget = renderTarget;
        _currentActiveCubeFace = activeCubeFace;
        _currentActiveMipmapLevel = activeMipmapLevel;
        if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) textures.setupRenderTarget(renderTarget);
        let framebuffer = _framebuffer;
        let isCube = false;
        if (renderTarget) {
            const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (renderTarget.isWebGLCubeRenderTarget) {
                framebuffer = __webglFramebuffer[activeCubeFace || 0];
                isCube = true;
            } else if (renderTarget.isWebGLMultisampleRenderTarget) framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
            else framebuffer = __webglFramebuffer;
            _currentViewport.copy(renderTarget.viewport);
            _currentScissor.copy(renderTarget.scissor);
            _currentScissorTest = renderTarget.scissorTest;
        } else {
            _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
            _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
            _currentScissorTest = _scissorTest;
        }
        if (_currentFramebuffer !== framebuffer) {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            _currentFramebuffer = framebuffer;
        }
        state.viewport(_currentViewport);
        state.scissor(_currentScissor);
        state.setScissorTest(_currentScissorTest);
        if (isCube) {
            const textureProperties = properties.get(renderTarget.texture);
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + (activeCubeFace || 0), textureProperties.__webglTexture, activeMipmapLevel || 0);
        }
    };
    this.readRenderTargetPixels = function(renderTarget, x6, y6, width2, height2, buffer, activeCubeFaceIndex) {
        if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
            return;
        }
        let framebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) framebuffer = framebuffer[activeCubeFaceIndex];
        if (framebuffer) {
            let restore = false;
            if (framebuffer !== _currentFramebuffer) {
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                restore = true;
            }
            try {
                const texture = renderTarget.texture;
                const textureFormat = texture.format;
                const textureType = texture.type;
                if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                    return;
                }
                if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) && !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get('EXT_color_buffer_float') : extensions.get('EXT_color_buffer_half_float')))) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                    return;
                }
                if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
                {
                    if (x6 >= 0 && x6 <= renderTarget.width - width2 && (y6 >= 0 && y6 <= renderTarget.height - height2)) _gl.readPixels(x6, y6, width2, height2, utils.convert(textureFormat), utils.convert(textureType), buffer);
                } else console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
            } finally{
                if (restore) _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
            }
        }
    };
    this.copyFramebufferToTexture = function(position, texture, level) {
        if (level === undefined) level = 0;
        const levelScale = Math.pow(2, -level);
        const width2 = Math.floor(texture.image.width * levelScale);
        const height2 = Math.floor(texture.image.height * levelScale);
        const glFormat = utils.convert(texture.format);
        textures.setTexture2D(texture, 0);
        _gl.copyTexImage2D(_gl.TEXTURE_2D, level, glFormat, position.x, position.y, width2, height2, 0);
        state.unbindTexture();
    };
    this.copyTextureToTexture = function(position, srcTexture, dstTexture, level) {
        if (level === undefined) level = 0;
        const width2 = srcTexture.image.width;
        const height2 = srcTexture.image.height;
        const glFormat = utils.convert(dstTexture.format);
        const glType = utils.convert(dstTexture.type);
        textures.setTexture2D(dstTexture, 0);
        // As another texture upload may have changed pixelStorei
        // parameters, make sure they are correct for the dstTexture
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
        if (srcTexture.isDataTexture) _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width2, height2, glFormat, glType, srcTexture.image.data);
        else if (srcTexture.isCompressedTexture) _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
        else _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);
        // Generate mipmaps only when copying level 0
        if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);
        state.unbindTexture();
    };
    this.initTexture = function(texture) {
        textures.setTexture2D(texture, 0);
        state.unbindTexture();
    };
    if (typeof __THREE_DEVTOOLS__ !== 'undefined') __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
        detail: this
    })); // eslint-disable-line no-undef
}
const WebGLRenderer1 = WebGLRenderer;
export { WebGLRenderer1 as WebGLRenderer };
import { WebGLAnimation } from './webgl/WebGLAnimation.js';
function WebGLAttributes2(gl, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    const buffers = new WeakMap();
    function createBuffer(attribute, bufferType) {
        const array = attribute.array;
        const usage = attribute.usage;
        const buffer = gl.createBuffer();
        gl.bindBuffer(bufferType, buffer);
        gl.bufferData(bufferType, array, usage);
        attribute.onUploadCallback();
        let type = gl.FLOAT;
        if (array instanceof Float32Array) type = gl.FLOAT;
        else if (array instanceof Float64Array) console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
        else if (array instanceof Uint16Array) type = gl.UNSIGNED_SHORT;
        else if (array instanceof Int16Array) type = gl.SHORT;
        else if (array instanceof Uint32Array) type = gl.UNSIGNED_INT;
        else if (array instanceof Int32Array) type = gl.INT;
        else if (array instanceof Int8Array) type = gl.BYTE;
        else if (array instanceof Uint8Array) type = gl.UNSIGNED_BYTE;
        return {
            buffer: buffer,
            type: type,
            bytesPerElement: array.BYTES_PER_ELEMENT,
            version: attribute.version
        };
    }
    function updateBuffer(buffer, attribute, bufferType) {
        const array = attribute.array;
        const updateRange = attribute.updateRange;
        gl.bindBuffer(bufferType, buffer);
        if (updateRange.count === -1) gl.bufferSubData(bufferType, 0, array);
        else {
            if (isWebGL2) gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
            else gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
            updateRange.count = -1;
        }
    }
    function get(attribute) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        return buffers.get(attribute);
    }
    function remove(attribute) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        const data = buffers.get(attribute);
        if (data) {
            gl.deleteBuffer(data.buffer);
            buffers.delete(attribute);
        }
    }
    function update(attribute, bufferType) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        const data = buffers.get(attribute);
        if (data === undefined) buffers.set(attribute, createBuffer(attribute, bufferType));
        else if (data.version < attribute.version) {
            updateBuffer(data.buffer, attribute, bufferType);
            data.version = attribute.version;
        }
    }
    return {
        get: get,
        remove: remove,
        update: update
    };
}
const WebGLAttributes1 = WebGLAttributes2;
function WebGLBackground2(renderer, cubemaps, state, objects, premultipliedAlpha) {
    const clearColor = new Color1(0);
    let clearAlpha = 0;
    let planeMesh;
    let boxMesh;
    let currentBackground = null;
    let currentBackgroundVersion = 0;
    let currentTonemapping = null;
    function render(renderList, scene, camera, forceClear) {
        let background = scene.isScene === true ? scene.background : null;
        if (background && background.isTexture) background = cubemaps.get(background);
        const xr = renderer.xr;
        const session = xr.getSession && xr.getSession();
        if (session && session.environmentBlendMode === 'additive') background = null;
        if (background === null) setClear(clearColor, clearAlpha);
        else if (background && background.isColor) {
            setClear(background, 1);
            forceClear = true;
        }
        if (renderer.autoClear || forceClear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
        if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.isWebGLCubeRenderTargetTexture || background.mapping === CubeUVReflectionMapping)) {
            if (boxMesh === undefined) {
                boxMesh = new Mesh1(new BoxBufferGeometry1(1, 1, 1), new ShaderMaterial1({
                    name: 'BackgroundCubeMaterial',
                    uniforms: cloneUniforms(ShaderLib1.cube.uniforms),
                    vertexShader: ShaderLib1.cube.vertexShader,
                    fragmentShader: ShaderLib1.cube.fragmentShader,
                    side: BackSide,
                    depthTest: false,
                    depthWrite: false,
                    fog: false
                }));
                boxMesh.geometry.deleteAttribute('normal');
                boxMesh.geometry.deleteAttribute('uv');
                boxMesh.onBeforeRender = function(renderer1, scene1, camera1) {
                    this.matrixWorld.copyPosition(camera1.matrixWorld);
                };
                Object.defineProperty(boxMesh.material, 'envMap', {
                    get: function() {
                        return this.uniforms.envMap.value;
                    }
                });
                objects.update(boxMesh);
            }
            if (background.isWebGLCubeRenderTarget) background = background.texture;
            boxMesh.material.uniforms.envMap.value = background;
            boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture ? -1 : 1;
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                boxMesh.material.needsUpdate = true;
                currentBackground = background;
                currentBackgroundVersion = background.version;
                currentTonemapping = renderer.toneMapping;
            }
            renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
        } else if (background && background.isTexture) {
            if (planeMesh === undefined) {
                planeMesh = new Mesh1(new PlaneBufferGeometry1(2, 2), new ShaderMaterial1({
                    name: 'BackgroundMaterial',
                    uniforms: cloneUniforms(ShaderLib1.background.uniforms),
                    vertexShader: ShaderLib1.background.vertexShader,
                    fragmentShader: ShaderLib1.background.fragmentShader,
                    side: FrontSide,
                    depthTest: false,
                    depthWrite: false,
                    fog: false
                }));
                planeMesh.geometry.deleteAttribute('normal');
                Object.defineProperty(planeMesh.material, 'map', {
                    get: function() {
                        return this.uniforms.t2D.value;
                    }
                });
                objects.update(planeMesh);
            }
            planeMesh.material.uniforms.t2D.value = background;
            if (background.matrixAutoUpdate === true) background.updateMatrix();
            planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                planeMesh.material.needsUpdate = true;
                currentBackground = background;
                currentBackgroundVersion = background.version;
                currentTonemapping = renderer.toneMapping;
            }
            renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
        }
    }
    function setClear(color1, alpha) {
        state.buffers.color.setClear(color1.r, color1.g, color1.b, alpha, premultipliedAlpha);
    }
    return {
        getClearColor: function() {
            return clearColor;
        },
        setClearColor: function(color1, alpha) {
            clearColor.set(color1);
            clearAlpha = alpha !== undefined ? alpha : 1;
            setClear(clearColor, clearAlpha);
        },
        getClearAlpha: function() {
            return clearAlpha;
        },
        setClearAlpha: function(alpha) {
            clearAlpha = alpha;
            setClear(clearColor, clearAlpha);
        },
        render: render
    };
}
const WebGLBackground1 = WebGLBackground2;
function WebGLBindingStates2(gl, extensions, attributes, capabilities) {
    const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    const extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
    const vaoAvailable = capabilities.isWebGL2 || extension !== null;
    const bindingStates = {
    };
    const defaultState = createBindingState(null);
    let currentState = defaultState;
    function setup(object, material, program, geometry, index) {
        let updateBuffers = false;
        if (vaoAvailable) {
            const state = getBindingState(geometry, program, material);
            if (currentState !== state) {
                currentState = state;
                bindVertexArrayObject(currentState.object);
            }
            updateBuffers = needsUpdate(geometry, index);
            if (updateBuffers) saveCache(geometry, index);
        } else {
            const wireframe = material.wireframe === true;
            if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
                currentState.geometry = geometry.id;
                currentState.program = program.id;
                currentState.wireframe = wireframe;
                updateBuffers = true;
            }
        }
        if (object.isInstancedMesh === true) updateBuffers = true;
        if (index !== null) attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
        if (updateBuffers) {
            setupVertexAttributes(object, material, program, geometry);
            if (index !== null) gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
        }
    }
    function createVertexArrayObject() {
        if (capabilities.isWebGL2) return gl.createVertexArray();
        return extension.createVertexArrayOES();
    }
    function bindVertexArrayObject(vao) {
        if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
        return extension.bindVertexArrayOES(vao);
    }
    function deleteVertexArrayObject(vao) {
        if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
        return extension.deleteVertexArrayOES(vao);
    }
    function getBindingState(geometry, program, material) {
        const wireframe = material.wireframe === true;
        let programMap = bindingStates[geometry.id];
        if (programMap === undefined) {
            programMap = {
            };
            bindingStates[geometry.id] = programMap;
        }
        let stateMap = programMap[program.id];
        if (stateMap === undefined) {
            stateMap = {
            };
            programMap[program.id] = stateMap;
        }
        let state = stateMap[wireframe];
        if (state === undefined) {
            state = createBindingState(createVertexArrayObject());
            stateMap[wireframe] = state;
        }
        return state;
    }
    function createBindingState(vao) {
        const newAttributes = [];
        const enabledAttributes = [];
        const attributeDivisors = [];
        for(let i1 = 0; i1 < maxVertexAttributes; i1++){
            newAttributes[i1] = 0;
            enabledAttributes[i1] = 0;
            attributeDivisors[i1] = 0;
        }
        return {
            geometry: null,
            program: null,
            wireframe: false,
            newAttributes: newAttributes,
            enabledAttributes: enabledAttributes,
            attributeDivisors: attributeDivisors,
            object: vao,
            attributes: {
            },
            index: null
        };
    }
    function needsUpdate(geometry, index) {
        const cachedAttributes = currentState.attributes;
        const geometryAttributes = geometry.attributes;
        if (Object.keys(cachedAttributes).length !== Object.keys(geometryAttributes).length) return true;
        for(const key in geometryAttributes){
            const cachedAttribute = cachedAttributes[key];
            const geometryAttribute = geometryAttributes[key];
            if (cachedAttribute === undefined) return true;
            if (cachedAttribute.attribute !== geometryAttribute) return true;
            if (cachedAttribute.data !== geometryAttribute.data) return true;
        }
        if (currentState.index !== index) return true;
        return false;
    }
    function saveCache(geometry, index) {
        const cache = {
        };
        const attributes1 = geometry.attributes;
        for(const key in attributes1){
            const attribute = attributes1[key];
            const data = {
            };
            data.attribute = attribute;
            if (attribute.data) data.data = attribute.data;
            cache[key] = data;
        }
        currentState.attributes = cache;
        currentState.index = index;
    }
    function initAttributes() {
        const newAttributes = currentState.newAttributes;
        for(let i1 = 0, il = newAttributes.length; i1 < il; i1++)newAttributes[i1] = 0;
    }
    function enableAttribute(attribute) {
        enableAttributeAndDivisor(attribute, 0);
    }
    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
        const newAttributes = currentState.newAttributes;
        const enabledAttributes = currentState.enabledAttributes;
        const attributeDivisors = currentState.attributeDivisors;
        newAttributes[attribute] = 1;
        if (enabledAttributes[attribute] === 0) {
            gl.enableVertexAttribArray(attribute);
            enabledAttributes[attribute] = 1;
        }
        if (attributeDivisors[attribute] !== meshPerAttribute) {
            const extension1 = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
            extension1[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
            attributeDivisors[attribute] = meshPerAttribute;
        }
    }
    function disableUnusedAttributes() {
        const newAttributes = currentState.newAttributes;
        const enabledAttributes = currentState.enabledAttributes;
        for(let i1 = 0, il = enabledAttributes.length; i1 < il; i1++)if (enabledAttributes[i1] !== newAttributes[i1]) {
            gl.disableVertexAttribArray(i1);
            enabledAttributes[i1] = 0;
        }
    }
    function vertexAttribPointer(index, size, type, normalized, stride, offset) {
        if (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) gl.vertexAttribIPointer(index, size, type, stride, offset);
        else gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
    function setupVertexAttributes(object, material, program, geometry) {
        if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
            if (extensions.get('ANGLE_instanced_arrays') === null) return;
        }
        initAttributes();
        const geometryAttributes = geometry.attributes;
        const programAttributes = program.getAttributes();
        const materialDefaultAttributeValues = material.defaultAttributeValues;
        for(const name in programAttributes){
            const programAttribute = programAttributes[name];
            if (programAttribute >= 0) {
                const geometryAttribute = geometryAttributes[name];
                if (geometryAttribute !== undefined) {
                    const normalized = geometryAttribute.normalized;
                    const size = geometryAttribute.itemSize;
                    const attribute = attributes.get(geometryAttribute);
                    if (attribute === undefined) continue;
                    const buffer = attribute.buffer;
                    const type = attribute.type;
                    const bytesPerElement = attribute.bytesPerElement;
                    if (geometryAttribute.isInterleavedBufferAttribute) {
                        const data = geometryAttribute.data;
                        const stride = data.stride;
                        const offset = geometryAttribute.offset;
                        if (data && data.isInstancedInterleavedBuffer) {
                            enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
                            if (geometry._maxInstanceCount === undefined) geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                        } else enableAttribute(programAttribute);
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                        vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
                    } else {
                        if (geometryAttribute.isInstancedBufferAttribute) {
                            enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
                            if (geometry._maxInstanceCount === undefined) geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                        } else enableAttribute(programAttribute);
                        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                        vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
                    }
                } else if (name === 'instanceMatrix') {
                    const attribute = attributes.get(object.instanceMatrix);
                    if (attribute === undefined) continue;
                    const buffer = attribute.buffer;
                    const type = attribute.type;
                    enableAttributeAndDivisor(programAttribute + 0, 1);
                    enableAttributeAndDivisor(programAttribute + 1, 1);
                    enableAttributeAndDivisor(programAttribute + 2, 1);
                    enableAttributeAndDivisor(programAttribute + 3, 1);
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
                    gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
                    gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
                    gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
                } else if (name === 'instanceColor') {
                    const attribute = attributes.get(object.instanceColor);
                    if (attribute === undefined) continue;
                    const buffer = attribute.buffer;
                    const type = attribute.type;
                    enableAttributeAndDivisor(programAttribute, 1);
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);
                } else if (materialDefaultAttributeValues !== undefined) {
                    const value = materialDefaultAttributeValues[name];
                    if (value !== undefined) switch(value.length){
                        case 2:
                            gl.vertexAttrib2fv(programAttribute, value);
                            break;
                        case 3:
                            gl.vertexAttrib3fv(programAttribute, value);
                            break;
                        case 4:
                            gl.vertexAttrib4fv(programAttribute, value);
                            break;
                        default:
                            gl.vertexAttrib1fv(programAttribute, value);
                    }
                }
            }
        }
        disableUnusedAttributes();
    }
    function dispose() {
        reset();
        for(const geometryId in bindingStates){
            const programMap = bindingStates[geometryId];
            for(const programId in programMap){
                const stateMap = programMap[programId];
                for(const wireframe in stateMap){
                    deleteVertexArrayObject(stateMap[wireframe].object);
                    delete stateMap[wireframe];
                }
                delete programMap[programId];
            }
            delete bindingStates[geometryId];
        }
    }
    function releaseStatesOfGeometry(geometry) {
        if (bindingStates[geometry.id] === undefined) return;
        const programMap = bindingStates[geometry.id];
        for(const programId in programMap){
            const stateMap = programMap[programId];
            for(const wireframe in stateMap){
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
            }
            delete programMap[programId];
        }
        delete bindingStates[geometry.id];
    }
    function releaseStatesOfProgram(program) {
        for(const geometryId in bindingStates){
            const programMap = bindingStates[geometryId];
            if (programMap[program.id] === undefined) continue;
            const stateMap = programMap[program.id];
            for(const wireframe in stateMap){
                deleteVertexArrayObject(stateMap[wireframe].object);
                delete stateMap[wireframe];
            }
            delete programMap[program.id];
        }
    }
    function reset() {
        resetDefaultState();
        if (currentState === defaultState) return;
        currentState = defaultState;
        bindVertexArrayObject(currentState.object);
    }
    function resetDefaultState() {
        defaultState.geometry = null;
        defaultState.program = null;
        defaultState.wireframe = false;
    }
    return {
        setup: setup,
        reset: reset,
        resetDefaultState: resetDefaultState,
        dispose: dispose,
        releaseStatesOfGeometry: releaseStatesOfGeometry,
        releaseStatesOfProgram: releaseStatesOfProgram,
        initAttributes: initAttributes,
        enableAttribute: enableAttribute,
        disableUnusedAttributes: disableUnusedAttributes
    };
}
const WebGLBindingStates1 = WebGLBindingStates2;
function WebGLBufferRenderer2(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
        mode = value;
    }
    function render(start, count) {
        gl.drawArrays(mode, start, count);
        info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
        if (primcount === 0) return;
        let extension, methodName;
        if (isWebGL2) {
            extension = gl;
            methodName = 'drawArraysInstanced';
        } else {
            extension = extensions.get('ANGLE_instanced_arrays');
            methodName = 'drawArraysInstancedANGLE';
            if (extension === null) {
                console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
        }
        extension[methodName](mode, start, count, primcount);
        info.update(count, mode, primcount);
    }
    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;
}
const WebGLBufferRenderer1 = WebGLBufferRenderer2;
function WebGLCapabilities2(gl, extensions, parameters) {
    let maxAnisotropy;
    function getMaxAnisotropy() {
        if (maxAnisotropy !== undefined) return maxAnisotropy;
        const extension = extensions.get('EXT_texture_filter_anisotropic');
        if (extension !== null) maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        else maxAnisotropy = 0;
        return maxAnisotropy;
    }
    function getMaxPrecision(precision) {
        if (precision === 'highp') {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) return 'highp';
            precision = 'mediump';
        }
        if (precision === 'mediump') {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) return 'mediump';
        }
        return 'lowp';
    }
    const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
    let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
    const maxPrecision = getMaxPrecision(precision);
    if (maxPrecision !== precision) {
        console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
        precision = maxPrecision;
    }
    const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
    const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
    const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
    const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
    const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
    const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
    const vertexTextures = maxVertexTextures > 0;
    const floatFragmentTextures = isWebGL2 || !!extensions.get('OES_texture_float');
    const floatVertexTextures = vertexTextures && floatFragmentTextures;
    const maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
    return {
        isWebGL2: isWebGL2,
        getMaxAnisotropy: getMaxAnisotropy,
        getMaxPrecision: getMaxPrecision,
        precision: precision,
        logarithmicDepthBuffer: logarithmicDepthBuffer,
        maxTextures: maxTextures,
        maxVertexTextures: maxVertexTextures,
        maxTextureSize: maxTextureSize,
        maxCubemapSize: maxCubemapSize,
        maxAttributes: maxAttributes,
        maxVertexUniforms: maxVertexUniforms,
        maxVaryings: maxVaryings,
        maxFragmentUniforms: maxFragmentUniforms,
        vertexTextures: vertexTextures,
        floatFragmentTextures: floatFragmentTextures,
        floatVertexTextures: floatVertexTextures,
        maxSamples: maxSamples
    };
}
const WebGLCapabilities1 = WebGLCapabilities2;
function WebGLClipping2() {
    const scope1 = this;
    let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
    const plane = new Plane1(), viewNormalMatrix = new Matrix31(), uniform = {
        value: null,
        needsUpdate: false
    };
    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;
    this.init = function(planes, enableLocalClipping, camera) {
        const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
        localClippingEnabled = enableLocalClipping;
        globalState = projectPlanes(planes, camera, 0);
        numGlobalPlanes = planes.length;
        return enabled;
    };
    this.beginShadows = function() {
        renderingShadows = true;
        projectPlanes(null);
    };
    this.endShadows = function() {
        renderingShadows = false;
        resetGlobalState();
    };
    this.setState = function(planes, clipIntersection, clipShadows, camera, cache, fromCache) {
        if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
            if (renderingShadows) projectPlanes(null);
            else resetGlobalState();
        } else {
            const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
            let dstArray = cache.clippingState || null;
            uniform.value = dstArray;
            dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
            for(let i1 = 0; i1 !== lGlobal; ++i1)dstArray[i1] = globalState[i1];
            cache.clippingState = dstArray;
            this.numIntersection = clipIntersection ? this.numPlanes : 0;
            this.numPlanes += nGlobal;
        }
    };
    function resetGlobalState() {
        if (uniform.value !== globalState) {
            uniform.value = globalState;
            uniform.needsUpdate = numGlobalPlanes > 0;
        }
        scope1.numPlanes = numGlobalPlanes;
        scope1.numIntersection = 0;
    }
    function projectPlanes(planes, camera, dstOffset, skipTransform) {
        const nPlanes = planes !== null ? planes.length : 0;
        let dstArray = null;
        if (nPlanes !== 0) {
            dstArray = uniform.value;
            if (skipTransform !== true || dstArray === null) {
                const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
                viewNormalMatrix.getNormalMatrix(viewMatrix);
                if (dstArray === null || dstArray.length < flatSize) dstArray = new Float32Array(flatSize);
                for(let i1 = 0, i4 = dstOffset; i1 !== nPlanes; ++i1, i4 += 4){
                    plane.copy(planes[i1]).applyMatrix4(viewMatrix, viewNormalMatrix);
                    plane.normal.toArray(dstArray, i4);
                    dstArray[i4 + 3] = plane.constant;
                }
            }
            uniform.value = dstArray;
            uniform.needsUpdate = true;
        }
        scope1.numPlanes = nPlanes;
        scope1.numIntersection = 0;
        return dstArray;
    }
}
const WebGLClipping1 = WebGLClipping2;
const fov = 90, aspect = 1;
function CubeCamera3(near, far, renderTarget) {
    Object3D1.call(this);
    this.type = 'CubeCamera';
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
        console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
        return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera1(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector31(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera1(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector31(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera1(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector31(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera1(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector31(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera1(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector31(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera1(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector31(0, 0, -1));
    this.add(cameraNZ);
    this.update = function(renderer, scene) {
        if (this.parent === null) this.updateMatrixWorld();
        const currentXrEnabled = renderer.xr.enabled;
        const currentRenderTarget = renderer.getRenderTarget();
        renderer.xr.enabled = false;
        const generateMipmaps = renderTarget.texture.generateMipmaps;
        renderTarget.texture.generateMipmaps = false;
        renderer.setRenderTarget(renderTarget, 0);
        renderer.render(scene, cameraPX);
        renderer.setRenderTarget(renderTarget, 1);
        renderer.render(scene, cameraNX);
        renderer.setRenderTarget(renderTarget, 2);
        renderer.render(scene, cameraPY);
        renderer.setRenderTarget(renderTarget, 3);
        renderer.render(scene, cameraNY);
        renderer.setRenderTarget(renderTarget, 4);
        renderer.render(scene, cameraPZ);
        renderTarget.texture.generateMipmaps = generateMipmaps;
        renderer.setRenderTarget(renderTarget, 5);
        renderer.render(scene, cameraNZ);
        renderer.setRenderTarget(currentRenderTarget);
        renderer.xr.enabled = currentXrEnabled;
    };
    this.clear = function(renderer, color1, depth1, stencil) {
        const currentRenderTarget = renderer.getRenderTarget();
        for(let i1 = 0; i1 < 6; i1++){
            renderer.setRenderTarget(renderTarget, i1);
            renderer.clear(color1, depth1, stencil);
        }
        renderer.setRenderTarget(currentRenderTarget);
    };
}
CubeCamera3.prototype = Object.create(Object3D1.prototype);
CubeCamera3.prototype.constructor = CubeCamera3;
const CubeCamera1 = CubeCamera3;
function WebGLCubeRenderTarget3(size, options, dummy) {
    if (Number.isInteger(options)) {
        console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');
        options = dummy;
    }
    WebGLRenderTarget1.call(this, size, size, options);
    this.texture.isWebGLCubeRenderTargetTexture = true;
}
WebGLCubeRenderTarget3.prototype = Object.create(WebGLRenderTarget1.prototype);
WebGLCubeRenderTarget3.prototype.constructor = WebGLCubeRenderTarget3;
WebGLCubeRenderTarget3.prototype.isWebGLCubeRenderTarget = true;
WebGLCubeRenderTarget3.prototype.fromEquirectangularTexture = function(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.format = RGBAFormat;
    this.texture.encoding = texture.encoding;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: `\n\n			varying vec3 vWorldDirection;\n\n			vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n				return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n			}\n\n			void main() {\n\n				vWorldDirection = transformDirection( position, modelMatrix );\n\n				#include <begin_vertex>\n				#include <project_vertex>\n\n			}\n		`,
        fragmentShader: `\n\n			uniform sampler2D tEquirect;\n\n			varying vec3 vWorldDirection;\n\n			#include <common>\n\n			void main() {\n\n				vec3 direction = normalize( vWorldDirection );\n\n				vec2 sampleUV = equirectUv( direction );\n\n				gl_FragColor = texture2D( tEquirect, sampleUV );\n\n			}\n		`
    };
    const geometry = new BoxBufferGeometry1(5, 5, 5);
    const material = new ShaderMaterial1({
        name: 'CubemapFromEquirect',
        uniforms: cloneUniforms(shader.uniforms),
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader,
        side: BackSide,
        blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh1(geometry, material);
    const currentMinFilter = texture.minFilter;
    const currentRenderList = renderer.getRenderList();
    const currentRenderTarget = renderer.getRenderTarget();
    const currentRenderState = renderer.getRenderState();
    if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
    const camera = new CubeCamera1(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    renderer.setRenderTarget(currentRenderTarget);
    renderer.setRenderList(currentRenderList);
    renderer.setRenderState(currentRenderState);
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
};
const WebGLCubeRenderTarget1 = WebGLCubeRenderTarget3;
function WebGLCubeMaps2(renderer) {
    let cubemaps = new WeakMap();
    function mapTextureMapping(texture, mapping) {
        if (mapping === EquirectangularReflectionMapping) texture.mapping = CubeReflectionMapping;
        else if (mapping === EquirectangularRefractionMapping) texture.mapping = CubeRefractionMapping;
        return texture;
    }
    function get(texture) {
        if (texture && texture.isTexture) {
            const mapping = texture.mapping;
            if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
                if (cubemaps.has(texture)) {
                    const cubemap = cubemaps.get(texture).texture;
                    return mapTextureMapping(cubemap, texture.mapping);
                } else {
                    const image = texture.image;
                    if (image && image.height > 0) {
                        const renderTarget = new WebGLCubeRenderTarget1(image.height / 2);
                        renderTarget.fromEquirectangularTexture(renderer, texture);
                        cubemaps.set(texture, renderTarget);
                        return mapTextureMapping(renderTarget.texture, texture.mapping);
                    } else return null;
                }
            }
        }
        return texture;
    }
    function dispose() {
        cubemaps = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
const WebGLCubeMaps1 = WebGLCubeMaps2;
function WebGLExtensions2(gl) {
    const extensions = {
    };
    return {
        has: function(name) {
            if (extensions[name] !== undefined) return extensions[name];
            let extension;
            switch(name){
                case 'WEBGL_depth_texture':
                    extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
                    break;
                case 'EXT_texture_filter_anisotropic':
                    extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                    break;
                case 'WEBGL_compressed_texture_s3tc':
                    extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                    break;
                case 'WEBGL_compressed_texture_pvrtc':
                    extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                    break;
                default:
                    extension = gl.getExtension(name);
            }
            extensions[name] = extension;
            return !!extension;
        },
        get: function(name) {
            if (!this.has(name)) console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
            return extensions[name];
        }
    };
}
const WebGLExtensions1 = WebGLExtensions2;
function WebGLGeometries2(gl, attributes, info, bindingStates) {
    const geometries = new WeakMap();
    const wireframeAttributes = new WeakMap();
    function onGeometryDispose(event) {
        const geometry = event.target;
        const buffergeometry = geometries.get(geometry);
        if (buffergeometry.index !== null) attributes.remove(buffergeometry.index);
        for(const name in buffergeometry.attributes)attributes.remove(buffergeometry.attributes[name]);
        geometry.removeEventListener('dispose', onGeometryDispose);
        geometries.delete(geometry);
        const attribute = wireframeAttributes.get(buffergeometry);
        if (attribute) {
            attributes.remove(attribute);
            wireframeAttributes.delete(buffergeometry);
        }
        bindingStates.releaseStatesOfGeometry(geometry);
        if (geometry.isInstancedBufferGeometry === true) delete geometry._maxInstanceCount;
        info.memory.geometries--;
    }
    function get(object, geometry) {
        let buffergeometry = geometries.get(geometry);
        if (buffergeometry) return buffergeometry;
        geometry.addEventListener('dispose', onGeometryDispose);
        if (geometry.isBufferGeometry) buffergeometry = geometry;
        else if (geometry.isGeometry) {
            if (geometry._bufferGeometry === undefined) geometry._bufferGeometry = new BufferGeometry1().setFromObject(object);
            buffergeometry = geometry._bufferGeometry;
        }
        geometries.set(geometry, buffergeometry);
        info.memory.geometries++;
        return buffergeometry;
    }
    function update(geometry) {
        const geometryAttributes = geometry.attributes;
        for(const name in geometryAttributes)attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
        const morphAttributes = geometry.morphAttributes;
        for(const name in morphAttributes){
            const array = morphAttributes[name];
            for(let i1 = 0, l = array.length; i1 < l; i1++)attributes.update(array[i1], gl.ARRAY_BUFFER);
        }
    }
    function updateWireframeAttribute(geometry) {
        const indices2 = [];
        const geometryIndex = geometry.index;
        const geometryPosition = geometry.attributes.position;
        let version = 0;
        if (geometryIndex !== null) {
            const array = geometryIndex.array;
            version = geometryIndex.version;
            for(let i1 = 0, l = array.length; i1 < l; i1 += 3){
                const a2 = array[i1 + 0];
                const b2 = array[i1 + 1];
                const c2 = array[i1 + 2];
                indices2.push(a2, b2, b2, c2, c2, a2);
            }
        } else {
            const array = geometryPosition.array;
            version = geometryPosition.version;
            for(let i1 = 0, l = array.length / 3 - 1; i1 < l; i1 += 3){
                const a2 = i1 + 0;
                const b2 = i1 + 1;
                const c2 = i1 + 2;
                indices2.push(a2, b2, b2, c2, c2, a2);
            }
        }
        const attribute = new (arrayMax1(indices2) > 65535 ? Uint32BufferAttribute1 : Uint16BufferAttribute1)(indices2, 1);
        attribute.version = version;
        const previousAttribute = wireframeAttributes.get(geometry);
        if (previousAttribute) attributes.remove(previousAttribute);
        wireframeAttributes.set(geometry, attribute);
    }
    function getWireframeAttribute(geometry) {
        const currentAttribute = wireframeAttributes.get(geometry);
        if (currentAttribute) {
            const geometryIndex = geometry.index;
            if (geometryIndex !== null) {
                if (currentAttribute.version < geometryIndex.version) updateWireframeAttribute(geometry);
            }
        } else updateWireframeAttribute(geometry);
        return wireframeAttributes.get(geometry);
    }
    return {
        get: get,
        update: update,
        getWireframeAttribute: getWireframeAttribute
    };
}
const WebGLGeometries1 = WebGLGeometries2;
function WebGLIndexedBufferRenderer2(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
        mode = value;
    }
    let type, bytesPerElement;
    function setIndex(value) {
        type = value.type;
        bytesPerElement = value.bytesPerElement;
    }
    function render(start, count) {
        gl.drawElements(mode, count, type, start * bytesPerElement);
        info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
        if (primcount === 0) return;
        let extension, methodName;
        if (isWebGL2) {
            extension = gl;
            methodName = 'drawElementsInstanced';
        } else {
            extension = extensions.get('ANGLE_instanced_arrays');
            methodName = 'drawElementsInstancedANGLE';
            if (extension === null) {
                console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                return;
            }
        }
        extension[methodName](mode, count, type, start * bytesPerElement, primcount);
        info.update(count, mode, primcount);
    }
    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;
}
const WebGLIndexedBufferRenderer1 = WebGLIndexedBufferRenderer2;
function WebGLInfo2(gl) {
    const memory = {
        geometries: 0,
        textures: 0
    };
    const render = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function update(count, mode, instanceCount) {
        render.calls++;
        switch(mode){
            case gl.TRIANGLES:
                render.triangles += instanceCount * (count / 3);
                break;
            case gl.LINES:
                render.lines += instanceCount * (count / 2);
                break;
            case gl.LINE_STRIP:
                render.lines += instanceCount * (count - 1);
                break;
            case gl.LINE_LOOP:
                render.lines += instanceCount * count;
                break;
            case gl.POINTS:
                render.points += instanceCount * count;
                break;
            default:
                console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
                break;
        }
    }
    function reset() {
        render.frame++;
        render.calls = 0;
        render.triangles = 0;
        render.points = 0;
        render.lines = 0;
    }
    return {
        memory: memory,
        render: render,
        programs: null,
        autoReset: true,
        reset: reset,
        update: update
    };
}
const WebGLInfo1 = WebGLInfo2;
function numericalSort(a2, b2) {
    return a2[0] - b2[0];
}
function absNumericalSort(a2, b2) {
    return Math.abs(b2[1]) - Math.abs(a2[1]);
}
function WebGLMorphtargets2(gl) {
    const influencesList = {
    };
    const morphInfluences = new Float32Array(8);
    const workInfluences = [];
    for(let i1 = 0; i1 < 8; i1++)workInfluences[i1] = [
        i1,
        0
    ];
    function update(object, geometry, material, program) {
        const objectInfluences = object.morphTargetInfluences;
        const length = objectInfluences === undefined ? 0 : objectInfluences.length;
        let influences = influencesList[geometry.id];
        if (influences === undefined) {
            influences = [];
            for(let i11 = 0; i11 < length; i11++)influences[i11] = [
                i11,
                0
            ];
            influencesList[geometry.id] = influences;
        }
        for(let i11 = 0; i11 < length; i11++){
            const influence = influences[i11];
            influence[0] = i11;
            influence[1] = objectInfluences[i11];
        }
        influences.sort(absNumericalSort);
        for(let i11 = 0; i11 < 8; i11++)if (i11 < length && influences[i11][1]) {
            workInfluences[i11][0] = influences[i11][0];
            workInfluences[i11][1] = influences[i11][1];
        } else {
            workInfluences[i11][0] = Number.MAX_SAFE_INTEGER;
            workInfluences[i11][1] = 0;
        }
        workInfluences.sort(numericalSort);
        const morphTargets = material.morphTargets && geometry.morphAttributes.position;
        const morphNormals = material.morphNormals && geometry.morphAttributes.normal;
        let morphInfluencesSum = 0;
        for(let i11 = 0; i11 < 8; i11++){
            const influence = workInfluences[i11];
            const index = influence[0];
            const value = influence[1];
            if (index !== Number.MAX_SAFE_INTEGER && value) {
                if (morphTargets && geometry.getAttribute('morphTarget' + i11) !== morphTargets[index]) geometry.setAttribute('morphTarget' + i11, morphTargets[index]);
                if (morphNormals && geometry.getAttribute('morphNormal' + i11) !== morphNormals[index]) geometry.setAttribute('morphNormal' + i11, morphNormals[index]);
                morphInfluences[i11] = value;
                morphInfluencesSum += value;
            } else {
                if (morphTargets && geometry.getAttribute('morphTarget' + i11) !== undefined) geometry.deleteAttribute('morphTarget' + i11);
                if (morphNormals && geometry.getAttribute('morphNormal' + i11) !== undefined) geometry.deleteAttribute('morphNormal' + i11);
                morphInfluences[i11] = 0;
            }
        }
        const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
        program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
    }
    return {
        update: update
    };
}
const WebGLMorphtargets1 = WebGLMorphtargets2;
function WebGLObjects2(gl, geometries, attributes, info) {
    let updateMap = new WeakMap();
    function update(object) {
        const frame = info.render.frame;
        const geometry = object.geometry;
        const buffergeometry = geometries.get(object, geometry);
        if (updateMap.get(buffergeometry) !== frame) {
            if (geometry.isGeometry) buffergeometry.updateFromObject(object);
            geometries.update(buffergeometry);
            updateMap.set(buffergeometry, frame);
        }
        if (object.isInstancedMesh) {
            attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
            if (object.instanceColor !== null) attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
        }
        return buffergeometry;
    }
    function dispose() {
        updateMap = new WeakMap();
    }
    return {
        update: update,
        dispose: dispose
    };
}
const WebGLObjects1 = WebGLObjects2;
function DataTexture2DArray2(data, width2, height2, depth1) {
    Texture1.call(this, null);
    this.image = {
        data: data || null,
        width: width2 || 1,
        height: height2 || 1,
        depth: depth1 || 1
    };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
}
DataTexture2DArray2.prototype = Object.create(Texture1.prototype);
DataTexture2DArray2.prototype.constructor = DataTexture2DArray2;
DataTexture2DArray2.prototype.isDataTexture2DArray = true;
const DataTexture2DArray1 = DataTexture2DArray2;
function DataTexture3D2(data, width2, height2, depth1) {
    Texture1.call(this, null);
    this.image = {
        data: data || null,
        width: width2 || 1,
        height: height2 || 1,
        depth: depth1 || 1
    };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
}
DataTexture3D2.prototype = Object.create(Texture1.prototype);
DataTexture3D2.prototype.constructor = DataTexture3D2;
DataTexture3D2.prototype.isDataTexture3D = true;
const DataTexture3D1 = DataTexture3D2;
const emptyTexture = new Texture1();
const emptyTexture2dArray = new DataTexture2DArray1();
const emptyTexture3d = new DataTexture3D1();
const emptyCubeTexture = new CubeTexture1();
const arrayCacheF32 = [];
const arrayCacheI32 = [];
const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
    const firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0) return array;
    const n = nBlocks * blockSize;
    let r = arrayCacheF32[n];
    if (r === undefined) {
        r = new Float32Array(n);
        arrayCacheF32[n] = r;
    }
    if (nBlocks !== 0) {
        firstElem.toArray(r, 0);
        for(let i1 = 1, offset = 0; i1 !== nBlocks; ++i1){
            offset += blockSize;
            array[i1].toArray(r, offset);
        }
    }
    return r;
}
function arraysEqual(a2, b2) {
    if (a2.length !== b2.length) return false;
    for(let i1 = 0, l = a2.length; i1 < l; i1++)if (a2[i1] !== b2[i1]) return false;
    return true;
}
function copyArray(a2, b2) {
    for(let i1 = 0, l = b2.length; i1 < l; i1++)a2[i1] = b2[i1];
}
function allocTexUnits(textures, n) {
    let r = arrayCacheI32[n];
    if (r === undefined) {
        r = new Int32Array(n);
        arrayCacheI32[n] = r;
    }
    for(let i1 = 0; i1 !== n; ++i1)r[i1] = textures.allocateTextureUnit();
    return r;
}
function setValueV1f(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1f(this.addr, v);
    cache[0] = v;
}
function setValueV2f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y) {
            gl.uniform2f(this.addr, v.x, v.y);
            cache[0] = v.x;
            cache[1] = v.y;
        }
    } else {
        if (arraysEqual(cache, v)) return;
        gl.uniform2fv(this.addr, v);
        copyArray(cache, v);
    }
}
function setValueV3f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
            gl.uniform3f(this.addr, v.x, v.y, v.z);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
        }
    } else if (v.r !== undefined) {
        if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
            gl.uniform3f(this.addr, v.r, v.g, v.b);
            cache[0] = v.r;
            cache[1] = v.g;
            cache[2] = v.b;
        }
    } else {
        if (arraysEqual(cache, v)) return;
        gl.uniform3fv(this.addr, v);
        copyArray(cache, v);
    }
}
function setValueV4f(gl, v) {
    const cache = this.cache;
    if (v.x !== undefined) {
        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
            gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
            cache[0] = v.x;
            cache[1] = v.y;
            cache[2] = v.z;
            cache[3] = v.w;
        }
    } else {
        if (arraysEqual(cache, v)) return;
        gl.uniform4fv(this.addr, v);
        copyArray(cache, v);
    }
}
function setValueM2(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if (arraysEqual(cache, v)) return;
        gl.uniformMatrix2fv(this.addr, false, v);
        copyArray(cache, v);
    } else {
        if (arraysEqual(cache, elements)) return;
        mat2array.set(elements);
        gl.uniformMatrix2fv(this.addr, false, mat2array);
        copyArray(cache, elements);
    }
}
function setValueM3(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if (arraysEqual(cache, v)) return;
        gl.uniformMatrix3fv(this.addr, false, v);
        copyArray(cache, v);
    } else {
        if (arraysEqual(cache, elements)) return;
        mat3array.set(elements);
        gl.uniformMatrix3fv(this.addr, false, mat3array);
        copyArray(cache, elements);
    }
}
function setValueM4(gl, v) {
    const cache = this.cache;
    const elements = v.elements;
    if (elements === undefined) {
        if (arraysEqual(cache, v)) return;
        gl.uniformMatrix4fv(this.addr, false, v);
        copyArray(cache, v);
    } else {
        if (arraysEqual(cache, elements)) return;
        mat4array.set(elements);
        gl.uniformMatrix4fv(this.addr, false, mat4array);
        copyArray(cache, elements);
    }
}
function setValueT1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.safeSetTexture2D(v || emptyTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.setTexture2DArray(v || emptyTexture2dArray, unit);
}
function setValueT3D1(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.setTexture3D(v || emptyTexture3d, unit);
}
function setValueT6(gl, v, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
        gl.uniform1i(this.addr, unit);
        cache[0] = unit;
    }
    textures.safeSetTextureCube(v || emptyCubeTexture, unit);
}
function setValueV1i(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1i(this.addr, v);
    cache[0] = v;
}
function setValueV2i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform2iv(this.addr, v);
    copyArray(cache, v);
}
function setValueV3i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform3iv(this.addr, v);
    copyArray(cache, v);
}
function setValueV4i(gl, v) {
    const cache = this.cache;
    if (arraysEqual(cache, v)) return;
    gl.uniform4iv(this.addr, v);
    copyArray(cache, v);
}
function setValueV1ui(gl, v) {
    const cache = this.cache;
    if (cache[0] === v) return;
    gl.uniform1ui(this.addr, v);
    cache[0] = v;
}
function getSingularSetter(type) {
    switch(type){
        case 5126:
            return setValueV1f;
        case 35664:
            return setValueV2f;
        case 35665:
            return setValueV3f;
        case 35666:
            return setValueV4f;
        case 35674:
            return setValueM2;
        case 35675:
            return setValueM3;
        case 35676:
            return setValueM4;
        case 5124:
        case 35670:
            return setValueV1i;
        case 35667:
        case 35671:
            return setValueV2i;
        case 35668:
        case 35672:
            return setValueV3i;
        case 35669:
        case 35673:
            return setValueV4i;
        case 5125:
            return setValueV1ui;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return setValueT1;
        case 35679:
        case 36299:
        case 36307:
            return setValueT3D1;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return setValueT6;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return setValueT2DArray1;
    }
}
function setValueV1fArray(gl, v) {
    gl.uniform1fv(this.addr, v);
}
function setValueV1iArray(gl, v) {
    gl.uniform1iv(this.addr, v);
}
function setValueV2iArray(gl, v) {
    gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
    gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
    gl.uniform4iv(this.addr, v);
}
function setValueV2fArray(gl, v) {
    const data = flatten(v, this.size, 2);
    gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
    const data = flatten(v, this.size, 3);
    gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v) {
    const data = flatten(v, this.size, 4);
    gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
    const data = flatten(v, this.size, 9);
    gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
    const data = flatten(v, this.size, 16);
    gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueT1Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for(let i1 = 0; i1 !== n; ++i1)textures.safeSetTexture2D(v[i1] || emptyTexture, units[i1]);
}
function setValueT6Array(gl, v, textures) {
    const n = v.length;
    const units = allocTexUnits(textures, n);
    gl.uniform1iv(this.addr, units);
    for(let i1 = 0; i1 !== n; ++i1)textures.safeSetTextureCube(v[i1] || emptyCubeTexture, units[i1]);
}
function getPureArraySetter(type) {
    switch(type){
        case 5126:
            return setValueV1fArray;
        case 35664:
            return setValueV2fArray;
        case 35665:
            return setValueV3fArray;
        case 35666:
            return setValueV4fArray;
        case 35674:
            return setValueM2Array;
        case 35675:
            return setValueM3Array;
        case 35676:
            return setValueM4Array;
        case 5124:
        case 35670:
            return setValueV1iArray;
        case 35667:
        case 35671:
            return setValueV2iArray;
        case 35668:
        case 35672:
            return setValueV3iArray;
        case 35669:
        case 35673:
            return setValueV4iArray;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return setValueT1Array;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return setValueT6Array;
    }
}
function SingleUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.setValue = getSingularSetter(activeInfo.type);
}
function PureArrayUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
}
PureArrayUniform.prototype.updateCache = function(data) {
    const cache = this.cache;
    if (data instanceof Float32Array && cache.length !== data.length) this.cache = new Float32Array(data.length);
    copyArray(cache, data);
};
function StructuredUniform(id) {
    this.id = id;
    this.seq = [];
    this.map = {
    };
}
StructuredUniform.prototype.setValue = function(gl, value, textures) {
    const seq = this.seq;
    for(let i1 = 0, n = seq.length; i1 !== n; ++i1){
        const u = seq[i1];
        u.setValue(gl, value[u.id], textures);
    }
};
const RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
    const path = activeInfo.name, pathLength = path.length;
    RePathPart.lastIndex = 0;
    while(true){
        const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
        let id = match[1];
        const idIsIndex = match[2] === ']', subscript = match[3];
        if (idIsIndex) id = id | 0;
        if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
            addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
            break;
        } else {
            const map = container.map;
            let next = map[id];
            if (next === undefined) {
                next = new StructuredUniform(id);
                addUniform(container, next);
            }
            container = next;
        }
    }
}
function WebGLUniforms2(gl, program) {
    this.seq = [];
    this.map = {
    };
    const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for(let i1 = 0; i1 < n; ++i1){
        const info = gl.getActiveUniform(program, i1), addr = gl.getUniformLocation(program, info.name);
        parseUniform(info, addr, this);
    }
}
WebGLUniforms2.prototype.setValue = function(gl, name, value, textures) {
    const u = this.map[name];
    if (u !== undefined) u.setValue(gl, value, textures);
};
WebGLUniforms2.prototype.setOptional = function(gl, object, name) {
    const v = object[name];
    if (v !== undefined) this.setValue(gl, name, v);
};
WebGLUniforms2.upload = function(gl, seq, values, textures) {
    for(let i1 = 0, n = seq.length; i1 !== n; ++i1){
        const u = seq[i1], v = values[u.id];
        if (v.needsUpdate !== false) u.setValue(gl, v.value, textures);
    }
};
WebGLUniforms2.seqWithValue = function(seq, values) {
    const r = [];
    for(let i1 = 0, n = seq.length; i1 !== n; ++i1){
        const u = seq[i1];
        if (u.id in values) r.push(u);
    }
    return r;
};
const WebGLUniforms1 = WebGLUniforms2;
function WebGLShader12(gl, type, string) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    return shader;
}
const WebGLShader11 = WebGLShader12;
let programIdCount = 0;
function addLineNumbers(string) {
    const lines = string.split('\n');
    for(let i1 = 0; i1 < lines.length; i1++)lines[i1] = i1 + 1 + ': ' + lines[i1];
    return lines.join('\n');
}
function getEncodingComponents(encoding) {
    switch(encoding){
        case LinearEncoding:
            return [
                'Linear',
                '( value )'
            ];
        case sRGBEncoding:
            return [
                'sRGB',
                '( value )'
            ];
        case RGBEEncoding:
            return [
                'RGBE',
                '( value )'
            ];
        case RGBM7Encoding:
            return [
                'RGBM',
                '( value, 7.0 )'
            ];
        case RGBM16Encoding:
            return [
                'RGBM',
                '( value, 16.0 )'
            ];
        case RGBDEncoding:
            return [
                'RGBD',
                '( value, 256.0 )'
            ];
        case GammaEncoding:
            return [
                'Gamma',
                '( value, float( GAMMA_FACTOR ) )'
            ];
        case LogLuvEncoding:
            return [
                'LogLuv',
                '( value )'
            ];
        default:
            console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
            return [
                'Linear',
                '( value )'
            ];
    }
}
function getShaderErrors(gl, shader, type) {
    const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    const log = gl.getShaderInfoLog(shader).trim();
    if (status && log === '') return '';
    const source = gl.getShaderSource(shader);
    return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers(source);
}
function getTexelDecodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
}
function getTexelEncodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
}
function getToneMappingFunction(functionName, toneMapping) {
    let toneMappingName;
    switch(toneMapping){
        case LinearToneMapping:
            toneMappingName = 'Linear';
            break;
        case ReinhardToneMapping:
            toneMappingName = 'Reinhard';
            break;
        case CineonToneMapping:
            toneMappingName = 'OptimizedCineon';
            break;
        case ACESFilmicToneMapping:
            toneMappingName = 'ACESFilmic';
            break;
        case CustomToneMapping:
            toneMappingName = 'Custom';
            break;
        default:
            console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
            toneMappingName = 'Linear';
    }
    return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
}
function generateExtensions(parameters) {
    const chunks = [
        parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '',
        (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
        parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '',
        (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
    ];
    return chunks.filter(filterEmptyLine).join('\n');
}
function generateDefines(defines) {
    const chunks = [];
    for(const name in defines){
        const value = defines[name];
        if (value === false) continue;
        chunks.push('#define ' + name + ' ' + value);
    }
    return chunks.join('\n');
}
function fetchAttributeLocations(gl, program) {
    const attributes = {
    };
    const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
    for(let i1 = 0; i1 < n; i1++){
        const info = gl.getActiveAttrib(program, i1);
        const name = info.name;
        attributes[name] = gl.getAttribLocation(program, name);
    }
    return attributes;
}
function filterEmptyLine(string) {
    return string !== '';
}
function replaceLightNums(string, parameters) {
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
    return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
    return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match, include) {
    const string = ShaderChunk[include];
    if (string === undefined) throw new Error('Can not resolve #include <' + include + '>');
    return resolveIncludes(string);
}
const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;
function unrollLoops(string) {
    return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match, start, end, snippet) {
    console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');
    return loopReplacer(match, start, end, snippet);
}
function loopReplacer(match, start, end, snippet) {
    let string = '';
    for(let i1 = parseInt(start); i1 < parseInt(end); i1++)string += snippet.replace(/\[ i \]/g, '[ ' + i1 + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i1);
    return string;
}
function generatePrecision(parameters) {
    let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
    if (parameters.precision === "highp") precisionstring += "\n#define HIGH_PRECISION";
    else if (parameters.precision === "mediump") precisionstring += "\n#define MEDIUM_PRECISION";
    else if (parameters.precision === "lowp") precisionstring += "\n#define LOW_PRECISION";
    return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
    let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
    if (parameters.shadowMapType === PCFShadowMap) shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
    else if (parameters.shadowMapType === PCFSoftShadowMap) shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
    else if (parameters.shadowMapType === VSMShadowMap) shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
    return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
    let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    if (parameters.envMap) switch(parameters.envMapMode){
        case CubeReflectionMapping:
        case CubeRefractionMapping:
            envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
            break;
        case CubeUVReflectionMapping:
        case CubeUVRefractionMapping:
            envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
            break;
    }
    return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
    let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
    if (parameters.envMap) switch(parameters.envMapMode){
        case CubeRefractionMapping:
        case CubeUVRefractionMapping:
            envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
            break;
    }
    return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
    let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';
    if (parameters.envMap) switch(parameters.combine){
        case MultiplyOperation:
            envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
            break;
        case MixOperation:
            envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
            break;
        case AddOperation:
            envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
            break;
    }
    return envMapBlendingDefine;
}
function WebGLProgram12(renderer, cacheKey, parameters, bindingStates) {
    const gl = renderer.getContext();
    const defines = parameters.defines;
    let vertexShader = parameters.vertexShader;
    let fragmentShader = parameters.fragmentShader;
    const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
    const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
    const envMapModeDefine = generateEnvMapModeDefine(parameters);
    const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
    const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
    const customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
    const customDefines = generateDefines(defines);
    const program = gl.createProgram();
    let prefixVertex, prefixFragment;
    if (parameters.isRawShaderMaterial) {
        prefixVertex = [
            customDefines
        ].filter(filterEmptyLine).join('\n');
        if (prefixVertex.length > 0) prefixVertex += '\n';
        prefixFragment = [
            customExtensions,
            customDefines
        ].filter(filterEmptyLine).join('\n');
        if (prefixFragment.length > 0) prefixFragment += '\n';
    } else {
        prefixVertex = [
            generatePrecision(parameters),
            '#define SHADER_NAME ' + parameters.shaderName,
            customDefines,
            parameters.instancing ? '#define USE_INSTANCING' : '',
            parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
            parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
            '#define GAMMA_FACTOR ' + gammaFactorDefine,
            '#define MAX_BONES ' + parameters.maxBones,
            parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
            parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',
            parameters.map ? '#define USE_MAP' : '',
            parameters.envMap ? '#define USE_ENVMAP' : '',
            parameters.envMap ? '#define ' + envMapModeDefine : '',
            parameters.lightMap ? '#define USE_LIGHTMAP' : '',
            parameters.aoMap ? '#define USE_AOMAP' : '',
            parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
            parameters.bumpMap ? '#define USE_BUMPMAP' : '',
            parameters.normalMap ? '#define USE_NORMALMAP' : '',
            parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
            parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
            parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
            parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
            parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
            parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
            parameters.specularMap ? '#define USE_SPECULARMAP' : '',
            parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
            parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
            parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
            parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
            parameters.vertexTangents ? '#define USE_TANGENT' : '',
            parameters.vertexColors ? '#define USE_COLOR' : '',
            parameters.vertexUvs ? '#define USE_UV' : '',
            parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
            parameters.flatShading ? '#define FLAT_SHADED' : '',
            parameters.skinning ? '#define USE_SKINNING' : '',
            parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
            parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
            parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
            parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
            parameters.flipSided ? '#define FLIP_SIDED' : '',
            parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
            parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
            parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
            parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
            parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
            'uniform mat4 modelMatrix;',
            'uniform mat4 modelViewMatrix;',
            'uniform mat4 projectionMatrix;',
            'uniform mat4 viewMatrix;',
            'uniform mat3 normalMatrix;',
            'uniform vec3 cameraPosition;',
            'uniform bool isOrthographic;',
            '#ifdef USE_INSTANCING',
            '\tattribute mat4 instanceMatrix;',
            '#endif',
            '#ifdef USE_INSTANCING_COLOR',
            '\tattribute vec3 instanceColor;',
            '#endif',
            'attribute vec3 position;',
            'attribute vec3 normal;',
            'attribute vec2 uv;',
            '#ifdef USE_TANGENT',
            '\tattribute vec4 tangent;',
            '#endif',
            '#ifdef USE_COLOR',
            '\tattribute vec3 color;',
            '#endif',
            '#ifdef USE_MORPHTARGETS',
            '\tattribute vec3 morphTarget0;',
            '\tattribute vec3 morphTarget1;',
            '\tattribute vec3 morphTarget2;',
            '\tattribute vec3 morphTarget3;',
            '\t#ifdef USE_MORPHNORMALS',
            '\t\tattribute vec3 morphNormal0;',
            '\t\tattribute vec3 morphNormal1;',
            '\t\tattribute vec3 morphNormal2;',
            '\t\tattribute vec3 morphNormal3;',
            '\t#else',
            '\t\tattribute vec3 morphTarget4;',
            '\t\tattribute vec3 morphTarget5;',
            '\t\tattribute vec3 morphTarget6;',
            '\t\tattribute vec3 morphTarget7;',
            '\t#endif',
            '#endif',
            '#ifdef USE_SKINNING',
            '\tattribute vec4 skinIndex;',
            '\tattribute vec4 skinWeight;',
            '#endif',
            '\n'
        ].filter(filterEmptyLine).join('\n');
        prefixFragment = [
            customExtensions,
            generatePrecision(parameters),
            '#define SHADER_NAME ' + parameters.shaderName,
            customDefines,
            parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '',
            '#define GAMMA_FACTOR ' + gammaFactorDefine,
            parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
            parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',
            parameters.map ? '#define USE_MAP' : '',
            parameters.matcap ? '#define USE_MATCAP' : '',
            parameters.envMap ? '#define USE_ENVMAP' : '',
            parameters.envMap ? '#define ' + envMapTypeDefine : '',
            parameters.envMap ? '#define ' + envMapModeDefine : '',
            parameters.envMap ? '#define ' + envMapBlendingDefine : '',
            parameters.lightMap ? '#define USE_LIGHTMAP' : '',
            parameters.aoMap ? '#define USE_AOMAP' : '',
            parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
            parameters.bumpMap ? '#define USE_BUMPMAP' : '',
            parameters.normalMap ? '#define USE_NORMALMAP' : '',
            parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
            parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '',
            parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
            parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
            parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
            parameters.specularMap ? '#define USE_SPECULARMAP' : '',
            parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
            parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
            parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
            parameters.sheen ? '#define USE_SHEEN' : '',
            parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
            parameters.vertexTangents ? '#define USE_TANGENT' : '',
            parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
            parameters.vertexUvs ? '#define USE_UV' : '',
            parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
            parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',
            parameters.flatShading ? '#define FLAT_SHADED' : '',
            parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
            parameters.flipSided ? '#define FLIP_SIDED' : '',
            parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
            parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
            parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
            parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
            parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
            parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',
            (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '',
            'uniform mat4 viewMatrix;',
            'uniform vec3 cameraPosition;',
            'uniform bool isOrthographic;',
            parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '',
            parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '',
            parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '',
            parameters.dithering ? '#define DITHERING' : '',
            ShaderChunk['encodings_pars_fragment'],
            parameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '',
            parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '',
            parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '',
            parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '',
            parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '',
            getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding),
            parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',
            '\n'
        ].filter(filterEmptyLine).join('\n');
    }
    vertexShader = resolveIncludes(vertexShader);
    vertexShader = replaceLightNums(vertexShader, parameters);
    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
    fragmentShader = resolveIncludes(fragmentShader);
    fragmentShader = replaceLightNums(fragmentShader, parameters);
    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
    vertexShader = unrollLoops(vertexShader);
    fragmentShader = unrollLoops(fragmentShader);
    if (parameters.isWebGL2 && !parameters.isRawShaderMaterial) {
        prefixVertex = [
            '#version 300 es\n',
            '#define attribute in',
            '#define varying out',
            '#define texture2D texture'
        ].join('\n') + '\n' + prefixVertex;
        prefixFragment = [
            '#version 300 es\n',
            '#define varying in',
            'out highp vec4 pc_fragColor;',
            '#define gl_FragColor pc_fragColor',
            '#define gl_FragDepthEXT gl_FragDepth',
            '#define texture2D texture',
            '#define textureCube texture',
            '#define texture2DProj textureProj',
            '#define texture2DLodEXT textureLod',
            '#define texture2DProjLodEXT textureProjLod',
            '#define textureCubeLodEXT textureLod',
            '#define texture2DGradEXT textureGrad',
            '#define texture2DProjGradEXT textureProjGrad',
            '#define textureCubeGradEXT textureGrad'
        ].join('\n') + '\n' + prefixFragment;
    }
    const vertexGlsl = prefixVertex + vertexShader;
    const fragmentGlsl = prefixFragment + fragmentShader;
    const glVertexShader = WebGLShader11(gl, gl.VERTEX_SHADER, vertexGlsl);
    const glFragmentShader = WebGLShader11(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
    gl.attachShader(program, glVertexShader);
    gl.attachShader(program, glFragmentShader);
    if (parameters.index0AttributeName !== undefined) gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
    else if (parameters.morphTargets === true) gl.bindAttribLocation(program, 0, 'position');
    gl.linkProgram(program);
    if (renderer.debug.checkShaderErrors) {
        const programLog = gl.getProgramInfoLog(program).trim();
        const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
        const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
        let runnable = true;
        let haveDiagnostics = true;
        if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
            runnable = false;
            const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
            const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
            console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);
        } else if (programLog !== '') console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
        else if (vertexLog === '' || fragmentLog === '') haveDiagnostics = false;
        if (haveDiagnostics) this.diagnostics = {
            runnable: runnable,
            programLog: programLog,
            vertexShader: {
                log: vertexLog,
                prefix: prefixVertex
            },
            fragmentShader: {
                log: fragmentLog,
                prefix: prefixFragment
            }
        };
    }
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    let cachedUniforms;
    this.getUniforms = function() {
        if (cachedUniforms === undefined) cachedUniforms = new WebGLUniforms1(gl, program);
        return cachedUniforms;
    };
    let cachedAttributes;
    this.getAttributes = function() {
        if (cachedAttributes === undefined) cachedAttributes = fetchAttributeLocations(gl, program);
        return cachedAttributes;
    };
    this.destroy = function() {
        bindingStates.releaseStatesOfProgram(this);
        gl.deleteProgram(program);
        this.program = undefined;
    };
    this.name = parameters.shaderName;
    this.id = programIdCount++;
    this.cacheKey = cacheKey;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
}
const WebGLProgram11 = WebGLProgram12;
function WebGLPrograms2(renderer, cubemaps, extensions, capabilities, bindingStates) {
    const programs = [];
    const isWebGL2 = capabilities.isWebGL2;
    const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
    const floatVertexTextures = capabilities.floatVertexTextures;
    const maxVertexUniforms = capabilities.maxVertexUniforms;
    const vertexTextures = capabilities.vertexTextures;
    let precision = capabilities.precision;
    const shaderIDs = {
        MeshDepthMaterial: 'depth',
        MeshDistanceMaterial: 'distanceRGBA',
        MeshNormalMaterial: 'normal',
        MeshBasicMaterial: 'basic',
        MeshLambertMaterial: 'lambert',
        MeshPhongMaterial: 'phong',
        MeshToonMaterial: 'toon',
        MeshStandardMaterial: 'physical',
        MeshPhysicalMaterial: 'physical',
        MeshMatcapMaterial: 'matcap',
        LineBasicMaterial: 'basic',
        LineDashedMaterial: 'dashed',
        PointsMaterial: 'points',
        ShadowMaterial: 'shadow',
        SpriteMaterial: 'sprite'
    };
    const parameterNames = [
        "precision",
        "isWebGL2",
        "supportsVertexTextures",
        "outputEncoding",
        "instancing",
        "instancingColor",
        "map",
        "mapEncoding",
        "matcap",
        "matcapEncoding",
        "envMap",
        "envMapMode",
        "envMapEncoding",
        "envMapCubeUV",
        "lightMap",
        "lightMapEncoding",
        "aoMap",
        "emissiveMap",
        "emissiveMapEncoding",
        "bumpMap",
        "normalMap",
        "objectSpaceNormalMap",
        "tangentSpaceNormalMap",
        "clearcoatMap",
        "clearcoatRoughnessMap",
        "clearcoatNormalMap",
        "displacementMap",
        "specularMap",
        "roughnessMap",
        "metalnessMap",
        "gradientMap",
        "alphaMap",
        "combine",
        "vertexColors",
        "vertexTangents",
        "vertexUvs",
        "uvsVertexOnly",
        "fog",
        "useFog",
        "fogExp2",
        "flatShading",
        "sizeAttenuation",
        "logarithmicDepthBuffer",
        "skinning",
        "maxBones",
        "useVertexTexture",
        "morphTargets",
        "morphNormals",
        "maxMorphTargets",
        "maxMorphNormals",
        "premultipliedAlpha",
        "numDirLights",
        "numPointLights",
        "numSpotLights",
        "numHemiLights",
        "numRectAreaLights",
        "numDirLightShadows",
        "numPointLightShadows",
        "numSpotLightShadows",
        "shadowMapEnabled",
        "shadowMapType",
        "toneMapping",
        'physicallyCorrectLights',
        "alphaTest",
        "doubleSided",
        "flipSided",
        "numClippingPlanes",
        "numClipIntersection",
        "depthPacking",
        "dithering",
        "sheen",
        "transmissionMap"
    ];
    function allocateBones(object) {
        const skeleton = object.skeleton;
        const bones = skeleton.bones;
        if (floatVertexTextures) return 1024;
        else {
            const nVertexUniforms = maxVertexUniforms;
            const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
            const maxBones = Math.min(nVertexMatrices, bones.length);
            if (maxBones < bones.length) {
                console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
                return 0;
            }
            return maxBones;
        }
    }
    function getTextureEncodingFromMap(map) {
        let encoding;
        if (!map) encoding = LinearEncoding;
        else if (map.isTexture) encoding = map.encoding;
        else if (map.isWebGLRenderTarget) {
            console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
            encoding = map.texture.encoding;
        }
        return encoding;
    }
    function getParameters(material, lights, shadows, scene, nClipPlanes, nClipIntersection, object) {
        const fog = scene.fog;
        const environment = material.isMeshStandardMaterial ? scene.environment : null;
        const envMap = cubemaps.get(material.envMap || environment);
        const shaderID = shaderIDs[material.type];
        const maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
        if (material.precision !== null) {
            precision = capabilities.getMaxPrecision(material.precision);
            if (precision !== material.precision) console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
        }
        let vertexShader, fragmentShader;
        if (shaderID) {
            const shader = ShaderLib1[shaderID];
            vertexShader = shader.vertexShader;
            fragmentShader = shader.fragmentShader;
        } else {
            vertexShader = material.vertexShader;
            fragmentShader = material.fragmentShader;
        }
        const currentRenderTarget = renderer.getRenderTarget();
        const parameters = {
            isWebGL2: isWebGL2,
            shaderID: shaderID,
            shaderName: material.type,
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            defines: material.defines,
            isRawShaderMaterial: material.isRawShaderMaterial,
            isShaderMaterial: material.isShaderMaterial,
            precision: precision,
            instancing: object.isInstancedMesh === true,
            instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
            supportsVertexTextures: vertexTextures,
            outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
            map: !!material.map,
            mapEncoding: getTextureEncodingFromMap(material.map),
            matcap: !!material.matcap,
            matcapEncoding: getTextureEncodingFromMap(material.matcap),
            envMap: !!envMap,
            envMapMode: envMap && envMap.mapping,
            envMapEncoding: getTextureEncodingFromMap(envMap),
            envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
            lightMap: !!material.lightMap,
            lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
            aoMap: !!material.aoMap,
            emissiveMap: !!material.emissiveMap,
            emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
            bumpMap: !!material.bumpMap,
            normalMap: !!material.normalMap,
            objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
            tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
            clearcoatMap: !!material.clearcoatMap,
            clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
            clearcoatNormalMap: !!material.clearcoatNormalMap,
            displacementMap: !!material.displacementMap,
            roughnessMap: !!material.roughnessMap,
            metalnessMap: !!material.metalnessMap,
            specularMap: !!material.specularMap,
            alphaMap: !!material.alphaMap,
            gradientMap: !!material.gradientMap,
            sheen: !!material.sheen,
            transmissionMap: !!material.transmissionMap,
            combine: material.combine,
            vertexTangents: material.normalMap && material.vertexTangents,
            vertexColors: material.vertexColors,
            vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap,
            uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmissionMap) && !!material.displacementMap,
            fog: !!fog,
            useFog: material.fog,
            fogExp2: fog && fog.isFogExp2,
            flatShading: material.flatShading,
            sizeAttenuation: material.sizeAttenuation,
            logarithmicDepthBuffer: logarithmicDepthBuffer,
            skinning: material.skinning && maxBones > 0,
            maxBones: maxBones,
            useVertexTexture: floatVertexTextures,
            morphTargets: material.morphTargets,
            morphNormals: material.morphNormals,
            maxMorphTargets: renderer.maxMorphTargets,
            maxMorphNormals: renderer.maxMorphNormals,
            numDirLights: lights.directional.length,
            numPointLights: lights.point.length,
            numSpotLights: lights.spot.length,
            numRectAreaLights: lights.rectArea.length,
            numHemiLights: lights.hemi.length,
            numDirLightShadows: lights.directionalShadowMap.length,
            numPointLightShadows: lights.pointShadowMap.length,
            numSpotLightShadows: lights.spotShadowMap.length,
            numClippingPlanes: nClipPlanes,
            numClipIntersection: nClipIntersection,
            dithering: material.dithering,
            shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
            shadowMapType: renderer.shadowMap.type,
            toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
            physicallyCorrectLights: renderer.physicallyCorrectLights,
            premultipliedAlpha: material.premultipliedAlpha,
            alphaTest: material.alphaTest,
            doubleSided: material.side === DoubleSide,
            flipSided: material.side === BackSide,
            depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
            index0AttributeName: material.index0AttributeName,
            extensionDerivatives: material.extensions && material.extensions.derivatives,
            extensionFragDepth: material.extensions && material.extensions.fragDepth,
            extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
            extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: isWebGL2 || extensions.get('EXT_frag_depth') !== null,
            rendererExtensionDrawBuffers: isWebGL2 || extensions.get('WEBGL_draw_buffers') !== null,
            rendererExtensionShaderTextureLod: isWebGL2 || extensions.get('EXT_shader_texture_lod') !== null,
            customProgramCacheKey: material.customProgramCacheKey()
        };
        return parameters;
    }
    function getProgramCacheKey(parameters) {
        const array = [];
        if (parameters.shaderID) array.push(parameters.shaderID);
        else {
            array.push(parameters.fragmentShader);
            array.push(parameters.vertexShader);
        }
        if (parameters.defines !== undefined) for(const name in parameters.defines){
            array.push(name);
            array.push(parameters.defines[name]);
        }
        if (parameters.isRawShaderMaterial === undefined) {
            for(let i1 = 0; i1 < parameterNames.length; i1++)array.push(parameters[parameterNames[i1]]);
            array.push(renderer.outputEncoding);
            array.push(renderer.gammaFactor);
        }
        array.push(parameters.customProgramCacheKey);
        return array.join();
    }
    function getUniforms(material) {
        const shaderID = shaderIDs[material.type];
        let uniforms;
        if (shaderID) {
            const shader = ShaderLib1[shaderID];
            uniforms = UniformsUtils1.clone(shader.uniforms);
        } else uniforms = material.uniforms;
        return uniforms;
    }
    function acquireProgram(parameters, cacheKey) {
        let program;
        for(let p = 0, pl = programs.length; p < pl; p++){
            const preexistingProgram = programs[p];
            if (preexistingProgram.cacheKey === cacheKey) {
                program = preexistingProgram;
                ++program.usedTimes;
                break;
            }
        }
        if (program === undefined) {
            program = new WebGLProgram11(renderer, cacheKey, parameters, bindingStates);
            programs.push(program);
        }
        return program;
    }
    function releaseProgram(program) {
        if ((--program.usedTimes) === 0) {
            const i1 = programs.indexOf(program);
            programs[i1] = programs[programs.length - 1];
            programs.pop();
            program.destroy();
        }
    }
    return {
        getParameters: getParameters,
        getProgramCacheKey: getProgramCacheKey,
        getUniforms: getUniforms,
        acquireProgram: acquireProgram,
        releaseProgram: releaseProgram,
        programs: programs
    };
}
const WebGLPrograms1 = WebGLPrograms2;
function WebGLProperties2() {
    let properties = new WeakMap();
    function get(object) {
        let map = properties.get(object);
        if (map === undefined) {
            map = {
            };
            properties.set(object, map);
        }
        return map;
    }
    function remove(object) {
        properties.delete(object);
    }
    function update(object, key, value) {
        properties.get(object)[key] = value;
    }
    function dispose() {
        properties = new WeakMap();
    }
    return {
        get: get,
        remove: remove,
        update: update,
        dispose: dispose
    };
}
const WebGLProperties1 = WebGLProperties2;
function painterSortStable(a2, b2) {
    if (a2.groupOrder !== b2.groupOrder) return a2.groupOrder - b2.groupOrder;
    else if (a2.renderOrder !== b2.renderOrder) return a2.renderOrder - b2.renderOrder;
    else if (a2.program !== b2.program) return a2.program.id - b2.program.id;
    else if (a2.material.id !== b2.material.id) return a2.material.id - b2.material.id;
    else if (a2.z !== b2.z) return a2.z - b2.z;
    else return a2.id - b2.id;
}
function reversePainterSortStable(a2, b2) {
    if (a2.groupOrder !== b2.groupOrder) return a2.groupOrder - b2.groupOrder;
    else if (a2.renderOrder !== b2.renderOrder) return a2.renderOrder - b2.renderOrder;
    else if (a2.z !== b2.z) return b2.z - a2.z;
    else return a2.id - b2.id;
}
function WebGLRenderList(properties) {
    const renderItems = [];
    let renderItemsIndex = 0;
    const opaque = [];
    const transparent = [];
    const defaultProgram = {
        id: -1
    };
    function init() {
        renderItemsIndex = 0;
        opaque.length = 0;
        transparent.length = 0;
    }
    function getNextRenderItem(object, geometry, material, groupOrder, z5, group) {
        let renderItem = renderItems[renderItemsIndex];
        const materialProperties = properties.get(material);
        if (renderItem === undefined) {
            renderItem = {
                id: object.id,
                object: object,
                geometry: geometry,
                material: material,
                program: materialProperties.program || defaultProgram,
                groupOrder: groupOrder,
                renderOrder: object.renderOrder,
                z: z5,
                group: group
            };
            renderItems[renderItemsIndex] = renderItem;
        } else {
            renderItem.id = object.id;
            renderItem.object = object;
            renderItem.geometry = geometry;
            renderItem.material = material;
            renderItem.program = materialProperties.program || defaultProgram;
            renderItem.groupOrder = groupOrder;
            renderItem.renderOrder = object.renderOrder;
            renderItem.z = z5;
            renderItem.group = group;
        }
        renderItemsIndex++;
        return renderItem;
    }
    function push(object, geometry, material, groupOrder, z5, group) {
        const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z5, group);
        (material.transparent === true ? transparent : opaque).push(renderItem);
    }
    function unshift(object, geometry, material, groupOrder, z5, group) {
        const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z5, group);
        (material.transparent === true ? transparent : opaque).unshift(renderItem);
    }
    function sort(customOpaqueSort, customTransparentSort) {
        if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
        if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
    }
    function finish() {
        for(let i1 = renderItemsIndex, il = renderItems.length; i1 < il; i1++){
            const renderItem = renderItems[i1];
            if (renderItem.id === null) break;
            renderItem.id = null;
            renderItem.object = null;
            renderItem.geometry = null;
            renderItem.material = null;
            renderItem.program = null;
            renderItem.group = null;
        }
    }
    return {
        opaque: opaque,
        transparent: transparent,
        init: init,
        push: push,
        unshift: unshift,
        finish: finish,
        sort: sort
    };
}
function WebGLRenderLists2(properties) {
    let lists = new WeakMap();
    function get(scene, camera) {
        const cameras = lists.get(scene);
        let list;
        if (cameras === undefined) {
            list = new WebGLRenderList(properties);
            lists.set(scene, new WeakMap());
            lists.get(scene).set(camera, list);
        } else {
            list = cameras.get(camera);
            if (list === undefined) {
                list = new WebGLRenderList(properties);
                cameras.set(camera, list);
            }
        }
        return list;
    }
    function dispose() {
        lists = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
const WebGLRenderLists1 = WebGLRenderLists2;
function UniformsCache() {
    const lights = {
    };
    return {
        get: function(light) {
            if (lights[light.id] !== undefined) return lights[light.id];
            let uniforms;
            switch(light.type){
                case 'DirectionalLight':
                    uniforms = {
                        direction: new Vector31(),
                        color: new Color1()
                    };
                    break;
                case 'SpotLight':
                    uniforms = {
                        position: new Vector31(),
                        direction: new Vector31(),
                        color: new Color1(),
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case 'PointLight':
                    uniforms = {
                        position: new Vector31(),
                        color: new Color1(),
                        distance: 0,
                        decay: 0
                    };
                    break;
                case 'HemisphereLight':
                    uniforms = {
                        direction: new Vector31(),
                        skyColor: new Color1(),
                        groundColor: new Color1()
                    };
                    break;
                case 'RectAreaLight':
                    uniforms = {
                        color: new Color1(),
                        position: new Vector31(),
                        halfWidth: new Vector31(),
                        halfHeight: new Vector31()
                    };
                    break;
            }
            lights[light.id] = uniforms;
            return uniforms;
        }
    };
}
function ShadowUniformsCache() {
    const lights = {
    };
    return {
        get: function(light) {
            if (lights[light.id] !== undefined) return lights[light.id];
            let uniforms;
            switch(light.type){
                case 'DirectionalLight':
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector21()
                    };
                    break;
                case 'SpotLight':
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector21()
                    };
                    break;
                case 'PointLight':
                    uniforms = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Vector21(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1000
                    };
                    break;
            }
            lights[light.id] = uniforms;
            return uniforms;
        }
    };
}
let nextVersion = 0;
function shadowCastingLightsFirst(lightA, lightB) {
    return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights2() {
    const cache = new UniformsCache();
    const shadowCache = ShadowUniformsCache();
    const state = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
        },
        ambient: [
            0,
            0,
            0
        ],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadow: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: []
    };
    for(let i1 = 0; i1 < 9; i1++)state.probe.push(new Vector31());
    const vector3 = new Vector31();
    const matrix4 = new Matrix41();
    const matrix42 = new Matrix41();
    function setup(lights, shadows, camera) {
        let r = 0, g = 0, b2 = 0;
        for(let i11 = 0; i11 < 9; i11++)state.probe[i11].set(0, 0, 0);
        let directionalLength = 0;
        let pointLength = 0;
        let spotLength = 0;
        let rectAreaLength = 0;
        let hemiLength = 0;
        let numDirectionalShadows = 0;
        let numPointShadows = 0;
        let numSpotShadows = 0;
        const viewMatrix = camera.matrixWorldInverse;
        lights.sort(shadowCastingLightsFirst);
        for(let i11 = 0, l = lights.length; i11 < l; i11++){
            const light = lights[i11];
            const color1 = light.color;
            const intensity = light.intensity;
            const distance = light.distance;
            const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
            if (light.isAmbientLight) {
                r += color1.r * intensity;
                g += color1.g * intensity;
                b2 += color1.b * intensity;
            } else if (light.isLightProbe) for(let j = 0; j < 9; j++)state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
            else if (light.isDirectionalLight) {
                const uniforms = cache.get(light);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(vector3);
                uniforms.direction.transformDirection(viewMatrix);
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    state.directionalShadow[directionalLength] = shadowUniforms;
                    state.directionalShadowMap[directionalLength] = shadowMap;
                    state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                    numDirectionalShadows++;
                }
                state.directional[directionalLength] = uniforms;
                directionalLength++;
            } else if (light.isSpotLight) {
                const uniforms = cache.get(light);
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                uniforms.color.copy(color1).multiplyScalar(intensity);
                uniforms.distance = distance;
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                vector3.setFromMatrixPosition(light.target.matrixWorld);
                uniforms.direction.sub(vector3);
                uniforms.direction.transformDirection(viewMatrix);
                uniforms.coneCos = Math.cos(light.angle);
                uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                uniforms.decay = light.decay;
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    state.spotShadow[spotLength] = shadowUniforms;
                    state.spotShadowMap[spotLength] = shadowMap;
                    state.spotShadowMatrix[spotLength] = light.shadow.matrix;
                    numSpotShadows++;
                }
                state.spot[spotLength] = uniforms;
                spotLength++;
            } else if (light.isRectAreaLight) {
                const uniforms = cache.get(light);
                uniforms.color.copy(color1).multiplyScalar(intensity);
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                matrix42.identity();
                matrix4.copy(light.matrixWorld);
                matrix4.premultiply(viewMatrix);
                matrix42.extractRotation(matrix4);
                uniforms.halfWidth.set(light.width * 0.5, 0, 0);
                uniforms.halfHeight.set(0, light.height * 0.5, 0);
                uniforms.halfWidth.applyMatrix4(matrix42);
                uniforms.halfHeight.applyMatrix4(matrix42);
                state.rectArea[rectAreaLength] = uniforms;
                rectAreaLength++;
            } else if (light.isPointLight) {
                const uniforms = cache.get(light);
                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                uniforms.position.applyMatrix4(viewMatrix);
                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                uniforms.distance = light.distance;
                uniforms.decay = light.decay;
                if (light.castShadow) {
                    const shadow = light.shadow;
                    const shadowUniforms = shadowCache.get(light);
                    shadowUniforms.shadowBias = shadow.bias;
                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                    shadowUniforms.shadowRadius = shadow.radius;
                    shadowUniforms.shadowMapSize = shadow.mapSize;
                    shadowUniforms.shadowCameraNear = shadow.camera.near;
                    shadowUniforms.shadowCameraFar = shadow.camera.far;
                    state.pointShadow[pointLength] = shadowUniforms;
                    state.pointShadowMap[pointLength] = shadowMap;
                    state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                    numPointShadows++;
                }
                state.point[pointLength] = uniforms;
                pointLength++;
            } else if (light.isHemisphereLight) {
                const uniforms = cache.get(light);
                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                uniforms.direction.transformDirection(viewMatrix);
                uniforms.direction.normalize();
                uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
                state.hemi[hemiLength] = uniforms;
                hemiLength++;
            }
        }
        state.ambient[0] = r;
        state.ambient[1] = g;
        state.ambient[2] = b2;
        const hash = state.hash;
        if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
            state.directional.length = directionalLength;
            state.spot.length = spotLength;
            state.rectArea.length = rectAreaLength;
            state.point.length = pointLength;
            state.hemi.length = hemiLength;
            state.directionalShadow.length = numDirectionalShadows;
            state.directionalShadowMap.length = numDirectionalShadows;
            state.pointShadow.length = numPointShadows;
            state.pointShadowMap.length = numPointShadows;
            state.spotShadow.length = numSpotShadows;
            state.spotShadowMap.length = numSpotShadows;
            state.directionalShadowMatrix.length = numDirectionalShadows;
            state.pointShadowMatrix.length = numPointShadows;
            state.spotShadowMatrix.length = numSpotShadows;
            hash.directionalLength = directionalLength;
            hash.pointLength = pointLength;
            hash.spotLength = spotLength;
            hash.rectAreaLength = rectAreaLength;
            hash.hemiLength = hemiLength;
            hash.numDirectionalShadows = numDirectionalShadows;
            hash.numPointShadows = numPointShadows;
            hash.numSpotShadows = numSpotShadows;
            state.version = nextVersion++;
        }
    }
    return {
        setup: setup,
        state: state
    };
}
const WebGLLights1 = WebGLLights2;
function WebGLRenderState() {
    const lights = new WebGLLights1();
    const lightsArray = [];
    const shadowsArray = [];
    function init() {
        lightsArray.length = 0;
        shadowsArray.length = 0;
    }
    function pushLight(light) {
        lightsArray.push(light);
    }
    function pushShadow(shadowLight) {
        shadowsArray.push(shadowLight);
    }
    function setupLights(camera) {
        lights.setup(lightsArray, shadowsArray, camera);
    }
    const state = {
        lightsArray: lightsArray,
        shadowsArray: shadowsArray,
        lights: lights
    };
    return {
        init: init,
        state: state,
        setupLights: setupLights,
        pushLight: pushLight,
        pushShadow: pushShadow
    };
}
function WebGLRenderStates2() {
    let renderStates = new WeakMap();
    function get(scene, camera) {
        let renderState;
        if (renderStates.has(scene) === false) {
            renderState = new WebGLRenderState();
            renderStates.set(scene, new WeakMap());
            renderStates.get(scene).set(camera, renderState);
        } else if (renderStates.get(scene).has(camera) === false) {
            renderState = new WebGLRenderState();
            renderStates.get(scene).set(camera, renderState);
        } else renderState = renderStates.get(scene).get(camera);
        return renderState;
    }
    function dispose() {
        renderStates = new WeakMap();
    }
    return {
        get: get,
        dispose: dispose
    };
}
const WebGLRenderStates1 = WebGLRenderStates2;
const vsm_frag = `\nuniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n\n#include <packing>\n\nvoid main() {\n\n	float mean = 0.0;\n	float squared_mean = 0.0;\n\n	// This seems totally useless but it's a crazy work around for a Adreno compiler bug\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\n	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\n		#ifdef HORIZONAL_PASS\n\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\n		#else\n\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n\n		#endif\n\n	}\n\n	mean = mean * HALF_SAMPLE_RATE;\n	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n\n	float std_dev = sqrt( squared_mean - mean * mean );\n\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n\n}\n`;
const vsm_vert = `\nvoid main() {\n\n	gl_Position = vec4( position, 1.0 );\n\n}\n`;
function WebGLShadowMap2(_renderer, _objects, maxTextureSize) {
    let _frustum = new Frustum1();
    const _shadowMapSize = new Vector21(), _viewportSize = new Vector21(), _viewport = new Vector41(), _depthMaterials = [], _distanceMaterials = [], _materialCache = {
    };
    const shadowSide = {
        0: BackSide,
        1: FrontSide,
        2: DoubleSide
    };
    const shadowMaterialVertical = new ShaderMaterial1({
        defines: {
            SAMPLE_RATE: 0.25,
            HALF_SAMPLE_RATE: 0.125
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new Vector21()
            },
            radius: {
                value: 4
            }
        },
        vertexShader: vsm_vert,
        fragmentShader: vsm_frag
    });
    const shadowMaterialHorizonal = shadowMaterialVertical.clone();
    shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;
    const fullScreenTri = new BufferGeometry1();
    fullScreenTri.setAttribute("position", new BufferAttribute1(new Float32Array([
        -1,
        -1,
        0.5,
        3,
        -1,
        0.5,
        -1,
        3,
        0.5
    ]), 3));
    const fullScreenMesh = new Mesh1(fullScreenTri, shadowMaterialVertical);
    const scope1 = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = PCFShadowMap;
    this.render = function(lights, scene, camera) {
        if (scope1.enabled === false) return;
        if (scope1.autoUpdate === false && scope1.needsUpdate === false) return;
        if (lights.length === 0) return;
        const currentRenderTarget = _renderer.getRenderTarget();
        const activeCubeFace = _renderer.getActiveCubeFace();
        const activeMipmapLevel = _renderer.getActiveMipmapLevel();
        const _state = _renderer.state;
        _state.setBlending(NoBlending);
        _state.buffers.color.setClear(1, 1, 1, 1);
        _state.buffers.depth.setTest(true);
        _state.setScissorTest(false);
        for(let i1 = 0, il = lights.length; i1 < il; i1++){
            const light = lights[i1];
            const shadow = light.shadow;
            if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
            if (shadow === undefined) {
                console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
                continue;
            }
            _shadowMapSize.copy(shadow.mapSize);
            const shadowFrameExtents = shadow.getFrameExtents();
            _shadowMapSize.multiply(shadowFrameExtents);
            _viewportSize.copy(shadow.mapSize);
            if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
                if (_shadowMapSize.x > maxTextureSize) {
                    _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
                    _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
                    shadow.mapSize.x = _viewportSize.x;
                }
                if (_shadowMapSize.y > maxTextureSize) {
                    _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
                    _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
                    shadow.mapSize.y = _viewportSize.y;
                }
            }
            if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
                const pars = {
                    minFilter: LinearFilter,
                    magFilter: LinearFilter,
                    format: RGBAFormat,
                    stencilBuffer: false
                };
                shadow.map = new WebGLRenderTarget1(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.map.texture.name = light.name + ".shadowMap";
                shadow.mapPass = new WebGLRenderTarget1(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.camera.updateProjectionMatrix();
            }
            if (shadow.map === null) {
                const pars = {
                    minFilter: NearestFilter,
                    magFilter: NearestFilter,
                    format: RGBAFormat,
                    stencilBuffer: false
                };
                shadow.map = new WebGLRenderTarget1(_shadowMapSize.x, _shadowMapSize.y, pars);
                shadow.map.texture.name = light.name + ".shadowMap";
                shadow.camera.updateProjectionMatrix();
            }
            _renderer.setRenderTarget(shadow.map);
            _renderer.clear();
            const viewportCount = shadow.getViewportCount();
            for(let vp = 0; vp < viewportCount; vp++){
                const viewport = shadow.getViewport(vp);
                _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
                _state.viewport(_viewport);
                shadow.updateMatrices(light, vp);
                _frustum = shadow.getFrustum();
                renderObject(scene, camera, shadow.camera, light, this.type);
            }
            if (!shadow.isPointLightShadow && this.type === VSMShadowMap) VSMPass(shadow, camera);
            shadow.needsUpdate = false;
        }
        scope1.needsUpdate = false;
        _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };
    function VSMPass(shadow, camera) {
        const geometry = _objects.update(fullScreenMesh);
        shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
        shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialVertical.uniforms.radius.value = shadow.radius;
        _renderer.setRenderTarget(shadow.mapPass);
        _renderer.clear();
        _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
        shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
        shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
        shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;
        _renderer.setRenderTarget(shadow.map);
        _renderer.clear();
        _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null);
    }
    function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
        const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
        let material = _depthMaterials[index];
        if (material === undefined) {
            material = new MeshDepthMaterial1({
                depthPacking: RGBADepthPacking,
                morphTargets: useMorphing,
                skinning: useSkinning
            });
            _depthMaterials[index] = material;
        }
        return material;
    }
    function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
        const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
        let material = _distanceMaterials[index];
        if (material === undefined) {
            material = new MeshDistanceMaterial1({
                morphTargets: useMorphing,
                skinning: useSkinning
            });
            _distanceMaterials[index] = material;
        }
        return material;
    }
    function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
        let result = null;
        let getMaterialVariant = getDepthMaterialVariant;
        let customMaterial = object.customDepthMaterial;
        if (light.isPointLight === true) {
            getMaterialVariant = getDistanceMaterialVariant;
            customMaterial = object.customDistanceMaterial;
        }
        if (customMaterial === undefined) {
            let useMorphing = false;
            if (material.morphTargets === true) useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
            let useSkinning = false;
            if (object.isSkinnedMesh === true) {
                if (material.skinning === true) useSkinning = true;
                else console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object);
            }
            const useInstancing = object.isInstancedMesh === true;
            result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
        } else result = customMaterial;
        if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
            const keyA = result.uuid, keyB = material.uuid;
            let materialsForVariant = _materialCache[keyA];
            if (materialsForVariant === undefined) {
                materialsForVariant = {
                };
                _materialCache[keyA] = materialsForVariant;
            }
            let cachedMaterial = materialsForVariant[keyB];
            if (cachedMaterial === undefined) {
                cachedMaterial = result.clone();
                materialsForVariant[keyB] = cachedMaterial;
            }
            result = cachedMaterial;
        }
        result.visible = material.visible;
        result.wireframe = material.wireframe;
        if (type === VSMShadowMap) result.side = material.shadowSide !== null ? material.shadowSide : material.side;
        else result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
        result.clipShadows = material.clipShadows;
        result.clippingPlanes = material.clippingPlanes;
        result.clipIntersection = material.clipIntersection;
        result.wireframeLinewidth = material.wireframeLinewidth;
        result.linewidth = material.linewidth;
        if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
            result.referencePosition.setFromMatrixPosition(light.matrixWorld);
            result.nearDistance = shadowCameraNear;
            result.farDistance = shadowCameraFar;
        }
        return result;
    }
    function renderObject(object, camera, shadowCamera, light, type) {
        if (object.visible === false) return;
        const visible = object.layers.test(camera.layers);
        if (visible && (object.isMesh || object.isLine || object.isPoints)) {
            if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
                object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                const geometry = _objects.update(object);
                const material = object.material;
                if (Array.isArray(material)) {
                    const groups = geometry.groups;
                    for(let k = 0, kl = groups.length; k < kl; k++){
                        const group = groups[k];
                        const groupMaterial = material[group.materialIndex];
                        if (groupMaterial && groupMaterial.visible) {
                            const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                        }
                    }
                } else if (material.visible) {
                    const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);
                    _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                }
            }
        }
        const children = object.children;
        for(let i1 = 0, l = children.length; i1 < l; i1++)renderObject(children[i1], camera, shadowCamera, light, type);
    }
}
const WebGLShadowMap1 = WebGLShadowMap2;
function WebGLState2(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function ColorBuffer() {
        let locked = false;
        const color1 = new Vector41();
        let currentColorMask = null;
        const currentColorClear = new Vector41(0, 0, 0, 0);
        return {
            setMask: function(colorMask) {
                if (currentColorMask !== colorMask && !locked) {
                    gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                    currentColorMask = colorMask;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(r, g, b2, a2, premultipliedAlpha) {
                if (premultipliedAlpha === true) {
                    r *= a2;
                    g *= a2;
                    b2 *= a2;
                }
                color1.set(r, g, b2, a2);
                if (currentColorClear.equals(color1) === false) {
                    gl.clearColor(r, g, b2, a2);
                    currentColorClear.copy(color1);
                }
            },
            reset: function() {
                locked = false;
                currentColorMask = null;
                currentColorClear.set(-1, 0, 0, 0);
            }
        };
    }
    function DepthBuffer() {
        let locked = false;
        let currentDepthMask = null;
        let currentDepthFunc = null;
        let currentDepthClear = null;
        return {
            setTest: function(depthTest) {
                if (depthTest) enable(gl.DEPTH_TEST);
                else disable(gl.DEPTH_TEST);
            },
            setMask: function(depthMask) {
                if (currentDepthMask !== depthMask && !locked) {
                    gl.depthMask(depthMask);
                    currentDepthMask = depthMask;
                }
            },
            setFunc: function(depthFunc) {
                if (currentDepthFunc !== depthFunc) {
                    if (depthFunc) switch(depthFunc){
                        case NeverDepth:
                            gl.depthFunc(gl.NEVER);
                            break;
                        case AlwaysDepth:
                            gl.depthFunc(gl.ALWAYS);
                            break;
                        case LessDepth:
                            gl.depthFunc(gl.LESS);
                            break;
                        case LessEqualDepth:
                            gl.depthFunc(gl.LEQUAL);
                            break;
                        case EqualDepth:
                            gl.depthFunc(gl.EQUAL);
                            break;
                        case GreaterEqualDepth:
                            gl.depthFunc(gl.GEQUAL);
                            break;
                        case GreaterDepth:
                            gl.depthFunc(gl.GREATER);
                            break;
                        case NotEqualDepth:
                            gl.depthFunc(gl.NOTEQUAL);
                            break;
                        default:
                            gl.depthFunc(gl.LEQUAL);
                    }
                    else gl.depthFunc(gl.LEQUAL);
                    currentDepthFunc = depthFunc;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(depth1) {
                if (currentDepthClear !== depth1) {
                    gl.clearDepth(depth1);
                    currentDepthClear = depth1;
                }
            },
            reset: function() {
                locked = false;
                currentDepthMask = null;
                currentDepthFunc = null;
                currentDepthClear = null;
            }
        };
    }
    function StencilBuffer() {
        let locked = false;
        let currentStencilMask = null;
        let currentStencilFunc = null;
        let currentStencilRef = null;
        let currentStencilFuncMask = null;
        let currentStencilFail = null;
        let currentStencilZFail = null;
        let currentStencilZPass = null;
        let currentStencilClear = null;
        return {
            setTest: function(stencilTest) {
                if (!locked) {
                    if (stencilTest) enable(gl.STENCIL_TEST);
                    else disable(gl.STENCIL_TEST);
                }
            },
            setMask: function(stencilMask) {
                if (currentStencilMask !== stencilMask && !locked) {
                    gl.stencilMask(stencilMask);
                    currentStencilMask = stencilMask;
                }
            },
            setFunc: function(stencilFunc, stencilRef, stencilMask) {
                if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                    gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                    currentStencilFunc = stencilFunc;
                    currentStencilRef = stencilRef;
                    currentStencilFuncMask = stencilMask;
                }
            },
            setOp: function(stencilFail, stencilZFail, stencilZPass) {
                if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                    gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                    currentStencilFail = stencilFail;
                    currentStencilZFail = stencilZFail;
                    currentStencilZPass = stencilZPass;
                }
            },
            setLocked: function(lock) {
                locked = lock;
            },
            setClear: function(stencil) {
                if (currentStencilClear !== stencil) {
                    gl.clearStencil(stencil);
                    currentStencilClear = stencil;
                }
            },
            reset: function() {
                locked = false;
                currentStencilMask = null;
                currentStencilFunc = null;
                currentStencilRef = null;
                currentStencilFuncMask = null;
                currentStencilFail = null;
                currentStencilZFail = null;
                currentStencilZPass = null;
                currentStencilClear = null;
            }
        };
    }
    const colorBuffer = new ColorBuffer();
    const depthBuffer = new DepthBuffer();
    const stencilBuffer = new StencilBuffer();
    let enabledCapabilities = {
    };
    let currentProgram = null;
    let currentBlendingEnabled = null;
    let currentBlending = null;
    let currentBlendEquation = null;
    let currentBlendSrc = null;
    let currentBlendDst = null;
    let currentBlendEquationAlpha = null;
    let currentBlendSrcAlpha = null;
    let currentBlendDstAlpha = null;
    let currentPremultipledAlpha = false;
    let currentFlipSided = null;
    let currentCullFace = null;
    let currentLineWidth = null;
    let currentPolygonOffsetFactor = null;
    let currentPolygonOffsetUnits = null;
    const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let lineWidthAvailable = false;
    let version = 0;
    const glVersion = gl.getParameter(gl.VERSION);
    if (glVersion.indexOf('WebGL') !== -1) {
        version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 1;
    } else if (glVersion.indexOf('OpenGL ES') !== -1) {
        version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
        lineWidthAvailable = version >= 2;
    }
    let currentTextureSlot = null;
    let currentBoundTextures = {
    };
    const currentScissor = new Vector41();
    const currentViewport = new Vector41();
    function createTexture(type, target, count) {
        const data = new Uint8Array(4);
        const texture = gl.createTexture();
        gl.bindTexture(type, texture);
        gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        for(let i1 = 0; i1 < count; i1++)gl.texImage2D(target + i1, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        return texture;
    }
    const emptyTextures = {
    };
    emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
    emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(gl.DEPTH_TEST);
    depthBuffer.setFunc(LessEqualDepth);
    setFlipSided(false);
    setCullFace(CullFaceBack);
    enable(gl.CULL_FACE);
    setBlending(NoBlending);
    function enable(id) {
        if (enabledCapabilities[id] !== true) {
            gl.enable(id);
            enabledCapabilities[id] = true;
        }
    }
    function disable(id) {
        if (enabledCapabilities[id] !== false) {
            gl.disable(id);
            enabledCapabilities[id] = false;
        }
    }
    function useProgram(program) {
        if (currentProgram !== program) {
            gl.useProgram(program);
            currentProgram = program;
            return true;
        }
        return false;
    }
    const equationToGL = {
        [AddEquation]: gl.FUNC_ADD,
        [SubtractEquation]: gl.FUNC_SUBTRACT,
        [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
    };
    if (isWebGL2) {
        equationToGL[MinEquation] = gl.MIN;
        equationToGL[MaxEquation] = gl.MAX;
    } else {
        const extension = extensions.get('EXT_blend_minmax');
        if (extension !== null) {
            equationToGL[MinEquation] = extension.MIN_EXT;
            equationToGL[MaxEquation] = extension.MAX_EXT;
        }
    }
    const factorToGL = {
        [ZeroFactor]: gl.ZERO,
        [OneFactor]: gl.ONE,
        [SrcColorFactor]: gl.SRC_COLOR,
        [SrcAlphaFactor]: gl.SRC_ALPHA,
        [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
        [DstColorFactor]: gl.DST_COLOR,
        [DstAlphaFactor]: gl.DST_ALPHA,
        [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
        [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
        [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
        [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
    };
    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
        if (blending === NoBlending) {
            if (currentBlendingEnabled) {
                disable(gl.BLEND);
                currentBlendingEnabled = false;
            }
            return;
        }
        if (!currentBlendingEnabled) {
            enable(gl.BLEND);
            currentBlendingEnabled = true;
        }
        if (blending !== CustomBlending) {
            if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
                if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
                    gl.blendEquation(gl.FUNC_ADD);
                    currentBlendEquation = AddEquation;
                    currentBlendEquationAlpha = AddEquation;
                }
                if (premultipliedAlpha) switch(blending){
                    case NormalBlending:
                        gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                        break;
                    case AdditiveBlending:
                        gl.blendFunc(gl.ONE, gl.ONE);
                        break;
                    case SubtractiveBlending:
                        gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
                        break;
                    case MultiplyBlending:
                        gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
                        break;
                    default:
                        console.error('THREE.WebGLState: Invalid blending: ', blending);
                        break;
                }
                else switch(blending){
                    case NormalBlending:
                        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                        break;
                    case AdditiveBlending:
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                        break;
                    case SubtractiveBlending:
                        gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
                        break;
                    case MultiplyBlending:
                        gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                        break;
                    default:
                        console.error('THREE.WebGLState: Invalid blending: ', blending);
                        break;
                }
                currentBlendSrc = null;
                currentBlendDst = null;
                currentBlendSrcAlpha = null;
                currentBlendDstAlpha = null;
                currentBlending = blending;
                currentPremultipledAlpha = premultipliedAlpha;
            }
            return;
        }
        blendEquationAlpha = blendEquationAlpha || blendEquation;
        blendSrcAlpha = blendSrcAlpha || blendSrc;
        blendDstAlpha = blendDstAlpha || blendDst;
        if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
            gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
            currentBlendEquation = blendEquation;
            currentBlendEquationAlpha = blendEquationAlpha;
        }
        if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
            gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
            currentBlendSrc = blendSrc;
            currentBlendDst = blendDst;
            currentBlendSrcAlpha = blendSrcAlpha;
            currentBlendDstAlpha = blendDstAlpha;
        }
        currentBlending = blending;
        currentPremultipledAlpha = null;
    }
    function setMaterial(material, frontFaceCW) {
        material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
        let flipSided = material.side === BackSide;
        if (frontFaceCW) flipSided = !flipSided;
        setFlipSided(flipSided);
        material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
        depthBuffer.setFunc(material.depthFunc);
        depthBuffer.setTest(material.depthTest);
        depthBuffer.setMask(material.depthWrite);
        colorBuffer.setMask(material.colorWrite);
        const stencilWrite = material.stencilWrite;
        stencilBuffer.setTest(stencilWrite);
        if (stencilWrite) {
            stencilBuffer.setMask(material.stencilWriteMask);
            stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
            stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
        }
        setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    }
    function setFlipSided(flipSided) {
        if (currentFlipSided !== flipSided) {
            if (flipSided) gl.frontFace(gl.CW);
            else gl.frontFace(gl.CCW);
            currentFlipSided = flipSided;
        }
    }
    function setCullFace(cullFace) {
        if (cullFace !== CullFaceNone) {
            enable(gl.CULL_FACE);
            if (cullFace !== currentCullFace) {
                if (cullFace === CullFaceBack) gl.cullFace(gl.BACK);
                else if (cullFace === CullFaceFront) gl.cullFace(gl.FRONT);
                else gl.cullFace(gl.FRONT_AND_BACK);
            }
        } else disable(gl.CULL_FACE);
        currentCullFace = cullFace;
    }
    function setLineWidth(width2) {
        if (width2 !== currentLineWidth) {
            if (lineWidthAvailable) gl.lineWidth(width2);
            currentLineWidth = width2;
        }
    }
    function setPolygonOffset(polygonOffset, factor, units) {
        if (polygonOffset) {
            enable(gl.POLYGON_OFFSET_FILL);
            if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
                gl.polygonOffset(factor, units);
                currentPolygonOffsetFactor = factor;
                currentPolygonOffsetUnits = units;
            }
        } else disable(gl.POLYGON_OFFSET_FILL);
    }
    function setScissorTest(scissorTest) {
        if (scissorTest) enable(gl.SCISSOR_TEST);
        else disable(gl.SCISSOR_TEST);
    }
    function activeTexture(webglSlot) {
        if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;
        if (currentTextureSlot !== webglSlot) {
            gl.activeTexture(webglSlot);
            currentTextureSlot = webglSlot;
        }
    }
    function bindTexture(webglType, webglTexture) {
        if (currentTextureSlot === null) activeTexture();
        let boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture === undefined) {
            boundTexture = {
                type: undefined,
                texture: undefined
            };
            currentBoundTextures[currentTextureSlot] = boundTexture;
        }
        if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
            gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
            boundTexture.type = webglType;
            boundTexture.texture = webglTexture;
        }
    }
    function unbindTexture() {
        const boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture !== undefined && boundTexture.type !== undefined) {
            gl.bindTexture(boundTexture.type, null);
            boundTexture.type = undefined;
            boundTexture.texture = undefined;
        }
    }
    function compressedTexImage2D() {
        try {
            gl.compressedTexImage2D.apply(gl, arguments);
        } catch (error) {
            console.error('THREE.WebGLState:', error);
        }
    }
    function texImage2D() {
        try {
            gl.texImage2D.apply(gl, arguments);
        } catch (error) {
            console.error('THREE.WebGLState:', error);
        }
    }
    function texImage3D() {
        try {
            gl.texImage3D.apply(gl, arguments);
        } catch (error) {
            console.error('THREE.WebGLState:', error);
        }
    }
    function scissor(scissor1) {
        if (currentScissor.equals(scissor1) === false) {
            gl.scissor(scissor1.x, scissor1.y, scissor1.z, scissor1.w);
            currentScissor.copy(scissor1);
        }
    }
    function viewport(viewport1) {
        if (currentViewport.equals(viewport1) === false) {
            gl.viewport(viewport1.x, viewport1.y, viewport1.z, viewport1.w);
            currentViewport.copy(viewport1);
        }
    }
    function reset() {
        enabledCapabilities = {
        };
        currentTextureSlot = null;
        currentBoundTextures = {
        };
        currentProgram = null;
        currentBlending = null;
        currentFlipSided = null;
        currentCullFace = null;
        colorBuffer.reset();
        depthBuffer.reset();
        stencilBuffer.reset();
    }
    return {
        buffers: {
            color: colorBuffer,
            depth: depthBuffer,
            stencil: stencilBuffer
        },
        enable: enable,
        disable: disable,
        useProgram: useProgram,
        setBlending: setBlending,
        setMaterial: setMaterial,
        setFlipSided: setFlipSided,
        setCullFace: setCullFace,
        setLineWidth: setLineWidth,
        setPolygonOffset: setPolygonOffset,
        setScissorTest: setScissorTest,
        activeTexture: activeTexture,
        bindTexture: bindTexture,
        unbindTexture: unbindTexture,
        compressedTexImage2D: compressedTexImage2D,
        texImage2D: texImage2D,
        texImage3D: texImage3D,
        scissor: scissor,
        viewport: viewport,
        reset: reset
    };
}
const WebGLState1 = WebGLState2;
function WebGLTextures2(_gl, extensions, state, properties, capabilities, utils, info) {
    const isWebGL2 = capabilities.isWebGL2;
    const maxTextures = capabilities.maxTextures;
    const maxCubemapSize = capabilities.maxCubemapSize;
    const maxTextureSize = capabilities.maxTextureSize;
    const maxSamples = capabilities.maxSamples;
    const _videoTextures = new WeakMap();
    let _canvas1;
    let useOffscreenCanvas = false;
    try {
        useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch (err) {
    }
    function createCanvas(width2, height2) {
        return useOffscreenCanvas ? new OffscreenCanvas(width2, height2) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
    }
    function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
        let scale = 1;
        if (image.width > maxSize || image.height > maxSize) scale = maxSize / Math.max(image.width, image.height);
        if (scale < 1 || needsPowerOfTwo === true) {
            if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
                const floor = needsPowerOfTwo ? MathUtils1.floorPowerOfTwo : Math.floor;
                const width2 = floor(scale * image.width);
                const height2 = floor(scale * image.height);
                if (_canvas1 === undefined) _canvas1 = createCanvas(width2, height2);
                const canvas = needsNewCanvas ? createCanvas(width2, height2) : _canvas1;
                canvas.width = width2;
                canvas.height = height2;
                const context = canvas.getContext('2d');
                context.drawImage(image, 0, 0, width2, height2);
                console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width2 + 'x' + height2 + ').');
                return canvas;
            } else {
                if ('data' in image) console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
                return image;
            }
        }
        return image;
    }
    function isPowerOfTwo(image) {
        return MathUtils1.isPowerOfTwo(image.width) && MathUtils1.isPowerOfTwo(image.height);
    }
    function textureNeedsPowerOfTwo(texture) {
        if (isWebGL2) return false;
        return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function textureNeedsGenerateMipmaps(texture, supportsMips) {
        return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function generateMipmap(target, texture, width2, height2) {
        _gl.generateMipmap(target);
        const textureProperties = properties.get(texture);
        textureProperties.__maxMipLevel = Math.log(Math.max(width2, height2)) * Math.LOG2E;
    }
    function getInternalFormat(internalFormatName, glFormat, glType) {
        if (isWebGL2 === false) return glFormat;
        if (internalFormatName !== null) {
            if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
            console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
        }
        let internalFormat = glFormat;
        if (glFormat === _gl.RED) {
            if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
            if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
            if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
        }
        if (glFormat === _gl.RGB) {
            if (glType === _gl.FLOAT) internalFormat = _gl.RGB32F;
            if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGB16F;
            if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8;
        }
        if (glFormat === _gl.RGBA) {
            if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
            if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
            if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8;
        }
        if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) extensions.get('EXT_color_buffer_float');
        return internalFormat;
    }
    function filterFallback(f) {
        if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) return _gl.NEAREST;
        return _gl.LINEAR;
    }
    function onTextureDispose(event) {
        const texture = event.target;
        texture.removeEventListener('dispose', onTextureDispose);
        deallocateTexture(texture);
        if (texture.isVideoTexture) _videoTextures.delete(texture);
        info.memory.textures--;
    }
    function onRenderTargetDispose(event) {
        const renderTarget = event.target;
        renderTarget.removeEventListener('dispose', onRenderTargetDispose);
        deallocateRenderTarget(renderTarget);
        info.memory.textures--;
    }
    function deallocateTexture(texture) {
        const textureProperties = properties.get(texture);
        if (textureProperties.__webglInit === undefined) return;
        _gl.deleteTexture(textureProperties.__webglTexture);
        properties.remove(texture);
    }
    function deallocateRenderTarget(renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        const textureProperties = properties.get(renderTarget.texture);
        if (!renderTarget) return;
        if (textureProperties.__webglTexture !== undefined) _gl.deleteTexture(textureProperties.__webglTexture);
        if (renderTarget.depthTexture) renderTarget.depthTexture.dispose();
        if (renderTarget.isWebGLCubeRenderTarget) for(let i1 = 0; i1 < 6; i1++){
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i1]);
            if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i1]);
        }
        else {
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
            if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
            if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
            if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
            if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
        }
        properties.remove(renderTarget.texture);
        properties.remove(renderTarget);
    }
    let textureUnits = 0;
    function resetTextureUnits() {
        textureUnits = 0;
    }
    function allocateTextureUnit() {
        const textureUnit = textureUnits;
        if (textureUnit >= maxTextures) console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
        textureUnits += 1;
        return textureUnit;
    }
    function setTexture2D(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.isVideoTexture) updateVideoTexture(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            const image = texture.image;
            if (image === undefined) console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
            else if (image.complete === false) console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
            else {
                uploadTexture(textureProperties, texture, slot);
                return;
            }
        }
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
    }
    function setTexture2DArray(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
        }
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture);
    }
    function setTexture3D(texture, slot) {
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            uploadTexture(textureProperties, texture, slot);
            return;
        }
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);
    }
    function setTextureCube(texture, slot) {
        if (texture.image.length !== 6) return;
        const textureProperties = properties.get(texture);
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
            initTexture(textureProperties, texture);
            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
            const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
            const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
            const cubeImage = [];
            for(let i1 = 0; i1 < 6; i1++)if (!isCompressed && !isDataTexture) cubeImage[i1] = resizeImage(texture.image[i1], false, true, maxCubemapSize);
            else cubeImage[i1] = isDataTexture ? texture.image[i1].image : texture.image[i1];
            const image = cubeImage[0], supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
            setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
            let mipmaps;
            if (isCompressed) {
                for(let i11 = 0; i11 < 6; i11++){
                    mipmaps = cubeImage[i11].mipmaps;
                    for(let j = 0; j < mipmaps.length; j++){
                        const mipmap = mipmaps[j];
                        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                            if (glFormat !== null) state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i11, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                            else console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
                        } else state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i11, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                    }
                }
                textureProperties.__maxMipLevel = mipmaps.length - 1;
            } else {
                mipmaps = texture.mipmaps;
                for(let i11 = 0; i11 < 6; i11++)if (isDataTexture) {
                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i11, 0, glInternalFormat, cubeImage[i11].width, cubeImage[i11].height, 0, glFormat, glType, cubeImage[i11].data);
                    for(let j = 0; j < mipmaps.length; j++){
                        const mipmap = mipmaps[j];
                        const mipmapImage = mipmap.image[i11].image;
                        state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i11, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                    }
                } else {
                    state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i11, 0, glInternalFormat, glFormat, glType, cubeImage[i11]);
                    for(let j = 0; j < mipmaps.length; j++){
                        const mipmap = mipmaps[j];
                        state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i11, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i11]);
                    }
                }
                textureProperties.__maxMipLevel = mipmaps.length;
            }
            if (textureNeedsGenerateMipmaps(texture, supportsMips)) generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, image.width, image.height);
            textureProperties.__version = texture.version;
            if (texture.onUpdate) texture.onUpdate(texture);
        } else {
            state.activeTexture(_gl.TEXTURE0 + slot);
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
        }
    }
    function setTextureCubeDynamic(texture, slot) {
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(_gl.TEXTURE_CUBE_MAP, properties.get(texture).__webglTexture);
    }
    const wrappingToGL = {
        [RepeatWrapping]: _gl.REPEAT,
        [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
        [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
    };
    const filterToGL = {
        [NearestFilter]: _gl.NEAREST,
        [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
        [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
        [LinearFilter]: _gl.LINEAR,
        [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
        [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
    };
    function setTextureParameters(textureType, texture, supportsMips) {
        if (supportsMips) {
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
            if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
        } else {
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
            if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
            if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
            _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
            _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
            if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
        }
        const extension = extensions.get('EXT_texture_filter_anisotropic');
        if (extension) {
            if (texture.type === FloatType && extensions.get('OES_texture_float_linear') === null) return;
            if (texture.type === HalfFloatType && (isWebGL2 || extensions.get('OES_texture_half_float_linear')) === null) return;
            if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                properties.get(texture).__currentAnisotropy = texture.anisotropy;
            }
        }
    }
    function initTexture(textureProperties, texture) {
        if (textureProperties.__webglInit === undefined) {
            textureProperties.__webglInit = true;
            texture.addEventListener('dispose', onTextureDispose);
            textureProperties.__webglTexture = _gl.createTexture();
            info.memory.textures++;
        }
    }
    function uploadTexture(textureProperties, texture, slot) {
        let textureType = _gl.TEXTURE_2D;
        if (texture.isDataTexture2DArray) textureType = _gl.TEXTURE_2D_ARRAY;
        if (texture.isDataTexture3D) textureType = _gl.TEXTURE_3D;
        initTexture(textureProperties, texture);
        state.activeTexture(_gl.TEXTURE0 + slot);
        state.bindTexture(textureType, textureProperties.__webglTexture);
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
        const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
        const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
        const supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format);
        let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
        setTextureParameters(textureType, texture, supportsMips);
        let mipmap;
        const mipmaps = texture.mipmaps;
        if (texture.isDepthTexture) {
            glInternalFormat = _gl.DEPTH_COMPONENT;
            if (isWebGL2) {
                if (texture.type === FloatType) glInternalFormat = _gl.DEPTH_COMPONENT32F;
                else if (texture.type === UnsignedIntType) glInternalFormat = _gl.DEPTH_COMPONENT24;
                else if (texture.type === UnsignedInt248Type) glInternalFormat = _gl.DEPTH24_STENCIL8;
                else glInternalFormat = _gl.DEPTH_COMPONENT16;
            } else if (texture.type === FloatType) console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
            if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
                if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
                    console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
                    texture.type = UnsignedShortType;
                    glType = utils.convert(texture.type);
                }
            }
            if (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
                glInternalFormat = _gl.DEPTH_STENCIL;
                if (texture.type !== UnsignedInt248Type) {
                    console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
                    texture.type = UnsignedInt248Type;
                    glType = utils.convert(texture.type);
                }
            }
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
        } else if (texture.isDataTexture) {
            if (mipmaps.length > 0 && supportsMips) {
                for(let i1 = 0, il = mipmaps.length; i1 < il; i1++){
                    mipmap = mipmaps[i1];
                    state.texImage2D(_gl.TEXTURE_2D, i1, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
                texture.generateMipmaps = false;
                textureProperties.__maxMipLevel = mipmaps.length - 1;
            } else {
                state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
                textureProperties.__maxMipLevel = 0;
            }
        } else if (texture.isCompressedTexture) {
            for(let i1 = 0, il = mipmaps.length; i1 < il; i1++){
                mipmap = mipmaps[i1];
                if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                    if (glFormat !== null) state.compressedTexImage2D(_gl.TEXTURE_2D, i1, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                    else console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
                } else state.texImage2D(_gl.TEXTURE_2D, i1, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
            textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else if (texture.isDataTexture2DArray) {
            state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
            textureProperties.__maxMipLevel = 0;
        } else if (texture.isDataTexture3D) {
            state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
            textureProperties.__maxMipLevel = 0;
        } else if (mipmaps.length > 0 && supportsMips) {
            for(let i1 = 0, il = mipmaps.length; i1 < il; i1++){
                mipmap = mipmaps[i1];
                state.texImage2D(_gl.TEXTURE_2D, i1, glInternalFormat, glFormat, glType, mipmap);
            }
            texture.generateMipmaps = false;
            textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
            textureProperties.__maxMipLevel = 0;
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) generateMipmap(textureType, texture, image.width, image.height);
        textureProperties.__version = texture.version;
        if (texture.onUpdate) texture.onUpdate(texture);
    }
    function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
        const glFormat = utils.convert(renderTarget.texture.format);
        const glType = utils.convert(renderTarget.texture.type);
        const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
        state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }
    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
            let glInternalFormat = _gl.DEPTH_COMPONENT16;
            if (isMultisample) {
                const depthTexture = renderTarget.depthTexture;
                if (depthTexture && depthTexture.isDepthTexture) {
                    if (depthTexture.type === FloatType) glInternalFormat = _gl.DEPTH_COMPONENT32F;
                    else if (depthTexture.type === UnsignedIntType) glInternalFormat = _gl.DEPTH_COMPONENT24;
                }
                const samples = getRenderTargetSamples(renderTarget);
                _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            } else _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
        } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
            if (isMultisample) {
                const samples = getRenderTargetSamples(renderTarget);
                _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
            } else _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
        } else {
            const glFormat = utils.convert(renderTarget.texture.format);
            const glType = utils.convert(renderTarget.texture.type);
            const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
            if (isMultisample) {
                const samples = getRenderTargetSamples(renderTarget);
                _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            } else _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
        }
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
    }
    function setupDepthTexture(framebuffer, renderTarget) {
        const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
        if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
        if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
            renderTarget.depthTexture.image.width = renderTarget.width;
            renderTarget.depthTexture.image.height = renderTarget.height;
            renderTarget.depthTexture.needsUpdate = true;
        }
        setTexture2D(renderTarget.depthTexture, 0);
        const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
        if (renderTarget.depthTexture.format === DepthFormat) _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
        else if (renderTarget.depthTexture.format === DepthStencilFormat) _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
        else throw new Error('Unknown depthTexture format');
    }
    function setupDepthRenderbuffer(renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        const isCube = renderTarget.isWebGLCubeRenderTarget === true;
        if (renderTarget.depthTexture) {
            if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
            setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
        } else if (isCube) {
            renderTargetProperties.__webglDepthbuffer = [];
            for(let i1 = 0; i1 < 6; i1++){
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i1]);
                renderTargetProperties.__webglDepthbuffer[i1] = _gl.createRenderbuffer();
                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i1], renderTarget, false);
            }
        } else {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
            renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
        }
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
    }
    function setupRenderTarget(renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        const textureProperties = properties.get(renderTarget.texture);
        renderTarget.addEventListener('dispose', onRenderTargetDispose);
        textureProperties.__webglTexture = _gl.createTexture();
        info.memory.textures++;
        const isCube = renderTarget.isWebGLCubeRenderTarget === true;
        const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
        const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
        if (isWebGL2 && renderTarget.texture.format === RGBFormat && (renderTarget.texture.type === FloatType || renderTarget.texture.type === HalfFloatType)) {
            renderTarget.texture.format = RGBAFormat;
            console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');
        }
        if (isCube) {
            renderTargetProperties.__webglFramebuffer = [];
            for(let i1 = 0; i1 < 6; i1++)renderTargetProperties.__webglFramebuffer[i1] = _gl.createFramebuffer();
        } else {
            renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
            if (isMultisample) {
                if (isWebGL2) {
                    renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
                    renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
                    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);
                    const glFormat = utils.convert(renderTarget.texture.format);
                    const glType = utils.convert(renderTarget.texture.type);
                    const glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
                    const samples = getRenderTargetSamples(renderTarget);
                    _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
                    _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);
                    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
                    if (renderTarget.depthBuffer) {
                        renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                        setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
                    }
                    _gl.bindFramebuffer(_gl.FRAMEBUFFER, null);
                } else console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
            }
        }
        if (isCube) {
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
            setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, supportsMips);
            for(let i1 = 0; i1 < 6; i1++)setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i1], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i1);
            if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) generateMipmap(_gl.TEXTURE_CUBE_MAP, renderTarget.texture, renderTarget.width, renderTarget.height);
            state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
        } else {
            state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
            setTextureParameters(_gl.TEXTURE_2D, renderTarget.texture, supportsMips);
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
            if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) generateMipmap(_gl.TEXTURE_2D, renderTarget.texture, renderTarget.width, renderTarget.height);
            state.bindTexture(_gl.TEXTURE_2D, null);
        }
        if (renderTarget.depthBuffer) setupDepthRenderbuffer(renderTarget);
    }
    function updateRenderTargetMipmap(renderTarget) {
        const texture = renderTarget.texture;
        const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
            const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
            const webglTexture = properties.get(texture).__webglTexture;
            state.bindTexture(target, webglTexture);
            generateMipmap(target, texture, renderTarget.width, renderTarget.height);
            state.bindTexture(target, null);
        }
    }
    function updateMultisampleRenderTarget(renderTarget) {
        if (renderTarget.isWebGLMultisampleRenderTarget) {
            if (isWebGL2) {
                const renderTargetProperties = properties.get(renderTarget);
                _gl.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
                _gl.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                const width2 = renderTarget.width;
                const height2 = renderTarget.height;
                let mask = _gl.COLOR_BUFFER_BIT;
                if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
                if (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
                _gl.blitFramebuffer(0, 0, width2, height2, 0, 0, width2, height2, mask, _gl.NEAREST);
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            } else console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
        }
    }
    function getRenderTargetSamples(renderTarget) {
        return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
    }
    function updateVideoTexture(texture) {
        const frame = info.render.frame;
        if (_videoTextures.get(texture) !== frame) {
            _videoTextures.set(texture, frame);
            texture.update();
        }
    }
    let warnedTexture2D = false;
    let warnedTextureCube = false;
    function safeSetTexture2D(texture, slot) {
        if (texture && texture.isWebGLRenderTarget) {
            if (warnedTexture2D === false) {
                console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
                warnedTexture2D = true;
            }
            texture = texture.texture;
        }
        setTexture2D(texture, slot);
    }
    function safeSetTextureCube(texture, slot) {
        if (texture && texture.isWebGLCubeRenderTarget) {
            if (warnedTextureCube === false) {
                console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
                warnedTextureCube = true;
            }
            texture = texture.texture;
        }
        if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) setTextureCube(texture, slot);
        else setTextureCubeDynamic(texture, slot);
    }
    this.allocateTextureUnit = allocateTextureUnit;
    this.resetTextureUnits = resetTextureUnits;
    this.setTexture2D = setTexture2D;
    this.setTexture2DArray = setTexture2DArray;
    this.setTexture3D = setTexture3D;
    this.setTextureCube = setTextureCube;
    this.setTextureCubeDynamic = setTextureCubeDynamic;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    this.safeSetTexture2D = safeSetTexture2D;
    this.safeSetTextureCube = safeSetTextureCube;
}
const WebGLTextures1 = WebGLTextures2;
function WebGLUtils2(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function convert(p) {
        let extension;
        if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
        if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
        if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
        if (p === UnsignedShort565Type) return gl.UNSIGNED_SHORT_5_6_5;
        if (p === ByteType) return gl.BYTE;
        if (p === ShortType) return gl.SHORT;
        if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
        if (p === IntType) return gl.INT;
        if (p === UnsignedIntType) return gl.UNSIGNED_INT;
        if (p === FloatType) return gl.FLOAT;
        if (p === HalfFloatType) {
            if (isWebGL2) return gl.HALF_FLOAT;
            extension = extensions.get('OES_texture_half_float');
            if (extension !== null) return extension.HALF_FLOAT_OES;
            else return null;
        }
        if (p === AlphaFormat) return gl.ALPHA;
        if (p === RGBFormat) return gl.RGB;
        if (p === RGBAFormat) return gl.RGBA;
        if (p === LuminanceFormat) return gl.LUMINANCE;
        if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
        if (p === DepthFormat) return gl.DEPTH_COMPONENT;
        if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
        if (p === RedFormat) return gl.RED;
        if (p === RedIntegerFormat) return gl.RED_INTEGER;
        if (p === RGFormat) return gl.RG;
        if (p === RGIntegerFormat) return gl.RG_INTEGER;
        if (p === RGBIntegerFormat) return gl.RGB_INTEGER;
        if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;
        if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
            extension = extensions.get('WEBGL_compressed_texture_s3tc');
            if (extension !== null) {
                if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
        }
        if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
            extension = extensions.get('WEBGL_compressed_texture_pvrtc');
            if (extension !== null) {
                if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
        }
        if (p === RGB_ETC1_Format) {
            extension = extensions.get('WEBGL_compressed_texture_etc1');
            if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;
            else return null;
        }
        if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
            extension = extensions.get('WEBGL_compressed_texture_etc');
            if (extension !== null) {
                if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;
                if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;
            }
        }
        if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
            extension = extensions.get('WEBGL_compressed_texture_astc');
            if (extension !== null) return p;
            else return null;
        }
        if (p === RGBA_BPTC_Format) {
            extension = extensions.get('EXT_texture_compression_bptc');
            if (extension !== null) return p;
            else return null;
        }
        if (p === UnsignedInt248Type) {
            if (isWebGL2) return gl.UNSIGNED_INT_24_8;
            extension = extensions.get('WEBGL_depth_texture');
            if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;
            else return null;
        }
    }
    return {
        convert: convert
    };
}
const WebGLUtils1 = WebGLUtils2;
function ArrayCamera2(array) {
    PerspectiveCamera1.call(this);
    this.cameras = array || [];
}
ArrayCamera2.prototype = Object.assign(Object.create(PerspectiveCamera1.prototype), {
    constructor: ArrayCamera2,
    isArrayCamera: true
});
const ArrayCamera1 = ArrayCamera2;
import { WebGLAnimation } from '../webgl/WebGLAnimation.js';
function WebXRController2() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
}
Object.assign(WebXRController2.prototype, {
    constructor: WebXRController2,
    getHandSpace: function() {
        if (this._hand === null) {
            this._hand = new Group1();
            this._hand.matrixAutoUpdate = false;
            this._hand.visible = false;
            this._hand.joints = [];
            this._hand.inputState = {
                pinching: false
            };
            if (window.XRHand) for(let i1 = 0; i1 <= window.XRHand.LITTLE_PHALANX_TIP; i1++){
                const joint = new Group1();
                joint.matrixAutoUpdate = false;
                joint.visible = false;
                this._hand.joints.push(joint);
                this._hand.add(joint);
            }
        }
        return this._hand;
    },
    getTargetRaySpace: function() {
        if (this._targetRay === null) {
            this._targetRay = new Group1();
            this._targetRay.matrixAutoUpdate = false;
            this._targetRay.visible = false;
        }
        return this._targetRay;
    },
    getGripSpace: function() {
        if (this._grip === null) {
            this._grip = new Group1();
            this._grip.matrixAutoUpdate = false;
            this._grip.visible = false;
        }
        return this._grip;
    },
    dispatchEvent: function(event) {
        if (this._targetRay !== null) this._targetRay.dispatchEvent(event);
        if (this._grip !== null) this._grip.dispatchEvent(event);
        if (this._hand !== null) this._hand.dispatchEvent(event);
        return this;
    },
    disconnect: function(inputSource) {
        this.dispatchEvent({
            type: 'disconnected',
            data: inputSource
        });
        if (this._targetRay !== null) this._targetRay.visible = false;
        if (this._grip !== null) this._grip.visible = false;
        if (this._hand !== null) this._hand.visible = false;
        return this;
    },
    update: function(inputSource, frame, referenceSpace) {
        let inputPose = null;
        let gripPose = null;
        let handPose = null;
        const targetRay = this._targetRay;
        const grip = this._grip;
        const hand = this._hand;
        if (inputSource) {
            if (hand && inputSource.hand) {
                handPose = true;
                for(let i1 = 0; i1 <= window.XRHand.LITTLE_PHALANX_TIP; i1++)if (inputSource.hand[i1]) {
                    const jointPose = frame.getJointPose(inputSource.hand[i1], referenceSpace);
                    const joint = hand.joints[i1];
                    if (jointPose !== null) {
                        joint.matrix.fromArray(jointPose.transform.matrix);
                        joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                        joint.jointRadius = jointPose.radius;
                    }
                    joint.visible = jointPose !== null;
                    const indexTip = hand.joints[window.XRHand.INDEX_PHALANX_TIP];
                    const thumbTip = hand.joints[window.XRHand.THUMB_PHALANX_TIP];
                    const distance = indexTip.position.distanceTo(thumbTip.position);
                    const distanceToPinch = 0.02;
                    const threshold = 0.005;
                    if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
                        hand.inputState.pinching = false;
                        this.dispatchEvent({
                            type: "pinchend",
                            handedness: inputSource.handedness,
                            target: this
                        });
                    } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
                        hand.inputState.pinching = true;
                        this.dispatchEvent({
                            type: "pinchstart",
                            handedness: inputSource.handedness,
                            target: this
                        });
                    }
                }
            } else {
                if (targetRay !== null) {
                    inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
                    if (inputPose !== null) {
                        targetRay.matrix.fromArray(inputPose.transform.matrix);
                        targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
                    }
                }
                if (grip !== null && inputSource.gripSpace) {
                    gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
                    if (gripPose !== null) {
                        grip.matrix.fromArray(gripPose.transform.matrix);
                        grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                    }
                }
            }
        }
        if (targetRay !== null) targetRay.visible = inputPose !== null;
        if (grip !== null) grip.visible = gripPose !== null;
        if (hand !== null) hand.visible = handPose !== null;
        return this;
    }
});
const WebXRController1 = WebXRController2;
function WebXRManager2(renderer, gl) {
    const scope1 = this;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = 'local-floor';
    let pose = null;
    const controllers = [];
    const inputSourcesMap = new Map();
    const cameraL = new PerspectiveCamera1();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector41();
    const cameraR = new PerspectiveCamera1();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector41();
    const cameras = [
        cameraL,
        cameraR
    ];
    const cameraVR = new ArrayCamera1();
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index) {
        let controller = controllers[index];
        if (controller === undefined) {
            controller = new WebXRController1();
            controllers[index] = controller;
        }
        return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index) {
        let controller = controllers[index];
        if (controller === undefined) {
            controller = new WebXRController1();
            controllers[index] = controller;
        }
        return controller.getGripSpace();
    };
    this.getHand = function(index) {
        let controller = controllers[index];
        if (controller === undefined) {
            controller = new WebXRController1();
            controllers[index] = controller;
        }
        return controller.getHandSpace();
    };
    function onSessionEvent(event) {
        const controller = inputSourcesMap.get(event.inputSource);
        if (controller) controller.dispatchEvent({
            type: event.type
        });
    }
    function onSessionEnd() {
        inputSourcesMap.forEach(function(controller, inputSource) {
            controller.disconnect(inputSource);
        });
        inputSourcesMap.clear();
        renderer.setFramebuffer(null);
        renderer.setRenderTarget(renderer.getRenderTarget());
        animation.stop();
        scope1.isPresenting = false;
        scope1.dispatchEvent({
            type: 'sessionend'
        });
    }
    function onRequestReferenceSpace(value) {
        referenceSpace = value;
        animation.setContext(session);
        animation.start();
        scope1.isPresenting = true;
        scope1.dispatchEvent({
            type: 'sessionstart'
        });
    }
    this.setFramebufferScaleFactor = function(value) {
        framebufferScaleFactor = value;
        if (scope1.isPresenting === true) console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
    };
    this.setReferenceSpaceType = function(value) {
        referenceSpaceType = value;
        if (scope1.isPresenting === true) console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
    };
    this.getReferenceSpace = function() {
        return referenceSpace;
    };
    this.getSession = function() {
        return session;
    };
    this.setSession = function(value) {
        session = value;
        if (session !== null) {
            session.addEventListener('select', onSessionEvent);
            session.addEventListener('selectstart', onSessionEvent);
            session.addEventListener('selectend', onSessionEvent);
            session.addEventListener('squeeze', onSessionEvent);
            session.addEventListener('squeezestart', onSessionEvent);
            session.addEventListener('squeezeend', onSessionEvent);
            session.addEventListener('end', onSessionEnd);
            const attributes = gl.getContextAttributes();
            if (attributes.xrCompatible !== true) gl.makeXRCompatible();
            const layerInit = {
                antialias: attributes.antialias,
                alpha: attributes.alpha,
                depth: attributes.depth,
                stencil: attributes.stencil,
                framebufferScaleFactor: framebufferScaleFactor
            };
            const baseLayer = new XRWebGLLayer(session, gl, layerInit);
            session.updateRenderState({
                baseLayer: baseLayer
            });
            session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace);
            session.addEventListener('inputsourceschange', updateInputSources);
        }
    };
    function updateInputSources(event) {
        const inputSources = session.inputSources;
        for(let i1 = 0; i1 < controllers.length; i1++)inputSourcesMap.set(inputSources[i1], controllers[i1]);
        for(let i1 = 0; i1 < event.removed.length; i1++){
            const inputSource = event.removed[i1];
            const controller = inputSourcesMap.get(inputSource);
            if (controller) {
                controller.dispatchEvent({
                    type: 'disconnected',
                    data: inputSource
                });
                inputSourcesMap.delete(inputSource);
            }
        }
        for(let i1 = 0; i1 < event.added.length; i1++){
            const inputSource = event.added[i1];
            const controller = inputSourcesMap.get(inputSource);
            if (controller) controller.dispatchEvent({
                type: 'connected',
                data: inputSource
            });
        }
    }
    const cameraLPos = new Vector31();
    const cameraRPos = new Vector31();
    function setProjectionFromUnion(camera, cameraL1, cameraR1) {
        cameraLPos.setFromMatrixPosition(cameraL1.matrixWorld);
        cameraRPos.setFromMatrixPosition(cameraR1.matrixWorld);
        const ipd = cameraLPos.distanceTo(cameraRPos);
        const projL = cameraL1.projectionMatrix.elements;
        const projR = cameraR1.projectionMatrix.elements;
        const near = projL[14] / (projL[10] - 1);
        const far = projL[14] / (projL[10] + 1);
        const topFov = (projL[9] + 1) / projL[5];
        const bottomFov = (projL[9] - 1) / projL[5];
        const leftFov = (projL[8] - 1) / projL[0];
        const rightFov = (projR[8] + 1) / projR[0];
        const left = near * leftFov;
        const right = near * rightFov;
        const zOffset = ipd / (-leftFov + rightFov);
        const xOffset = zOffset * -leftFov;
        cameraL1.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
        camera.translateX(xOffset);
        camera.translateZ(zOffset);
        camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
        const near2 = near + zOffset;
        const far2 = far + zOffset;
        const left2 = left - xOffset;
        const right2 = right + (ipd - xOffset);
        const top2 = topFov * far / far2 * near2;
        const bottom2 = bottomFov * far / far2 * near2;
        camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
    }
    function updateCamera(camera, parent) {
        if (parent === null) camera.matrixWorld.copy(camera.matrix);
        else camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    }
    this.getCamera = function(camera) {
        cameraVR.near = cameraR.near = cameraL.near = camera.near;
        cameraVR.far = cameraR.far = cameraL.far = camera.far;
        if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
            session.updateRenderState({
                depthNear: cameraVR.near,
                depthFar: cameraVR.far
            });
            _currentDepthNear = cameraVR.near;
            _currentDepthFar = cameraVR.far;
        }
        const parent = camera.parent;
        const cameras1 = cameraVR.cameras;
        updateCamera(cameraVR, parent);
        for(let i1 = 0; i1 < cameras1.length; i1++)updateCamera(cameras1[i1], parent);
        camera.matrixWorld.copy(cameraVR.matrixWorld);
        const children = camera.children;
        for(let i1 = 0, l = children.length; i1 < l; i1++)children[i1].updateMatrixWorld(true);
        if (cameras1.length === 2) setProjectionFromUnion(cameraVR, cameraL, cameraR);
        else cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
        return cameraVR;
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
        pose = frame.getViewerPose(referenceSpace);
        if (pose !== null) {
            const views = pose.views;
            const baseLayer = session.renderState.baseLayer;
            renderer.setFramebuffer(baseLayer.framebuffer);
            let cameraVRNeedsUpdate = false;
            if (views.length !== cameraVR.cameras.length) {
                cameraVR.cameras.length = 0;
                cameraVRNeedsUpdate = true;
            }
            for(let i1 = 0; i1 < views.length; i1++){
                const view = views[i1];
                const viewport = baseLayer.getViewport(view);
                const camera = cameras[i1];
                camera.matrix.fromArray(view.transform.matrix);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                if (i1 === 0) cameraVR.matrix.copy(camera.matrix);
                if (cameraVRNeedsUpdate === true) cameraVR.cameras.push(camera);
            }
        }
        const inputSources = session.inputSources;
        for(let i1 = 0; i1 < controllers.length; i1++){
            const controller = controllers[i1];
            const inputSource = inputSources[i1];
            controller.update(inputSource, frame, referenceSpace);
        }
        if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
}
Object.assign(WebXRManager2.prototype, EventDispatcher1.prototype);
const WebXRManager1 = WebXRManager2;
function WebGLMaterials2(properties) {
    function refreshFogUniforms(uniforms, fog) {
        uniforms.fogColor.value.copy(fog.color);
        if (fog.isFog) {
            uniforms.fogNear.value = fog.near;
            uniforms.fogFar.value = fog.far;
        } else if (fog.isFogExp2) uniforms.fogDensity.value = fog.density;
    }
    function refreshMaterialUniforms(uniforms, material, pixelRatio, height2) {
        if (material.isMeshBasicMaterial) refreshUniformsCommon(uniforms, material);
        else if (material.isMeshLambertMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsLambert(uniforms, material);
        } else if (material.isMeshToonMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsToon(uniforms, material);
        } else if (material.isMeshPhongMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsPhong(uniforms, material);
        } else if (material.isMeshStandardMaterial) {
            refreshUniformsCommon(uniforms, material);
            if (material.isMeshPhysicalMaterial) refreshUniformsPhysical(uniforms, material);
            else refreshUniformsStandard(uniforms, material);
        } else if (material.isMeshMatcapMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsMatcap(uniforms, material);
        } else if (material.isMeshDepthMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsDepth(uniforms, material);
        } else if (material.isMeshDistanceMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsDistance(uniforms, material);
        } else if (material.isMeshNormalMaterial) {
            refreshUniformsCommon(uniforms, material);
            refreshUniformsNormal(uniforms, material);
        } else if (material.isLineBasicMaterial) {
            refreshUniformsLine(uniforms, material);
            if (material.isLineDashedMaterial) refreshUniformsDash(uniforms, material);
        } else if (material.isPointsMaterial) refreshUniformsPoints(uniforms, material, pixelRatio, height2);
        else if (material.isSpriteMaterial) refreshUniformsSprites(uniforms, material);
        else if (material.isShadowMaterial) {
            uniforms.color.value.copy(material.color);
            uniforms.opacity.value = material.opacity;
        } else if (material.isShaderMaterial) material.uniformsNeedUpdate = false;
    }
    function refreshUniformsCommon(uniforms, material) {
        uniforms.opacity.value = material.opacity;
        if (material.color) uniforms.diffuse.value.copy(material.color);
        if (material.emissive) uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
        if (material.map) uniforms.map.value = material.map;
        if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
        if (material.specularMap) uniforms.specularMap.value = material.specularMap;
        const envMap = properties.get(material).envMap;
        if (envMap) {
            uniforms.envMap.value = envMap;
            uniforms.flipEnvMap.value = envMap.isCubeTexture ? -1 : 1;
            uniforms.reflectivity.value = material.reflectivity;
            uniforms.refractionRatio.value = material.refractionRatio;
            const maxMipLevel = properties.get(envMap).__maxMipLevel;
            if (maxMipLevel !== undefined) uniforms.maxMipLevel.value = maxMipLevel;
        }
        if (material.lightMap) {
            uniforms.lightMap.value = material.lightMap;
            uniforms.lightMapIntensity.value = material.lightMapIntensity;
        }
        if (material.aoMap) {
            uniforms.aoMap.value = material.aoMap;
            uniforms.aoMapIntensity.value = material.aoMapIntensity;
        }
        let uvScaleMap;
        if (material.map) uvScaleMap = material.map;
        else if (material.specularMap) uvScaleMap = material.specularMap;
        else if (material.displacementMap) uvScaleMap = material.displacementMap;
        else if (material.normalMap) uvScaleMap = material.normalMap;
        else if (material.bumpMap) uvScaleMap = material.bumpMap;
        else if (material.roughnessMap) uvScaleMap = material.roughnessMap;
        else if (material.metalnessMap) uvScaleMap = material.metalnessMap;
        else if (material.alphaMap) uvScaleMap = material.alphaMap;
        else if (material.emissiveMap) uvScaleMap = material.emissiveMap;
        if (uvScaleMap !== undefined) {
            if (uvScaleMap.isWebGLRenderTarget) uvScaleMap = uvScaleMap.texture;
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
        let uv2ScaleMap;
        if (material.aoMap) uv2ScaleMap = material.aoMap;
        else if (material.lightMap) uv2ScaleMap = material.lightMap;
        if (uv2ScaleMap !== undefined) {
            if (uv2ScaleMap.isWebGLRenderTarget) uv2ScaleMap = uv2ScaleMap.texture;
            if (uv2ScaleMap.matrixAutoUpdate === true) uv2ScaleMap.updateMatrix();
            uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
        }
    }
    function refreshUniformsLine(uniforms, material) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
    }
    function refreshUniformsDash(uniforms, material) {
        uniforms.dashSize.value = material.dashSize;
        uniforms.totalSize.value = material.dashSize + material.gapSize;
        uniforms.scale.value = material.scale;
    }
    function refreshUniformsPoints(uniforms, material, pixelRatio, height2) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
        uniforms.size.value = material.size * pixelRatio;
        uniforms.scale.value = height2 * 0.5;
        if (material.map) uniforms.map.value = material.map;
        if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
        let uvScaleMap;
        if (material.map) uvScaleMap = material.map;
        else if (material.alphaMap) uvScaleMap = material.alphaMap;
        if (uvScaleMap !== undefined) {
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
    }
    function refreshUniformsSprites(uniforms, material) {
        uniforms.diffuse.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
        uniforms.rotation.value = material.rotation;
        if (material.map) uniforms.map.value = material.map;
        if (material.alphaMap) uniforms.alphaMap.value = material.alphaMap;
        let uvScaleMap;
        if (material.map) uvScaleMap = material.map;
        else if (material.alphaMap) uvScaleMap = material.alphaMap;
        if (uvScaleMap !== undefined) {
            if (uvScaleMap.matrixAutoUpdate === true) uvScaleMap.updateMatrix();
            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }
    }
    function refreshUniformsLambert(uniforms, material) {
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
    }
    function refreshUniformsPhong(uniforms, material) {
        uniforms.specular.value.copy(material.specular);
        uniforms.shininess.value = Math.max(material.shininess, 0.0001);
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsToon(uniforms, material) {
        if (material.gradientMap) uniforms.gradientMap.value = material.gradientMap;
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsStandard(uniforms, material) {
        uniforms.roughness.value = material.roughness;
        uniforms.metalness.value = material.metalness;
        if (material.roughnessMap) uniforms.roughnessMap.value = material.roughnessMap;
        if (material.metalnessMap) uniforms.metalnessMap.value = material.metalnessMap;
        if (material.emissiveMap) uniforms.emissiveMap.value = material.emissiveMap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
        const envMap = properties.get(material).envMap;
        if (envMap) uniforms.envMapIntensity.value = material.envMapIntensity;
    }
    function refreshUniformsPhysical(uniforms, material) {
        refreshUniformsStandard(uniforms, material);
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.clearcoat.value = material.clearcoat;
        uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
        if (material.sheen) uniforms.sheen.value.copy(material.sheen);
        if (material.clearcoatMap) uniforms.clearcoatMap.value = material.clearcoatMap;
        if (material.clearcoatRoughnessMap) uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        if (material.clearcoatNormalMap) {
            uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
            uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
            if (material.side === BackSide) uniforms.clearcoatNormalScale.value.negate();
        }
        uniforms.transmission.value = material.transmission;
        if (material.transmissionMap) uniforms.transmissionMap.value = material.transmissionMap;
    }
    function refreshUniformsMatcap(uniforms, material) {
        if (material.matcap) uniforms.matcap.value = material.matcap;
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsDepth(uniforms, material) {
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    function refreshUniformsDistance(uniforms, material) {
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
        uniforms.referencePosition.value.copy(material.referencePosition);
        uniforms.nearDistance.value = material.nearDistance;
        uniforms.farDistance.value = material.farDistance;
    }
    function refreshUniformsNormal(uniforms, material) {
        if (material.bumpMap) {
            uniforms.bumpMap.value = material.bumpMap;
            uniforms.bumpScale.value = material.bumpScale;
            if (material.side === BackSide) uniforms.bumpScale.value *= -1;
        }
        if (material.normalMap) {
            uniforms.normalMap.value = material.normalMap;
            uniforms.normalScale.value.copy(material.normalScale);
            if (material.side === BackSide) uniforms.normalScale.value.negate();
        }
        if (material.displacementMap) {
            uniforms.displacementMap.value = material.displacementMap;
            uniforms.displacementScale.value = material.displacementScale;
            uniforms.displacementBias.value = material.displacementBias;
        }
    }
    return {
        refreshFogUniforms: refreshFogUniforms,
        refreshMaterialUniforms: refreshMaterialUniforms
    };
}
const WebGLMaterials1 = WebGLMaterials2;
function WebGLRenderer2(parameters) {
    parameters = parameters || {
    };
    const _canvas1 = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'), _context = parameters.context !== undefined ? parameters.context : null, _alpha = parameters.alpha !== undefined ? parameters.alpha : false, _depth = parameters.depth !== undefined ? parameters.depth : true, _stencil = parameters.stencil !== undefined ? parameters.stencil : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default', _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;
    let currentRenderList = null;
    let currentRenderState = null;
    this.domElement = _canvas1;
    this.debug = {
        checkShaderErrors: true
    };
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this.gammaFactor = 2;
    this.outputEncoding = LinearEncoding;
    this.physicallyCorrectLights = false;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    const _this = this;
    let _isContextLost = false;
    let _framebuffer = null;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentFramebuffer = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    let _currentArrayCamera = null;
    const _currentViewport = new Vector41();
    const _currentScissor = new Vector41();
    let _currentScissorTest = null;
    let _width = _canvas1.width;
    let _height = _canvas1.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector41(0, 0, _width, _height);
    const _scissor = new Vector41(0, 0, _width, _height);
    let _scissorTest = false;
    const _frustum = new Frustum1();
    const _clipping = new WebGLClipping1();
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    const _projScreenMatrix = new Matrix41();
    const _vector31 = new Vector31();
    const _emptyScene = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: true
    };
    function getTargetPixelRatio() {
        return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    let _gl = _context;
    function getContext(contextNames, contextAttributes) {
        for(let i1 = 0; i1 < contextNames.length; i1++){
            const contextName = contextNames[i1];
            const context = _canvas1.getContext(contextName, contextAttributes);
            if (context !== null) return context;
        }
        return null;
    }
    try {
        const contextAttributes = {
            alpha: _alpha,
            depth: _depth,
            stencil: _stencil,
            antialias: _antialias,
            premultipliedAlpha: _premultipliedAlpha,
            preserveDrawingBuffer: _preserveDrawingBuffer,
            powerPreference: _powerPreference,
            failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
        };
        _canvas1.addEventListener('webglcontextlost', onContextLost, false);
        _canvas1.addEventListener('webglcontextrestored', onContextRestore, false);
        if (_gl === null) {
            const contextNames = [
                'webgl2',
                'webgl',
                'experimental-webgl'
            ];
            if (_this.isWebGL1Renderer === true) contextNames.shift();
            _gl = getContext(contextNames, contextAttributes);
            if (_gl === null) {
                if (getContext(contextNames)) throw new Error('Error creating WebGL context with your selected attributes.');
                else throw new Error('Error creating WebGL context.');
            }
        }
        if (_gl.getShaderPrecisionFormat === undefined) _gl.getShaderPrecisionFormat = function() {
            return {
                'rangeMin': 1,
                'rangeMax': 1,
                'precision': 1
            };
        };
    } catch (error) {
        console.error('THREE.WebGLRenderer: ' + error.message);
        throw error;
    }
    let extensions, capabilities, state, info;
    let properties, textures, cubemaps, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates;
    function initGLContext() {
        extensions = new WebGLExtensions1(_gl);
        capabilities = new WebGLCapabilities1(_gl, extensions, parameters);
        if (capabilities.isWebGL2 === false) {
            extensions.get('WEBGL_depth_texture');
            extensions.get('OES_texture_float');
            extensions.get('OES_texture_half_float');
            extensions.get('OES_texture_half_float_linear');
            extensions.get('OES_standard_derivatives');
            extensions.get('OES_element_index_uint');
            extensions.get('OES_vertex_array_object');
            extensions.get('ANGLE_instanced_arrays');
        }
        extensions.get('OES_texture_float_linear');
        utils = new WebGLUtils1(_gl, extensions, capabilities);
        state = new WebGLState1(_gl, extensions, capabilities);
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
        info = new WebGLInfo1(_gl);
        properties = new WebGLProperties1();
        textures = new WebGLTextures1(_gl, extensions, state, properties, capabilities, utils, info);
        cubemaps = new WebGLCubeMaps1(_this);
        attributes = new WebGLAttributes1(_gl, capabilities);
        bindingStates = new WebGLBindingStates1(_gl, extensions, attributes, capabilities);
        geometries = new WebGLGeometries1(_gl, attributes, info, bindingStates);
        objects = new WebGLObjects1(_gl, geometries, attributes, info);
        morphtargets = new WebGLMorphtargets1(_gl);
        programCache = new WebGLPrograms1(_this, cubemaps, extensions, capabilities, bindingStates);
        materials = new WebGLMaterials1(properties, cubemaps);
        renderLists = new WebGLRenderLists1(properties);
        renderStates = new WebGLRenderStates1();
        background = new WebGLBackground1(_this, cubemaps, state, objects, _premultipliedAlpha);
        bufferRenderer = new WebGLBufferRenderer1(_gl, extensions, info, capabilities);
        indexedBufferRenderer = new WebGLIndexedBufferRenderer1(_gl, extensions, info, capabilities);
        info.programs = programCache.programs;
        _this.capabilities = capabilities;
        _this.extensions = extensions;
        _this.properties = properties;
        _this.renderLists = renderLists;
        _this.state = state;
        _this.info = info;
    }
    initGLContext();
    const xr = new WebXRManager1(_this, _gl);
    this.xr = xr;
    const shadowMap = new WebGLShadowMap1(_this, objects, capabilities.maxTextureSize);
    this.shadowMap = shadowMap;
    this.getContext = function() {
        return _gl;
    };
    this.getContextAttributes = function() {
        return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
        const extension = extensions.get('WEBGL_lose_context');
        if (extension) extension.loseContext();
    };
    this.forceContextRestore = function() {
        const extension = extensions.get('WEBGL_lose_context');
        if (extension) extension.restoreContext();
    };
    this.getPixelRatio = function() {
        return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
        if (value === undefined) return;
        _pixelRatio = value;
        this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
        if (target === undefined) {
            console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');
            target = new Vector21();
        }
        return target.set(_width, _height);
    };
    this.setSize = function(width2, height2, updateStyle) {
        if (xr.isPresenting) {
            console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
            return;
        }
        _width = width2;
        _height = height2;
        _canvas1.width = Math.floor(width2 * _pixelRatio);
        _canvas1.height = Math.floor(height2 * _pixelRatio);
        if (updateStyle !== false) {
            _canvas1.style.width = width2 + 'px';
            _canvas1.style.height = height2 + 'px';
        }
        this.setViewport(0, 0, width2, height2);
    };
    this.getDrawingBufferSize = function(target) {
        if (target === undefined) {
            console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');
            target = new Vector21();
        }
        return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width2, height2, pixelRatio) {
        _width = width2;
        _height = height2;
        _pixelRatio = pixelRatio;
        _canvas1.width = Math.floor(width2 * pixelRatio);
        _canvas1.height = Math.floor(height2 * pixelRatio);
        this.setViewport(0, 0, width2, height2);
    };
    this.getCurrentViewport = function(target) {
        if (target === undefined) {
            console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');
            target = new Vector41();
        }
        return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
        return target.copy(_viewport);
    };
    this.setViewport = function(x6, y6, width2, height2) {
        if (x6.isVector4) _viewport.set(x6.x, x6.y, x6.z, x6.w);
        else _viewport.set(x6, y6, width2, height2);
        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissor = function(target) {
        return target.copy(_scissor);
    };
    this.setScissor = function(x6, y6, width2, height2) {
        if (x6.isVector4) _scissor.set(x6.x, x6.y, x6.z, x6.w);
        else _scissor.set(x6, y6, width2, height2);
        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissorTest = function() {
        return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
        state.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
        _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
        _transparentSort = method;
    };
    this.getClearColor = function() {
        return background.getClearColor();
    };
    this.setClearColor = function() {
        background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
        return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
        background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color1, depth1, stencil) {
        let bits = 0;
        if (color1 === undefined || color1) bits |= _gl.COLOR_BUFFER_BIT;
        if (depth1 === undefined || depth1) bits |= _gl.DEPTH_BUFFER_BIT;
        if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;
        _gl.clear(bits);
    };
    this.clearColor = function() {
        this.clear(true, false, false);
    };
    this.clearDepth = function() {
        this.clear(false, true, false);
    };
    this.clearStencil = function() {
        this.clear(false, false, true);
    };
    this.dispose = function() {
        _canvas1.removeEventListener('webglcontextlost', onContextLost, false);
        _canvas1.removeEventListener('webglcontextrestored', onContextRestore, false);
        renderLists.dispose();
        renderStates.dispose();
        properties.dispose();
        cubemaps.dispose();
        objects.dispose();
        bindingStates.dispose();
        xr.dispose();
        animation.stop();
    };
    function onContextLost(event) {
        event.preventDefault();
        console.log('THREE.WebGLRenderer: Context Lost.');
        _isContextLost = true;
    }
    function onContextRestore() {
        console.log('THREE.WebGLRenderer: Context Restored.');
        _isContextLost = false;
        initGLContext();
    }
    function onMaterialDispose(event) {
        const material = event.target;
        material.removeEventListener('dispose', onMaterialDispose);
        deallocateMaterial(material);
    }
    function deallocateMaterial(material) {
        releaseMaterialProgramReference(material);
        properties.remove(material);
    }
    function releaseMaterialProgramReference(material) {
        const programInfo = properties.get(material).program;
        if (programInfo !== undefined) programCache.releaseProgram(programInfo);
    }
    function renderObjectImmediate(object, program) {
        object.render(function(object1) {
            _this.renderBufferImmediate(object1, program);
        });
    }
    this.renderBufferImmediate = function(object, program) {
        bindingStates.initAttributes();
        const buffers = properties.get(object);
        if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
        if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
        if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
        if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
        const programAttributes = program.getAttributes();
        if (object.hasPositions) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);
            bindingStates.enableAttribute(programAttributes.position);
            _gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasNormals) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);
            bindingStates.enableAttribute(programAttributes.normal);
            _gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasUvs) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);
            bindingStates.enableAttribute(programAttributes.uv);
            _gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, false, 0, 0);
        }
        if (object.hasColors) {
            _gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);
            _gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);
            bindingStates.enableAttribute(programAttributes.color);
            _gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0);
        }
        bindingStates.disableUnusedAttributes();
        _gl.drawArrays(_gl.TRIANGLES, 0, object.count);
        object.count = 0;
    };
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
        if (scene === null) scene = _emptyScene;
        const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
        const program = setProgram(camera, scene, material, object);
        state.setMaterial(material, frontFaceCW);
        let index = geometry.index;
        const position = geometry.attributes.position;
        if (index === null) {
            if (position === undefined || position.count === 0) return;
        } else if (index.count === 0) return;
        let rangeFactor = 1;
        if (material.wireframe === true) {
            index = geometries.getWireframeAttribute(geometry);
            rangeFactor = 2;
        }
        if (material.morphTargets || material.morphNormals) morphtargets.update(object, geometry, material, program);
        bindingStates.setup(object, material, program, geometry, index);
        let attribute;
        let renderer = bufferRenderer;
        if (index !== null) {
            attribute = attributes.get(index);
            renderer = indexedBufferRenderer;
            renderer.setIndex(attribute);
        }
        const dataCount = index !== null ? index.count : position.count;
        const rangeStart = geometry.drawRange.start * rangeFactor;
        const rangeCount = geometry.drawRange.count * rangeFactor;
        const groupStart1 = group !== null ? group.start * rangeFactor : 0;
        const groupCount = group !== null ? group.count * rangeFactor : Infinity;
        const drawStart = Math.max(rangeStart, groupStart1);
        const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart1 + groupCount) - 1;
        const drawCount = Math.max(0, drawEnd - drawStart + 1);
        if (drawCount === 0) return;
        if (object.isMesh) {
            if (material.wireframe === true) {
                state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                renderer.setMode(_gl.LINES);
            } else renderer.setMode(_gl.TRIANGLES);
        } else if (object.isLine) {
            let lineWidth = material.linewidth;
            if (lineWidth === undefined) lineWidth = 1;
            state.setLineWidth(lineWidth * getTargetPixelRatio());
            if (object.isLineSegments) renderer.setMode(_gl.LINES);
            else if (object.isLineLoop) renderer.setMode(_gl.LINE_LOOP);
            else renderer.setMode(_gl.LINE_STRIP);
        } else if (object.isPoints) renderer.setMode(_gl.POINTS);
        else if (object.isSprite) renderer.setMode(_gl.TRIANGLES);
        if (object.isInstancedMesh) renderer.renderInstances(drawStart, drawCount, object.count);
        else if (geometry.isInstancedBufferGeometry) {
            const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
            renderer.renderInstances(drawStart, drawCount, instanceCount);
        } else renderer.render(drawStart, drawCount);
    };
    this.compile = function(scene, camera) {
        currentRenderState = renderStates.get(scene, camera);
        currentRenderState.init();
        scene.traverse(function(object) {
            if (object.isLight) {
                currentRenderState.pushLight(object);
                if (object.castShadow) currentRenderState.pushShadow(object);
            }
        });
        currentRenderState.setupLights(camera);
        const compiled = new WeakMap();
        scene.traverse(function(object) {
            const material = object.material;
            if (material) {
                if (Array.isArray(material)) for(let i1 = 0; i1 < material.length; i1++){
                    const material2 = material[i1];
                    if (compiled.has(material2) === false) {
                        initMaterial(material2, scene, object);
                        compiled.set(material2);
                    }
                }
                else if (compiled.has(material) === false) {
                    initMaterial(material, scene, object);
                    compiled.set(material);
                }
            }
        });
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
        if (xr.isPresenting) return;
        if (onAnimationFrameCallback) onAnimationFrameCallback(time);
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof window !== 'undefined') animation.setContext(window);
    this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
        xr.setAnimationLoop(callback);
        callback === null ? animation.stop() : animation.start();
    };
    this.render = function(scene, camera) {
        let renderTarget, forceClear;
        if (arguments[2] !== undefined) {
            console.warn('THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');
            renderTarget = arguments[2];
        }
        if (arguments[3] !== undefined) {
            console.warn('THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.');
            forceClear = arguments[3];
        }
        if (camera !== undefined && camera.isCamera !== true) {
            console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
            return;
        }
        if (_isContextLost === true) return;
        bindingStates.resetDefaultState();
        _currentMaterialId = -1;
        _currentCamera = null;
        if (scene.autoUpdate === true) scene.updateMatrixWorld();
        if (camera.parent === null) camera.updateMatrixWorld();
        if (xr.enabled === true && xr.isPresenting === true) camera = xr.getCamera(camera);
        if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
        currentRenderState = renderStates.get(scene, camera);
        currentRenderState.init();
        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        _frustum.setFromProjectionMatrix(_projScreenMatrix);
        _localClippingEnabled = this.localClippingEnabled;
        _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
        currentRenderList = renderLists.get(scene, camera);
        currentRenderList.init();
        projectObject(scene, camera, 0, _this.sortObjects);
        currentRenderList.finish();
        if (_this.sortObjects === true) currentRenderList.sort(_opaqueSort, _transparentSort);
        if (_clippingEnabled === true) _clipping.beginShadows();
        const shadowsArray = currentRenderState.state.shadowsArray;
        shadowMap.render(shadowsArray, scene, camera);
        currentRenderState.setupLights(camera);
        if (_clippingEnabled === true) _clipping.endShadows();
        if (this.info.autoReset === true) this.info.reset();
        if (renderTarget !== undefined) this.setRenderTarget(renderTarget);
        background.render(currentRenderList, scene, camera, forceClear);
        const opaqueObjects = currentRenderList.opaque;
        const transparentObjects = currentRenderList.transparent;
        if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
        if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);
        if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);
        if (_currentRenderTarget !== null) {
            textures.updateRenderTargetMipmap(_currentRenderTarget);
            textures.updateMultisampleRenderTarget(_currentRenderTarget);
        }
        state.buffers.depth.setTest(true);
        state.buffers.depth.setMask(true);
        state.buffers.color.setMask(true);
        state.setPolygonOffset(false);
        currentRenderList = null;
        currentRenderState = null;
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
        if (object.visible === false) return;
        const visible = object.layers.test(camera.layers);
        if (visible) {
            if (object.isGroup) groupOrder = object.renderOrder;
            else if (object.isLOD) {
                if (object.autoUpdate === true) object.update(camera);
            } else if (object.isLight) {
                currentRenderState.pushLight(object);
                if (object.castShadow) currentRenderState.pushShadow(object);
            } else if (object.isSprite) {
                if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                    if (sortObjects) _vector31.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    const geometry = objects.update(object);
                    const material = object.material;
                    if (material.visible) currentRenderList.push(object, geometry, material, groupOrder, _vector31.z, null);
                }
            } else if (object.isImmediateRenderObject) {
                if (sortObjects) _vector31.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                currentRenderList.push(object, null, object.material, groupOrder, _vector31.z, null);
            } else if (object.isMesh || object.isLine || object.isPoints) {
                if (object.isSkinnedMesh) {
                    if (object.skeleton.frame !== info.render.frame) {
                        object.skeleton.update();
                        object.skeleton.frame = info.render.frame;
                    }
                }
                if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                    if (sortObjects) _vector31.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
                    const geometry = objects.update(object);
                    const material = object.material;
                    if (Array.isArray(material)) {
                        const groups = geometry.groups;
                        for(let i1 = 0, l = groups.length; i1 < l; i1++){
                            const group = groups[i1];
                            const groupMaterial = material[group.materialIndex];
                            if (groupMaterial && groupMaterial.visible) currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector31.z, group);
                        }
                    } else if (material.visible) currentRenderList.push(object, geometry, material, groupOrder, _vector31.z, null);
                }
            }
        }
        const children = object.children;
        for(let i1 = 0, l = children.length; i1 < l; i1++)projectObject(children[i1], camera, groupOrder, sortObjects);
    }
    function renderObjects(renderList, scene, camera) {
        const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
        for(let i1 = 0, l = renderList.length; i1 < l; i1++){
            const renderItem = renderList[i1];
            const object = renderItem.object;
            const geometry = renderItem.geometry;
            const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
            const group = renderItem.group;
            if (camera.isArrayCamera) {
                _currentArrayCamera = camera;
                const cameras = camera.cameras;
                for(let j = 0, jl = cameras.length; j < jl; j++){
                    const camera2 = cameras[j];
                    if (object.layers.test(camera2.layers)) {
                        state.viewport(_currentViewport.copy(camera2.viewport));
                        currentRenderState.setupLights(camera2);
                        renderObject(object, scene, camera2, geometry, material, group);
                    }
                }
            } else {
                _currentArrayCamera = null;
                renderObject(object, scene, camera, geometry, material, group);
            }
        }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
        object.onBeforeRender(_this, scene, camera, geometry, material, group);
        currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
        object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
        if (object.isImmediateRenderObject) {
            const program = setProgram(camera, scene, material, object);
            state.setMaterial(material);
            bindingStates.reset();
            renderObjectImmediate(object, program);
        } else _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        object.onAfterRender(_this, scene, camera, geometry, material, group);
        currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
    }
    function initMaterial(material, scene, object) {
        if (scene.isScene !== true) scene = _emptyScene;
        const materialProperties = properties.get(material);
        const lights = currentRenderState.state.lights;
        const shadowsArray = currentRenderState.state.shadowsArray;
        const lightsStateVersion = lights.state.version;
        const parameters1 = programCache.getParameters(material, lights.state, shadowsArray, scene, _clipping.numPlanes, _clipping.numIntersection, object);
        const programCacheKey = programCache.getProgramCacheKey(parameters1);
        let program = materialProperties.program;
        let programChange = true;
        if (program === undefined) material.addEventListener('dispose', onMaterialDispose);
        else if (program.cacheKey !== programCacheKey) releaseMaterialProgramReference(material);
        else if (materialProperties.lightsStateVersion !== lightsStateVersion) {
            materialProperties.lightsStateVersion = lightsStateVersion;
            programChange = false;
        } else if (parameters1.shaderID !== undefined) return;
        else programChange = false;
        if (programChange) {
            parameters1.uniforms = programCache.getUniforms(material, parameters1);
            material.onBeforeCompile(parameters1, _this);
            program = programCache.acquireProgram(parameters1, programCacheKey);
            materialProperties.program = program;
            materialProperties.uniforms = parameters1.uniforms;
            materialProperties.outputEncoding = parameters1.outputEncoding;
        }
        const programAttributes = program.getAttributes();
        if (material.morphTargets) {
            material.numSupportedMorphTargets = 0;
            for(let i1 = 0; i1 < _this.maxMorphTargets; i1++)if (programAttributes['morphTarget' + i1] >= 0) material.numSupportedMorphTargets++;
        }
        if (material.morphNormals) {
            material.numSupportedMorphNormals = 0;
            for(let i1 = 0; i1 < _this.maxMorphNormals; i1++)if (programAttributes['morphNormal' + i1] >= 0) material.numSupportedMorphNormals++;
        }
        const uniforms = materialProperties.uniforms;
        if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
            materialProperties.numClippingPlanes = _clipping.numPlanes;
            materialProperties.numIntersection = _clipping.numIntersection;
            uniforms.clippingPlanes = _clipping.uniform;
        }
        materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
        materialProperties.fog = scene.fog;
        materialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);
        materialProperties.needsLights = materialNeedsLights(material);
        materialProperties.lightsStateVersion = lightsStateVersion;
        if (materialProperties.needsLights) {
            uniforms.ambientLightColor.value = lights.state.ambient;
            uniforms.lightProbe.value = lights.state.probe;
            uniforms.directionalLights.value = lights.state.directional;
            uniforms.directionalLightShadows.value = lights.state.directionalShadow;
            uniforms.spotLights.value = lights.state.spot;
            uniforms.spotLightShadows.value = lights.state.spotShadow;
            uniforms.rectAreaLights.value = lights.state.rectArea;
            uniforms.pointLights.value = lights.state.point;
            uniforms.pointLightShadows.value = lights.state.pointShadow;
            uniforms.hemisphereLights.value = lights.state.hemi;
            uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
            uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
            uniforms.spotShadowMap.value = lights.state.spotShadowMap;
            uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
            uniforms.pointShadowMap.value = lights.state.pointShadowMap;
            uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
        }
        const progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms1.seqWithValue(progUniforms.seq, uniforms);
        materialProperties.uniformsList = uniformsList;
    }
    function setProgram(camera, scene, material, object) {
        if (scene.isScene !== true) scene = _emptyScene;
        textures.resetTextureUnits();
        const fog = scene.fog;
        const environment = material.isMeshStandardMaterial ? scene.environment : null;
        const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
        const envMap = cubemaps.get(material.envMap || environment);
        const materialProperties = properties.get(material);
        const lights = currentRenderState.state.lights;
        if (_clippingEnabled === true) {
            if (_localClippingEnabled === true || camera !== _currentCamera) {
                const useCache = camera === _currentCamera && material.id === _currentMaterialId;
                _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
            }
        }
        if (material.version === materialProperties.__version) {
            if (materialProperties.program === undefined) initMaterial(material, scene, object);
            else if (material.fog && materialProperties.fog !== fog) initMaterial(material, scene, object);
            else if (materialProperties.environment !== environment) initMaterial(material, scene, object);
            else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) initMaterial(material, scene, object);
            else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) initMaterial(material, scene, object);
            else if (materialProperties.outputEncoding !== encoding) initMaterial(material, scene, object);
            else if (materialProperties.envMap !== envMap) initMaterial(material, scene, object);
        } else {
            initMaterial(material, scene, object);
            materialProperties.__version = material.version;
        }
        let refreshProgram = false;
        let refreshMaterial = false;
        let refreshLights = false;
        const program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
        if (state.useProgram(program.program)) {
            refreshProgram = true;
            refreshMaterial = true;
            refreshLights = true;
        }
        if (material.id !== _currentMaterialId) {
            _currentMaterialId = material.id;
            refreshMaterial = true;
        }
        if (refreshProgram || _currentCamera !== camera) {
            p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);
            if (capabilities.logarithmicDepthBuffer) p_uniforms.setValue(_gl, 'logDepthBufFC', 2 / (Math.log(camera.far + 1) / Math.LN2));
            if (_currentCamera !== camera) {
                _currentCamera = camera;
                refreshMaterial = true;
                refreshLights = true;
            }
            if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
                const uCamPos = p_uniforms.map.cameraPosition;
                if (uCamPos !== undefined) uCamPos.setValue(_gl, _vector31.setFromMatrixPosition(camera.matrixWorld));
            }
            if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
            if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
        }
        if (material.skinning) {
            p_uniforms.setOptional(_gl, object, 'bindMatrix');
            p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
            const skeleton = object.skeleton;
            if (skeleton) {
                const bones = skeleton.bones;
                if (capabilities.floatVertexTextures) {
                    if (skeleton.boneTexture === undefined) {
                        let size = Math.sqrt(bones.length * 4);
                        size = MathUtils1.ceilPowerOfTwo(size);
                        size = Math.max(size, 4);
                        const boneMatrices = new Float32Array(size * size * 4);
                        boneMatrices.set(skeleton.boneMatrices);
                        const boneTexture = new DataTexture1(boneMatrices, size, size, RGBAFormat, FloatType);
                        skeleton.boneMatrices = boneMatrices;
                        skeleton.boneTexture = boneTexture;
                        skeleton.boneTextureSize = size;
                    }
                    p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
                    p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
                } else p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
            }
        }
        if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
            materialProperties.receiveShadow = object.receiveShadow;
            p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
        }
        if (refreshMaterial) {
            p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
            if (materialProperties.needsLights) markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
            if (fog && material.fog) materials.refreshFogUniforms(m_uniforms, fog);
            materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height);
            if (m_uniforms.ltc_1 !== undefined) m_uniforms.ltc_1.value = UniformsLib1.LTC_1;
            if (m_uniforms.ltc_2 !== undefined) m_uniforms.ltc_2.value = UniformsLib1.LTC_2;
            WebGLUniforms1.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
        }
        if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
            WebGLUniforms1.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
            material.uniformsNeedUpdate = false;
        }
        if (material.isSpriteMaterial) p_uniforms.setValue(_gl, 'center', object.center);
        p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
        p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
        p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
        return program;
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
        uniforms.ambientLightColor.needsUpdate = value;
        uniforms.lightProbe.needsUpdate = value;
        uniforms.directionalLights.needsUpdate = value;
        uniforms.directionalLightShadows.needsUpdate = value;
        uniforms.pointLights.needsUpdate = value;
        uniforms.pointLightShadows.needsUpdate = value;
        uniforms.spotLights.needsUpdate = value;
        uniforms.spotLightShadows.needsUpdate = value;
        uniforms.rectAreaLights.needsUpdate = value;
        uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
        return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    this.setFramebuffer = function(value) {
        if (_framebuffer !== value && _currentRenderTarget === null) _gl.bindFramebuffer(_gl.FRAMEBUFFER, value);
        _framebuffer = value;
    };
    this.getActiveCubeFace = function() {
        return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
        return _currentActiveMipmapLevel;
    };
    this.getRenderList = function() {
        return currentRenderList;
    };
    this.setRenderList = function(renderList) {
        currentRenderList = renderList;
    };
    this.getRenderState = function() {
        return currentRenderState;
    };
    this.setRenderState = function(renderState) {
        currentRenderState = renderState;
    };
    this.getRenderTarget = function() {
        return _currentRenderTarget;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace, activeMipmapLevel) {
        _currentRenderTarget = renderTarget;
        _currentActiveCubeFace = activeCubeFace;
        _currentActiveMipmapLevel = activeMipmapLevel;
        if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) textures.setupRenderTarget(renderTarget);
        let framebuffer = _framebuffer;
        let isCube = false;
        if (renderTarget) {
            const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
            if (renderTarget.isWebGLCubeRenderTarget) {
                framebuffer = __webglFramebuffer[activeCubeFace || 0];
                isCube = true;
            } else if (renderTarget.isWebGLMultisampleRenderTarget) framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
            else framebuffer = __webglFramebuffer;
            _currentViewport.copy(renderTarget.viewport);
            _currentScissor.copy(renderTarget.scissor);
            _currentScissorTest = renderTarget.scissorTest;
        } else {
            _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
            _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
            _currentScissorTest = _scissorTest;
        }
        if (_currentFramebuffer !== framebuffer) {
            _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
            _currentFramebuffer = framebuffer;
        }
        state.viewport(_currentViewport);
        state.scissor(_currentScissor);
        state.setScissorTest(_currentScissorTest);
        if (isCube) {
            const textureProperties = properties.get(renderTarget.texture);
            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + (activeCubeFace || 0), textureProperties.__webglTexture, activeMipmapLevel || 0);
        }
    };
    this.readRenderTargetPixels = function(renderTarget, x6, y6, width2, height2, buffer, activeCubeFaceIndex) {
        if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
            return;
        }
        let framebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) framebuffer = framebuffer[activeCubeFaceIndex];
        if (framebuffer) {
            let restore = false;
            if (framebuffer !== _currentFramebuffer) {
                _gl.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                restore = true;
            }
            try {
                const texture = renderTarget.texture;
                const textureFormat = texture.format;
                const textureType = texture.type;
                if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                    return;
                }
                if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get('OES_texture_float') || extensions.get('WEBGL_color_buffer_float'))) && !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get('EXT_color_buffer_float') : extensions.get('EXT_color_buffer_half_float')))) {
                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                    return;
                }
                if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
                    if (x6 >= 0 && x6 <= renderTarget.width - width2 && (y6 >= 0 && y6 <= renderTarget.height - height2)) _gl.readPixels(x6, y6, width2, height2, utils.convert(textureFormat), utils.convert(textureType), buffer);
                } else console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
            } finally{
                if (restore) _gl.bindFramebuffer(_gl.FRAMEBUFFER, _currentFramebuffer);
            }
        }
    };
    this.copyFramebufferToTexture = function(position, texture, level) {
        if (level === undefined) level = 0;
        const levelScale = Math.pow(2, -level);
        const width2 = Math.floor(texture.image.width * levelScale);
        const height2 = Math.floor(texture.image.height * levelScale);
        const glFormat = utils.convert(texture.format);
        textures.setTexture2D(texture, 0);
        _gl.copyTexImage2D(_gl.TEXTURE_2D, level, glFormat, position.x, position.y, width2, height2, 0);
        state.unbindTexture();
    };
    this.copyTextureToTexture = function(position, srcTexture, dstTexture, level) {
        if (level === undefined) level = 0;
        const width2 = srcTexture.image.width;
        const height2 = srcTexture.image.height;
        const glFormat = utils.convert(dstTexture.format);
        const glType = utils.convert(dstTexture.type);
        textures.setTexture2D(dstTexture, 0);
        _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
        _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
        _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
        if (srcTexture.isDataTexture) _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width2, height2, glFormat, glType, srcTexture.image.data);
        else if (srcTexture.isCompressedTexture) _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
        else _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);
        if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);
        state.unbindTexture();
    };
    this.initTexture = function(texture) {
        textures.setTexture2D(texture, 0);
        state.unbindTexture();
    };
    if (typeof __THREE_DEVTOOLS__ !== 'undefined') __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
        detail: this
    }));
}
const WebGLRenderer1 = WebGLRenderer2;
function WebGL1Renderer(parameters) {
    WebGLRenderer1.call(this, parameters);
}
WebGL1Renderer.prototype = Object.assign(Object.create(WebGLRenderer1.prototype), {
    constructor: WebGL1Renderer,
    isWebGL1Renderer: true
});
const WebGL1Renderer1 = WebGL1Renderer;
export { WebGL1Renderer1 as WebGL1Renderer };
const ShaderLib2 = {
    basic: {
        uniforms: mergeUniforms([
            UniformsLib1.common,
            UniformsLib1.specularmap,
            UniformsLib1.envmap,
            UniformsLib1.aomap,
            UniformsLib1.lightmap,
            UniformsLib1.fog
        ]),
        vertexShader: ShaderChunk.meshbasic_vert,
        fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
        uniforms: mergeUniforms([
            UniformsLib1.common,
            UniformsLib1.specularmap,
            UniformsLib1.envmap,
            UniformsLib1.aomap,
            UniformsLib1.lightmap,
            UniformsLib1.emissivemap,
            UniformsLib1.fog,
            UniformsLib1.lights,
            {
                emissive: {
                    value: new Color1(0)
                }
            }
        ]),
        vertexShader: ShaderChunk.meshlambert_vert,
        fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
        uniforms: mergeUniforms([
            UniformsLib1.common,
            UniformsLib1.specularmap,
            UniformsLib1.envmap,
            UniformsLib1.aomap,
            UniformsLib1.lightmap,
            UniformsLib1.emissivemap,
            UniformsLib1.bumpmap,
            UniformsLib1.normalmap,
            UniformsLib1.displacementmap,
            UniformsLib1.fog,
            UniformsLib1.lights,
            {
                emissive: {
                    value: new Color1(0)
                },
                specular: {
                    value: new Color1(1118481)
                },
                shininess: {
                    value: 30
                }
            }
        ]),
        vertexShader: ShaderChunk.meshphong_vert,
        fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
        uniforms: mergeUniforms([
            UniformsLib1.common,
            UniformsLib1.envmap,
            UniformsLib1.aomap,
            UniformsLib1.lightmap,
            UniformsLib1.emissivemap,
            UniformsLib1.bumpmap,
            UniformsLib1.normalmap,
            UniformsLib1.displacementmap,
            UniformsLib1.roughnessmap,
            UniformsLib1.metalnessmap,
            UniformsLib1.fog,
            UniformsLib1.lights,
            {
                emissive: {
                    value: new Color1(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }
        ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    },
    toon: {
        uniforms: mergeUniforms([
            UniformsLib1.common,
            UniformsLib1.aomap,
            UniformsLib1.lightmap,
            UniformsLib1.emissivemap,
            UniformsLib1.bumpmap,
            UniformsLib1.normalmap,
            UniformsLib1.displacementmap,
            UniformsLib1.gradientmap,
            UniformsLib1.fog,
            UniformsLib1.lights,
            {
                emissive: {
                    value: new Color1(0)
                }
            }
        ]),
        vertexShader: ShaderChunk.meshtoon_vert,
        fragmentShader: ShaderChunk.meshtoon_frag
    },
    matcap: {
        uniforms: mergeUniforms([
            UniformsLib1.common,
            UniformsLib1.bumpmap,
            UniformsLib1.normalmap,
            UniformsLib1.displacementmap,
            UniformsLib1.fog,
            {
                matcap: {
                    value: null
                }
            }
        ]),
        vertexShader: ShaderChunk.meshmatcap_vert,
        fragmentShader: ShaderChunk.meshmatcap_frag
    },
    points: {
        uniforms: mergeUniforms([
            UniformsLib1.points,
            UniformsLib1.fog
        ]),
        vertexShader: ShaderChunk.points_vert,
        fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
        uniforms: mergeUniforms([
            UniformsLib1.common,
            UniformsLib1.fog,
            {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }
        ]),
        vertexShader: ShaderChunk.linedashed_vert,
        fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
        uniforms: mergeUniforms([
            UniformsLib1.common,
            UniformsLib1.displacementmap
        ]),
        vertexShader: ShaderChunk.depth_vert,
        fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
        uniforms: mergeUniforms([
            UniformsLib1.common,
            UniformsLib1.bumpmap,
            UniformsLib1.normalmap,
            UniformsLib1.displacementmap,
            {
                opacity: {
                    value: 1
                }
            }
        ]),
        vertexShader: ShaderChunk.normal_vert,
        fragmentShader: ShaderChunk.normal_frag
    },
    sprite: {
        uniforms: mergeUniforms([
            UniformsLib1.sprite,
            UniformsLib1.fog
        ]),
        vertexShader: ShaderChunk.sprite_vert,
        fragmentShader: ShaderChunk.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new Matrix31()
            },
            t2D: {
                value: null
            }
        },
        vertexShader: ShaderChunk.background_vert,
        fragmentShader: ShaderChunk.background_frag
    },
    cube: {
        uniforms: mergeUniforms([
            UniformsLib1.envmap,
            {
                opacity: {
                    value: 1
                }
            }
        ]),
        vertexShader: ShaderChunk.cube_vert,
        fragmentShader: ShaderChunk.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: ShaderChunk.equirect_vert,
        fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
        uniforms: mergeUniforms([
            UniformsLib1.common,
            UniformsLib1.displacementmap,
            {
                referencePosition: {
                    value: new Vector31()
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1000
                }
            }
        ]),
        vertexShader: ShaderChunk.distanceRGBA_vert,
        fragmentShader: ShaderChunk.distanceRGBA_frag
    },
    shadow: {
        uniforms: mergeUniforms([
            UniformsLib1.lights,
            UniformsLib1.fog,
            {
                color: {
                    value: new Color1(0)
                },
                opacity: {
                    value: 1
                }
            }, 
        ]),
        vertexShader: ShaderChunk.shadow_vert,
        fragmentShader: ShaderChunk.shadow_frag
    }
};
ShaderLib2.physical = {
    uniforms: mergeUniforms([
        ShaderLib2.standard.uniforms,
        {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatNormalScale: {
                value: new Vector21(1, 1)
            },
            clearcoatNormalMap: {
                value: null
            },
            sheen: {
                value: new Color1(0)
            },
            transmission: {
                value: 0
            },
            transmissionMap: {
                value: null
            }
        }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
};
const ShaderLib1 = ShaderLib2;
export { ShaderLib1 as ShaderLib };
const UniformsLib2 = {
    common: {
        diffuse: {
            value: new Color1(15658734)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new Matrix31()
        },
        uv2Transform: {
            value: new Matrix31()
        },
        alphaMap: {
            value: null
        }
    },
    specularmap: {
        specularMap: {
            value: null
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        refractionRatio: {
            value: 0.98
        },
        maxMipLevel: {
            value: 0
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new Vector21(1, 1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 0.00025
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2000
        },
        fogColor: {
            value: new Color1(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {
                },
                color: {
                }
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {
                },
                shadowNormalBias: {
                },
                shadowRadius: {
                },
                shadowMapSize: {
                }
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {
                },
                position: {
                },
                direction: {
                },
                distance: {
                },
                coneCos: {
                },
                penumbraCos: {
                },
                decay: {
                }
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {
                },
                shadowNormalBias: {
                },
                shadowRadius: {
                },
                shadowMapSize: {
                }
            }
        },
        spotShadowMap: {
            value: []
        },
        spotShadowMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {
                },
                position: {
                },
                decay: {
                },
                distance: {
                }
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {
                },
                shadowNormalBias: {
                },
                shadowRadius: {
                },
                shadowMapSize: {
                },
                shadowCameraNear: {
                },
                shadowCameraFar: {
                }
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {
                },
                skyColor: {
                },
                groundColor: {
                }
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {
                },
                position: {
                },
                width: {
                },
                height: {
                }
            }
        }
    },
    points: {
        diffuse: {
            value: new Color1(15658734)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        uvTransform: {
            value: new Matrix31()
        }
    },
    sprite: {
        diffuse: {
            value: new Color1(15658734)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new Vector21(0.5, 0.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        uvTransform: {
            value: new Matrix31()
        }
    }
};
const UniformsLib1 = UniformsLib2;
export { UniformsLib1 as UniformsLib };
function cloneUniforms(src) {
    const dst = {
    };
    for(const u in src){
        dst[u] = {
        };
        for(const p in src[u]){
            const property = src[u][p];
            if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) dst[u][p] = property.clone();
            else if (Array.isArray(property)) dst[u][p] = property.slice();
            else dst[u][p] = property;
        }
    }
    return dst;
}
function mergeUniforms(uniforms) {
    const merged = {
    };
    for(let u = 0; u < uniforms.length; u++){
        const tmp = cloneUniforms(uniforms[u]);
        for(const p in tmp)merged[p] = tmp[p];
    }
    return merged;
}
const UniformsUtils2 = {
    clone: cloneUniforms,
    merge: mergeUniforms
};
const UniformsUtils1 = UniformsUtils2;
export { UniformsUtils1 as UniformsUtils };
const alphamap_fragment = `\n#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n`;
const alphamap_pars_fragment = `\n#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n`;
const alphatest_fragment = `\n#ifdef ALPHATEST\n\n	if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n`;
const aomap_fragment = `\n#ifdef USE_AOMAP\n\n	// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\n	#endif\n\n#endif\n`;
const aomap_pars_fragment = `\n#ifdef USE_AOMAP\n\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n\n#endif\n`;
const begin_vertex = `\nvec3 transformed = vec3( position );\n`;
const beginnormal_vertex = `\nvec3 objectNormal = vec3( normal );\n\n#ifdef USE_TANGENT\n\n	vec3 objectTangent = vec3( tangent.xyz );\n\n#endif\n`;
const bsdfs = `\n\n// Analytical approximation of the DFG LUT, one half of the\n// split-sum approximation used in indirect specular lighting.\n// via 'environmentBRDF' from "Physically Based Shading on Mobile"\n// https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n	vec4 r = roughness * c0 + c1;\n\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n}\n\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n	// based upon Frostbite 3 Moving to Physically-based Rendering\n	// page 32, equation 26: E[window1]\n	// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n	// this is intended to be used on spot and point lights who are represented as luminous intensity\n	// but who must be converted to luminous irradiance for surface lighting calculation\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\n	if( cutoffDistance > 0.0 ) {\n\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n	}\n\n	return distanceFalloff;\n\n#else\n\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n	}\n\n	return 1.0;\n\n#endif\n\n}\n\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\n	return RECIPROCAL_PI * diffuseColor;\n\n} // validated\n\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\n	// Original approximation by Christophe Schlick '94\n	// float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n	// Optimized variant (presented by Epic at SIGGRAPH '13)\n	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n} // validated\n\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\n	// See F_Schlick\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\n	return Fr * fresnel + F0;\n\n}\n\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (34)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is "roughness squared" in Disneys reparameterization\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n	// geometry term (normalized) = G(l)G(v) / 4(nl)(nv)\n	// also see #12151\n\n	float a2 = pow2( alpha );\n\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\n	return 1.0 / ( gl * gv );\n\n} // validated\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n	float a2 = pow2( alpha );\n\n	// dotNL and dotNV are explicitly swapped. This is not a mistake.\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n	return 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is "roughness squared" in Disneys reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n	float a2 = pow2( alpha );\n\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n	return RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\n	float alpha = pow2( roughness ); // UE4's roughness\n\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n	vec3 F = F_Schlick( specularColor, dotLH );\n\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n	float D = D_GGX( alpha, dotNH );\n\n	return F * ( G * D );\n\n} // validated\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n\n	float dotNV = saturate( dot( N, V ) );\n\n	// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\n	uv = uv * LUT_SCALE + LUT_BIAS;\n\n	return uv;\n\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\n	// Real-Time Area Lighting: a Journey from Research to Production (p.102)\n	// An approximation of the form factor of a horizon-clipped rectangle.\n\n	float l = length( f );\n\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\n	float x = dot( v1, v2 );\n\n	float y = abs( x );\n\n	// rational polynomial approximation to theta / sin( theta ) / 2PI\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\n	return cross( v1, v2 ) * theta_sintheta;\n\n}\n\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\n	// bail if point is on back side of plane of light\n	// assumes ccw winding order of light vertices\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\n	// construct orthonormal basis around N\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\n	// compute transform\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\n	// transform rect\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\n	// project rect onto sphere\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n\n	// calculate vector form factor\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\n	// adjust for horizon clipping\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n/*\n	// alternate method of adjusting for horizon clipping (see referece)\n	// refactoring required\n	float len = length( vectorFormFactor );\n	float z = vectorFormFactor.z / len;\n\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n\n	// tabulated horizon-clipped sphere, apparently...\n	vec2 uv = vec2( z * 0.5 + 0.5, len );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n\n	float scale = texture2D( ltc_2, uv ).w;\n\n	float result = len * scale;\n*/\n\n	return vec3( result );\n\n}\n\n// End Rect Area Light\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\n	float dotNV = saturate( dot( normal, viewDir ) );\n\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\n	return specularColor * brdf.x + brdf.y;\n\n} // validated\n\n// Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"\n// Approximates multiscattering in order to preserve energy.\n// http://www.jcgt.org/published/0008/01/03/\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21\n	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n\n	// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n	return 0.25;\n\n}\n\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n	//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n	//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n	vec3 F = F_Schlick( specularColor, dotLH );\n\n	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n	float D = D_BlinnPhong( shininess, dotNH );\n\n	return F * ( G * D );\n\n} // validated\n\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\n\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n\n#if defined( USE_SHEEN )\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L94\nfloat D_Charlie(float roughness, float NoH) {\n	// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125); // 2^(-14/2), so sin2h^2 > 0 in fp16\n	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\n\n// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L136\nfloat V_Neubelt(float NoV, float NoL) {\n	// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\n\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n\n}\n\n#endif\n`;
const bumpmap_pars_fragment = `\n#ifdef USE_BUMPMAP\n\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n\n	// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n	// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\n	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n	vec2 dHdxy_fwd() {\n\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n		return vec2( dBx, dBy );\n\n	}\n\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;		// normalized\n\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n\n		float fDet = dot( vSigmaX, R1 );\n\n		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n\n	}\n\n#endif\n`;
const clipping_planes_fragment = `\n#if NUM_CLIPPING_PLANES > 0\n\n	vec4 plane;\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\n	}\n	#pragma unroll_loop_end\n\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\n		bool clipped = true;\n\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\n		}\n		#pragma unroll_loop_end\n\n		if ( clipped ) discard;\n\n	#endif\n\n#endif\n`;
const clipping_planes_pars_fragment = `\n#if NUM_CLIPPING_PLANES > 0\n\n	varying vec3 vClipPosition;\n\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n\n#endif\n`;
const clipping_planes_pars_vertex = `\n#if NUM_CLIPPING_PLANES > 0\n\n	varying vec3 vClipPosition;\n\n#endif\n`;
const clipping_planes_vertex = `\n#if NUM_CLIPPING_PLANES > 0\n\n	vClipPosition = - mvPosition.xyz;\n\n#endif\n`;
const color_fragment = `\n#ifdef USE_COLOR\n\n	diffuseColor.rgb *= vColor;\n\n#endif\n`;
const color_pars_fragment = `\n#ifdef USE_COLOR\n\n	varying vec3 vColor;\n\n#endif\n`;
const color_pars_vertex = `\n#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\n	varying vec3 vColor;\n\n#endif\n`;
const color_vertex = `\n#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\n	vColor = vec3( 1.0 );\n\n#endif\n\n#ifdef USE_COLOR\n\n	vColor.xyz *= color.xyz;\n\n#endif\n\n#ifdef USE_INSTANCING_COLOR\n\n	vColor.xyz *= instanceColor.xyz;\n\n#endif\n`;
const common = `\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n\n#ifndef saturate\n// <tonemapping_pars_fragment> may have defined saturate() already\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\n\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\n\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n	// dir can be either a direction vector or a normal vector\n	// upper-left 3x3 of matrix is assumed to be orthogonal\n\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	float distance = dot( planeNormal, point - pointOnPlane );\n\n	return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nmat3 transposeMat3( const in mat3 m ) {\n\n	mat3 tmp;\n\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n	return tmp;\n\n}\n\n// https://en.wikipedia.org/wiki/Relative_luminance\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\n	return dot( weights, color.rgb );\n\n}\n\nbool isPerspectiveMatrix( mat4 m ) {\n\n	return m[ 2 ][ 3 ] == - 1.0;\n\n}\n\nvec2 equirectUv( in vec3 dir ) {\n\n	// dir is assumed to be unit length\n\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n	return vec2( u, v );\n\n}\n`;
const cube_uv_reflection_fragment = `\n#ifdef ENVMAP_TYPE_CUBE_UV\n\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n\n	// These shader functions convert between the UV coordinates of a single face of\n	// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n	// sampling a textureCube (not generally normalized ).\n\n	float getFace( vec3 direction ) {\n\n		vec3 absDirection = abs( direction );\n\n		float face = - 1.0;\n\n		if ( absDirection.x > absDirection.z ) {\n\n			if ( absDirection.x > absDirection.y )\n\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n\n			else\n\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n\n		} else {\n\n			if ( absDirection.z > absDirection.y )\n\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n\n			else\n\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n\n		}\n\n		return face;\n\n	}\n\n	// RH coordinate system; PMREM face-indexing convention\n	vec2 getUV( vec3 direction, float face ) {\n\n		vec2 uv;\n\n		if ( face == 0.0 ) {\n\n			uv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x\n\n		} else if ( face == 1.0 ) {\n\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y\n\n		} else if ( face == 2.0 ) {\n\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z\n\n		} else if ( face == 3.0 ) {\n\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x\n\n		} else if ( face == 4.0 ) {\n\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y\n\n		} else {\n\n			uv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z\n\n		}\n\n		return 0.5 * ( uv + 1.0 );\n\n	}\n\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\n		float face = getFace( direction );\n\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n\n		float faceSize = exp2( mipInt );\n\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\n		vec2 f = fract( uv );\n\n		uv += 0.5 - f;\n\n		if ( face > 2.0 ) {\n\n			uv.y += faceSize;\n\n			face -= 3.0;\n\n		}\n\n		uv.x += face * faceSize;\n\n		if ( mipInt < cubeUV_maxMipLevel ) {\n\n			uv.y += 2.0 * cubeUV_maxTileSize;\n\n		}\n\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\n		uv *= texelSize;\n\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\n		uv.x += texelSize;\n\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\n		uv.y += texelSize;\n\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\n		uv.x -= texelSize;\n\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\n		vec3 tm = mix( tl, tr, f.x );\n\n		vec3 bm = mix( bl, br, f.x );\n\n		return mix( tm, bm, f.y );\n\n	}\n\n	// These defines must match with PMREMGenerator\n\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n\n	float roughnessToMip( float roughness ) {\n\n		float mip = 0.0;\n\n		if ( roughness >= r1 ) {\n\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\n		} else if ( roughness >= r4 ) {\n\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\n		} else if ( roughness >= r5 ) {\n\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\n		} else if ( roughness >= r6 ) {\n\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\n		} else {\n\n			mip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25\n		}\n\n		return mip;\n\n	}\n\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\n		float mipF = fract( mip );\n\n		float mipInt = floor( mip );\n\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\n		if ( mipF == 0.0 ) {\n\n			return vec4( color0, 1.0 );\n\n		} else {\n\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n\n		}\n\n	}\n\n#endif\n`;
const defaultnormal_vertex = `\nvec3 transformedNormal = objectNormal;\n\n#ifdef USE_INSTANCING\n\n	// this is in lieu of a per-instance normal-matrix\n	// shear transforms in the instance matrix are not supported\n\n	mat3 m = mat3( instanceMatrix );\n\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\n	transformedNormal = m * transformedNormal;\n\n#endif\n\ntransformedNormal = normalMatrix * transformedNormal;\n\n#ifdef FLIP_SIDED\n\n	transformedNormal = - transformedNormal;\n\n#endif\n\n#ifdef USE_TANGENT\n\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n	#ifdef FLIP_SIDED\n\n		transformedTangent = - transformedTangent;\n\n	#endif\n\n#endif\n`;
const displacementmap_pars_vertex = `\n#ifdef USE_DISPLACEMENTMAP\n\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n\n#endif\n`;
const displacementmap_vertex = `\n#ifdef USE_DISPLACEMENTMAP\n\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n\n#endif\n`;
const emissivemap_fragment = `\n#ifdef USE_EMISSIVEMAP\n\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n	totalEmissiveRadiance *= emissiveColor.rgb;\n\n#endif\n`;
const emissivemap_pars_fragment = `\n#ifdef USE_EMISSIVEMAP\n\n	uniform sampler2D emissiveMap;\n\n#endif\n`;
const encodings_fragment = `\ngl_FragColor = linearToOutputTexel( gl_FragColor );\n`;
const encodings_pars_fragment = `\n// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\n\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\n\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\n\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\n\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\n\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\n\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\n\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n	// return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\n\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\n\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	// NOTE: The implementation with min causes the shader to not compile on\n	// a common Alcatel A502DL in Chrome 78/Android 8.1. Some research suggests \n	// that the chipset is Mediatek MT6739 w/ IMG PowerVR GE8100 GPU.\n	// D = min( floor( D ) / 255.0, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\n\n// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n\n// M matrix, for encoding\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\n\n// Inverse M matrix, for decoding\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}\n`;
const envmap_fragment = `\n#ifdef USE_ENVMAP\n\n	#ifdef ENV_WORLDPOS\n\n		vec3 cameraToFrag;\n\n		if ( isOrthographic ) {\n\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\n		} else {\n\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n\n		}\n\n		// Transforming Normal Vectors with the Inverse Transformation\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\n		#else\n\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\n		#endif\n\n	#else\n\n		vec3 reflectVec = vReflect;\n\n	#endif\n\n	#ifdef ENVMAP_TYPE_CUBE\n\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\n	#else\n\n		vec4 envColor = vec4( 0.0 );\n\n	#endif\n\n	#ifndef ENVMAP_TYPE_CUBE_UV\n\n		envColor = envMapTexelToLinear( envColor );\n\n	#endif\n\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_MIX )\n\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n	#elif defined( ENVMAP_BLENDING_ADD )\n\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n	#endif\n\n#endif\n`;
const envmap_common_pars_fragment = `\n#ifdef USE_ENVMAP\n\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif\n`;
const envmap_pars_fragment = `\n#ifdef USE_ENVMAP\n\n	uniform float reflectivity;\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n		#define ENV_WORLDPOS\n\n	#endif\n\n	#ifdef ENV_WORLDPOS\n\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n\n#endif\n`;
const envmap_pars_vertex = `\n#ifdef USE_ENVMAP\n\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\n		#define ENV_WORLDPOS\n\n	#endif\n\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n\n	#else\n\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n\n	#endif\n\n#endif\n`;
const envmap_vertex = `\n#ifdef USE_ENVMAP\n\n	#ifdef ENV_WORLDPOS\n\n		vWorldPosition = worldPosition.xyz;\n\n	#else\n\n		vec3 cameraToVertex;\n\n		if ( isOrthographic ) {\n\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\n		} else {\n\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n		}\n\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vReflect = reflect( cameraToVertex, worldNormal );\n\n		#else\n\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n		#endif\n\n	#endif\n\n#endif\n`;
const fog_vertex = `\n#ifdef USE_FOG\n\n	fogDepth = - mvPosition.z;\n\n#endif\n`;
const fog_pars_vertex = `\n#ifdef USE_FOG\n\n	varying float fogDepth;\n\n#endif\n`;
const fog_fragment = `\n#ifdef USE_FOG\n\n	#ifdef FOG_EXP2\n\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\n	#else\n\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\n	#endif\n\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\n#endif\n`;
const fog_pars_fragment = `\n#ifdef USE_FOG\n\n	uniform vec3 fogColor;\n	varying float fogDepth;\n\n	#ifdef FOG_EXP2\n\n		uniform float fogDensity;\n\n	#else\n\n		uniform float fogNear;\n		uniform float fogFar;\n\n	#endif\n\n#endif\n`;
const gradientmap_pars_fragment = `\n\n#ifdef USE_GRADIENTMAP\n\n	uniform sampler2D gradientMap;\n\n#endif\n\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\n	// dotNL will be from -1.0 to 1.0\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\n	#ifdef USE_GRADIENTMAP\n\n		return texture2D( gradientMap, coord ).rgb;\n\n	#else\n\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\n	#endif\n\n}\n`;
const lightmap_fragment = `\n#ifdef USE_LIGHTMAP\n\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage\n\n#endif\n`;
const lightmap_pars_fragment = `\n#ifdef USE_LIGHTMAP\n\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n\n#endif\n`;
const lights_lambert_vertex = `\nvec3 diffuse = vec3( 1.0 );\n\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\n\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\n\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\n\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\n\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n\n#ifdef DOUBLE_SIDED\n\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n\n#endif\n\n#if NUM_POINT_LIGHTS > 0\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n		#endif\n\n	}\n	#pragma unroll_loop_end\n\n#endif\n\n#if NUM_SPOT_LIGHTS > 0\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n		#endif\n	}\n	#pragma unroll_loop_end\n\n#endif\n\n/*\n#if NUM_RECT_AREA_LIGHTS > 0\n\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n		// TODO (abelnation): implement\n\n	}\n\n#endif\n*/\n\n#if NUM_DIR_LIGHTS > 0\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n		#ifdef DOUBLE_SIDED\n\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n		#endif\n\n	}\n	#pragma unroll_loop_end\n\n#endif\n\n#if NUM_HEMI_LIGHTS > 0\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n		#ifdef DOUBLE_SIDED\n\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\n		#endif\n\n	}\n	#pragma unroll_loop_end\n\n#endif\n`;
const lights_pars_begin = `\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\n\n// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\n	// normal is assumed to have unit length\n\n	float x = normal.x, y = normal.y, z = normal.z;\n\n	// band 0\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n\n	// band 1\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\n	// band 2\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\n	return result;\n\n}\n\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\n	return irradiance;\n\n}\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n	vec3 irradiance = ambientLightColor;\n\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n		irradiance *= PI;\n\n	#endif\n\n	return irradiance;\n\n}\n\n#if NUM_DIR_LIGHTS > 0\n\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n\n	}\n\n#endif\n\n\n#if NUM_POINT_LIGHTS > 0\n\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\n	// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n\n		float lightDistance = length( lVector );\n\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n\n	}\n\n#endif\n\n\n#if NUM_SPOT_LIGHTS > 0\n\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\n	// directLight is an out parameter as having it as a return value caused compiler errors on some devices\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n\n		if ( angleCos > spotLight.coneCos ) {\n\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n\n		} else {\n\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n\n		}\n	}\n\n#endif\n\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n\n	// Pre-computed values of LinearTransformedCosine approximation of BRDF\n	// BRDF approximation Texture is 64x64\n	uniform sampler2D ltc_1; // RGBA Float\n	uniform sampler2D ltc_2; // RGBA Float\n\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n\n#endif\n\n\n#if NUM_HEMI_LIGHTS > 0\n\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n			irradiance *= PI;\n\n		#endif\n\n		return irradiance;\n\n	}\n\n#endif\n`;
const envmap_physical_pars_fragment = `\n#if defined( USE_ENVMAP )\n\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n\n	vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\n\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n		#ifdef ENVMAP_TYPE_CUBE\n\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\n			// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n			// of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n\n			#ifdef TEXTURE_LOD_EXT\n\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\n			#else\n\n				// force the bias high to get the last LOD level as it is the most blurred.\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\n			#endif\n\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\n		#else\n\n			vec4 envMapColor = vec4( 0.0 );\n\n		#endif\n\n		return PI * envMapColor.rgb * envMapIntensity;\n\n	}\n\n	// Trowbridge-Reitz distribution to Mip level, following the logic of http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\n		float maxMIPLevelScalar = float( maxMIPLevel );\n\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\n		// clamp to allowable LOD ranges.\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n	}\n\n	vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\n		#ifdef ENVMAP_MODE_REFLECTION\n\n			vec3 reflectVec = reflect( -viewDir, normal );\n\n			// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\n		#else\n\n			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\n		#endif\n\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\n		#ifdef ENVMAP_TYPE_CUBE\n\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\n			#ifdef TEXTURE_LOD_EXT\n\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\n			#else\n\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\n			#endif\n\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\n		#endif\n\n		return envMapColor.rgb * envMapIntensity;\n\n	}\n\n#endif\n`;
const lights_toon_fragment = `\nToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\n`;
const lights_toon_pars_fragment = `\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n\n\nstruct ToonMaterial {\n\n	vec3 diffuseColor;\n\n};\n\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n		irradiance *= PI; // punctual light\n\n	#endif\n\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n\n#define Material_LightProbeLOD( material )	(0)\n`;
const lights_phong_fragment = `\nBlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n`;
const lights_phong_pars_fragment = `\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n\n\nstruct BlinnPhongMaterial {\n\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n\n};\n\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n		irradiance *= PI; // punctual light\n\n	#endif\n\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n\n#define Material_LightProbeLOD( material )	(0)\n`;
const lights_physical_fragment = `\nPhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\n\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\n\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.\nmaterial.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n\n#ifdef REFLECTIVITY\n\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\n#else\n\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n\n#endif\n\n#ifdef CLEARCOAT\n\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n\n	#ifdef USE_CLEARCOATMAP\n\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\n	#endif\n\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\n	#endif\n\n	material.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model\n	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n\n#endif\n\n#ifdef USE_SHEEN\n\n	material.sheenColor = sheen;\n\n#endif\n`;
const lights_physical_pars_fragment = `\nstruct PhysicalMaterial {\n\n	vec3 diffuseColor;\n	float specularRoughness;\n	vec3 specularColor;\n\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n\n};\n\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n// Clear coat directional hemishperical reflectance (this approximation should be improved)\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n\n}\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction\n		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n\n		// LTC Fresnel Approximation by Stephen Hill\n		// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\n	}\n\n#endif\n\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n	vec3 irradiance = dotNL * directLight.color;\n\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n		irradiance *= PI; // punctual light\n\n	#endif\n\n	#ifdef CLEARCOAT\n\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n			ccIrradiance *= PI; // punctual light\n\n		#endif\n\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\n	#else\n\n		float clearcoatDHR = 0.0;\n\n	#endif\n\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\n	#ifdef CLEARCOAT\n\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\n	#else\n\n		float clearcoatDHR = 0.0;\n\n	#endif\n\n	float clearcoatInv = 1.0 - clearcoatDHR;\n\n	// Both indirect specular and indirect diffuse light accumulate here\n\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\n}\n\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\n\n// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n`;
const lights_fragment_begin = `\n/**\n * This is a template that can be used to light a material, it uses pluggable\n * RenderEquations (RE)for specific lighting scenarios.\n *\n * Instructions for use:\n * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???\n * - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n *\n * TODO:\n * - Add area light support.\n * - Add sphere light support.\n * - Add diffuse light probe (irradiance cubemap) support.\n */\n\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n#ifdef CLEARCOAT\n\n	geometry.clearcoatNormal = clearcoatNormal;\n\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n		pointLight = pointLights[ i ];\n\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n\n		RE_Direct( directLight, geometry, material, reflectedLight );\n\n	}\n	#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n		spotLight = spotLights[ i ];\n\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n\n		RE_Direct( directLight, geometry, material, reflectedLight );\n\n	}\n	#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n		directionalLight = directionalLights[ i ];\n\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n\n		RE_Direct( directLight, geometry, material, reflectedLight );\n\n	}\n	#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n	RectAreaLight rectAreaLight;\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n	}\n	#pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n	vec3 iblIrradiance = vec3( 0.0 );\n\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n\n	#if ( NUM_HEMI_LIGHTS > 0 )\n\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n		}\n		#pragma unroll_loop_end\n\n	#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif\n`;
const lights_fragment_maps = `\n#if defined( RE_IndirectDiffuse )\n\n	#ifdef USE_LIGHTMAP\n\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n			lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\n\n		#endif\n\n		irradiance += lightMapIrradiance;\n\n	#endif\n\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\n		iblIrradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );\n\n	#endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n	radiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\n	#ifdef CLEARCOAT\n\n		clearcoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\n	#endif\n\n#endif\n`;
const lights_fragment_end = `\n#if defined( RE_IndirectDiffuse )\n\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n\n#endif\n`;
const logdepthbuf_fragment = `\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n	// Doing a strict comparison with == 1.0 can cause noise artifacts\n	// on some platforms. See issue #17623.\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n\n#endif\n`;
const logdepthbuf_pars_fragment = `\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n\n#endif\n`;
const logdepthbuf_pars_vertex = `\n#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		varying float vFragDepth;\n		varying float vIsPerspective;\n\n	#else\n\n		uniform float logDepthBufFC;\n\n	#endif\n\n#endif\n`;
const logdepthbuf_vertex = `\n#ifdef USE_LOGDEPTHBUF\n\n	#ifdef USE_LOGDEPTHBUF_EXT\n\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\n	#else\n\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\n			gl_Position.z *= gl_Position.w;\n\n		}\n\n	#endif\n\n#endif\n`;
const map_fragment = `\n#ifdef USE_MAP\n\n	vec4 texelColor = texture2D( map, vUv );\n\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n\n#endif\n`;
const map_pars_fragment = `\n#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif\n`;
const map_particle_fragment = `\n#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\n#endif\n\n#ifdef USE_MAP\n\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n\n#endif\n\n#ifdef USE_ALPHAMAP\n\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n\n#endif\n`;
const map_particle_pars_fragment = `\n#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\n	uniform mat3 uvTransform;\n\n#endif\n\n#ifdef USE_MAP\n\n	uniform sampler2D map;\n\n#endif\n\n#ifdef USE_ALPHAMAP\n\n	uniform sampler2D alphaMap;\n\n#endif\n`;
const metalnessmap_fragment = `\nfloat metalnessFactor = metalness;\n\n#ifdef USE_METALNESSMAP\n\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n	// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n	metalnessFactor *= texelMetalness.b;\n\n#endif\n`;
const metalnessmap_pars_fragment = `\n#ifdef USE_METALNESSMAP\n\n	uniform sampler2D metalnessMap;\n\n#endif\n`;
const morphnormal_vertex = `\n#ifdef USE_MORPHNORMALS\n\n	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)\n	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\n#endif\n`;
const morphtarget_pars_vertex = `\n#ifdef USE_MORPHTARGETS\n\n	uniform float morphTargetBaseInfluence;\n\n	#ifndef USE_MORPHNORMALS\n\n		uniform float morphTargetInfluences[ 8 ];\n\n	#else\n\n		uniform float morphTargetInfluences[ 4 ];\n\n	#endif\n\n#endif\n`;
const morphtarget_vertex = `\n#ifdef USE_MORPHTARGETS\n\n	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)\n	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\n	#ifndef USE_MORPHNORMALS\n\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\n	#endif\n\n#endif\n`;
const normal_fragment_begin = `\n#ifdef FLAT_SHADED\n\n	// Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n\n#else\n\n	vec3 normal = normalize( vNormal );\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n	#endif\n\n	#ifdef USE_TANGENT\n\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n\n		#ifdef DOUBLE_SIDED\n\n			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n		#endif\n\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n\n		#endif\n\n	#endif\n\n#endif\n\n// non perturbed normal for clearcoat among others\n\nvec3 geometryNormal = normal;\n\n`;
const normal_fragment_maps = `\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n	#ifdef FLIP_SIDED\n\n		normal = - normal;\n\n	#endif\n\n	#ifdef DOUBLE_SIDED\n\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n	#endif\n\n	normal = normalize( normalMatrix * normal );\n\n#elif defined( TANGENTSPACE_NORMALMAP )\n\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n\n	#ifdef USE_TANGENT\n\n		normal = normalize( vTBN * mapN );\n\n	#else\n\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\n	#endif\n\n#elif defined( USE_BUMPMAP )\n\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n`;
const normalmap_pars_fragment = `\n#ifdef USE_NORMALMAP\n\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n\n#endif\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n	uniform mat3 normalMatrix;\n\n#endif\n\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\n	// Per-Pixel Tangent Space Normal Mapping\n	// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\n		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n\n		float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n		vec3 N = normalize( surf_norm );\n\n		mat3 tsn = mat3( S, T, N );\n\n		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n		return normalize( tsn * mapN );\n\n	}\n\n#endif\n`;
const clearcoat_normal_fragment_begin = `\n#ifdef CLEARCOAT\n\n	vec3 clearcoatNormal = geometryNormal;\n\n#endif\n`;
const clearcoat_normal_fragment_maps = `\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n\n	#ifdef USE_TANGENT\n\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n\n	#else\n\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\n	#endif\n\n#endif\n`;
const clearcoat_pars_fragment = `\n\n#ifdef USE_CLEARCOATMAP\n\n	uniform sampler2D clearcoatMap;\n\n#endif\n\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\n	uniform sampler2D clearcoatRoughnessMap;\n\n#endif\n\n#ifdef USE_CLEARCOAT_NORMALMAP\n\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n\n#endif\n`;
const packing = `\nvec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8; // tidy overflow\n	return r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\n\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n`;
const premultiplied_alpha_fragment = `\n#ifdef PREMULTIPLIED_ALPHA\n\n	// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\n	gl_FragColor.rgb *= gl_FragColor.a;\n\n#endif\n`;
const project_vertex = `\nvec4 mvPosition = vec4( transformed, 1.0 );\n\n#ifdef USE_INSTANCING\n\n	mvPosition = instanceMatrix * mvPosition;\n\n#endif\n\nmvPosition = modelViewMatrix * mvPosition;\n\ngl_Position = projectionMatrix * mvPosition;\n`;
const dithering_fragment = `\n#ifdef DITHERING\n\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\n#endif\n`;
const dithering_pars_fragment = `\n#ifdef DITHERING\n\n	// based on https://www.shadertoy.com/view/MslGR8\n	vec3 dithering( vec3 color ) {\n		//Calculate grid position\n		float grid_position = rand( gl_FragCoord.xy );\n\n		//Shift the individual colors differently, thus making it even harder to see the dithering pattern\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\n		//modify shift acording to grid position.\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\n		//shift the color by dither_shift\n		return color + dither_shift_RGB;\n	}\n\n#endif\n`;
const roughnessmap_fragment = `\nfloat roughnessFactor = roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n	// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n	roughnessFactor *= texelRoughness.g;\n\n#endif\n`;
const roughnessmap_pars_fragment = `\n#ifdef USE_ROUGHNESSMAP\n\n	uniform sampler2D roughnessMap;\n\n#endif\n`;
const shadowmap_pars_fragment = `\n#ifdef USE_SHADOWMAP\n\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n	#endif\n\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\n	#endif\n\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\n	#endif\n\n	/*\n	#if NUM_RECT_AREA_LIGHTS > 0\n\n		// TODO (abelnation): create uniforms for area light shadows\n\n	#endif\n	*/\n\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n	}\n\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n	}\n\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n		float occlusion = 1.0;\n\n		vec2 distribution = texture2DDistribution( shadow, uv );\n\n		float hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n		if (hard_shadow != 1.0 ) {\n\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n		}\n		return occlusion;\n\n	}\n\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n		float shadow = 1.0;\n\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n\n		// if ( something && something ) breaks ATI OpenGL shader compiler\n		// if ( all( something, something ) ) using this instead\n\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n		bool frustumTest = all( frustumTestVec );\n\n		if ( frustumTest ) {\n\n		#if defined( SHADOWMAP_TYPE_PCF )\n\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n\n		#elif defined( SHADOWMAP_TYPE_VSM )\n\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n		#else // no percentage-closer filtering:\n\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n		#endif\n\n		}\n\n		return shadow;\n\n	}\n\n	// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n	// vector suitable for 2D texture mapping. This code uses the following layout for the\n	// 2D texture:\n	//\n	// xzXZ\n	//  y Y\n	//\n	// Y - Positive y direction\n	// y - Negative y direction\n	// X - Positive x direction\n	// x - Negative x direction\n	// Z - Positive z direction\n	// z - Negative z direction\n	//\n	// Source and test bed:\n	// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n		// Number of texels to avoid at the edge of each square\n\n		vec3 absV = abs( v );\n\n		// Intersect unit cube\n\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n\n		// Apply scale to avoid seams\n\n		// two texels less per square (one texel will do for NEAREST)\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n		// Unwrap\n\n		// space: -1 ... 1 range for each square\n		//\n		// #X##		dim    := ( 4 , 2 )\n		//  # #		center := ( 1 , 1 )\n\n		vec2 planar = v.xy;\n\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n\n		if ( absV.z >= almostOne ) {\n\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n\n		} else if ( absV.x >= almostOne ) {\n\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n\n		} else if ( absV.y >= almostOne ) {\n\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n\n		}\n\n		// Transform to UV space\n\n		// scale := 0.5 / dim\n		// translate := ( center + 0.5 ) / dim\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n	}\n\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n		// for point lights, the uniform @vShadowCoord is re-purposed to hold\n		// the vector from the light to the world-space position of the fragment.\n		vec3 lightToPosition = shadowCoord.xyz;\n\n		// dp = normalized distance from light to fragment position\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n		dp += shadowBias;\n\n		// bd3D = base direction 3D\n		vec3 bd3D = normalize( lightToPosition );\n\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n\n		#else // no percentage-closer filtering\n\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n		#endif\n\n	}\n\n#endif\n`;
const shadowmap_pars_vertex = `\n#ifdef USE_SHADOWMAP\n\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n	#endif\n\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\n	#endif\n\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\n	#endif\n\n	/*\n	#if NUM_RECT_AREA_LIGHTS > 0\n\n		// TODO (abelnation): uniforms for area light shadows\n\n	#endif\n	*/\n\n#endif\n`;
const shadowmap_vertex = `\n#ifdef USE_SHADOWMAP\n\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\n		// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n\n	#endif\n\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\n	}\n	#pragma unroll_loop_end\n\n	#endif\n\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\n	}\n	#pragma unroll_loop_end\n\n	#endif\n\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\n	}\n	#pragma unroll_loop_end\n\n	#endif\n\n	/*\n	#if NUM_RECT_AREA_LIGHTS > 0\n\n		// TODO (abelnation): update vAreaShadowCoord with area light info\n\n	#endif\n	*/\n\n#endif\n`;
const shadowmask_pars_fragment = `\nfloat getShadowMask() {\n\n	float shadow = 1.0;\n\n	#ifdef USE_SHADOWMAP\n\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n\n	DirectionalLightShadow directionalLight;\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n	}\n	#pragma unroll_loop_end\n\n	#endif\n\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n	SpotLightShadow spotLight;\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\n	}\n	#pragma unroll_loop_end\n\n	#endif\n\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n\n	PointLightShadow pointLight;\n\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\n	}\n	#pragma unroll_loop_end\n\n	#endif\n\n	/*\n	#if NUM_RECT_AREA_LIGHTS > 0\n\n		// TODO (abelnation): update shadow for Area light\n\n	#endif\n	*/\n\n	#endif\n\n	return shadow;\n\n}\n`;
const skinbase_vertex = `\n#ifdef USE_SKINNING\n\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif\n`;
const skinning_pars_vertex = `\n#ifdef USE_SKINNING\n\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n\n	#ifdef BONE_TEXTURE\n\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n\n			y = dy * ( y + 0.5 );\n\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n			mat4 bone = mat4( v1, v2, v3, v4 );\n\n			return bone;\n\n		}\n\n	#else\n\n		uniform mat4 boneMatrices[ MAX_BONES ];\n\n		mat4 getBoneMatrix( const in float i ) {\n\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n\n		}\n\n	#endif\n\n#endif\n`;
const skinning_vertex = `\n#ifdef USE_SKINNING\n\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n\n#endif\n`;
const skinnormal_vertex = `\n#ifdef USE_SKINNING\n\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n	#ifdef USE_TANGENT\n\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\n	#endif\n\n#endif\n`;
const specularmap_fragment = `\nfloat specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n\n#else\n\n	specularStrength = 1.0;\n\n#endif\n`;
const specularmap_pars_fragment = `\n#ifdef USE_SPECULARMAP\n\n	uniform sampler2D specularMap;\n\n#endif\n`;
const tonemapping_fragment = `\n#if defined( TONE_MAPPING )\n\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\n#endif\n`;
const tonemapping_pars_fragment = `\n#ifndef saturate\n// <common> may have defined saturate() already\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n\nuniform float toneMappingExposure;\n\n// exposure only\nvec3 LinearToneMapping( vec3 color ) {\n\n	return toneMappingExposure * color;\n\n}\n\n// source: https://www.cs.utah.edu/~reinhard/cdrom/\nvec3 ReinhardToneMapping( vec3 color ) {\n\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n\n}\n\n// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\n	// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n\n}\n\n// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs\nvec3 RRTAndODTFit( vec3 v ) {\n\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n\n}\n\n// this implementation of ACES is modified to accommodate a brighter viewing environment.\n// the scale factor of 1/0.6 is subjective. see discussion in #19621.\n\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\n	// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ), // transposed from source\n		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n\n	// ODT_SAT => XYZ => D60_2_D65 => sRGB\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ), // transposed from source\n		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n\n	color *= toneMappingExposure / 0.6;\n\n	color = ACESInputMat * color;\n\n	// Apply RRT and ODT\n	color = RRTAndODTFit( color );\n\n	color = ACESOutputMat * color;\n\n	// Clamp to [0, 1]\n	return saturate( color );\n\n}\n\nvec3 CustomToneMapping( vec3 color ) { return color; }\n`;
const transmissionmap_fragment = `\n#ifdef USE_TRANSMISSIONMAP\n\n	totalTransmission *= texture2D( transmissionMap, vUv ).r;\n\n#endif\n`;
const transmissionmap_pars_fragment = `\n#ifdef USE_TRANSMISSIONMAP\n\n	uniform sampler2D transmissionMap;\n\n#endif\n`;
const uv_pars_fragment = `\n#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\n	varying vec2 vUv;\n\n#endif\n`;
const uv_pars_vertex = `\n#ifdef USE_UV\n\n	#ifdef UVS_VERTEX_ONLY\n\n		vec2 vUv;\n\n	#else\n\n		varying vec2 vUv;\n\n	#endif\n\n	uniform mat3 uvTransform;\n\n#endif\n`;
const uv_vertex = `\n#ifdef USE_UV\n\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n#endif\n`;
const uv2_pars_fragment = `\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	varying vec2 vUv2;\n\n#endif\n`;
const uv2_pars_vertex = `\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n\n	uniform mat3 uv2Transform;\n\n#endif\n`;
const uv2_vertex = `\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n\n#endif\n`;
const worldpos_vertex = `\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\n	vec4 worldPosition = vec4( transformed, 1.0 );\n\n	#ifdef USE_INSTANCING\n\n		worldPosition = instanceMatrix * worldPosition;\n\n	#endif\n\n	worldPosition = modelMatrix * worldPosition;\n\n#endif\n`;
const background_frag = `\nuniform sampler2D t2D;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n	vec4 texColor = texture2D( t2D, vUv );\n\n	gl_FragColor = mapTexelToLinear( texColor );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n\n}\n`;
const background_vert = `\nvarying vec2 vUv;\nuniform mat3 uvTransform;\n\nvoid main() {\n\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n\n}\n`;
const cube_frag = `\n#include <envmap_common_pars_fragment>\nuniform float opacity;\n\nvarying vec3 vWorldDirection;\n\n#include <cube_uv_reflection_fragment>\n\nvoid main() {\n\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n\n}\n`;
const cube_vert = `\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n	vWorldDirection = transformDirection( position, modelMatrix );\n\n	#include <begin_vertex>\n	#include <project_vertex>\n\n	gl_Position.z = gl_Position.w; // set z to camera.far\n\n}\n`;
const depth_frag = `\n#if DEPTH_PACKING == 3200\n\n	uniform float opacity;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n\n	vec4 diffuseColor = vec4( 1.0 );\n\n	#if DEPTH_PACKING == 3200\n\n		diffuseColor.a = opacity;\n\n	#endif\n\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n\n	#include <logdepthbuf_fragment>\n\n	// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\n	#if DEPTH_PACKING == 3200\n\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\n	#elif DEPTH_PACKING == 3201\n\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n\n	#endif\n\n}\n`;
const depth_vert = `\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.\n// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for\n// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.\nvarying vec2 vHighPrecisionZW;\n\nvoid main() {\n\n	#include <uv_vertex>\n\n	#include <skinbase_vertex>\n\n	#ifdef USE_DISPLACEMENTMAP\n\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n\n	#endif\n\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n\n	vHighPrecisionZW = gl_Position.zw;\n\n}\n`;
const distanceRGBA_frag = `\n#define DISTANCE\n\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main () {\n\n	#include <clipping_planes_fragment>\n\n	vec4 diffuseColor = vec4( 1.0 );\n\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist ); // clamp to [ 0, 1 ]\n\n	gl_FragColor = packDepthToRGBA( dist );\n\n}\n`;
const distanceRGBA_vert = `\n#define DISTANCE\n\nvarying vec3 vWorldPosition;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	#include <uv_vertex>\n\n	#include <skinbase_vertex>\n\n	#ifdef USE_DISPLACEMENTMAP\n\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n\n	#endif\n\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n\n	vWorldPosition = worldPosition.xyz;\n\n}\n`;
const equirect_frag = `\nuniform sampler2D tEquirect;\n\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n	vec3 direction = normalize( vWorldDirection );\n\n	vec2 sampleUV = equirectUv( direction );\n\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n\n	gl_FragColor = mapTexelToLinear( texColor );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n\n}\n`;
const equirect_vert = `\nvarying vec3 vWorldDirection;\n\n#include <common>\n\nvoid main() {\n\n	vWorldDirection = transformDirection( position, modelMatrix );\n\n	#include <begin_vertex>\n	#include <project_vertex>\n\n}\n`;
const linedashed_frag = `\nuniform vec3 diffuse;\nuniform float opacity;\n\nuniform float dashSize;\nuniform float totalSize;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n\n		discard;\n\n	}\n\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n\n	outgoingLight = diffuseColor.rgb; // simple shader\n\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n\n}\n`;
const linedashed_vert = `\nuniform float scale;\nattribute float lineDistance;\n\nvarying float vLineDistance;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	vLineDistance = scale * lineDistance;\n\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n\n}\n`;
const meshbasic_frag = `\nuniform vec3 diffuse;\nuniform float opacity;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n\n	vec4 diffuseColor = vec4( diffuse, opacity );\n\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n	// accumulation (baked indirect lighting only)\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\n	#else\n\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n\n	#endif\n\n	// modulation\n	#include <aomap_fragment>\n\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n	#include <envmap_fragment>\n\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n\n}\n`;
const meshbasic_vert = `\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n\n	#ifdef USE_ENVMAP\n\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n\n	#endif\n\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n\n}\n`;
const meshlambert_frag = `\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n\n	// accumulation\n\n	#ifdef DOUBLE_SIDED\n\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\n	#else\n\n		reflectedLight.indirectDiffuse += vIndirectFront;\n\n	#endif\n\n	#include <lightmap_fragment>\n\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\n	#ifdef DOUBLE_SIDED\n\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\n	#else\n\n		reflectedLight.directDiffuse = vLightFront;\n\n	#endif\n\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\n	// modulation\n\n	#include <aomap_fragment>\n\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n	#include <envmap_fragment>\n\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}\n`;
const meshlambert_vert = `\n#define LAMBERT\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}\n`;
const meshmatcap_frag = `\n#define MATCAP\n\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n\n	vec4 diffuseColor = vec4( diffuse, opacity );\n\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks\n\n	#ifdef USE_MATCAP\n\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n\n	#else\n\n		vec4 matcapColor = vec4( 1.0 );\n\n	#endif\n\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n\n}\n`;
const meshmatcap_vert = `\n#define MATCAP\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n\n	#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n		vNormal = normalize( transformedNormal );\n\n	#endif\n\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n\n	vViewPosition = - mvPosition.xyz;\n\n}\n`;
const meshtoon_frag = `\n#define TOON\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n\n	// accumulation\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n\n	// modulation\n	#include <aomap_fragment>\n\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n\n}\n`;
const meshtoon_vert = `\n#define TOON\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n	vNormal = normalize( transformedNormal );\n\n#endif\n\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n\n	vViewPosition = - mvPosition.xyz;\n\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n\n}\n`;
const meshphong_frag = `\n#define PHONG\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n\n	// accumulation\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n\n	// modulation\n	#include <aomap_fragment>\n\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n	#include <envmap_fragment>\n\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n\n}\n`;
const meshphong_vert = `\n#define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n	vNormal = normalize( transformedNormal );\n\n#endif\n\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n\n	vViewPosition = - mvPosition.xyz;\n\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n\n}\n`;
const meshphysical_frag = `\n#define STANDARD\n\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n	#define TRANSMISSION\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef TRANSMISSION\n	uniform float transmission;\n#endif\n\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n	#ifdef USE_TANGENT\n\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n\n	#endif\n\n#endif\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n\n	#ifdef TRANSMISSION\n		float totalTransmission = transmission;\n	#endif\n\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <transmissionmap_fragment>\n\n	// accumulation\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n\n	// modulation\n	#include <aomap_fragment>\n\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n	// this is a stub for the transmission model\n	#ifdef TRANSMISSION\n		diffuseColor.a *= saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n	#endif\n\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n\n}\n`;
const meshphysical_vert = `\n#define STANDARD\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n	#ifdef USE_TANGENT\n\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n\n	#endif\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n	vNormal = normalize( transformedNormal );\n\n	#ifdef USE_TANGENT\n\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n	#endif\n\n#endif\n\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n\n	vViewPosition = - mvPosition.xyz;\n\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n\n}\n`;
const normal_frag = `\n#define NORMAL\n\nuniform float opacity;\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n	varying vec3 vViewPosition;\n\n#endif\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n	#ifdef USE_TANGENT\n\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n\n	#endif\n\n#endif\n\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\n}\n`;
const normal_vert = `\n#define NORMAL\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n	varying vec3 vViewPosition;\n\n#endif\n\n#ifndef FLAT_SHADED\n\n	varying vec3 vNormal;\n\n	#ifdef USE_TANGENT\n\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n\n	#endif\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	#include <uv_vertex>\n\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n	vNormal = normalize( transformedNormal );\n\n	#ifdef USE_TANGENT\n\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\n	#endif\n\n#endif\n\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\n	vViewPosition = - mvPosition.xyz;\n\n#endif\n\n}\n`;
const points_frag = `\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n\n	outgoingLight = diffuseColor.rgb;\n\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n\n}\n`;
const points_vert = `\nuniform float size;\nuniform float scale;\n\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n\n	gl_PointSize = size;\n\n	#ifdef USE_SIZEATTENUATION\n\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\n	#endif\n\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n\n}\n`;
const shadow_frag = `\nuniform vec3 color;\nuniform float opacity;\n\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n\nvoid main() {\n\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n\n}\n`;
const shadow_vert = `\n#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n\nvoid main() {\n\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n\n}\n`;
const sprite_frag = `\nuniform vec3 diffuse;\nuniform float opacity;\n\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n	#include <clipping_planes_fragment>\n\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n\n	outgoingLight = diffuseColor.rgb;\n\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n\n}\n`;
const sprite_vert = `\nuniform float rotation;\nuniform vec2 center;\n\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n	#include <uv_vertex>\n\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n	#ifndef USE_SIZEATTENUATION\n\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\n		if ( isPerspective ) scale *= - mvPosition.z;\n\n	#endif\n\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\n	mvPosition.xy += rotatedPosition;\n\n	gl_Position = projectionMatrix * mvPosition;\n\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n\n}\n`;
const ShaderChunk = {
    alphamap_fragment: alphamap_fragment,
    alphamap_pars_fragment: alphamap_pars_fragment,
    alphatest_fragment: alphatest_fragment,
    aomap_fragment: aomap_fragment,
    aomap_pars_fragment: aomap_pars_fragment,
    begin_vertex: begin_vertex,
    beginnormal_vertex: beginnormal_vertex,
    bsdfs: bsdfs,
    bumpmap_pars_fragment: bumpmap_pars_fragment,
    clipping_planes_fragment: clipping_planes_fragment,
    clipping_planes_pars_fragment: clipping_planes_pars_fragment,
    clipping_planes_pars_vertex: clipping_planes_pars_vertex,
    clipping_planes_vertex: clipping_planes_vertex,
    color_fragment: color_fragment,
    color_pars_fragment: color_pars_fragment,
    color_pars_vertex: color_pars_vertex,
    color_vertex: color_vertex,
    common: common,
    cube_uv_reflection_fragment: cube_uv_reflection_fragment,
    defaultnormal_vertex: defaultnormal_vertex,
    displacementmap_pars_vertex: displacementmap_pars_vertex,
    displacementmap_vertex: displacementmap_vertex,
    emissivemap_fragment: emissivemap_fragment,
    emissivemap_pars_fragment: emissivemap_pars_fragment,
    encodings_fragment: encodings_fragment,
    encodings_pars_fragment: encodings_pars_fragment,
    envmap_fragment: envmap_fragment,
    envmap_common_pars_fragment: envmap_common_pars_fragment,
    envmap_pars_fragment: envmap_pars_fragment,
    envmap_pars_vertex: envmap_pars_vertex,
    envmap_physical_pars_fragment: envmap_physical_pars_fragment,
    envmap_vertex: envmap_vertex,
    fog_vertex: fog_vertex,
    fog_pars_vertex: fog_pars_vertex,
    fog_fragment: fog_fragment,
    fog_pars_fragment: fog_pars_fragment,
    gradientmap_pars_fragment: gradientmap_pars_fragment,
    lightmap_fragment: lightmap_fragment,
    lightmap_pars_fragment: lightmap_pars_fragment,
    lights_lambert_vertex: lights_lambert_vertex,
    lights_pars_begin: lights_pars_begin,
    lights_toon_fragment: lights_toon_fragment,
    lights_toon_pars_fragment: lights_toon_pars_fragment,
    lights_phong_fragment: lights_phong_fragment,
    lights_phong_pars_fragment: lights_phong_pars_fragment,
    lights_physical_fragment: lights_physical_fragment,
    lights_physical_pars_fragment: lights_physical_pars_fragment,
    lights_fragment_begin: lights_fragment_begin,
    lights_fragment_maps: lights_fragment_maps,
    lights_fragment_end: lights_fragment_end,
    logdepthbuf_fragment: logdepthbuf_fragment,
    logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
    logdepthbuf_vertex: logdepthbuf_vertex,
    map_fragment: map_fragment,
    map_pars_fragment: map_pars_fragment,
    map_particle_fragment: map_particle_fragment,
    map_particle_pars_fragment: map_particle_pars_fragment,
    metalnessmap_fragment: metalnessmap_fragment,
    metalnessmap_pars_fragment: metalnessmap_pars_fragment,
    morphnormal_vertex: morphnormal_vertex,
    morphtarget_pars_vertex: morphtarget_pars_vertex,
    morphtarget_vertex: morphtarget_vertex,
    normal_fragment_begin: normal_fragment_begin,
    normal_fragment_maps: normal_fragment_maps,
    normalmap_pars_fragment: normalmap_pars_fragment,
    clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment: clearcoat_pars_fragment,
    packing: packing,
    premultiplied_alpha_fragment: premultiplied_alpha_fragment,
    project_vertex: project_vertex,
    dithering_fragment: dithering_fragment,
    dithering_pars_fragment: dithering_pars_fragment,
    roughnessmap_fragment: roughnessmap_fragment,
    roughnessmap_pars_fragment: roughnessmap_pars_fragment,
    shadowmap_pars_fragment: shadowmap_pars_fragment,
    shadowmap_pars_vertex: shadowmap_pars_vertex,
    shadowmap_vertex: shadowmap_vertex,
    shadowmask_pars_fragment: shadowmask_pars_fragment,
    skinbase_vertex: skinbase_vertex,
    skinning_pars_vertex: skinning_pars_vertex,
    skinning_vertex: skinning_vertex,
    skinnormal_vertex: skinnormal_vertex,
    specularmap_fragment: specularmap_fragment,
    specularmap_pars_fragment: specularmap_pars_fragment,
    tonemapping_fragment: tonemapping_fragment,
    tonemapping_pars_fragment: tonemapping_pars_fragment,
    transmissionmap_fragment: transmissionmap_fragment,
    transmissionmap_pars_fragment: transmissionmap_pars_fragment,
    uv_pars_fragment: uv_pars_fragment,
    uv_pars_vertex: uv_pars_vertex,
    uv_vertex: uv_vertex,
    uv2_pars_fragment: uv2_pars_fragment,
    uv2_pars_vertex: uv2_pars_vertex,
    uv2_vertex: uv2_vertex,
    worldpos_vertex: worldpos_vertex,
    background_frag: background_frag,
    background_vert: background_vert,
    cube_frag: cube_frag,
    cube_vert: cube_vert,
    depth_frag: depth_frag,
    depth_vert: depth_vert,
    distanceRGBA_frag: distanceRGBA_frag,
    distanceRGBA_vert: distanceRGBA_vert,
    equirect_frag: equirect_frag,
    equirect_vert: equirect_vert,
    linedashed_frag: linedashed_frag,
    linedashed_vert: linedashed_vert,
    meshbasic_frag: meshbasic_frag,
    meshbasic_vert: meshbasic_vert,
    meshlambert_frag: meshlambert_frag,
    meshlambert_vert: meshlambert_vert,
    meshmatcap_frag: meshmatcap_frag,
    meshmatcap_vert: meshmatcap_vert,
    meshtoon_frag: meshtoon_frag,
    meshtoon_vert: meshtoon_vert,
    meshphong_frag: meshphong_frag,
    meshphong_vert: meshphong_vert,
    meshphysical_frag: meshphysical_frag,
    meshphysical_vert: meshphysical_vert,
    normal_frag: normal_frag,
    normal_vert: normal_vert,
    points_frag: points_frag,
    points_vert: points_vert,
    shadow_frag: shadow_frag,
    shadow_vert: shadow_vert,
    sprite_frag: sprite_frag,
    sprite_vert: sprite_vert
};
export { ShaderChunk };
function FogExp2(color1, density) {
    this.name = '';
    this.color = new Color1(color1);
    this.density = density !== undefined ? density : 0.00025;
}
Object.assign(FogExp2.prototype, {
    isFogExp2: true,
    clone: function() {
        return new FogExp2(this.color, this.density);
    },
    toJSON: function() {
        return {
            type: 'FogExp2',
            color: this.color.getHex(),
            density: this.density
        };
    }
});
const FogExp21 = FogExp2;
export { FogExp21 as FogExp2 };
function Fog(color1, near, far) {
    this.name = '';
    this.color = new Color1(color1);
    this.near = near !== undefined ? near : 1;
    this.far = far !== undefined ? far : 1000;
}
Object.assign(Fog.prototype, {
    isFog: true,
    clone: function() {
        return new Fog(this.color, this.near, this.far);
    },
    toJSON: function() {
        return {
            type: 'Fog',
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        };
    }
});
const Fog1 = Fog;
export { Fog1 as Fog };
function Scene() {
    Object3D1.call(this);
    this.type = 'Scene';
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true; // checked by the renderer
    if (typeof __THREE_DEVTOOLS__ !== 'undefined') __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
        detail: this
    })); // eslint-disable-line no-undef
}
Scene.prototype = Object.assign(Object.create(Object3D1.prototype), {
    constructor: Scene,
    isScene: true,
    copy: function(source, recursive) {
        Object3D1.prototype.copy.call(this, source, recursive);
        if (source.background !== null) this.background = source.background.clone();
        if (source.environment !== null) this.environment = source.environment.clone();
        if (source.fog !== null) this.fog = source.fog.clone();
        if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
        this.autoUpdate = source.autoUpdate;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        return this;
    },
    toJSON: function(meta) {
        const data = Object3D1.prototype.toJSON.call(this, meta);
        if (this.background !== null) data.object.background = this.background.toJSON(meta);
        if (this.environment !== null) data.object.environment = this.environment.toJSON(meta);
        if (this.fog !== null) data.object.fog = this.fog.toJSON();
        return data;
    }
});
const Scene1 = Scene;
export { Scene1 as Scene };
function InterleavedBuffer(array, stride) {
    this.array = array;
    this.stride = stride;
    this.count = array !== undefined ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRange = {
        offset: 0,
        count: -1
    };
    this.version = 0;
    this.uuid = MathUtils1.generateUUID();
}
Object.defineProperty(InterleavedBuffer.prototype, 'needsUpdate', {
    set: function(value) {
        if (value === true) this.version++;
    }
});
Object.assign(InterleavedBuffer.prototype, {
    isInterleavedBuffer: true,
    onUploadCallback: function() {
    },
    setUsage: function(value) {
        this.usage = value;
        return this;
    },
    copy: function(source) {
        this.array = new source.array.constructor(source.array);
        this.count = source.count;
        this.stride = source.stride;
        this.usage = source.usage;
        return this;
    },
    copyAt: function(index1, attribute, index2) {
        index1 *= this.stride;
        index2 *= attribute.stride;
        for(let i1 = 0, l = this.stride; i1 < l; i1++)this.array[index1 + i1] = attribute.array[index2 + i1];
        return this;
    },
    set: function(value, offset) {
        if (offset === undefined) offset = 0;
        this.array.set(value, offset);
        return this;
    },
    clone: function(data) {
        if (data.arrayBuffers === undefined) data.arrayBuffers = {
        };
        if (this.array.buffer._uuid === undefined) this.array.buffer._uuid = MathUtils1.generateUUID();
        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
        const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
        const ib = new InterleavedBuffer(array, this.stride);
        ib.setUsage(this.usage);
        return ib;
    },
    onUpload: function(callback) {
        this.onUploadCallback = callback;
        return this;
    },
    toJSON: function(data) {
        if (data.arrayBuffers === undefined) data.arrayBuffers = {
        };
        // generate UUID for array buffer if necessary
        if (this.array.buffer._uuid === undefined) this.array.buffer._uuid = MathUtils1.generateUUID();
        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
        //
        return {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        };
    }
});
const InterleavedBuffer1 = InterleavedBuffer;
const _vector7 = new Vector31();
function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
    this.name = '';
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized === true;
}
Object.defineProperties(InterleavedBufferAttribute.prototype, {
    count: {
        get: function() {
            return this.data.count;
        }
    },
    array: {
        get: function() {
            return this.data.array;
        }
    },
    needsUpdate: {
        set: function(value) {
            this.data.needsUpdate = value;
        }
    }
});
Object.assign(InterleavedBufferAttribute.prototype, {
    isInterleavedBufferAttribute: true,
    applyMatrix4: function(m) {
        for(let i1 = 0, l = this.data.count; i1 < l; i1++){
            _vector7.x = this.getX(i1);
            _vector7.y = this.getY(i1);
            _vector7.z = this.getZ(i1);
            _vector7.applyMatrix4(m);
            this.setXYZ(i1, _vector7.x, _vector7.y, _vector7.z);
        }
        return this;
    },
    setX: function(index, x6) {
        this.data.array[index * this.data.stride + this.offset] = x6;
        return this;
    },
    setY: function(index, y6) {
        this.data.array[index * this.data.stride + this.offset + 1] = y6;
        return this;
    },
    setZ: function(index, z5) {
        this.data.array[index * this.data.stride + this.offset + 2] = z5;
        return this;
    },
    setW: function(index, w3) {
        this.data.array[index * this.data.stride + this.offset + 3] = w3;
        return this;
    },
    getX: function(index) {
        return this.data.array[index * this.data.stride + this.offset];
    },
    getY: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 1];
    },
    getZ: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 2];
    },
    getW: function(index) {
        return this.data.array[index * this.data.stride + this.offset + 3];
    },
    setXY: function(index, x6, y6) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x6;
        this.data.array[index + 1] = y6;
        return this;
    },
    setXYZ: function(index, x6, y6, z5) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x6;
        this.data.array[index + 1] = y6;
        this.data.array[index + 2] = z5;
        return this;
    },
    setXYZW: function(index, x6, y6, z5, w3) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x6;
        this.data.array[index + 1] = y6;
        this.data.array[index + 2] = z5;
        this.data.array[index + 3] = w3;
        return this;
    },
    clone: function(data) {
        if (data === undefined) {
            console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');
            const array = [];
            for(let i1 = 0; i1 < this.count; i1++){
                const index = i1 * this.data.stride + this.offset;
                for(let j = 0; j < this.itemSize; j++)array.push(this.data.array[index + j]);
            }
            return new BufferAttribute1(new this.array.constructor(array), this.itemSize, this.normalized);
        } else {
            if (data.interleavedBuffers === undefined) data.interleavedBuffers = {
            };
            if (data.interleavedBuffers[this.data.uuid] === undefined) data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
            return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
    },
    toJSON: function(data) {
        if (data === undefined) {
            console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');
            const array = [];
            for(let i1 = 0; i1 < this.count; i1++){
                const index = i1 * this.data.stride + this.offset;
                for(let j = 0; j < this.itemSize; j++)array.push(this.data.array[index + j]);
            }
            // deinterleave data and save it as an ordinary buffer attribute for now
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: array,
                normalized: this.normalized
            };
        } else {
            // save as true interlaved attribtue
            if (data.interleavedBuffers === undefined) data.interleavedBuffers = {
            };
            if (data.interleavedBuffers[this.data.uuid] === undefined) data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
            return {
                isInterleavedBufferAttribute: true,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            };
        }
    }
});
const InterleavedBufferAttribute1 = InterleavedBufferAttribute;
/**
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */
function SpriteMaterial(parameters) {
    Material1.call(this);
    this.type = 'SpriteMaterial';
    this.color = new Color1(16777215);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.setValues(parameters);
}
SpriteMaterial.prototype = Object.create(Material1.prototype);
SpriteMaterial.prototype.constructor = SpriteMaterial;
SpriteMaterial.prototype.isSpriteMaterial = true;
SpriteMaterial.prototype.copy = function(source) {
    Material1.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
};
const SpriteMaterial1 = SpriteMaterial;
let _geometry;
const _intersectPoint = new Vector31();
const _worldScale = new Vector31();
const _mvPosition = new Vector31();
const _alignedPosition = new Vector21();
const _rotatedPosition = new Vector21();
const _viewWorldMatrix = new Matrix41();
const _vA1 = new Vector31();
const _vB1 = new Vector31();
const _vC1 = new Vector31();
const _uvA1 = new Vector21();
const _uvB1 = new Vector21();
const _uvC1 = new Vector21();
function Sprite(material) {
    Object3D1.call(this);
    this.type = 'Sprite';
    if (_geometry === undefined) {
        _geometry = new BufferGeometry1();
        const float32Array = new Float32Array([
            -0.5,
            -0.5,
            0,
            0,
            0,
            0.5,
            -0.5,
            0,
            1,
            0,
            0.5,
            0.5,
            0,
            1,
            1,
            -0.5,
            0.5,
            0,
            0,
            1
        ]);
        const interleavedBuffer = new InterleavedBuffer1(float32Array, 5);
        _geometry.setIndex([
            0,
            1,
            2,
            0,
            2,
            3
        ]);
        _geometry.setAttribute('position', new InterleavedBufferAttribute1(interleavedBuffer, 3, 0, false));
        _geometry.setAttribute('uv', new InterleavedBufferAttribute1(interleavedBuffer, 2, 3, false));
    }
    this.geometry = _geometry;
    this.material = material !== undefined ? material : new SpriteMaterial1();
    this.center = new Vector21(0.5, 0.5);
}
Sprite.prototype = Object.assign(Object.create(Object3D1.prototype), {
    constructor: Sprite,
    isSprite: true,
    raycast: function(raycaster, intersects) {
        if (raycaster.camera === null) console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
        _worldScale.setFromMatrixScale(this.matrixWorld);
        _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
        this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
        _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
        if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) _worldScale.multiplyScalar(-_mvPosition.z);
        const rotation = this.material.rotation;
        let sin, cos;
        if (rotation !== 0) {
            cos = Math.cos(rotation);
            sin = Math.sin(rotation);
        }
        const center = this.center;
        transformVertex(_vA1.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        transformVertex(_vB1.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        transformVertex(_vC1.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        _uvA1.set(0, 0);
        _uvB1.set(1, 0);
        _uvC1.set(1, 1);
        // check first triangle
        let intersect = raycaster.ray.intersectTriangle(_vA1, _vB1, _vC1, false, _intersectPoint);
        if (intersect === null) {
            // check second triangle
            transformVertex(_vB1.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
            _uvB1.set(0, 1);
            intersect = raycaster.ray.intersectTriangle(_vA1, _vC1, _vB1, false, _intersectPoint);
            if (intersect === null) return;
        }
        const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far) return;
        intersects.push({
            distance: distance,
            point: _intersectPoint.clone(),
            uv: Triangle1.getUV(_intersectPoint, _vA1, _vB1, _vC1, _uvA1, _uvB1, _uvC1, new Vector21()),
            face: null,
            object: this
        });
    },
    copy: function(source) {
        Object3D1.prototype.copy.call(this, source);
        if (source.center !== undefined) this.center.copy(source.center);
        this.material = source.material;
        return this;
    }
});
function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
    // compute position in camera space
    _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
    // to check if rotation is not zero
    if (sin !== undefined) {
        _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
        _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
    } else _rotatedPosition.copy(_alignedPosition);
    vertexPosition.copy(mvPosition);
    vertexPosition.x += _rotatedPosition.x;
    vertexPosition.y += _rotatedPosition.y;
    // transform to world space
    vertexPosition.applyMatrix4(_viewWorldMatrix);
}
const Sprite1 = Sprite;
export { Sprite1 as Sprite };
const _v15 = new Vector31();
const _v22 = new Vector31();
function LOD() {
    Object3D1.call(this);
    this._currentLevel = 0;
    this.type = 'LOD';
    Object.defineProperties(this, {
        levels: {
            enumerable: true,
            value: []
        }
    });
    this.autoUpdate = true;
}
LOD.prototype = Object.assign(Object.create(Object3D1.prototype), {
    constructor: LOD,
    isLOD: true,
    copy: function(source) {
        Object3D1.prototype.copy.call(this, source, false);
        const levels = source.levels;
        for(let i1 = 0, l = levels.length; i1 < l; i1++){
            const level = levels[i1];
            this.addLevel(level.object.clone(), level.distance);
        }
        this.autoUpdate = source.autoUpdate;
        return this;
    },
    addLevel: function(object, distance) {
        if (distance === undefined) distance = 0;
        distance = Math.abs(distance);
        const levels = this.levels;
        let l;
        for(l = 0; l < levels.length; l++)if (distance < levels[l].distance) break;
        levels.splice(l, 0, {
            distance: distance,
            object: object
        });
        this.add(object);
        return this;
    },
    getCurrentLevel: function() {
        return this._currentLevel;
    },
    getObjectForDistance: function(distance) {
        const levels = this.levels;
        if (levels.length > 0) {
            let i1, l;
            for((i1 = 1, l = levels.length); i1 < l; i1++)if (distance < levels[i1].distance) break;
            return levels[i1 - 1].object;
        }
        return null;
    },
    raycast: function(raycaster, intersects) {
        const levels = this.levels;
        if (levels.length > 0) {
            _v15.setFromMatrixPosition(this.matrixWorld);
            const distance = raycaster.ray.origin.distanceTo(_v15);
            this.getObjectForDistance(distance).raycast(raycaster, intersects);
        }
    },
    update: function(camera) {
        const levels = this.levels;
        if (levels.length > 1) {
            _v15.setFromMatrixPosition(camera.matrixWorld);
            _v22.setFromMatrixPosition(this.matrixWorld);
            const distance = _v15.distanceTo(_v22) / camera.zoom;
            levels[0].object.visible = true;
            let i1, l;
            for((i1 = 1, l = levels.length); i1 < l; i1++)if (distance >= levels[i1].distance) {
                levels[i1 - 1].object.visible = false;
                levels[i1].object.visible = true;
            } else break;
            this._currentLevel = i1 - 1;
            for(; i1 < l; i1++)levels[i1].object.visible = false;
        }
    },
    toJSON: function(meta) {
        const data = Object3D1.prototype.toJSON.call(this, meta);
        if (this.autoUpdate === false) data.object.autoUpdate = false;
        data.object.levels = [];
        const levels = this.levels;
        for(let i1 = 0, l = levels.length; i1 < l; i1++){
            const level = levels[i1];
            data.object.levels.push({
                object: level.object.uuid,
                distance: level.distance
            });
        }
        return data;
    }
});
const LOD1 = LOD;
export { LOD1 as LOD };
function SkinnedMesh(geometry, material) {
    if (geometry && geometry.isGeometry) console.error('THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
    Mesh1.call(this, geometry, material);
    this.type = 'SkinnedMesh';
    this.bindMode = 'attached';
    this.bindMatrix = new Matrix41();
    this.bindMatrixInverse = new Matrix41();
}
SkinnedMesh.prototype = Object.assign(Object.create(Mesh1.prototype), {
    constructor: SkinnedMesh,
    isSkinnedMesh: true,
    copy: function(source) {
        Mesh1.prototype.copy.call(this, source);
        this.bindMode = source.bindMode;
        this.bindMatrix.copy(source.bindMatrix);
        this.bindMatrixInverse.copy(source.bindMatrixInverse);
        this.skeleton = source.skeleton;
        return this;
    },
    bind: function(skeleton, bindMatrix) {
        this.skeleton = skeleton;
        if (bindMatrix === undefined) {
            this.updateMatrixWorld(true);
            this.skeleton.calculateInverses();
            bindMatrix = this.matrixWorld;
        }
        this.bindMatrix.copy(bindMatrix);
        this.bindMatrixInverse.getInverse(bindMatrix);
    },
    pose: function() {
        this.skeleton.pose();
    },
    normalizeSkinWeights: function() {
        const vector = new Vector41();
        const skinWeight = this.geometry.attributes.skinWeight;
        for(let i1 = 0, l = skinWeight.count; i1 < l; i1++){
            vector.x = skinWeight.getX(i1);
            vector.y = skinWeight.getY(i1);
            vector.z = skinWeight.getZ(i1);
            vector.w = skinWeight.getW(i1);
            const scale = 1 / vector.manhattanLength();
            if (scale !== Infinity) vector.multiplyScalar(scale);
            else vector.set(1, 0, 0, 0); // do something reasonable
            skinWeight.setXYZW(i1, vector.x, vector.y, vector.z, vector.w);
        }
    },
    updateMatrixWorld: function(force) {
        Mesh1.prototype.updateMatrixWorld.call(this, force);
        if (this.bindMode === 'attached') this.bindMatrixInverse.getInverse(this.matrixWorld);
        else if (this.bindMode === 'detached') this.bindMatrixInverse.getInverse(this.bindMatrix);
        else console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
    },
    boneTransform: function() {
        const basePosition = new Vector31();
        const skinIndex = new Vector41();
        const skinWeight = new Vector41();
        const vector = new Vector31();
        const matrix = new Matrix41();
        return function(index, target) {
            const skeleton = this.skeleton;
            const geometry = this.geometry;
            skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
            skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
            basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);
            target.set(0, 0, 0);
            for(let i1 = 0; i1 < 4; i1++){
                const weight = skinWeight.getComponent(i1);
                if (weight !== 0) {
                    const boneIndex = skinIndex.getComponent(i1);
                    matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
                    target.addScaledVector(vector.copy(basePosition).applyMatrix4(matrix), weight);
                }
            }
            return target.applyMatrix4(this.bindMatrixInverse);
        };
    }()
});
const SkinnedMesh1 = SkinnedMesh;
export { SkinnedMesh1 as SkinnedMesh };
const _offsetMatrix = new Matrix41();
const _identityMatrix = new Matrix41();
function Skeleton(bones, boneInverses) {
    // copy the bone array
    bones = bones || [];
    this.bones = bones.slice(0);
    this.boneMatrices = new Float32Array(this.bones.length * 16);
    this.frame = -1;
    // use the supplied bone inverses or calculate the inverses
    if (boneInverses === undefined) this.calculateInverses();
    else if (this.bones.length === boneInverses.length) this.boneInverses = boneInverses.slice(0);
    else {
        console.warn('THREE.Skeleton boneInverses is the wrong length.');
        this.boneInverses = [];
        for(let i1 = 0, il = this.bones.length; i1 < il; i1++)this.boneInverses.push(new Matrix41());
    }
}
Object.assign(Skeleton.prototype, {
    calculateInverses: function() {
        this.boneInverses = [];
        for(let i1 = 0, il = this.bones.length; i1 < il; i1++){
            const inverse = new Matrix41();
            if (this.bones[i1]) inverse.getInverse(this.bones[i1].matrixWorld);
            this.boneInverses.push(inverse);
        }
    },
    pose: function() {
        // recover the bind-time world matrices
        for(let i1 = 0, il = this.bones.length; i1 < il; i1++){
            const bone = this.bones[i1];
            if (bone) bone.matrixWorld.getInverse(this.boneInverses[i1]);
        }
        // compute the local matrices, positions, rotations and scales
        for(let i1 = 0, il = this.bones.length; i1 < il; i1++){
            const bone = this.bones[i1];
            if (bone) {
                if (bone.parent && bone.parent.isBone) {
                    bone.matrix.getInverse(bone.parent.matrixWorld);
                    bone.matrix.multiply(bone.matrixWorld);
                } else bone.matrix.copy(bone.matrixWorld);
                bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
            }
        }
    },
    update: function() {
        const bones = this.bones;
        const boneInverses = this.boneInverses;
        const boneMatrices = this.boneMatrices;
        const boneTexture = this.boneTexture;
        // flatten bone matrices to array
        for(let i1 = 0, il = bones.length; i1 < il; i1++){
            // compute the offset between the current and the original transform
            const matrix = bones[i1] ? bones[i1].matrixWorld : _identityMatrix;
            _offsetMatrix.multiplyMatrices(matrix, boneInverses[i1]);
            _offsetMatrix.toArray(boneMatrices, i1 * 16);
        }
        if (boneTexture !== undefined) boneTexture.needsUpdate = true;
    },
    clone: function() {
        return new Skeleton(this.bones, this.boneInverses);
    },
    getBoneByName: function(name) {
        for(let i1 = 0, il = this.bones.length; i1 < il; i1++){
            const bone = this.bones[i1];
            if (bone.name === name) return bone;
        }
        return undefined;
    },
    dispose: function() {
        if (this.boneTexture) {
            this.boneTexture.dispose();
            this.boneTexture = undefined;
        }
    }
});
const Skeleton1 = Skeleton;
export { Skeleton1 as Skeleton };
function Bone() {
    Object3D1.call(this);
    this.type = 'Bone';
}
Bone.prototype = Object.assign(Object.create(Object3D1.prototype), {
    constructor: Bone,
    isBone: true
});
const Bone1 = Bone;
export { Bone1 as Bone };
const _inverseMatrix = new Matrix41();
const _ray = new Ray1();
const _sphere = new Sphere1();
const _vA = new Vector31();
const _vB = new Vector31();
const _vC = new Vector31();
const _tempA = new Vector31();
const _tempB = new Vector31();
const _tempC = new Vector31();
const _morphA = new Vector31();
const _morphB = new Vector31();
const _morphC = new Vector31();
const _uvA = new Vector21();
const _uvB = new Vector21();
const _uvC = new Vector21();
const _intersectionPoint = new Vector31();
const _intersectionPointWorld = new Vector31();
function Mesh2(geometry, material) {
    Object3D1.call(this);
    this.type = 'Mesh';
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry1();
    this.material = material !== undefined ? material : new MeshBasicMaterial1();
    this.updateMorphTargets();
}
Mesh2.prototype = Object.assign(Object.create(Object3D1.prototype), {
    constructor: Mesh2,
    isMesh: true,
    copy: function(source) {
        Object3D1.prototype.copy.call(this, source);
        if (source.morphTargetInfluences !== undefined) this.morphTargetInfluences = source.morphTargetInfluences.slice();
        if (source.morphTargetDictionary !== undefined) this.morphTargetDictionary = Object.assign({
        }, source.morphTargetDictionary);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    },
    updateMorphTargets: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {
                    };
                    for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
    },
    raycast: function(raycaster, intersects) {
        const geometry = this.geometry;
        const material = this.material;
        const matrixWorld = this.matrixWorld;
        if (material === undefined) return;
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere.copy(geometry.boundingSphere);
        _sphere.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere(_sphere) === false) return;
        _inverseMatrix.getInverse(matrixWorld);
        _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
        if (geometry.boundingBox !== null) {
            if (_ray.intersectsBox(geometry.boundingBox) === false) return;
        }
        let intersection;
        if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const position = geometry.attributes.position;
            const morphPosition = geometry.morphAttributes.position;
            const morphTargetsRelative = geometry.morphTargetsRelative;
            const uv = geometry.attributes.uv;
            const uv2 = geometry.attributes.uv2;
            const groups = geometry.groups;
            const drawRange = geometry.drawRange;
            if (index !== null) {
                if (Array.isArray(material)) for(let i1 = 0, il = groups.length; i1 < il; i1++){
                    const group = groups[i1];
                    const groupMaterial = material[group.materialIndex];
                    const start = Math.max(group.start, drawRange.start);
                    const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                    for(let j = start, jl = end; j < jl; j += 3){
                        const a2 = index.getX(j);
                        const b2 = index.getX(j + 1);
                        const c2 = index.getX(j + 2);
                        intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(j / 3);
                            intersection.face.materialIndex = group.materialIndex;
                            intersects.push(intersection);
                        }
                    }
                }
                else {
                    const start = Math.max(0, drawRange.start);
                    const end = Math.min(index.count, drawRange.start + drawRange.count);
                    for(let i11 = start, il1 = end; i11 < il1; i11 += 3){
                        const a2 = index.getX(i11);
                        const b2 = index.getX(i11 + 1);
                        const c2 = index.getX(i11 + 2);
                        intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(i11 / 3);
                            intersects.push(intersection);
                        }
                    }
                }
            } else if (position !== undefined) {
                if (Array.isArray(material)) for(let i1 = 0, il = groups.length; i1 < il; i1++){
                    const group = groups[i1];
                    const groupMaterial = material[group.materialIndex];
                    const start = Math.max(group.start, drawRange.start);
                    const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                    for(let j = start, jl = end; j < jl; j += 3){
                        const a2 = j;
                        const b2 = j + 1;
                        const c2 = j + 2;
                        intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(j / 3);
                            intersection.face.materialIndex = group.materialIndex;
                            intersects.push(intersection);
                        }
                    }
                }
                else {
                    const start = Math.max(0, drawRange.start);
                    const end = Math.min(position.count, drawRange.start + drawRange.count);
                    for(let i11 = start, il1 = end; i11 < il1; i11 += 3){
                        const a2 = i11;
                        const b2 = i11 + 1;
                        const c2 = i11 + 2;
                        intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
                        if (intersection) {
                            intersection.faceIndex = Math.floor(i11 / 3);
                            intersects.push(intersection);
                        }
                    }
                }
            }
        } else if (geometry.isGeometry) {
            const isMultiMaterial = Array.isArray(material);
            const vertices2 = geometry.vertices;
            const faces = geometry.faces;
            let uvs2;
            const faceVertexUvs = geometry.faceVertexUvs[0];
            if (faceVertexUvs.length > 0) uvs2 = faceVertexUvs;
            for(let f = 0, fl = faces.length; f < fl; f++){
                const face = faces[f];
                const faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
                if (faceMaterial === undefined) continue;
                const fvA = vertices2[face.a];
                const fvB = vertices2[face.b];
                const fvC = vertices2[face.c];
                intersection = checkIntersection(this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint);
                if (intersection) {
                    if (uvs2 && uvs2[f]) {
                        const uvs_f = uvs2[f];
                        _uvA.copy(uvs_f[0]);
                        _uvB.copy(uvs_f[1]);
                        _uvC.copy(uvs_f[2]);
                        intersection.uv = Triangle1.getUV(_intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector21());
                    }
                    intersection.face = face;
                    intersection.faceIndex = f;
                    intersects.push(intersection);
                }
            }
        }
    }
});
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
    let intersect;
    if (material.side === BackSide) intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    else intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
    if (intersect === null) return null;
    _intersectionPointWorld.copy(point);
    _intersectionPointWorld.applyMatrix4(object.matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far) return null;
    return {
        distance: distance,
        point: _intersectionPointWorld.clone(),
        object: object
    };
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2) {
    _vA.fromBufferAttribute(position, a2);
    _vB.fromBufferAttribute(position, b2);
    _vC.fromBufferAttribute(position, c2);
    const morphInfluences = object.morphTargetInfluences;
    if (material.morphTargets && morphPosition && morphInfluences) {
        _morphA.set(0, 0, 0);
        _morphB.set(0, 0, 0);
        _morphC.set(0, 0, 0);
        for(let i1 = 0, il = morphPosition.length; i1 < il; i1++){
            const influence = morphInfluences[i1];
            const morphAttribute = morphPosition[i1];
            if (influence === 0) continue;
            _tempA.fromBufferAttribute(morphAttribute, a2);
            _tempB.fromBufferAttribute(morphAttribute, b2);
            _tempC.fromBufferAttribute(morphAttribute, c2);
            if (morphTargetsRelative) {
                _morphA.addScaledVector(_tempA, influence);
                _morphB.addScaledVector(_tempB, influence);
                _morphC.addScaledVector(_tempC, influence);
            } else {
                _morphA.addScaledVector(_tempA.sub(_vA), influence);
                _morphB.addScaledVector(_tempB.sub(_vB), influence);
                _morphC.addScaledVector(_tempC.sub(_vC), influence);
            }
        }
        _vA.add(_morphA);
        _vB.add(_morphB);
        _vC.add(_morphC);
    }
    if (object.isSkinnedMesh) {
        object.boneTransform(a2, _vA);
        object.boneTransform(b2, _vB);
        object.boneTransform(c2, _vC);
    }
    const intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);
    if (intersection) {
        if (uv) {
            _uvA.fromBufferAttribute(uv, a2);
            _uvB.fromBufferAttribute(uv, b2);
            _uvC.fromBufferAttribute(uv, c2);
            intersection.uv = Triangle1.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector21());
        }
        if (uv2) {
            _uvA.fromBufferAttribute(uv2, a2);
            _uvB.fromBufferAttribute(uv2, b2);
            _uvC.fromBufferAttribute(uv2, c2);
            intersection.uv2 = Triangle1.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector21());
        }
        const face = new Face31(a2, b2, c2);
        Triangle1.getNormal(_vA, _vB, _vC, face.normal);
        intersection.face = face;
    }
    return intersection;
}
const Mesh1 = Mesh2;
export { Mesh1 as Mesh };
const _instanceLocalMatrix = new Matrix41();
const _instanceWorldMatrix = new Matrix41();
const _instanceIntersects = [];
const _mesh = new Mesh1();
function InstancedMesh(geometry, material, count) {
    Mesh1.call(this, geometry, material);
    this.instanceMatrix = new BufferAttribute1(new Float32Array(count * 16), 16);
    this.instanceColor = null;
    this.count = count;
    this.frustumCulled = false;
}
InstancedMesh.prototype = Object.assign(Object.create(Mesh1.prototype), {
    constructor: InstancedMesh,
    isInstancedMesh: true,
    copy: function(source) {
        Mesh1.prototype.copy.call(this, source);
        this.instanceMatrix.copy(source.instanceMatrix);
        this.count = source.count;
        return this;
    },
    setColorAt: function(index, color1) {
        if (this.instanceColor === null) this.instanceColor = new BufferAttribute1(new Float32Array(this.count * 3), 3);
        color1.toArray(this.instanceColor.array, index * 3);
    },
    getMatrixAt: function(index, matrix) {
        matrix.fromArray(this.instanceMatrix.array, index * 16);
    },
    raycast: function(raycaster, intersects) {
        const matrixWorld = this.matrixWorld;
        const raycastTimes = this.count;
        _mesh.geometry = this.geometry;
        _mesh.material = this.material;
        if (_mesh.material === undefined) return;
        for(let instanceId = 0; instanceId < raycastTimes; instanceId++){
            // calculate the world matrix for each instance
            this.getMatrixAt(instanceId, _instanceLocalMatrix);
            _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
            // the mesh represents this single instance
            _mesh.matrixWorld = _instanceWorldMatrix;
            _mesh.raycast(raycaster, _instanceIntersects);
            // process the result of raycast
            for(let i1 = 0, l = _instanceIntersects.length; i1 < l; i1++){
                const intersect = _instanceIntersects[i1];
                intersect.instanceId = instanceId;
                intersect.object = this;
                intersects.push(intersect);
            }
            _instanceIntersects.length = 0;
        }
    },
    setMatrixAt: function(index, matrix) {
        matrix.toArray(this.instanceMatrix.array, index * 16);
    },
    updateMorphTargets: function() {
    }
});
const InstancedMesh1 = InstancedMesh;
export { InstancedMesh1 as InstancedMesh };
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */
function LineBasicMaterial2(parameters) {
    Material1.call(this);
    this.type = 'LineBasicMaterial';
    this.color = new Color1(16777215);
    this.linewidth = 1;
    this.linecap = 'round';
    this.linejoin = 'round';
    this.morphTargets = false;
    this.setValues(parameters);
}
LineBasicMaterial2.prototype = Object.create(Material1.prototype);
LineBasicMaterial2.prototype.constructor = LineBasicMaterial2;
LineBasicMaterial2.prototype.isLineBasicMaterial = true;
LineBasicMaterial2.prototype.copy = function(source) {
    Material1.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.morphTargets = source.morphTargets;
    return this;
};
const LineBasicMaterial1 = LineBasicMaterial2;
const _start = new Vector31();
const _end = new Vector31();
const _inverseMatrix1 = new Matrix41();
const _ray1 = new Ray1();
const _sphere2 = new Sphere1();
function Line(geometry, material, mode) {
    if (mode === 1) console.error('THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.');
    Object3D1.call(this);
    this.type = 'Line';
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry1();
    this.material = material !== undefined ? material : new LineBasicMaterial1();
    this.updateMorphTargets();
}
Line.prototype = Object.assign(Object.create(Object3D1.prototype), {
    constructor: Line,
    isLine: true,
    copy: function(source) {
        Object3D1.prototype.copy.call(this, source);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    },
    computeLineDistances: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            // we assume non-indexed geometry
            if (geometry.index === null) {
                const positionAttribute = geometry.attributes.position;
                const lineDistances = [
                    0
                ];
                for(let i1 = 1, l = positionAttribute.count; i1 < l; i1++){
                    _start.fromBufferAttribute(positionAttribute, i1 - 1);
                    _end.fromBufferAttribute(positionAttribute, i1);
                    lineDistances[i1] = lineDistances[i1 - 1];
                    lineDistances[i1] += _start.distanceTo(_end);
                }
                geometry.setAttribute('lineDistance', new Float32BufferAttribute1(lineDistances, 1));
            } else console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        } else if (geometry.isGeometry) {
            const vertices2 = geometry.vertices;
            const lineDistances = geometry.lineDistances;
            lineDistances[0] = 0;
            for(let i1 = 1, l = vertices2.length; i1 < l; i1++){
                lineDistances[i1] = lineDistances[i1 - 1];
                lineDistances[i1] += vertices2[i1 - 1].distanceTo(vertices2[i1]);
            }
        }
        return this;
    },
    raycast: function(raycaster, intersects) {
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Line.threshold;
        // Checking boundingSphere distance to ray
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere2.copy(geometry.boundingSphere);
        _sphere2.applyMatrix4(matrixWorld);
        _sphere2.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere2) === false) return;
        //
        _inverseMatrix1.getInverse(matrixWorld);
        _ray1.copy(raycaster.ray).applyMatrix4(_inverseMatrix1);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        const vStart = new Vector31();
        const vEnd = new Vector31();
        const interSegment = new Vector31();
        const interRay = new Vector31();
        const step = this && this.isLineSegments ? 2 : 1;
        if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positions = attributes.position.array;
            if (index !== null) {
                const indices2 = index.array;
                for(let i1 = 0, l = indices2.length - 1; i1 < l; i1 += step){
                    const a2 = indices2[i1];
                    const b2 = indices2[i1 + 1];
                    vStart.fromArray(positions, a2 * 3);
                    vEnd.fromArray(positions, b2 * 3);
                    const distSq = _ray1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                    if (distSq > localThresholdSq) continue;
                    interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                    const distance = raycaster.ray.origin.distanceTo(interRay);
                    if (distance < raycaster.near || distance > raycaster.far) continue;
                    intersects.push({
                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                        index: i1,
                        face: null,
                        faceIndex: null,
                        object: this
                    });
                }
            } else for(let i1 = 0, l = positions.length / 3 - 1; i1 < l; i1 += step){
                vStart.fromArray(positions, 3 * i1);
                vEnd.fromArray(positions, 3 * i1 + 3);
                const distSq = _ray1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                if (distSq > localThresholdSq) continue;
                interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                const distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far) continue;
                intersects.push({
                    distance: distance,
                    // What do we want? intersection point on the ray or on the segment??
                    // point: raycaster.ray.at( distance ),
                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                    index: i1,
                    face: null,
                    faceIndex: null,
                    object: this
                });
            }
        } else if (geometry.isGeometry) {
            const vertices2 = geometry.vertices;
            const nbVertices = vertices2.length;
            for(let i1 = 0; i1 < nbVertices - 1; i1 += step){
                const distSq = _ray1.distanceSqToSegment(vertices2[i1], vertices2[i1 + 1], interRay, interSegment);
                if (distSq > localThresholdSq) continue;
                interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                const distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far) continue;
                intersects.push({
                    distance: distance,
                    // What do we want? intersection point on the ray or on the segment??
                    // point: raycaster.ray.at( distance ),
                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                    index: i1,
                    face: null,
                    faceIndex: null,
                    object: this
                });
            }
        }
    },
    updateMorphTargets: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {
                    };
                    for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
    }
});
const Line1 = Line;
const _start1 = new Vector31();
const _end1 = new Vector31();
function LineSegments(geometry, material) {
    Line1.call(this, geometry, material);
    this.type = 'LineSegments';
}
LineSegments.prototype = Object.assign(Object.create(Line1.prototype), {
    constructor: LineSegments,
    isLineSegments: true,
    computeLineDistances: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            // we assume non-indexed geometry
            if (geometry.index === null) {
                const positionAttribute = geometry.attributes.position;
                const lineDistances = [];
                for(let i1 = 0, l = positionAttribute.count; i1 < l; i1 += 2){
                    _start1.fromBufferAttribute(positionAttribute, i1);
                    _end1.fromBufferAttribute(positionAttribute, i1 + 1);
                    lineDistances[i1] = i1 === 0 ? 0 : lineDistances[i1 - 1];
                    lineDistances[i1 + 1] = lineDistances[i1] + _start1.distanceTo(_end1);
                }
                geometry.setAttribute('lineDistance', new Float32BufferAttribute1(lineDistances, 1));
            } else console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        } else if (geometry.isGeometry) {
            const vertices2 = geometry.vertices;
            const lineDistances = geometry.lineDistances;
            for(let i1 = 0, l = vertices2.length; i1 < l; i1 += 2){
                _start1.copy(vertices2[i1]);
                _end1.copy(vertices2[i1 + 1]);
                lineDistances[i1] = i1 === 0 ? 0 : lineDistances[i1 - 1];
                lineDistances[i1 + 1] = lineDistances[i1] + _start1.distanceTo(_end1);
            }
        }
        return this;
    }
});
const LineSegments1 = LineSegments;
export { LineSegments1 as LineSegments };
function LineLoop(geometry, material) {
    Line1.call(this, geometry, material);
    this.type = 'LineLoop';
}
LineLoop.prototype = Object.assign(Object.create(Line1.prototype), {
    constructor: LineLoop,
    isLineLoop: true
});
const LineLoop1 = LineLoop;
export { LineLoop1 as LineLoop };
const _start = new Vector31();
const _end = new Vector31();
const _inverseMatrix1 = new Matrix41();
const _ray1 = new Ray1();
const _sphere2 = new Sphere1();
function Line2(geometry, material, mode) {
    if (mode === 1) console.error('THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.');
    Object3D1.call(this);
    this.type = 'Line';
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry1();
    this.material = material !== undefined ? material : new LineBasicMaterial1();
    this.updateMorphTargets();
}
Line2.prototype = Object.assign(Object.create(Object3D1.prototype), {
    constructor: Line2,
    isLine: true,
    copy: function(source) {
        Object3D1.prototype.copy.call(this, source);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    },
    computeLineDistances: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            if (geometry.index === null) {
                const positionAttribute = geometry.attributes.position;
                const lineDistances = [
                    0
                ];
                for(let i1 = 1, l = positionAttribute.count; i1 < l; i1++){
                    _start.fromBufferAttribute(positionAttribute, i1 - 1);
                    _end.fromBufferAttribute(positionAttribute, i1);
                    lineDistances[i1] = lineDistances[i1 - 1];
                    lineDistances[i1] += _start.distanceTo(_end);
                }
                geometry.setAttribute('lineDistance', new Float32BufferAttribute1(lineDistances, 1));
            } else console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        } else if (geometry.isGeometry) {
            const vertices2 = geometry.vertices;
            const lineDistances = geometry.lineDistances;
            lineDistances[0] = 0;
            for(let i1 = 1, l = vertices2.length; i1 < l; i1++){
                lineDistances[i1] = lineDistances[i1 - 1];
                lineDistances[i1] += vertices2[i1 - 1].distanceTo(vertices2[i1]);
            }
        }
        return this;
    },
    raycast: function(raycaster, intersects) {
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Line.threshold;
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere2.copy(geometry.boundingSphere);
        _sphere2.applyMatrix4(matrixWorld);
        _sphere2.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere2) === false) return;
        _inverseMatrix1.getInverse(matrixWorld);
        _ray1.copy(raycaster.ray).applyMatrix4(_inverseMatrix1);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        const vStart = new Vector31();
        const vEnd = new Vector31();
        const interSegment = new Vector31();
        const interRay = new Vector31();
        const step = this && this.isLineSegments ? 2 : 1;
        if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positions = attributes.position.array;
            if (index !== null) {
                const indices2 = index.array;
                for(let i1 = 0, l = indices2.length - 1; i1 < l; i1 += step){
                    const a2 = indices2[i1];
                    const b2 = indices2[i1 + 1];
                    vStart.fromArray(positions, a2 * 3);
                    vEnd.fromArray(positions, b2 * 3);
                    const distSq = _ray1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                    if (distSq > localThresholdSq) continue;
                    interRay.applyMatrix4(this.matrixWorld);
                    const distance = raycaster.ray.origin.distanceTo(interRay);
                    if (distance < raycaster.near || distance > raycaster.far) continue;
                    intersects.push({
                        distance: distance,
                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                        index: i1,
                        face: null,
                        faceIndex: null,
                        object: this
                    });
                }
            } else for(let i1 = 0, l = positions.length / 3 - 1; i1 < l; i1 += step){
                vStart.fromArray(positions, 3 * i1);
                vEnd.fromArray(positions, 3 * i1 + 3);
                const distSq = _ray1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                if (distSq > localThresholdSq) continue;
                interRay.applyMatrix4(this.matrixWorld);
                const distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far) continue;
                intersects.push({
                    distance: distance,
                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                    index: i1,
                    face: null,
                    faceIndex: null,
                    object: this
                });
            }
        } else if (geometry.isGeometry) {
            const vertices2 = geometry.vertices;
            const nbVertices = vertices2.length;
            for(let i1 = 0; i1 < nbVertices - 1; i1 += step){
                const distSq = _ray1.distanceSqToSegment(vertices2[i1], vertices2[i1 + 1], interRay, interSegment);
                if (distSq > localThresholdSq) continue;
                interRay.applyMatrix4(this.matrixWorld);
                const distance = raycaster.ray.origin.distanceTo(interRay);
                if (distance < raycaster.near || distance > raycaster.far) continue;
                intersects.push({
                    distance: distance,
                    point: interSegment.clone().applyMatrix4(this.matrixWorld),
                    index: i1,
                    face: null,
                    faceIndex: null,
                    object: this
                });
            }
        }
    },
    updateMorphTargets: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {
                    };
                    for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
    }
});
const Line1 = Line2;
export { Line1 as Line };
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */
function PointsMaterial(parameters) {
    Material1.call(this);
    this.type = 'PointsMaterial';
    this.color = new Color1(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.morphTargets = false;
    this.setValues(parameters);
}
PointsMaterial.prototype = Object.create(Material1.prototype);
PointsMaterial.prototype.constructor = PointsMaterial;
PointsMaterial.prototype.isPointsMaterial = true;
PointsMaterial.prototype.copy = function(source) {
    Material1.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.morphTargets = source.morphTargets;
    return this;
};
const PointsMaterial1 = PointsMaterial;
const _inverseMatrix2 = new Matrix41();
const _ray2 = new Ray1();
const _sphere3 = new Sphere1();
const _position1 = new Vector31();
function Points(geometry, material) {
    Object3D1.call(this);
    this.type = 'Points';
    this.geometry = geometry !== undefined ? geometry : new BufferGeometry1();
    this.material = material !== undefined ? material : new PointsMaterial1();
    this.updateMorphTargets();
}
Points.prototype = Object.assign(Object.create(Object3D1.prototype), {
    constructor: Points,
    isPoints: true,
    copy: function(source) {
        Object3D1.prototype.copy.call(this, source);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
    },
    raycast: function(raycaster, intersects) {
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Points.threshold;
        // Checking boundingSphere distance to ray
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere3.copy(geometry.boundingSphere);
        _sphere3.applyMatrix4(matrixWorld);
        _sphere3.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere3) === false) return;
        //
        _inverseMatrix2.getInverse(matrixWorld);
        _ray2.copy(raycaster.ray).applyMatrix4(_inverseMatrix2);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        if (geometry.isBufferGeometry) {
            const index = geometry.index;
            const attributes = geometry.attributes;
            const positions = attributes.position.array;
            if (index !== null) {
                const indices2 = index.array;
                for(let i1 = 0, il = indices2.length; i1 < il; i1++){
                    const a2 = indices2[i1];
                    _position1.fromArray(positions, a2 * 3);
                    testPoint(_position1, a2, localThresholdSq, matrixWorld, raycaster, intersects, this);
                }
            } else for(let i1 = 0, l = positions.length / 3; i1 < l; i1++){
                _position1.fromArray(positions, i1 * 3);
                testPoint(_position1, i1, localThresholdSq, matrixWorld, raycaster, intersects, this);
            }
        } else {
            const vertices2 = geometry.vertices;
            for(let i1 = 0, l = vertices2.length; i1 < l; i1++)testPoint(vertices2[i1], i1, localThresholdSq, matrixWorld, raycaster, intersects, this);
        }
    },
    updateMorphTargets: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            const morphAttributes = geometry.morphAttributes;
            const keys = Object.keys(morphAttributes);
            if (keys.length > 0) {
                const morphAttribute = morphAttributes[keys[0]];
                if (morphAttribute !== undefined) {
                    this.morphTargetInfluences = [];
                    this.morphTargetDictionary = {
                    };
                    for(let m = 0, ml = morphAttribute.length; m < ml; m++){
                        const name = morphAttribute[m].name || String(m);
                        this.morphTargetInfluences.push(0);
                        this.morphTargetDictionary[name] = m;
                    }
                }
            }
        } else {
            const morphTargets = geometry.morphTargets;
            if (morphTargets !== undefined && morphTargets.length > 0) console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
        }
    }
});
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
    const rayPointDistanceSq = _ray2.distanceSqToPoint(point);
    if (rayPointDistanceSq < localThresholdSq) {
        const intersectPoint = new Vector31();
        _ray2.closestPointToPoint(point, intersectPoint);
        intersectPoint.applyMatrix4(matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far) return;
        intersects.push({
            distance: distance,
            distanceToRay: Math.sqrt(rayPointDistanceSq),
            point: intersectPoint,
            index: index,
            face: null,
            object: object
        });
    }
}
const Points1 = Points;
export { Points1 as Points };
function Group2() {
    Object3D1.call(this);
    this.type = 'Group';
}
Group2.prototype = Object.assign(Object.create(Object3D1.prototype), {
    constructor: Group2,
    isGroup: true
});
const Group1 = Group2;
export { Group1 as Group };
function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    Texture1.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.format = format !== undefined ? format : RGBFormat;
    this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
    this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    this.generateMipmaps = false;
    const scope1 = this;
    function updateVideo() {
        scope1.needsUpdate = true;
        video.requestVideoFrameCallback(updateVideo);
    }
    if ('requestVideoFrameCallback' in video) video.requestVideoFrameCallback(updateVideo);
}
VideoTexture.prototype = Object.assign(Object.create(Texture1.prototype), {
    constructor: VideoTexture,
    isVideoTexture: true,
    update: function() {
        const video = this.image;
        const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;
        if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) this.needsUpdate = true;
    }
});
const VideoTexture1 = VideoTexture;
export { VideoTexture1 as VideoTexture };
function DataTexture2(data, width2, height2, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    Texture1.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {
        data: data || null,
        width: width2 || 1,
        height: height2 || 1
    };
    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.needsUpdate = true;
}
DataTexture2.prototype = Object.create(Texture1.prototype);
DataTexture2.prototype.constructor = DataTexture2;
DataTexture2.prototype.isDataTexture = true;
const DataTexture1 = DataTexture2;
export { DataTexture1 as DataTexture };
function DataTexture2DArray3(data, width2, height2, depth1) {
    Texture1.call(this, null);
    this.image = {
        data: data || null,
        width: width2 || 1,
        height: height2 || 1,
        depth: depth1 || 1
    };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
}
DataTexture2DArray3.prototype = Object.create(Texture1.prototype);
DataTexture2DArray3.prototype.constructor = DataTexture2DArray3;
DataTexture2DArray3.prototype.isDataTexture2DArray = true;
const DataTexture2DArray1 = DataTexture2DArray3;
export { DataTexture2DArray1 as DataTexture2DArray };
function DataTexture3D3(data, width2, height2, depth1) {
    Texture1.call(this, null);
    this.image = {
        data: data || null,
        width: width2 || 1,
        height: height2 || 1,
        depth: depth1 || 1
    };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.needsUpdate = true;
}
DataTexture3D3.prototype = Object.create(Texture1.prototype);
DataTexture3D3.prototype.constructor = DataTexture3D3;
DataTexture3D3.prototype.isDataTexture3D = true;
const DataTexture3D1 = DataTexture3D3;
export { DataTexture3D1 as DataTexture3D };
function CompressedTexture(mipmaps, width2, height2, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    Texture1.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {
        width: width2,
        height: height2
    };
    this.mipmaps = mipmaps;
    // no flipping for cube textures
    // (also flipping doesn't work for compressed textures )
    this.flipY = false;
    // can't generate mipmaps for compressed textures
    // mips must be embedded in DDS files
    this.generateMipmaps = false;
}
CompressedTexture.prototype = Object.create(Texture1.prototype);
CompressedTexture.prototype.constructor = CompressedTexture;
CompressedTexture.prototype.isCompressedTexture = true;
const CompressedTexture1 = CompressedTexture;
export { CompressedTexture1 as CompressedTexture };
function CubeTexture2(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    images = images !== undefined ? images : [];
    mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
    format = format !== undefined ? format : RGBFormat;
    Texture1.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.flipY = false;
}
CubeTexture2.prototype = Object.create(Texture1.prototype);
CubeTexture2.prototype.constructor = CubeTexture2;
CubeTexture2.prototype.isCubeTexture = true;
Object.defineProperty(CubeTexture2.prototype, 'images', {
    get: function() {
        return this.image;
    },
    set: function(value) {
        this.image = value;
    }
});
const CubeTexture1 = CubeTexture2;
export { CubeTexture1 as CubeTexture };
function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    Texture1.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.needsUpdate = true;
}
CanvasTexture.prototype = Object.create(Texture1.prototype);
CanvasTexture.prototype.constructor = CanvasTexture;
CanvasTexture.prototype.isCanvasTexture = true;
const CanvasTexture1 = CanvasTexture;
export { CanvasTexture1 as CanvasTexture };
function DepthTexture(width2, height2, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== undefined ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
    if (type === undefined && format === DepthFormat) type = UnsignedShortType;
    if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
    Texture1.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = {
        width: width2,
        height: height2
    };
    this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
}
DepthTexture.prototype = Object.create(Texture1.prototype);
DepthTexture.prototype.constructor = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;
const DepthTexture1 = DepthTexture;
export { DepthTexture1 as DepthTexture };
let _canvas;
const ImageUtils2 = {
    getDataURL: function(image) {
        if (/^data:/i.test(image.src)) return image.src;
        if (typeof HTMLCanvasElement == 'undefined') return image.src;
        let canvas;
        if (image instanceof HTMLCanvasElement) canvas = image;
        else {
            if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
            _canvas.width = image.width;
            _canvas.height = image.height;
            const context = _canvas.getContext('2d');
            if (image instanceof ImageData) context.putImageData(image, 0, 0);
            else context.drawImage(image, 0, 0, image.width, image.height);
            canvas = _canvas;
        }
        if (canvas.width > 2048 || canvas.height > 2048) return canvas.toDataURL('image/jpeg', 0.6);
        else return canvas.toDataURL('image/png');
    }
};
const ImageUtils1 = ImageUtils2;
let textureId = 0;
function Texture2(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    Object.defineProperty(this, 'id', {
        value: textureId++
    });
    this.uuid = MathUtils1.generateUUID();
    this.name = '';
    this.image = image !== undefined ? image : Texture2.DEFAULT_IMAGE;
    this.mipmaps = [];
    this.mapping = mapping !== undefined ? mapping : Texture2.DEFAULT_MAPPING;
    this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
    this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
    this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    this.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;
    this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
    this.format = format !== undefined ? format : RGBAFormat;
    this.internalFormat = null;
    this.type = type !== undefined ? type : UnsignedByteType;
    this.offset = new Vector21(0, 0);
    this.repeat = new Vector21(1, 1);
    this.center = new Vector21(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix31();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = encoding !== undefined ? encoding : LinearEncoding;
    this.version = 0;
    this.onUpdate = null;
}
Texture2.DEFAULT_IMAGE = undefined;
Texture2.DEFAULT_MAPPING = UVMapping;
Texture2.prototype = Object.assign(Object.create(EventDispatcher1.prototype), {
    constructor: Texture2,
    isTexture: true,
    updateMatrix: function() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.name = source.name;
        this.image = source.image;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.internalFormat = source.internalFormat;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.center.copy(source.center);
        this.rotation = source.rotation;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrix.copy(source.matrix);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        this.encoding = source.encoding;
        return this;
    },
    toJSON: function(meta) {
        const isRootObject = meta === undefined || typeof meta === 'string';
        if (!isRootObject && meta.textures[this.uuid] !== undefined) return meta.textures[this.uuid];
        const output = {
            metadata: {
                version: 4.5,
                type: 'Texture',
                generator: 'Texture.toJSON'
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [
                this.repeat.x,
                this.repeat.y
            ],
            offset: [
                this.offset.x,
                this.offset.y
            ],
            center: [
                this.center.x,
                this.center.y
            ],
            rotation: this.rotation,
            wrap: [
                this.wrapS,
                this.wrapT
            ],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        if (this.image !== undefined) {
            const image = this.image;
            if (image.uuid === undefined) image.uuid = MathUtils1.generateUUID();
            if (!isRootObject && meta.images[image.uuid] === undefined) {
                let url;
                if (Array.isArray(image)) {
                    url = [];
                    for(let i1 = 0, l = image.length; i1 < l; i1++)url.push(ImageUtils1.getDataURL(image[i1]));
                } else url = ImageUtils1.getDataURL(image);
                meta.images[image.uuid] = {
                    uuid: image.uuid,
                    url: url
                };
            }
            output.image = image.uuid;
        }
        if (!isRootObject) meta.textures[this.uuid] = output;
        return output;
    },
    dispose: function() {
        this.dispatchEvent({
            type: 'dispose'
        });
    },
    transformUv: function(uv) {
        if (this.mapping !== UVMapping) return uv;
        uv.applyMatrix3(this.matrix);
        if (uv.x < 0 || uv.x > 1) switch(this.wrapS){
            case RepeatWrapping:
                uv.x = uv.x - Math.floor(uv.x);
                break;
            case ClampToEdgeWrapping:
                uv.x = uv.x < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.x) % 2) === 1) uv.x = Math.ceil(uv.x) - uv.x;
                else uv.x = uv.x - Math.floor(uv.x);
                break;
        }
        if (uv.y < 0 || uv.y > 1) switch(this.wrapT){
            case RepeatWrapping:
                uv.y = uv.y - Math.floor(uv.y);
                break;
            case ClampToEdgeWrapping:
                uv.y = uv.y < 0 ? 0 : 1;
                break;
            case MirroredRepeatWrapping:
                if (Math.abs(Math.floor(uv.y) % 2) === 1) uv.y = Math.ceil(uv.y) - uv.y;
                else uv.y = uv.y - Math.floor(uv.y);
                break;
        }
        if (this.flipY) uv.y = 1 - uv.y;
        return uv;
    }
});
Object.defineProperty(Texture2.prototype, "needsUpdate", {
    set: function(value) {
        if (value === true) this.version++;
    }
});
const Texture1 = Texture2;
export { Texture1 as Texture };
let _geometryId = 0; // Geometry uses even numbers as Id
const _m13 = new Matrix41();
const _obj1 = new Object3D1();
const _offset1 = new Vector31();
function Geometry() {
    Object.defineProperty(this, 'id', {
        value: _geometryId += 2
    });
    this.uuid = MathUtils1.generateUUID();
    this.name = '';
    this.type = 'Geometry';
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [
        []
    ];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    // update flags
    this.elementsNeedUpdate = false;
    this.verticesNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.lineDistancesNeedUpdate = false;
    this.groupsNeedUpdate = false;
}
Geometry.prototype = Object.assign(Object.create(EventDispatcher1.prototype), {
    constructor: Geometry,
    isGeometry: true,
    applyMatrix4: function(matrix) {
        const normalMatrix = new Matrix31().getNormalMatrix(matrix);
        for(let i1 = 0, il = this.vertices.length; i1 < il; i1++){
            const vertex = this.vertices[i1];
            vertex.applyMatrix4(matrix);
        }
        for(let i1 = 0, il = this.faces.length; i1 < il; i1++){
            const face = this.faces[i1];
            face.normal.applyMatrix3(normalMatrix).normalize();
            for(let j = 0, jl = face.vertexNormals.length; j < jl; j++)face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
        }
        if (this.boundingBox !== null) this.computeBoundingBox();
        if (this.boundingSphere !== null) this.computeBoundingSphere();
        this.verticesNeedUpdate = true;
        this.normalsNeedUpdate = true;
        return this;
    },
    rotateX: function(angle) {
        // rotate geometry around world x-axis
        _m13.makeRotationX(angle);
        this.applyMatrix4(_m13);
        return this;
    },
    rotateY: function(angle) {
        // rotate geometry around world y-axis
        _m13.makeRotationY(angle);
        this.applyMatrix4(_m13);
        return this;
    },
    rotateZ: function(angle) {
        // rotate geometry around world z-axis
        _m13.makeRotationZ(angle);
        this.applyMatrix4(_m13);
        return this;
    },
    translate: function(x6, y6, z5) {
        // translate geometry
        _m13.makeTranslation(x6, y6, z5);
        this.applyMatrix4(_m13);
        return this;
    },
    scale: function(x6, y6, z5) {
        // scale geometry
        _m13.makeScale(x6, y6, z5);
        this.applyMatrix4(_m13);
        return this;
    },
    lookAt: function(vector) {
        _obj1.lookAt(vector);
        _obj1.updateMatrix();
        this.applyMatrix4(_obj1.matrix);
        return this;
    },
    fromBufferGeometry: function(geometry) {
        const scope1 = this;
        const index = geometry.index !== null ? geometry.index : undefined;
        const attributes = geometry.attributes;
        if (attributes.position === undefined) {
            console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');
            return this;
        }
        const position = attributes.position;
        const normal2 = attributes.normal;
        const color1 = attributes.color;
        const uv = attributes.uv;
        const uv2 = attributes.uv2;
        if (uv2 !== undefined) this.faceVertexUvs[1] = [];
        for(let i1 = 0; i1 < position.count; i1++){
            scope1.vertices.push(new Vector31().fromBufferAttribute(position, i1));
            if (color1 !== undefined) scope1.colors.push(new Color1().fromBufferAttribute(color1, i1));
        }
        function addFace(a2, b2, c2, materialIndex1) {
            const vertexColors = color1 === undefined ? [] : [
                scope1.colors[a2].clone(),
                scope1.colors[b2].clone(),
                scope1.colors[c2].clone()
            ];
            const vertexNormals = normal2 === undefined ? [] : [
                new Vector31().fromBufferAttribute(normal2, a2),
                new Vector31().fromBufferAttribute(normal2, b2),
                new Vector31().fromBufferAttribute(normal2, c2)
            ];
            const face = new Face31(a2, b2, c2, vertexNormals, vertexColors, materialIndex1);
            scope1.faces.push(face);
            if (uv !== undefined) scope1.faceVertexUvs[0].push([
                new Vector21().fromBufferAttribute(uv, a2),
                new Vector21().fromBufferAttribute(uv, b2),
                new Vector21().fromBufferAttribute(uv, c2)
            ]);
            if (uv2 !== undefined) scope1.faceVertexUvs[1].push([
                new Vector21().fromBufferAttribute(uv2, a2),
                new Vector21().fromBufferAttribute(uv2, b2),
                new Vector21().fromBufferAttribute(uv2, c2)
            ]);
        }
        const groups = geometry.groups;
        if (groups.length > 0) for(let i1 = 0; i1 < groups.length; i1++){
            const group = groups[i1];
            const start = group.start;
            const count = group.count;
            for(let j = start, jl = start + count; j < jl; j += 3)if (index !== undefined) addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);
            else addFace(j, j + 1, j + 2, group.materialIndex);
        }
        else if (index !== undefined) for(let i1 = 0; i1 < index.count; i1 += 3)addFace(index.getX(i1), index.getX(i1 + 1), index.getX(i1 + 2));
        else for(let i1 = 0; i1 < position.count; i1 += 3)addFace(i1, i1 + 1, i1 + 2);
        this.computeFaceNormals();
        if (geometry.boundingBox !== null) this.boundingBox = geometry.boundingBox.clone();
        if (geometry.boundingSphere !== null) this.boundingSphere = geometry.boundingSphere.clone();
        return this;
    },
    center: function() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(_offset1).negate();
        this.translate(_offset1.x, _offset1.y, _offset1.z);
        return this;
    },
    normalize: function() {
        this.computeBoundingSphere();
        const center = this.boundingSphere.center;
        const radius = this.boundingSphere.radius;
        const s = radius === 0 ? 1 : 1 / radius;
        const matrix = new Matrix41();
        matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
        this.applyMatrix4(matrix);
        return this;
    },
    computeFaceNormals: function() {
        const cb = new Vector31(), ab = new Vector31();
        for(let f = 0, fl = this.faces.length; f < fl; f++){
            const face = this.faces[f];
            const vA = this.vertices[face.a];
            const vB = this.vertices[face.b];
            const vC = this.vertices[face.c];
            cb.subVectors(vC, vB);
            ab.subVectors(vA, vB);
            cb.cross(ab);
            cb.normalize();
            face.normal.copy(cb);
        }
    },
    computeVertexNormals: function(areaWeighted) {
        if (areaWeighted === undefined) areaWeighted = true;
        const vertices2 = new Array(this.vertices.length);
        for(let v = 0, vl = this.vertices.length; v < vl; v++)vertices2[v] = new Vector31();
        if (areaWeighted) {
            // vertex normals weighted by triangle areas
            // http://www.iquilezles.org/www/articles/normals/normals.htm
            const cb = new Vector31(), ab = new Vector31();
            for(let f = 0, fl = this.faces.length; f < fl; f++){
                const face = this.faces[f];
                const vA = this.vertices[face.a];
                const vB = this.vertices[face.b];
                const vC = this.vertices[face.c];
                cb.subVectors(vC, vB);
                ab.subVectors(vA, vB);
                cb.cross(ab);
                vertices2[face.a].add(cb);
                vertices2[face.b].add(cb);
                vertices2[face.c].add(cb);
            }
        } else {
            this.computeFaceNormals();
            for(let f = 0, fl = this.faces.length; f < fl; f++){
                const face = this.faces[f];
                vertices2[face.a].add(face.normal);
                vertices2[face.b].add(face.normal);
                vertices2[face.c].add(face.normal);
            }
        }
        for(let v = 0, vl = this.vertices.length; v < vl; v++)vertices2[v].normalize();
        for(let f = 0, fl = this.faces.length; f < fl; f++){
            const face = this.faces[f];
            const vertexNormals = face.vertexNormals;
            if (vertexNormals.length === 3) {
                vertexNormals[0].copy(vertices2[face.a]);
                vertexNormals[1].copy(vertices2[face.b]);
                vertexNormals[2].copy(vertices2[face.c]);
            } else {
                vertexNormals[0] = vertices2[face.a].clone();
                vertexNormals[1] = vertices2[face.b].clone();
                vertexNormals[2] = vertices2[face.c].clone();
            }
        }
        if (this.faces.length > 0) this.normalsNeedUpdate = true;
    },
    computeFlatVertexNormals: function() {
        this.computeFaceNormals();
        for(let f = 0, fl = this.faces.length; f < fl; f++){
            const face = this.faces[f];
            const vertexNormals = face.vertexNormals;
            if (vertexNormals.length === 3) {
                vertexNormals[0].copy(face.normal);
                vertexNormals[1].copy(face.normal);
                vertexNormals[2].copy(face.normal);
            } else {
                vertexNormals[0] = face.normal.clone();
                vertexNormals[1] = face.normal.clone();
                vertexNormals[2] = face.normal.clone();
            }
        }
        if (this.faces.length > 0) this.normalsNeedUpdate = true;
    },
    computeMorphNormals: function() {
        // save original normals
        // - create temp variables on first access
        //   otherwise just copy (for faster repeated calls)
        for(let f = 0, fl = this.faces.length; f < fl; f++){
            const face = this.faces[f];
            if (!face.__originalFaceNormal) face.__originalFaceNormal = face.normal.clone();
            else face.__originalFaceNormal.copy(face.normal);
            if (!face.__originalVertexNormals) face.__originalVertexNormals = [];
            for(let i1 = 0, il = face.vertexNormals.length; i1 < il; i1++)if (!face.__originalVertexNormals[i1]) face.__originalVertexNormals[i1] = face.vertexNormals[i1].clone();
            else face.__originalVertexNormals[i1].copy(face.vertexNormals[i1]);
        }
        // use temp geometry to compute face and vertex normals for each morph
        const tmpGeo = new Geometry();
        tmpGeo.faces = this.faces;
        for(let i1 = 0, il = this.morphTargets.length; i1 < il; i1++){
            // create on first access
            if (!this.morphNormals[i1]) {
                this.morphNormals[i1] = {
                };
                this.morphNormals[i1].faceNormals = [];
                this.morphNormals[i1].vertexNormals = [];
                const dstNormalsFace = this.morphNormals[i1].faceNormals;
                const dstNormalsVertex = this.morphNormals[i1].vertexNormals;
                for(let f1 = 0, fl1 = this.faces.length; f1 < fl1; f1++){
                    const faceNormal = new Vector31();
                    const vertexNormals = {
                        a: new Vector31(),
                        b: new Vector31(),
                        c: new Vector31()
                    };
                    dstNormalsFace.push(faceNormal);
                    dstNormalsVertex.push(vertexNormals);
                }
            }
            const morphNormals = this.morphNormals[i1];
            // set vertices to morph target
            tmpGeo.vertices = this.morphTargets[i1].vertices;
            // compute morph normals
            tmpGeo.computeFaceNormals();
            tmpGeo.computeVertexNormals();
            // store morph normals
            for(let f1 = 0, fl1 = this.faces.length; f1 < fl1; f1++){
                const face = this.faces[f1];
                const faceNormal = morphNormals.faceNormals[f1];
                const vertexNormals = morphNormals.vertexNormals[f1];
                faceNormal.copy(face.normal);
                vertexNormals.a.copy(face.vertexNormals[0]);
                vertexNormals.b.copy(face.vertexNormals[1]);
                vertexNormals.c.copy(face.vertexNormals[2]);
            }
        }
        // restore original normals
        for(let f = 0, fl = this.faces.length; f < fl; f++){
            const face = this.faces[f];
            face.normal = face.__originalFaceNormal;
            face.vertexNormals = face.__originalVertexNormals;
        }
    },
    computeBoundingBox: function() {
        if (this.boundingBox === null) this.boundingBox = new Box31();
        this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function() {
        if (this.boundingSphere === null) this.boundingSphere = new Sphere1();
        this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function(geometry, matrix, materialIndexOffset) {
        if (!(geometry && geometry.isGeometry)) {
            console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
            return;
        }
        let normalMatrix;
        const vertexOffset = this.vertices.length, vertices11 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, colors1 = this.colors, colors2 = geometry.colors;
        if (materialIndexOffset === undefined) materialIndexOffset = 0;
        if (matrix !== undefined) normalMatrix = new Matrix31().getNormalMatrix(matrix);
        // vertices
        for(let i1 = 0, il = vertices2.length; i1 < il; i1++){
            const vertex = vertices2[i1];
            const vertexCopy = vertex.clone();
            if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);
            vertices11.push(vertexCopy);
        }
        // colors
        for(let i1 = 0, il = colors2.length; i1 < il; i1++)colors1.push(colors2[i1].clone());
        // faces
        for(let i1 = 0, il = faces2.length; i1 < il; i1++){
            const face = faces2[i1];
            let normal2, color1;
            const faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
            const faceCopy = new Face31(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
            faceCopy.normal.copy(face.normal);
            if (normalMatrix !== undefined) faceCopy.normal.applyMatrix3(normalMatrix).normalize();
            for(let j = 0, jl = faceVertexNormals.length; j < jl; j++){
                normal2 = faceVertexNormals[j].clone();
                if (normalMatrix !== undefined) normal2.applyMatrix3(normalMatrix).normalize();
                faceCopy.vertexNormals.push(normal2);
            }
            faceCopy.color.copy(face.color);
            for(let j = 0, jl = faceVertexColors.length; j < jl; j++){
                color1 = faceVertexColors[j];
                faceCopy.vertexColors.push(color1.clone());
            }
            faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
            faces1.push(faceCopy);
        }
        // uvs
        for(let i1 = 0, il = geometry.faceVertexUvs.length; i1 < il; i1++){
            const faceVertexUvs2 = geometry.faceVertexUvs[i1];
            if (this.faceVertexUvs[i1] === undefined) this.faceVertexUvs[i1] = [];
            for(let j = 0, jl = faceVertexUvs2.length; j < jl; j++){
                const uvs2 = faceVertexUvs2[j], uvsCopy = [];
                for(let k = 0, kl = uvs2.length; k < kl; k++)uvsCopy.push(uvs2[k].clone());
                this.faceVertexUvs[i1].push(uvsCopy);
            }
        }
    },
    mergeMesh: function(mesh) {
        if (!(mesh && mesh.isMesh)) {
            console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
            return;
        }
        if (mesh.matrixAutoUpdate) mesh.updateMatrix();
        this.merge(mesh.geometry, mesh.matrix);
    },
    /*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */
    mergeVertices: function() {
        const verticesMap = {
        }; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
        const unique = [], changes = [];
        const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
        const precision = Math.pow(10, precisionPoints);
        for(let i1 = 0, il = this.vertices.length; i1 < il; i1++){
            const v = this.vertices[i1];
            const key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);
            if (verticesMap[key] === undefined) {
                verticesMap[key] = i1;
                unique.push(this.vertices[i1]);
                changes[i1] = unique.length - 1;
            } else //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
            changes[i1] = changes[verticesMap[key]];
        }
        // if faces are completely degenerate after merging vertices, we
        // have to remove them from the geometry.
        const faceIndicesToRemove = [];
        for(let i1 = 0, il = this.faces.length; i1 < il; i1++){
            const face = this.faces[i1];
            face.a = changes[face.a];
            face.b = changes[face.b];
            face.c = changes[face.c];
            const indices2 = [
                face.a,
                face.b,
                face.c
            ];
            // if any duplicate vertices are found in a Face3
            // we have to remove the face as nothing can be saved
            for(let n = 0; n < 3; n++)if (indices2[n] === indices2[(n + 1) % 3]) {
                faceIndicesToRemove.push(i1);
                break;
            }
        }
        for(let i1 = faceIndicesToRemove.length - 1; i1 >= 0; i1--){
            const idx = faceIndicesToRemove[i1];
            this.faces.splice(idx, 1);
            for(let j = 0, jl = this.faceVertexUvs.length; j < jl; j++)this.faceVertexUvs[j].splice(idx, 1);
        }
        // Use unique set of vertices
        const diff = this.vertices.length - unique.length;
        this.vertices = unique;
        return diff;
    },
    setFromPoints: function(points) {
        this.vertices = [];
        for(let i1 = 0, l = points.length; i1 < l; i1++){
            const point = points[i1];
            this.vertices.push(new Vector31(point.x, point.y, point.z || 0));
        }
        return this;
    },
    sortFacesByMaterialIndex: function() {
        const faces = this.faces;
        const length = faces.length;
        // tag faces
        for(let i1 = 0; i1 < length; i1++)faces[i1]._id = i1;
        // sort faces
        function materialIndexSort(a2, b2) {
            return a2.materialIndex - b2.materialIndex;
        }
        faces.sort(materialIndexSort);
        // sort uvs
        const uvs11 = this.faceVertexUvs[0];
        const uvs2 = this.faceVertexUvs[1];
        let newUvs1, newUvs2;
        if (uvs11 && uvs11.length === length) newUvs1 = [];
        if (uvs2 && uvs2.length === length) newUvs2 = [];
        for(let i1 = 0; i1 < length; i1++){
            const id = faces[i1]._id;
            if (newUvs1) newUvs1.push(uvs11[id]);
            if (newUvs2) newUvs2.push(uvs2[id]);
        }
        if (newUvs1) this.faceVertexUvs[0] = newUvs1;
        if (newUvs2) this.faceVertexUvs[1] = newUvs2;
    },
    toJSON: function() {
        const data = {
            metadata: {
                version: 4.5,
                type: 'Geometry',
                generator: 'Geometry.toJSON'
            }
        };
        // standard Geometry serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '') data.name = this.name;
        if (this.parameters !== undefined) {
            const parameters = this.parameters;
            for(const key in parameters)if (parameters[key] !== undefined) data[key] = parameters[key];
            return data;
        }
        const vertices2 = [];
        for(let i1 = 0; i1 < this.vertices.length; i1++){
            const vertex = this.vertices[i1];
            vertices2.push(vertex.x, vertex.y, vertex.z);
        }
        const faces = [];
        const normals2 = [];
        const normalsHash = {
        };
        const colors = [];
        const colorsHash = {
        };
        const uvs2 = [];
        const uvsHash = {
        };
        for(let i1 = 0; i1 < this.faces.length; i1++){
            const face = this.faces[i1];
            const hasMaterial = true;
            const hasFaceUv = false; // deprecated
            const hasFaceVertexUv = this.faceVertexUvs[0][i1] !== undefined;
            const hasFaceNormal = face.normal.length() > 0;
            const hasFaceVertexNormal = face.vertexNormals.length > 0;
            const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
            const hasFaceVertexColor = face.vertexColors.length > 0;
            let faceType = 0;
            faceType = setBit(faceType, 0, 0); // isQuad
            faceType = setBit(faceType, 1, hasMaterial);
            faceType = setBit(faceType, 2, hasFaceUv);
            faceType = setBit(faceType, 3, hasFaceVertexUv);
            faceType = setBit(faceType, 4, hasFaceNormal);
            faceType = setBit(faceType, 5, hasFaceVertexNormal);
            faceType = setBit(faceType, 6, hasFaceColor);
            faceType = setBit(faceType, 7, hasFaceVertexColor);
            faces.push(faceType);
            faces.push(face.a, face.b, face.c);
            faces.push(face.materialIndex);
            if (hasFaceVertexUv) {
                const faceVertexUvs = this.faceVertexUvs[0][i1];
                faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
            }
            if (hasFaceNormal) faces.push(getNormalIndex(face.normal));
            if (hasFaceVertexNormal) {
                const vertexNormals = face.vertexNormals;
                faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
            }
            if (hasFaceColor) faces.push(getColorIndex(face.color));
            if (hasFaceVertexColor) {
                const vertexColors = face.vertexColors;
                faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
            }
        }
        function setBit(value, position, enabled) {
            return enabled ? value | 1 << position : value & ~(1 << position);
        }
        function getNormalIndex(normal2) {
            const hash = normal2.x.toString() + normal2.y.toString() + normal2.z.toString();
            if (normalsHash[hash] !== undefined) return normalsHash[hash];
            normalsHash[hash] = normals2.length / 3;
            normals2.push(normal2.x, normal2.y, normal2.z);
            return normalsHash[hash];
        }
        function getColorIndex(color1) {
            const hash = color1.r.toString() + color1.g.toString() + color1.b.toString();
            if (colorsHash[hash] !== undefined) return colorsHash[hash];
            colorsHash[hash] = colors.length;
            colors.push(color1.getHex());
            return colorsHash[hash];
        }
        function getUvIndex(uv) {
            const hash = uv.x.toString() + uv.y.toString();
            if (uvsHash[hash] !== undefined) return uvsHash[hash];
            uvsHash[hash] = uvs2.length / 2;
            uvs2.push(uv.x, uv.y);
            return uvsHash[hash];
        }
        data.data = {
        };
        data.data.vertices = vertices2;
        data.data.normals = normals2;
        if (colors.length > 0) data.data.colors = colors;
        if (uvs2.length > 0) data.data.uvs = [
            uvs2
        ]; // temporal backward compatibility
        data.data.faces = faces;
        return data;
    },
    clone: function() {
        /*
		 // Handle primitives

		 const parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 const values = [];

		 for ( const key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 const geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */
        return new Geometry().copy(this);
    },
    copy: function(source) {
        // reset
        this.vertices = [];
        this.colors = [];
        this.faces = [];
        this.faceVertexUvs = [
            []
        ];
        this.morphTargets = [];
        this.morphNormals = [];
        this.skinWeights = [];
        this.skinIndices = [];
        this.lineDistances = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        // name
        this.name = source.name;
        // vertices
        const vertices2 = source.vertices;
        for(let i1 = 0, il = vertices2.length; i1 < il; i1++)this.vertices.push(vertices2[i1].clone());
        // colors
        const colors = source.colors;
        for(let i1 = 0, il = colors.length; i1 < il; i1++)this.colors.push(colors[i1].clone());
        // faces
        const faces = source.faces;
        for(let i1 = 0, il = faces.length; i1 < il; i1++)this.faces.push(faces[i1].clone());
        // face vertex uvs
        for(let i1 = 0, il = source.faceVertexUvs.length; i1 < il; i1++){
            const faceVertexUvs = source.faceVertexUvs[i1];
            if (this.faceVertexUvs[i1] === undefined) this.faceVertexUvs[i1] = [];
            for(let j = 0, jl = faceVertexUvs.length; j < jl; j++){
                const uvs2 = faceVertexUvs[j], uvsCopy = [];
                for(let k = 0, kl = uvs2.length; k < kl; k++){
                    const uv = uvs2[k];
                    uvsCopy.push(uv.clone());
                }
                this.faceVertexUvs[i1].push(uvsCopy);
            }
        }
        // morph targets
        const morphTargets = source.morphTargets;
        for(let i1 = 0, il = morphTargets.length; i1 < il; i1++){
            const morphTarget = {
            };
            morphTarget.name = morphTargets[i1].name;
            // vertices
            if (morphTargets[i1].vertices !== undefined) {
                morphTarget.vertices = [];
                for(let j = 0, jl = morphTargets[i1].vertices.length; j < jl; j++)morphTarget.vertices.push(morphTargets[i1].vertices[j].clone());
            }
            // normals
            if (morphTargets[i1].normals !== undefined) {
                morphTarget.normals = [];
                for(let j = 0, jl = morphTargets[i1].normals.length; j < jl; j++)morphTarget.normals.push(morphTargets[i1].normals[j].clone());
            }
            this.morphTargets.push(morphTarget);
        }
        // morph normals
        const morphNormals = source.morphNormals;
        for(let i1 = 0, il = morphNormals.length; i1 < il; i1++){
            const morphNormal = {
            };
            // vertex normals
            if (morphNormals[i1].vertexNormals !== undefined) {
                morphNormal.vertexNormals = [];
                for(let j = 0, jl = morphNormals[i1].vertexNormals.length; j < jl; j++){
                    const srcVertexNormal = morphNormals[i1].vertexNormals[j];
                    const destVertexNormal = {
                    };
                    destVertexNormal.a = srcVertexNormal.a.clone();
                    destVertexNormal.b = srcVertexNormal.b.clone();
                    destVertexNormal.c = srcVertexNormal.c.clone();
                    morphNormal.vertexNormals.push(destVertexNormal);
                }
            }
            // face normals
            if (morphNormals[i1].faceNormals !== undefined) {
                morphNormal.faceNormals = [];
                for(let j = 0, jl = morphNormals[i1].faceNormals.length; j < jl; j++)morphNormal.faceNormals.push(morphNormals[i1].faceNormals[j].clone());
            }
            this.morphNormals.push(morphNormal);
        }
        // skin weights
        const skinWeights = source.skinWeights;
        for(let i1 = 0, il = skinWeights.length; i1 < il; i1++)this.skinWeights.push(skinWeights[i1].clone());
        // skin indices
        const skinIndices = source.skinIndices;
        for(let i1 = 0, il = skinIndices.length; i1 < il; i1++)this.skinIndices.push(skinIndices[i1].clone());
        // line distances
        const lineDistances = source.lineDistances;
        for(let i1 = 0, il = lineDistances.length; i1 < il; i1++)this.lineDistances.push(lineDistances[i1]);
        // bounding box
        const boundingBox = source.boundingBox;
        if (boundingBox !== null) this.boundingBox = boundingBox.clone();
        // bounding sphere
        const boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) this.boundingSphere = boundingSphere.clone();
        // update flags
        this.elementsNeedUpdate = source.elementsNeedUpdate;
        this.verticesNeedUpdate = source.verticesNeedUpdate;
        this.uvsNeedUpdate = source.uvsNeedUpdate;
        this.normalsNeedUpdate = source.normalsNeedUpdate;
        this.colorsNeedUpdate = source.colorsNeedUpdate;
        this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
        this.groupsNeedUpdate = source.groupsNeedUpdate;
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
});
const Geometry1 = Geometry;
/**
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
 */
// ParametricGeometry
function ParametricGeometry(func, slices, stacks) {
    Geometry1.call(this);
    this.type = 'ParametricGeometry';
    this.parameters = {
        func: func,
        slices: slices,
        stacks: stacks
    };
    this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
    this.mergeVertices();
}
ParametricGeometry.prototype = Object.create(Geometry1.prototype);
ParametricGeometry.prototype.constructor = ParametricGeometry;
// ParametricBufferGeometry
function ParametricBufferGeometry(func, slices, stacks) {
    BufferGeometry1.call(this);
    this.type = 'ParametricBufferGeometry';
    this.parameters = {
        func: func,
        slices: slices,
        stacks: stacks
    };
    // buffers
    const indices2 = [];
    const vertices2 = [];
    const normals2 = [];
    const uvs2 = [];
    const EPS = 0.00001;
    const normal2 = new Vector31();
    const p0 = new Vector31(), p1 = new Vector31();
    const pu = new Vector31(), pv = new Vector31();
    if (func.length < 3) console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');
    // generate vertices, normals and uvs
    const sliceCount = slices + 1;
    for(let i1 = 0; i1 <= stacks; i1++){
        const v = i1 / stacks;
        for(let j = 0; j <= slices; j++){
            const u = j / slices;
            // vertex
            func(u, v, p0);
            vertices2.push(p0.x, p0.y, p0.z);
            // normal
            // approximate tangent vectors via finite differences
            if (u - EPS >= 0) {
                func(u - EPS, v, p1);
                pu.subVectors(p0, p1);
            } else {
                func(u + EPS, v, p1);
                pu.subVectors(p1, p0);
            }
            if (v - EPS >= 0) {
                func(u, v - EPS, p1);
                pv.subVectors(p0, p1);
            } else {
                func(u, v + EPS, p1);
                pv.subVectors(p1, p0);
            }
            // cross product of tangent vectors returns surface normal
            normal2.crossVectors(pu, pv).normalize();
            normals2.push(normal2.x, normal2.y, normal2.z);
            // uv
            uvs2.push(u, v);
        }
    }
    // generate indices
    for(let i1 = 0; i1 < stacks; i1++)for(let j = 0; j < slices; j++){
        const a2 = i1 * sliceCount + j;
        const b2 = i1 * sliceCount + j + 1;
        const c2 = (i1 + 1) * sliceCount + j + 1;
        const d = (i1 + 1) * sliceCount + j;
        // faces one and two
        indices2.push(a2, b2, d);
        indices2.push(b2, c2, d);
    }
    // build geometry
    this.setIndex(indices2);
    this.setAttribute('position', new Float32BufferAttribute1(vertices2, 3));
    this.setAttribute('normal', new Float32BufferAttribute1(normals2, 3));
    this.setAttribute('uv', new Float32BufferAttribute1(uvs2, 2));
}
ParametricBufferGeometry.prototype = Object.create(BufferGeometry1.prototype);
ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
// PolyhedronBufferGeometry
class PolyhedronBufferGeometry2 extends BufferGeometry1 {
    constructor(vertices2, indices2, radius11, detail){
        super();
        this.type = 'PolyhedronBufferGeometry';
        this.parameters = {
            vertices: vertices2,
            indices: indices2,
            radius: radius11,
            detail: detail
        };
        radius11 = radius11 || 1;
        detail = detail || 0;
        // default buffer data
        const vertexBuffer = [];
        const uvBuffer = [];
        // the subdivision creates the vertex buffer data
        subdivide(detail);
        // all vertices should lie on a conceptual sphere with a given radius
        applyRadius(radius11);
        // finally, create the uv data
        generateUVs1();
        // build non-indexed geometry
        this.setAttribute('position', new Float32BufferAttribute1(vertexBuffer, 3));
        this.setAttribute('normal', new Float32BufferAttribute1(vertexBuffer.slice(), 3));
        this.setAttribute('uv', new Float32BufferAttribute1(uvBuffer, 2));
        if (detail === 0) this.computeVertexNormals(); // flat normals
        else this.normalizeNormals(); // smooth normals
        // helper functions
        function subdivide(detail1) {
            const a2 = new Vector31();
            const b2 = new Vector31();
            const c2 = new Vector31();
            // iterate over all faces and apply a subdivison with the given detail value
            for(let i1 = 0; i1 < indices2.length; i1 += 3){
                // get the vertices of the face
                getVertexByIndex(indices2[i1 + 0], a2);
                getVertexByIndex(indices2[i1 + 1], b2);
                getVertexByIndex(indices2[i1 + 2], c2);
                // perform subdivision
                subdivideFace(a2, b2, c2, detail1);
            }
        }
        function subdivideFace(a2, b2, c2, detail1) {
            const cols = Math.pow(2, detail1);
            // we use this multidimensional array as a data structure for creating the subdivision
            const v = [];
            // construct all of the vertices for this subdivision
            for(let i1 = 0; i1 <= cols; i1++){
                v[i1] = [];
                const aj = a2.clone().lerp(c2, i1 / cols);
                const bj = b2.clone().lerp(c2, i1 / cols);
                const rows = cols - i1;
                for(let j = 0; j <= rows; j++)if (j === 0 && i1 === cols) v[i1][j] = aj;
                else v[i1][j] = aj.clone().lerp(bj, j / rows);
            }
            // construct all of the faces
            for(let i1 = 0; i1 < cols; i1++)for(let j = 0; j < 2 * (cols - i1) - 1; j++){
                const k = Math.floor(j / 2);
                if (j % 2 === 0) {
                    pushVertex(v[i1][k + 1]);
                    pushVertex(v[i1 + 1][k]);
                    pushVertex(v[i1][k]);
                } else {
                    pushVertex(v[i1][k + 1]);
                    pushVertex(v[i1 + 1][k + 1]);
                    pushVertex(v[i1 + 1][k]);
                }
            }
        }
        function applyRadius(radius1) {
            const vertex = new Vector31();
            // iterate over the entire buffer and apply the radius to each vertex
            for(let i1 = 0; i1 < vertexBuffer.length; i1 += 3){
                vertex.x = vertexBuffer[i1 + 0];
                vertex.y = vertexBuffer[i1 + 1];
                vertex.z = vertexBuffer[i1 + 2];
                vertex.normalize().multiplyScalar(radius1);
                vertexBuffer[i1 + 0] = vertex.x;
                vertexBuffer[i1 + 1] = vertex.y;
                vertexBuffer[i1 + 2] = vertex.z;
            }
        }
        function generateUVs1() {
            const vertex = new Vector31();
            for(let i1 = 0; i1 < vertexBuffer.length; i1 += 3){
                vertex.x = vertexBuffer[i1 + 0];
                vertex.y = vertexBuffer[i1 + 1];
                vertex.z = vertexBuffer[i1 + 2];
                const u = azimuth(vertex) / 2 / Math.PI + 0.5;
                const v = inclination(vertex) / Math.PI + 0.5;
                uvBuffer.push(u, 1 - v);
            }
            correctUVs();
            correctSeam();
        }
        function correctSeam() {
            // handle case when face straddles the seam, see #3269
            for(let i1 = 0; i1 < uvBuffer.length; i1 += 6){
                // uv data of a single face
                const x0 = uvBuffer[i1 + 0];
                const x11 = uvBuffer[i1 + 2];
                const x21 = uvBuffer[i1 + 4];
                const max = Math.max(x0, x11, x21);
                const min = Math.min(x0, x11, x21);
                // 0.9 is somewhat arbitrary
                if (max > 0.9 && min < 0.1) {
                    if (x0 < 0.2) uvBuffer[i1 + 0] += 1;
                    if (x11 < 0.2) uvBuffer[i1 + 2] += 1;
                    if (x21 < 0.2) uvBuffer[i1 + 4] += 1;
                }
            }
        }
        function pushVertex(vertex) {
            vertexBuffer.push(vertex.x, vertex.y, vertex.z);
        }
        function getVertexByIndex(index, vertex) {
            const stride = index * 3;
            vertex.x = vertices2[stride + 0];
            vertex.y = vertices2[stride + 1];
            vertex.z = vertices2[stride + 2];
        }
        function correctUVs() {
            const a2 = new Vector31();
            const b2 = new Vector31();
            const c2 = new Vector31();
            const centroid = new Vector31();
            const uvA = new Vector21();
            const uvB = new Vector21();
            const uvC = new Vector21();
            for(let i1 = 0, j = 0; i1 < vertexBuffer.length; i1 += 9, j += 6){
                a2.set(vertexBuffer[i1 + 0], vertexBuffer[i1 + 1], vertexBuffer[i1 + 2]);
                b2.set(vertexBuffer[i1 + 3], vertexBuffer[i1 + 4], vertexBuffer[i1 + 5]);
                c2.set(vertexBuffer[i1 + 6], vertexBuffer[i1 + 7], vertexBuffer[i1 + 8]);
                uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
                uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
                uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
                centroid.copy(a2).add(b2).add(c2).divideScalar(3);
                const azi = azimuth(centroid);
                correctUV(uvA, j + 0, a2, azi);
                correctUV(uvB, j + 2, b2, azi);
                correctUV(uvC, j + 4, c2, azi);
            }
        }
        function correctUV(uv, stride, vector, azimuth) {
            if (azimuth < 0 && uv.x === 1) uvBuffer[stride] = uv.x - 1;
            if (vector.x === 0 && vector.z === 0) uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
        }
        // Angle around the Y axis, counter-clockwise when looking from above.
        function azimuth(vector) {
            return Math.atan2(vector.z, -vector.x);
        }
        // Angle above the XZ plane.
        function inclination(vector) {
            return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
        }
    }
}
const PolyhedronBufferGeometry1 = PolyhedronBufferGeometry2;
/**
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */
const Earcut = {
    triangulate: function(data, holeIndices, dim) {
        dim = dim || 2;
        const hasHoles = holeIndices && holeIndices.length;
        const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        let outerNode = linkedList(data, 0, outerLen, dim, true);
        const triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev) return triangles;
        let minX, minY, maxX, maxY, x6, y6, invSize;
        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for(let i3 = dim; i3 < outerLen; i3 += dim){
                x6 = data[i3];
                y6 = data[i3 + 1];
                if (x6 < minX) minX = x6;
                if (y6 < minY) minY = y6;
                if (x6 > maxX) maxX = x6;
                if (y6 > maxY) maxY = y6;
            }
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
    }
};
// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    let i3, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) for(i3 = start; i3 < end; i3 += dim)last = insertNode(i3, data[i3], data[i3 + 1], last);
    else for(i3 = end - dim; i3 >= start; i3 -= dim)last = insertNode(i3, data[i3], data[i3 + 1], last);
    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }
    return last;
}
// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    let p1 = start, again;
    do {
        if (!p1.steiner && (equals(p1, p1.next) || area(p1.prev, p1, p1.next) === 0)) {
            removeNode(p1);
            p1 = end = p1.prev;
            if (p1 === p1.next) break;
        } else p1 = p1.next;
    }while (again || p1 !== end)
    return end;
}
// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;
    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    let stop = ear, prev, next;
    // iterate through ears, slicing them one by one
    while(ear.prev !== ear.next){
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear);
            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) splitEarcut(ear, triangles, dim, minX, minY, invSize);
            break;
        }
    }
}
// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    const a2 = ear.prev, b2 = ear, c2 = ear.next;
    if (area(a2, b2, c2) >= 0) return false; // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear
    let p1 = ear.next.next;
    while(p1 !== ear.prev){
        if (pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p1.x, p1.y) && area(p1.prev, p1, p1.next) >= 0) return false;
        p1 = p1.next;
    }
    return true;
}
function isEarHashed(ear, minX, minY, invSize) {
    const a2 = ear.prev, b2 = ear, c2 = ear.next;
    if (area(a2, b2, c2) >= 0) return false; // reflex, can't be an ear
    // triangle bbox; min & max are calculated like this for speed
    const minTX = a2.x < b2.x ? a2.x < c2.x ? a2.x : c2.x : b2.x < c2.x ? b2.x : c2.x, minTY = a2.y < b2.y ? a2.y < c2.y ? a2.y : c2.y : b2.y < c2.y ? b2.y : c2.y, maxTX = a2.x > b2.x ? a2.x > c2.x ? a2.x : c2.x : b2.x > c2.x ? b2.x : c2.x, maxTY = a2.y > b2.y ? a2.y > c2.y ? a2.y : c2.y : b2.y > c2.y ? b2.y : c2.y;
    // z-order range for the current triangle bbox;
    const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    let p1 = ear.prevZ, n = ear.nextZ;
    // look for points inside the triangle in both directions
    while(p1 && p1.z >= minZ && n && n.z <= maxZ){
        if (p1 !== ear.prev && p1 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p1.x, p1.y) && area(p1.prev, p1, p1.next) >= 0) return false;
        p1 = p1.prevZ;
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    // look for remaining points in decreasing z-order
    while(p1 && p1.z >= minZ){
        if (p1 !== ear.prev && p1 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p1.x, p1.y) && area(p1.prev, p1, p1.next) >= 0) return false;
        p1 = p1.prevZ;
    }
    // look for remaining points in increasing z-order
    while(n && n.z <= maxZ){
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    return true;
}
// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    let p1 = start;
    do {
        const a2 = p1.prev, b2 = p1.next.next;
        if (!equals(a2, b2) && intersects(a2, p1, p1.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
            triangles.push(a2.i / dim);
            triangles.push(p1.i / dim);
            triangles.push(b2.i / dim);
            // remove two nodes involved
            removeNode(p1);
            removeNode(p1.next);
            p1 = start = b2;
        }
        p1 = p1.next;
    }while (p1 !== start)
    return filterPoints(p1);
}
// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    let a2 = start;
    do {
        let b2 = a2.next.next;
        while(b2 !== a2.prev){
            if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
                // split the polygon in two by the diagonal
                let c2 = splitPolygon(a2, b2);
                // filter colinear points around the cuts
                a2 = filterPoints(a2, a2.next);
                c2 = filterPoints(c2, c2.next);
                // run earcut on each half
                earcutLinked(a2, triangles, dim, minX, minY, invSize);
                earcutLinked(c2, triangles, dim, minX, minY, invSize);
                return;
            }
            b2 = b2.next;
        }
        a2 = a2.next;
    }while (a2 !== start)
}
// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    const queue = [];
    let i3, len, start, end, list;
    for(i3 = 0, len = holeIndices.length; i3 < len; i3++){
        start = holeIndices[i3] * dim;
        end = i3 < len - 1 ? holeIndices[i3 + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    // process holes from left to right
    for(i3 = 0; i3 < queue.length; i3++){
        eliminateHole(queue[i3], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
}
function compareX(a2, b2) {
    return a2.x - b2.x;
}
// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        const b2 = splitPolygon(outerNode, hole);
        // filter collinear points around the cuts
        filterPoints(outerNode, outerNode.next);
        filterPoints(b2, b2.next);
    }
}
// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    let p1 = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity, m;
    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p1.y && hy >= p1.next.y && p1.next.y !== p1.y) {
            const x6 = p1.x + (hy - p1.y) * (p1.next.x - p1.x) / (p1.next.y - p1.y);
            if (x6 <= hx && x6 > qx) {
                qx = x6;
                if (x6 === hx) {
                    if (hy === p1.y) return p1;
                    if (hy === p1.next.y) return p1.next;
                }
                m = p1.x < p1.next.x ? p1 : p1.next;
            }
        }
        p1 = p1.next;
    }while (p1 !== outerNode)
    if (!m) return null;
    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point
    const stop = m, mx = m.x, my = m.y;
    let tanMin = Infinity, tan;
    p1 = m;
    do {
        if (hx >= p1.x && p1.x >= mx && hx !== p1.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p1.x, p1.y)) {
            tan = Math.abs(hy - p1.y) / (hx - p1.x); // tangential
            if (locallyInside(p1, hole) && (tan < tanMin || tan === tanMin && (p1.x > m.x || p1.x === m.x && sectorContainsSector(m, p1)))) {
                m = p1;
                tanMin = tan;
            }
        }
        p1 = p1.next;
    }while (p1 !== stop)
    return m;
}
// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector(m, p1) {
    return area(m.prev, m, p1.prev) < 0 && area(p1.next, m, m.next) < 0;
}
// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    let p1 = start;
    do {
        if (p1.z === null) p1.z = zOrder(p1.x, p1.y, minX, minY, invSize);
        p1.prevZ = p1.prev;
        p1.nextZ = p1.next;
        p1 = p1.next;
    }while (p1 !== start)
    p1.prevZ.nextZ = null;
    p1.prevZ = null;
    sortLinked(p1);
}
// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    let i3, p1, q1, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
        p1 = list;
        list = null;
        tail = null;
        numMerges = 0;
        while(p1){
            numMerges++;
            q1 = p1;
            pSize = 0;
            for(i3 = 0; i3 < inSize; i3++){
                pSize++;
                q1 = q1.nextZ;
                if (!q1) break;
            }
            qSize = inSize;
            while(pSize > 0 || qSize > 0 && q1){
                if (pSize !== 0 && (qSize === 0 || !q1 || p1.z <= q1.z)) {
                    e = p1;
                    p1 = p1.nextZ;
                    pSize--;
                } else {
                    e = q1;
                    q1 = q1.nextZ;
                    qSize--;
                }
                if (tail) tail.nextZ = e;
                else list = e;
                e.prevZ = tail;
                tail = e;
            }
            p1 = q1;
        }
        tail.nextZ = null;
        inSize *= 2;
    }while (numMerges > 1)
    return list;
}
// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x6, y6, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x6 = 32767 * (x6 - minX) * invSize;
    y6 = 32767 * (y6 - minY) * invSize;
    x6 = (x6 | x6 << 8) & 16711935;
    x6 = (x6 | x6 << 4) & 252645135;
    x6 = (x6 | x6 << 2) & 858993459;
    x6 = (x6 | x6 << 1) & 1431655765;
    y6 = (y6 | y6 << 8) & 16711935;
    y6 = (y6 | y6 << 4) & 252645135;
    y6 = (y6 | y6 << 2) & 858993459;
    y6 = (y6 | y6 << 1) & 1431655765;
    return x6 | y6 << 1;
}
// find the leftmost node of a polygon ring
function getLeftmost(start) {
    let p1 = start, leftmost = start;
    do {
        if (p1.x < leftmost.x || p1.x === leftmost.x && p1.y < leftmost.y) leftmost = p1;
        p1 = p1.next;
    }while (p1 !== start)
    return leftmost;
}
// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}
// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a2, b2) {
    return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0); // special zero-length case
}
// signed area of a triangle
function area(p1, q1, r1) {
    return (q1.y - p1.y) * (r1.x - q1.x) - (q1.x - p1.x) * (r1.y - q1.y);
}
// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}
// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    const o1 = sign(area(p1, q1, p2));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p2, q2, p1));
    const o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true; // general case
    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2
    return false;
}
// for collinear points p, q, r, check if point q lies on segment pr
function onSegment(p1, q1, r1) {
    return q1.x <= Math.max(p1.x, r1.x) && q1.x >= Math.min(p1.x, r1.x) && q1.y <= Math.max(p1.y, r1.y) && q1.y >= Math.min(p1.y, r1.y);
}
function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}
// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a2, b2) {
    let p1 = a2;
    do {
        if (p1.i !== a2.i && p1.next.i !== a2.i && p1.i !== b2.i && p1.next.i !== b2.i && intersects(p1, p1.next, a2, b2)) return true;
        p1 = p1.next;
    }while (p1 !== a2)
    return false;
}
// check if a polygon diagonal is locally inside the polygon
function locallyInside(a2, b2) {
    return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
}
// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a2, b2) {
    let p1 = a2, inside = false;
    const px = (a2.x + b2.x) / 2, py = (a2.y + b2.y) / 2;
    do {
        if (p1.y > py !== p1.next.y > py && p1.next.y !== p1.y && px < (p1.next.x - p1.x) * (py - p1.y) / (p1.next.y - p1.y) + p1.x) inside = !inside;
        p1 = p1.next;
    }while (p1 !== a2)
    return inside;
}
// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a2, b2) {
    const a2 = new Node1(a2.i, a2.x, a2.y), b2 = new Node1(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
    a2.next = b2;
    b2.prev = a2;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
}
// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i3, x6, y6, last) {
    const p1 = new Node1(i3, x6, y6);
    if (!last) {
        p1.prev = p1;
        p1.next = p1;
    } else {
        p1.next = last.next;
        p1.prev = last;
        last.next.prev = p1;
        last.next = p1;
    }
    return p1;
}
function removeNode(p1) {
    p1.next.prev = p1.prev;
    p1.prev.next = p1.next;
    if (p1.prevZ) p1.prevZ.nextZ = p1.nextZ;
    if (p1.nextZ) p1.nextZ.prevZ = p1.prevZ;
}
function Node1(i3, x6, y6) {
    // vertex index in coordinates array
    this.i = i3;
    // vertex coordinates
    this.x = x6;
    this.y = y6;
    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;
    // z-order curve value
    this.z = null;
    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;
    // indicates whether this is a steiner point
    this.steiner = false;
}
function signedArea(data, start, end, dim) {
    let sum = 0;
    for(let i3 = start, j2 = end - dim; i3 < end; i3 += dim){
        sum += (data[j2] - data[i3]) * (data[i3 + 1] + data[j2 + 1]);
        j2 = i3;
    }
    return sum;
}
const Earcut1 = Earcut;
const ShapeUtils = {
    // calculate area of the contour polygon
    area: function(contour) {
        const n = contour.length;
        let a2 = 0;
        for(let p1 = n - 1, q1 = 0; q1 < n; p1 = q1++)a2 += contour[p1].x * contour[q1].y - contour[q1].x * contour[p1].y;
        return a2 * 0.5;
    },
    isClockWise: function(pts) {
        return ShapeUtils.area(pts) < 0;
    },
    triangulateShape: function(contour, holes) {
        const vertices10 = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
        const holeIndices = []; // array of hole indices
        const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
        removeDupEndPts(contour);
        addContour(vertices10, contour);
        //
        let holeIndex = contour.length;
        holes.forEach(removeDupEndPts);
        for(let i3 = 0; i3 < holes.length; i3++){
            holeIndices.push(holeIndex);
            holeIndex += holes[i3].length;
            addContour(vertices10, holes[i3]);
        }
        //
        const triangles = Earcut1.triangulate(vertices10, holeIndices);
        //
        for(let i3 = 0; i3 < triangles.length; i3 += 3)faces.push(triangles.slice(i3, i3 + 3));
        return faces;
    }
};
function removeDupEndPts(points) {
    const l = points.length;
    if (l > 2 && points[l - 1].equals(points[0])) points.pop();
}
function addContour(vertices10, contour) {
    for(let i3 = 0; i3 < contour.length; i3++){
        vertices10.push(contour[i3].x);
        vertices10.push(contour[i3].y);
    }
}
const ShapeUtils1 = ShapeUtils;
const WorldUVGenerator = {
    generateTopUV: function(geometry, vertices10, indexA, indexB, indexC) {
        const a_x = vertices10[indexA * 3];
        const a_y = vertices10[indexA * 3 + 1];
        const b_x = vertices10[indexB * 3];
        const b_y = vertices10[indexB * 3 + 1];
        const c_x = vertices10[indexC * 3];
        const c_y = vertices10[indexC * 3 + 1];
        return [
            new Vector21(a_x, a_y),
            new Vector21(b_x, b_y),
            new Vector21(c_x, c_y)
        ];
    },
    generateSideWallUV: function(geometry, vertices10, indexA, indexB, indexC, indexD) {
        const a_x = vertices10[indexA * 3];
        const a_y = vertices10[indexA * 3 + 1];
        const a_z = vertices10[indexA * 3 + 2];
        const b_x = vertices10[indexB * 3];
        const b_y = vertices10[indexB * 3 + 1];
        const b_z = vertices10[indexB * 3 + 2];
        const c_x = vertices10[indexC * 3];
        const c_y = vertices10[indexC * 3 + 1];
        const c_z = vertices10[indexC * 3 + 2];
        const d_x = vertices10[indexD * 3];
        const d_y = vertices10[indexD * 3 + 1];
        const d_z = vertices10[indexD * 3 + 2];
        if (Math.abs(a_y - b_y) < 0.01) return [
            new Vector21(a_x, 1 - a_z),
            new Vector21(b_x, 1 - b_z),
            new Vector21(c_x, 1 - c_z),
            new Vector21(d_x, 1 - d_z)
        ];
        else return [
            new Vector21(a_y, 1 - a_z),
            new Vector21(b_y, 1 - b_z),
            new Vector21(c_y, 1 - c_z),
            new Vector21(d_y, 1 - d_z)
        ];
    }
};
function toJSON1(shapes1, options1, data) {
    data.shapes = [];
    if (Array.isArray(shapes1)) for(let i12 = 0, l1 = shapes1.length; i12 < l1; i12++){
        const shape = shapes1[i12];
        data.shapes.push(shape.uuid);
    }
    else data.shapes.push(shapes1.uuid);
    if (options1.extrudePath !== undefined) data.options.extrudePath = options1.extrudePath.toJSON();
    return data;
}
//
function toJSON2(shapes11, data) {
    data.shapes = [];
    if (Array.isArray(shapes11)) for(let i12 = 0, l1 = shapes11.length; i12 < l1; i12++){
        const shape = shapes11[i12];
        data.shapes.push(shape.uuid);
    }
    else data.shapes.push(shapes11.uuid);
    return data;
}
const WorldUVGenerator = {
    generateTopUV: function(geometry, vertices15, indexA, indexB, indexC) {
        const a_x = vertices15[indexA * 3];
        const a_y = vertices15[indexA * 3 + 1];
        const b_x = vertices15[indexB * 3];
        const b_y = vertices15[indexB * 3 + 1];
        const c_x = vertices15[indexC * 3];
        const c_y = vertices15[indexC * 3 + 1];
        return [
            new Vector21(a_x, a_y),
            new Vector21(b_x, b_y),
            new Vector21(c_x, c_y)
        ];
    },
    generateSideWallUV: function(geometry, vertices15, indexA, indexB, indexC, indexD) {
        const a_x = vertices15[indexA * 3];
        const a_y = vertices15[indexA * 3 + 1];
        const a_z = vertices15[indexA * 3 + 2];
        const b_x = vertices15[indexB * 3];
        const b_y = vertices15[indexB * 3 + 1];
        const b_z = vertices15[indexB * 3 + 2];
        const c_x = vertices15[indexC * 3];
        const c_y = vertices15[indexC * 3 + 1];
        const c_z = vertices15[indexC * 3 + 2];
        const d_x = vertices15[indexD * 3];
        const d_y = vertices15[indexD * 3 + 1];
        const d_z = vertices15[indexD * 3 + 2];
        if (Math.abs(a_y - b_y) < 0.01) return [
            new Vector21(a_x, 1 - a_z),
            new Vector21(b_x, 1 - b_z),
            new Vector21(c_x, 1 - c_z),
            new Vector21(d_x, 1 - d_z)
        ];
        else return [
            new Vector21(a_y, 1 - a_z),
            new Vector21(b_y, 1 - b_z),
            new Vector21(c_y, 1 - c_z),
            new Vector21(d_y, 1 - d_z)
        ];
    }
};
function toJSON1(shapes11, options1, data) {
    data.shapes = [];
    if (Array.isArray(shapes11)) for(let i12 = 0, l1 = shapes11.length; i12 < l1; i12++){
        const shape = shapes11[i12];
        data.shapes.push(shape.uuid);
    }
    else data.shapes.push(shapes11.uuid);
    if (options1.extrudePath !== undefined) data.options.extrudePath = options1.extrudePath.toJSON();
    return data;
}
// CylinderBufferGeometry
class CylinderBufferGeometry extends BufferGeometry1 {
    constructor(radiusTop, radiusBottom, height2, radialSegments3, heightSegments3, openEnded, thetaStart2, thetaLength2){
        super();
        this.type = 'CylinderBufferGeometry';
        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height2,
            radialSegments: radialSegments3,
            heightSegments: heightSegments3,
            openEnded: openEnded,
            thetaStart: thetaStart2,
            thetaLength: thetaLength2
        };
        const scope2 = this;
        radiusTop = radiusTop !== undefined ? radiusTop : 1;
        radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
        height2 = height2 || 1;
        radialSegments3 = Math.floor(radialSegments3) || 8;
        heightSegments3 = Math.floor(heightSegments3) || 1;
        openEnded = openEnded !== undefined ? openEnded : false;
        thetaStart2 = thetaStart2 !== undefined ? thetaStart2 : 0;
        thetaLength2 = thetaLength2 !== undefined ? thetaLength2 : Math.PI * 2;
        // buffers
        const indices15 = [];
        const vertices15 = [];
        const normals8 = [];
        const uvs9 = [];
        // helper variables
        let index1 = 0;
        const indexArray = [];
        const halfHeight = height2 / 2;
        let groupStart2 = 0;
        // generate geometry
        generateTorso();
        if (openEnded === false) {
            if (radiusTop > 0) generateCap(true);
            if (radiusBottom > 0) generateCap(false);
        }
        // build geometry
        this.setIndex(indices15);
        this.setAttribute('position', new Float32BufferAttribute1(vertices15, 3));
        this.setAttribute('normal', new Float32BufferAttribute1(normals8, 3));
        this.setAttribute('uv', new Float32BufferAttribute1(uvs9, 2));
        function generateTorso() {
            const normal6 = new Vector31();
            const vertex6 = new Vector31();
            let groupCount1 = 0;
            // this will be used to calculate the normal
            const slope = (radiusBottom - radiusTop) / height2;
            // generate vertices, normals and uvs
            for(let y6 = 0; y6 <= heightSegments3; y6++){
                const indexRow = [];
                const v = y6 / heightSegments3;
                // calculate the radius of the current row
                const radius10 = v * (radiusBottom - radiusTop) + radiusTop;
                for(let x6 = 0; x6 <= radialSegments3; x6++){
                    const u = x6 / radialSegments3;
                    const theta = u * thetaLength2 + thetaStart2;
                    const sinTheta = Math.sin(theta);
                    const cosTheta = Math.cos(theta);
                    // vertex
                    vertex6.x = radius10 * sinTheta;
                    vertex6.y = -v * height2 + halfHeight;
                    vertex6.z = radius10 * cosTheta;
                    vertices15.push(vertex6.x, vertex6.y, vertex6.z);
                    // normal
                    normal6.set(sinTheta, slope, cosTheta).normalize();
                    normals8.push(normal6.x, normal6.y, normal6.z);
                    // uv
                    uvs9.push(u, 1 - v);
                    // save index of vertex in respective row
                    indexRow.push(index1++);
                }
                // now save vertices of the row in our index array
                indexArray.push(indexRow);
            }
            // generate indices
            for(let x6 = 0; x6 < radialSegments3; x6++)for(let y6 = 0; y6 < heightSegments3; y6++){
                // we use the index array to access the correct indices
                const a2 = indexArray[y6][x6];
                const b2 = indexArray[y6 + 1][x6];
                const c2 = indexArray[y6 + 1][x6 + 1];
                const d = indexArray[y6][x6 + 1];
                // faces
                indices15.push(a2, b2, d);
                indices15.push(b2, c2, d);
                // update group counter
                groupCount1 += 6;
            }
            // add a group to the geometry. this will ensure multi material support
            scope2.addGroup(groupStart2, groupCount1, 0);
            // calculate new start value for groups
            groupStart2 += groupCount1;
        }
        function generateCap(top) {
            // save the index of the first center vertex
            const centerIndexStart = index1;
            const uv3 = new Vector21();
            const vertex6 = new Vector31();
            let groupCount1 = 0;
            const radius10 = top === true ? radiusTop : radiusBottom;
            const sign1 = top === true ? 1 : -1;
            // first we generate the center vertex data of the cap.
            // because the geometry needs one set of uvs per face,
            // we must generate a center vertex per face/segment
            for(let x6 = 1; x6 <= radialSegments3; x6++){
                // vertex
                vertices15.push(0, halfHeight * sign1, 0);
                // normal
                normals8.push(0, sign1, 0);
                // uv
                uvs9.push(0.5, 0.5);
                // increase index
                index1++;
            }
            // save the index of the last center vertex
            const centerIndexEnd = index1;
            // now we generate the surrounding vertices, normals and uvs
            for(let x6 = 0; x6 <= radialSegments3; x6++){
                const u = x6 / radialSegments3;
                const theta = u * thetaLength2 + thetaStart2;
                const cosTheta = Math.cos(theta);
                const sinTheta = Math.sin(theta);
                // vertex
                vertex6.x = radius10 * sinTheta;
                vertex6.y = halfHeight * sign1;
                vertex6.z = radius10 * cosTheta;
                vertices15.push(vertex6.x, vertex6.y, vertex6.z);
                // normal
                normals8.push(0, sign1, 0);
                // uv
                uv3.x = cosTheta * 0.5 + 0.5;
                uv3.y = sinTheta * 0.5 * sign1 + 0.5;
                uvs9.push(uv3.x, uv3.y);
                // increase index
                index1++;
            }
            // generate indices
            for(let x6 = 0; x6 < radialSegments3; x6++){
                const c2 = centerIndexStart + x6;
                const i6 = centerIndexEnd + x6;
                if (top === true) // face top
                indices15.push(i6, i6 + 1, c2);
                else // face bottom
                indices15.push(i6 + 1, i6, c2);
                groupCount1 += 3;
            }
            // add a group to the geometry. this will ensure multi material support
            scope2.addGroup(groupStart2, groupCount1, top === true ? 1 : 2);
            // calculate new start value for groups
            groupStart2 += groupCount1;
        }
    }
}
const CylinderBufferGeometry1 = CylinderBufferGeometry;
/**
 * parameters = {
 *  color: <THREE.Color>
 * }
 */
function ShadowMaterial(parameters1) {
    Material4.call(this);
    this.type = 'ShadowMaterial';
    this.color = new Color1(0);
    this.transparent = true;
    this.setValues(parameters1);
}
ShadowMaterial.prototype = Object.create(Material4.prototype);
ShadowMaterial.prototype.constructor = ShadowMaterial;
ShadowMaterial.prototype.isShadowMaterial = true;
ShadowMaterial.prototype.copy = function(source) {
    Material4.prototype.copy.call(this, source);
    this.color.copy(source.color);
    return this;
};
function SpriteMaterial2(parameters1) {
    Material4.call(this);
    this.type = 'SpriteMaterial';
    this.color = new Color1(16777215);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.setValues(parameters1);
}
SpriteMaterial2.prototype = Object.create(Material4.prototype);
SpriteMaterial2.prototype.constructor = SpriteMaterial2;
SpriteMaterial2.prototype.isSpriteMaterial = true;
SpriteMaterial2.prototype.copy = function(source) {
    Material4.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
};
function RawShaderMaterial(parameters1) {
    ShaderMaterial4.call(this, parameters1);
    this.type = 'RawShaderMaterial';
}
RawShaderMaterial.prototype = Object.create(ShaderMaterial4.prototype);
RawShaderMaterial.prototype.constructor = RawShaderMaterial;
RawShaderMaterial.prototype.isRawShaderMaterial = true;
const default_vertex = `\nvoid main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`;
const default_fragment = `\nvoid main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}\n`;
function ShaderMaterial3(parameters1) {
    Material4.call(this);
    this.type = 'ShaderMaterial';
    this.defines = {
    };
    this.uniforms = {
    };
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.extensions = {
        derivatives: false,
        fragDepth: false,
        drawBuffers: false,
        shaderTextureLOD: false
    };
    this.defaultAttributeValues = {
        'color': [
            1,
            1,
            1
        ],
        'uv': [
            0,
            0
        ],
        'uv2': [
            0,
            0
        ]
    };
    this.index0AttributeName = undefined;
    this.uniformsNeedUpdate = false;
    if (parameters1 !== undefined) {
        if (parameters1.attributes !== undefined) console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
        this.setValues(parameters1);
    }
}
ShaderMaterial3.prototype = Object.create(Material4.prototype);
ShaderMaterial3.prototype.constructor = ShaderMaterial3;
ShaderMaterial3.prototype.isShaderMaterial = true;
ShaderMaterial3.prototype.copy = function(source) {
    Material4.prototype.copy.call(this, source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.defines = Object.assign({
    }, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.extensions = Object.assign({
    }, source.extensions);
    return this;
};
ShaderMaterial3.prototype.toJSON = function(meta) {
    const data = Material4.prototype.toJSON.call(this, meta);
    data.uniforms = {
    };
    for(const name in this.uniforms){
        const uniform = this.uniforms[name];
        const value = uniform.value;
        if (value && value.isTexture) data.uniforms[name] = {
            type: 't',
            value: value.toJSON(meta).uuid
        };
        else if (value && value.isColor) data.uniforms[name] = {
            type: 'c',
            value: value.getHex()
        };
        else if (value && value.isVector2) data.uniforms[name] = {
            type: 'v2',
            value: value.toArray()
        };
        else if (value && value.isVector3) data.uniforms[name] = {
            type: 'v3',
            value: value.toArray()
        };
        else if (value && value.isVector4) data.uniforms[name] = {
            type: 'v4',
            value: value.toArray()
        };
        else if (value && value.isMatrix3) data.uniforms[name] = {
            type: 'm3',
            value: value.toArray()
        };
        else if (value && value.isMatrix4) data.uniforms[name] = {
            type: 'm4',
            value: value.toArray()
        };
        else data.uniforms[name] = {
            value: value
        };
    }
    if (Object.keys(this.defines).length > 0) data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    const extensions = {
    };
    for(const key in this.extensions)if (this.extensions[key] === true) extensions[key] = true;
    if (Object.keys(extensions).length > 0) data.extensions = extensions;
    return data;
};
const ShaderMaterial4 = ShaderMaterial3;
function PointsMaterial2(parameters1) {
    Material4.call(this);
    this.type = 'PointsMaterial';
    this.color = new Color1(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.morphTargets = false;
    this.setValues(parameters1);
}
PointsMaterial2.prototype = Object.create(Material4.prototype);
PointsMaterial2.prototype.constructor = PointsMaterial2;
PointsMaterial2.prototype.isPointsMaterial = true;
PointsMaterial2.prototype.copy = function(source) {
    Material4.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.morphTargets = source.morphTargets;
    return this;
};
/**
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */
function MeshStandardMaterial2(parameters1) {
    Material1.call(this);
    this.defines = {
        'STANDARD': ''
    };
    this.type = 'MeshStandardMaterial';
    this.color = new Color1(16777215); // diffuse
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color1(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector21(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapIntensity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.vertexTangents = false;
    this.setValues(parameters1);
}
MeshStandardMaterial2.prototype = Object.create(Material1.prototype);
MeshStandardMaterial2.prototype.constructor = MeshStandardMaterial2;
MeshStandardMaterial2.prototype.isMeshStandardMaterial = true;
MeshStandardMaterial2.prototype.copy = function(source) {
    Material1.prototype.copy.call(this, source);
    this.defines = {
        'STANDARD': ''
    };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapIntensity = source.envMapIntensity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.vertexTangents = source.vertexTangents;
    return this;
};
const MeshStandardMaterial1 = MeshStandardMaterial2;
/**
 * parameters = {
 *  clearcoat: <float>,
 *  clearcoatMap: new THREE.Texture( <Image> ),
 *  clearcoatRoughness: <float>,
 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
 *  clearcoatNormalScale: <Vector2>,
 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
 *
 *  reflectivity: <float>,
 *
 *  sheen: <Color>,
 *
 *  transmission: <float>,
 *  transmissionMap: new THREE.Texture( <Image> )
 * }
 */
function MeshPhysicalMaterial(parameters1) {
    MeshStandardMaterial4.call(this);
    this.defines = {
        'STANDARD': '',
        'PHYSICAL': ''
    };
    this.type = 'MeshPhysicalMaterial';
    this.clearcoat = 0;
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector21(1, 1);
    this.clearcoatNormalMap = null;
    this.reflectivity = 0.5; // maps to F0 = 0.04
    this.sheen = null; // null will disable sheen bsdf
    this.transmission = 0;
    this.transmissionMap = null;
    this.setValues(parameters1);
}
MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial4.prototype);
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
MeshPhysicalMaterial.prototype.copy = function(source) {
    MeshStandardMaterial4.prototype.copy.call(this, source);
    this.defines = {
        'STANDARD': '',
        'PHYSICAL': ''
    };
    this.clearcoat = source.clearcoat;
    this.clearcoatMap = source.clearcoatMap;
    this.clearcoatRoughness = source.clearcoatRoughness;
    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
    this.reflectivity = source.reflectivity;
    if (source.sheen) this.sheen = (this.sheen || new Color1()).copy(source.sheen);
    else this.sheen = null;
    this.transmission = source.transmission;
    this.transmissionMap = source.transmissionMap;
    return this;
};
function MeshStandardMaterial3(parameters1) {
    Material4.call(this);
    this.defines = {
        'STANDARD': ''
    };
    this.type = 'MeshStandardMaterial';
    this.color = new Color1(16777215);
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color1(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector21(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapIntensity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.vertexTangents = false;
    this.setValues(parameters1);
}
MeshStandardMaterial3.prototype = Object.create(Material4.prototype);
MeshStandardMaterial3.prototype.constructor = MeshStandardMaterial3;
MeshStandardMaterial3.prototype.isMeshStandardMaterial = true;
MeshStandardMaterial3.prototype.copy = function(source) {
    Material4.prototype.copy.call(this, source);
    this.defines = {
        'STANDARD': ''
    };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapIntensity = source.envMapIntensity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.vertexTangents = source.vertexTangents;
    return this;
};
const MeshStandardMaterial4 = MeshStandardMaterial3;
/**
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.MultiplyOperation,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */
function MeshPhongMaterial(parameters1) {
    Material4.call(this);
    this.type = 'MeshPhongMaterial';
    this.color = new Color1(16777215); // diffuse
    this.specular = new Color1(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color1(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector21(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters1);
}
MeshPhongMaterial.prototype = Object.create(Material4.prototype);
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
MeshPhongMaterial.prototype.copy = function(source) {
    Material4.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
/**
 * parameters = {
 *  color: <hex>,
 *
 *  map: new THREE.Texture( <Image> ),
 *  gradientMap: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */
function MeshToonMaterial(parameters1) {
    Material4.call(this);
    this.defines = {
        'TOON': ''
    };
    this.type = 'MeshToonMaterial';
    this.color = new Color1(16777215);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color1(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector21(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters1);
}
MeshToonMaterial.prototype = Object.create(Material4.prototype);
MeshToonMaterial.prototype.constructor = MeshToonMaterial;
MeshToonMaterial.prototype.isMeshToonMaterial = true;
MeshToonMaterial.prototype.copy = function(source) {
    Material4.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.gradientMap = source.gradientMap;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
/**
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */
function MeshNormalMaterial(parameters1) {
    Material4.call(this);
    this.type = 'MeshNormalMaterial';
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector21(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters1);
}
MeshNormalMaterial.prototype = Object.create(Material4.prototype);
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
MeshNormalMaterial.prototype.copy = function(source) {
    Material4.prototype.copy.call(this, source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */
function MeshLambertMaterial(parameters1) {
    Material4.call(this);
    this.type = 'MeshLambertMaterial';
    this.color = new Color1(16777215); // diffuse
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color1(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters1);
}
MeshLambertMaterial.prototype = Object.create(Material4.prototype);
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
MeshLambertMaterial.prototype.copy = function(source) {
    Material4.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
function MeshDepthMaterial2(parameters1) {
    Material4.call(this);
    this.type = 'MeshDepthMaterial';
    this.depthPacking = BasicDepthPacking;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.setValues(parameters1);
}
MeshDepthMaterial2.prototype = Object.create(Material4.prototype);
MeshDepthMaterial2.prototype.constructor = MeshDepthMaterial2;
MeshDepthMaterial2.prototype.isMeshDepthMaterial = true;
MeshDepthMaterial2.prototype.copy = function(source) {
    Material4.prototype.copy.call(this, source);
    this.depthPacking = source.depthPacking;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
};
function MeshDistanceMaterial2(parameters1) {
    Material4.call(this);
    this.type = 'MeshDistanceMaterial';
    this.referencePosition = new Vector31();
    this.nearDistance = 1;
    this.farDistance = 1000;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.setValues(parameters1);
}
MeshDistanceMaterial2.prototype = Object.create(Material4.prototype);
MeshDistanceMaterial2.prototype.constructor = MeshDistanceMaterial2;
MeshDistanceMaterial2.prototype.isMeshDistanceMaterial = true;
MeshDistanceMaterial2.prototype.copy = function(source) {
    Material4.prototype.copy.call(this, source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
};
function MeshBasicMaterial2(parameters1) {
    Material4.call(this);
    this.type = 'MeshBasicMaterial';
    this.color = new Color1(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = 'round';
    this.wireframeLinejoin = 'round';
    this.skinning = false;
    this.morphTargets = false;
    this.setValues(parameters1);
}
MeshBasicMaterial2.prototype = Object.create(Material4.prototype);
MeshBasicMaterial2.prototype.constructor = MeshBasicMaterial2;
MeshBasicMaterial2.prototype.isMeshBasicMaterial = true;
MeshBasicMaterial2.prototype.copy = function(source) {
    Material4.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    return this;
};
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */
function MeshMatcapMaterial(parameters1) {
    Material4.call(this);
    this.defines = {
        'MATCAP': ''
    };
    this.type = 'MeshMatcapMaterial';
    this.color = new Color1(16777215); // diffuse
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector21(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters1);
}
MeshMatcapMaterial.prototype = Object.create(Material4.prototype);
MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
MeshMatcapMaterial.prototype.copy = function(source) {
    Material4.prototype.copy.call(this, source);
    this.defines = {
        'MATCAP': ''
    };
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
};
/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */
function LineDashedMaterial(parameters1) {
    LineBasicMaterial4.call(this);
    this.type = 'LineDashedMaterial';
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters1);
}
LineDashedMaterial.prototype = Object.create(LineBasicMaterial4.prototype);
LineDashedMaterial.prototype.constructor = LineDashedMaterial;
LineDashedMaterial.prototype.isLineDashedMaterial = true;
LineDashedMaterial.prototype.copy = function(source) {
    LineBasicMaterial4.prototype.copy.call(this, source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
};
function LineBasicMaterial3(parameters1) {
    Material4.call(this);
    this.type = 'LineBasicMaterial';
    this.color = new Color1(16777215);
    this.linewidth = 1;
    this.linecap = 'round';
    this.linejoin = 'round';
    this.morphTargets = false;
    this.setValues(parameters1);
}
LineBasicMaterial3.prototype = Object.create(Material4.prototype);
LineBasicMaterial3.prototype.constructor = LineBasicMaterial3;
LineBasicMaterial3.prototype.isLineBasicMaterial = true;
LineBasicMaterial3.prototype.copy = function(source) {
    Material4.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.morphTargets = source.morphTargets;
    return this;
};
const LineBasicMaterial4 = LineBasicMaterial3;
let materialId = 0;
function Material3() {
    Object.defineProperty(this, 'id', {
        value: materialId++
    });
    this.uuid = MathUtils1.generateUUID();
    this.name = '';
    this.type = 'Material';
    this.fog = true;
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.flatShading = false;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaTest = 0;
    this.premultipliedAlpha = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {
    };
    this.version = 0;
}
Material3.prototype = Object.assign(Object.create(EventDispatcher1.prototype), {
    constructor: Material3,
    isMaterial: true,
    onBeforeCompile: function() {
    },
    customProgramCacheKey: function() {
        return this.onBeforeCompile.toString();
    },
    setValues: function(values) {
        if (values === undefined) return;
        for(const key in values){
            const newValue = values[key];
            if (newValue === undefined) {
                console.warn("THREE.Material: '" + key + "' parameter is undefined.");
                continue;
            }
            if (key === 'shading') {
                console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                this.flatShading = newValue === FlatShading ? true : false;
                continue;
            }
            const currentValue = this[key];
            if (currentValue === undefined) {
                console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                continue;
            }
            if (currentValue && currentValue.isColor) currentValue.set(newValue);
            else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) currentValue.copy(newValue);
            else this[key] = newValue;
        }
    },
    toJSON: function(meta) {
        const isRoot = meta === undefined || typeof meta === 'string';
        if (isRoot) meta = {
            textures: {
            },
            images: {
            }
        };
        const data = {
            metadata: {
                version: 4.5,
                type: 'Material',
                generator: 'Material.toJSON'
            }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '') data.name = this.name;
        if (this.color && this.color.isColor) data.color = this.color.getHex();
        if (this.roughness !== undefined) data.roughness = this.roughness;
        if (this.metalness !== undefined) data.metalness = this.metalness;
        if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();
        if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
        if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
        if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
        if (this.shininess !== undefined) data.shininess = this.shininess;
        if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
        if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;
        if (this.clearcoatMap && this.clearcoatMap.isTexture) data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
        if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
        if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
            data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
            data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
        }
        if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
        if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
        if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
        if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;
        if (this.aoMap && this.aoMap.isTexture) {
            data.aoMap = this.aoMap.toJSON(meta).uuid;
            data.aoMapIntensity = this.aoMapIntensity;
        }
        if (this.bumpMap && this.bumpMap.isTexture) {
            data.bumpMap = this.bumpMap.toJSON(meta).uuid;
            data.bumpScale = this.bumpScale;
        }
        if (this.normalMap && this.normalMap.isTexture) {
            data.normalMap = this.normalMap.toJSON(meta).uuid;
            data.normalMapType = this.normalMapType;
            data.normalScale = this.normalScale.toArray();
        }
        if (this.displacementMap && this.displacementMap.isTexture) {
            data.displacementMap = this.displacementMap.toJSON(meta).uuid;
            data.displacementScale = this.displacementScale;
            data.displacementBias = this.displacementBias;
        }
        if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
        if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
        if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
        if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
        if (this.envMap && this.envMap.isTexture) {
            data.envMap = this.envMap.toJSON(meta).uuid;
            data.reflectivity = this.reflectivity;
            data.refractionRatio = this.refractionRatio;
            if (this.combine !== undefined) data.combine = this.combine;
            if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
        }
        if (this.gradientMap && this.gradientMap.isTexture) data.gradientMap = this.gradientMap.toJSON(meta).uuid;
        if (this.size !== undefined) data.size = this.size;
        if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
        if (this.blending !== NormalBlending) data.blending = this.blending;
        if (this.flatShading === true) data.flatShading = this.flatShading;
        if (this.side !== FrontSide) data.side = this.side;
        if (this.vertexColors) data.vertexColors = true;
        if (this.opacity < 1) data.opacity = this.opacity;
        if (this.transparent === true) data.transparent = this.transparent;
        data.depthFunc = this.depthFunc;
        data.depthTest = this.depthTest;
        data.depthWrite = this.depthWrite;
        data.stencilWrite = this.stencilWrite;
        data.stencilWriteMask = this.stencilWriteMask;
        data.stencilFunc = this.stencilFunc;
        data.stencilRef = this.stencilRef;
        data.stencilFuncMask = this.stencilFuncMask;
        data.stencilFail = this.stencilFail;
        data.stencilZFail = this.stencilZFail;
        data.stencilZPass = this.stencilZPass;
        if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
        if (this.polygonOffset === true) data.polygonOffset = true;
        if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
        if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
        if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
        if (this.dashSize !== undefined) data.dashSize = this.dashSize;
        if (this.gapSize !== undefined) data.gapSize = this.gapSize;
        if (this.scale !== undefined) data.scale = this.scale;
        if (this.dithering === true) data.dithering = true;
        if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
        if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
        if (this.wireframe === true) data.wireframe = this.wireframe;
        if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
        if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
        if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
        if (this.morphTargets === true) data.morphTargets = true;
        if (this.morphNormals === true) data.morphNormals = true;
        if (this.skinning === true) data.skinning = true;
        if (this.visible === false) data.visible = false;
        if (this.toneMapped === false) data.toneMapped = false;
        if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData;
        function extractFromCache(cache) {
            const values = [];
            for(const key in cache){
                const data1 = cache[key];
                delete data1.metadata;
                values.push(data1);
            }
            return values;
        }
        if (isRoot) {
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            if (textures.length > 0) data.textures = textures;
            if (images.length > 0) data.images = images;
        }
        return data;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.name = source.name;
        this.fog = source.fog;
        this.blending = source.blending;
        this.side = source.side;
        this.flatShading = source.flatShading;
        this.vertexColors = source.vertexColors;
        this.opacity = source.opacity;
        this.transparent = source.transparent;
        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;
        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;
        this.stencilWriteMask = source.stencilWriteMask;
        this.stencilFunc = source.stencilFunc;
        this.stencilRef = source.stencilRef;
        this.stencilFuncMask = source.stencilFuncMask;
        this.stencilFail = source.stencilFail;
        this.stencilZFail = source.stencilZFail;
        this.stencilZPass = source.stencilZPass;
        this.stencilWrite = source.stencilWrite;
        const srcPlanes = source.clippingPlanes;
        let dstPlanes = null;
        if (srcPlanes !== null) {
            const n = srcPlanes.length;
            dstPlanes = new Array(n);
            for(let i7 = 0; i7 !== n; ++i7)dstPlanes[i7] = srcPlanes[i7].clone();
        }
        this.clippingPlanes = dstPlanes;
        this.clipIntersection = source.clipIntersection;
        this.clipShadows = source.clipShadows;
        this.shadowSide = source.shadowSide;
        this.colorWrite = source.colorWrite;
        this.precision = source.precision;
        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;
        this.dithering = source.dithering;
        this.alphaTest = source.alphaTest;
        this.premultipliedAlpha = source.premultipliedAlpha;
        this.visible = source.visible;
        this.toneMapped = source.toneMapped;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
});
Object.defineProperty(Material3.prototype, 'needsUpdate', {
    set: function(value) {
        if (value === true) this.version++;
    }
});
const Material4 = Material3;
/**
 * A Track of Boolean keyframe values.
 */
function BooleanKeyframeTrack(name, times, values) {
    KeyframeTrack1.call(this, name, times, values);
}
BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack1.prototype), {
    constructor: BooleanKeyframeTrack,
    ValueTypeName: 'bool',
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: undefined,
    InterpolantFactoryMethodSmooth: undefined
});
const BooleanKeyframeTrack1 = BooleanKeyframeTrack;
/**
 * A Track of keyframe values that represent color.
 */
function ColorKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack1.call(this, name, times, values, interpolation);
}
ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack1.prototype), {
    constructor: ColorKeyframeTrack,
    ValueTypeName: 'color'
});
const ColorKeyframeTrack1 = ColorKeyframeTrack;
/**
 * A Track of numeric keyframe values.
 */
function NumberKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack1.call(this, name, times, values, interpolation);
}
NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack1.prototype), {
    constructor: NumberKeyframeTrack,
    ValueTypeName: 'number'
});
const NumberKeyframeTrack1 = NumberKeyframeTrack;
/**
 * Spherical linear unit quaternion interpolant.
 */
function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant1.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant1.prototype), {
    constructor: QuaternionLinearInterpolant,
    interpolate_: function(i12, t0, t2, t11) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t2 - t0) / (t11 - t0);
        let offset = i12 * stride;
        for(let end = offset + stride; offset !== end; offset += 4)Quaternion1.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
        return result;
    }
});
const QuaternionLinearInterpolant1 = QuaternionLinearInterpolant;
/**
 * A Track of quaternion keyframe values.
 */
function QuaternionKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack1.call(this, name, times, values, interpolation);
}
QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack1.prototype), {
    constructor: QuaternionKeyframeTrack,
    ValueTypeName: 'quaternion',
    // ValueBufferType is inherited
    DefaultInterpolation: InterpolateLinear,
    InterpolantFactoryMethodLinear: function(result) {
        return new QuaternionLinearInterpolant1(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodSmooth: undefined
});
const QuaternionKeyframeTrack1 = QuaternionKeyframeTrack;
/**
 * A Track that interpolates Strings
 */
function StringKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack1.call(this, name, times, values, interpolation);
}
StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack1.prototype), {
    constructor: StringKeyframeTrack,
    ValueTypeName: 'string',
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: undefined,
    InterpolantFactoryMethodSmooth: undefined
});
const StringKeyframeTrack1 = StringKeyframeTrack;
/**
 * A Track of vectored keyframe values.
 */
function VectorKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack1.call(this, name, times, values, interpolation);
}
VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack1.prototype), {
    constructor: VectorKeyframeTrack,
    ValueTypeName: 'vector'
});
const VectorKeyframeTrack1 = VectorKeyframeTrack;
function AnimationClip(name, duration, tracks, blendMode) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration !== undefined ? duration : -1;
    this.blendMode = blendMode !== undefined ? blendMode : NormalAnimationBlendMode;
    this.uuid = MathUtils1.generateUUID();
    // this means it should figure out its duration by scanning the tracks
    if (this.duration < 0) this.resetDuration();
}
function getTrackTypeForValueTypeName(typeName) {
    switch(typeName.toLowerCase()){
        case 'scalar':
        case 'double':
        case 'float':
        case 'number':
        case 'integer':
            return NumberKeyframeTrack1;
        case 'vector':
        case 'vector2':
        case 'vector3':
        case 'vector4':
            return VectorKeyframeTrack1;
        case 'color':
            return ColorKeyframeTrack1;
        case 'quaternion':
            return QuaternionKeyframeTrack1;
        case 'bool':
        case 'boolean':
            return BooleanKeyframeTrack1;
        case 'string':
            return StringKeyframeTrack1;
    }
    throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
}
function parseKeyframeTrack(json) {
    if (json.type === undefined) throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
    const trackType = getTrackTypeForValueTypeName(json.type);
    if (json.times === undefined) {
        const times = [], values = [];
        AnimationUtils1.flattenJSON(json.keys, times, values, 'value');
        json.times = times;
        json.values = values;
    }
    // derived classes can define a static parse method
    if (trackType.parse !== undefined) return trackType.parse(json);
    else // by default, we assume a constructor compatible with the base
    return new trackType(json.name, json.times, json.values, json.interpolation);
}
Object.assign(AnimationClip, {
    parse: function(json) {
        const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
        for(let i7 = 0, n = jsonTracks.length; i7 !== n; ++i7)tracks.push(parseKeyframeTrack(jsonTracks[i7]).scale(frameTime));
        return new AnimationClip(json.name, json.duration, tracks, json.blendMode);
    },
    toJSON: function(clip) {
        const tracks = [], clipTracks = clip.tracks;
        const json = {
            'name': clip.name,
            'duration': clip.duration,
            'tracks': tracks,
            'uuid': clip.uuid,
            'blendMode': clip.blendMode
        };
        for(let i7 = 0, n = clipTracks.length; i7 !== n; ++i7)tracks.push(KeyframeTrack1.toJSON(clipTracks[i7]));
        return json;
    },
    CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {
        const numMorphTargets = morphTargetSequence.length;
        const tracks = [];
        for(let i7 = 0; i7 < numMorphTargets; i7++){
            let times = [];
            let values = [];
            times.push((i7 + numMorphTargets - 1) % numMorphTargets, i7, (i7 + 1) % numMorphTargets);
            values.push(0, 1, 0);
            const order1 = AnimationUtils1.getKeyframeOrder(times);
            times = AnimationUtils1.sortedArray(times, 1, order1);
            values = AnimationUtils1.sortedArray(values, 1, order1);
            // if there is a key at the first frame, duplicate it as the
            // last frame as well for perfect loop.
            if (!noLoop && times[0] === 0) {
                times.push(numMorphTargets);
                values.push(values[0]);
            }
            tracks.push(new NumberKeyframeTrack1('.morphTargetInfluences[' + morphTargetSequence[i7].name + ']', times, values).scale(1 / fps));
        }
        return new AnimationClip(name, -1, tracks);
    },
    findByName: function(objectOrClipArray, name) {
        let clipArray = objectOrClipArray;
        if (!Array.isArray(objectOrClipArray)) {
            const o = objectOrClipArray;
            clipArray = o.geometry && o.geometry.animations || o.animations;
        }
        for(let i7 = 0; i7 < clipArray.length; i7++)if (clipArray[i7].name === name) return clipArray[i7];
        return null;
    },
    CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {
        const animationToMorphTargets = {
        };
        // tested with https://regex101.com/ on trick sequences
        // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
        const pattern = /^([\w-]*?)([\d]+)$/;
        // sort morph target names into animation groups based
        // patterns like Walk_001, Walk_002, Run_001, Run_002
        for(let i7 = 0, il = morphTargets.length; i7 < il; i7++){
            const morphTarget = morphTargets[i7];
            const parts = morphTarget.name.match(pattern);
            if (parts && parts.length > 1) {
                const name = parts[1];
                let animationMorphTargets = animationToMorphTargets[name];
                if (!animationMorphTargets) animationToMorphTargets[name] = animationMorphTargets = [];
                animationMorphTargets.push(morphTarget);
            }
        }
        const clips = [];
        for(const name in animationToMorphTargets)clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
        return clips;
    },
    // parse the animation.hierarchy format
    parseAnimation: function(animation, bones) {
        if (!animation) {
            console.error('THREE.AnimationClip: No animation in JSONLoader data.');
            return null;
        }
        const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
            // only return track if there are actually keys.
            if (animationKeys.length !== 0) {
                const times = [];
                const values = [];
                AnimationUtils1.flattenJSON(animationKeys, times, values, propertyName);
                // empty keys are filtered out, so check again
                if (times.length !== 0) destTracks.push(new trackType(trackName, times, values));
            }
        };
        const tracks = [];
        const clipName = animation.name || 'default';
        const fps = animation.fps || 30;
        const blendMode = animation.blendMode;
        // automatic length determination in AnimationClip.
        let duration = animation.length || -1;
        const hierarchyTracks = animation.hierarchy || [];
        for(let h = 0; h < hierarchyTracks.length; h++){
            const animationKeys = hierarchyTracks[h].keys;
            // skip empty tracks
            if (!animationKeys || animationKeys.length === 0) continue;
            // process morph targets
            if (animationKeys[0].morphTargets) {
                // figure out all morph targets used in this track
                const morphTargetNames = {
                };
                let k;
                for(k = 0; k < animationKeys.length; k++)if (animationKeys[k].morphTargets) for(let m = 0; m < animationKeys[k].morphTargets.length; m++)morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                // create a track for each morph target with all zero
                // morphTargetInfluences except for the keys in which
                // the morphTarget is named.
                for(const morphTargetName in morphTargetNames){
                    const times = [];
                    const values = [];
                    for(let m1 = 0; m1 !== animationKeys[k].morphTargets.length; ++m1){
                        const animationKey = animationKeys[k];
                        times.push(animationKey.time);
                        values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                    }
                    tracks.push(new NumberKeyframeTrack1('.morphTargetInfluence[' + morphTargetName + ']', times, values));
                }
                duration = morphTargetNames.length * (fps || 1);
            } else {
                // ...assume skeletal animation
                const boneName = '.bones[' + bones[h].name + ']';
                addNonemptyTrack(VectorKeyframeTrack1, boneName + '.position', animationKeys, 'pos', tracks);
                addNonemptyTrack(QuaternionKeyframeTrack1, boneName + '.quaternion', animationKeys, 'rot', tracks);
                addNonemptyTrack(VectorKeyframeTrack1, boneName + '.scale', animationKeys, 'scl', tracks);
            }
        }
        if (tracks.length === 0) return null;
        const clip = new AnimationClip(clipName, duration, tracks, blendMode);
        return clip;
    }
});
Object.assign(AnimationClip.prototype, {
    resetDuration: function() {
        const tracks = this.tracks;
        let duration = 0;
        for(let i7 = 0, n = tracks.length; i7 !== n; ++i7){
            const track = this.tracks[i7];
            duration = Math.max(duration, track.times[track.times.length - 1]);
        }
        this.duration = duration;
        return this;
    },
    trim: function() {
        for(let i7 = 0; i7 < this.tracks.length; i7++)this.tracks[i7].trim(0, this.duration);
        return this;
    },
    validate: function() {
        let valid = true;
        for(let i7 = 0; i7 < this.tracks.length; i7++)valid = valid && this.tracks[i7].validate();
        return valid;
    },
    optimize: function() {
        for(let i7 = 0; i7 < this.tracks.length; i7++)this.tracks[i7].optimize();
        return this;
    },
    clone: function() {
        const tracks = [];
        for(let i7 = 0; i7 < this.tracks.length; i7++)tracks.push(this.tracks[i7].clone());
        return new AnimationClip(this.name, this.duration, tracks, this.blendMode);
    }
});
const AnimationClip1 = AnimationClip;
const Cache11 = {
    enabled: false,
    files: {
    },
    add: function(key, file) {
        if (this.enabled === false) return;
        // console.log( 'THREE.Cache', 'Adding key:', key );
        this.files[key] = file;
    },
    get: function(key) {
        if (this.enabled === false) return;
        // console.log( 'THREE.Cache', 'Checking key:', key );
        return this.files[key];
    },
    remove: function(key) {
        delete this.files[key];
    },
    clear: function() {
        this.files = {
        };
    }
};
const Cache2 = Cache11;
function LoadingManager(onLoad, onProgress, onError) {
    const scope3 = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = undefined;
    const handlers = [];
    // Refer to #5689 for the reason why we don't set .onStart
    // in the constructor
    this.onStart = undefined;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
        itemsTotal++;
        if (isLoading === false) {
            if (scope3.onStart !== undefined) scope3.onStart(url, itemsLoaded, itemsTotal);
        }
        isLoading = true;
    };
    this.itemEnd = function(url) {
        itemsLoaded++;
        if (scope3.onProgress !== undefined) scope3.onProgress(url, itemsLoaded, itemsTotal);
        if (itemsLoaded === itemsTotal) {
            isLoading = false;
            if (scope3.onLoad !== undefined) scope3.onLoad();
        }
    };
    this.itemError = function(url) {
        if (scope3.onError !== undefined) scope3.onError(url);
    };
    this.resolveURL = function(url) {
        if (urlModifier) return urlModifier(url);
        return url;
    };
    this.setURLModifier = function(transform) {
        urlModifier = transform;
        return this;
    };
    this.addHandler = function(regex, loader) {
        handlers.push(regex, loader);
        return this;
    };
    this.removeHandler = function(regex) {
        const index2 = handlers.indexOf(regex);
        if (index2 !== -1) handlers.splice(index2, 2);
        return this;
    };
    this.getHandler = function(file) {
        for(let i7 = 0, l1 = handlers.length; i7 < l1; i7 += 2){
            const regex = handlers[i7];
            const loader = handlers[i7 + 1];
            if (regex.global) regex.lastIndex = 0; // see #17920
            if (regex.test(file)) return loader;
        }
        return null;
    };
}
const DefaultLoadingManager = new LoadingManager();
const DefaultLoadingManager1 = DefaultLoadingManager, LoadingManager1 = LoadingManager;
function Loader(manager) {
    this.manager = manager !== undefined ? manager : DefaultLoadingManager1;
    this.crossOrigin = 'anonymous';
    this.path = '';
    this.resourcePath = '';
    this.requestHeader = {
    };
}
Object.assign(Loader.prototype, {
    load: function() {
    },
    loadAsync: function(url, onProgress) {
        const scope3 = this;
        return new Promise(function(resolve, reject) {
            scope3.load(url, resolve, onProgress, reject);
        });
    },
    parse: function() {
    },
    setCrossOrigin: function(crossOrigin) {
        this.crossOrigin = crossOrigin;
        return this;
    },
    setPath: function(path1) {
        this.path = path1;
        return this;
    },
    setResourcePath: function(resourcePath) {
        this.resourcePath = resourcePath;
        return this;
    },
    setRequestHeader: function(requestHeader) {
        this.requestHeader = requestHeader;
        return this;
    }
});
const Loader1 = Loader;
const loading = {
};
function FileLoader(manager) {
    Loader1.call(this, manager);
}
FileLoader.prototype = Object.assign(Object.create(Loader1.prototype), {
    constructor: FileLoader,
    load: function(url, onLoad, onProgress, onError) {
        if (url === undefined) url = '';
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope3 = this;
        const cached = Cache1.get(url);
        if (cached !== undefined) {
            scope3.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope3.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        // Check if request is duplicate
        if (loading[url] !== undefined) {
            loading[url].push({
                onLoad: onLoad,
                onProgress: onProgress,
                onError: onError
            });
            return;
        }
        // Check for data: URI
        const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
        const dataUriRegexResult = url.match(dataUriRegex);
        let request;
        // Safari can not handle Data URIs through XMLHttpRequest so process manually
        if (dataUriRegexResult) {
            const mimeType = dataUriRegexResult[1];
            const isBase64 = !!dataUriRegexResult[2];
            let data = dataUriRegexResult[3];
            data = decodeURIComponent(data);
            if (isBase64) data = atob(data);
            try {
                let response;
                const responseType = (this.responseType || '').toLowerCase();
                switch(responseType){
                    case 'arraybuffer':
                    case 'blob':
                        const view = new Uint8Array(data.length);
                        for(let i7 = 0; i7 < data.length; i7++)view[i7] = data.charCodeAt(i7);
                        if (responseType === 'blob') response = new Blob([
                            view.buffer
                        ], {
                            type: mimeType
                        });
                        else response = view.buffer;
                        break;
                    case 'document':
                        const parser = new DOMParser();
                        response = parser.parseFromString(data, mimeType);
                        break;
                    case 'json':
                        response = JSON.parse(data);
                        break;
                    default:
                        response = data;
                        break;
                }
                // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                setTimeout(function() {
                    if (onLoad) onLoad(response);
                    scope3.manager.itemEnd(url);
                }, 0);
            } catch (error) {
                // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                setTimeout(function() {
                    if (onError) onError(error);
                    scope3.manager.itemError(url);
                    scope3.manager.itemEnd(url);
                }, 0);
            }
        } else {
            // Initialise array for duplicate requests
            loading[url] = [];
            loading[url].push({
                onLoad: onLoad,
                onProgress: onProgress,
                onError: onError
            });
            request = new XMLHttpRequest();
            request.open('GET', url, true);
            request.addEventListener('load', function(event) {
                const response = this.response;
                const callbacks = loading[url];
                delete loading[url];
                if (this.status === 200 || this.status === 0) {
                    // Some browsers return HTTP Status 0 when using non-http protocol
                    // e.g. 'file://' or 'data://'. Handle as success.
                    if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.');
                    // Add to cache only on HTTP success, so that we do not cache
                    // error response bodies as proper responses to requests.
                    Cache1.add(url, response);
                    for(let i7 = 0, il = callbacks.length; i7 < il; i7++){
                        const callback = callbacks[i7];
                        if (callback.onLoad) callback.onLoad(response);
                    }
                    scope3.manager.itemEnd(url);
                } else {
                    for(let i7 = 0, il = callbacks.length; i7 < il; i7++){
                        const callback = callbacks[i7];
                        if (callback.onError) callback.onError(event);
                    }
                    scope3.manager.itemError(url);
                    scope3.manager.itemEnd(url);
                }
            }, false);
            request.addEventListener('progress', function(event) {
                const callbacks = loading[url];
                for(let i7 = 0, il = callbacks.length; i7 < il; i7++){
                    const callback = callbacks[i7];
                    if (callback.onProgress) callback.onProgress(event);
                }
            }, false);
            request.addEventListener('error', function(event) {
                const callbacks = loading[url];
                delete loading[url];
                for(let i7 = 0, il = callbacks.length; i7 < il; i7++){
                    const callback = callbacks[i7];
                    if (callback.onError) callback.onError(event);
                }
                scope3.manager.itemError(url);
                scope3.manager.itemEnd(url);
            }, false);
            request.addEventListener('abort', function(event) {
                const callbacks = loading[url];
                delete loading[url];
                for(let i7 = 0, il = callbacks.length; i7 < il; i7++){
                    const callback = callbacks[i7];
                    if (callback.onError) callback.onError(event);
                }
                scope3.manager.itemError(url);
                scope3.manager.itemEnd(url);
            }, false);
            if (this.responseType !== undefined) request.responseType = this.responseType;
            if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
            if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');
            for(const header in this.requestHeader)request.setRequestHeader(header, this.requestHeader[header]);
            request.send(null);
        }
        scope3.manager.itemStart(url);
        return request;
    },
    setResponseType: function(value) {
        this.responseType = value;
        return this;
    },
    setWithCredentials: function(value) {
        this.withCredentials = value;
        return this;
    },
    setMimeType: function(value) {
        this.mimeType = value;
        return this;
    }
});
const FileLoader1 = FileLoader;
function AnimationLoader(manager) {
    Loader1.call(this, manager);
}
AnimationLoader.prototype = Object.assign(Object.create(Loader1.prototype), {
    constructor: AnimationLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope3 = this;
        const loader = new FileLoader1(scope3.manager);
        loader.setPath(scope3.path);
        loader.setRequestHeader(scope3.requestHeader);
        loader.load(url, function(text1) {
            try {
                onLoad(scope3.parse(JSON.parse(text1)));
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope3.manager.itemError(url);
            }
        }, onProgress, onError);
    },
    parse: function(json) {
        const animations = [];
        for(let i7 = 0; i7 < json.length; i7++){
            const clip = AnimationClip1.parse(json[i7]);
            animations.push(clip);
        }
        return animations;
    }
});
const AnimationLoader1 = AnimationLoader;
export { AnimationLoader1 as AnimationLoader };
function CompressedTexture2(mipmaps, width2, height3, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    Texture1.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = {
        width: width2,
        height: height3
    };
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
}
CompressedTexture2.prototype = Object.create(Texture1.prototype);
CompressedTexture2.prototype.constructor = CompressedTexture2;
CompressedTexture2.prototype.isCompressedTexture = true;
const CompressedTexture1 = CompressedTexture2;
/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */
function CompressedTextureLoader(manager) {
    Loader1.call(this, manager);
}
CompressedTextureLoader.prototype = Object.assign(Object.create(Loader1.prototype), {
    constructor: CompressedTextureLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope3 = this;
        const images = [];
        const texture = new CompressedTexture1();
        texture.image = images;
        const loader = new FileLoader1(this.manager);
        loader.setPath(this.path);
        loader.setResponseType('arraybuffer');
        loader.setRequestHeader(this.requestHeader);
        let loaded = 0;
        function loadTexture(i7) {
            loader.load(url[i7], function(buffer) {
                const texDatas = scope3.parse(buffer, true);
                images[i7] = {
                    width: texDatas.width,
                    height: texDatas.height,
                    format: texDatas.format,
                    mipmaps: texDatas.mipmaps
                };
                loaded += 1;
                if (loaded === 6) {
                    if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
                    texture.format = texDatas.format;
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                }
            }, onProgress, onError);
        }
        if (Array.isArray(url)) for(let i7 = 0, il = url.length; i7 < il; ++i7)loadTexture(i7);
        else // compressed cubemap texture stored in a single DDS file
        loader.load(url, function(buffer) {
            const texDatas = scope3.parse(buffer, true);
            if (texDatas.isCubemap) {
                const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                for(let f = 0; f < faces; f++){
                    images[f] = {
                        mipmaps: []
                    };
                    for(let i12 = 0; i12 < texDatas.mipmapCount; i12++){
                        images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i12]);
                        images[f].format = texDatas.format;
                        images[f].width = texDatas.width;
                        images[f].height = texDatas.height;
                    }
                }
            } else {
                texture.image.width = texDatas.width;
                texture.image.height = texDatas.height;
                texture.mipmaps = texDatas.mipmaps;
            }
            if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture);
        }, onProgress, onError);
        return texture;
    }
});
const CompressedTextureLoader1 = CompressedTextureLoader;
export { CompressedTextureLoader1 as CompressedTextureLoader };
function ImageLoader(manager) {
    Loader1.call(this, manager);
}
ImageLoader.prototype = Object.assign(Object.create(Loader1.prototype), {
    constructor: ImageLoader,
    load: function(url, onLoad, onProgress, onError) {
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope3 = this;
        const cached = Cache1.get(url);
        if (cached !== undefined) {
            scope3.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope3.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        const image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
        function onImageLoad() {
            image.removeEventListener('load', onImageLoad, false);
            image.removeEventListener('error', onImageError, false);
            Cache1.add(url, this);
            if (onLoad) onLoad(this);
            scope3.manager.itemEnd(url);
        }
        function onImageError(event) {
            image.removeEventListener('load', onImageLoad, false);
            image.removeEventListener('error', onImageError, false);
            if (onError) onError(event);
            scope3.manager.itemError(url);
            scope3.manager.itemEnd(url);
        }
        image.addEventListener('load', onImageLoad, false);
        image.addEventListener('error', onImageError, false);
        if (url.substr(0, 5) !== 'data:') {
            if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
        }
        scope3.manager.itemStart(url);
        image.src = url;
        return image;
    }
});
const ImageLoader1 = ImageLoader;
function CubeTextureLoader(manager) {
    Loader1.call(this, manager);
}
CubeTextureLoader.prototype = Object.assign(Object.create(Loader1.prototype), {
    constructor: CubeTextureLoader,
    load: function(urls, onLoad, onProgress, onError) {
        const texture = new CubeTexture1();
        const loader = new ImageLoader1(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        let loaded = 0;
        function loadTexture(i7) {
            loader.load(urls[i7], function(image) {
                texture.images[i7] = image;
                loaded++;
                if (loaded === 6) {
                    texture.needsUpdate = true;
                    if (onLoad) onLoad(texture);
                }
            }, undefined, onError);
        }
        for(let i7 = 0; i7 < urls.length; ++i7)loadTexture(i7);
        return texture;
    }
});
const CubeTextureLoader1 = CubeTextureLoader;
export { CubeTextureLoader1 as CubeTextureLoader };
/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */
function DataTextureLoader(manager) {
    Loader1.call(this, manager);
}
DataTextureLoader.prototype = Object.assign(Object.create(Loader1.prototype), {
    constructor: DataTextureLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope3 = this;
        const texture = new DataTexture1();
        const loader = new FileLoader1(this.manager);
        loader.setResponseType('arraybuffer');
        loader.setRequestHeader(this.requestHeader);
        loader.setPath(this.path);
        loader.load(url, function(buffer) {
            const texData = scope3.parse(buffer);
            if (!texData) return;
            if (texData.image !== undefined) texture.image = texData.image;
            else if (texData.data !== undefined) {
                texture.image.width = texData.width;
                texture.image.height = texData.height;
                texture.image.data = texData.data;
            }
            texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
            texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
            texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
            texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
            texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
            if (texData.format !== undefined) texture.format = texData.format;
            if (texData.type !== undefined) texture.type = texData.type;
            if (texData.mipmaps !== undefined) {
                texture.mipmaps = texData.mipmaps;
                texture.minFilter = LinearMipmapLinearFilter; // presumably...
            }
            if (texData.mipmapCount === 1) texture.minFilter = LinearFilter;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture, texData);
        }, onProgress, onError);
        return texture;
    }
});
const DataTextureLoader1 = DataTextureLoader;
export { DataTextureLoader1 as DataTextureLoader };
function TextureLoader(manager) {
    Loader1.call(this, manager);
}
TextureLoader.prototype = Object.assign(Object.create(Loader1.prototype), {
    constructor: TextureLoader,
    load: function(url, onLoad, onProgress, onError) {
        const texture = new Texture1();
        const loader = new ImageLoader1(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        loader.load(url, function(image) {
            texture.image = image;
            // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
            const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
            texture.format = isJPEG ? RGBFormat : RGBAFormat;
            texture.needsUpdate = true;
            if (onLoad !== undefined) onLoad(texture);
        }, onProgress, onError);
        return texture;
    }
});
const TextureLoader1 = TextureLoader;
export { TextureLoader1 as TextureLoader };
const _instanceLocalMatrix = new Matrix41();
const _instanceWorldMatrix = new Matrix41();
const _instanceIntersects = [];
const _mesh = new Mesh1();
function InstancedMesh2(geometry, material, count) {
    Mesh1.call(this, geometry, material);
    this.instanceMatrix = new BufferAttribute1(new Float32Array(count * 16), 16);
    this.instanceColor = null;
    this.count = count;
    this.frustumCulled = false;
}
InstancedMesh2.prototype = Object.assign(Object.create(Mesh1.prototype), {
    constructor: InstancedMesh2,
    isInstancedMesh: true,
    copy: function(source) {
        Mesh1.prototype.copy.call(this, source);
        this.instanceMatrix.copy(source.instanceMatrix);
        this.count = source.count;
        return this;
    },
    setColorAt: function(index2, color1) {
        if (this.instanceColor === null) this.instanceColor = new BufferAttribute1(new Float32Array(this.count * 3), 3);
        color1.toArray(this.instanceColor.array, index2 * 3);
    },
    getMatrixAt: function(index2, matrix) {
        matrix.fromArray(this.instanceMatrix.array, index2 * 16);
    },
    raycast: function(raycaster, intersects1) {
        const matrixWorld = this.matrixWorld;
        const raycastTimes = this.count;
        _mesh.geometry = this.geometry;
        _mesh.material = this.material;
        if (_mesh.material === undefined) return;
        for(let instanceId = 0; instanceId < raycastTimes; instanceId++){
            this.getMatrixAt(instanceId, _instanceLocalMatrix);
            _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
            _mesh.matrixWorld = _instanceWorldMatrix;
            _mesh.raycast(raycaster, _instanceIntersects);
            for(let i7 = 0, l1 = _instanceIntersects.length; i7 < l1; i7++){
                const intersect = _instanceIntersects[i7];
                intersect.instanceId = instanceId;
                intersect.object = this;
                intersects1.push(intersect);
            }
            _instanceIntersects.length = 0;
        }
    },
    setMatrixAt: function(index2, matrix) {
        matrix.toArray(this.instanceMatrix.array, index2 * 16);
    },
    updateMorphTargets: function() {
    }
});
const InstancedMesh1 = InstancedMesh2;
import { Sprite as Sprite1 } from '../objects/Sprite.js';
import { Points as Points1 } from '../objects/Points.js';
function LineLoop2(geometry, material) {
    Line1.call(this, geometry, material);
    this.type = 'LineLoop';
}
LineLoop2.prototype = Object.assign(Object.create(Line1.prototype), {
    constructor: LineLoop2,
    isLineLoop: true
});
const LineLoop1 = LineLoop2;
const _start1 = new Vector31();
const _end1 = new Vector31();
function LineSegments2(geometry, material) {
    Line1.call(this, geometry, material);
    this.type = 'LineSegments';
}
LineSegments2.prototype = Object.assign(Object.create(Line1.prototype), {
    constructor: LineSegments2,
    isLineSegments: true,
    computeLineDistances: function() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
            if (geometry.index === null) {
                const positionAttribute = geometry.attributes.position;
                const lineDistances = [];
                for(let i7 = 0, l1 = positionAttribute.count; i7 < l1; i7 += 2){
                    _start1.fromBufferAttribute(positionAttribute, i7);
                    _end1.fromBufferAttribute(positionAttribute, i7 + 1);
                    lineDistances[i7] = i7 === 0 ? 0 : lineDistances[i7 - 1];
                    lineDistances[i7 + 1] = lineDistances[i7] + _start1.distanceTo(_end1);
                }
                geometry.setAttribute('lineDistance', new Float32BufferAttribute1(lineDistances, 1));
            } else console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        } else if (geometry.isGeometry) {
            const vertices17 = geometry.vertices;
            const lineDistances = geometry.lineDistances;
            for(let i7 = 0, l1 = vertices17.length; i7 < l1; i7 += 2){
                _start1.copy(vertices17[i7]);
                _end1.copy(vertices17[i7 + 1]);
                lineDistances[i7] = i7 === 0 ? 0 : lineDistances[i7 - 1];
                lineDistances[i7 + 1] = lineDistances[i7] + _start1.distanceTo(_end1);
            }
        }
        return this;
    }
});
const LineSegments1 = LineSegments2;
const _v15 = new Vector31();
const _v22 = new Vector31();
function LOD2() {
    Object3D1.call(this);
    this._currentLevel = 0;
    this.type = 'LOD';
    Object.defineProperties(this, {
        levels: {
            enumerable: true,
            value: []
        }
    });
    this.autoUpdate = true;
}
LOD2.prototype = Object.assign(Object.create(Object3D1.prototype), {
    constructor: LOD2,
    isLOD: true,
    copy: function(source) {
        Object3D1.prototype.copy.call(this, source, false);
        const levels = source.levels;
        for(let i7 = 0, l1 = levels.length; i7 < l1; i7++){
            const level = levels[i7];
            this.addLevel(level.object.clone(), level.distance);
        }
        this.autoUpdate = source.autoUpdate;
        return this;
    },
    addLevel: function(object, distance) {
        if (distance === undefined) distance = 0;
        distance = Math.abs(distance);
        const levels = this.levels;
        let l1;
        for(l1 = 0; l1 < levels.length; l1++)if (distance < levels[l1].distance) break;
        levels.splice(l1, 0, {
            distance: distance,
            object: object
        });
        this.add(object);
        return this;
    },
    getCurrentLevel: function() {
        return this._currentLevel;
    },
    getObjectForDistance: function(distance) {
        const levels = this.levels;
        if (levels.length > 0) {
            let i7, l1;
            for((i7 = 1, l1 = levels.length); i7 < l1; i7++)if (distance < levels[i7].distance) break;
            return levels[i7 - 1].object;
        }
        return null;
    },
    raycast: function(raycaster, intersects1) {
        const levels = this.levels;
        if (levels.length > 0) {
            _v15.setFromMatrixPosition(this.matrixWorld);
            const distance = raycaster.ray.origin.distanceTo(_v15);
            this.getObjectForDistance(distance).raycast(raycaster, intersects1);
        }
    },
    update: function(camera) {
        const levels = this.levels;
        if (levels.length > 1) {
            _v15.setFromMatrixPosition(camera.matrixWorld);
            _v22.setFromMatrixPosition(this.matrixWorld);
            const distance = _v15.distanceTo(_v22) / camera.zoom;
            levels[0].object.visible = true;
            let i7, l1;
            for((i7 = 1, l1 = levels.length); i7 < l1; i7++)if (distance >= levels[i7].distance) {
                levels[i7 - 1].object.visible = false;
                levels[i7].object.visible = true;
            } else break;
            this._currentLevel = i7 - 1;
            for(; i7 < l1; i7++)levels[i7].object.visible = false;
        }
    },
    toJSON: function(meta) {
        const data = Object3D1.prototype.toJSON.call(this, meta);
        if (this.autoUpdate === false) data.object.autoUpdate = false;
        data.object.levels = [];
        const levels = this.levels;
        for(let i7 = 0, l1 = levels.length; i7 < l1; i7++){
            const level = levels[i7];
            data.object.levels.push({
                object: level.object.uuid,
                distance: level.distance
            });
        }
        return data;
    }
});
const LOD1 = LOD2;
function Shape(points1) {
    Path1.call(this, points1);
    this.uuid = MathUtils1.generateUUID();
    this.type = 'Shape';
    this.holes = [];
}
Shape.prototype = Object.assign(Object.create(Path1.prototype), {
    constructor: Shape,
    getPointsHoles: function(divisions) {
        const holesPts = [];
        for(let i7 = 0, l1 = this.holes.length; i7 < l1; i7++)holesPts[i7] = this.holes[i7].getPoints(divisions);
        return holesPts;
    },
    // get points of shape and holes (keypoints based on segments parameter)
    extractPoints: function(divisions) {
        return {
            shape: this.getPoints(divisions),
            holes: this.getPointsHoles(divisions)
        };
    },
    copy: function(source) {
        Path1.prototype.copy.call(this, source);
        this.holes = [];
        for(let i7 = 0, l1 = source.holes.length; i7 < l1; i7++){
            const hole = source.holes[i7];
            this.holes.push(hole.clone());
        }
        return this;
    },
    toJSON: function() {
        const data = Path1.prototype.toJSON.call(this);
        data.uuid = this.uuid;
        data.holes = [];
        for(let i7 = 0, l1 = this.holes.length; i7 < l1; i7++){
            const hole = this.holes[i7];
            data.holes.push(hole.toJSON());
        }
        return data;
    },
    fromJSON: function(json) {
        Path1.prototype.fromJSON.call(this, json);
        this.uuid = json.uuid;
        this.holes = [];
        for(let i7 = 0, l1 = json.holes.length; i7 < l1; i7++){
            const hole = json.holes[i7];
            this.holes.push(new Path1().fromJSON(hole));
        }
        return this;
    }
});
const Shape1 = Shape;
function Fog2(color1, near, far) {
    this.name = '';
    this.color = new Color1(color1);
    this.near = near !== undefined ? near : 1;
    this.far = far !== undefined ? far : 1000;
}
Object.assign(Fog2.prototype, {
    isFog: true,
    clone: function() {
        return new Fog2(this.color, this.near, this.far);
    },
    toJSON: function() {
        return {
            type: 'Fog',
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        };
    }
});
const Fog1 = Fog2;
function FogExp22(color1, density) {
    this.name = '';
    this.color = new Color1(color1);
    this.density = density !== undefined ? density : 0.00025;
}
Object.assign(FogExp22.prototype, {
    isFogExp2: true,
    clone: function() {
        return new FogExp22(this.color, this.density);
    },
    toJSON: function() {
        return {
            type: 'FogExp2',
            color: this.color.getHex(),
            density: this.density
        };
    }
});
const FogExp21 = FogExp22;
function Light(color1, intensity) {
    Object3D1.call(this);
    this.type = 'Light';
    this.color = new Color1(color1);
    this.intensity = intensity !== undefined ? intensity : 1;
    this.receiveShadow = undefined;
}
Light.prototype = Object.assign(Object.create(Object3D1.prototype), {
    constructor: Light,
    isLight: true,
    copy: function(source) {
        Object3D1.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.intensity = source.intensity;
        return this;
    },
    toJSON: function(meta) {
        const data = Object3D1.prototype.toJSON.call(this, meta);
        data.object.color = this.color.getHex();
        data.object.intensity = this.intensity;
        if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
        if (this.distance !== undefined) data.object.distance = this.distance;
        if (this.angle !== undefined) data.object.angle = this.angle;
        if (this.decay !== undefined) data.object.decay = this.decay;
        if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
        if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
        return data;
    }
});
const Light1 = Light;
function HemisphereLight(skyColor, groundColor, intensity) {
    Light1.call(this, skyColor, intensity);
    this.type = 'HemisphereLight';
    this.castShadow = undefined;
    this.position.copy(Object3D1.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color1(groundColor);
}
HemisphereLight.prototype = Object.assign(Object.create(Light1.prototype), {
    constructor: HemisphereLight,
    isHemisphereLight: true,
    copy: function(source) {
        Light1.prototype.copy.call(this, source);
        this.groundColor.copy(source.groundColor);
        return this;
    }
});
const HemisphereLight1 = HemisphereLight;
function LightShadow(camera) {
    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.mapSize = new Vector21(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix41();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum1();
    this._frameExtents = new Vector21(1, 1);
    this._viewportCount = 1;
    this._viewports = [
        new Vector41(0, 0, 1, 1)
    ];
}
Object.assign(LightShadow.prototype, {
    _projScreenMatrix: new Matrix41(),
    _lightPositionWorld: new Vector31(),
    _lookTarget: new Vector31(),
    getViewportCount: function() {
        return this._viewportCount;
    },
    getFrustum: function() {
        return this._frustum;
    },
    updateMatrices: function(light) {
        const shadowCamera = this.camera, shadowMatrix = this.matrix, projScreenMatrix = this._projScreenMatrix, lookTarget = this._lookTarget, lightPositionWorld = this._lightPositionWorld;
        lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
        shadowCamera.position.copy(lightPositionWorld);
        lookTarget.setFromMatrixPosition(light.target.matrixWorld);
        shadowCamera.lookAt(lookTarget);
        shadowCamera.updateMatrixWorld();
        projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(projScreenMatrix);
        shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
        shadowMatrix.multiply(shadowCamera.projectionMatrix);
        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
    },
    getViewport: function(viewportIndex) {
        return this._viewports[viewportIndex];
    },
    getFrameExtents: function() {
        return this._frameExtents;
    },
    copy: function(source) {
        this.camera = source.camera.clone();
        this.bias = source.bias;
        this.radius = source.radius;
        this.mapSize.copy(source.mapSize);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    toJSON: function() {
        const object = {
        };
        if (this.bias !== 0) object.bias = this.bias;
        if (this.normalBias !== 0) object.normalBias = this.normalBias;
        if (this.radius !== 1) object.radius = this.radius;
        if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
        object.camera = this.camera.toJSON(false).object;
        delete object.camera.matrix;
        return object;
    }
});
const LightShadow1 = LightShadow;
function SpotLightShadow() {
    LightShadow1.call(this, new PerspectiveCamera1(50, 1, 0.5, 500));
}
SpotLightShadow.prototype = Object.assign(Object.create(LightShadow1.prototype), {
    constructor: SpotLightShadow,
    isSpotLightShadow: true,
    updateMatrices: function(light) {
        const camera = this.camera;
        const fov1 = MathUtils1.RAD2DEG * 2 * light.angle;
        const aspect1 = this.mapSize.width / this.mapSize.height;
        const far = light.distance || camera.far;
        if (fov1 !== camera.fov || aspect1 !== camera.aspect || far !== camera.far) {
            camera.fov = fov1;
            camera.aspect = aspect1;
            camera.far = far;
            camera.updateProjectionMatrix();
        }
        LightShadow1.prototype.updateMatrices.call(this, light);
    }
});
const SpotLightShadow1 = SpotLightShadow;
function SpotLight(color1, intensity, distance, angle, penumbra, decay) {
    Light1.call(this, color1, intensity);
    this.type = 'SpotLight';
    this.position.copy(Object3D1.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D1();
    Object.defineProperty(this, 'power', {
        get: function() {
            // intensity = power per solid angle.
            // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
            return this.intensity * Math.PI;
        },
        set: function(power) {
            // intensity = power per solid angle.
            // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
            this.intensity = power / Math.PI;
        }
    });
    this.distance = distance !== undefined ? distance : 0;
    this.angle = angle !== undefined ? angle : Math.PI / 3;
    this.penumbra = penumbra !== undefined ? penumbra : 0;
    this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.
    this.shadow = new SpotLightShadow1();
}
SpotLight.prototype = Object.assign(Object.create(Light1.prototype), {
    constructor: SpotLight,
    isSpotLight: true,
    copy: function(source) {
        Light1.prototype.copy.call(this, source);
        this.distance = source.distance;
        this.angle = source.angle;
        this.penumbra = source.penumbra;
        this.decay = source.decay;
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    }
});
const SpotLight1 = SpotLight;
function OrthographicCamera(left, right, top, bottom, near, far) {
    Camera1.call(this);
    this.type = 'OrthographicCamera';
    this.zoom = 1;
    this.view = null;
    this.left = left !== undefined ? left : -1;
    this.right = right !== undefined ? right : 1;
    this.top = top !== undefined ? top : 1;
    this.bottom = bottom !== undefined ? bottom : -1;
    this.near = near !== undefined ? near : 0.1;
    this.far = far !== undefined ? far : 2000;
    this.updateProjectionMatrix();
}
OrthographicCamera.prototype = Object.assign(Object.create(Camera1.prototype), {
    constructor: OrthographicCamera,
    isOrthographicCamera: true,
    copy: function(source, recursive) {
        Camera1.prototype.copy.call(this, source, recursive);
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.near = source.near;
        this.far = source.far;
        this.zoom = source.zoom;
        this.view = source.view === null ? null : Object.assign({
        }, source.view);
        return this;
    },
    setViewOffset: function(fullWidth, fullHeight, x6, y6, width2, height3) {
        if (this.view === null) this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        };
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x6;
        this.view.offsetY = y6;
        this.view.width = width2;
        this.view.height = height3;
        this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
        if (this.view !== null) this.view.enabled = false;
        this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
        const dx = (this.right - this.left) / (2 * this.zoom);
        const dy = (this.top - this.bottom) / (2 * this.zoom);
        const cx = (this.right + this.left) / 2;
        const cy = (this.top + this.bottom) / 2;
        let left = cx - dx;
        let right = cx + dx;
        let top = cy + dy;
        let bottom = cy - dy;
        if (this.view !== null && this.view.enabled) {
            const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
            const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            left += scaleW * this.view.offsetX;
            right = left + scaleW * this.view.width;
            top -= scaleH * this.view.offsetY;
            bottom = top - scaleH * this.view.height;
        }
        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(meta) {
        const data = Object3D1.prototype.toJSON.call(this, meta);
        data.object.zoom = this.zoom;
        data.object.left = this.left;
        data.object.right = this.right;
        data.object.top = this.top;
        data.object.bottom = this.bottom;
        data.object.near = this.near;
        data.object.far = this.far;
        if (this.view !== null) data.object.view = Object.assign({
        }, this.view);
        return data;
    }
});
const OrthographicCamera1 = OrthographicCamera;
function DirectionalLightShadow() {
    LightShadow1.call(this, new OrthographicCamera1(-5, 5, 5, -5, 0.5, 500));
}
DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow1.prototype), {
    constructor: DirectionalLightShadow,
    isDirectionalLightShadow: true,
    updateMatrices: function(light) {
        LightShadow1.prototype.updateMatrices.call(this, light);
    }
});
const DirectionalLightShadow1 = DirectionalLightShadow;
function DirectionalLight(color1, intensity) {
    Light1.call(this, color1, intensity);
    this.type = 'DirectionalLight';
    this.position.copy(Object3D1.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D1();
    this.shadow = new DirectionalLightShadow1();
}
DirectionalLight.prototype = Object.assign(Object.create(Light1.prototype), {
    constructor: DirectionalLight,
    isDirectionalLight: true,
    copy: function(source) {
        Light1.prototype.copy.call(this, source);
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    }
});
const DirectionalLight1 = DirectionalLight;
function AmbientLight(color1, intensity) {
    Light1.call(this, color1, intensity);
    this.type = 'AmbientLight';
    this.castShadow = undefined;
}
AmbientLight.prototype = Object.assign(Object.create(Light1.prototype), {
    constructor: AmbientLight,
    isAmbientLight: true
});
const AmbientLight1 = AmbientLight;
function RectAreaLight(color1, intensity, width2, height3) {
    Light1.call(this, color1, intensity);
    this.type = 'RectAreaLight';
    this.width = width2 !== undefined ? width2 : 10;
    this.height = height3 !== undefined ? height3 : 10;
}
RectAreaLight.prototype = Object.assign(Object.create(Light1.prototype), {
    constructor: RectAreaLight,
    isRectAreaLight: true,
    copy: function(source) {
        Light1.prototype.copy.call(this, source);
        this.width = source.width;
        this.height = source.height;
        return this;
    },
    toJSON: function(meta) {
        const data = Light1.prototype.toJSON.call(this, meta);
        data.object.width = this.width;
        data.object.height = this.height;
        return data;
    }
});
const RectAreaLight1 = RectAreaLight;
/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */
// 3-band SH defined by 9 coefficients
function SphericalHarmonics3() {
    this.coefficients = [];
    for(let i7 = 0; i7 < 9; i7++)this.coefficients.push(new Vector31());
}
Object.assign(SphericalHarmonics3.prototype, {
    isSphericalHarmonics3: true,
    set: function(coefficients) {
        for(let i7 = 0; i7 < 9; i7++)this.coefficients[i7].copy(coefficients[i7]);
        return this;
    },
    zero: function() {
        for(let i7 = 0; i7 < 9; i7++)this.coefficients[i7].set(0, 0, 0);
        return this;
    },
    // get the radiance in the direction of the normal
    // target is a Vector3
    getAt: function(normal6, target) {
        // normal is assumed to be unit length
        const x6 = normal6.x, y6 = normal6.y, z5 = normal6.z;
        const coeff = this.coefficients;
        // band 0
        target.copy(coeff[0]).multiplyScalar(0.282095);
        // band 1
        target.addScaledVector(coeff[1], 0.488603 * y6);
        target.addScaledVector(coeff[2], 0.488603 * z5);
        target.addScaledVector(coeff[3], 0.488603 * x6);
        // band 2
        target.addScaledVector(coeff[4], 1.092548 * (x6 * y6));
        target.addScaledVector(coeff[5], 1.092548 * (y6 * z5));
        target.addScaledVector(coeff[6], 0.315392 * (3 * z5 * z5 - 1));
        target.addScaledVector(coeff[7], 1.092548 * (x6 * z5));
        target.addScaledVector(coeff[8], 0.546274 * (x6 * x6 - y6 * y6));
        return target;
    },
    // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
    // target is a Vector3
    // https://graphics.stanford.edu/papers/envmap/envmap.pdf
    getIrradianceAt: function(normal6, target) {
        // normal is assumed to be unit length
        const x6 = normal6.x, y6 = normal6.y, z5 = normal6.z;
        const coeff = this.coefficients;
        // band 0
        target.copy(coeff[0]).multiplyScalar(0.886227); //  * 0.282095
        // band 1
        target.addScaledVector(coeff[1], 1.023328 * y6); // ( 2 *  / 3 ) * 0.488603
        target.addScaledVector(coeff[2], 1.023328 * z5);
        target.addScaledVector(coeff[3], 1.023328 * x6);
        // band 2
        target.addScaledVector(coeff[4], 0.858086 * x6 * y6); // (  / 4 ) * 1.092548
        target.addScaledVector(coeff[5], 0.858086 * y6 * z5);
        target.addScaledVector(coeff[6], 0.743125 * z5 * z5 - 0.247708); // (  / 4 ) * 0.315392 * 3
        target.addScaledVector(coeff[7], 0.858086 * x6 * z5);
        target.addScaledVector(coeff[8], 0.429043 * (x6 * x6 - y6 * y6)); // (  / 4 ) * 0.546274
        return target;
    },
    add: function(sh) {
        for(let i7 = 0; i7 < 9; i7++)this.coefficients[i7].add(sh.coefficients[i7]);
        return this;
    },
    addScaledSH: function(sh, s1) {
        for(let i7 = 0; i7 < 9; i7++)this.coefficients[i7].addScaledVector(sh.coefficients[i7], s1);
        return this;
    },
    scale: function(s1) {
        for(let i7 = 0; i7 < 9; i7++)this.coefficients[i7].multiplyScalar(s1);
        return this;
    },
    lerp: function(sh, alpha) {
        for(let i7 = 0; i7 < 9; i7++)this.coefficients[i7].lerp(sh.coefficients[i7], alpha);
        return this;
    },
    equals: function(sh) {
        for(let i7 = 0; i7 < 9; i7++)if (!this.coefficients[i7].equals(sh.coefficients[i7])) return false;
        return true;
    },
    copy: function(sh) {
        return this.set(sh.coefficients);
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        const coefficients = this.coefficients;
        for(let i7 = 0; i7 < 9; i7++)coefficients[i7].fromArray(array, offset + i7 * 3);
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        const coefficients = this.coefficients;
        for(let i7 = 0; i7 < 9; i7++)coefficients[i7].toArray(array, offset + i7 * 3);
        return array;
    }
});
Object.assign(SphericalHarmonics3, {
    // evaluate the basis functions
    // shBasis is an Array[ 9 ]
    getBasisAt: function(normal6, shBasis) {
        // normal is assumed to be unit length
        const x6 = normal6.x, y6 = normal6.y, z5 = normal6.z;
        // band 0
        shBasis[0] = 0.282095;
        // band 1
        shBasis[1] = 0.488603 * y6;
        shBasis[2] = 0.488603 * z5;
        shBasis[3] = 0.488603 * x6;
        // band 2
        shBasis[4] = 1.092548 * x6 * y6;
        shBasis[5] = 1.092548 * y6 * z5;
        shBasis[6] = 0.315392 * (3 * z5 * z5 - 1);
        shBasis[7] = 1.092548 * x6 * z5;
        shBasis[8] = 0.546274 * (x6 * x6 - y6 * y6);
    }
});
const SphericalHarmonics31 = SphericalHarmonics3;
function LightProbe(sh, intensity) {
    Light1.call(this, undefined, intensity);
    this.type = 'LightProbe';
    this.sh = sh !== undefined ? sh : new SphericalHarmonics31();
}
LightProbe.prototype = Object.assign(Object.create(Light1.prototype), {
    constructor: LightProbe,
    isLightProbe: true,
    copy: function(source) {
        Light1.prototype.copy.call(this, source);
        this.sh.copy(source.sh);
        return this;
    },
    fromJSON: function(json) {
        this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
        this.sh.fromArray(json.sh);
        return this;
    },
    toJSON: function(meta) {
        const data = Light1.prototype.toJSON.call(this, meta);
        data.object.sh = this.sh.toArray();
        return data;
    }
});
const LightProbe1 = LightProbe;
function Scene2() {
    Object3D1.call(this);
    this.type = 'Scene';
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true;
    if (typeof __THREE_DEVTOOLS__ !== 'undefined') __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
        detail: this
    }));
}
Scene2.prototype = Object.assign(Object.create(Object3D1.prototype), {
    constructor: Scene2,
    isScene: true,
    copy: function(source, recursive) {
        Object3D1.prototype.copy.call(this, source, recursive);
        if (source.background !== null) this.background = source.background.clone();
        if (source.environment !== null) this.environment = source.environment.clone();
        if (source.fog !== null) this.fog = source.fog.clone();
        if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
        this.autoUpdate = source.autoUpdate;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        return this;
    },
    toJSON: function(meta) {
        const data = Object3D1.prototype.toJSON.call(this, meta);
        if (this.background !== null) data.object.background = this.background.toJSON(meta);
        if (this.environment !== null) data.object.environment = this.environment.toJSON(meta);
        if (this.fog !== null) data.object.fog = this.fog.toJSON();
        return data;
    }
});
const Scene1 = Scene2;
const Materials = function() {
    function ShadowMaterial1(parameters1) {
        Material1.call(this);
        this.type = 'ShadowMaterial';
        this.color = new Color1(0);
        this.transparent = true;
        this.setValues(parameters1);
    }
    ShadowMaterial1.prototype = Object.create(Material1.prototype);
    ShadowMaterial1.prototype.constructor = ShadowMaterial1;
    ShadowMaterial1.prototype.isShadowMaterial = true;
    ShadowMaterial1.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.color.copy(source.color);
        return this;
    };
    function SpriteMaterial3(parameters1) {
        Material1.call(this);
        this.type = 'SpriteMaterial';
        this.color = new Color1(16777215);
        this.map = null;
        this.alphaMap = null;
        this.rotation = 0;
        this.sizeAttenuation = true;
        this.transparent = true;
        this.setValues(parameters1);
    }
    SpriteMaterial3.prototype = Object.create(Material1.prototype);
    SpriteMaterial3.prototype.constructor = SpriteMaterial3;
    SpriteMaterial3.prototype.isSpriteMaterial = true;
    SpriteMaterial3.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.rotation = source.rotation;
        this.sizeAttenuation = source.sizeAttenuation;
        return this;
    };
    const SpriteMaterial1 = SpriteMaterial3;
    function RawShaderMaterial1(parameters1) {
        ShaderMaterial1.call(this, parameters1);
        this.type = 'RawShaderMaterial';
    }
    RawShaderMaterial1.prototype = Object.create(ShaderMaterial1.prototype);
    RawShaderMaterial1.prototype.constructor = RawShaderMaterial1;
    RawShaderMaterial1.prototype.isRawShaderMaterial = true;
    const default_vertex = `\nvoid main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`;
    const default_fragment = `\nvoid main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}\n`;
    function ShaderMaterial5(parameters1) {
        Material1.call(this);
        this.type = 'ShaderMaterial';
        this.defines = {
        };
        this.uniforms = {
        };
        this.vertexShader = default_vertex;
        this.fragmentShader = default_fragment;
        this.linewidth = 1;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.lights = false;
        this.clipping = false;
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.extensions = {
            derivatives: false,
            fragDepth: false,
            drawBuffers: false,
            shaderTextureLOD: false
        };
        this.defaultAttributeValues = {
            'color': [
                1,
                1,
                1
            ],
            'uv': [
                0,
                0
            ],
            'uv2': [
                0,
                0
            ]
        };
        this.index0AttributeName = undefined;
        this.uniformsNeedUpdate = false;
        if (parameters1 !== undefined) {
            if (parameters1.attributes !== undefined) console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
            this.setValues(parameters1);
        }
    }
    ShaderMaterial5.prototype = Object.create(Material1.prototype);
    ShaderMaterial5.prototype.constructor = ShaderMaterial5;
    ShaderMaterial5.prototype.isShaderMaterial = true;
    ShaderMaterial5.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.fragmentShader = source.fragmentShader;
        this.vertexShader = source.vertexShader;
        this.uniforms = cloneUniforms(source.uniforms);
        this.defines = Object.assign({
        }, source.defines);
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.lights = source.lights;
        this.clipping = source.clipping;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        this.extensions = Object.assign({
        }, source.extensions);
        return this;
    };
    ShaderMaterial5.prototype.toJSON = function(meta) {
        const data = Material1.prototype.toJSON.call(this, meta);
        data.uniforms = {
        };
        for(const name in this.uniforms){
            const uniform = this.uniforms[name];
            const value = uniform.value;
            if (value && value.isTexture) data.uniforms[name] = {
                type: 't',
                value: value.toJSON(meta).uuid
            };
            else if (value && value.isColor) data.uniforms[name] = {
                type: 'c',
                value: value.getHex()
            };
            else if (value && value.isVector2) data.uniforms[name] = {
                type: 'v2',
                value: value.toArray()
            };
            else if (value && value.isVector3) data.uniforms[name] = {
                type: 'v3',
                value: value.toArray()
            };
            else if (value && value.isVector4) data.uniforms[name] = {
                type: 'v4',
                value: value.toArray()
            };
            else if (value && value.isMatrix3) data.uniforms[name] = {
                type: 'm3',
                value: value.toArray()
            };
            else if (value && value.isMatrix4) data.uniforms[name] = {
                type: 'm4',
                value: value.toArray()
            };
            else data.uniforms[name] = {
                value: value
            };
        }
        if (Object.keys(this.defines).length > 0) data.defines = this.defines;
        data.vertexShader = this.vertexShader;
        data.fragmentShader = this.fragmentShader;
        const extensions = {
        };
        for(const key in this.extensions)if (this.extensions[key] === true) extensions[key] = true;
        if (Object.keys(extensions).length > 0) data.extensions = extensions;
        return data;
    };
    const ShaderMaterial1 = ShaderMaterial5;
    function PointsMaterial3(parameters1) {
        Material1.call(this);
        this.type = 'PointsMaterial';
        this.color = new Color1(16777215);
        this.map = null;
        this.alphaMap = null;
        this.size = 1;
        this.sizeAttenuation = true;
        this.morphTargets = false;
        this.setValues(parameters1);
    }
    PointsMaterial3.prototype = Object.create(Material1.prototype);
    PointsMaterial3.prototype.constructor = PointsMaterial3;
    PointsMaterial3.prototype.isPointsMaterial = true;
    PointsMaterial3.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.size = source.size;
        this.sizeAttenuation = source.sizeAttenuation;
        this.morphTargets = source.morphTargets;
        return this;
    };
    const PointsMaterial1 = PointsMaterial3;
    function MeshPhysicalMaterial1(parameters1) {
        MeshStandardMaterial1.call(this);
        this.defines = {
            'STANDARD': '',
            'PHYSICAL': ''
        };
        this.type = 'MeshPhysicalMaterial';
        this.clearcoat = 0;
        this.clearcoatMap = null;
        this.clearcoatRoughness = 0;
        this.clearcoatRoughnessMap = null;
        this.clearcoatNormalScale = new Vector21(1, 1);
        this.clearcoatNormalMap = null;
        this.reflectivity = 0.5;
        this.sheen = null;
        this.transmission = 0;
        this.transmissionMap = null;
        this.setValues(parameters1);
    }
    MeshPhysicalMaterial1.prototype = Object.create(MeshStandardMaterial1.prototype);
    MeshPhysicalMaterial1.prototype.constructor = MeshPhysicalMaterial1;
    MeshPhysicalMaterial1.prototype.isMeshPhysicalMaterial = true;
    MeshPhysicalMaterial1.prototype.copy = function(source) {
        MeshStandardMaterial1.prototype.copy.call(this, source);
        this.defines = {
            'STANDARD': '',
            'PHYSICAL': ''
        };
        this.clearcoat = source.clearcoat;
        this.clearcoatMap = source.clearcoatMap;
        this.clearcoatRoughness = source.clearcoatRoughness;
        this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
        this.clearcoatNormalMap = source.clearcoatNormalMap;
        this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
        this.reflectivity = source.reflectivity;
        if (source.sheen) this.sheen = (this.sheen || new Color1()).copy(source.sheen);
        else this.sheen = null;
        this.transmission = source.transmission;
        this.transmissionMap = source.transmissionMap;
        return this;
    };
    function MeshStandardMaterial5(parameters1) {
        Material1.call(this);
        this.defines = {
            'STANDARD': ''
        };
        this.type = 'MeshStandardMaterial';
        this.color = new Color1(16777215);
        this.roughness = 1;
        this.metalness = 0;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color1(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector21(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.roughnessMap = null;
        this.metalnessMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.envMapIntensity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.vertexTangents = false;
        this.setValues(parameters1);
    }
    MeshStandardMaterial5.prototype = Object.create(Material1.prototype);
    MeshStandardMaterial5.prototype.constructor = MeshStandardMaterial5;
    MeshStandardMaterial5.prototype.isMeshStandardMaterial = true;
    MeshStandardMaterial5.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.defines = {
            'STANDARD': ''
        };
        this.color.copy(source.color);
        this.roughness = source.roughness;
        this.metalness = source.metalness;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.roughnessMap = source.roughnessMap;
        this.metalnessMap = source.metalnessMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.envMapIntensity = source.envMapIntensity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        this.vertexTangents = source.vertexTangents;
        return this;
    };
    const MeshStandardMaterial1 = MeshStandardMaterial5;
    function MeshPhongMaterial1(parameters1) {
        Material1.call(this);
        this.type = 'MeshPhongMaterial';
        this.color = new Color1(16777215);
        this.specular = new Color1(1118481);
        this.shininess = 30;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color1(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector21(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters1);
    }
    MeshPhongMaterial1.prototype = Object.create(Material1.prototype);
    MeshPhongMaterial1.prototype.constructor = MeshPhongMaterial1;
    MeshPhongMaterial1.prototype.isMeshPhongMaterial = true;
    MeshPhongMaterial1.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.specular.copy(source.specular);
        this.shininess = source.shininess;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    function MeshToonMaterial1(parameters1) {
        Material1.call(this);
        this.defines = {
            'TOON': ''
        };
        this.type = 'MeshToonMaterial';
        this.color = new Color1(16777215);
        this.map = null;
        this.gradientMap = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color1(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector21(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.alphaMap = null;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters1);
    }
    MeshToonMaterial1.prototype = Object.create(Material1.prototype);
    MeshToonMaterial1.prototype.constructor = MeshToonMaterial1;
    MeshToonMaterial1.prototype.isMeshToonMaterial = true;
    MeshToonMaterial1.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.gradientMap = source.gradientMap;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    function MeshNormalMaterial1(parameters1) {
        Material1.call(this);
        this.type = 'MeshNormalMaterial';
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector21(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters1);
    }
    MeshNormalMaterial1.prototype = Object.create(Material1.prototype);
    MeshNormalMaterial1.prototype.constructor = MeshNormalMaterial1;
    MeshNormalMaterial1.prototype.isMeshNormalMaterial = true;
    MeshNormalMaterial1.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    function MeshLambertMaterial1(parameters1) {
        Material1.call(this);
        this.type = 'MeshLambertMaterial';
        this.color = new Color1(16777215);
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color1(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters1);
    }
    MeshLambertMaterial1.prototype = Object.create(Material1.prototype);
    MeshLambertMaterial1.prototype.constructor = MeshLambertMaterial1;
    MeshLambertMaterial1.prototype.isMeshLambertMaterial = true;
    MeshLambertMaterial1.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    function MeshDepthMaterial3(parameters1) {
        Material1.call(this);
        this.type = 'MeshDepthMaterial';
        this.depthPacking = BasicDepthPacking;
        this.skinning = false;
        this.morphTargets = false;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.setValues(parameters1);
    }
    MeshDepthMaterial3.prototype = Object.create(Material1.prototype);
    MeshDepthMaterial3.prototype.constructor = MeshDepthMaterial3;
    MeshDepthMaterial3.prototype.isMeshDepthMaterial = true;
    MeshDepthMaterial3.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.depthPacking = source.depthPacking;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        return this;
    };
    const MeshDepthMaterial1 = MeshDepthMaterial3;
    function MeshDistanceMaterial3(parameters1) {
        Material1.call(this);
        this.type = 'MeshDistanceMaterial';
        this.referencePosition = new Vector31();
        this.nearDistance = 1;
        this.farDistance = 1000;
        this.skinning = false;
        this.morphTargets = false;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.fog = false;
        this.setValues(parameters1);
    }
    MeshDistanceMaterial3.prototype = Object.create(Material1.prototype);
    MeshDistanceMaterial3.prototype.constructor = MeshDistanceMaterial3;
    MeshDistanceMaterial3.prototype.isMeshDistanceMaterial = true;
    MeshDistanceMaterial3.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.referencePosition.copy(source.referencePosition);
        this.nearDistance = source.nearDistance;
        this.farDistance = source.farDistance;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        return this;
    };
    const MeshDistanceMaterial1 = MeshDistanceMaterial3;
    function MeshBasicMaterial3(parameters1) {
        Material1.call(this);
        this.type = 'MeshBasicMaterial';
        this.color = new Color1(16777215);
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.setValues(parameters1);
    }
    MeshBasicMaterial3.prototype = Object.create(Material1.prototype);
    MeshBasicMaterial3.prototype.constructor = MeshBasicMaterial3;
    MeshBasicMaterial3.prototype.isMeshBasicMaterial = true;
    MeshBasicMaterial3.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        return this;
    };
    const MeshBasicMaterial1 = MeshBasicMaterial3;
    function MeshMatcapMaterial1(parameters1) {
        Material1.call(this);
        this.defines = {
            'MATCAP': ''
        };
        this.type = 'MeshMatcapMaterial';
        this.color = new Color1(16777215);
        this.matcap = null;
        this.map = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector21(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.alphaMap = null;
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters1);
    }
    MeshMatcapMaterial1.prototype = Object.create(Material1.prototype);
    MeshMatcapMaterial1.prototype.constructor = MeshMatcapMaterial1;
    MeshMatcapMaterial1.prototype.isMeshMatcapMaterial = true;
    MeshMatcapMaterial1.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.defines = {
            'MATCAP': ''
        };
        this.color.copy(source.color);
        this.matcap = source.matcap;
        this.map = source.map;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    function LineDashedMaterial1(parameters1) {
        LineBasicMaterial1.call(this);
        this.type = 'LineDashedMaterial';
        this.scale = 1;
        this.dashSize = 3;
        this.gapSize = 1;
        this.setValues(parameters1);
    }
    LineDashedMaterial1.prototype = Object.create(LineBasicMaterial1.prototype);
    LineDashedMaterial1.prototype.constructor = LineDashedMaterial1;
    LineDashedMaterial1.prototype.isLineDashedMaterial = true;
    LineDashedMaterial1.prototype.copy = function(source) {
        LineBasicMaterial1.prototype.copy.call(this, source);
        this.scale = source.scale;
        this.dashSize = source.dashSize;
        this.gapSize = source.gapSize;
        return this;
    };
    function LineBasicMaterial5(parameters1) {
        Material1.call(this);
        this.type = 'LineBasicMaterial';
        this.color = new Color1(16777215);
        this.linewidth = 1;
        this.linecap = 'round';
        this.linejoin = 'round';
        this.morphTargets = false;
        this.setValues(parameters1);
    }
    LineBasicMaterial5.prototype = Object.create(Material1.prototype);
    LineBasicMaterial5.prototype.constructor = LineBasicMaterial5;
    LineBasicMaterial5.prototype.isLineBasicMaterial = true;
    LineBasicMaterial5.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.linewidth = source.linewidth;
        this.linecap = source.linecap;
        this.linejoin = source.linejoin;
        this.morphTargets = source.morphTargets;
        return this;
    };
    const LineBasicMaterial1 = LineBasicMaterial5;
    let materialId = 0;
    function Material5() {
        Object.defineProperty(this, 'id', {
            value: materialId++
        });
        this.uuid = MathUtils1.generateUUID();
        this.name = '';
        this.type = 'Material';
        this.fog = true;
        this.blending = NormalBlending;
        this.side = FrontSide;
        this.flatShading = false;
        this.vertexColors = false;
        this.opacity = 1;
        this.transparent = false;
        this.blendSrc = SrcAlphaFactor;
        this.blendDst = OneMinusSrcAlphaFactor;
        this.blendEquation = AddEquation;
        this.blendSrcAlpha = null;
        this.blendDstAlpha = null;
        this.blendEquationAlpha = null;
        this.depthFunc = LessEqualDepth;
        this.depthTest = true;
        this.depthWrite = true;
        this.stencilWriteMask = 255;
        this.stencilFunc = AlwaysStencilFunc;
        this.stencilRef = 0;
        this.stencilFuncMask = 255;
        this.stencilFail = KeepStencilOp;
        this.stencilZFail = KeepStencilOp;
        this.stencilZPass = KeepStencilOp;
        this.stencilWrite = false;
        this.clippingPlanes = null;
        this.clipIntersection = false;
        this.clipShadows = false;
        this.shadowSide = null;
        this.colorWrite = true;
        this.precision = null;
        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;
        this.dithering = false;
        this.alphaTest = 0;
        this.premultipliedAlpha = false;
        this.visible = true;
        this.toneMapped = true;
        this.userData = {
        };
        this.version = 0;
    }
    Material5.prototype = Object.assign(Object.create(EventDispatcher1.prototype), {
        constructor: Material5,
        isMaterial: true,
        onBeforeCompile: function() {
        },
        customProgramCacheKey: function() {
            return this.onBeforeCompile.toString();
        },
        setValues: function(values) {
            if (values === undefined) return;
            for(const key in values){
                const newValue = values[key];
                if (newValue === undefined) {
                    console.warn("THREE.Material: '" + key + "' parameter is undefined.");
                    continue;
                }
                if (key === 'shading') {
                    console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                    this.flatShading = newValue === FlatShading ? true : false;
                    continue;
                }
                const currentValue = this[key];
                if (currentValue === undefined) {
                    console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                    continue;
                }
                if (currentValue && currentValue.isColor) currentValue.set(newValue);
                else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) currentValue.copy(newValue);
                else this[key] = newValue;
            }
        },
        toJSON: function(meta) {
            const isRoot = meta === undefined || typeof meta === 'string';
            if (isRoot) meta = {
                textures: {
                },
                images: {
                }
            };
            const data = {
                metadata: {
                    version: 4.5,
                    type: 'Material',
                    generator: 'Material.toJSON'
                }
            };
            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== '') data.name = this.name;
            if (this.color && this.color.isColor) data.color = this.color.getHex();
            if (this.roughness !== undefined) data.roughness = this.roughness;
            if (this.metalness !== undefined) data.metalness = this.metalness;
            if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();
            if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
            if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
            if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
            if (this.shininess !== undefined) data.shininess = this.shininess;
            if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
            if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;
            if (this.clearcoatMap && this.clearcoatMap.isTexture) data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
            if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
            if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
                data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
                data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
            }
            if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
            if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
            if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
            if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;
            if (this.aoMap && this.aoMap.isTexture) {
                data.aoMap = this.aoMap.toJSON(meta).uuid;
                data.aoMapIntensity = this.aoMapIntensity;
            }
            if (this.bumpMap && this.bumpMap.isTexture) {
                data.bumpMap = this.bumpMap.toJSON(meta).uuid;
                data.bumpScale = this.bumpScale;
            }
            if (this.normalMap && this.normalMap.isTexture) {
                data.normalMap = this.normalMap.toJSON(meta).uuid;
                data.normalMapType = this.normalMapType;
                data.normalScale = this.normalScale.toArray();
            }
            if (this.displacementMap && this.displacementMap.isTexture) {
                data.displacementMap = this.displacementMap.toJSON(meta).uuid;
                data.displacementScale = this.displacementScale;
                data.displacementBias = this.displacementBias;
            }
            if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
            if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
            if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
            if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
            if (this.envMap && this.envMap.isTexture) {
                data.envMap = this.envMap.toJSON(meta).uuid;
                data.reflectivity = this.reflectivity;
                data.refractionRatio = this.refractionRatio;
                if (this.combine !== undefined) data.combine = this.combine;
                if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
            }
            if (this.gradientMap && this.gradientMap.isTexture) data.gradientMap = this.gradientMap.toJSON(meta).uuid;
            if (this.size !== undefined) data.size = this.size;
            if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
            if (this.blending !== NormalBlending) data.blending = this.blending;
            if (this.flatShading === true) data.flatShading = this.flatShading;
            if (this.side !== FrontSide) data.side = this.side;
            if (this.vertexColors) data.vertexColors = true;
            if (this.opacity < 1) data.opacity = this.opacity;
            if (this.transparent === true) data.transparent = this.transparent;
            data.depthFunc = this.depthFunc;
            data.depthTest = this.depthTest;
            data.depthWrite = this.depthWrite;
            data.stencilWrite = this.stencilWrite;
            data.stencilWriteMask = this.stencilWriteMask;
            data.stencilFunc = this.stencilFunc;
            data.stencilRef = this.stencilRef;
            data.stencilFuncMask = this.stencilFuncMask;
            data.stencilFail = this.stencilFail;
            data.stencilZFail = this.stencilZFail;
            data.stencilZPass = this.stencilZPass;
            if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
            if (this.polygonOffset === true) data.polygonOffset = true;
            if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
            if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
            if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
            if (this.dashSize !== undefined) data.dashSize = this.dashSize;
            if (this.gapSize !== undefined) data.gapSize = this.gapSize;
            if (this.scale !== undefined) data.scale = this.scale;
            if (this.dithering === true) data.dithering = true;
            if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
            if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
            if (this.wireframe === true) data.wireframe = this.wireframe;
            if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
            if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
            if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
            if (this.morphTargets === true) data.morphTargets = true;
            if (this.morphNormals === true) data.morphNormals = true;
            if (this.skinning === true) data.skinning = true;
            if (this.visible === false) data.visible = false;
            if (this.toneMapped === false) data.toneMapped = false;
            if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData;
            function extractFromCache(cache) {
                const values = [];
                for(const key in cache){
                    const data1 = cache[key];
                    delete data1.metadata;
                    values.push(data1);
                }
                return values;
            }
            if (isRoot) {
                const textures = extractFromCache(meta.textures);
                const images = extractFromCache(meta.images);
                if (textures.length > 0) data.textures = textures;
                if (images.length > 0) data.images = images;
            }
            return data;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            this.name = source.name;
            this.fog = source.fog;
            this.blending = source.blending;
            this.side = source.side;
            this.flatShading = source.flatShading;
            this.vertexColors = source.vertexColors;
            this.opacity = source.opacity;
            this.transparent = source.transparent;
            this.blendSrc = source.blendSrc;
            this.blendDst = source.blendDst;
            this.blendEquation = source.blendEquation;
            this.blendSrcAlpha = source.blendSrcAlpha;
            this.blendDstAlpha = source.blendDstAlpha;
            this.blendEquationAlpha = source.blendEquationAlpha;
            this.depthFunc = source.depthFunc;
            this.depthTest = source.depthTest;
            this.depthWrite = source.depthWrite;
            this.stencilWriteMask = source.stencilWriteMask;
            this.stencilFunc = source.stencilFunc;
            this.stencilRef = source.stencilRef;
            this.stencilFuncMask = source.stencilFuncMask;
            this.stencilFail = source.stencilFail;
            this.stencilZFail = source.stencilZFail;
            this.stencilZPass = source.stencilZPass;
            this.stencilWrite = source.stencilWrite;
            const srcPlanes = source.clippingPlanes;
            let dstPlanes = null;
            if (srcPlanes !== null) {
                const n = srcPlanes.length;
                dstPlanes = new Array(n);
                for(let i7 = 0; i7 !== n; ++i7)dstPlanes[i7] = srcPlanes[i7].clone();
            }
            this.clippingPlanes = dstPlanes;
            this.clipIntersection = source.clipIntersection;
            this.clipShadows = source.clipShadows;
            this.shadowSide = source.shadowSide;
            this.colorWrite = source.colorWrite;
            this.precision = source.precision;
            this.polygonOffset = source.polygonOffset;
            this.polygonOffsetFactor = source.polygonOffsetFactor;
            this.polygonOffsetUnits = source.polygonOffsetUnits;
            this.dithering = source.dithering;
            this.alphaTest = source.alphaTest;
            this.premultipliedAlpha = source.premultipliedAlpha;
            this.visible = source.visible;
            this.toneMapped = source.toneMapped;
            this.userData = JSON.parse(JSON.stringify(source.userData));
            return this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: 'dispose'
            });
        }
    });
    Object.defineProperty(Material5.prototype, 'needsUpdate', {
        set: function(value) {
            if (value === true) this.version++;
        }
    });
    const Material1 = Material5;
}();
function MaterialLoader(manager) {
    Loader1.call(this, manager);
    this.textures = {
    };
}
MaterialLoader.prototype = Object.assign(Object.create(Loader1.prototype), {
    constructor: MaterialLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope3 = this;
        const loader = new FileLoader1(scope3.manager);
        loader.setPath(scope3.path);
        loader.setRequestHeader(scope3.requestHeader);
        loader.load(url, function(text1) {
            try {
                onLoad(scope3.parse(JSON.parse(text1)));
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope3.manager.itemError(url);
            }
        }, onProgress, onError);
    },
    parse: function(json) {
        const textures = this.textures;
        function getTexture(name) {
            if (textures[name] === undefined) console.warn('THREE.MaterialLoader: Undefined texture', name);
            return textures[name];
        }
        const material = new Materials[json.type]();
        if (json.uuid !== undefined) material.uuid = json.uuid;
        if (json.name !== undefined) material.name = json.name;
        if (json.color !== undefined) material.color.setHex(json.color);
        if (json.roughness !== undefined) material.roughness = json.roughness;
        if (json.metalness !== undefined) material.metalness = json.metalness;
        if (json.sheen !== undefined) material.sheen = new Color1().setHex(json.sheen);
        if (json.emissive !== undefined) material.emissive.setHex(json.emissive);
        if (json.specular !== undefined) material.specular.setHex(json.specular);
        if (json.shininess !== undefined) material.shininess = json.shininess;
        if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
        if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
        if (json.fog !== undefined) material.fog = json.fog;
        if (json.flatShading !== undefined) material.flatShading = json.flatShading;
        if (json.blending !== undefined) material.blending = json.blending;
        if (json.combine !== undefined) material.combine = json.combine;
        if (json.side !== undefined) material.side = json.side;
        if (json.opacity !== undefined) material.opacity = json.opacity;
        if (json.transparent !== undefined) material.transparent = json.transparent;
        if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
        if (json.depthTest !== undefined) material.depthTest = json.depthTest;
        if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
        if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
        if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
        if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
        if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
        if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
        if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
        if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
        if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
        if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
        if (json.wireframe !== undefined) material.wireframe = json.wireframe;
        if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
        if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
        if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
        if (json.rotation !== undefined) material.rotation = json.rotation;
        if (json.linewidth !== 1) material.linewidth = json.linewidth;
        if (json.dashSize !== undefined) material.dashSize = json.dashSize;
        if (json.gapSize !== undefined) material.gapSize = json.gapSize;
        if (json.scale !== undefined) material.scale = json.scale;
        if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
        if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
        if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
        if (json.skinning !== undefined) material.skinning = json.skinning;
        if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
        if (json.morphNormals !== undefined) material.morphNormals = json.morphNormals;
        if (json.dithering !== undefined) material.dithering = json.dithering;
        if (json.vertexTangents !== undefined) material.vertexTangents = json.vertexTangents;
        if (json.visible !== undefined) material.visible = json.visible;
        if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
        if (json.userData !== undefined) material.userData = json.userData;
        if (json.vertexColors !== undefined) {
            if (typeof json.vertexColors === 'number') material.vertexColors = json.vertexColors > 0 ? true : false;
            else material.vertexColors = json.vertexColors;
        }
        // Shader Material
        if (json.uniforms !== undefined) for(const name in json.uniforms){
            const uniform = json.uniforms[name];
            material.uniforms[name] = {
            };
            switch(uniform.type){
                case 't':
                    material.uniforms[name].value = getTexture(uniform.value);
                    break;
                case 'c':
                    material.uniforms[name].value = new Color1().setHex(uniform.value);
                    break;
                case 'v2':
                    material.uniforms[name].value = new Vector21().fromArray(uniform.value);
                    break;
                case 'v3':
                    material.uniforms[name].value = new Vector31().fromArray(uniform.value);
                    break;
                case 'v4':
                    material.uniforms[name].value = new Vector41().fromArray(uniform.value);
                    break;
                case 'm3':
                    material.uniforms[name].value = new Matrix31().fromArray(uniform.value);
                    break;
                case 'm4':
                    material.uniforms[name].value = new Matrix41().fromArray(uniform.value);
                    break;
                default:
                    material.uniforms[name].value = uniform.value;
            }
        }
        if (json.defines !== undefined) material.defines = json.defines;
        if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
        if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
        if (json.extensions !== undefined) for(const key in json.extensions)material.extensions[key] = json.extensions[key];
        // Deprecated
        if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading
        // for PointsMaterial
        if (json.size !== undefined) material.size = json.size;
        if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;
        // maps
        if (json.map !== undefined) material.map = getTexture(json.map);
        if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
        if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
        if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
        if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
        if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
        if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;
        if (json.normalScale !== undefined) {
            let normalScale = json.normalScale;
            if (Array.isArray(normalScale) === false) // Blender exporter used to export a scalar. See #7459
            normalScale = [
                normalScale,
                normalScale
            ];
            material.normalScale = new Vector21().fromArray(normalScale);
        }
        if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
        if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
        if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
        if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
        if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
        if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
        if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
        if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
        if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
        if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
        if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
        if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
        if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
        if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
        if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
        if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
        if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
        if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
        if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
        if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
        if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector21().fromArray(json.clearcoatNormalScale);
        if (json.transmission !== undefined) material.transmission = json.transmission;
        if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
        return material;
    },
    setTextures: function(value) {
        this.textures = value;
        return this;
    }
});
const MaterialLoader1 = MaterialLoader;
const LoaderUtils = {
    decodeText: function(array) {
        if (typeof TextDecoder !== 'undefined') return new TextDecoder().decode(array);
        // Avoid the String.fromCharCode.apply(null, array) shortcut, which
        // throws a "maximum call stack size exceeded" error for large arrays.
        let s1 = '';
        for(let i7 = 0, il = array.length; i7 < il; i7++)// Implicitly assumes little-endian.
        s1 += String.fromCharCode(array[i7]);
        try {
            // merges multi-byte utf-8 characters.
            return decodeURIComponent(escape(s1));
        } catch (e) {
            return s1;
        }
    },
    extractUrlBase: function(url) {
        const index2 = url.lastIndexOf('/');
        if (index2 === -1) return './';
        return url.substr(0, index2 + 1);
    }
};
const LoaderUtils1 = LoaderUtils;
function InstancedBufferGeometry() {
    BufferGeometry1.call(this);
    this.type = 'InstancedBufferGeometry';
    this.instanceCount = Infinity;
}
InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry1.prototype), {
    constructor: InstancedBufferGeometry,
    isInstancedBufferGeometry: true,
    copy: function(source) {
        BufferGeometry1.prototype.copy.call(this, source);
        this.instanceCount = source.instanceCount;
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    toJSON: function() {
        const data = BufferGeometry1.prototype.toJSON.call(this);
        data.instanceCount = this.instanceCount;
        data.isInstancedBufferGeometry = true;
        return data;
    }
});
const InstancedBufferGeometry1 = InstancedBufferGeometry;
function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
    if (typeof normalized === 'number') {
        console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
    }
    BufferAttribute1.call(this, array, itemSize, normalized);
    this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute1.prototype), {
    constructor: InstancedBufferAttribute,
    isInstancedBufferAttribute: true,
    copy: function(source) {
        BufferAttribute1.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    },
    toJSON: function() {
        const data = BufferAttribute1.prototype.toJSON.call(this);
        data.meshPerAttribute = this.meshPerAttribute;
        data.isInstancedBufferAttribute = true;
        return data;
    }
});
const InstancedBufferAttribute1 = InstancedBufferAttribute;
function BufferGeometryLoader(manager) {
    Loader1.call(this, manager);
}
BufferGeometryLoader.prototype = Object.assign(Object.create(Loader1.prototype), {
    constructor: BufferGeometryLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope3 = this;
        const loader = new FileLoader1(scope3.manager);
        loader.setPath(scope3.path);
        loader.setRequestHeader(scope3.requestHeader);
        loader.load(url, function(text1) {
            try {
                onLoad(scope3.parse(JSON.parse(text1)));
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope3.manager.itemError(url);
            }
        }, onProgress, onError);
    },
    parse: function(json) {
        const interleavedBufferMap = {
        };
        const arrayBufferMap = {
        };
        function getInterleavedBuffer(json1, uuid) {
            if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
            const interleavedBuffers = json1.interleavedBuffers;
            const interleavedBuffer = interleavedBuffers[uuid];
            const buffer = getArrayBuffer(json1, interleavedBuffer.buffer);
            const array = new TYPED_ARRAYS[interleavedBuffer.type](buffer);
            const ib = new InterleavedBuffer1(array, interleavedBuffer.stride);
            ib.uuid = interleavedBuffer.uuid;
            interleavedBufferMap[uuid] = ib;
            return ib;
        }
        function getArrayBuffer(json1, uuid) {
            if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
            const arrayBuffers = json1.arrayBuffers;
            const arrayBuffer = arrayBuffers[uuid];
            const ab = new Uint32Array(arrayBuffer).buffer;
            arrayBufferMap[uuid] = ab;
            return ab;
        }
        const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry1() : new BufferGeometry1();
        const index2 = json.data.index;
        if (index2 !== undefined) {
            const typedArray = new TYPED_ARRAYS[index2.type](index2.array);
            geometry.setIndex(new BufferAttribute1(typedArray, 1));
        }
        const attributes = json.data.attributes;
        for(const key in attributes){
            const attribute = attributes[key];
            let bufferAttribute;
            if (attribute.isInterleavedBufferAttribute) {
                const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                bufferAttribute = new InterleavedBufferAttribute1(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
            } else {
                const typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
                const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute1 : BufferAttribute1;
                bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
            }
            if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
            geometry.setAttribute(key, bufferAttribute);
        }
        const morphAttributes = json.data.morphAttributes;
        if (morphAttributes) for(const key in morphAttributes){
            const attributeArray = morphAttributes[key];
            const array = [];
            for(let i7 = 0, il = attributeArray.length; i7 < il; i7++){
                const attribute = attributeArray[i7];
                let bufferAttribute;
                if (attribute.isInterleavedBufferAttribute) {
                    const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                    bufferAttribute = new InterleavedBufferAttribute1(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
                } else {
                    const typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
                    bufferAttribute = new BufferAttribute1(typedArray, attribute.itemSize, attribute.normalized);
                }
                if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
                array.push(bufferAttribute);
            }
            geometry.morphAttributes[key] = array;
        }
        const morphTargetsRelative = json.data.morphTargetsRelative;
        if (morphTargetsRelative) geometry.morphTargetsRelative = true;
        const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
        if (groups !== undefined) for(let i7 = 0, n = groups.length; i7 !== n; ++i7){
            const group = groups[i7];
            geometry.addGroup(group.start, group.count, group.materialIndex);
        }
        const boundingSphere = json.data.boundingSphere;
        if (boundingSphere !== undefined) {
            const center1 = new Vector31();
            if (boundingSphere.center !== undefined) center1.fromArray(boundingSphere.center);
            geometry.boundingSphere = new Sphere1(center1, boundingSphere.radius);
        }
        if (json.name) geometry.name = json.name;
        if (json.userData) geometry.userData = json.userData;
        return geometry;
    }
});
const TYPED_ARRAYS = {
    Int8Array: Int8Array,
    Uint8Array: Uint8Array,
    // Workaround for IE11 pre KB2929437. See #11440
    Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
    Int16Array: Int16Array,
    Uint16Array: Uint16Array,
    Int32Array: Int32Array,
    Uint32Array: Uint32Array,
    Float32Array: Float32Array,
    Float64Array: Float64Array
};
const BufferGeometryLoader1 = BufferGeometryLoader;
function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    EllipseCurve1.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.type = 'ArcCurve';
}
ArcCurve.prototype = Object.create(EllipseCurve1.prototype);
ArcCurve.prototype.constructor = ArcCurve;
ArcCurve.prototype.isArcCurve = true;
/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */
/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/
function CubicPoly() {
    let c0 = 0, c11 = 0, c2 = 0, c3 = 0;
    /*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
    function init(x0, x11, t0, t11) {
        c0 = x0;
        c11 = t0;
        c2 = -3 * x0 + 3 * x11 - 2 * t0 - t11;
        c3 = 2 * x0 - 2 * x11 + t0 + t11;
    }
    return {
        initCatmullRom: function(x0, x11, x21, x31, tension) {
            init(x11, x21, tension * (x21 - x0), tension * (x31 - x11));
        },
        initNonuniformCatmullRom: function(x0, x11, x21, x31, dt0, dt1, dt2) {
            // compute tangents when parameterized in [t1,t2]
            let t11 = (x11 - x0) / dt0 - (x21 - x0) / (dt0 + dt1) + (x21 - x11) / dt1;
            let t2 = (x21 - x11) / dt1 - (x31 - x11) / (dt1 + dt2) + (x31 - x21) / dt2;
            // rescale tangents for parametrization in [0,1]
            t11 *= dt1;
            t2 *= dt1;
            init(x11, x21, t11, t2);
        },
        calc: function(t2) {
            const t2 = t2 * t2;
            const t3 = t2 * t2;
            return c0 + c11 * t2 + c2 * t2 + c3 * t3;
        }
    };
}
//
const tmp = new Vector31();
const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
function CatmullRomCurve3(points1, closed1, curveType, tension) {
    Curve1.call(this);
    this.type = 'CatmullRomCurve3';
    this.points = points1 || [];
    this.closed = closed1 || false;
    this.curveType = curveType || 'centripetal';
    this.tension = tension !== undefined ? tension : 0.5;
}
CatmullRomCurve3.prototype = Object.create(Curve1.prototype);
CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
CatmullRomCurve3.prototype.getPoint = function(t2, optionalTarget) {
    const point = optionalTarget || new Vector31();
    const points1 = this.points;
    const l1 = points1.length;
    const p1 = (l1 - (this.closed ? 0 : 1)) * t2;
    let intPoint = Math.floor(p1);
    let weight = p1 - intPoint;
    if (this.closed) intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l1) + 1) * l1;
    else if (weight === 0 && intPoint === l1 - 1) {
        intPoint = l1 - 2;
        weight = 1;
    }
    let p0, p3; // 4 points (p1 & p2 defined below)
    if (this.closed || intPoint > 0) p0 = points1[(intPoint - 1) % l1];
    else {
        // extrapolate first point
        tmp.subVectors(points1[0], points1[1]).add(points1[0]);
        p0 = tmp;
    }
    const p1 = points1[intPoint % l1];
    const p2 = points1[(intPoint + 1) % l1];
    if (this.closed || intPoint + 2 < l1) p3 = points1[(intPoint + 2) % l1];
    else {
        // extrapolate last point
        tmp.subVectors(points1[l1 - 1], points1[l1 - 2]).add(points1[l1 - 1]);
        p3 = tmp;
    }
    if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
        // init Centripetal / Chordal Catmull-Rom
        const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
        let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
        let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
        let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
        // safety check for repeated points
        if (dt1 < 0.0001) dt1 = 1;
        if (dt0 < 0.0001) dt0 = dt1;
        if (dt2 < 0.0001) dt2 = dt1;
        px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
        py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
        pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === 'catmullrom') {
        px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
        py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
        pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
    }
    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point;
};
CatmullRomCurve3.prototype.copy = function(source) {
    Curve1.prototype.copy.call(this, source);
    this.points = [];
    for(let i7 = 0, l1 = source.points.length; i7 < l1; i7++){
        const point = source.points[i7];
        this.points.push(point.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
};
CatmullRomCurve3.prototype.toJSON = function() {
    const data = Curve1.prototype.toJSON.call(this);
    data.points = [];
    for(let i7 = 0, l1 = this.points.length; i7 < l1; i7++){
        const point = this.points[i7];
        data.points.push(point.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
};
CatmullRomCurve3.prototype.fromJSON = function(json) {
    Curve1.prototype.fromJSON.call(this, json);
    this.points = [];
    for(let i7 = 0, l1 = json.points.length; i7 < l1; i7++){
        const point = json.points[i7];
        this.points.push(new Vector31().fromArray(point));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
};
function CubicBezierCurve1(v0, v1, v2, v3) {
    Curve1.call(this);
    this.type = 'CubicBezierCurve';
    this.v0 = v0 || new Vector21();
    this.v1 = v1 || new Vector21();
    this.v2 = v2 || new Vector21();
    this.v3 = v3 || new Vector21();
}
CubicBezierCurve1.prototype = Object.create(Curve1.prototype);
CubicBezierCurve1.prototype.constructor = CubicBezierCurve1;
CubicBezierCurve1.prototype.isCubicBezierCurve = true;
CubicBezierCurve1.prototype.getPoint = function(t2, optionalTarget) {
    const point = optionalTarget || new Vector21();
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier1(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier1(t2, v0.y, v1.y, v2.y, v3.y));
    return point;
};
CubicBezierCurve1.prototype.copy = function(source) {
    Curve1.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
};
CubicBezierCurve1.prototype.toJSON = function() {
    const data = Curve1.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
};
CubicBezierCurve1.prototype.fromJSON = function(json) {
    Curve1.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
};
function CubicBezierCurve3(v0, v1, v2, v3) {
    Curve1.call(this);
    this.type = 'CubicBezierCurve3';
    this.v0 = v0 || new Vector31();
    this.v1 = v1 || new Vector31();
    this.v2 = v2 || new Vector31();
    this.v3 = v3 || new Vector31();
}
CubicBezierCurve3.prototype = Object.create(Curve1.prototype);
CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
CubicBezierCurve3.prototype.getPoint = function(t2, optionalTarget) {
    const point = optionalTarget || new Vector31();
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier1(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier1(t2, v0.y, v1.y, v2.y, v3.y), CubicBezier1(t2, v0.z, v1.z, v2.z, v3.z));
    return point;
};
CubicBezierCurve3.prototype.copy = function(source) {
    Curve1.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
};
CubicBezierCurve3.prototype.toJSON = function() {
    const data = Curve1.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
};
CubicBezierCurve3.prototype.fromJSON = function(json) {
    Curve1.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
};
function EllipseCurve4(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    Curve1.call(this);
    this.type = 'EllipseCurve';
    this.aX = aX || 0;
    this.aY = aY || 0;
    this.xRadius = xRadius || 1;
    this.yRadius = yRadius || 1;
    this.aStartAngle = aStartAngle || 0;
    this.aEndAngle = aEndAngle || 2 * Math.PI;
    this.aClockwise = aClockwise || false;
    this.aRotation = aRotation || 0;
}
EllipseCurve4.prototype = Object.create(Curve1.prototype);
EllipseCurve4.prototype.constructor = EllipseCurve4;
EllipseCurve4.prototype.isEllipseCurve = true;
EllipseCurve4.prototype.getPoint = function(t2, optionalTarget) {
    const point = optionalTarget || new Vector21();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    // ensures that deltaAngle is 0 .. 2 PI
    while(deltaAngle < 0)deltaAngle += twoPi;
    while(deltaAngle > twoPi)deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
        if (samePoints) deltaAngle = 0;
        else deltaAngle = twoPi;
    }
    if (this.aClockwise === true && !samePoints) {
        if (deltaAngle === twoPi) deltaAngle = -twoPi;
        else deltaAngle = deltaAngle - twoPi;
    }
    const angle = this.aStartAngle + t2 * deltaAngle;
    let x6 = this.aX + this.xRadius * Math.cos(angle);
    let y6 = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
        const cos = Math.cos(this.aRotation);
        const sin = Math.sin(this.aRotation);
        const tx = x6 - this.aX;
        const ty = y6 - this.aY;
        // Rotate the point about the center of the ellipse.
        x6 = tx * cos - ty * sin + this.aX;
        y6 = tx * sin + ty * cos + this.aY;
    }
    return point.set(x6, y6);
};
EllipseCurve4.prototype.copy = function(source) {
    Curve1.prototype.copy.call(this, source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
};
EllipseCurve4.prototype.toJSON = function() {
    const data = Curve1.prototype.toJSON.call(this);
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
};
EllipseCurve4.prototype.fromJSON = function(json) {
    Curve1.prototype.fromJSON.call(this, json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
};
const EllipseCurve1 = EllipseCurve4;
function LineCurve1(v1, v2) {
    Curve1.call(this);
    this.type = 'LineCurve';
    this.v1 = v1 || new Vector21();
    this.v2 = v2 || new Vector21();
}
LineCurve1.prototype = Object.create(Curve1.prototype);
LineCurve1.prototype.constructor = LineCurve1;
LineCurve1.prototype.isLineCurve = true;
LineCurve1.prototype.getPoint = function(t2, optionalTarget) {
    const point = optionalTarget || new Vector21();
    if (t2 === 1) point.copy(this.v2);
    else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t2).add(this.v1);
    }
    return point;
};
// Line curve is linear, so we can overwrite default getPointAt
LineCurve1.prototype.getPointAt = function(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
};
LineCurve1.prototype.getTangent = function(t2, optionalTarget) {
    const tangent = optionalTarget || new Vector21();
    tangent.copy(this.v2).sub(this.v1).normalize();
    return tangent;
};
LineCurve1.prototype.copy = function(source) {
    Curve1.prototype.copy.call(this, source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
LineCurve1.prototype.toJSON = function() {
    const data = Curve1.prototype.toJSON.call(this);
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
LineCurve1.prototype.fromJSON = function(json) {
    Curve1.prototype.fromJSON.call(this, json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function LineCurve3(v1, v2) {
    Curve1.call(this);
    this.type = 'LineCurve3';
    this.v1 = v1 || new Vector31();
    this.v2 = v2 || new Vector31();
}
LineCurve3.prototype = Object.create(Curve1.prototype);
LineCurve3.prototype.constructor = LineCurve3;
LineCurve3.prototype.isLineCurve3 = true;
LineCurve3.prototype.getPoint = function(t2, optionalTarget) {
    const point = optionalTarget || new Vector31();
    if (t2 === 1) point.copy(this.v2);
    else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t2).add(this.v1);
    }
    return point;
};
// Line curve is linear, so we can overwrite default getPointAt
LineCurve3.prototype.getPointAt = function(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
};
LineCurve3.prototype.copy = function(source) {
    Curve1.prototype.copy.call(this, source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
LineCurve3.prototype.toJSON = function() {
    const data = Curve1.prototype.toJSON.call(this);
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
LineCurve3.prototype.fromJSON = function(json) {
    Curve1.prototype.fromJSON.call(this, json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function QuadraticBezierCurve1(v0, v1, v2) {
    Curve1.call(this);
    this.type = 'QuadraticBezierCurve';
    this.v0 = v0 || new Vector21();
    this.v1 = v1 || new Vector21();
    this.v2 = v2 || new Vector21();
}
QuadraticBezierCurve1.prototype = Object.create(Curve1.prototype);
QuadraticBezierCurve1.prototype.constructor = QuadraticBezierCurve1;
QuadraticBezierCurve1.prototype.isQuadraticBezierCurve = true;
QuadraticBezierCurve1.prototype.getPoint = function(t2, optionalTarget) {
    const point = optionalTarget || new Vector21();
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier1(t2, v0.x, v1.x, v2.x), QuadraticBezier1(t2, v0.y, v1.y, v2.y));
    return point;
};
QuadraticBezierCurve1.prototype.copy = function(source) {
    Curve1.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
QuadraticBezierCurve1.prototype.toJSON = function() {
    const data = Curve1.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
QuadraticBezierCurve1.prototype.fromJSON = function(json) {
    Curve1.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function QuadraticBezierCurve3(v0, v1, v2) {
    Curve1.call(this);
    this.type = 'QuadraticBezierCurve3';
    this.v0 = v0 || new Vector31();
    this.v1 = v1 || new Vector31();
    this.v2 = v2 || new Vector31();
}
QuadraticBezierCurve3.prototype = Object.create(Curve1.prototype);
QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
QuadraticBezierCurve3.prototype.getPoint = function(t2, optionalTarget) {
    const point = optionalTarget || new Vector31();
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier1(t2, v0.x, v1.x, v2.x), QuadraticBezier1(t2, v0.y, v1.y, v2.y), QuadraticBezier1(t2, v0.z, v1.z, v2.z));
    return point;
};
QuadraticBezierCurve3.prototype.copy = function(source) {
    Curve1.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
QuadraticBezierCurve3.prototype.toJSON = function() {
    const data = Curve1.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
QuadraticBezierCurve3.prototype.fromJSON = function(json) {
    Curve1.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function SplineCurve1(points1) {
    Curve1.call(this);
    this.type = 'SplineCurve';
    this.points = points1 || [];
}
SplineCurve1.prototype = Object.create(Curve1.prototype);
SplineCurve1.prototype.constructor = SplineCurve1;
SplineCurve1.prototype.isSplineCurve = true;
SplineCurve1.prototype.getPoint = function(t2, optionalTarget) {
    const point = optionalTarget || new Vector21();
    const points1 = this.points;
    const p1 = (points1.length - 1) * t2;
    const intPoint = Math.floor(p1);
    const weight = p1 - intPoint;
    const p0 = points1[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points1[intPoint];
    const p2 = points1[intPoint > points1.length - 2 ? points1.length - 1 : intPoint + 1];
    const p3 = points1[intPoint > points1.length - 3 ? points1.length - 1 : intPoint + 2];
    point.set(CatmullRom1(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom1(weight, p0.y, p1.y, p2.y, p3.y));
    return point;
};
SplineCurve1.prototype.copy = function(source) {
    Curve1.prototype.copy.call(this, source);
    this.points = [];
    for(let i7 = 0, l1 = source.points.length; i7 < l1; i7++){
        const point = source.points[i7];
        this.points.push(point.clone());
    }
    return this;
};
SplineCurve1.prototype.toJSON = function() {
    const data = Curve1.prototype.toJSON.call(this);
    data.points = [];
    for(let i7 = 0, l1 = this.points.length; i7 < l1; i7++){
        const point = this.points[i7];
        data.points.push(point.toArray());
    }
    return data;
};
SplineCurve1.prototype.fromJSON = function(json) {
    Curve1.prototype.fromJSON.call(this, json);
    this.points = [];
    for(let i7 = 0, l1 = json.points.length; i7 < l1; i7++){
        const point = json.points[i7];
        this.points.push(new Vector21().fromArray(point));
    }
    return this;
};
function ObjectLoader(manager) {
    Loader1.call(this, manager);
}
ObjectLoader.prototype = Object.assign(Object.create(Loader1.prototype), {
    constructor: ObjectLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope3 = this;
        const path1 = this.path === '' ? LoaderUtils1.extractUrlBase(url) : this.path;
        this.resourcePath = this.resourcePath || path1;
        const loader = new FileLoader1(scope3.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.load(url, function(text1) {
            let json = null;
            try {
                json = JSON.parse(text1);
            } catch (error) {
                if (onError !== undefined) onError(error);
                console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
                return;
            }
            const metadata = json.metadata;
            if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
                console.error('THREE.ObjectLoader: Can\'t load ' + url);
                return;
            }
            scope3.parse(json, onLoad);
        }, onProgress, onError);
    },
    parse: function(json, onLoad) {
        const shapes3 = this.parseShape(json.shapes);
        const geometries = this.parseGeometries(json.geometries, shapes3);
        const images = this.parseImages(json.images, function() {
            if (onLoad !== undefined) onLoad(object);
        });
        const textures = this.parseTextures(json.textures, images);
        const materials = this.parseMaterials(json.materials, textures);
        const object = this.parseObject(json.object, geometries, materials);
        if (json.animations) object.animations = this.parseAnimations(json.animations);
        if (json.images === undefined || json.images.length === 0) {
            if (onLoad !== undefined) onLoad(object);
        }
        return object;
    },
    parseShape: function(json) {
        const shapes3 = {
        };
        if (json !== undefined) for(let i7 = 0, l1 = json.length; i7 < l1; i7++){
            const shape = new Shape1().fromJSON(json[i7]);
            shapes3[shape.uuid] = shape;
        }
        return shapes3;
    },
    parseGeometries: function(json, shapes3) {
        const geometries = {
        };
        let geometryShapes;
        if (json !== undefined) {
            const bufferGeometryLoader = new BufferGeometryLoader1();
            for(let i7 = 0, l1 = json.length; i7 < l1; i7++){
                let geometry;
                const data = json[i7];
                switch(data.type){
                    case 'PlaneGeometry':
                    case 'PlaneBufferGeometry':
                        geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
                        break;
                    case 'BoxGeometry':
                    case 'BoxBufferGeometry':
                    case 'CubeGeometry':
                        geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                        break;
                    case 'CircleGeometry':
                    case 'CircleBufferGeometry':
                        geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
                        break;
                    case 'CylinderGeometry':
                    case 'CylinderBufferGeometry':
                        geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                        break;
                    case 'ConeGeometry':
                    case 'ConeBufferGeometry':
                        geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                        break;
                    case 'SphereGeometry':
                    case 'SphereBufferGeometry':
                        geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                        break;
                    case 'DodecahedronGeometry':
                    case 'DodecahedronBufferGeometry':
                    case 'IcosahedronGeometry':
                    case 'IcosahedronBufferGeometry':
                    case 'OctahedronGeometry':
                    case 'OctahedronBufferGeometry':
                    case 'TetrahedronGeometry':
                    case 'TetrahedronBufferGeometry':
                        geometry = new Geometries[data.type](data.radius, data.detail);
                        break;
                    case 'RingGeometry':
                    case 'RingBufferGeometry':
                        geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                        break;
                    case 'TorusGeometry':
                    case 'TorusBufferGeometry':
                        geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                        break;
                    case 'TorusKnotGeometry':
                    case 'TorusKnotBufferGeometry':
                        geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
                        break;
                    case 'TubeGeometry':
                    case 'TubeBufferGeometry':
                        // This only works for built-in curves (e.g. CatmullRomCurve3).
                        // User defined curves or instances of CurvePath will not be deserialized.
                        geometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
                        break;
                    case 'LatheGeometry':
                    case 'LatheBufferGeometry':
                        geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
                        break;
                    case 'PolyhedronGeometry':
                    case 'PolyhedronBufferGeometry':
                        geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
                        break;
                    case 'ShapeGeometry':
                    case 'ShapeBufferGeometry':
                        geometryShapes = [];
                        for(let j4 = 0, jl = data.shapes.length; j4 < jl; j4++){
                            const shape = shapes3[data.shapes[j4]];
                            geometryShapes.push(shape);
                        }
                        geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
                        break;
                    case 'ExtrudeGeometry':
                    case 'ExtrudeBufferGeometry':
                        geometryShapes = [];
                        for(let j4 = 0, jl = data.shapes.length; j4 < jl; j4++){
                            const shape = shapes3[data.shapes[j4]];
                            geometryShapes.push(shape);
                        }
                        const extrudePath = data.options.extrudePath;
                        if (extrudePath !== undefined) data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
                        geometry = new Geometries[data.type](geometryShapes, data.options);
                        break;
                    case 'BufferGeometry':
                    case 'InstancedBufferGeometry':
                        geometry = bufferGeometryLoader.parse(data);
                        break;
                    case 'Geometry':
                        console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
                        break;
                    default:
                        console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
                        continue;
                }
                geometry.uuid = data.uuid;
                if (data.name !== undefined) geometry.name = data.name;
                if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
                geometries[data.uuid] = geometry;
            }
        }
        return geometries;
    },
    parseMaterials: function(json, textures) {
        const cache = {
        }; // MultiMaterial
        const materials = {
        };
        if (json !== undefined) {
            const loader = new MaterialLoader1();
            loader.setTextures(textures);
            for(let i7 = 0, l1 = json.length; i7 < l1; i7++){
                const data = json[i7];
                if (data.type === 'MultiMaterial') {
                    // Deprecated
                    const array = [];
                    for(let j4 = 0; j4 < data.materials.length; j4++){
                        const material = data.materials[j4];
                        if (cache[material.uuid] === undefined) cache[material.uuid] = loader.parse(material);
                        array.push(cache[material.uuid]);
                    }
                    materials[data.uuid] = array;
                } else {
                    if (cache[data.uuid] === undefined) cache[data.uuid] = loader.parse(data);
                    materials[data.uuid] = cache[data.uuid];
                }
            }
        }
        return materials;
    },
    parseAnimations: function(json) {
        const animations = [];
        for(let i7 = 0; i7 < json.length; i7++){
            const data = json[i7];
            const clip = AnimationClip1.parse(data);
            if (data.uuid !== undefined) clip.uuid = data.uuid;
            animations.push(clip);
        }
        return animations;
    },
    parseImages: function(json, onLoad) {
        const scope3 = this;
        const images = {
        };
        let loader;
        function loadImage(url) {
            scope3.manager.itemStart(url);
            return loader.load(url, function() {
                scope3.manager.itemEnd(url);
            }, undefined, function() {
                scope3.manager.itemError(url);
                scope3.manager.itemEnd(url);
            });
        }
        if (json !== undefined && json.length > 0) {
            const manager = new LoadingManager1(onLoad);
            loader = new ImageLoader1(manager);
            loader.setCrossOrigin(this.crossOrigin);
            for(let i7 = 0, il = json.length; i7 < il; i7++){
                const image = json[i7];
                const url = image.url;
                if (Array.isArray(url)) {
                    // load array of images e.g CubeTexture
                    images[image.uuid] = [];
                    for(let j4 = 0, jl = url.length; j4 < jl; j4++){
                        const currentUrl = url[j4];
                        const path1 = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(currentUrl) ? currentUrl : scope3.resourcePath + currentUrl;
                        images[image.uuid].push(loadImage(path1));
                    }
                } else {
                    // load single image
                    const path1 = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope3.resourcePath + image.url;
                    images[image.uuid] = loadImage(path1);
                }
            }
        }
        return images;
    },
    parseTextures: function(json, images) {
        function parseConstant(value, type) {
            if (typeof value === 'number') return value;
            console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
            return type[value];
        }
        const textures = {
        };
        if (json !== undefined) for(let i7 = 0, l1 = json.length; i7 < l1; i7++){
            const data = json[i7];
            if (data.image === undefined) console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
            if (images[data.image] === undefined) console.warn('THREE.ObjectLoader: Undefined image', data.image);
            let texture;
            if (Array.isArray(images[data.image])) texture = new CubeTexture1(images[data.image]);
            else texture = new Texture1(images[data.image]);
            texture.needsUpdate = true;
            texture.uuid = data.uuid;
            if (data.name !== undefined) texture.name = data.name;
            if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
            if (data.offset !== undefined) texture.offset.fromArray(data.offset);
            if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
            if (data.center !== undefined) texture.center.fromArray(data.center);
            if (data.rotation !== undefined) texture.rotation = data.rotation;
            if (data.wrap !== undefined) {
                texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
            }
            if (data.format !== undefined) texture.format = data.format;
            if (data.type !== undefined) texture.type = data.type;
            if (data.encoding !== undefined) texture.encoding = data.encoding;
            if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
            if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
            if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
            if (data.flipY !== undefined) texture.flipY = data.flipY;
            if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
            if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
            textures[data.uuid] = texture;
        }
        return textures;
    },
    parseObject: function(data, geometries, materials) {
        let object;
        function getGeometry(name) {
            if (geometries[name] === undefined) console.warn('THREE.ObjectLoader: Undefined geometry', name);
            return geometries[name];
        }
        function getMaterial(name) {
            if (name === undefined) return undefined;
            if (Array.isArray(name)) {
                const array = [];
                for(let i7 = 0, l1 = name.length; i7 < l1; i7++){
                    const uuid = name[i7];
                    if (materials[uuid] === undefined) console.warn('THREE.ObjectLoader: Undefined material', uuid);
                    array.push(materials[uuid]);
                }
                return array;
            }
            if (materials[name] === undefined) console.warn('THREE.ObjectLoader: Undefined material', name);
            return materials[name];
        }
        let geometry, material;
        switch(data.type){
            case 'Scene':
                object = new Scene1();
                if (data.background !== undefined) {
                    if (Number.isInteger(data.background)) object.background = new Color1(data.background);
                }
                if (data.fog !== undefined) {
                    if (data.fog.type === 'Fog') object.fog = new Fog1(data.fog.color, data.fog.near, data.fog.far);
                    else if (data.fog.type === 'FogExp2') object.fog = new FogExp21(data.fog.color, data.fog.density);
                }
                break;
            case 'PerspectiveCamera':
                object = new PerspectiveCamera1(data.fov, data.aspect, data.near, data.far);
                if (data.focus !== undefined) object.focus = data.focus;
                if (data.zoom !== undefined) object.zoom = data.zoom;
                if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
                if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
                if (data.view !== undefined) object.view = Object.assign({
                }, data.view);
                break;
            case 'OrthographicCamera':
                object = new OrthographicCamera1(data.left, data.right, data.top, data.bottom, data.near, data.far);
                if (data.zoom !== undefined) object.zoom = data.zoom;
                if (data.view !== undefined) object.view = Object.assign({
                }, data.view);
                break;
            case 'AmbientLight':
                object = new AmbientLight1(data.color, data.intensity);
                break;
            case 'DirectionalLight':
                object = new DirectionalLight1(data.color, data.intensity);
                break;
            case 'PointLight':
                object = new PointLight1(data.color, data.intensity, data.distance, data.decay);
                break;
            case 'RectAreaLight':
                object = new RectAreaLight1(data.color, data.intensity, data.width, data.height);
                break;
            case 'SpotLight':
                object = new SpotLight1(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                break;
            case 'HemisphereLight':
                object = new HemisphereLight1(data.color, data.groundColor, data.intensity);
                break;
            case 'LightProbe':
                object = new LightProbe1().fromJSON(data);
                break;
            case 'SkinnedMesh':
                console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');
            case 'Mesh':
                geometry = getGeometry(data.geometry);
                material = getMaterial(data.material);
                object = new Mesh1(geometry, material);
                break;
            case 'InstancedMesh':
                geometry = getGeometry(data.geometry);
                material = getMaterial(data.material);
                const count = data.count;
                const instanceMatrix = data.instanceMatrix;
                object = new InstancedMesh1(geometry, material, count);
                object.instanceMatrix = new BufferAttribute1(new Float32Array(instanceMatrix.array), 16);
                break;
            case 'LOD':
                object = new LOD1();
                break;
            case 'Line':
                object = new Line1(getGeometry(data.geometry), getMaterial(data.material), data.mode);
                break;
            case 'LineLoop':
                object = new LineLoop1(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'LineSegments':
                object = new LineSegments1(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'PointCloud':
            case 'Points':
                object = new Points1(getGeometry(data.geometry), getMaterial(data.material));
                break;
            case 'Sprite':
                object = new Sprite1(getMaterial(data.material));
                break;
            case 'Group':
                object = new Group1();
                break;
            default:
                object = new Object3D1();
        }
        object.uuid = data.uuid;
        if (data.name !== undefined) object.name = data.name;
        if (data.matrix !== undefined) {
            object.matrix.fromArray(data.matrix);
            if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
            if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
        } else {
            if (data.position !== undefined) object.position.fromArray(data.position);
            if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
            if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
            if (data.scale !== undefined) object.scale.fromArray(data.scale);
        }
        if (data.castShadow !== undefined) object.castShadow = data.castShadow;
        if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;
        if (data.shadow) {
            if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
            if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
            if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
            if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
            if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
        }
        if (data.visible !== undefined) object.visible = data.visible;
        if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
        if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
        if (data.userData !== undefined) object.userData = data.userData;
        if (data.layers !== undefined) object.layers.mask = data.layers;
        if (data.children !== undefined) {
            const children = data.children;
            for(let i7 = 0; i7 < children.length; i7++)object.add(this.parseObject(children[i7], geometries, materials));
        }
        if (data.type === 'LOD') {
            if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
            const levels = data.levels;
            for(let l1 = 0; l1 < levels.length; l1++){
                const level = levels[l1];
                const child = object.getObjectByProperty('uuid', level.object);
                if (child !== undefined) object.addLevel(child, level.distance);
            }
        }
        return object;
    }
});
const TEXTURE_MAPPING = {
    UVMapping: UVMapping,
    CubeReflectionMapping: CubeReflectionMapping,
    CubeRefractionMapping: CubeRefractionMapping,
    EquirectangularReflectionMapping: EquirectangularReflectionMapping,
    EquirectangularRefractionMapping: EquirectangularRefractionMapping,
    CubeUVReflectionMapping: CubeUVReflectionMapping,
    CubeUVRefractionMapping: CubeUVRefractionMapping
};
const TEXTURE_WRAPPING = {
    RepeatWrapping: RepeatWrapping,
    ClampToEdgeWrapping: ClampToEdgeWrapping,
    MirroredRepeatWrapping: MirroredRepeatWrapping
};
const TEXTURE_FILTER = {
    NearestFilter: NearestFilter,
    NearestMipmapNearestFilter: NearestMipmapNearestFilter,
    NearestMipmapLinearFilter: NearestMipmapLinearFilter,
    LinearFilter: LinearFilter,
    LinearMipmapNearestFilter: LinearMipmapNearestFilter,
    LinearMipmapLinearFilter: LinearMipmapLinearFilter
};
const ObjectLoader1 = ObjectLoader;
export { ObjectLoader1 as ObjectLoader };
const Materials = function() {
    function ShadowMaterial1(parameters1) {
        Material1.call(this);
        this.type = 'ShadowMaterial';
        this.color = new Color1(0);
        this.transparent = true;
        this.setValues(parameters1);
    }
    ShadowMaterial1.prototype = Object.create(Material1.prototype);
    ShadowMaterial1.prototype.constructor = ShadowMaterial1;
    ShadowMaterial1.prototype.isShadowMaterial = true;
    ShadowMaterial1.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.color.copy(source.color);
        return this;
    };
    function SpriteMaterial3(parameters1) {
        Material1.call(this);
        this.type = 'SpriteMaterial';
        this.color = new Color1(16777215);
        this.map = null;
        this.alphaMap = null;
        this.rotation = 0;
        this.sizeAttenuation = true;
        this.transparent = true;
        this.setValues(parameters1);
    }
    SpriteMaterial3.prototype = Object.create(Material1.prototype);
    SpriteMaterial3.prototype.constructor = SpriteMaterial3;
    SpriteMaterial3.prototype.isSpriteMaterial = true;
    SpriteMaterial3.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.rotation = source.rotation;
        this.sizeAttenuation = source.sizeAttenuation;
        return this;
    };
    const SpriteMaterial1 = SpriteMaterial3;
    function RawShaderMaterial1(parameters1) {
        ShaderMaterial1.call(this, parameters1);
        this.type = 'RawShaderMaterial';
    }
    RawShaderMaterial1.prototype = Object.create(ShaderMaterial1.prototype);
    RawShaderMaterial1.prototype.constructor = RawShaderMaterial1;
    RawShaderMaterial1.prototype.isRawShaderMaterial = true;
    const default_vertex = `\nvoid main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n`;
    const default_fragment = `\nvoid main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}\n`;
    function ShaderMaterial5(parameters1) {
        Material1.call(this);
        this.type = 'ShaderMaterial';
        this.defines = {
        };
        this.uniforms = {
        };
        this.vertexShader = default_vertex;
        this.fragmentShader = default_fragment;
        this.linewidth = 1;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.lights = false;
        this.clipping = false;
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.extensions = {
            derivatives: false,
            fragDepth: false,
            drawBuffers: false,
            shaderTextureLOD: false
        };
        this.defaultAttributeValues = {
            'color': [
                1,
                1,
                1
            ],
            'uv': [
                0,
                0
            ],
            'uv2': [
                0,
                0
            ]
        };
        this.index0AttributeName = undefined;
        this.uniformsNeedUpdate = false;
        if (parameters1 !== undefined) {
            if (parameters1.attributes !== undefined) console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
            this.setValues(parameters1);
        }
    }
    ShaderMaterial5.prototype = Object.create(Material1.prototype);
    ShaderMaterial5.prototype.constructor = ShaderMaterial5;
    ShaderMaterial5.prototype.isShaderMaterial = true;
    ShaderMaterial5.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.fragmentShader = source.fragmentShader;
        this.vertexShader = source.vertexShader;
        this.uniforms = cloneUniforms(source.uniforms);
        this.defines = Object.assign({
        }, source.defines);
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.lights = source.lights;
        this.clipping = source.clipping;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        this.extensions = Object.assign({
        }, source.extensions);
        return this;
    };
    ShaderMaterial5.prototype.toJSON = function(meta) {
        const data = Material1.prototype.toJSON.call(this, meta);
        data.uniforms = {
        };
        for(const name in this.uniforms){
            const uniform = this.uniforms[name];
            const value = uniform.value;
            if (value && value.isTexture) data.uniforms[name] = {
                type: 't',
                value: value.toJSON(meta).uuid
            };
            else if (value && value.isColor) data.uniforms[name] = {
                type: 'c',
                value: value.getHex()
            };
            else if (value && value.isVector2) data.uniforms[name] = {
                type: 'v2',
                value: value.toArray()
            };
            else if (value && value.isVector3) data.uniforms[name] = {
                type: 'v3',
                value: value.toArray()
            };
            else if (value && value.isVector4) data.uniforms[name] = {
                type: 'v4',
                value: value.toArray()
            };
            else if (value && value.isMatrix3) data.uniforms[name] = {
                type: 'm3',
                value: value.toArray()
            };
            else if (value && value.isMatrix4) data.uniforms[name] = {
                type: 'm4',
                value: value.toArray()
            };
            else data.uniforms[name] = {
                value: value
            };
        }
        if (Object.keys(this.defines).length > 0) data.defines = this.defines;
        data.vertexShader = this.vertexShader;
        data.fragmentShader = this.fragmentShader;
        const extensions = {
        };
        for(const key in this.extensions)if (this.extensions[key] === true) extensions[key] = true;
        if (Object.keys(extensions).length > 0) data.extensions = extensions;
        return data;
    };
    const ShaderMaterial1 = ShaderMaterial5;
    function PointsMaterial3(parameters1) {
        Material1.call(this);
        this.type = 'PointsMaterial';
        this.color = new Color1(16777215);
        this.map = null;
        this.alphaMap = null;
        this.size = 1;
        this.sizeAttenuation = true;
        this.morphTargets = false;
        this.setValues(parameters1);
    }
    PointsMaterial3.prototype = Object.create(Material1.prototype);
    PointsMaterial3.prototype.constructor = PointsMaterial3;
    PointsMaterial3.prototype.isPointsMaterial = true;
    PointsMaterial3.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.size = source.size;
        this.sizeAttenuation = source.sizeAttenuation;
        this.morphTargets = source.morphTargets;
        return this;
    };
    const PointsMaterial1 = PointsMaterial3;
    function MeshPhysicalMaterial1(parameters1) {
        MeshStandardMaterial1.call(this);
        this.defines = {
            'STANDARD': '',
            'PHYSICAL': ''
        };
        this.type = 'MeshPhysicalMaterial';
        this.clearcoat = 0;
        this.clearcoatMap = null;
        this.clearcoatRoughness = 0;
        this.clearcoatRoughnessMap = null;
        this.clearcoatNormalScale = new Vector21(1, 1);
        this.clearcoatNormalMap = null;
        this.reflectivity = 0.5;
        this.sheen = null;
        this.transmission = 0;
        this.transmissionMap = null;
        this.setValues(parameters1);
    }
    MeshPhysicalMaterial1.prototype = Object.create(MeshStandardMaterial1.prototype);
    MeshPhysicalMaterial1.prototype.constructor = MeshPhysicalMaterial1;
    MeshPhysicalMaterial1.prototype.isMeshPhysicalMaterial = true;
    MeshPhysicalMaterial1.prototype.copy = function(source) {
        MeshStandardMaterial1.prototype.copy.call(this, source);
        this.defines = {
            'STANDARD': '',
            'PHYSICAL': ''
        };
        this.clearcoat = source.clearcoat;
        this.clearcoatMap = source.clearcoatMap;
        this.clearcoatRoughness = source.clearcoatRoughness;
        this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
        this.clearcoatNormalMap = source.clearcoatNormalMap;
        this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
        this.reflectivity = source.reflectivity;
        if (source.sheen) this.sheen = (this.sheen || new Color1()).copy(source.sheen);
        else this.sheen = null;
        this.transmission = source.transmission;
        this.transmissionMap = source.transmissionMap;
        return this;
    };
    function MeshStandardMaterial5(parameters1) {
        Material1.call(this);
        this.defines = {
            'STANDARD': ''
        };
        this.type = 'MeshStandardMaterial';
        this.color = new Color1(16777215);
        this.roughness = 1;
        this.metalness = 0;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color1(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector21(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.roughnessMap = null;
        this.metalnessMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.envMapIntensity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.vertexTangents = false;
        this.setValues(parameters1);
    }
    MeshStandardMaterial5.prototype = Object.create(Material1.prototype);
    MeshStandardMaterial5.prototype.constructor = MeshStandardMaterial5;
    MeshStandardMaterial5.prototype.isMeshStandardMaterial = true;
    MeshStandardMaterial5.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.defines = {
            'STANDARD': ''
        };
        this.color.copy(source.color);
        this.roughness = source.roughness;
        this.metalness = source.metalness;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.roughnessMap = source.roughnessMap;
        this.metalnessMap = source.metalnessMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.envMapIntensity = source.envMapIntensity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        this.vertexTangents = source.vertexTangents;
        return this;
    };
    const MeshStandardMaterial1 = MeshStandardMaterial5;
    function MeshPhongMaterial1(parameters1) {
        Material1.call(this);
        this.type = 'MeshPhongMaterial';
        this.color = new Color1(16777215);
        this.specular = new Color1(1118481);
        this.shininess = 30;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color1(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector21(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters1);
    }
    MeshPhongMaterial1.prototype = Object.create(Material1.prototype);
    MeshPhongMaterial1.prototype.constructor = MeshPhongMaterial1;
    MeshPhongMaterial1.prototype.isMeshPhongMaterial = true;
    MeshPhongMaterial1.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.specular.copy(source.specular);
        this.shininess = source.shininess;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    function MeshToonMaterial1(parameters1) {
        Material1.call(this);
        this.defines = {
            'TOON': ''
        };
        this.type = 'MeshToonMaterial';
        this.color = new Color1(16777215);
        this.map = null;
        this.gradientMap = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color1(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector21(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.alphaMap = null;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters1);
    }
    MeshToonMaterial1.prototype = Object.create(Material1.prototype);
    MeshToonMaterial1.prototype.constructor = MeshToonMaterial1;
    MeshToonMaterial1.prototype.isMeshToonMaterial = true;
    MeshToonMaterial1.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.gradientMap = source.gradientMap;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    function MeshNormalMaterial1(parameters1) {
        Material1.call(this);
        this.type = 'MeshNormalMaterial';
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector21(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters1);
    }
    MeshNormalMaterial1.prototype = Object.create(Material1.prototype);
    MeshNormalMaterial1.prototype.constructor = MeshNormalMaterial1;
    MeshNormalMaterial1.prototype.isMeshNormalMaterial = true;
    MeshNormalMaterial1.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    function MeshLambertMaterial1(parameters1) {
        Material1.call(this);
        this.type = 'MeshLambertMaterial';
        this.color = new Color1(16777215);
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color1(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters1);
    }
    MeshLambertMaterial1.prototype = Object.create(Material1.prototype);
    MeshLambertMaterial1.prototype.constructor = MeshLambertMaterial1;
    MeshLambertMaterial1.prototype.isMeshLambertMaterial = true;
    MeshLambertMaterial1.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    function MeshDepthMaterial3(parameters1) {
        Material1.call(this);
        this.type = 'MeshDepthMaterial';
        this.depthPacking = BasicDepthPacking;
        this.skinning = false;
        this.morphTargets = false;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.setValues(parameters1);
    }
    MeshDepthMaterial3.prototype = Object.create(Material1.prototype);
    MeshDepthMaterial3.prototype.constructor = MeshDepthMaterial3;
    MeshDepthMaterial3.prototype.isMeshDepthMaterial = true;
    MeshDepthMaterial3.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.depthPacking = source.depthPacking;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        return this;
    };
    const MeshDepthMaterial1 = MeshDepthMaterial3;
    function MeshDistanceMaterial3(parameters1) {
        Material1.call(this);
        this.type = 'MeshDistanceMaterial';
        this.referencePosition = new Vector31();
        this.nearDistance = 1;
        this.farDistance = 1000;
        this.skinning = false;
        this.morphTargets = false;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.fog = false;
        this.setValues(parameters1);
    }
    MeshDistanceMaterial3.prototype = Object.create(Material1.prototype);
    MeshDistanceMaterial3.prototype.constructor = MeshDistanceMaterial3;
    MeshDistanceMaterial3.prototype.isMeshDistanceMaterial = true;
    MeshDistanceMaterial3.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.referencePosition.copy(source.referencePosition);
        this.nearDistance = source.nearDistance;
        this.farDistance = source.farDistance;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        return this;
    };
    const MeshDistanceMaterial1 = MeshDistanceMaterial3;
    function MeshBasicMaterial3(parameters1) {
        Material1.call(this);
        this.type = 'MeshBasicMaterial';
        this.color = new Color1(16777215);
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
        this.skinning = false;
        this.morphTargets = false;
        this.setValues(parameters1);
    }
    MeshBasicMaterial3.prototype = Object.create(Material1.prototype);
    MeshBasicMaterial3.prototype.constructor = MeshBasicMaterial3;
    MeshBasicMaterial3.prototype.isMeshBasicMaterial = true;
    MeshBasicMaterial3.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        return this;
    };
    const MeshBasicMaterial1 = MeshBasicMaterial3;
    function MeshMatcapMaterial1(parameters1) {
        Material1.call(this);
        this.defines = {
            'MATCAP': ''
        };
        this.type = 'MeshMatcapMaterial';
        this.color = new Color1(16777215);
        this.matcap = null;
        this.map = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector21(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.alphaMap = null;
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
        this.setValues(parameters1);
    }
    MeshMatcapMaterial1.prototype = Object.create(Material1.prototype);
    MeshMatcapMaterial1.prototype.constructor = MeshMatcapMaterial1;
    MeshMatcapMaterial1.prototype.isMeshMatcapMaterial = true;
    MeshMatcapMaterial1.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.defines = {
            'MATCAP': ''
        };
        this.color.copy(source.color);
        this.matcap = source.matcap;
        this.map = source.map;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
        return this;
    };
    function LineDashedMaterial1(parameters1) {
        LineBasicMaterial1.call(this);
        this.type = 'LineDashedMaterial';
        this.scale = 1;
        this.dashSize = 3;
        this.gapSize = 1;
        this.setValues(parameters1);
    }
    LineDashedMaterial1.prototype = Object.create(LineBasicMaterial1.prototype);
    LineDashedMaterial1.prototype.constructor = LineDashedMaterial1;
    LineDashedMaterial1.prototype.isLineDashedMaterial = true;
    LineDashedMaterial1.prototype.copy = function(source) {
        LineBasicMaterial1.prototype.copy.call(this, source);
        this.scale = source.scale;
        this.dashSize = source.dashSize;
        this.gapSize = source.gapSize;
        return this;
    };
    function LineBasicMaterial5(parameters1) {
        Material1.call(this);
        this.type = 'LineBasicMaterial';
        this.color = new Color1(16777215);
        this.linewidth = 1;
        this.linecap = 'round';
        this.linejoin = 'round';
        this.morphTargets = false;
        this.setValues(parameters1);
    }
    LineBasicMaterial5.prototype = Object.create(Material1.prototype);
    LineBasicMaterial5.prototype.constructor = LineBasicMaterial5;
    LineBasicMaterial5.prototype.isLineBasicMaterial = true;
    LineBasicMaterial5.prototype.copy = function(source) {
        Material1.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.linewidth = source.linewidth;
        this.linecap = source.linecap;
        this.linejoin = source.linejoin;
        this.morphTargets = source.morphTargets;
        return this;
    };
    const LineBasicMaterial1 = LineBasicMaterial5;
    let materialId = 0;
    function Material5() {
        Object.defineProperty(this, 'id', {
            value: materialId++
        });
        this.uuid = MathUtils1.generateUUID();
        this.name = '';
        this.type = 'Material';
        this.fog = true;
        this.blending = NormalBlending;
        this.side = FrontSide;
        this.flatShading = false;
        this.vertexColors = false;
        this.opacity = 1;
        this.transparent = false;
        this.blendSrc = SrcAlphaFactor;
        this.blendDst = OneMinusSrcAlphaFactor;
        this.blendEquation = AddEquation;
        this.blendSrcAlpha = null;
        this.blendDstAlpha = null;
        this.blendEquationAlpha = null;
        this.depthFunc = LessEqualDepth;
        this.depthTest = true;
        this.depthWrite = true;
        this.stencilWriteMask = 255;
        this.stencilFunc = AlwaysStencilFunc;
        this.stencilRef = 0;
        this.stencilFuncMask = 255;
        this.stencilFail = KeepStencilOp;
        this.stencilZFail = KeepStencilOp;
        this.stencilZPass = KeepStencilOp;
        this.stencilWrite = false;
        this.clippingPlanes = null;
        this.clipIntersection = false;
        this.clipShadows = false;
        this.shadowSide = null;
        this.colorWrite = true;
        this.precision = null;
        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;
        this.dithering = false;
        this.alphaTest = 0;
        this.premultipliedAlpha = false;
        this.visible = true;
        this.toneMapped = true;
        this.userData = {
        };
        this.version = 0;
    }
    Material5.prototype = Object.assign(Object.create(EventDispatcher1.prototype), {
        constructor: Material5,
        isMaterial: true,
        onBeforeCompile: function() {
        },
        customProgramCacheKey: function() {
            return this.onBeforeCompile.toString();
        },
        setValues: function(values) {
            if (values === undefined) return;
            for(const key in values){
                const newValue = values[key];
                if (newValue === undefined) {
                    console.warn("THREE.Material: '" + key + "' parameter is undefined.");
                    continue;
                }
                if (key === 'shading') {
                    console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                    this.flatShading = newValue === FlatShading ? true : false;
                    continue;
                }
                const currentValue = this[key];
                if (currentValue === undefined) {
                    console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
                    continue;
                }
                if (currentValue && currentValue.isColor) currentValue.set(newValue);
                else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) currentValue.copy(newValue);
                else this[key] = newValue;
            }
        },
        toJSON: function(meta) {
            const isRoot = meta === undefined || typeof meta === 'string';
            if (isRoot) meta = {
                textures: {
                },
                images: {
                }
            };
            const data = {
                metadata: {
                    version: 4.5,
                    type: 'Material',
                    generator: 'Material.toJSON'
                }
            };
            data.uuid = this.uuid;
            data.type = this.type;
            if (this.name !== '') data.name = this.name;
            if (this.color && this.color.isColor) data.color = this.color.getHex();
            if (this.roughness !== undefined) data.roughness = this.roughness;
            if (this.metalness !== undefined) data.metalness = this.metalness;
            if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();
            if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
            if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
            if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
            if (this.shininess !== undefined) data.shininess = this.shininess;
            if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
            if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;
            if (this.clearcoatMap && this.clearcoatMap.isTexture) data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
            if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
            if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
                data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
                data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
            }
            if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
            if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
            if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
            if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;
            if (this.aoMap && this.aoMap.isTexture) {
                data.aoMap = this.aoMap.toJSON(meta).uuid;
                data.aoMapIntensity = this.aoMapIntensity;
            }
            if (this.bumpMap && this.bumpMap.isTexture) {
                data.bumpMap = this.bumpMap.toJSON(meta).uuid;
                data.bumpScale = this.bumpScale;
            }
            if (this.normalMap && this.normalMap.isTexture) {
                data.normalMap = this.normalMap.toJSON(meta).uuid;
                data.normalMapType = this.normalMapType;
                data.normalScale = this.normalScale.toArray();
            }
            if (this.displacementMap && this.displacementMap.isTexture) {
                data.displacementMap = this.displacementMap.toJSON(meta).uuid;
                data.displacementScale = this.displacementScale;
                data.displacementBias = this.displacementBias;
            }
            if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
            if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
            if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
            if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
            if (this.envMap && this.envMap.isTexture) {
                data.envMap = this.envMap.toJSON(meta).uuid;
                data.reflectivity = this.reflectivity;
                data.refractionRatio = this.refractionRatio;
                if (this.combine !== undefined) data.combine = this.combine;
                if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
            }
            if (this.gradientMap && this.gradientMap.isTexture) data.gradientMap = this.gradientMap.toJSON(meta).uuid;
            if (this.size !== undefined) data.size = this.size;
            if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
            if (this.blending !== NormalBlending) data.blending = this.blending;
            if (this.flatShading === true) data.flatShading = this.flatShading;
            if (this.side !== FrontSide) data.side = this.side;
            if (this.vertexColors) data.vertexColors = true;
            if (this.opacity < 1) data.opacity = this.opacity;
            if (this.transparent === true) data.transparent = this.transparent;
            data.depthFunc = this.depthFunc;
            data.depthTest = this.depthTest;
            data.depthWrite = this.depthWrite;
            data.stencilWrite = this.stencilWrite;
            data.stencilWriteMask = this.stencilWriteMask;
            data.stencilFunc = this.stencilFunc;
            data.stencilRef = this.stencilRef;
            data.stencilFuncMask = this.stencilFuncMask;
            data.stencilFail = this.stencilFail;
            data.stencilZFail = this.stencilZFail;
            data.stencilZPass = this.stencilZPass;
            if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
            if (this.polygonOffset === true) data.polygonOffset = true;
            if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
            if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
            if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
            if (this.dashSize !== undefined) data.dashSize = this.dashSize;
            if (this.gapSize !== undefined) data.gapSize = this.gapSize;
            if (this.scale !== undefined) data.scale = this.scale;
            if (this.dithering === true) data.dithering = true;
            if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
            if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
            if (this.wireframe === true) data.wireframe = this.wireframe;
            if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
            if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
            if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
            if (this.morphTargets === true) data.morphTargets = true;
            if (this.morphNormals === true) data.morphNormals = true;
            if (this.skinning === true) data.skinning = true;
            if (this.visible === false) data.visible = false;
            if (this.toneMapped === false) data.toneMapped = false;
            if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData;
            function extractFromCache(cache) {
                const values = [];
                for(const key in cache){
                    const data1 = cache[key];
                    delete data1.metadata;
                    values.push(data1);
                }
                return values;
            }
            if (isRoot) {
                const textures = extractFromCache(meta.textures);
                const images = extractFromCache(meta.images);
                if (textures.length > 0) data.textures = textures;
                if (images.length > 0) data.images = images;
            }
            return data;
        },
        clone: function() {
            return new this.constructor().copy(this);
        },
        copy: function(source) {
            this.name = source.name;
            this.fog = source.fog;
            this.blending = source.blending;
            this.side = source.side;
            this.flatShading = source.flatShading;
            this.vertexColors = source.vertexColors;
            this.opacity = source.opacity;
            this.transparent = source.transparent;
            this.blendSrc = source.blendSrc;
            this.blendDst = source.blendDst;
            this.blendEquation = source.blendEquation;
            this.blendSrcAlpha = source.blendSrcAlpha;
            this.blendDstAlpha = source.blendDstAlpha;
            this.blendEquationAlpha = source.blendEquationAlpha;
            this.depthFunc = source.depthFunc;
            this.depthTest = source.depthTest;
            this.depthWrite = source.depthWrite;
            this.stencilWriteMask = source.stencilWriteMask;
            this.stencilFunc = source.stencilFunc;
            this.stencilRef = source.stencilRef;
            this.stencilFuncMask = source.stencilFuncMask;
            this.stencilFail = source.stencilFail;
            this.stencilZFail = source.stencilZFail;
            this.stencilZPass = source.stencilZPass;
            this.stencilWrite = source.stencilWrite;
            const srcPlanes = source.clippingPlanes;
            let dstPlanes = null;
            if (srcPlanes !== null) {
                const n = srcPlanes.length;
                dstPlanes = new Array(n);
                for(let i7 = 0; i7 !== n; ++i7)dstPlanes[i7] = srcPlanes[i7].clone();
            }
            this.clippingPlanes = dstPlanes;
            this.clipIntersection = source.clipIntersection;
            this.clipShadows = source.clipShadows;
            this.shadowSide = source.shadowSide;
            this.colorWrite = source.colorWrite;
            this.precision = source.precision;
            this.polygonOffset = source.polygonOffset;
            this.polygonOffsetFactor = source.polygonOffsetFactor;
            this.polygonOffsetUnits = source.polygonOffsetUnits;
            this.dithering = source.dithering;
            this.alphaTest = source.alphaTest;
            this.premultipliedAlpha = source.premultipliedAlpha;
            this.visible = source.visible;
            this.toneMapped = source.toneMapped;
            this.userData = JSON.parse(JSON.stringify(source.userData));
            return this;
        },
        dispose: function() {
            this.dispatchEvent({
                type: 'dispose'
            });
        }
    });
    Object.defineProperty(Material5.prototype, 'needsUpdate', {
        set: function(value) {
            if (value === true) this.version++;
        }
    });
    const Material1 = Material5;
}();
function MaterialLoader2(manager) {
    Loader1.call(this, manager);
    this.textures = {
    };
}
MaterialLoader2.prototype = Object.assign(Object.create(Loader1.prototype), {
    constructor: MaterialLoader2,
    load: function(url, onLoad, onProgress, onError) {
        const scope3 = this;
        const loader = new FileLoader1(scope3.manager);
        loader.setPath(scope3.path);
        loader.setRequestHeader(scope3.requestHeader);
        loader.load(url, function(text1) {
            try {
                onLoad(scope3.parse(JSON.parse(text1)));
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope3.manager.itemError(url);
            }
        }, onProgress, onError);
    },
    parse: function(json) {
        const textures = this.textures;
        function getTexture(name) {
            if (textures[name] === undefined) console.warn('THREE.MaterialLoader: Undefined texture', name);
            return textures[name];
        }
        const material = new Materials[json.type]();
        if (json.uuid !== undefined) material.uuid = json.uuid;
        if (json.name !== undefined) material.name = json.name;
        if (json.color !== undefined) material.color.setHex(json.color);
        if (json.roughness !== undefined) material.roughness = json.roughness;
        if (json.metalness !== undefined) material.metalness = json.metalness;
        if (json.sheen !== undefined) material.sheen = new Color1().setHex(json.sheen);
        if (json.emissive !== undefined) material.emissive.setHex(json.emissive);
        if (json.specular !== undefined) material.specular.setHex(json.specular);
        if (json.shininess !== undefined) material.shininess = json.shininess;
        if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
        if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
        if (json.fog !== undefined) material.fog = json.fog;
        if (json.flatShading !== undefined) material.flatShading = json.flatShading;
        if (json.blending !== undefined) material.blending = json.blending;
        if (json.combine !== undefined) material.combine = json.combine;
        if (json.side !== undefined) material.side = json.side;
        if (json.opacity !== undefined) material.opacity = json.opacity;
        if (json.transparent !== undefined) material.transparent = json.transparent;
        if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
        if (json.depthTest !== undefined) material.depthTest = json.depthTest;
        if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
        if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
        if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
        if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
        if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
        if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
        if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
        if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
        if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
        if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
        if (json.wireframe !== undefined) material.wireframe = json.wireframe;
        if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
        if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
        if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
        if (json.rotation !== undefined) material.rotation = json.rotation;
        if (json.linewidth !== 1) material.linewidth = json.linewidth;
        if (json.dashSize !== undefined) material.dashSize = json.dashSize;
        if (json.gapSize !== undefined) material.gapSize = json.gapSize;
        if (json.scale !== undefined) material.scale = json.scale;
        if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
        if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
        if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
        if (json.skinning !== undefined) material.skinning = json.skinning;
        if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
        if (json.morphNormals !== undefined) material.morphNormals = json.morphNormals;
        if (json.dithering !== undefined) material.dithering = json.dithering;
        if (json.vertexTangents !== undefined) material.vertexTangents = json.vertexTangents;
        if (json.visible !== undefined) material.visible = json.visible;
        if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
        if (json.userData !== undefined) material.userData = json.userData;
        if (json.vertexColors !== undefined) {
            if (typeof json.vertexColors === 'number') material.vertexColors = json.vertexColors > 0 ? true : false;
            else material.vertexColors = json.vertexColors;
        }
        if (json.uniforms !== undefined) for(const name in json.uniforms){
            const uniform = json.uniforms[name];
            material.uniforms[name] = {
            };
            switch(uniform.type){
                case 't':
                    material.uniforms[name].value = getTexture(uniform.value);
                    break;
                case 'c':
                    material.uniforms[name].value = new Color1().setHex(uniform.value);
                    break;
                case 'v2':
                    material.uniforms[name].value = new Vector21().fromArray(uniform.value);
                    break;
                case 'v3':
                    material.uniforms[name].value = new Vector31().fromArray(uniform.value);
                    break;
                case 'v4':
                    material.uniforms[name].value = new Vector41().fromArray(uniform.value);
                    break;
                case 'm3':
                    material.uniforms[name].value = new Matrix31().fromArray(uniform.value);
                    break;
                case 'm4':
                    material.uniforms[name].value = new Matrix41().fromArray(uniform.value);
                    break;
                default:
                    material.uniforms[name].value = uniform.value;
            }
        }
        if (json.defines !== undefined) material.defines = json.defines;
        if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
        if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
        if (json.extensions !== undefined) for(const key in json.extensions)material.extensions[key] = json.extensions[key];
        if (json.shading !== undefined) material.flatShading = json.shading === 1;
        if (json.size !== undefined) material.size = json.size;
        if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;
        if (json.map !== undefined) material.map = getTexture(json.map);
        if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
        if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
        if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
        if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
        if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
        if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;
        if (json.normalScale !== undefined) {
            let normalScale = json.normalScale;
            if (Array.isArray(normalScale) === false) normalScale = [
                normalScale,
                normalScale
            ];
            material.normalScale = new Vector21().fromArray(normalScale);
        }
        if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
        if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
        if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
        if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
        if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
        if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
        if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
        if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
        if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
        if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
        if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
        if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
        if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
        if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
        if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
        if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
        if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
        if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
        if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
        if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
        if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector21().fromArray(json.clearcoatNormalScale);
        if (json.transmission !== undefined) material.transmission = json.transmission;
        if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
        return material;
    },
    setTextures: function(value) {
        this.textures = value;
        return this;
    }
});
const MaterialLoader1 = MaterialLoader2;
export { MaterialLoader1 as MaterialLoader };
function InstancedBufferGeometry2() {
    BufferGeometry1.call(this);
    this.type = 'InstancedBufferGeometry';
    this.instanceCount = Infinity;
}
InstancedBufferGeometry2.prototype = Object.assign(Object.create(BufferGeometry1.prototype), {
    constructor: InstancedBufferGeometry2,
    isInstancedBufferGeometry: true,
    copy: function(source) {
        BufferGeometry1.prototype.copy.call(this, source);
        this.instanceCount = source.instanceCount;
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    toJSON: function() {
        const data = BufferGeometry1.prototype.toJSON.call(this);
        data.instanceCount = this.instanceCount;
        data.isInstancedBufferGeometry = true;
        return data;
    }
});
const InstancedBufferGeometry1 = InstancedBufferGeometry2;
function InstancedBufferAttribute2(array, itemSize, normalized, meshPerAttribute) {
    if (typeof normalized === 'number') {
        meshPerAttribute = normalized;
        normalized = false;
        console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
    }
    BufferAttribute1.call(this, array, itemSize, normalized);
    this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedBufferAttribute2.prototype = Object.assign(Object.create(BufferAttribute1.prototype), {
    constructor: InstancedBufferAttribute2,
    isInstancedBufferAttribute: true,
    copy: function(source) {
        BufferAttribute1.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    },
    toJSON: function() {
        const data = BufferAttribute1.prototype.toJSON.call(this);
        data.meshPerAttribute = this.meshPerAttribute;
        data.isInstancedBufferAttribute = true;
        return data;
    }
});
const InstancedBufferAttribute1 = InstancedBufferAttribute2;
function BufferGeometryLoader2(manager) {
    Loader1.call(this, manager);
}
BufferGeometryLoader2.prototype = Object.assign(Object.create(Loader1.prototype), {
    constructor: BufferGeometryLoader2,
    load: function(url, onLoad, onProgress, onError) {
        const scope3 = this;
        const loader = new FileLoader1(scope3.manager);
        loader.setPath(scope3.path);
        loader.setRequestHeader(scope3.requestHeader);
        loader.load(url, function(text1) {
            try {
                onLoad(scope3.parse(JSON.parse(text1)));
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope3.manager.itemError(url);
            }
        }, onProgress, onError);
    },
    parse: function(json) {
        const interleavedBufferMap = {
        };
        const arrayBufferMap = {
        };
        function getInterleavedBuffer(json1, uuid) {
            if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
            const interleavedBuffers = json1.interleavedBuffers;
            const interleavedBuffer = interleavedBuffers[uuid];
            const buffer = getArrayBuffer(json1, interleavedBuffer.buffer);
            const array = new TYPED_ARRAYS[interleavedBuffer.type](buffer);
            const ib = new InterleavedBuffer1(array, interleavedBuffer.stride);
            ib.uuid = interleavedBuffer.uuid;
            interleavedBufferMap[uuid] = ib;
            return ib;
        }
        function getArrayBuffer(json1, uuid) {
            if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
            const arrayBuffers = json1.arrayBuffers;
            const arrayBuffer = arrayBuffers[uuid];
            const ab = new Uint32Array(arrayBuffer).buffer;
            arrayBufferMap[uuid] = ab;
            return ab;
        }
        const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry1() : new BufferGeometry1();
        const index2 = json.data.index;
        if (index2 !== undefined) {
            const typedArray = new TYPED_ARRAYS[index2.type](index2.array);
            geometry.setIndex(new BufferAttribute1(typedArray, 1));
        }
        const attributes = json.data.attributes;
        for(const key in attributes){
            const attribute = attributes[key];
            let bufferAttribute;
            if (attribute.isInterleavedBufferAttribute) {
                const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                bufferAttribute = new InterleavedBufferAttribute1(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
            } else {
                const typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
                const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute1 : BufferAttribute1;
                bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
            }
            if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
            geometry.setAttribute(key, bufferAttribute);
        }
        const morphAttributes = json.data.morphAttributes;
        if (morphAttributes) for(const key in morphAttributes){
            const attributeArray = morphAttributes[key];
            const array = [];
            for(let i7 = 0, il = attributeArray.length; i7 < il; i7++){
                const attribute = attributeArray[i7];
                let bufferAttribute;
                if (attribute.isInterleavedBufferAttribute) {
                    const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                    bufferAttribute = new InterleavedBufferAttribute1(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
                } else {
                    const typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
                    bufferAttribute = new BufferAttribute1(typedArray, attribute.itemSize, attribute.normalized);
                }
                if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
                array.push(bufferAttribute);
            }
            geometry.morphAttributes[key] = array;
        }
        const morphTargetsRelative = json.data.morphTargetsRelative;
        if (morphTargetsRelative) geometry.morphTargetsRelative = true;
        const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
        if (groups !== undefined) for(let i7 = 0, n = groups.length; i7 !== n; ++i7){
            const group = groups[i7];
            geometry.addGroup(group.start, group.count, group.materialIndex);
        }
        const boundingSphere = json.data.boundingSphere;
        if (boundingSphere !== undefined) {
            const center1 = new Vector31();
            if (boundingSphere.center !== undefined) center1.fromArray(boundingSphere.center);
            geometry.boundingSphere = new Sphere1(center1, boundingSphere.radius);
        }
        if (json.name) geometry.name = json.name;
        if (json.userData) geometry.userData = json.userData;
        return geometry;
    }
});
const TYPED_ARRAYS = {
    Int8Array: Int8Array,
    Uint8Array: Uint8Array,
    Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
    Int16Array: Int16Array,
    Uint16Array: Uint16Array,
    Int32Array: Int32Array,
    Uint32Array: Uint32Array,
    Float32Array: Float32Array,
    Float64Array: Float64Array
};
const BufferGeometryLoader1 = BufferGeometryLoader2;
export { BufferGeometryLoader1 as BufferGeometryLoader };
function LoadingManager2(onLoad, onProgress, onError) {
    const scope3 = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = undefined;
    const handlers = [];
    this.onStart = undefined;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
        itemsTotal++;
        if (isLoading === false) {
            if (scope3.onStart !== undefined) scope3.onStart(url, itemsLoaded, itemsTotal);
        }
        isLoading = true;
    };
    this.itemEnd = function(url) {
        itemsLoaded++;
        if (scope3.onProgress !== undefined) scope3.onProgress(url, itemsLoaded, itemsTotal);
        if (itemsLoaded === itemsTotal) {
            isLoading = false;
            if (scope3.onLoad !== undefined) scope3.onLoad();
        }
    };
    this.itemError = function(url) {
        if (scope3.onError !== undefined) scope3.onError(url);
    };
    this.resolveURL = function(url) {
        if (urlModifier) return urlModifier(url);
        return url;
    };
    this.setURLModifier = function(transform) {
        urlModifier = transform;
        return this;
    };
    this.addHandler = function(regex, loader) {
        handlers.push(regex, loader);
        return this;
    };
    this.removeHandler = function(regex) {
        const index2 = handlers.indexOf(regex);
        if (index2 !== -1) handlers.splice(index2, 2);
        return this;
    };
    this.getHandler = function(file) {
        for(let i7 = 0, l1 = handlers.length; i7 < l1; i7 += 2){
            const regex = handlers[i7];
            const loader = handlers[i7 + 1];
            if (regex.global) regex.lastIndex = 0;
            if (regex.test(file)) return loader;
        }
        return null;
    };
}
const DefaultLoadingManager2 = new LoadingManager2();
const DefaultLoadingManager1 = DefaultLoadingManager2, LoadingManager1 = LoadingManager2;
export { DefaultLoadingManager1 as DefaultLoadingManager, LoadingManager1 as LoadingManager };
function ImageLoader2(manager) {
    Loader1.call(this, manager);
}
ImageLoader2.prototype = Object.assign(Object.create(Loader1.prototype), {
    constructor: ImageLoader2,
    load: function(url, onLoad, onProgress, onError) {
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope3 = this;
        const cached = Cache1.get(url);
        if (cached !== undefined) {
            scope3.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope3.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        const image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
        function onImageLoad() {
            image.removeEventListener('load', onImageLoad, false);
            image.removeEventListener('error', onImageError, false);
            Cache1.add(url, this);
            if (onLoad) onLoad(this);
            scope3.manager.itemEnd(url);
        }
        function onImageError(event) {
            image.removeEventListener('load', onImageLoad, false);
            image.removeEventListener('error', onImageError, false);
            if (onError) onError(event);
            scope3.manager.itemError(url);
            scope3.manager.itemEnd(url);
        }
        image.addEventListener('load', onImageLoad, false);
        image.addEventListener('error', onImageError, false);
        if (url.substr(0, 5) !== 'data:') {
            if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
        }
        scope3.manager.itemStart(url);
        image.src = url;
        return image;
    }
});
const ImageLoader1 = ImageLoader2;
export { ImageLoader1 as ImageLoader };
function ImageBitmapLoader(manager) {
    if (typeof createImageBitmap === 'undefined') console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
    if (typeof fetch === 'undefined') console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
    Loader1.call(this, manager);
    this.options = {
        premultiplyAlpha: 'none'
    };
}
ImageBitmapLoader.prototype = Object.assign(Object.create(Loader1.prototype), {
    constructor: ImageBitmapLoader,
    isImageBitmapLoader: true,
    setOptions: function setOptions(options1) {
        this.options = options1;
        return this;
    },
    load: function(url, onLoad, onProgress, onError) {
        if (url === undefined) url = '';
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope3 = this;
        const cached = Cache1.get(url);
        if (cached !== undefined) {
            scope3.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope3.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        fetch(url).then(function(res) {
            return res.blob();
        }).then(function(blob) {
            return createImageBitmap(blob, scope3.options);
        }).then(function(imageBitmap) {
            Cache1.add(url, imageBitmap);
            if (onLoad) onLoad(imageBitmap);
            scope3.manager.itemEnd(url);
        }).catch(function(e) {
            if (onError) onError(e);
            scope3.manager.itemError(url);
            scope3.manager.itemEnd(url);
        });
        scope3.manager.itemStart(url);
    }
});
const ImageBitmapLoader1 = ImageBitmapLoader;
export { ImageBitmapLoader1 as ImageBitmapLoader };
/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/
function CurvePath() {
    Curve1.call(this);
    this.type = 'CurvePath';
    this.curves = [];
    this.autoClose = false; // Automatically closes the path
}
CurvePath.prototype = Object.assign(Object.create(Curve1.prototype), {
    constructor: CurvePath,
    add: function(curve) {
        this.curves.push(curve);
    },
    closePath: function() {
        // Add a line curve if start and end of lines are not connected
        const startPoint = this.curves[0].getPoint(0);
        const endPoint = this.curves[this.curves.length - 1].getPoint(1);
        if (!startPoint.equals(endPoint)) this.curves.push(new Curves['LineCurve'](endPoint, startPoint));
    },
    // To get accurate point with reference to
    // entire path distance at time t,
    // following has to be done:
    // 1. Length of each sub path have to be known
    // 2. Locate and identify type of curve
    // 3. Get t for the curve
    // 4. Return curve.getPointAt(t')
    getPoint: function(t2) {
        const d = t2 * this.getLength();
        const curveLengths = this.getCurveLengths();
        let i7 = 0;
        // To think about boundaries points.
        while(i7 < curveLengths.length){
            if (curveLengths[i7] >= d) {
                const diff = curveLengths[i7] - d;
                const curve = this.curves[i7];
                const segmentLength = curve.getLength();
                const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                return curve.getPointAt(u);
            }
            i7++;
        }
        return null;
    },
    // We cannot use the default THREE.Curve getPoint() with getLength() because in
    // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
    // getPoint() depends on getLength
    getLength: function() {
        const lens = this.getCurveLengths();
        return lens[lens.length - 1];
    },
    // cacheLengths must be recalculated.
    updateArcLengths: function() {
        this.needsUpdate = true;
        this.cacheLengths = null;
        this.getCurveLengths();
    },
    // Compute lengths and cache them
    // We cannot overwrite getLengths() because UtoT mapping uses it.
    getCurveLengths: function() {
        // We use cache values if curves and cache array are same length
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        // Get length of sub-curve
        // Push sums into cached array
        const lengths = [];
        let sums = 0;
        for(let i7 = 0, l1 = this.curves.length; i7 < l1; i7++){
            sums += this.curves[i7].getLength();
            lengths.push(sums);
        }
        this.cacheLengths = lengths;
        return lengths;
    },
    getSpacedPoints: function(divisions) {
        if (divisions === undefined) divisions = 40;
        const points1 = [];
        for(let i7 = 0; i7 <= divisions; i7++)points1.push(this.getPoint(i7 / divisions));
        if (this.autoClose) points1.push(points1[0]);
        return points1;
    },
    getPoints: function(divisions) {
        divisions = divisions || 12;
        const points1 = [];
        let last;
        for(let i7 = 0, curves = this.curves; i7 < curves.length; i7++){
            const curve = curves[i7];
            const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
            const pts = curve.getPoints(resolution);
            for(let j4 = 0; j4 < pts.length; j4++){
                const point = pts[j4];
                if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates
                points1.push(point);
                last = point;
            }
        }
        if (this.autoClose && points1.length > 1 && !points1[points1.length - 1].equals(points1[0])) points1.push(points1[0]);
        return points1;
    },
    copy: function(source) {
        Curve1.prototype.copy.call(this, source);
        this.curves = [];
        for(let i7 = 0, l1 = source.curves.length; i7 < l1; i7++){
            const curve = source.curves[i7];
            this.curves.push(curve.clone());
        }
        this.autoClose = source.autoClose;
        return this;
    },
    toJSON: function() {
        const data = Curve1.prototype.toJSON.call(this);
        data.autoClose = this.autoClose;
        data.curves = [];
        for(let i7 = 0, l1 = this.curves.length; i7 < l1; i7++){
            const curve = this.curves[i7];
            data.curves.push(curve.toJSON());
        }
        return data;
    },
    fromJSON: function(json) {
        Curve1.prototype.fromJSON.call(this, json);
        this.autoClose = json.autoClose;
        this.curves = [];
        for(let i7 = 0, l1 = json.curves.length; i7 < l1; i7++){
            const curve = json.curves[i7];
            this.curves.push(new Curves[curve.type]().fromJSON(curve));
        }
        return this;
    }
});
const CurvePath1 = CurvePath;
function EllipseCurve2(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    Curve1.call(this);
    this.type = 'EllipseCurve';
    this.aX = aX || 0;
    this.aY = aY || 0;
    this.xRadius = xRadius || 1;
    this.yRadius = yRadius || 1;
    this.aStartAngle = aStartAngle || 0;
    this.aEndAngle = aEndAngle || 2 * Math.PI;
    this.aClockwise = aClockwise || false;
    this.aRotation = aRotation || 0;
}
EllipseCurve2.prototype = Object.create(Curve1.prototype);
EllipseCurve2.prototype.constructor = EllipseCurve2;
EllipseCurve2.prototype.isEllipseCurve = true;
EllipseCurve2.prototype.getPoint = function(t2, optionalTarget) {
    const point = optionalTarget || new Vector21();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while(deltaAngle < 0)deltaAngle += twoPi;
    while(deltaAngle > twoPi)deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
        if (samePoints) deltaAngle = 0;
        else deltaAngle = twoPi;
    }
    if (this.aClockwise === true && !samePoints) {
        if (deltaAngle === twoPi) deltaAngle = -twoPi;
        else deltaAngle = deltaAngle - twoPi;
    }
    const angle = this.aStartAngle + t2 * deltaAngle;
    let x6 = this.aX + this.xRadius * Math.cos(angle);
    let y6 = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
        const cos = Math.cos(this.aRotation);
        const sin = Math.sin(this.aRotation);
        const tx = x6 - this.aX;
        const ty = y6 - this.aY;
        x6 = tx * cos - ty * sin + this.aX;
        y6 = tx * sin + ty * cos + this.aY;
    }
    return point.set(x6, y6);
};
EllipseCurve2.prototype.copy = function(source) {
    Curve1.prototype.copy.call(this, source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
};
EllipseCurve2.prototype.toJSON = function() {
    const data = Curve1.prototype.toJSON.call(this);
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
};
EllipseCurve2.prototype.fromJSON = function(json) {
    Curve1.prototype.fromJSON.call(this, json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
};
const EllipseCurve3 = EllipseCurve2;
function Path(points1) {
    CurvePath1.call(this);
    this.type = 'Path';
    this.currentPoint = new Vector21();
    if (points1) this.setFromPoints(points1);
}
Path.prototype = Object.assign(Object.create(CurvePath1.prototype), {
    constructor: Path,
    setFromPoints: function(points1) {
        this.moveTo(points1[0].x, points1[0].y);
        for(let i7 = 1, l1 = points1.length; i7 < l1; i7++)this.lineTo(points1[i7].x, points1[i7].y);
        return this;
    },
    moveTo: function(x6, y6) {
        this.currentPoint.set(x6, y6); // TODO consider referencing vectors instead of copying?
        return this;
    },
    lineTo: function(x6, y6) {
        const curve = new LineCurve(this.currentPoint.clone(), new Vector21(x6, y6));
        this.curves.push(curve);
        this.currentPoint.set(x6, y6);
        return this;
    },
    quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
        const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector21(aCPx, aCPy), new Vector21(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
    },
    bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector21(aCP1x, aCP1y), new Vector21(aCP2x, aCP2y), new Vector21(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
    },
    splineThru: function(pts/*Array of Vector*/
    ) {
        const npts = [
            this.currentPoint.clone()
        ].concat(pts);
        const curve = new SplineCurve(npts);
        this.curves.push(curve);
        this.currentPoint.copy(pts[pts.length - 1]);
        return this;
    },
    arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
    },
    absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
    },
    ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        return this;
    },
    absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const curve = new EllipseCurve3(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        if (this.curves.length > 0) {
            // if a previous curve is present, attempt to join
            const firstPoint = curve.getPoint(0);
            if (!firstPoint.equals(this.currentPoint)) this.lineTo(firstPoint.x, firstPoint.y);
        }
        this.curves.push(curve);
        const lastPoint = curve.getPoint(1);
        this.currentPoint.copy(lastPoint);
        return this;
    },
    copy: function(source) {
        CurvePath1.prototype.copy.call(this, source);
        this.currentPoint.copy(source.currentPoint);
        return this;
    },
    toJSON: function() {
        const data = CurvePath1.prototype.toJSON.call(this);
        data.currentPoint = this.currentPoint.toArray();
        return data;
    },
    fromJSON: function(json) {
        CurvePath1.prototype.fromJSON.call(this, json);
        this.currentPoint.fromArray(json.currentPoint);
        return this;
    }
});
const Path1 = Path;
function ShapePath() {
    this.type = 'ShapePath';
    this.color = new Color1();
    this.subPaths = [];
    this.currentPath = null;
}
Object.assign(ShapePath.prototype, {
    moveTo: function(x6, y6) {
        this.currentPath = new Path1();
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo(x6, y6);
        return this;
    },
    lineTo: function(x6, y6) {
        this.currentPath.lineTo(x6, y6);
        return this;
    },
    quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        return this;
    },
    bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        return this;
    },
    splineThru: function(pts) {
        this.currentPath.splineThru(pts);
        return this;
    },
    toShapes: function(isCCW, noHoles) {
        function toShapesNoHoles(inSubpaths) {
            const shapes3 = [];
            for(let i7 = 0, l1 = inSubpaths.length; i7 < l1; i7++){
                const tmpPath = inSubpaths[i7];
                const tmpShape = new Shape1();
                tmpShape.curves = tmpPath.curves;
                shapes3.push(tmpShape);
            }
            return shapes3;
        }
        function isPointInsidePolygon(inPt, inPolygon) {
            const polyLen = inPolygon.length;
            // inPt on polygon contour => immediate success    or
            // toggling of inside/outside at every single! intersection point of an edge
            //  with the horizontal line through inPt, left of inPt
            //  not counting lowerY endpoints of edges and whole edges on that line
            let inside = false;
            for(let p1 = polyLen - 1, q1 = 0; q1 < polyLen; p1 = q1++){
                let edgeLowPt = inPolygon[p1];
                let edgeHighPt = inPolygon[q1];
                let edgeDx = edgeHighPt.x - edgeLowPt.x;
                let edgeDy = edgeHighPt.y - edgeLowPt.y;
                if (Math.abs(edgeDy) > Number.EPSILON) {
                    // not parallel
                    if (edgeDy < 0) {
                        edgeLowPt = inPolygon[q1];
                        edgeDx = -edgeDx;
                        edgeHighPt = inPolygon[p1];
                        edgeDy = -edgeDy;
                    }
                    if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
                    if (inPt.y === edgeLowPt.y) {
                        if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
                    } else {
                        const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                        if (perpEdge === 0) return true; // inPt is on contour ?
                        if (perpEdge < 0) continue;
                        inside = !inside; // true intersection left of inPt
                    }
                } else {
                    // parallel or collinear
                    if (inPt.y !== edgeLowPt.y) continue; // parallel
                    // edge lies on the same horizontal line as inPt
                    if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
                }
            }
            return inside;
        }
        const isClockWise = ShapeUtils1.isClockWise;
        const subPaths = this.subPaths;
        if (subPaths.length === 0) return [];
        if (noHoles === true) return toShapesNoHoles(subPaths);
        let solid, tmpPath, tmpShape;
        const shapes3 = [];
        if (subPaths.length === 1) {
            tmpPath = subPaths[0];
            tmpShape = new Shape1();
            tmpShape.curves = tmpPath.curves;
            shapes3.push(tmpShape);
            return shapes3;
        }
        let holesFirst = !isClockWise(subPaths[0].getPoints());
        holesFirst = isCCW ? !holesFirst : holesFirst;
        // console.log("Holes first", holesFirst);
        const betterShapeHoles = [];
        const newShapes = [];
        let newShapeHoles = [];
        let mainIdx = 0;
        let tmpPoints;
        newShapes[mainIdx] = undefined;
        newShapeHoles[mainIdx] = [];
        for(let i7 = 0, l1 = subPaths.length; i7 < l1; i7++){
            tmpPath = subPaths[i7];
            tmpPoints = tmpPath.getPoints();
            solid = isClockWise(tmpPoints);
            solid = isCCW ? !solid : solid;
            if (solid) {
                if (!holesFirst && newShapes[mainIdx]) mainIdx++;
                newShapes[mainIdx] = {
                    s: new Shape1(),
                    p: tmpPoints
                };
                newShapes[mainIdx].s.curves = tmpPath.curves;
                if (holesFirst) mainIdx++;
                newShapeHoles[mainIdx] = [];
            } else newShapeHoles[mainIdx].push({
                h: tmpPath,
                p: tmpPoints[0]
            });
        }
        // only Holes? -> probably all Shapes with wrong orientation
        if (!newShapes[0]) return toShapesNoHoles(subPaths);
        if (newShapes.length > 1) {
            let ambiguous = false;
            const toChange = [];
            for(let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++)betterShapeHoles[sIdx] = [];
            for(let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++){
                const sho = newShapeHoles[sIdx];
                for(let hIdx = 0; hIdx < sho.length; hIdx++){
                    const ho = sho[hIdx];
                    let hole_unassigned = true;
                    for(let s2Idx = 0; s2Idx < newShapes.length; s2Idx++)if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                        if (sIdx !== s2Idx) toChange.push({
                            froms: sIdx,
                            tos: s2Idx,
                            hole: hIdx
                        });
                        if (hole_unassigned) {
                            hole_unassigned = false;
                            betterShapeHoles[s2Idx].push(ho);
                        } else ambiguous = true;
                    }
                    if (hole_unassigned) betterShapeHoles[sIdx].push(ho);
                }
            }
            // console.log("ambiguous: ", ambiguous);
            if (toChange.length > 0) // console.log("to change: ", toChange);
            {
                if (!ambiguous) newShapeHoles = betterShapeHoles;
            }
        }
        let tmpHoles;
        for(let i7 = 0, il = newShapes.length; i7 < il; i7++){
            tmpShape = newShapes[i7].s;
            shapes3.push(tmpShape);
            tmpHoles = newShapeHoles[i7];
            for(let j4 = 0, jl = tmpHoles.length; j4 < jl; j4++)tmpShape.holes.push(tmpHoles[j4].h);
        }
        //console.log("shape", shapes);
        return shapes3;
    }
});
const ShapePath1 = ShapePath;
function Font(data) {
    this.type = 'Font';
    this.data = data;
}
Object.assign(Font.prototype, {
    isFont: true,
    generateShapes: function(text1, size) {
        if (size === undefined) size = 100;
        const shapes3 = [];
        const paths = createPaths(text1, size, this.data);
        for(let p1 = 0, pl = paths.length; p1 < pl; p1++)Array.prototype.push.apply(shapes3, paths[p1].toShapes());
        return shapes3;
    }
});
function createPaths(text1, size, data) {
    const chars = Array.from ? Array.from(text1) : String(text1).split(''); // workaround for IE11, see #13988
    const scale = size / data.resolution;
    const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
    const paths = [];
    let offsetX = 0, offsetY = 0;
    for(let i7 = 0; i7 < chars.length; i7++){
        const char = chars[i7];
        if (char === '\n') {
            offsetX = 0;
            offsetY -= line_height;
        } else {
            const ret = createPath(char, scale, offsetX, offsetY, data);
            offsetX += ret.offsetX;
            paths.push(ret.path);
        }
    }
    return paths;
}
function createPath(char, scale, offsetX, offsetY, data) {
    const glyph = data.glyphs[char] || data.glyphs['?'];
    if (!glyph) {
        console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
        return;
    }
    const path1 = new ShapePath1();
    let x6, y6, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
    if (glyph.o) {
        const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
        for(let i7 = 0, l1 = outline.length; i7 < l1;){
            const action = outline[i7++];
            switch(action){
                case 'm':
                    x6 = outline[i7++] * scale + offsetX;
                    y6 = outline[i7++] * scale + offsetY;
                    path1.moveTo(x6, y6);
                    break;
                case 'l':
                    x6 = outline[i7++] * scale + offsetX;
                    y6 = outline[i7++] * scale + offsetY;
                    path1.lineTo(x6, y6);
                    break;
                case 'q':
                    cpx = outline[i7++] * scale + offsetX;
                    cpy = outline[i7++] * scale + offsetY;
                    cpx1 = outline[i7++] * scale + offsetX;
                    cpy1 = outline[i7++] * scale + offsetY;
                    path1.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                    break;
                case 'b':
                    cpx = outline[i7++] * scale + offsetX;
                    cpy = outline[i7++] * scale + offsetY;
                    cpx1 = outline[i7++] * scale + offsetX;
                    cpy1 = outline[i7++] * scale + offsetY;
                    cpx2 = outline[i7++] * scale + offsetX;
                    cpy2 = outline[i7++] * scale + offsetY;
                    path1.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                    break;
            }
        }
    }
    return {
        offsetX: glyph.ha * scale,
        path: path1
    };
}
const Font1 = Font;
function FontLoader(manager) {
    Loader1.call(this, manager);
}
FontLoader.prototype = Object.assign(Object.create(Loader1.prototype), {
    constructor: FontLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope3 = this;
        const loader = new FileLoader1(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.load(url, function(text1) {
            let json;
            try {
                json = JSON.parse(text1);
            } catch (e) {
                console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
                json = JSON.parse(text1.substring(65, text1.length - 2));
            }
            const font1 = scope3.parse(json);
            if (onLoad) onLoad(font1);
        }, onProgress, onError);
    },
    parse: function(json) {
        return new Font1(json);
    }
});
const FontLoader1 = FontLoader;
export { FontLoader1 as FontLoader };
const loading = {
};
function FileLoader2(manager) {
    Loader1.call(this, manager);
}
FileLoader2.prototype = Object.assign(Object.create(Loader1.prototype), {
    constructor: FileLoader2,
    load: function(url, onLoad, onProgress, onError) {
        if (url === undefined) url = '';
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope3 = this;
        const cached = Cache1.get(url);
        if (cached !== undefined) {
            scope3.manager.itemStart(url);
            setTimeout(function() {
                if (onLoad) onLoad(cached);
                scope3.manager.itemEnd(url);
            }, 0);
            return cached;
        }
        if (loading[url] !== undefined) {
            loading[url].push({
                onLoad: onLoad,
                onProgress: onProgress,
                onError: onError
            });
            return;
        }
        const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
        const dataUriRegexResult = url.match(dataUriRegex);
        let request;
        if (dataUriRegexResult) {
            const mimeType = dataUriRegexResult[1];
            const isBase64 = !!dataUriRegexResult[2];
            let data = dataUriRegexResult[3];
            data = decodeURIComponent(data);
            if (isBase64) data = atob(data);
            try {
                let response;
                const responseType = (this.responseType || '').toLowerCase();
                switch(responseType){
                    case 'arraybuffer':
                    case 'blob':
                        const view = new Uint8Array(data.length);
                        for(let i7 = 0; i7 < data.length; i7++)view[i7] = data.charCodeAt(i7);
                        if (responseType === 'blob') response = new Blob([
                            view.buffer
                        ], {
                            type: mimeType
                        });
                        else response = view.buffer;
                        break;
                    case 'document':
                        const parser = new DOMParser();
                        response = parser.parseFromString(data, mimeType);
                        break;
                    case 'json':
                        response = JSON.parse(data);
                        break;
                    default:
                        response = data;
                        break;
                }
                setTimeout(function() {
                    if (onLoad) onLoad(response);
                    scope3.manager.itemEnd(url);
                }, 0);
            } catch (error) {
                setTimeout(function() {
                    if (onError) onError(error);
                    scope3.manager.itemError(url);
                    scope3.manager.itemEnd(url);
                }, 0);
            }
        } else {
            loading[url] = [];
            loading[url].push({
                onLoad: onLoad,
                onProgress: onProgress,
                onError: onError
            });
            request = new XMLHttpRequest();
            request.open('GET', url, true);
            request.addEventListener('load', function(event) {
                const response = this.response;
                const callbacks = loading[url];
                delete loading[url];
                if (this.status === 200 || this.status === 0) {
                    if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.');
                    Cache1.add(url, response);
                    for(let i7 = 0, il = callbacks.length; i7 < il; i7++){
                        const callback = callbacks[i7];
                        if (callback.onLoad) callback.onLoad(response);
                    }
                    scope3.manager.itemEnd(url);
                } else {
                    for(let i7 = 0, il = callbacks.length; i7 < il; i7++){
                        const callback = callbacks[i7];
                        if (callback.onError) callback.onError(event);
                    }
                    scope3.manager.itemError(url);
                    scope3.manager.itemEnd(url);
                }
            }, false);
            request.addEventListener('progress', function(event) {
                const callbacks = loading[url];
                for(let i7 = 0, il = callbacks.length; i7 < il; i7++){
                    const callback = callbacks[i7];
                    if (callback.onProgress) callback.onProgress(event);
                }
            }, false);
            request.addEventListener('error', function(event) {
                const callbacks = loading[url];
                delete loading[url];
                for(let i7 = 0, il = callbacks.length; i7 < il; i7++){
                    const callback = callbacks[i7];
                    if (callback.onError) callback.onError(event);
                }
                scope3.manager.itemError(url);
                scope3.manager.itemEnd(url);
            }, false);
            request.addEventListener('abort', function(event) {
                const callbacks = loading[url];
                delete loading[url];
                for(let i7 = 0, il = callbacks.length; i7 < il; i7++){
                    const callback = callbacks[i7];
                    if (callback.onError) callback.onError(event);
                }
                scope3.manager.itemError(url);
                scope3.manager.itemEnd(url);
            }, false);
            if (this.responseType !== undefined) request.responseType = this.responseType;
            if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
            if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');
            for(const header in this.requestHeader)request.setRequestHeader(header, this.requestHeader[header]);
            request.send(null);
        }
        scope3.manager.itemStart(url);
        return request;
    },
    setResponseType: function(value) {
        this.responseType = value;
        return this;
    },
    setWithCredentials: function(value) {
        this.withCredentials = value;
        return this;
    },
    setMimeType: function(value) {
        this.mimeType = value;
        return this;
    }
});
const FileLoader1 = FileLoader2;
export { FileLoader1 as FileLoader };
function Loader2(manager) {
    this.manager = manager !== undefined ? manager : DefaultLoadingManager1;
    this.crossOrigin = 'anonymous';
    this.path = '';
    this.resourcePath = '';
    this.requestHeader = {
    };
}
Object.assign(Loader2.prototype, {
    load: function() {
    },
    loadAsync: function(url, onProgress) {
        const scope3 = this;
        return new Promise(function(resolve, reject) {
            scope3.load(url, resolve, onProgress, reject);
        });
    },
    parse: function() {
    },
    setCrossOrigin: function(crossOrigin) {
        this.crossOrigin = crossOrigin;
        return this;
    },
    setPath: function(path1) {
        this.path = path1;
        return this;
    },
    setResourcePath: function(resourcePath) {
        this.resourcePath = resourcePath;
        return this;
    },
    setRequestHeader: function(requestHeader) {
        this.requestHeader = requestHeader;
        return this;
    }
});
const Loader1 = Loader2;
export { Loader1 as Loader };
const LoaderUtils2 = {
    decodeText: function(array) {
        if (typeof TextDecoder !== 'undefined') return new TextDecoder().decode(array);
        let s1 = '';
        for(let i7 = 0, il = array.length; i7 < il; i7++)s1 += String.fromCharCode(array[i7]);
        try {
            return decodeURIComponent(escape(s1));
        } catch (e) {
            return s1;
        }
    },
    extractUrlBase: function(url) {
        const index2 = url.lastIndexOf('/');
        if (index2 === -1) return './';
        return url.substr(0, index2 + 1);
    }
};
const LoaderUtils1 = LoaderUtils2;
export { LoaderUtils1 as LoaderUtils };
const Cache12 = {
    enabled: false,
    files: {
    },
    add: function(key, file) {
        if (this.enabled === false) return;
        this.files[key] = file;
    },
    get: function(key) {
        if (this.enabled === false) return;
        return this.files[key];
    },
    remove: function(key) {
        delete this.files[key];
    },
    clear: function() {
        this.files = {
        };
    }
};
const Cache2 = Cache12;
export { Cache2 as Cache };
let _context;
const AudioContext11 = {
    getContext: function() {
        if (_context === undefined) _context = new window.AudioContext || window.webkitAudioContext();
        return _context;
    },
    setContext: function(value) {
        _context = value;
    }
};
const AudioContext2 = AudioContext11;
function AudioLoader(manager) {
    Loader1.call(this, manager);
}
AudioLoader.prototype = Object.assign(Object.create(Loader1.prototype), {
    constructor: AudioLoader,
    load: function(url, onLoad, onProgress, onError) {
        const scope3 = this;
        const loader = new FileLoader1(scope3.manager);
        loader.setResponseType('arraybuffer');
        loader.setPath(scope3.path);
        loader.setRequestHeader(scope3.requestHeader);
        loader.load(url, function(buffer) {
            try {
                // Create a copy of the buffer. The `decodeAudioData` method
                // detaches the buffer when complete, preventing reuse.
                const bufferCopy = buffer.slice(0);
                const context = AudioContext1.getContext();
                context.decodeAudioData(bufferCopy, function(audioBuffer) {
                    onLoad(audioBuffer);
                });
            } catch (e) {
                if (onError) onError(e);
                else console.error(e);
                scope3.manager.itemError(url);
            }
        }, onProgress, onError);
    }
});
const AudioLoader1 = AudioLoader;
export { AudioLoader1 as AudioLoader };
function SpotLightShadow2() {
    LightShadow1.call(this, new PerspectiveCamera1(50, 1, 0.5, 500));
}
SpotLightShadow2.prototype = Object.assign(Object.create(LightShadow1.prototype), {
    constructor: SpotLightShadow2,
    isSpotLightShadow: true,
    updateMatrices: function(light) {
        const camera = this.camera;
        const fov1 = MathUtils1.RAD2DEG * 2 * light.angle;
        const aspect1 = this.mapSize.width / this.mapSize.height;
        const far = light.distance || camera.far;
        if (fov1 !== camera.fov || aspect1 !== camera.aspect || far !== camera.far) {
            camera.fov = fov1;
            camera.aspect = aspect1;
            camera.far = far;
            camera.updateProjectionMatrix();
        }
        LightShadow1.prototype.updateMatrices.call(this, light);
    }
});
const SpotLightShadow1 = SpotLightShadow2;
export { SpotLightShadow1 as SpotLightShadow };
function SpotLightShadow3() {
    LightShadow1.call(this, new PerspectiveCamera1(50, 1, 0.5, 500));
}
SpotLightShadow3.prototype = Object.assign(Object.create(LightShadow1.prototype), {
    constructor: SpotLightShadow3,
    isSpotLightShadow: true,
    updateMatrices: function(light) {
        const camera = this.camera;
        const fov1 = MathUtils1.RAD2DEG * 2 * light.angle;
        const aspect1 = this.mapSize.width / this.mapSize.height;
        const far = light.distance || camera.far;
        if (fov1 !== camera.fov || aspect1 !== camera.aspect || far !== camera.far) {
            camera.fov = fov1;
            camera.aspect = aspect1;
            camera.far = far;
            camera.updateProjectionMatrix();
        }
        LightShadow1.prototype.updateMatrices.call(this, light);
    }
});
const SpotLightShadow1 = SpotLightShadow3;
function SpotLight2(color1, intensity, distance, angle, penumbra, decay) {
    Light1.call(this, color1, intensity);
    this.type = 'SpotLight';
    this.position.copy(Object3D1.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D1();
    Object.defineProperty(this, 'power', {
        get: function() {
            return this.intensity * Math.PI;
        },
        set: function(power) {
            this.intensity = power / Math.PI;
        }
    });
    this.distance = distance !== undefined ? distance : 0;
    this.angle = angle !== undefined ? angle : Math.PI / 3;
    this.penumbra = penumbra !== undefined ? penumbra : 0;
    this.decay = decay !== undefined ? decay : 1;
    this.shadow = new SpotLightShadow1();
}
SpotLight2.prototype = Object.assign(Object.create(Light1.prototype), {
    constructor: SpotLight2,
    isSpotLight: true,
    copy: function(source) {
        Light1.prototype.copy.call(this, source);
        this.distance = source.distance;
        this.angle = source.angle;
        this.penumbra = source.penumbra;
        this.decay = source.decay;
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    }
});
const SpotLight1 = SpotLight2;
export { SpotLight1 as SpotLight };
function PointLightShadow() {
    LightShadow1.call(this, new PerspectiveCamera1(90, 1, 0.5, 500));
    this._frameExtents = new Vector21(4, 2);
    this._viewportCount = 6;
    this._viewports = [
        // These viewports map a cube-map onto a 2D texture with the
        // following orientation:
        //
        //  xzXZ
        //   y Y
        //
        // X - Positive x direction
        // x - Negative x direction
        // Y - Positive y direction
        // y - Negative y direction
        // Z - Positive z direction
        // z - Negative z direction
        // positive X
        new Vector41(2, 1, 1, 1),
        // negative X
        new Vector41(0, 1, 1, 1),
        // positive Z
        new Vector41(3, 1, 1, 1),
        // negative Z
        new Vector41(1, 1, 1, 1),
        // positive Y
        new Vector41(3, 0, 1, 1),
        // negative Y
        new Vector41(1, 0, 1, 1)
    ];
    this._cubeDirections = [
        new Vector31(1, 0, 0),
        new Vector31(-1, 0, 0),
        new Vector31(0, 0, 1),
        new Vector31(0, 0, -1),
        new Vector31(0, 1, 0),
        new Vector31(0, -1, 0)
    ];
    this._cubeUps = [
        new Vector31(0, 1, 0),
        new Vector31(0, 1, 0),
        new Vector31(0, 1, 0),
        new Vector31(0, 1, 0),
        new Vector31(0, 0, 1),
        new Vector31(0, 0, -1)
    ];
}
PointLightShadow.prototype = Object.assign(Object.create(LightShadow1.prototype), {
    constructor: PointLightShadow,
    isPointLightShadow: true,
    updateMatrices: function(light, viewportIndex) {
        if (viewportIndex === undefined) viewportIndex = 0;
        const camera = this.camera, shadowMatrix = this.matrix, lightPositionWorld = this._lightPositionWorld, lookTarget = this._lookTarget, projScreenMatrix = this._projScreenMatrix;
        lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
        camera.position.copy(lightPositionWorld);
        lookTarget.copy(camera.position);
        lookTarget.add(this._cubeDirections[viewportIndex]);
        camera.up.copy(this._cubeUps[viewportIndex]);
        camera.lookAt(lookTarget);
        camera.updateMatrixWorld();
        shadowMatrix.makeTranslation(-lightPositionWorld.x, -lightPositionWorld.y, -lightPositionWorld.z);
        projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(projScreenMatrix);
    }
});
const PointLightShadow1 = PointLightShadow;
function PointLight(color1, intensity, distance, decay) {
    Light1.call(this, color1, intensity);
    this.type = 'PointLight';
    Object.defineProperty(this, 'power', {
        get: function() {
            // intensity = power per solid angle.
            // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
            return this.intensity * 4 * Math.PI;
        },
        set: function(power) {
            // intensity = power per solid angle.
            // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
            this.intensity = power / (4 * Math.PI);
        }
    });
    this.distance = distance !== undefined ? distance : 0;
    this.decay = decay !== undefined ? decay : 1; // for physically correct lights, should be 2.
    this.shadow = new PointLightShadow1();
}
PointLight.prototype = Object.assign(Object.create(Light1.prototype), {
    constructor: PointLight,
    isPointLight: true,
    copy: function(source) {
        Light1.prototype.copy.call(this, source);
        this.distance = source.distance;
        this.decay = source.decay;
        this.shadow = source.shadow.clone();
        return this;
    }
});
const PointLight1 = PointLight;
export { PointLight1 as PointLight };
function RectAreaLight2(color1, intensity, width2, height3) {
    Light1.call(this, color1, intensity);
    this.type = 'RectAreaLight';
    this.width = width2 !== undefined ? width2 : 10;
    this.height = height3 !== undefined ? height3 : 10;
}
RectAreaLight2.prototype = Object.assign(Object.create(Light1.prototype), {
    constructor: RectAreaLight2,
    isRectAreaLight: true,
    copy: function(source) {
        Light1.prototype.copy.call(this, source);
        this.width = source.width;
        this.height = source.height;
        return this;
    },
    toJSON: function(meta) {
        const data = Light1.prototype.toJSON.call(this, meta);
        data.object.width = this.width;
        data.object.height = this.height;
        return data;
    }
});
const RectAreaLight1 = RectAreaLight2;
export { RectAreaLight1 as RectAreaLight };
function HemisphereLight2(skyColor, groundColor, intensity) {
    Light1.call(this, skyColor, intensity);
    this.type = 'HemisphereLight';
    this.castShadow = undefined;
    this.position.copy(Object3D1.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color1(groundColor);
}
HemisphereLight2.prototype = Object.assign(Object.create(Light1.prototype), {
    constructor: HemisphereLight2,
    isHemisphereLight: true,
    copy: function(source) {
        Light1.prototype.copy.call(this, source);
        this.groundColor.copy(source.groundColor);
        return this;
    }
});
const HemisphereLight1 = HemisphereLight2;
export { HemisphereLight1 as HemisphereLight };
function HemisphereLightProbe(skyColor, groundColor, intensity) {
    LightProbe1.call(this, undefined, intensity);
    const color1 = new Color1().set(skyColor);
    const color2 = new Color1().set(groundColor);
    const sky = new Vector31(color1.r, color1.g, color1.b);
    const ground = new Vector31(color2.r, color2.g, color2.b);
    // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
    const c0 = Math.sqrt(Math.PI);
    const c11 = c0 * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c11);
}
HemisphereLightProbe.prototype = Object.assign(Object.create(LightProbe1.prototype), {
    constructor: HemisphereLightProbe,
    isHemisphereLightProbe: true,
    copy: function(source) {
        LightProbe1.prototype.copy.call(this, source);
        return this;
    },
    toJSON: function(meta) {
        const data = LightProbe1.prototype.toJSON.call(this, meta);
        // data.sh = this.sh.toArray(); // todo
        return data;
    }
});
const HemisphereLightProbe1 = HemisphereLightProbe;
export { HemisphereLightProbe1 as HemisphereLightProbe };
function DirectionalLightShadow2() {
    LightShadow1.call(this, new OrthographicCamera1(-5, 5, 5, -5, 0.5, 500));
}
DirectionalLightShadow2.prototype = Object.assign(Object.create(LightShadow1.prototype), {
    constructor: DirectionalLightShadow2,
    isDirectionalLightShadow: true,
    updateMatrices: function(light) {
        LightShadow1.prototype.updateMatrices.call(this, light);
    }
});
const DirectionalLightShadow1 = DirectionalLightShadow2;
export { DirectionalLightShadow1 as DirectionalLightShadow };
function DirectionalLightShadow3() {
    LightShadow1.call(this, new OrthographicCamera1(-5, 5, 5, -5, 0.5, 500));
}
DirectionalLightShadow3.prototype = Object.assign(Object.create(LightShadow1.prototype), {
    constructor: DirectionalLightShadow3,
    isDirectionalLightShadow: true,
    updateMatrices: function(light) {
        LightShadow1.prototype.updateMatrices.call(this, light);
    }
});
const DirectionalLightShadow1 = DirectionalLightShadow3;
function DirectionalLight2(color1, intensity) {
    Light1.call(this, color1, intensity);
    this.type = 'DirectionalLight';
    this.position.copy(Object3D1.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D1();
    this.shadow = new DirectionalLightShadow1();
}
DirectionalLight2.prototype = Object.assign(Object.create(Light1.prototype), {
    constructor: DirectionalLight2,
    isDirectionalLight: true,
    copy: function(source) {
        Light1.prototype.copy.call(this, source);
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
    }
});
const DirectionalLight1 = DirectionalLight2;
export { DirectionalLight1 as DirectionalLight };
function AmbientLight2(color1, intensity) {
    Light1.call(this, color1, intensity);
    this.type = 'AmbientLight';
    this.castShadow = undefined;
}
AmbientLight2.prototype = Object.assign(Object.create(Light1.prototype), {
    constructor: AmbientLight2,
    isAmbientLight: true
});
const AmbientLight1 = AmbientLight2;
export { AmbientLight1 as AmbientLight };
function AmbientLightProbe(color1, intensity) {
    LightProbe1.call(this, undefined, intensity);
    const color1 = new Color1().set(color1);
    // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
    this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
}
AmbientLightProbe.prototype = Object.assign(Object.create(LightProbe1.prototype), {
    constructor: AmbientLightProbe,
    isAmbientLightProbe: true,
    copy: function(source) {
        LightProbe1.prototype.copy.call(this, source);
        return this;
    },
    toJSON: function(meta) {
        const data = LightProbe1.prototype.toJSON.call(this, meta);
        // data.sh = this.sh.toArray(); // todo
        return data;
    }
});
const AmbientLightProbe1 = AmbientLightProbe;
export { AmbientLightProbe1 as AmbientLightProbe };
function LightShadow2(camera) {
    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.mapSize = new Vector21(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix41();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum1();
    this._frameExtents = new Vector21(1, 1);
    this._viewportCount = 1;
    this._viewports = [
        new Vector41(0, 0, 1, 1)
    ];
}
Object.assign(LightShadow2.prototype, {
    _projScreenMatrix: new Matrix41(),
    _lightPositionWorld: new Vector31(),
    _lookTarget: new Vector31(),
    getViewportCount: function() {
        return this._viewportCount;
    },
    getFrustum: function() {
        return this._frustum;
    },
    updateMatrices: function(light) {
        const shadowCamera = this.camera, shadowMatrix = this.matrix, projScreenMatrix = this._projScreenMatrix, lookTarget = this._lookTarget, lightPositionWorld = this._lightPositionWorld;
        lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
        shadowCamera.position.copy(lightPositionWorld);
        lookTarget.setFromMatrixPosition(light.target.matrixWorld);
        shadowCamera.lookAt(lookTarget);
        shadowCamera.updateMatrixWorld();
        projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(projScreenMatrix);
        shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
        shadowMatrix.multiply(shadowCamera.projectionMatrix);
        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
    },
    getViewport: function(viewportIndex) {
        return this._viewports[viewportIndex];
    },
    getFrameExtents: function() {
        return this._frameExtents;
    },
    copy: function(source) {
        this.camera = source.camera.clone();
        this.bias = source.bias;
        this.radius = source.radius;
        this.mapSize.copy(source.mapSize);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    toJSON: function() {
        const object = {
        };
        if (this.bias !== 0) object.bias = this.bias;
        if (this.normalBias !== 0) object.normalBias = this.normalBias;
        if (this.radius !== 1) object.radius = this.radius;
        if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
        object.camera = this.camera.toJSON(false).object;
        delete object.camera.matrix;
        return object;
    }
});
const LightShadow1 = LightShadow2;
export { LightShadow1 as LightShadow };
function Light2(color1, intensity) {
    Object3D1.call(this);
    this.type = 'Light';
    this.color = new Color1(color1);
    this.intensity = intensity !== undefined ? intensity : 1;
    this.receiveShadow = undefined;
}
Light2.prototype = Object.assign(Object.create(Object3D1.prototype), {
    constructor: Light2,
    isLight: true,
    copy: function(source) {
        Object3D1.prototype.copy.call(this, source);
        this.color.copy(source.color);
        this.intensity = source.intensity;
        return this;
    },
    toJSON: function(meta) {
        const data = Object3D1.prototype.toJSON.call(this, meta);
        data.object.color = this.color.getHex();
        data.object.intensity = this.intensity;
        if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
        if (this.distance !== undefined) data.object.distance = this.distance;
        if (this.angle !== undefined) data.object.angle = this.angle;
        if (this.decay !== undefined) data.object.decay = this.decay;
        if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
        if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
        return data;
    }
});
const Light1 = Light2;
export { Light1 as Light };
function SphericalHarmonics32() {
    this.coefficients = [];
    for(let i7 = 0; i7 < 9; i7++)this.coefficients.push(new Vector31());
}
Object.assign(SphericalHarmonics32.prototype, {
    isSphericalHarmonics3: true,
    set: function(coefficients) {
        for(let i7 = 0; i7 < 9; i7++)this.coefficients[i7].copy(coefficients[i7]);
        return this;
    },
    zero: function() {
        for(let i7 = 0; i7 < 9; i7++)this.coefficients[i7].set(0, 0, 0);
        return this;
    },
    getAt: function(normal6, target) {
        const x6 = normal6.x, y6 = normal6.y, z5 = normal6.z;
        const coeff = this.coefficients;
        target.copy(coeff[0]).multiplyScalar(0.282095);
        target.addScaledVector(coeff[1], 0.488603 * y6);
        target.addScaledVector(coeff[2], 0.488603 * z5);
        target.addScaledVector(coeff[3], 0.488603 * x6);
        target.addScaledVector(coeff[4], 1.092548 * (x6 * y6));
        target.addScaledVector(coeff[5], 1.092548 * (y6 * z5));
        target.addScaledVector(coeff[6], 0.315392 * (3 * z5 * z5 - 1));
        target.addScaledVector(coeff[7], 1.092548 * (x6 * z5));
        target.addScaledVector(coeff[8], 0.546274 * (x6 * x6 - y6 * y6));
        return target;
    },
    getIrradianceAt: function(normal6, target) {
        const x6 = normal6.x, y6 = normal6.y, z5 = normal6.z;
        const coeff = this.coefficients;
        target.copy(coeff[0]).multiplyScalar(0.886227);
        target.addScaledVector(coeff[1], 1.023328 * y6);
        target.addScaledVector(coeff[2], 1.023328 * z5);
        target.addScaledVector(coeff[3], 1.023328 * x6);
        target.addScaledVector(coeff[4], 0.858086 * x6 * y6);
        target.addScaledVector(coeff[5], 0.858086 * y6 * z5);
        target.addScaledVector(coeff[6], 0.743125 * z5 * z5 - 0.247708);
        target.addScaledVector(coeff[7], 0.858086 * x6 * z5);
        target.addScaledVector(coeff[8], 0.429043 * (x6 * x6 - y6 * y6));
        return target;
    },
    add: function(sh) {
        for(let i7 = 0; i7 < 9; i7++)this.coefficients[i7].add(sh.coefficients[i7]);
        return this;
    },
    addScaledSH: function(sh, s1) {
        for(let i7 = 0; i7 < 9; i7++)this.coefficients[i7].addScaledVector(sh.coefficients[i7], s1);
        return this;
    },
    scale: function(s1) {
        for(let i7 = 0; i7 < 9; i7++)this.coefficients[i7].multiplyScalar(s1);
        return this;
    },
    lerp: function(sh, alpha) {
        for(let i7 = 0; i7 < 9; i7++)this.coefficients[i7].lerp(sh.coefficients[i7], alpha);
        return this;
    },
    equals: function(sh) {
        for(let i7 = 0; i7 < 9; i7++)if (!this.coefficients[i7].equals(sh.coefficients[i7])) return false;
        return true;
    },
    copy: function(sh) {
        return this.set(sh.coefficients);
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        const coefficients = this.coefficients;
        for(let i7 = 0; i7 < 9; i7++)coefficients[i7].fromArray(array, offset + i7 * 3);
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        const coefficients = this.coefficients;
        for(let i7 = 0; i7 < 9; i7++)coefficients[i7].toArray(array, offset + i7 * 3);
        return array;
    }
});
Object.assign(SphericalHarmonics32, {
    getBasisAt: function(normal6, shBasis) {
        const x6 = normal6.x, y6 = normal6.y, z5 = normal6.z;
        shBasis[0] = 0.282095;
        shBasis[1] = 0.488603 * y6;
        shBasis[2] = 0.488603 * z5;
        shBasis[3] = 0.488603 * x6;
        shBasis[4] = 1.092548 * x6 * y6;
        shBasis[5] = 1.092548 * y6 * z5;
        shBasis[6] = 0.315392 * (3 * z5 * z5 - 1);
        shBasis[7] = 1.092548 * x6 * z5;
        shBasis[8] = 0.546274 * (x6 * x6 - y6 * y6);
    }
});
const SphericalHarmonics31 = SphericalHarmonics32;
function LightProbe2(sh, intensity) {
    Light1.call(this, undefined, intensity);
    this.type = 'LightProbe';
    this.sh = sh !== undefined ? sh : new SphericalHarmonics31();
}
LightProbe2.prototype = Object.assign(Object.create(Light1.prototype), {
    constructor: LightProbe2,
    isLightProbe: true,
    copy: function(source) {
        Light1.prototype.copy.call(this, source);
        this.sh.copy(source.sh);
        return this;
    },
    fromJSON: function(json) {
        this.intensity = json.intensity;
        this.sh.fromArray(json.sh);
        return this;
    },
    toJSON: function(meta) {
        const data = Light1.prototype.toJSON.call(this, meta);
        data.object.sh = this.sh.toArray();
        return data;
    }
});
const LightProbe1 = LightProbe2;
export { LightProbe1 as LightProbe };
const _eyeRight = new Matrix41();
const _eyeLeft = new Matrix41();
function StereoCamera() {
    this.type = 'StereoCamera';
    this.aspect = 1;
    this.eyeSep = 0.064;
    this.cameraL = new PerspectiveCamera1();
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = false;
    this.cameraR = new PerspectiveCamera1();
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = false;
    this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null
    };
}
Object.assign(StereoCamera.prototype, {
    update: function(camera) {
        const cache = this._cache;
        const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
        if (needsUpdate) {
            cache.focus = camera.focus;
            cache.fov = camera.fov;
            cache.aspect = camera.aspect * this.aspect;
            cache.near = camera.near;
            cache.far = camera.far;
            cache.zoom = camera.zoom;
            cache.eyeSep = this.eyeSep;
            // Off-axis stereoscopic effect based on
            // http://paulbourke.net/stereographics/stereorender/
            const projectionMatrix = camera.projectionMatrix.clone();
            const eyeSepHalf = cache.eyeSep / 2;
            const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
            const ymax = cache.near * Math.tan(MathUtils1.DEG2RAD * cache.fov * 0.5) / cache.zoom;
            let xmin, xmax;
            // translate xOffset
            _eyeLeft.elements[12] = -eyeSepHalf;
            _eyeRight.elements[12] = eyeSepHalf;
            // for left eye
            xmin = -ymax * cache.aspect + eyeSepOnProjection;
            xmax = ymax * cache.aspect + eyeSepOnProjection;
            projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraL.projectionMatrix.copy(projectionMatrix);
            // for right eye
            xmin = -ymax * cache.aspect - eyeSepOnProjection;
            xmax = ymax * cache.aspect - eyeSepOnProjection;
            projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
            projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
            this.cameraR.projectionMatrix.copy(projectionMatrix);
        }
        this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
        this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
    }
});
const StereoCamera1 = StereoCamera;
export { StereoCamera1 as StereoCamera };
function Camera() {
    Object3D1.call(this);
    this.type = 'Camera';
    this.matrixWorldInverse = new Matrix41();
    this.projectionMatrix = new Matrix41();
    this.projectionMatrixInverse = new Matrix41();
}
Camera.prototype = Object.assign(Object.create(Object3D1.prototype), {
    constructor: Camera,
    isCamera: true,
    copy: function(source, recursive) {
        Object3D1.prototype.copy.call(this, source, recursive);
        this.matrixWorldInverse.copy(source.matrixWorldInverse);
        this.projectionMatrix.copy(source.projectionMatrix);
        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
        return this;
    },
    getWorldDirection: function(target) {
        if (target === undefined) {
            console.warn('THREE.Camera: .getWorldDirection() target is now required');
            target = new Vector31();
        }
        this.updateMatrixWorld(true);
        const e = this.matrixWorld.elements;
        return target.set(-e[8], -e[9], -e[10]).normalize();
    },
    updateMatrixWorld: function(force) {
        Object3D1.prototype.updateMatrixWorld.call(this, force);
        this.matrixWorldInverse.getInverse(this.matrixWorld);
    },
    updateWorldMatrix: function(updateParents, updateChildren) {
        Object3D1.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
        this.matrixWorldInverse.getInverse(this.matrixWorld);
    },
    clone: function() {
        return new this.constructor().copy(this);
    }
});
const Camera1 = Camera;
function PerspectiveCamera2(fov1, aspect1, near, far) {
    Camera1.call(this);
    this.type = 'PerspectiveCamera';
    this.fov = fov1 !== undefined ? fov1 : 50;
    this.zoom = 1;
    this.near = near !== undefined ? near : 0.1;
    this.far = far !== undefined ? far : 2000;
    this.focus = 10;
    this.aspect = aspect1 !== undefined ? aspect1 : 1;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
}
PerspectiveCamera2.prototype = Object.assign(Object.create(Camera1.prototype), {
    constructor: PerspectiveCamera2,
    isPerspectiveCamera: true,
    copy: function(source, recursive) {
        Camera1.prototype.copy.call(this, source, recursive);
        this.fov = source.fov;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.aspect = source.aspect;
        this.view = source.view === null ? null : Object.assign({
        }, source.view);
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset;
        return this;
    },
    setFocalLength: function(focalLength) {
        const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
        this.fov = MathUtils1.RAD2DEG * 2 * Math.atan(vExtentSlope);
        this.updateProjectionMatrix();
    },
    getFocalLength: function() {
        const vExtentSlope = Math.tan(MathUtils1.DEG2RAD * 0.5 * this.fov);
        return 0.5 * this.getFilmHeight() / vExtentSlope;
    },
    getEffectiveFOV: function() {
        return MathUtils1.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils1.DEG2RAD * 0.5 * this.fov) / this.zoom);
    },
    getFilmWidth: function() {
        return this.filmGauge * Math.min(this.aspect, 1);
    },
    getFilmHeight: function() {
        return this.filmGauge / Math.max(this.aspect, 1);
    },
    setViewOffset: function(fullWidth, fullHeight, x6, y6, width2, height3) {
        this.aspect = fullWidth / fullHeight;
        if (this.view === null) this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        };
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x6;
        this.view.offsetY = y6;
        this.view.width = width2;
        this.view.height = height3;
        this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
        if (this.view !== null) this.view.enabled = false;
        this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
        const near = this.near;
        let top = near * Math.tan(MathUtils1.DEG2RAD * 0.5 * this.fov) / this.zoom;
        let height3 = 2 * top;
        let width2 = this.aspect * height3;
        let left = -0.5 * width2;
        const view = this.view;
        if (this.view !== null && this.view.enabled) {
            const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
            left += view.offsetX * width2 / fullWidth;
            top -= view.offsetY * height3 / fullHeight;
            width2 *= view.width / fullWidth;
            height3 *= view.height / fullHeight;
        }
        const skew = this.filmOffset;
        if (skew !== 0) left += near * skew / this.getFilmWidth();
        this.projectionMatrix.makePerspective(left, left + width2, top, top - height3, near, this.far);
        this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(meta) {
        const data = Object3D1.prototype.toJSON.call(this, meta);
        data.object.fov = this.fov;
        data.object.zoom = this.zoom;
        data.object.near = this.near;
        data.object.far = this.far;
        data.object.focus = this.focus;
        data.object.aspect = this.aspect;
        if (this.view !== null) data.object.view = Object.assign({
        }, this.view);
        data.object.filmGauge = this.filmGauge;
        data.object.filmOffset = this.filmOffset;
        return data;
    }
});
const PerspectiveCamera1 = PerspectiveCamera2;
export { PerspectiveCamera1 as PerspectiveCamera };
function OrthographicCamera2(left, right, top, bottom, near, far) {
    Camera1.call(this);
    this.type = 'OrthographicCamera';
    this.zoom = 1;
    this.view = null;
    this.left = left !== undefined ? left : -1;
    this.right = right !== undefined ? right : 1;
    this.top = top !== undefined ? top : 1;
    this.bottom = bottom !== undefined ? bottom : -1;
    this.near = near !== undefined ? near : 0.1;
    this.far = far !== undefined ? far : 2000;
    this.updateProjectionMatrix();
}
OrthographicCamera2.prototype = Object.assign(Object.create(Camera1.prototype), {
    constructor: OrthographicCamera2,
    isOrthographicCamera: true,
    copy: function(source, recursive) {
        Camera1.prototype.copy.call(this, source, recursive);
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.near = source.near;
        this.far = source.far;
        this.zoom = source.zoom;
        this.view = source.view === null ? null : Object.assign({
        }, source.view);
        return this;
    },
    setViewOffset: function(fullWidth, fullHeight, x6, y6, width2, height3) {
        if (this.view === null) this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        };
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x6;
        this.view.offsetY = y6;
        this.view.width = width2;
        this.view.height = height3;
        this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
        if (this.view !== null) this.view.enabled = false;
        this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
        const dx = (this.right - this.left) / (2 * this.zoom);
        const dy = (this.top - this.bottom) / (2 * this.zoom);
        const cx = (this.right + this.left) / 2;
        const cy = (this.top + this.bottom) / 2;
        let left = cx - dx;
        let right = cx + dx;
        let top = cy + dy;
        let bottom = cy - dy;
        if (this.view !== null && this.view.enabled) {
            const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
            const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            left += scaleW * this.view.offsetX;
            right = left + scaleW * this.view.width;
            top -= scaleH * this.view.offsetY;
            bottom = top - scaleH * this.view.height;
        }
        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(meta) {
        const data = Object3D1.prototype.toJSON.call(this, meta);
        data.object.zoom = this.zoom;
        data.object.left = this.left;
        data.object.right = this.right;
        data.object.top = this.top;
        data.object.bottom = this.bottom;
        data.object.near = this.near;
        data.object.far = this.far;
        if (this.view !== null) data.object.view = Object.assign({
        }, this.view);
        return data;
    }
});
const OrthographicCamera1 = OrthographicCamera2;
export { OrthographicCamera1 as OrthographicCamera };
const fov = 90, aspect = 1;
function CubeCamera4(near, far, renderTarget) {
    Object3D1.call(this);
    this.type = 'CubeCamera';
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
        console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
        return;
    }
    this.renderTarget = renderTarget;
    const cameraPX = new PerspectiveCamera1(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector31(1, 0, 0));
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera1(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector31(-1, 0, 0));
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera1(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector31(0, 1, 0));
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera1(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector31(0, -1, 0));
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera1(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector31(0, 0, 1));
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera1(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector31(0, 0, -1));
    this.add(cameraNZ);
    this.update = function(renderer, scene) {
        if (this.parent === null) this.updateMatrixWorld();
        const currentXrEnabled = renderer.xr.enabled;
        const currentRenderTarget = renderer.getRenderTarget();
        renderer.xr.enabled = false;
        const generateMipmaps = renderTarget.texture.generateMipmaps;
        renderTarget.texture.generateMipmaps = false;
        renderer.setRenderTarget(renderTarget, 0);
        renderer.render(scene, cameraPX);
        renderer.setRenderTarget(renderTarget, 1);
        renderer.render(scene, cameraNX);
        renderer.setRenderTarget(renderTarget, 2);
        renderer.render(scene, cameraPY);
        renderer.setRenderTarget(renderTarget, 3);
        renderer.render(scene, cameraNY);
        renderer.setRenderTarget(renderTarget, 4);
        renderer.render(scene, cameraPZ);
        renderTarget.texture.generateMipmaps = generateMipmaps;
        renderer.setRenderTarget(renderTarget, 5);
        renderer.render(scene, cameraNZ);
        renderer.setRenderTarget(currentRenderTarget);
        renderer.xr.enabled = currentXrEnabled;
    };
    this.clear = function(renderer, color1, depth1, stencil) {
        const currentRenderTarget = renderer.getRenderTarget();
        for(let i7 = 0; i7 < 6; i7++){
            renderer.setRenderTarget(renderTarget, i7);
            renderer.clear(color1, depth1, stencil);
        }
        renderer.setRenderTarget(currentRenderTarget);
    };
}
CubeCamera4.prototype = Object.create(Object3D1.prototype);
CubeCamera4.prototype.constructor = CubeCamera4;
const CubeCamera1 = CubeCamera4;
export { CubeCamera1 as CubeCamera };
function ArrayCamera3(array) {
    PerspectiveCamera1.call(this);
    this.cameras = array || [];
}
ArrayCamera3.prototype = Object.assign(Object.create(PerspectiveCamera1.prototype), {
    constructor: ArrayCamera3,
    isArrayCamera: true
});
const ArrayCamera1 = ArrayCamera3;
export { ArrayCamera1 as ArrayCamera };
function Camera2() {
    Object3D1.call(this);
    this.type = 'Camera';
    this.matrixWorldInverse = new Matrix41();
    this.projectionMatrix = new Matrix41();
    this.projectionMatrixInverse = new Matrix41();
}
Camera2.prototype = Object.assign(Object.create(Object3D1.prototype), {
    constructor: Camera2,
    isCamera: true,
    copy: function(source, recursive) {
        Object3D1.prototype.copy.call(this, source, recursive);
        this.matrixWorldInverse.copy(source.matrixWorldInverse);
        this.projectionMatrix.copy(source.projectionMatrix);
        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
        return this;
    },
    getWorldDirection: function(target) {
        if (target === undefined) {
            console.warn('THREE.Camera: .getWorldDirection() target is now required');
            target = new Vector31();
        }
        this.updateMatrixWorld(true);
        const e = this.matrixWorld.elements;
        return target.set(-e[8], -e[9], -e[10]).normalize();
    },
    updateMatrixWorld: function(force) {
        Object3D1.prototype.updateMatrixWorld.call(this, force);
        this.matrixWorldInverse.getInverse(this.matrixWorld);
    },
    updateWorldMatrix: function(updateParents, updateChildren) {
        Object3D1.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
        this.matrixWorldInverse.getInverse(this.matrixWorld);
    },
    clone: function() {
        return new this.constructor().copy(this);
    }
});
const Camera1 = Camera2;
export { Camera1 as Camera };
class Clock {
    start() {
        this.startTime = (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
        this.oldTime = this.startTime;
        this.elapsedTime = 0;
        this.running = true;
    }
    stop() {
        this.getElapsedTime();
        this.running = false;
        this.autoStart = false;
    }
    getElapsedTime() {
        this.getDelta();
        return this.elapsedTime;
    }
    getDelta() {
        let diff = 0;
        if (this.autoStart && !this.running) {
            this.start();
            return 0;
        }
        if (this.running) {
            const newTime = (typeof performance === 'undefined' ? Date : performance).now();
            diff = (newTime - this.oldTime) / 1000;
            this.oldTime = newTime;
            this.elapsedTime += diff;
        }
        return diff;
    }
    constructor(autoStart){
        this.autoStart = autoStart !== undefined ? autoStart : true;
        this.startTime = 0;
        this.oldTime = 0;
        this.elapsedTime = 0;
        this.running = false;
    }
}
const Clock1 = Clock;
const _position2 = new Vector31();
const _quaternion4 = new Quaternion1();
const _scale1 = new Vector31();
const _orientation = new Vector31();
class AudioListener1 extends Object3D1 {
    getInput() {
        return this.gain;
    }
    removeFilter() {
        if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
            this.gain.connect(this.context.destination);
            this.filter = null;
        }
        return this;
    }
    getFilter() {
        return this.filter;
    }
    setFilter(value) {
        if (this.filter !== null) {
            this.gain.disconnect(this.filter);
            this.filter.disconnect(this.context.destination);
        } else this.gain.disconnect(this.context.destination);
        this.filter = value;
        this.gain.connect(this.filter);
        this.filter.connect(this.context.destination);
        return this;
    }
    getMasterVolume() {
        return this.gain.gain.value;
    }
    setMasterVolume(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
    }
    updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        const listener = this.context.listener;
        const up = this.up;
        this.timeDelta = this._clock.getDelta();
        this.matrixWorld.decompose(_position2, _quaternion4, _scale1);
        _orientation.set(0, 0, -1).applyQuaternion(_quaternion4);
        if (listener.positionX) {
            // code path for Chrome (see #14393)
            const endTime = this.context.currentTime + this.timeDelta;
            listener.positionX.linearRampToValueAtTime(_position2.x, endTime);
            listener.positionY.linearRampToValueAtTime(_position2.y, endTime);
            listener.positionZ.linearRampToValueAtTime(_position2.z, endTime);
            listener.forwardX.linearRampToValueAtTime(_orientation.x, endTime);
            listener.forwardY.linearRampToValueAtTime(_orientation.y, endTime);
            listener.forwardZ.linearRampToValueAtTime(_orientation.z, endTime);
            listener.upX.linearRampToValueAtTime(up.x, endTime);
            listener.upY.linearRampToValueAtTime(up.y, endTime);
            listener.upZ.linearRampToValueAtTime(up.z, endTime);
        } else {
            listener.setPosition(_position2.x, _position2.y, _position2.z);
            listener.setOrientation(_orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z);
        }
    }
    constructor(){
        super();
        this.type = 'AudioListener';
        this.context = AudioContext1.getContext();
        this.gain = this.context.createGain();
        this.gain.connect(this.context.destination);
        this.filter = null;
        this.timeDelta = 0;
        // private
        this._clock = new Clock1();
    }
}
const AudioListener2 = AudioListener1;
export { AudioListener2 as AudioListener };
class Audio1 extends Object3D1 {
    getOutput() {
        return this.gain;
    }
    setNodeSource(audioNode) {
        this.hasPlaybackControl = false;
        this.sourceType = 'audioNode';
        this.source = audioNode;
        this.connect();
        return this;
    }
    setMediaElementSource(mediaElement) {
        this.hasPlaybackControl = false;
        this.sourceType = 'mediaNode';
        this.source = this.context.createMediaElementSource(mediaElement);
        this.connect();
        return this;
    }
    setMediaStreamSource(mediaStream) {
        this.hasPlaybackControl = false;
        this.sourceType = 'mediaStreamNode';
        this.source = this.context.createMediaStreamSource(mediaStream);
        this.connect();
        return this;
    }
    setBuffer(audioBuffer) {
        this.buffer = audioBuffer;
        this.sourceType = 'buffer';
        if (this.autoplay) this.play();
        return this;
    }
    play(delay) {
        if (delay === undefined) delay = 0;
        if (this.isPlaying === true) {
            console.warn('THREE.Audio: Audio is already playing.');
            return;
        }
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this._startedAt = this.context.currentTime + delay;
        const source = this.context.createBufferSource();
        source.buffer = this.buffer;
        source.loop = this.loop;
        source.loopStart = this.loopStart;
        source.loopEnd = this.loopEnd;
        source.onended = this.onEnded.bind(this);
        source.start(this._startedAt, this._progress + this.offset, this.duration);
        this.isPlaying = true;
        this.source = source;
        this.setDetune(this.detune);
        this.setPlaybackRate(this.playbackRate);
        return this.connect();
    }
    pause() {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        if (this.isPlaying === true) {
            // update current progress
            this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
            if (this.loop === true) // ensure _progress does not exceed duration with looped audios
            this._progress = this._progress % (this.duration || this.buffer.duration);
            this.source.stop();
            this.source.onended = null;
            this.isPlaying = false;
        }
        return this;
    }
    stop() {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this._progress = 0;
        this.source.stop();
        this.source.onended = null;
        this.isPlaying = false;
        return this;
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for(let i7 = 1, l1 = this.filters.length; i7 < l1; i7++)this.filters[i7 - 1].connect(this.filters[i7]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        return this;
    }
    disconnect() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for(let i7 = 1, l1 = this.filters.length; i7 < l1; i7++)this.filters[i7 - 1].disconnect(this.filters[i7]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        return this;
    }
    getFilters() {
        return this.filters;
    }
    setFilters(value) {
        if (!value) value = [];
        if (this.isPlaying === true) {
            this.disconnect();
            this.filters = value;
            this.connect();
        } else this.filters = value;
        return this;
    }
    setDetune(value) {
        this.detune = value;
        if (this.source.detune === undefined) return; // only set detune when available
        if (this.isPlaying === true) this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
        return this;
    }
    getDetune() {
        return this.detune;
    }
    getFilter() {
        return this.getFilters()[0];
    }
    setFilter(filter) {
        return this.setFilters(filter ? [
            filter
        ] : []);
    }
    setPlaybackRate(value) {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this.playbackRate = value;
        if (this.isPlaying === true) this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
        return this;
    }
    getPlaybackRate() {
        return this.playbackRate;
    }
    onEnded() {
        this.isPlaying = false;
    }
    getLoop() {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return false;
        }
        return this.loop;
    }
    setLoop(value) {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this.loop = value;
        if (this.isPlaying === true) this.source.loop = this.loop;
        return this;
    }
    setLoopStart(value) {
        this.loopStart = value;
        return this;
    }
    setLoopEnd(value) {
        this.loopEnd = value;
        return this;
    }
    getVolume() {
        return this.gain.gain.value;
    }
    setVolume(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
    }
    constructor(listener){
        super();
        this.type = 'Audio';
        this.listener = listener;
        this.context = listener.context;
        this.gain = this.context.createGain();
        this.gain.connect(listener.getInput());
        this.autoplay = false;
        this.buffer = null;
        this.detune = 0;
        this.loop = false;
        this.loopStart = 0;
        this.loopEnd = 0;
        this.offset = 0;
        this.duration = undefined;
        this.playbackRate = 1;
        this.isPlaying = false;
        this.hasPlaybackControl = true;
        this.source = null;
        this.sourceType = 'empty';
        this._startedAt = 0;
        this._progress = 0;
        this.filters = [];
    }
}
const Audio11 = Audio1;
const _position3 = new Vector31();
const _quaternion5 = new Quaternion1();
const _scale2 = new Vector31();
const _orientation1 = new Vector31();
class PositionalAudio extends Audio11 {
    getOutput() {
        return this.panner;
    }
    getRefDistance() {
        return this.panner.refDistance;
    }
    setRefDistance(value) {
        this.panner.refDistance = value;
        return this;
    }
    getRolloffFactor() {
        return this.panner.rolloffFactor;
    }
    setRolloffFactor(value) {
        this.panner.rolloffFactor = value;
        return this;
    }
    getDistanceModel() {
        return this.panner.distanceModel;
    }
    setDistanceModel(value) {
        this.panner.distanceModel = value;
        return this;
    }
    getMaxDistance() {
        return this.panner.maxDistance;
    }
    setMaxDistance(value) {
        this.panner.maxDistance = value;
        return this;
    }
    setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
        this.panner.coneInnerAngle = coneInnerAngle;
        this.panner.coneOuterAngle = coneOuterAngle;
        this.panner.coneOuterGain = coneOuterGain;
        return this;
    }
    updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        if (this.hasPlaybackControl === true && this.isPlaying === false) return;
        this.matrixWorld.decompose(_position3, _quaternion5, _scale2);
        _orientation1.set(0, 0, 1).applyQuaternion(_quaternion5);
        const panner = this.panner;
        if (panner.positionX) {
            // code path for Chrome and Firefox (see #14393)
            const endTime = this.context.currentTime + this.listener.timeDelta;
            panner.positionX.linearRampToValueAtTime(_position3.x, endTime);
            panner.positionY.linearRampToValueAtTime(_position3.y, endTime);
            panner.positionZ.linearRampToValueAtTime(_position3.z, endTime);
            panner.orientationX.linearRampToValueAtTime(_orientation1.x, endTime);
            panner.orientationY.linearRampToValueAtTime(_orientation1.y, endTime);
            panner.orientationZ.linearRampToValueAtTime(_orientation1.z, endTime);
        } else {
            panner.setPosition(_position3.x, _position3.y, _position3.z);
            panner.setOrientation(_orientation1.x, _orientation1.y, _orientation1.z);
        }
    }
    constructor(listener1){
        super(listener1);
        this.panner = this.context.createPanner();
        this.panner.panningModel = 'HRTF';
        this.panner.connect(this.gain);
    }
}
const PositionalAudio1 = PositionalAudio;
export { PositionalAudio1 as PositionalAudio };
let _context;
const AudioContext12 = {
    getContext: function() {
        if (_context === undefined) _context = new window.AudioContext || window.webkitAudioContext();
        return _context;
    },
    setContext: function(value) {
        _context = value;
    }
};
const AudioContext2 = AudioContext12;
export { AudioContext2 as AudioContext };
class AudioAnalyser {
    getFrequencyData() {
        this.analyser.getByteFrequencyData(this.data);
        return this.data;
    }
    getAverageFrequency() {
        let value = 0;
        const data = this.getFrequencyData();
        for(let i7 = 0; i7 < data.length; i7++)value += data[i7];
        return value / data.length;
    }
    constructor(audio, fftSize){
        this.analyser = audio.context.createAnalyser();
        this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
        this.data = new Uint8Array(this.analyser.frequencyBinCount);
        audio.getOutput().connect(this.analyser);
    }
}
const AudioAnalyser1 = AudioAnalyser;
export { AudioAnalyser1 as AudioAnalyser };
class Audio12 extends Object3D1 {
    getOutput() {
        return this.gain;
    }
    setNodeSource(audioNode) {
        this.hasPlaybackControl = false;
        this.sourceType = 'audioNode';
        this.source = audioNode;
        this.connect();
        return this;
    }
    setMediaElementSource(mediaElement) {
        this.hasPlaybackControl = false;
        this.sourceType = 'mediaNode';
        this.source = this.context.createMediaElementSource(mediaElement);
        this.connect();
        return this;
    }
    setMediaStreamSource(mediaStream) {
        this.hasPlaybackControl = false;
        this.sourceType = 'mediaStreamNode';
        this.source = this.context.createMediaStreamSource(mediaStream);
        this.connect();
        return this;
    }
    setBuffer(audioBuffer) {
        this.buffer = audioBuffer;
        this.sourceType = 'buffer';
        if (this.autoplay) this.play();
        return this;
    }
    play(delay) {
        if (delay === undefined) delay = 0;
        if (this.isPlaying === true) {
            console.warn('THREE.Audio: Audio is already playing.');
            return;
        }
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this._startedAt = this.context.currentTime + delay;
        const source = this.context.createBufferSource();
        source.buffer = this.buffer;
        source.loop = this.loop;
        source.loopStart = this.loopStart;
        source.loopEnd = this.loopEnd;
        source.onended = this.onEnded.bind(this);
        source.start(this._startedAt, this._progress + this.offset, this.duration);
        this.isPlaying = true;
        this.source = source;
        this.setDetune(this.detune);
        this.setPlaybackRate(this.playbackRate);
        return this.connect();
    }
    pause() {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        if (this.isPlaying === true) {
            this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
            if (this.loop === true) this._progress = this._progress % (this.duration || this.buffer.duration);
            this.source.stop();
            this.source.onended = null;
            this.isPlaying = false;
        }
        return this;
    }
    stop() {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this._progress = 0;
        this.source.stop();
        this.source.onended = null;
        this.isPlaying = false;
        return this;
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for(let i7 = 1, l1 = this.filters.length; i7 < l1; i7++)this.filters[i7 - 1].connect(this.filters[i7]);
            this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        return this;
    }
    disconnect() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for(let i7 = 1, l1 = this.filters.length; i7 < l1; i7++)this.filters[i7 - 1].disconnect(this.filters[i7]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        return this;
    }
    getFilters() {
        return this.filters;
    }
    setFilters(value) {
        if (!value) value = [];
        if (this.isPlaying === true) {
            this.disconnect();
            this.filters = value;
            this.connect();
        } else this.filters = value;
        return this;
    }
    setDetune(value) {
        this.detune = value;
        if (this.source.detune === undefined) return;
        if (this.isPlaying === true) this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
        return this;
    }
    getDetune() {
        return this.detune;
    }
    getFilter() {
        return this.getFilters()[0];
    }
    setFilter(filter) {
        return this.setFilters(filter ? [
            filter
        ] : []);
    }
    setPlaybackRate(value) {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this.playbackRate = value;
        if (this.isPlaying === true) this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
        return this;
    }
    getPlaybackRate() {
        return this.playbackRate;
    }
    onEnded() {
        this.isPlaying = false;
    }
    getLoop() {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return false;
        }
        return this.loop;
    }
    setLoop(value) {
        if (this.hasPlaybackControl === false) {
            console.warn('THREE.Audio: this Audio has no playback control.');
            return;
        }
        this.loop = value;
        if (this.isPlaying === true) this.source.loop = this.loop;
        return this;
    }
    setLoopStart(value) {
        this.loopStart = value;
        return this;
    }
    setLoopEnd(value) {
        this.loopEnd = value;
        return this;
    }
    getVolume() {
        return this.gain.gain.value;
    }
    setVolume(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
    }
    constructor(listener){
        super();
        this.type = 'Audio';
        this.listener = listener;
        this.context = listener.context;
        this.gain = this.context.createGain();
        this.gain.connect(listener.getInput());
        this.autoplay = false;
        this.buffer = null;
        this.detune = 0;
        this.loop = false;
        this.loopStart = 0;
        this.loopEnd = 0;
        this.offset = 0;
        this.duration = undefined;
        this.playbackRate = 1;
        this.isPlaying = false;
        this.hasPlaybackControl = true;
        this.source = null;
        this.sourceType = 'empty';
        this._startedAt = 0;
        this._progress = 0;
        this.filters = [];
    }
}
const Audio2 = Audio12;
export { Audio2 as Audio };
/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */
function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant1.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0.0;
    this._offsetPrev = -0.0;
    this._weightNext = -0.0;
    this._offsetNext = -0.0;
}
CubicInterpolant.prototype = Object.assign(Object.create(Interpolant1.prototype), {
    constructor: CubicInterpolant,
    DefaultSettings_: {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
    },
    intervalChanged_: function(i12, t0, t11) {
        const pp = this.parameterPositions;
        let iPrev = i12 - 2, iNext = i12 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
        if (tPrev === undefined) switch(this.getSettings_().endingStart){
            case ZeroSlopeEnding:
                // f'(t0) = 0
                iPrev = i12;
                tPrev = 2 * t0 - t11;
                break;
            case WrapAroundEnding:
                // use the other end of the curve
                iPrev = pp.length - 2;
                tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                break;
            default:
                // f''(t0) = 0 a.k.a. Natural Spline
                iPrev = i12;
                tPrev = t11;
        }
        if (tNext === undefined) switch(this.getSettings_().endingEnd){
            case ZeroSlopeEnding:
                // f'(tN) = 0
                iNext = i12;
                tNext = 2 * t11 - t0;
                break;
            case WrapAroundEnding:
                // use the other end of the curve
                iNext = 1;
                tNext = t11 + pp[1] - pp[0];
                break;
            default:
                // f''(tN) = 0, a.k.a. Natural Spline
                iNext = i12 - 1;
                tNext = t0;
        }
        const halfDt = (t11 - t0) * 0.5, stride = this.valueSize;
        this._weightPrev = halfDt / (t0 - tPrev);
        this._weightNext = halfDt / (tNext - t11);
        this._offsetPrev = iPrev * stride;
        this._offsetNext = iNext * stride;
    },
    interpolate_: function(i12, t0, t2, t11) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i12 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p1 = (t2 - t0) / (t11 - t0), pp = p1 * p1, ppp = pp * p1;
        // evaluate polynomials
        const sP = -wP * ppp + 2 * wP * pp - wP * p1;
        const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p1 + 1;
        const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p1;
        const sN = wN * ppp - wN * pp;
        // combine data linearly
        for(let i7 = 0; i7 !== stride; ++i7)result[i7] = sP * values[oP + i7] + s0 * values[o0 + i7] + s1 * values[o1 + i7] + sN * values[oN + i7];
        return result;
    }
});
const CubicInterpolant1 = CubicInterpolant;
/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 */
function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant1.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant1.prototype), {
    constructor: DiscreteInterpolant,
    interpolate_: function(i12/*, t0, t, t1 */
    ) {
        return this.copySampleValue_(i12 - 1);
    }
});
const DiscreteInterpolant1 = DiscreteInterpolant;
function KeyframeTrack(name, times, values, interpolation) {
    if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
    if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
    this.name = name;
    this.times = AnimationUtils1.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils1.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
}
// Static methods
Object.assign(KeyframeTrack, {
    // Serialization (in static context, because of constructor invocation
    // and automatic invocation of .toJSON):
    toJSON: function(track) {
        const trackType = track.constructor;
        let json;
        // derived classes can define a static toJSON method
        if (trackType.toJSON !== undefined) json = trackType.toJSON(track);
        else {
            // by default, we assume the data can be serialized as-is
            json = {
                'name': track.name,
                'times': AnimationUtils1.convertArray(track.times, Array),
                'values': AnimationUtils1.convertArray(track.values, Array)
            };
            const interpolation = track.getInterpolation();
            if (interpolation !== track.DefaultInterpolation) json.interpolation = interpolation;
        }
        json.type = track.ValueTypeName; // mandatory
        return json;
    }
});
Object.assign(KeyframeTrack.prototype, {
    constructor: KeyframeTrack,
    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,
    DefaultInterpolation: InterpolateLinear,
    InterpolantFactoryMethodDiscrete: function(result) {
        return new DiscreteInterpolant1(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodLinear: function(result) {
        return new LinearInterpolant1(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodSmooth: function(result) {
        return new CubicInterpolant1(this.times, this.values, this.getValueSize(), result);
    },
    setInterpolation: function(interpolation) {
        let factoryMethod;
        switch(interpolation){
            case InterpolateDiscrete:
                factoryMethod = this.InterpolantFactoryMethodDiscrete;
                break;
            case InterpolateLinear:
                factoryMethod = this.InterpolantFactoryMethodLinear;
                break;
            case InterpolateSmooth:
                factoryMethod = this.InterpolantFactoryMethodSmooth;
                break;
        }
        if (factoryMethod === undefined) {
            const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === undefined) {
                // fall back to default, unless the default itself is messed up
                if (interpolation !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                else throw new Error(message); // fatal, in this case
            }
            console.warn('THREE.KeyframeTrack:', message);
            return this;
        }
        this.createInterpolant = factoryMethod;
        return this;
    },
    getInterpolation: function() {
        switch(this.createInterpolant){
            case this.InterpolantFactoryMethodDiscrete:
                return InterpolateDiscrete;
            case this.InterpolantFactoryMethodLinear:
                return InterpolateLinear;
            case this.InterpolantFactoryMethodSmooth:
                return InterpolateSmooth;
        }
    },
    getValueSize: function() {
        return this.values.length / this.times.length;
    },
    // move all keyframes either forwards or backwards in time
    shift: function(timeOffset) {
        if (timeOffset !== 0) {
            const times = this.times;
            for(let i7 = 0, n = times.length; i7 !== n; ++i7)times[i7] += timeOffset;
        }
        return this;
    },
    // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
    scale: function(timeScale) {
        if (timeScale !== 1) {
            const times = this.times;
            for(let i7 = 0, n = times.length; i7 !== n; ++i7)times[i7] *= timeScale;
        }
        return this;
    },
    // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
    // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
    trim: function(startTime, endTime) {
        const times = this.times, nKeys = times.length;
        let from = 0, to = nKeys - 1;
        while(from !== nKeys && times[from] < startTime)++from;
        while(to !== -1 && times[to] > endTime)--to;
        ++to; // inclusive -> exclusive bound
        if (from !== 0 || to !== nKeys) {
            // empty tracks are forbidden, so keep at least one keyframe
            if (from >= to) {
                to = Math.max(to, 1);
                from = to - 1;
            }
            const stride = this.getValueSize();
            this.times = AnimationUtils1.arraySlice(times, from, to);
            this.values = AnimationUtils1.arraySlice(this.values, from * stride, to * stride);
        }
        return this;
    },
    // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
    validate: function() {
        let valid = true;
        const valueSize = this.getValueSize();
        if (valueSize - Math.floor(valueSize) !== 0) {
            console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
            valid = false;
        }
        const times = this.times, values = this.values, nKeys = times.length;
        if (nKeys === 0) {
            console.error('THREE.KeyframeTrack: Track is empty.', this);
            valid = false;
        }
        let prevTime = null;
        for(let i7 = 0; i7 !== nKeys; i7++){
            const currTime = times[i7];
            if (typeof currTime === 'number' && isNaN(currTime)) {
                console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i7, currTime);
                valid = false;
                break;
            }
            if (prevTime !== null && prevTime > currTime) {
                console.error('THREE.KeyframeTrack: Out of order keys.', this, i7, currTime, prevTime);
                valid = false;
                break;
            }
            prevTime = currTime;
        }
        if (values !== undefined) {
            if (AnimationUtils1.isTypedArray(values)) for(let i7 = 0, n = values.length; i7 !== n; ++i7){
                const value = values[i7];
                if (isNaN(value)) {
                    console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i7, value);
                    valid = false;
                    break;
                }
            }
        }
        return valid;
    },
    // removes equivalent sequential keys as common in morph target sequences
    // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
    optimize: function() {
        // times or values may be shared with other tracks, so overwriting is unsafe
        const times = AnimationUtils1.arraySlice(this.times), values = AnimationUtils1.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
        let writeIndex = 1;
        for(let i7 = 1; i7 < lastIndex; ++i7){
            let keep = false;
            const time = times[i7];
            const timeNext = times[i7 + 1];
            // remove adjacent keyframes scheduled at the same time
            if (time !== timeNext && (i7 !== 1 || time !== time[0])) {
                if (!smoothInterpolation) {
                    // remove unnecessary keyframes same as their neighbors
                    const offset = i7 * stride, offsetP = offset - stride, offsetN = offset + stride;
                    for(let j4 = 0; j4 !== stride; ++j4){
                        const value = values[offset + j4];
                        if (value !== values[offsetP + j4] || value !== values[offsetN + j4]) {
                            keep = true;
                            break;
                        }
                    }
                } else keep = true;
            }
            // in-place compaction
            if (keep) {
                if (i7 !== writeIndex) {
                    times[writeIndex] = times[i7];
                    const readOffset = i7 * stride, writeOffset = writeIndex * stride;
                    for(let j4 = 0; j4 !== stride; ++j4)values[writeOffset + j4] = values[readOffset + j4];
                }
                ++writeIndex;
            }
        }
        // flush last keyframe (compaction looks ahead)
        if (lastIndex > 0) {
            times[writeIndex] = times[lastIndex];
            for(let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j4 = 0; j4 !== stride; ++j4)values[writeOffset + j4] = values[readOffset + j4];
            ++writeIndex;
        }
        if (writeIndex !== times.length) {
            this.times = AnimationUtils1.arraySlice(times, 0, writeIndex);
            this.values = AnimationUtils1.arraySlice(values, 0, writeIndex * stride);
        } else {
            this.times = times;
            this.values = values;
        }
        return this;
    },
    clone: function() {
        const times = AnimationUtils1.arraySlice(this.times, 0);
        const values = AnimationUtils1.arraySlice(this.values, 0);
        const TypedKeyframeTrack = this.constructor;
        const track = new TypedKeyframeTrack(this.name, times, values);
        // Interpolant argument to constructor is not saved, so copy the factory method directly.
        track.createInterpolant = this.createInterpolant;
        return track;
    }
});
const KeyframeTrack1 = KeyframeTrack;
function VectorKeyframeTrack2(name, times, values, interpolation) {
    KeyframeTrack1.call(this, name, times, values, interpolation);
}
VectorKeyframeTrack2.prototype = Object.assign(Object.create(KeyframeTrack1.prototype), {
    constructor: VectorKeyframeTrack2,
    ValueTypeName: 'vector'
});
const VectorKeyframeTrack1 = VectorKeyframeTrack2;
export { VectorKeyframeTrack1 as VectorKeyframeTrack };
function StringKeyframeTrack2(name, times, values, interpolation) {
    KeyframeTrack1.call(this, name, times, values, interpolation);
}
StringKeyframeTrack2.prototype = Object.assign(Object.create(KeyframeTrack1.prototype), {
    constructor: StringKeyframeTrack2,
    ValueTypeName: 'string',
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: undefined,
    InterpolantFactoryMethodSmooth: undefined
});
const StringKeyframeTrack1 = StringKeyframeTrack2;
export { StringKeyframeTrack1 as StringKeyframeTrack };
/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */
function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
}
Object.assign(Interpolant.prototype, {
    evaluate: function(t2) {
        const pp = this.parameterPositions;
        let i12 = this._cachedIndex, t11 = pp[i12], t0 = pp[i12 - 1];
        validate_interval: {
            seek: {
                let right;
                linear_scan: {
                    //- See http://jsperf.com/comparison-to-undefined/3
                    //- slower code:
                    //-
                    //- 				if ( t >= t1 || t1 === undefined ) {
                    forward_scan: if (!(t2 < t11)) {
                        for(let giveUpAt = i12 + 2;;){
                            if (t11 === undefined) {
                                if (t2 < t0) break forward_scan;
                                // after end
                                i12 = pp.length;
                                this._cachedIndex = i12;
                                return this.afterEnd_(i12 - 1, t2, t0);
                            }
                            if (i12 === giveUpAt) break; // this loop
                            t0 = t11;
                            t11 = pp[++i12];
                            if (t2 < t11) break seek;
                        }
                        // prepare binary search on the right side of the index
                        right = pp.length;
                        break linear_scan;
                    }
                    //- slower code:
                    //-					if ( t < t0 || t0 === undefined ) {
                    if (!(t2 >= t0)) {
                        // looping?
                        const t1global = pp[1];
                        if (t2 < t1global) {
                            i12 = 2; // + 1, using the scan for the details
                            t0 = t1global;
                        }
                        // linear reverse scan
                        for(let giveUpAt = i12 - 2;;){
                            if (t0 === undefined) {
                                // before start
                                this._cachedIndex = 0;
                                return this.beforeStart_(0, t2, t11);
                            }
                            if (i12 === giveUpAt) break; // this loop
                            t11 = t0;
                            t0 = pp[(--i12) - 1];
                            if (t2 >= t0) break seek;
                        }
                        // prepare binary search on the left side of the index
                        right = i12;
                        i12 = 0;
                        break linear_scan;
                    }
                    break validate_interval;
                } // linear scan
                // binary search
                while(i12 < right){
                    const mid = i12 + right >>> 1;
                    if (t2 < pp[mid]) right = mid;
                    else i12 = mid + 1;
                }
                t11 = pp[i12];
                t0 = pp[i12 - 1];
                // check boundary cases, again
                if (t0 === undefined) {
                    this._cachedIndex = 0;
                    return this.beforeStart_(0, t2, t11);
                }
                if (t11 === undefined) {
                    i12 = pp.length;
                    this._cachedIndex = i12;
                    return this.afterEnd_(i12 - 1, t0, t2);
                }
            } // seek
            this._cachedIndex = i12;
            this.intervalChanged_(i12, t0, t11);
        } // validate_interval
        return this.interpolate_(i12, t0, t2, t11);
    },
    settings: null,
    // Note: The indirection allows central control of many interpolants.
    // --- Protected interface
    DefaultSettings_: {
    },
    getSettings_: function() {
        return this.settings || this.DefaultSettings_;
    },
    copySampleValue_: function(index2) {
        // copies a sample value to the result buffer
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index2 * stride;
        for(let i7 = 0; i7 !== stride; ++i7)result[i7] = values[offset + i7];
        return result;
    },
    // Template methods for derived classes:
    interpolate_: function() {
        throw new Error('call to abstract method');
    },
    intervalChanged_: function() {
    }
});
// DECLARE ALIAS AFTER assign prototype
Object.assign(Interpolant.prototype, {
    //( 0, t, t0 ), returns this.resultBuffer
    beforeStart_: Interpolant.prototype.copySampleValue_,
    //( N-1, tN-1, t ), returns this.resultBuffer
    afterEnd_: Interpolant.prototype.copySampleValue_
});
const Interpolant1 = Interpolant;
function QuaternionLinearInterpolant2(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant1.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
QuaternionLinearInterpolant2.prototype = Object.assign(Object.create(Interpolant1.prototype), {
    constructor: QuaternionLinearInterpolant2,
    interpolate_: function(i12, t0, t2, t11) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t2 - t0) / (t11 - t0);
        let offset = i12 * stride;
        for(let end = offset + stride; offset !== end; offset += 4)Quaternion1.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
        return result;
    }
});
const QuaternionLinearInterpolant1 = QuaternionLinearInterpolant2;
function QuaternionKeyframeTrack2(name, times, values, interpolation) {
    KeyframeTrack1.call(this, name, times, values, interpolation);
}
QuaternionKeyframeTrack2.prototype = Object.assign(Object.create(KeyframeTrack1.prototype), {
    constructor: QuaternionKeyframeTrack2,
    ValueTypeName: 'quaternion',
    DefaultInterpolation: InterpolateLinear,
    InterpolantFactoryMethodLinear: function(result) {
        return new QuaternionLinearInterpolant1(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodSmooth: undefined
});
const QuaternionKeyframeTrack1 = QuaternionKeyframeTrack2;
export { QuaternionKeyframeTrack1 as QuaternionKeyframeTrack };
function NumberKeyframeTrack2(name, times, values, interpolation) {
    KeyframeTrack1.call(this, name, times, values, interpolation);
}
NumberKeyframeTrack2.prototype = Object.assign(Object.create(KeyframeTrack1.prototype), {
    constructor: NumberKeyframeTrack2,
    ValueTypeName: 'number'
});
const NumberKeyframeTrack1 = NumberKeyframeTrack2;
export { NumberKeyframeTrack1 as NumberKeyframeTrack };
function ColorKeyframeTrack2(name, times, values, interpolation) {
    KeyframeTrack1.call(this, name, times, values, interpolation);
}
ColorKeyframeTrack2.prototype = Object.assign(Object.create(KeyframeTrack1.prototype), {
    constructor: ColorKeyframeTrack2,
    ValueTypeName: 'color'
});
const ColorKeyframeTrack1 = ColorKeyframeTrack2;
export { ColorKeyframeTrack1 as ColorKeyframeTrack };
function BooleanKeyframeTrack2(name, times, values) {
    KeyframeTrack1.call(this, name, times, values);
}
BooleanKeyframeTrack2.prototype = Object.assign(Object.create(KeyframeTrack1.prototype), {
    constructor: BooleanKeyframeTrack2,
    ValueTypeName: 'bool',
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: undefined,
    InterpolantFactoryMethodSmooth: undefined
});
const BooleanKeyframeTrack1 = BooleanKeyframeTrack2;
export { BooleanKeyframeTrack1 as BooleanKeyframeTrack };
function PropertyMixer(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
    //
    // interpolators can use .buffer as their .result
    // the data then goes to 'incoming'
    //
    // 'accu0' and 'accu1' are used frame-interleaved for
    // the cumulative result and are compared to detect
    // changes
    //
    // 'orig' stores the original state of the property
    //
    // 'add' is used for additive cumulative results
    //
    // 'work' is optional and is only present for quaternion types. It is used
    // to store intermediate quaternion multiplication results
    switch(typeName){
        case 'quaternion':
            mixFunction = this._slerp;
            mixFunctionAdditive = this._slerpAdditive;
            setIdentity = this._setAdditiveIdentityQuaternion;
            this.buffer = new Float64Array(valueSize * 6);
            this._workIndex = 5;
            break;
        case 'string':
        case 'bool':
            mixFunction = this._select;
            // Use the regular mix function and for additive on these types,
            // additive is not relevant for non-numeric types
            mixFunctionAdditive = this._select;
            setIdentity = this._setAdditiveIdentityOther;
            this.buffer = new Array(valueSize * 5);
            break;
        default:
            mixFunction = this._lerp;
            mixFunctionAdditive = this._lerpAdditive;
            setIdentity = this._setAdditiveIdentityNumeric;
            this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
}
Object.assign(PropertyMixer.prototype, {
    // accumulate data in the 'incoming' region into 'accu<i>'
    accumulate: function(accuIndex, weight) {
        // note: happily accumulating nothing when weight = 0, the caller knows
        // the weight and shouldn't have made the call in the first place
        const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
        let currentWeight = this.cumulativeWeight;
        if (currentWeight === 0) {
            // accuN := incoming * weight
            for(let i7 = 0; i7 !== stride; ++i7)buffer[offset + i7] = buffer[i7];
            currentWeight = weight;
        } else {
            // accuN := accuN + incoming * weight
            currentWeight += weight;
            const mix = weight / currentWeight;
            this._mixBufferRegion(buffer, offset, 0, mix, stride);
        }
        this.cumulativeWeight = currentWeight;
    },
    // accumulate data in the 'incoming' region into 'add'
    accumulateAdditive: function(weight) {
        const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
        if (this.cumulativeWeightAdditive === 0) // add = identity
        this._setIdentity();
        // add := add + incoming * weight
        this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
        this.cumulativeWeightAdditive += weight;
    },
    // apply the state of 'accu<i>' to the binding when accus differ
    apply: function(accuIndex) {
        const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        if (weight < 1) {
            // accuN := accuN + original * ( 1 - cumulativeWeight )
            const originalValueOffset = stride * this._origIndex;
            this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
        }
        if (weightAdditive > 0) // accuN := accuN + additive accuN
        this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
        for(let i7 = stride, e = stride + stride; i7 !== e; ++i7)if (buffer[i7] !== buffer[i7 + stride]) {
            // value has changed -> update scene graph
            binding.setValue(buffer, offset);
            break;
        }
    },
    // remember the state of the bound property and copy it to both accus
    saveOriginalState: function() {
        const binding = this.binding;
        const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
        binding.getValue(buffer, originalValueOffset);
        // accu[0..1] := orig -- initially detect changes against the original
        for(let i7 = stride, e = originalValueOffset; i7 !== e; ++i7)buffer[i7] = buffer[originalValueOffset + i7 % stride];
        // Add to identity for additive
        this._setIdentity();
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
    },
    // apply the state previously taken via 'saveOriginalState' to the binding
    restoreOriginalState: function() {
        const originalValueOffset = this.valueSize * 3;
        this.binding.setValue(this.buffer, originalValueOffset);
    },
    _setAdditiveIdentityNumeric: function() {
        const startIndex = this._addIndex * this.valueSize;
        const endIndex = startIndex + this.valueSize;
        for(let i7 = startIndex; i7 < endIndex; i7++)this.buffer[i7] = 0;
    },
    _setAdditiveIdentityQuaternion: function() {
        this._setAdditiveIdentityNumeric();
        this.buffer[this._addIndex * this.valueSize + 3] = 1;
    },
    _setAdditiveIdentityOther: function() {
        const startIndex = this._origIndex * this.valueSize;
        const targetIndex = this._addIndex * this.valueSize;
        for(let i7 = 0; i7 < this.valueSize; i7++)this.buffer[targetIndex + i7] = this.buffer[startIndex + i7];
    },
    // mix functions
    _select: function(buffer, dstOffset, srcOffset, t2, stride) {
        if (t2 >= 0.5) for(let i7 = 0; i7 !== stride; ++i7)buffer[dstOffset + i7] = buffer[srcOffset + i7];
    },
    _slerp: function(buffer, dstOffset, srcOffset, t2) {
        Quaternion1.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t2);
    },
    _slerpAdditive: function(buffer, dstOffset, srcOffset, t2, stride) {
        const workOffset = this._workIndex * stride;
        // Store result in intermediate buffer offset
        Quaternion1.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
        // Slerp to the intermediate result
        Quaternion1.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t2);
    },
    _lerp: function(buffer, dstOffset, srcOffset, t2, stride) {
        const s1 = 1 - t2;
        for(let i7 = 0; i7 !== stride; ++i7){
            const j4 = dstOffset + i7;
            buffer[j4] = buffer[j4] * s1 + buffer[srcOffset + i7] * t2;
        }
    },
    _lerpAdditive: function(buffer, dstOffset, srcOffset, t2, stride) {
        for(let i7 = 0; i7 !== stride; ++i7){
            const j4 = dstOffset + i7;
            buffer[j4] = buffer[j4] + buffer[srcOffset + i7] * t2;
        }
    }
});
const PropertyMixer1 = PropertyMixer;
export { PropertyMixer1 as PropertyMixer };
// Characters [].:/ are reserved for track binding syntax.
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
const _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');
// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']';
// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar);
// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot);
// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar);
// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);
const _trackRe = new RegExp('^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');
const _supportedObjectNames = [
    'material',
    'materials',
    'bones'
];
function Composite(targetGroup, path1, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding2.parseTrackName(path1);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path1, parsedPath);
}
Object.assign(Composite.prototype, {
    getValue: function(array, offset) {
        this.bind(); // bind all binding
        const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
        // and only call .getValue on the first
        if (binding !== undefined) binding.getValue(array, offset);
    },
    setValue: function(array, offset) {
        const bindings = this._bindings;
        for(let i7 = this._targetGroup.nCachedObjects_, n = bindings.length; i7 !== n; ++i7)bindings[i7].setValue(array, offset);
    },
    bind: function() {
        const bindings = this._bindings;
        for(let i7 = this._targetGroup.nCachedObjects_, n = bindings.length; i7 !== n; ++i7)bindings[i7].bind();
    },
    unbind: function() {
        const bindings = this._bindings;
        for(let i7 = this._targetGroup.nCachedObjects_, n = bindings.length; i7 !== n; ++i7)bindings[i7].unbind();
    }
});
function PropertyBinding2(rootNode, path1, parsedPath) {
    this.path = path1;
    this.parsedPath = parsedPath || PropertyBinding2.parseTrackName(path1);
    this.node = PropertyBinding2.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
    this.rootNode = rootNode;
}
Object.assign(PropertyBinding2, {
    Composite: Composite,
    create: function(root, path1, parsedPath) {
        if (!(root && root.isAnimationObjectGroup)) return new PropertyBinding2(root, path1, parsedPath);
        else return new PropertyBinding2.Composite(root, path1, parsedPath);
    },
    /**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */
    sanitizeNodeName: function(name) {
        return name.replace(/\s/g, '_').replace(_reservedRe, '');
    },
    parseTrackName: function(trackName) {
        const matches = _trackRe.exec(trackName);
        if (!matches) throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
        const results = {
            // directoryName: matches[ 1 ], // (tschw) currently unused
            nodeName: matches[2],
            objectName: matches[3],
            objectIndex: matches[4],
            propertyName: matches[5],
            propertyIndex: matches[6]
        };
        const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');
        if (lastDot !== undefined && lastDot !== -1) {
            const objectName = results.nodeName.substring(lastDot + 1);
            // Object names must be checked against an allowlist. Otherwise, there
            // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
            // 'bar' could be the objectName, or part of a nodeName (which can
            // include '.' characters).
            if (_supportedObjectNames.indexOf(objectName) !== -1) {
                results.nodeName = results.nodeName.substring(0, lastDot);
                results.objectName = objectName;
            }
        }
        if (results.propertyName === null || results.propertyName.length === 0) throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
        return results;
    },
    findNode: function(root, nodeName) {
        if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) return root;
        // search into skeleton bones.
        if (root.skeleton) {
            const bone = root.skeleton.getBoneByName(nodeName);
            if (bone !== undefined) return bone;
        }
        // search into node subtree.
        if (root.children) {
            const searchNodeSubtree = function(children) {
                for(let i7 = 0; i7 < children.length; i7++){
                    const childNode = children[i7];
                    if (childNode.name === nodeName || childNode.uuid === nodeName) return childNode;
                    const result = searchNodeSubtree(childNode.children);
                    if (result) return result;
                }
                return null;
            };
            const subTreeNode = searchNodeSubtree(root.children);
            if (subTreeNode) return subTreeNode;
        }
        return null;
    }
});
Object.assign(PropertyBinding2.prototype, {
    // these are used to "bind" a nonexistent property
    _getValue_unavailable: function() {
    },
    _setValue_unavailable: function() {
    },
    BindingType: {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    },
    Versioning: {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    },
    GetterByBindingType: [
        function getValue_direct(buffer, offset) {
            buffer[offset] = this.node[this.propertyName];
        },
        function getValue_array(buffer, offset) {
            const source = this.resolvedProperty;
            for(let i7 = 0, n = source.length; i7 !== n; ++i7)buffer[offset++] = source[i7];
        },
        function getValue_arrayElement(buffer, offset) {
            buffer[offset] = this.resolvedProperty[this.propertyIndex];
        },
        function getValue_toArray(buffer, offset) {
            this.resolvedProperty.toArray(buffer, offset);
        }
    ],
    SetterByBindingTypeAndVersioning: [
        [
            // Direct
            function setValue_direct(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
            },
            function setValue_direct_setNeedsUpdate(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
                this.targetObject.needsUpdate = true;
            },
            function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ],
        [
            // EntireArray
            function setValue_array(buffer, offset) {
                const dest = this.resolvedProperty;
                for(let i7 = 0, n = dest.length; i7 !== n; ++i7)dest[i7] = buffer[offset++];
            },
            function setValue_array_setNeedsUpdate(buffer, offset) {
                const dest = this.resolvedProperty;
                for(let i7 = 0, n = dest.length; i7 !== n; ++i7)dest[i7] = buffer[offset++];
                this.targetObject.needsUpdate = true;
            },
            function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
                const dest = this.resolvedProperty;
                for(let i7 = 0, n = dest.length; i7 !== n; ++i7)dest[i7] = buffer[offset++];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ],
        [
            // ArrayElement
            function setValue_arrayElement(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
            },
            function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
                this.targetObject.needsUpdate = true;
            },
            function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ],
        [
            // HasToFromArray
            function setValue_fromArray(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
            },
            function setValue_fromArray_setNeedsUpdate(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
                this.targetObject.needsUpdate = true;
            },
            function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ]
    ],
    getValue: function getValue_unbound(targetArray, offset) {
        this.bind();
        this.getValue(targetArray, offset);
    },
    setValue: function getValue_unbound(sourceArray, offset) {
        this.bind();
        this.setValue(sourceArray, offset);
    },
    // create getter / setter pair for a property in the scene graph
    bind: function() {
        let targetObject = this.node;
        const parsedPath = this.parsedPath;
        const objectName = parsedPath.objectName;
        const propertyName = parsedPath.propertyName;
        let propertyIndex = parsedPath.propertyIndex;
        if (!targetObject) {
            targetObject = PropertyBinding2.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
            this.node = targetObject;
        }
        // set fail state so we can just 'return' on error
        this.getValue = this._getValue_unavailable;
        this.setValue = this._setValue_unavailable;
        // ensure there is a value node
        if (!targetObject) {
            console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
            return;
        }
        if (objectName) {
            let objectIndex = parsedPath.objectIndex;
            // special cases were we need to reach deeper into the hierarchy to get the face materials....
            switch(objectName){
                case 'materials':
                    if (!targetObject.material) {
                        console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                        return;
                    }
                    if (!targetObject.material.materials) {
                        console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
                        return;
                    }
                    targetObject = targetObject.material.materials;
                    break;
                case 'bones':
                    if (!targetObject.skeleton) {
                        console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
                        return;
                    }
                    // potential future optimization: skip this if propertyIndex is already an integer
                    // and convert the integer string to a true integer.
                    targetObject = targetObject.skeleton.bones;
                    // support resolving morphTarget names into indices.
                    for(let i7 = 0; i7 < targetObject.length; i7++)if (targetObject[i7].name === objectIndex) {
                        objectIndex = i7;
                        break;
                    }
                    break;
                default:
                    if (targetObject[objectName] === undefined) {
                        console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
                        return;
                    }
                    targetObject = targetObject[objectName];
            }
            if (objectIndex !== undefined) {
                if (targetObject[objectIndex] === undefined) {
                    console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
                    return;
                }
                targetObject = targetObject[objectIndex];
            }
        }
        // resolve property
        const nodeProperty = targetObject[propertyName];
        if (nodeProperty === undefined) {
            const nodeName = parsedPath.nodeName;
            console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
            return;
        }
        // determine versioning scheme
        let versioning = this.Versioning.None;
        this.targetObject = targetObject;
        if (targetObject.needsUpdate !== undefined) versioning = this.Versioning.NeedsUpdate;
        else if (targetObject.matrixWorldNeedsUpdate !== undefined) versioning = this.Versioning.MatrixWorldNeedsUpdate;
        // determine how the property gets bound
        let bindingType = this.BindingType.Direct;
        if (propertyIndex !== undefined) {
            // access a sub element of the property array (only primitives are supported right now)
            if (propertyName === "morphTargetInfluences") {
                // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
                // support resolving morphTarget names into indices.
                if (!targetObject.geometry) {
                    console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
                    return;
                }
                if (targetObject.geometry.isBufferGeometry) {
                    if (!targetObject.geometry.morphAttributes) {
                        console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
                        return;
                    }
                    if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
                } else {
                    console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);
                    return;
                }
            }
            bindingType = this.BindingType.ArrayElement;
            this.resolvedProperty = nodeProperty;
            this.propertyIndex = propertyIndex;
        } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
            // must use copy for Object3D.Euler/Quaternion
            bindingType = this.BindingType.HasFromToArray;
            this.resolvedProperty = nodeProperty;
        } else if (Array.isArray(nodeProperty)) {
            bindingType = this.BindingType.EntireArray;
            this.resolvedProperty = nodeProperty;
        } else this.propertyName = propertyName;
        // select getter / setter
        this.getValue = this.GetterByBindingType[bindingType];
        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    },
    unbind: function() {
        this.node = null;
        // back to the prototype version of getValue / setValue
        // note: avoiding to mutate the shape of 'this' via 'delete'
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
    }
});
// DECLARE ALIAS AFTER assign prototype
Object.assign(PropertyBinding2.prototype, {
    // initial state of these methods that calls 'bind'
    _getValue_unbound: PropertyBinding2.prototype.getValue,
    _setValue_unbound: PropertyBinding2.prototype.setValue
});
const PropertyBinding1 = PropertyBinding2;
export { PropertyBinding1 as PropertyBinding };
function CubicInterpolant2(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant1.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0.0;
    this._offsetPrev = -0.0;
    this._weightNext = -0.0;
    this._offsetNext = -0.0;
}
CubicInterpolant2.prototype = Object.assign(Object.create(Interpolant1.prototype), {
    constructor: CubicInterpolant2,
    DefaultSettings_: {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
    },
    intervalChanged_: function(i12, t0, t11) {
        const pp = this.parameterPositions;
        let iPrev = i12 - 2, iNext = i12 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
        if (tPrev === undefined) switch(this.getSettings_().endingStart){
            case ZeroSlopeEnding:
                iPrev = i12;
                tPrev = 2 * t0 - t11;
                break;
            case WrapAroundEnding:
                iPrev = pp.length - 2;
                tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                break;
            default:
                iPrev = i12;
                tPrev = t11;
        }
        if (tNext === undefined) switch(this.getSettings_().endingEnd){
            case ZeroSlopeEnding:
                iNext = i12;
                tNext = 2 * t11 - t0;
                break;
            case WrapAroundEnding:
                iNext = 1;
                tNext = t11 + pp[1] - pp[0];
                break;
            default:
                iNext = i12 - 1;
                tNext = t0;
        }
        const halfDt = (t11 - t0) * 0.5, stride = this.valueSize;
        this._weightPrev = halfDt / (t0 - tPrev);
        this._weightNext = halfDt / (tNext - t11);
        this._offsetPrev = iPrev * stride;
        this._offsetNext = iNext * stride;
    },
    interpolate_: function(i12, t0, t2, t11) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i12 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p1 = (t2 - t0) / (t11 - t0), pp = p1 * p1, ppp = pp * p1;
        const sP = -wP * ppp + 2 * wP * pp - wP * p1;
        const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p1 + 1;
        const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p1;
        const sN = wN * ppp - wN * pp;
        for(let i7 = 0; i7 !== stride; ++i7)result[i7] = sP * values[oP + i7] + s0 * values[o0 + i7] + s1 * values[o1 + i7] + sN * values[oN + i7];
        return result;
    }
});
const CubicInterpolant1 = CubicInterpolant2;
function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant1.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
LinearInterpolant.prototype = Object.assign(Object.create(Interpolant1.prototype), {
    constructor: LinearInterpolant,
    interpolate_: function(i12, t0, t2, t11) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i12 * stride, offset0 = offset1 - stride, weight1 = (t2 - t0) / (t11 - t0), weight0 = 1 - weight1;
        for(let i7 = 0; i7 !== stride; ++i7)result[i7] = values[offset0 + i7] * weight0 + values[offset1 + i7] * weight1;
        return result;
    }
});
const LinearInterpolant1 = LinearInterpolant;
function DiscreteInterpolant2(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant1.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
DiscreteInterpolant2.prototype = Object.assign(Object.create(Interpolant1.prototype), {
    constructor: DiscreteInterpolant2,
    interpolate_: function(i12) {
        return this.copySampleValue_(i12 - 1);
    }
});
const DiscreteInterpolant1 = DiscreteInterpolant2;
const AnimationUtils = {
    // same as Array.prototype.slice, but also works on typed arrays
    arraySlice: function(array, from, to) {
        if (AnimationUtils.isTypedArray(array)) // in ios9 array.subarray(from, undefined) will return empty array
        // but array.subarray(from) or array.subarray(from, len) is correct
        return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
        return array.slice(from, to);
    },
    // converts an array to a specific type
    convertArray: function(array, type, forceClone) {
        if (!array || !forceClone && array.constructor === type) return array;
        if (typeof type.BYTES_PER_ELEMENT === 'number') return new type(array); // create typed array
        return Array.prototype.slice.call(array); // create Array
    },
    isTypedArray: function(object) {
        return ArrayBuffer.isView(object) && !(object instanceof DataView);
    },
    // returns an array by which times and values can be sorted
    getKeyframeOrder: function(times) {
        function compareTime(i7, j4) {
            return times[i7] - times[j4];
        }
        const n = times.length;
        const result = new Array(n);
        for(let i7 = 0; i7 !== n; ++i7)result[i7] = i7;
        result.sort(compareTime);
        return result;
    },
    // uses the array previously returned by 'getKeyframeOrder' to sort data
    sortedArray: function(values, stride, order1) {
        const nValues = values.length;
        const result = new values.constructor(nValues);
        for(let i7 = 0, dstOffset = 0; dstOffset !== nValues; ++i7){
            const srcOffset = order1[i7] * stride;
            for(let j4 = 0; j4 !== stride; ++j4)result[dstOffset++] = values[srcOffset + j4];
        }
        return result;
    },
    // function for parsing AOS keyframe formats
    flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
        let i7 = 1, key = jsonKeys[0];
        while(key !== undefined && key[valuePropertyName] === undefined)key = jsonKeys[i7++];
        if (key === undefined) return; // no data
        let value = key[valuePropertyName];
        if (value === undefined) return; // no data
        if (Array.isArray(value)) do {
            value = key[valuePropertyName];
            if (value !== undefined) {
                times.push(key.time);
                values.push.apply(values, value); // push all elements
            }
            key = jsonKeys[i7++];
        }while (key !== undefined)
        else if (value.toArray !== undefined) // ...assume THREE.Math-ish
        do {
            value = key[valuePropertyName];
            if (value !== undefined) {
                times.push(key.time);
                value.toArray(values, values.length);
            }
            key = jsonKeys[i7++];
        }while (key !== undefined)
        else // otherwise push as-is
        do {
            value = key[valuePropertyName];
            if (value !== undefined) {
                times.push(key.time);
                values.push(value);
            }
            key = jsonKeys[i7++];
        }while (key !== undefined)
    },
    subclip: function(sourceClip, name, startFrame, endFrame, fps) {
        fps = fps || 30;
        const clip = sourceClip.clone();
        clip.name = name;
        const tracks = [];
        for(let i7 = 0; i7 < clip.tracks.length; ++i7){
            const track = clip.tracks[i7];
            const valueSize = track.getValueSize();
            const times = [];
            const values = [];
            for(let j4 = 0; j4 < track.times.length; ++j4){
                const frame = track.times[j4] * fps;
                if (frame < startFrame || frame >= endFrame) continue;
                times.push(track.times[j4]);
                for(let k = 0; k < valueSize; ++k)values.push(track.values[j4 * valueSize + k]);
            }
            if (times.length === 0) continue;
            track.times = AnimationUtils.convertArray(times, track.times.constructor);
            track.values = AnimationUtils.convertArray(values, track.values.constructor);
            tracks.push(track);
        }
        clip.tracks = tracks;
        // find minimum .times value across all tracks in the trimmed clip
        let minStartTime = Infinity;
        for(let i7 = 0; i7 < clip.tracks.length; ++i7)if (minStartTime > clip.tracks[i7].times[0]) minStartTime = clip.tracks[i7].times[0];
        // shift all tracks such that clip begins at t=0
        for(let i7 = 0; i7 < clip.tracks.length; ++i7)clip.tracks[i7].shift(-1 * minStartTime);
        clip.resetDuration();
        return clip;
    },
    makeClipAdditive: function(targetClip, referenceFrame, referenceClip, fps) {
        if (referenceFrame === undefined) referenceFrame = 0;
        if (referenceClip === undefined) referenceClip = targetClip;
        if (fps === undefined || fps <= 0) fps = 30;
        const numTracks = targetClip.tracks.length;
        const referenceTime = referenceFrame / fps;
        // Make each track's values relative to the values at the reference frame
        for(let i7 = 0; i7 < numTracks; ++i7){
            const referenceTrack = referenceClip.tracks[i7];
            const referenceTrackType = referenceTrack.ValueTypeName;
            // Skip this track if it's non-numeric
            if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue;
            // Find the track in the target clip whose name and type matches the reference track
            const targetTrack = targetClip.tracks.find(function(track) {
                return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
            });
            if (targetTrack === undefined) continue;
            let referenceOffset = 0;
            const referenceValueSize = referenceTrack.getValueSize();
            if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) referenceOffset = referenceValueSize / 3;
            let targetOffset = 0;
            const targetValueSize = targetTrack.getValueSize();
            if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) targetOffset = targetValueSize / 3;
            const lastIndex = referenceTrack.times.length - 1;
            let referenceValue;
            // Find the value to subtract out of the track
            if (referenceTime <= referenceTrack.times[0]) {
                // Reference frame is earlier than the first keyframe, so just use the first keyframe
                const startIndex = referenceOffset;
                const endIndex = referenceValueSize - referenceOffset;
                referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else if (referenceTime >= referenceTrack.times[lastIndex]) {
                // Reference frame is after the last keyframe, so just use the last keyframe
                const startIndex = lastIndex * referenceValueSize + referenceOffset;
                const endIndex = startIndex + referenceValueSize - referenceOffset;
                referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else {
                // Interpolate to the reference value
                const interpolant = referenceTrack.createInterpolant();
                const startIndex = referenceOffset;
                const endIndex = referenceValueSize - referenceOffset;
                interpolant.evaluate(referenceTime);
                referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
            }
            // Conjugate the quaternion
            if (referenceTrackType === 'quaternion') {
                const referenceQuat = new Quaternion1().fromArray(referenceValue).normalize().conjugate();
                referenceQuat.toArray(referenceValue);
            }
            // Subtract the reference value from all of the track values
            const numTimes = targetTrack.times.length;
            for(let j4 = 0; j4 < numTimes; ++j4){
                const valueStart = j4 * targetValueSize + targetOffset;
                if (referenceTrackType === 'quaternion') // Multiply the conjugate for quaternion track types
                Quaternion1.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
                else {
                    const valueEnd = targetValueSize - targetOffset * 2;
                    // Subtract each value for all other numeric track types
                    for(let k = 0; k < valueEnd; ++k)targetTrack.values[valueStart + k] -= referenceValue[k];
                }
            }
        }
        targetClip.blendMode = AdditiveAnimationBlendMode;
        return targetClip;
    }
};
const AnimationUtils1 = AnimationUtils;
function KeyframeTrack2(name, times, values, interpolation) {
    if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
    if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
    this.name = name;
    this.times = AnimationUtils1.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils1.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
}
Object.assign(KeyframeTrack2, {
    toJSON: function(track) {
        const trackType = track.constructor;
        let json;
        if (trackType.toJSON !== undefined) json = trackType.toJSON(track);
        else {
            json = {
                'name': track.name,
                'times': AnimationUtils1.convertArray(track.times, Array),
                'values': AnimationUtils1.convertArray(track.values, Array)
            };
            const interpolation = track.getInterpolation();
            if (interpolation !== track.DefaultInterpolation) json.interpolation = interpolation;
        }
        json.type = track.ValueTypeName;
        return json;
    }
});
Object.assign(KeyframeTrack2.prototype, {
    constructor: KeyframeTrack2,
    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,
    DefaultInterpolation: InterpolateLinear,
    InterpolantFactoryMethodDiscrete: function(result) {
        return new DiscreteInterpolant1(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodLinear: function(result) {
        return new LinearInterpolant1(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodSmooth: function(result) {
        return new CubicInterpolant1(this.times, this.values, this.getValueSize(), result);
    },
    setInterpolation: function(interpolation) {
        let factoryMethod;
        switch(interpolation){
            case InterpolateDiscrete:
                factoryMethod = this.InterpolantFactoryMethodDiscrete;
                break;
            case InterpolateLinear:
                factoryMethod = this.InterpolantFactoryMethodLinear;
                break;
            case InterpolateSmooth:
                factoryMethod = this.InterpolantFactoryMethodSmooth;
                break;
        }
        if (factoryMethod === undefined) {
            const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === undefined) {
                if (interpolation !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                else throw new Error(message);
            }
            console.warn('THREE.KeyframeTrack:', message);
            return this;
        }
        this.createInterpolant = factoryMethod;
        return this;
    },
    getInterpolation: function() {
        switch(this.createInterpolant){
            case this.InterpolantFactoryMethodDiscrete:
                return InterpolateDiscrete;
            case this.InterpolantFactoryMethodLinear:
                return InterpolateLinear;
            case this.InterpolantFactoryMethodSmooth:
                return InterpolateSmooth;
        }
    },
    getValueSize: function() {
        return this.values.length / this.times.length;
    },
    shift: function(timeOffset) {
        if (timeOffset !== 0) {
            const times = this.times;
            for(let i7 = 0, n = times.length; i7 !== n; ++i7)times[i7] += timeOffset;
        }
        return this;
    },
    scale: function(timeScale) {
        if (timeScale !== 1) {
            const times = this.times;
            for(let i7 = 0, n = times.length; i7 !== n; ++i7)times[i7] *= timeScale;
        }
        return this;
    },
    trim: function(startTime, endTime) {
        const times = this.times, nKeys = times.length;
        let from = 0, to = nKeys - 1;
        while(from !== nKeys && times[from] < startTime)++from;
        while(to !== -1 && times[to] > endTime)--to;
        ++to;
        if (from !== 0 || to !== nKeys) {
            if (from >= to) {
                to = Math.max(to, 1);
                from = to - 1;
            }
            const stride = this.getValueSize();
            this.times = AnimationUtils1.arraySlice(times, from, to);
            this.values = AnimationUtils1.arraySlice(this.values, from * stride, to * stride);
        }
        return this;
    },
    validate: function() {
        let valid = true;
        const valueSize = this.getValueSize();
        if (valueSize - Math.floor(valueSize) !== 0) {
            console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
            valid = false;
        }
        const times = this.times, values = this.values, nKeys = times.length;
        if (nKeys === 0) {
            console.error('THREE.KeyframeTrack: Track is empty.', this);
            valid = false;
        }
        let prevTime = null;
        for(let i7 = 0; i7 !== nKeys; i7++){
            const currTime = times[i7];
            if (typeof currTime === 'number' && isNaN(currTime)) {
                console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i7, currTime);
                valid = false;
                break;
            }
            if (prevTime !== null && prevTime > currTime) {
                console.error('THREE.KeyframeTrack: Out of order keys.', this, i7, currTime, prevTime);
                valid = false;
                break;
            }
            prevTime = currTime;
        }
        if (values !== undefined) {
            if (AnimationUtils1.isTypedArray(values)) for(let i7 = 0, n = values.length; i7 !== n; ++i7){
                const value = values[i7];
                if (isNaN(value)) {
                    console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i7, value);
                    valid = false;
                    break;
                }
            }
        }
        return valid;
    },
    optimize: function() {
        const times = AnimationUtils1.arraySlice(this.times), values = AnimationUtils1.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
        let writeIndex = 1;
        for(let i7 = 1; i7 < lastIndex; ++i7){
            let keep = false;
            const time = times[i7];
            const timeNext = times[i7 + 1];
            if (time !== timeNext && (i7 !== 1 || time !== time[0])) {
                if (!smoothInterpolation) {
                    const offset = i7 * stride, offsetP = offset - stride, offsetN = offset + stride;
                    for(let j4 = 0; j4 !== stride; ++j4){
                        const value = values[offset + j4];
                        if (value !== values[offsetP + j4] || value !== values[offsetN + j4]) {
                            keep = true;
                            break;
                        }
                    }
                } else keep = true;
            }
            if (keep) {
                if (i7 !== writeIndex) {
                    times[writeIndex] = times[i7];
                    const readOffset = i7 * stride, writeOffset = writeIndex * stride;
                    for(let j4 = 0; j4 !== stride; ++j4)values[writeOffset + j4] = values[readOffset + j4];
                }
                ++writeIndex;
            }
        }
        if (lastIndex > 0) {
            times[writeIndex] = times[lastIndex];
            for(let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j4 = 0; j4 !== stride; ++j4)values[writeOffset + j4] = values[readOffset + j4];
            ++writeIndex;
        }
        if (writeIndex !== times.length) {
            this.times = AnimationUtils1.arraySlice(times, 0, writeIndex);
            this.values = AnimationUtils1.arraySlice(values, 0, writeIndex * stride);
        } else {
            this.times = times;
            this.values = values;
        }
        return this;
    },
    clone: function() {
        const times = AnimationUtils1.arraySlice(this.times, 0);
        const values = AnimationUtils1.arraySlice(this.values, 0);
        const TypedKeyframeTrack = this.constructor;
        const track = new TypedKeyframeTrack(this.name, times, values);
        track.createInterpolant = this.createInterpolant;
        return track;
    }
});
const KeyframeTrack1 = KeyframeTrack2;
export { KeyframeTrack1 as KeyframeTrack };
const AnimationUtils2 = {
    arraySlice: function(array, from, to) {
        if (AnimationUtils2.isTypedArray(array)) return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
        return array.slice(from, to);
    },
    convertArray: function(array, type, forceClone) {
        if (!array || !forceClone && array.constructor === type) return array;
        if (typeof type.BYTES_PER_ELEMENT === 'number') return new type(array);
        return Array.prototype.slice.call(array);
    },
    isTypedArray: function(object) {
        return ArrayBuffer.isView(object) && !(object instanceof DataView);
    },
    getKeyframeOrder: function(times) {
        function compareTime(i7, j4) {
            return times[i7] - times[j4];
        }
        const n = times.length;
        const result = new Array(n);
        for(let i7 = 0; i7 !== n; ++i7)result[i7] = i7;
        result.sort(compareTime);
        return result;
    },
    sortedArray: function(values, stride, order1) {
        const nValues = values.length;
        const result = new values.constructor(nValues);
        for(let i7 = 0, dstOffset = 0; dstOffset !== nValues; ++i7){
            const srcOffset = order1[i7] * stride;
            for(let j4 = 0; j4 !== stride; ++j4)result[dstOffset++] = values[srcOffset + j4];
        }
        return result;
    },
    flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
        let i7 = 1, key = jsonKeys[0];
        while(key !== undefined && key[valuePropertyName] === undefined)key = jsonKeys[i7++];
        if (key === undefined) return;
        let value = key[valuePropertyName];
        if (value === undefined) return;
        if (Array.isArray(value)) do {
            value = key[valuePropertyName];
            if (value !== undefined) {
                times.push(key.time);
                values.push.apply(values, value);
            }
            key = jsonKeys[i7++];
        }while (key !== undefined)
        else if (value.toArray !== undefined) do {
            value = key[valuePropertyName];
            if (value !== undefined) {
                times.push(key.time);
                value.toArray(values, values.length);
            }
            key = jsonKeys[i7++];
        }while (key !== undefined)
        else do {
            value = key[valuePropertyName];
            if (value !== undefined) {
                times.push(key.time);
                values.push(value);
            }
            key = jsonKeys[i7++];
        }while (key !== undefined)
    },
    subclip: function(sourceClip, name, startFrame, endFrame, fps) {
        fps = fps || 30;
        const clip = sourceClip.clone();
        clip.name = name;
        const tracks = [];
        for(let i7 = 0; i7 < clip.tracks.length; ++i7){
            const track = clip.tracks[i7];
            const valueSize = track.getValueSize();
            const times = [];
            const values = [];
            for(let j4 = 0; j4 < track.times.length; ++j4){
                const frame = track.times[j4] * fps;
                if (frame < startFrame || frame >= endFrame) continue;
                times.push(track.times[j4]);
                for(let k = 0; k < valueSize; ++k)values.push(track.values[j4 * valueSize + k]);
            }
            if (times.length === 0) continue;
            track.times = AnimationUtils2.convertArray(times, track.times.constructor);
            track.values = AnimationUtils2.convertArray(values, track.values.constructor);
            tracks.push(track);
        }
        clip.tracks = tracks;
        let minStartTime = Infinity;
        for(let i7 = 0; i7 < clip.tracks.length; ++i7)if (minStartTime > clip.tracks[i7].times[0]) minStartTime = clip.tracks[i7].times[0];
        for(let i7 = 0; i7 < clip.tracks.length; ++i7)clip.tracks[i7].shift(-1 * minStartTime);
        clip.resetDuration();
        return clip;
    },
    makeClipAdditive: function(targetClip, referenceFrame, referenceClip, fps) {
        if (referenceFrame === undefined) referenceFrame = 0;
        if (referenceClip === undefined) referenceClip = targetClip;
        if (fps === undefined || fps <= 0) fps = 30;
        const numTracks = targetClip.tracks.length;
        const referenceTime = referenceFrame / fps;
        for(let i7 = 0; i7 < numTracks; ++i7){
            const referenceTrack = referenceClip.tracks[i7];
            const referenceTrackType = referenceTrack.ValueTypeName;
            if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue;
            const targetTrack = targetClip.tracks.find(function(track) {
                return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
            });
            if (targetTrack === undefined) continue;
            let referenceOffset = 0;
            const referenceValueSize = referenceTrack.getValueSize();
            if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) referenceOffset = referenceValueSize / 3;
            let targetOffset = 0;
            const targetValueSize = targetTrack.getValueSize();
            if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) targetOffset = targetValueSize / 3;
            const lastIndex = referenceTrack.times.length - 1;
            let referenceValue;
            if (referenceTime <= referenceTrack.times[0]) {
                const startIndex = referenceOffset;
                const endIndex = referenceValueSize - referenceOffset;
                referenceValue = AnimationUtils2.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else if (referenceTime >= referenceTrack.times[lastIndex]) {
                const startIndex = lastIndex * referenceValueSize + referenceOffset;
                const endIndex = startIndex + referenceValueSize - referenceOffset;
                referenceValue = AnimationUtils2.arraySlice(referenceTrack.values, startIndex, endIndex);
            } else {
                const interpolant = referenceTrack.createInterpolant();
                const startIndex = referenceOffset;
                const endIndex = referenceValueSize - referenceOffset;
                interpolant.evaluate(referenceTime);
                referenceValue = AnimationUtils2.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
            }
            if (referenceTrackType === 'quaternion') {
                const referenceQuat = new Quaternion1().fromArray(referenceValue).normalize().conjugate();
                referenceQuat.toArray(referenceValue);
            }
            const numTimes = targetTrack.times.length;
            for(let j4 = 0; j4 < numTimes; ++j4){
                const valueStart = j4 * targetValueSize + targetOffset;
                if (referenceTrackType === 'quaternion') Quaternion1.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
                else {
                    const valueEnd = targetValueSize - targetOffset * 2;
                    for(let k = 0; k < valueEnd; ++k)targetTrack.values[valueStart + k] -= referenceValue[k];
                }
            }
        }
        targetClip.blendMode = AdditiveAnimationBlendMode;
        return targetClip;
    }
};
const AnimationUtils1 = AnimationUtils2;
export { AnimationUtils1 as AnimationUtils };
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
const _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');
const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']';
const _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar);
const _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot);
const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar);
const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);
const _trackRe = new RegExp('^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');
const _supportedObjectNames = [
    'material',
    'materials',
    'bones'
];
function Composite(targetGroup, path1, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding3.parseTrackName(path1);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path1, parsedPath);
}
Object.assign(Composite.prototype, {
    getValue: function(array, offset) {
        this.bind();
        const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
        if (binding !== undefined) binding.getValue(array, offset);
    },
    setValue: function(array, offset) {
        const bindings = this._bindings;
        for(let i7 = this._targetGroup.nCachedObjects_, n = bindings.length; i7 !== n; ++i7)bindings[i7].setValue(array, offset);
    },
    bind: function() {
        const bindings = this._bindings;
        for(let i7 = this._targetGroup.nCachedObjects_, n = bindings.length; i7 !== n; ++i7)bindings[i7].bind();
    },
    unbind: function() {
        const bindings = this._bindings;
        for(let i7 = this._targetGroup.nCachedObjects_, n = bindings.length; i7 !== n; ++i7)bindings[i7].unbind();
    }
});
function PropertyBinding3(rootNode, path1, parsedPath) {
    this.path = path1;
    this.parsedPath = parsedPath || PropertyBinding3.parseTrackName(path1);
    this.node = PropertyBinding3.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
    this.rootNode = rootNode;
}
Object.assign(PropertyBinding3, {
    Composite: Composite,
    create: function(root, path1, parsedPath) {
        if (!(root && root.isAnimationObjectGroup)) return new PropertyBinding3(root, path1, parsedPath);
        else return new PropertyBinding3.Composite(root, path1, parsedPath);
    },
    sanitizeNodeName: function(name) {
        return name.replace(/\s/g, '_').replace(_reservedRe, '');
    },
    parseTrackName: function(trackName) {
        const matches = _trackRe.exec(trackName);
        if (!matches) throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
        const results = {
            nodeName: matches[2],
            objectName: matches[3],
            objectIndex: matches[4],
            propertyName: matches[5],
            propertyIndex: matches[6]
        };
        const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');
        if (lastDot !== undefined && lastDot !== -1) {
            const objectName = results.nodeName.substring(lastDot + 1);
            if (_supportedObjectNames.indexOf(objectName) !== -1) {
                results.nodeName = results.nodeName.substring(0, lastDot);
                results.objectName = objectName;
            }
        }
        if (results.propertyName === null || results.propertyName.length === 0) throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
        return results;
    },
    findNode: function(root, nodeName) {
        if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) return root;
        if (root.skeleton) {
            const bone = root.skeleton.getBoneByName(nodeName);
            if (bone !== undefined) return bone;
        }
        if (root.children) {
            const searchNodeSubtree = function(children) {
                for(let i7 = 0; i7 < children.length; i7++){
                    const childNode = children[i7];
                    if (childNode.name === nodeName || childNode.uuid === nodeName) return childNode;
                    const result = searchNodeSubtree(childNode.children);
                    if (result) return result;
                }
                return null;
            };
            const subTreeNode = searchNodeSubtree(root.children);
            if (subTreeNode) return subTreeNode;
        }
        return null;
    }
});
Object.assign(PropertyBinding3.prototype, {
    _getValue_unavailable: function() {
    },
    _setValue_unavailable: function() {
    },
    BindingType: {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    },
    Versioning: {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    },
    GetterByBindingType: [
        function getValue_direct(buffer, offset) {
            buffer[offset] = this.node[this.propertyName];
        },
        function getValue_array(buffer, offset) {
            const source = this.resolvedProperty;
            for(let i7 = 0, n = source.length; i7 !== n; ++i7)buffer[offset++] = source[i7];
        },
        function getValue_arrayElement(buffer, offset) {
            buffer[offset] = this.resolvedProperty[this.propertyIndex];
        },
        function getValue_toArray(buffer, offset) {
            this.resolvedProperty.toArray(buffer, offset);
        }
    ],
    SetterByBindingTypeAndVersioning: [
        [
            function setValue_direct(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
            },
            function setValue_direct_setNeedsUpdate(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
                this.targetObject.needsUpdate = true;
            },
            function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.targetObject[this.propertyName] = buffer[offset];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ],
        [
            function setValue_array(buffer, offset) {
                const dest = this.resolvedProperty;
                for(let i7 = 0, n = dest.length; i7 !== n; ++i7)dest[i7] = buffer[offset++];
            },
            function setValue_array_setNeedsUpdate(buffer, offset) {
                const dest = this.resolvedProperty;
                for(let i7 = 0, n = dest.length; i7 !== n; ++i7)dest[i7] = buffer[offset++];
                this.targetObject.needsUpdate = true;
            },
            function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
                const dest = this.resolvedProperty;
                for(let i7 = 0, n = dest.length; i7 !== n; ++i7)dest[i7] = buffer[offset++];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ],
        [
            function setValue_arrayElement(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
            },
            function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
                this.targetObject.needsUpdate = true;
            },
            function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.resolvedProperty[this.propertyIndex] = buffer[offset];
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ],
        [
            function setValue_fromArray(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
            },
            function setValue_fromArray_setNeedsUpdate(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
                this.targetObject.needsUpdate = true;
            },
            function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
                this.resolvedProperty.fromArray(buffer, offset);
                this.targetObject.matrixWorldNeedsUpdate = true;
            }
        ]
    ],
    getValue: function getValue_unbound(targetArray, offset) {
        this.bind();
        this.getValue(targetArray, offset);
    },
    setValue: function getValue_unbound(sourceArray, offset) {
        this.bind();
        this.setValue(sourceArray, offset);
    },
    bind: function() {
        let targetObject = this.node;
        const parsedPath = this.parsedPath;
        const objectName = parsedPath.objectName;
        const propertyName = parsedPath.propertyName;
        let propertyIndex = parsedPath.propertyIndex;
        if (!targetObject) {
            targetObject = PropertyBinding3.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
            this.node = targetObject;
        }
        this.getValue = this._getValue_unavailable;
        this.setValue = this._setValue_unavailable;
        if (!targetObject) {
            console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
            return;
        }
        if (objectName) {
            let objectIndex = parsedPath.objectIndex;
            switch(objectName){
                case 'materials':
                    if (!targetObject.material) {
                        console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                        return;
                    }
                    if (!targetObject.material.materials) {
                        console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
                        return;
                    }
                    targetObject = targetObject.material.materials;
                    break;
                case 'bones':
                    if (!targetObject.skeleton) {
                        console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
                        return;
                    }
                    targetObject = targetObject.skeleton.bones;
                    for(let i7 = 0; i7 < targetObject.length; i7++)if (targetObject[i7].name === objectIndex) {
                        objectIndex = i7;
                        break;
                    }
                    break;
                default:
                    if (targetObject[objectName] === undefined) {
                        console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
                        return;
                    }
                    targetObject = targetObject[objectName];
            }
            if (objectIndex !== undefined) {
                if (targetObject[objectIndex] === undefined) {
                    console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
                    return;
                }
                targetObject = targetObject[objectIndex];
            }
        }
        const nodeProperty = targetObject[propertyName];
        if (nodeProperty === undefined) {
            const nodeName = parsedPath.nodeName;
            console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
            return;
        }
        let versioning = this.Versioning.None;
        this.targetObject = targetObject;
        if (targetObject.needsUpdate !== undefined) versioning = this.Versioning.NeedsUpdate;
        else if (targetObject.matrixWorldNeedsUpdate !== undefined) versioning = this.Versioning.MatrixWorldNeedsUpdate;
        let bindingType = this.BindingType.Direct;
        if (propertyIndex !== undefined) {
            if (propertyName === "morphTargetInfluences") {
                if (!targetObject.geometry) {
                    console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
                    return;
                }
                if (targetObject.geometry.isBufferGeometry) {
                    if (!targetObject.geometry.morphAttributes) {
                        console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
                        return;
                    }
                    if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
                } else {
                    console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);
                    return;
                }
            }
            bindingType = this.BindingType.ArrayElement;
            this.resolvedProperty = nodeProperty;
            this.propertyIndex = propertyIndex;
        } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
            bindingType = this.BindingType.HasFromToArray;
            this.resolvedProperty = nodeProperty;
        } else if (Array.isArray(nodeProperty)) {
            bindingType = this.BindingType.EntireArray;
            this.resolvedProperty = nodeProperty;
        } else this.propertyName = propertyName;
        this.getValue = this.GetterByBindingType[bindingType];
        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    },
    unbind: function() {
        this.node = null;
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
    }
});
Object.assign(PropertyBinding3.prototype, {
    _getValue_unbound: PropertyBinding3.prototype.getValue,
    _setValue_unbound: PropertyBinding3.prototype.setValue
});
const PropertyBinding1 = PropertyBinding3;
/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */
function AnimationObjectGroup() {
    this.uuid = MathUtils1.generateUUID();
    // cached objects followed by the active ones
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0; // threshold
    // note: read by PropertyBinding.Composite
    const indices17 = {
    };
    this._indicesByUUID = indices17; // for bookkeeping
    for(let i7 = 0, n = arguments.length; i7 !== n; ++i7)indices17[arguments[i7].uuid] = i7;
    this._paths = []; // inside: string
    this._parsedPaths = []; // inside: { we don't care, here }
    this._bindings = []; // inside: Array< PropertyBinding >
    this._bindingsIndicesByPath = {
    }; // inside: indices in these arrays
    const scope3 = this;
    this.stats = {
        objects: {
            get total () {
                return scope3._objects.length;
            },
            get inUse () {
                return this.total - scope3.nCachedObjects_;
            }
        },
        get bindingsPerObject () {
            return scope3._bindings.length;
        }
    };
}
Object.assign(AnimationObjectGroup.prototype, {
    isAnimationObjectGroup: true,
    add: function() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
        let knownObject = undefined, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
        for(let i7 = 0, n = arguments.length; i7 !== n; ++i7){
            const object = arguments[i7], uuid = object.uuid;
            let index2 = indicesByUUID[uuid];
            if (index2 === undefined) {
                // unknown object -> add it to the ACTIVE region
                index2 = nObjects++;
                indicesByUUID[uuid] = index2;
                objects.push(object);
                // accounting is done, now do the same for all bindings
                for(let j4 = 0, m = nBindings; j4 !== m; ++j4)bindings[j4].push(new PropertyBinding1(object, paths[j4], parsedPaths[j4]));
            } else if (index2 < nCachedObjects) {
                knownObject = objects[index2];
                // move existing object to the ACTIVE region
                const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
                indicesByUUID[lastCachedObject.uuid] = index2;
                objects[index2] = lastCachedObject;
                indicesByUUID[uuid] = firstActiveIndex;
                objects[firstActiveIndex] = object;
                // accounting is done, now do the same for all bindings
                for(let j4 = 0, m = nBindings; j4 !== m; ++j4){
                    const bindingsForPath = bindings[j4], lastCached = bindingsForPath[firstActiveIndex];
                    let binding = bindingsForPath[index2];
                    bindingsForPath[index2] = lastCached;
                    if (binding === undefined) // since we do not bother to create new bindings
                    // for objects that are cached, the binding may
                    // or may not exist
                    binding = new PropertyBinding1(object, paths[j4], parsedPaths[j4]);
                    bindingsForPath[firstActiveIndex] = binding;
                }
            } else if (objects[index2] !== knownObject) console.error('THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.');
             // else the object is already where we want it to be
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    },
    remove: function() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_;
        for(let i7 = 0, n = arguments.length; i7 !== n; ++i7){
            const object = arguments[i7], uuid = object.uuid, index2 = indicesByUUID[uuid];
            if (index2 !== undefined && index2 >= nCachedObjects) {
                // move existing object into the CACHED region
                const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
                indicesByUUID[firstActiveObject.uuid] = index2;
                objects[index2] = firstActiveObject;
                indicesByUUID[uuid] = lastCachedIndex;
                objects[lastCachedIndex] = object;
                // accounting is done, now do the same for all bindings
                for(let j4 = 0, m = nBindings; j4 !== m; ++j4){
                    const bindingsForPath = bindings[j4], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index2];
                    bindingsForPath[index2] = firstActive;
                    bindingsForPath[lastCachedIndex] = binding;
                }
            }
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    },
    // remove & forget
    uncache: function() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
        for(let i7 = 0, n = arguments.length; i7 !== n; ++i7){
            const object = arguments[i7], uuid = object.uuid, index2 = indicesByUUID[uuid];
            if (index2 !== undefined) {
                delete indicesByUUID[uuid];
                if (index2 < nCachedObjects) {
                    // object is cached, shrink the CACHED region
                    const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
                    // last cached object takes this object's place
                    indicesByUUID[lastCachedObject.uuid] = index2;
                    objects[index2] = lastCachedObject;
                    // last object goes to the activated slot and pop
                    indicesByUUID[lastObject.uuid] = firstActiveIndex;
                    objects[firstActiveIndex] = lastObject;
                    objects.pop();
                    // accounting is done, now do the same for all bindings
                    for(let j4 = 0, m = nBindings; j4 !== m; ++j4){
                        const bindingsForPath = bindings[j4], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                        bindingsForPath[index2] = lastCached;
                        bindingsForPath[firstActiveIndex] = last;
                        bindingsForPath.pop();
                    }
                } else {
                    // object is active, just swap with the last and pop
                    const lastIndex = --nObjects, lastObject = objects[lastIndex];
                    indicesByUUID[lastObject.uuid] = index2;
                    objects[index2] = lastObject;
                    objects.pop();
                    // accounting is done, now do the same for all bindings
                    for(let j4 = 0, m = nBindings; j4 !== m; ++j4){
                        const bindingsForPath = bindings[j4];
                        bindingsForPath[index2] = bindingsForPath[lastIndex];
                        bindingsForPath.pop();
                    }
                } // cached or active
            } // if object is known
        } // for arguments
        this.nCachedObjects_ = nCachedObjects;
    },
    // Internal interface used by befriended PropertyBinding.Composite:
    subscribe_: function(path1, parsedPath) {
        // returns an array of bindings for the given path that is changed
        // according to the contained objects in the group
        const indicesByPath = this._bindingsIndicesByPath;
        let index2 = indicesByPath[path1];
        const bindings = this._bindings;
        if (index2 !== undefined) return bindings[index2];
        const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
        index2 = bindings.length;
        indicesByPath[path1] = index2;
        paths.push(path1);
        parsedPaths.push(parsedPath);
        bindings.push(bindingsForPath);
        for(let i7 = nCachedObjects, n = objects.length; i7 !== n; ++i7){
            const object = objects[i7];
            bindingsForPath[i7] = new PropertyBinding1(object, path1, parsedPath);
        }
        return bindingsForPath;
    },
    unsubscribe_: function(path1) {
        // tells the group to forget about a property path and no longer
        // update the array previously obtained with 'subscribe_'
        const indicesByPath = this._bindingsIndicesByPath, index2 = indicesByPath[path1];
        if (index2 !== undefined) {
            const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path1[lastBindingsIndex];
            indicesByPath[lastBindingsPath] = index2;
            bindings[index2] = lastBindings;
            bindings.pop();
            parsedPaths[index2] = parsedPaths[lastBindingsIndex];
            parsedPaths.pop();
            paths[index2] = paths[lastBindingsIndex];
            paths.pop();
        }
    }
});
const AnimationObjectGroup1 = AnimationObjectGroup;
export { AnimationObjectGroup1 as AnimationObjectGroup };
class AnimationAction {
    // State & Scheduling
    play() {
        this._mixer._activateAction(this);
        return this;
    }
    stop() {
        this._mixer._deactivateAction(this);
        return this.reset();
    }
    reset() {
        this.paused = false;
        this.enabled = true;
        this.time = 0; // restart clip
        this._loopCount = -1; // forget previous loops
        this._startTime = null; // forget scheduling
        return this.stopFading().stopWarping();
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    }
    // return true when play has been called
    isScheduled() {
        return this._mixer._isActiveAction(this);
    }
    startAt(time) {
        this._startTime = time;
        return this;
    }
    setLoop(mode, repetitions) {
        this.loop = mode;
        this.repetitions = repetitions;
        return this;
    }
    // Weight
    // set the weight stopping any scheduled fading
    // although .enabled = false yields an effective weight of zero, this
    // method does *not* change .enabled, because it would be confusing
    setEffectiveWeight(weight) {
        this.weight = weight;
        // note: same logic as when updated at runtime
        this._effectiveWeight = this.enabled ? weight : 0;
        return this.stopFading();
    }
    // return the weight considering fading and .enabled
    getEffectiveWeight() {
        return this._effectiveWeight;
    }
    fadeIn(duration) {
        return this._scheduleFading(duration, 0, 1);
    }
    fadeOut(duration) {
        return this._scheduleFading(duration, 1, 0);
    }
    crossFadeFrom(fadeOutAction, duration, warp) {
        fadeOutAction.fadeOut(duration);
        this.fadeIn(duration);
        if (warp) {
            const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
            fadeOutAction.warp(1, startEndRatio, duration);
            this.warp(endStartRatio, 1, duration);
        }
        return this;
    }
    crossFadeTo(fadeInAction, duration, warp) {
        return fadeInAction.crossFadeFrom(this, duration, warp);
    }
    stopFading() {
        const weightInterpolant = this._weightInterpolant;
        if (weightInterpolant !== null) {
            this._weightInterpolant = null;
            this._mixer._takeBackControlInterpolant(weightInterpolant);
        }
        return this;
    }
    // Time Scale Control
    // set the time scale stopping any scheduled warping
    // although .paused = true yields an effective time scale of zero, this
    // method does *not* change .paused, because it would be confusing
    setEffectiveTimeScale(timeScale) {
        this.timeScale = timeScale;
        this._effectiveTimeScale = this.paused ? 0 : timeScale;
        return this.stopWarping();
    }
    // return the time scale considering warping and .paused
    getEffectiveTimeScale() {
        return this._effectiveTimeScale;
    }
    setDuration(duration) {
        this.timeScale = this._clip.duration / duration;
        return this.stopWarping();
    }
    syncWith(action) {
        this.time = action.time;
        this.timeScale = action.timeScale;
        return this.stopWarping();
    }
    halt(duration) {
        return this.warp(this._effectiveTimeScale, 0, duration);
    }
    warp(startTimeScale, endTimeScale, duration) {
        const mixer = this._mixer, now = mixer.time, timeScale = this.timeScale;
        let interpolant = this._timeScaleInterpolant;
        if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._timeScaleInterpolant = interpolant;
        }
        const times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now;
        times[1] = now + duration;
        values[0] = startTimeScale / timeScale;
        values[1] = endTimeScale / timeScale;
        return this;
    }
    stopWarping() {
        const timeScaleInterpolant = this._timeScaleInterpolant;
        if (timeScaleInterpolant !== null) {
            this._timeScaleInterpolant = null;
            this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
        }
        return this;
    }
    // Object Accessors
    getMixer() {
        return this._mixer;
    }
    getClip() {
        return this._clip;
    }
    getRoot() {
        return this._localRoot || this._mixer._root;
    }
    // Interna
    _update(time, deltaTime, timeDirection, accuIndex) {
        // called by the mixer
        if (!this.enabled) {
            // call ._updateWeight() to update ._effectiveWeight
            this._updateWeight(time);
            return;
        }
        const startTime = this._startTime;
        if (startTime !== null) {
            // check for scheduled start of action
            const timeRunning = (time - startTime) * timeDirection;
            if (timeRunning < 0 || timeDirection === 0) return; // yet to come / don't decide when delta = 0
            // start
            this._startTime = null; // unschedule
            deltaTime = timeDirection * timeRunning;
        }
        // apply time scale and advance time
        deltaTime *= this._updateTimeScale(time);
        const clipTime = this._updateTime(deltaTime);
        // note: _updateTime may disable the action resulting in
        // an effective weight of 0
        const weight = this._updateWeight(time);
        if (weight > 0) {
            const interpolants = this._interpolants;
            const propertyMixers = this._propertyBindings;
            switch(this.blendMode){
                case AdditiveAnimationBlendMode:
                    for(let j4 = 0, m = interpolants.length; j4 !== m; ++j4){
                        interpolants[j4].evaluate(clipTime);
                        propertyMixers[j4].accumulateAdditive(weight);
                    }
                    break;
                case NormalAnimationBlendMode:
                default:
                    for(let j4 = 0, m = interpolants.length; j4 !== m; ++j4){
                        interpolants[j4].evaluate(clipTime);
                        propertyMixers[j4].accumulate(accuIndex, weight);
                    }
            }
        }
    }
    _updateWeight(time) {
        let weight = 0;
        if (this.enabled) {
            weight = this.weight;
            const interpolant = this._weightInterpolant;
            if (interpolant !== null) {
                const interpolantValue = interpolant.evaluate(time)[0];
                weight *= interpolantValue;
                if (time > interpolant.parameterPositions[1]) {
                    this.stopFading();
                    if (interpolantValue === 0) // faded out, disable
                    this.enabled = false;
                }
            }
        }
        this._effectiveWeight = weight;
        return weight;
    }
    _updateTimeScale(time) {
        let timeScale = 0;
        if (!this.paused) {
            timeScale = this.timeScale;
            const interpolant = this._timeScaleInterpolant;
            if (interpolant !== null) {
                const interpolantValue = interpolant.evaluate(time)[0];
                timeScale *= interpolantValue;
                if (time > interpolant.parameterPositions[1]) {
                    this.stopWarping();
                    if (timeScale === 0) // motion has halted, pause
                    this.paused = true;
                    else // warp done - apply final time scale
                    this.timeScale = timeScale;
                }
            }
        }
        this._effectiveTimeScale = timeScale;
        return timeScale;
    }
    _updateTime(deltaTime) {
        const duration = this._clip.duration;
        const loop = this.loop;
        let time = this.time + deltaTime;
        let loopCount = this._loopCount;
        const pingPong = loop === LoopPingPong;
        if (deltaTime === 0) {
            if (loopCount === -1) return time;
            return pingPong && (loopCount & 1) === 1 ? duration - time : time;
        }
        if (loop === LoopOnce) {
            if (loopCount === -1) {
                // just started
                this._loopCount = 0;
                this._setEndings(true, true, false);
            }
            handle_stop: {
                if (time >= duration) time = duration;
                else if (time < 0) time = 0;
                else {
                    this.time = time;
                    break handle_stop;
                }
                if (this.clampWhenFinished) this.paused = true;
                else this.enabled = false;
                this.time = time;
                this._mixer.dispatchEvent({
                    type: 'finished',
                    action: this,
                    direction: deltaTime < 0 ? -1 : 1
                });
            }
        } else {
            if (loopCount === -1) {
                // just started
                if (deltaTime >= 0) {
                    loopCount = 0;
                    this._setEndings(true, this.repetitions === 0, pingPong);
                } else // when looping in reverse direction, the initial
                // transition through zero counts as a repetition,
                // so leave loopCount at -1
                this._setEndings(this.repetitions === 0, true, pingPong);
            }
            if (time >= duration || time < 0) {
                // wrap around
                const loopDelta = Math.floor(time / duration); // signed
                time -= duration * loopDelta;
                loopCount += Math.abs(loopDelta);
                const pending = this.repetitions - loopCount;
                if (pending <= 0) {
                    // have to stop (switch state, clamp time, fire event)
                    if (this.clampWhenFinished) this.paused = true;
                    else this.enabled = false;
                    time = deltaTime > 0 ? duration : 0;
                    this.time = time;
                    this._mixer.dispatchEvent({
                        type: 'finished',
                        action: this,
                        direction: deltaTime > 0 ? 1 : -1
                    });
                } else {
                    // keep running
                    if (pending === 1) {
                        // entering the last round
                        const atStart = deltaTime < 0;
                        this._setEndings(atStart, !atStart, pingPong);
                    } else this._setEndings(false, false, pingPong);
                    this._loopCount = loopCount;
                    this.time = time;
                    this._mixer.dispatchEvent({
                        type: 'loop',
                        action: this,
                        loopDelta: loopDelta
                    });
                }
            } else this.time = time;
            if (pingPong && (loopCount & 1) === 1) // invert time for the "pong round"
            return duration - time;
        }
        return time;
    }
    _setEndings(atStart, atEnd, pingPong) {
        const settings = this._interpolantSettings;
        if (pingPong) {
            settings.endingStart = ZeroSlopeEnding;
            settings.endingEnd = ZeroSlopeEnding;
        } else {
            // assuming for LoopOnce atStart == atEnd == true
            if (atStart) settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
            else settings.endingStart = WrapAroundEnding;
            if (atEnd) settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
            else settings.endingEnd = WrapAroundEnding;
        }
    }
    _scheduleFading(duration, weightNow, weightThen) {
        const mixer = this._mixer, now = mixer.time;
        let interpolant = this._weightInterpolant;
        if (interpolant === null) {
            interpolant = mixer._lendControlInterpolant();
            this._weightInterpolant = interpolant;
        }
        const times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now;
        values[0] = weightNow;
        times[1] = now + duration;
        values[1] = weightThen;
        return this;
    }
    constructor(mixer, clip, localRoot, blendMode){
        this._mixer = mixer;
        this._clip = clip;
        this._localRoot = localRoot || null;
        this.blendMode = blendMode || clip.blendMode;
        const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
        const interpolantSettings = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        };
        for(let i7 = 0; i7 !== nTracks; ++i7){
            const interpolant = tracks[i7].createInterpolant(null);
            interpolants[i7] = interpolant;
            interpolant.settings = interpolantSettings;
        }
        this._interpolantSettings = interpolantSettings;
        this._interpolants = interpolants; // bound by the mixer
        // inside: PropertyMixer (managed by the mixer)
        this._propertyBindings = new Array(nTracks);
        this._cacheIndex = null; // for the memory manager
        this._byClipCacheIndex = null; // for the memory manager
        this._timeScaleInterpolant = null;
        this._weightInterpolant = null;
        this.loop = LoopRepeat;
        this._loopCount = -1;
        // global mixer time when the action is to be started
        // it's set back to 'null' upon start of the action
        this._startTime = null;
        // scaled local time of the action
        // gets clamped or wrapped to 0..clip.duration according to loop
        this.time = 0;
        this.timeScale = 1;
        this._effectiveTimeScale = 1;
        this.weight = 1;
        this._effectiveWeight = 1;
        this.repetitions = Infinity; // no. of repetitions when looping
        this.paused = false; // true -> zero effective time scale
        this.enabled = true; // false -> zero effective weight
        this.clampWhenFinished = false; // keep feeding the last frame?
        this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
        this.zeroSlopeAtEnd = true; // clips for start, loop and end
    }
}
const AnimationAction1 = AnimationAction;
function PropertyMixer2(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    switch(typeName){
        case 'quaternion':
            mixFunction = this._slerp;
            mixFunctionAdditive = this._slerpAdditive;
            setIdentity = this._setAdditiveIdentityQuaternion;
            this.buffer = new Float64Array(valueSize * 6);
            this._workIndex = 5;
            break;
        case 'string':
        case 'bool':
            mixFunction = this._select;
            mixFunctionAdditive = this._select;
            setIdentity = this._setAdditiveIdentityOther;
            this.buffer = new Array(valueSize * 5);
            break;
        default:
            mixFunction = this._lerp;
            mixFunctionAdditive = this._lerpAdditive;
            setIdentity = this._setAdditiveIdentityNumeric;
            this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
}
Object.assign(PropertyMixer2.prototype, {
    accumulate: function(accuIndex, weight) {
        const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
        let currentWeight = this.cumulativeWeight;
        if (currentWeight === 0) {
            for(let i8 = 0; i8 !== stride; ++i8)buffer[offset + i8] = buffer[i8];
            currentWeight = weight;
        } else {
            currentWeight += weight;
            const mix = weight / currentWeight;
            this._mixBufferRegion(buffer, offset, 0, mix, stride);
        }
        this.cumulativeWeight = currentWeight;
    },
    accumulateAdditive: function(weight) {
        const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
        if (this.cumulativeWeightAdditive === 0) this._setIdentity();
        this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
        this.cumulativeWeightAdditive += weight;
    },
    apply: function(accuIndex) {
        const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        if (weight < 1) {
            const originalValueOffset = stride * this._origIndex;
            this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
        }
        if (weightAdditive > 0) this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
        for(let i8 = stride, e = stride + stride; i8 !== e; ++i8)if (buffer[i8] !== buffer[i8 + stride]) {
            binding.setValue(buffer, offset);
            break;
        }
    },
    saveOriginalState: function() {
        const binding = this.binding;
        const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
        binding.getValue(buffer, originalValueOffset);
        for(let i8 = stride, e = originalValueOffset; i8 !== e; ++i8)buffer[i8] = buffer[originalValueOffset + i8 % stride];
        this._setIdentity();
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
    },
    restoreOriginalState: function() {
        const originalValueOffset = this.valueSize * 3;
        this.binding.setValue(this.buffer, originalValueOffset);
    },
    _setAdditiveIdentityNumeric: function() {
        const startIndex = this._addIndex * this.valueSize;
        const endIndex = startIndex + this.valueSize;
        for(let i8 = startIndex; i8 < endIndex; i8++)this.buffer[i8] = 0;
    },
    _setAdditiveIdentityQuaternion: function() {
        this._setAdditiveIdentityNumeric();
        this.buffer[this._addIndex * this.valueSize + 3] = 1;
    },
    _setAdditiveIdentityOther: function() {
        const startIndex = this._origIndex * this.valueSize;
        const targetIndex = this._addIndex * this.valueSize;
        for(let i8 = 0; i8 < this.valueSize; i8++)this.buffer[targetIndex + i8] = this.buffer[startIndex + i8];
    },
    _select: function(buffer, dstOffset, srcOffset, t2, stride) {
        if (t2 >= 0.5) for(let i8 = 0; i8 !== stride; ++i8)buffer[dstOffset + i8] = buffer[srcOffset + i8];
    },
    _slerp: function(buffer, dstOffset, srcOffset, t2) {
        Quaternion1.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t2);
    },
    _slerpAdditive: function(buffer, dstOffset, srcOffset, t2, stride) {
        const workOffset = this._workIndex * stride;
        Quaternion1.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
        Quaternion1.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t2);
    },
    _lerp: function(buffer, dstOffset, srcOffset, t2, stride) {
        const s1 = 1 - t2;
        for(let i8 = 0; i8 !== stride; ++i8){
            const j4 = dstOffset + i8;
            buffer[j4] = buffer[j4] * s1 + buffer[srcOffset + i8] * t2;
        }
    },
    _lerpAdditive: function(buffer, dstOffset, srcOffset, t2, stride) {
        for(let i8 = 0; i8 !== stride; ++i8){
            const j4 = dstOffset + i8;
            buffer[j4] = buffer[j4] + buffer[srcOffset + i8] * t2;
        }
    }
});
const PropertyMixer1 = PropertyMixer2;
function AnimationMixer(root) {
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
}
AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher1.prototype), {
    constructor: AnimationMixer,
    _bindAction: function(action, prototypeAction) {
        const root = action._localRoot || this._root, tracks1 = action._clip.tracks, nTracks1 = tracks1.length, bindings = action._propertyBindings, interpolants1 = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
        let bindingsByName = bindingsByRoot[rootUuid];
        if (bindingsByName === undefined) {
            bindingsByName = {
            };
            bindingsByRoot[rootUuid] = bindingsByName;
        }
        for(let i8 = 0; i8 !== nTracks1; ++i8){
            const track = tracks1[i8], trackName = track.name;
            let binding = bindingsByName[trackName];
            if (binding !== undefined) bindings[i8] = binding;
            else {
                binding = bindings[i8];
                if (binding !== undefined) {
                    // existing binding, make sure the cache knows
                    if (binding._cacheIndex === null) {
                        ++binding.referenceCount;
                        this._addInactiveBinding(binding, rootUuid, trackName);
                    }
                    continue;
                }
                const path1 = prototypeAction && prototypeAction._propertyBindings[i8].binding.parsedPath;
                binding = new PropertyMixer1(PropertyBinding1.create(root, trackName, path1), track.ValueTypeName, track.getValueSize());
                ++binding.referenceCount;
                this._addInactiveBinding(binding, rootUuid, trackName);
                bindings[i8] = binding;
            }
            interpolants1[i8].resultBuffer = binding.buffer;
        }
    },
    _activateAction: function(action) {
        if (!this._isActiveAction(action)) {
            if (action._cacheIndex === null) {
                // this action has been forgotten by the cache, but the user
                // appears to be still using it -> rebind
                const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
                this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
                this._addInactiveAction(action, clipUuid, rootUuid);
            }
            const bindings = action._propertyBindings;
            // increment reference counts / sort out state
            for(let i8 = 0, n = bindings.length; i8 !== n; ++i8){
                const binding = bindings[i8];
                if ((binding.useCount++) === 0) {
                    this._lendBinding(binding);
                    binding.saveOriginalState();
                }
            }
            this._lendAction(action);
        }
    },
    _deactivateAction: function(action) {
        if (this._isActiveAction(action)) {
            const bindings = action._propertyBindings;
            // decrement reference counts / sort out state
            for(let i8 = 0, n = bindings.length; i8 !== n; ++i8){
                const binding = bindings[i8];
                if ((--binding.useCount) === 0) {
                    binding.restoreOriginalState();
                    this._takeBackBinding(binding);
                }
            }
            this._takeBackAction(action);
        }
    },
    // Memory manager
    _initMemoryManager: function() {
        this._actions = []; // 'nActiveActions' followed by inactive ones
        this._nActiveActions = 0;
        this._actionsByClip = {
        };
        // inside:
        // {
        // 	knownActions: Array< AnimationAction > - used as prototypes
        // 	actionByRoot: AnimationAction - lookup
        // }
        this._bindings = []; // 'nActiveBindings' followed by inactive ones
        this._nActiveBindings = 0;
        this._bindingsByRootAndName = {
        }; // inside: Map< name, PropertyMixer >
        this._controlInterpolants = []; // same game as above
        this._nActiveControlInterpolants = 0;
        const scope3 = this;
        this.stats = {
            actions: {
                get total () {
                    return scope3._actions.length;
                },
                get inUse () {
                    return scope3._nActiveActions;
                }
            },
            bindings: {
                get total () {
                    return scope3._bindings.length;
                },
                get inUse () {
                    return scope3._nActiveBindings;
                }
            },
            controlInterpolants: {
                get total () {
                    return scope3._controlInterpolants.length;
                },
                get inUse () {
                    return scope3._nActiveControlInterpolants;
                }
            }
        };
    },
    // Memory management for AnimationAction objects
    _isActiveAction: function(action) {
        const index2 = action._cacheIndex;
        return index2 !== null && index2 < this._nActiveActions;
    },
    _addInactiveAction: function(action, clipUuid, rootUuid) {
        const actions = this._actions, actionsByClip = this._actionsByClip;
        let actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip === undefined) {
            actionsForClip = {
                knownActions: [
                    action
                ],
                actionByRoot: {
                }
            };
            action._byClipCacheIndex = 0;
            actionsByClip[clipUuid] = actionsForClip;
        } else {
            const knownActions = actionsForClip.knownActions;
            action._byClipCacheIndex = knownActions.length;
            knownActions.push(action);
        }
        action._cacheIndex = actions.length;
        actions.push(action);
        actionsForClip.actionByRoot[rootUuid] = action;
    },
    _removeInactiveAction: function(action) {
        const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        action._cacheIndex = null;
        const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
        lastKnownAction._byClipCacheIndex = byClipCacheIndex;
        knownActionsForClip[byClipCacheIndex] = lastKnownAction;
        knownActionsForClip.pop();
        action._byClipCacheIndex = null;
        const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
        delete actionByRoot[rootUuid];
        if (knownActionsForClip.length === 0) delete actionsByClip[clipUuid];
        this._removeInactiveBindingsForAction(action);
    },
    _removeInactiveBindingsForAction: function(action) {
        const bindings = action._propertyBindings;
        for(let i8 = 0, n = bindings.length; i8 !== n; ++i8){
            const binding = bindings[i8];
            if ((--binding.referenceCount) === 0) this._removeInactiveBinding(binding);
        }
    },
    _lendAction: function(action) {
        // [ active actions |  inactive actions  ]
        // [  active actions >| inactive actions ]
        //                 s        a
        //                  <-swap->
        //                 a        s
        const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
        action._cacheIndex = lastActiveIndex;
        actions[lastActiveIndex] = action;
        firstInactiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = firstInactiveAction;
    },
    _takeBackAction: function(action) {
        // [  active actions  | inactive actions ]
        // [ active actions |< inactive actions  ]
        //        a        s
        //         <-swap->
        //        s        a
        const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
        action._cacheIndex = firstInactiveIndex;
        actions[firstInactiveIndex] = action;
        lastActiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = lastActiveAction;
    },
    // Memory management for PropertyMixer objects
    _addInactiveBinding: function(binding, rootUuid, trackName) {
        const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
        let bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName === undefined) {
            bindingByName = {
            };
            bindingsByRoot[rootUuid] = bindingByName;
        }
        bindingByName[trackName] = binding;
        binding._cacheIndex = bindings.length;
        bindings.push(binding);
    },
    _removeInactiveBinding: function(binding) {
        const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
        lastInactiveBinding._cacheIndex = cacheIndex;
        bindings[cacheIndex] = lastInactiveBinding;
        bindings.pop();
        delete bindingByName[trackName];
        if (Object.keys(bindingByName).length === 0) delete bindingsByRoot[rootUuid];
    },
    _lendBinding: function(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
        binding._cacheIndex = lastActiveIndex;
        bindings[lastActiveIndex] = binding;
        firstInactiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = firstInactiveBinding;
    },
    _takeBackBinding: function(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
        binding._cacheIndex = firstInactiveIndex;
        bindings[firstInactiveIndex] = binding;
        lastActiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = lastActiveBinding;
    },
    // Memory management of Interpolants for weight and time scale
    _lendControlInterpolant: function() {
        const interpolants1 = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
        let interpolant = interpolants1[lastActiveIndex];
        if (interpolant === undefined) {
            interpolant = new LinearInterpolant1(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
            interpolant.__cacheIndex = lastActiveIndex;
            interpolants1[lastActiveIndex] = interpolant;
        }
        return interpolant;
    },
    _takeBackControlInterpolant: function(interpolant) {
        const interpolants1 = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants1[firstInactiveIndex];
        interpolant.__cacheIndex = firstInactiveIndex;
        interpolants1[firstInactiveIndex] = interpolant;
        lastActiveInterpolant.__cacheIndex = prevIndex;
        interpolants1[prevIndex] = lastActiveInterpolant;
    },
    _controlInterpolantsResultBuffer: new Float32Array(1),
    // return an action for a clip optionally using a custom root target
    // object (this method allocates a lot of dynamic memory in case a
    // previously unknown clip/root combination is specified)
    clipAction: function(clip1, optionalRoot, blendMode1) {
        const root = optionalRoot || this._root, rootUuid = root.uuid;
        let clipObject = typeof clip1 === 'string' ? AnimationClip1.findByName(root, clip1) : clip1;
        const clipUuid = clipObject !== null ? clipObject.uuid : clip1;
        const actionsForClip = this._actionsByClip[clipUuid];
        let prototypeAction = null;
        if (blendMode1 === undefined) {
            if (clipObject !== null) blendMode1 = clipObject.blendMode;
            else blendMode1 = NormalAnimationBlendMode;
        }
        if (actionsForClip !== undefined) {
            const existingAction = actionsForClip.actionByRoot[rootUuid];
            if (existingAction !== undefined && existingAction.blendMode === blendMode1) return existingAction;
            // we know the clip, so we don't have to parse all
            // the bindings again but can just copy
            prototypeAction = actionsForClip.knownActions[0];
            // also, take the clip from the prototype action
            if (clipObject === null) clipObject = prototypeAction._clip;
        }
        // clip must be known when specified via string
        if (clipObject === null) return null;
        // allocate all resources required to run it
        const newAction = new AnimationAction1(this, clipObject, optionalRoot, blendMode1);
        this._bindAction(newAction, prototypeAction);
        // and make the action known to the memory manager
        this._addInactiveAction(newAction, clipUuid, rootUuid);
        return newAction;
    },
    // get an existing action
    existingAction: function(clip1, optionalRoot) {
        const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip1 === 'string' ? AnimationClip1.findByName(root, clip1) : clip1, clipUuid = clipObject ? clipObject.uuid : clip1, actionsForClip = this._actionsByClip[clipUuid];
        if (actionsForClip !== undefined) return actionsForClip.actionByRoot[rootUuid] || null;
        return null;
    },
    // deactivates all previously scheduled actions
    stopAllAction: function() {
        const actions = this._actions, nActions = this._nActiveActions;
        for(let i8 = nActions - 1; i8 >= 0; --i8)actions[i8].stop();
        return this;
    },
    // advance the time and update apply the animation
    update: function(deltaTime) {
        deltaTime *= this.timeScale;
        const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
        // run active actions
        for(let i8 = 0; i8 !== nActions; ++i8){
            const action = actions[i8];
            action._update(time, deltaTime, timeDirection, accuIndex);
        }
        // update scene graph
        const bindings = this._bindings, nBindings = this._nActiveBindings;
        for(let i8 = 0; i8 !== nBindings; ++i8)bindings[i8].apply(accuIndex);
        return this;
    },
    // Allows you to seek to a specific time in an animation.
    setTime: function(timeInSeconds) {
        this.time = 0; // Zero out time attribute for AnimationMixer object;
        for(let i8 = 0; i8 < this._actions.length; i8++)this._actions[i8].time = 0; // Zero out time attribute for all associated AnimationAction objects.
        return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
    },
    // return this mixer's root target object
    getRoot: function() {
        return this._root;
    },
    // free all resources specific to a particular clip
    uncacheClip: function(clip1) {
        const actions = this._actions, clipUuid = clip1.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip !== undefined) {
            // note: just calling _removeInactiveAction would mess up the
            // iteration state and also require updating the state we can
            // just throw away
            const actionsToRemove = actionsForClip.knownActions;
            for(let i8 = 0, n = actionsToRemove.length; i8 !== n; ++i8){
                const action = actionsToRemove[i8];
                this._deactivateAction(action);
                const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
                action._cacheIndex = null;
                action._byClipCacheIndex = null;
                lastInactiveAction._cacheIndex = cacheIndex;
                actions[cacheIndex] = lastInactiveAction;
                actions.pop();
                this._removeInactiveBindingsForAction(action);
            }
            delete actionsByClip[clipUuid];
        }
    },
    // free all resources specific to a particular root target object
    uncacheRoot: function(root) {
        const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
        for(const clipUuid in actionsByClip){
            const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
            if (action !== undefined) {
                this._deactivateAction(action);
                this._removeInactiveAction(action);
            }
        }
        const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName !== undefined) for(const trackName in bindingByName){
            const binding = bindingByName[trackName];
            binding.restoreOriginalState();
            this._removeInactiveBinding(binding);
        }
    },
    // remove a targeted clip from the cache
    uncacheAction: function(clip1, optionalRoot) {
        const action = this.existingAction(clip1, optionalRoot);
        if (action !== null) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
        }
    }
});
const AnimationMixer1 = AnimationMixer;
export { AnimationMixer1 as AnimationMixer };
function BooleanKeyframeTrack3(name, times, values) {
    KeyframeTrack1.call(this, name, times, values);
}
BooleanKeyframeTrack3.prototype = Object.assign(Object.create(KeyframeTrack1.prototype), {
    constructor: BooleanKeyframeTrack3,
    ValueTypeName: 'bool',
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: undefined,
    InterpolantFactoryMethodSmooth: undefined
});
const BooleanKeyframeTrack1 = BooleanKeyframeTrack3;
function ColorKeyframeTrack3(name, times, values, interpolation) {
    KeyframeTrack1.call(this, name, times, values, interpolation);
}
ColorKeyframeTrack3.prototype = Object.assign(Object.create(KeyframeTrack1.prototype), {
    constructor: ColorKeyframeTrack3,
    ValueTypeName: 'color'
});
const ColorKeyframeTrack1 = ColorKeyframeTrack3;
function NumberKeyframeTrack3(name, times, values, interpolation) {
    KeyframeTrack1.call(this, name, times, values, interpolation);
}
NumberKeyframeTrack3.prototype = Object.assign(Object.create(KeyframeTrack1.prototype), {
    constructor: NumberKeyframeTrack3,
    ValueTypeName: 'number'
});
const NumberKeyframeTrack1 = NumberKeyframeTrack3;
function QuaternionLinearInterpolant3(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant1.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
QuaternionLinearInterpolant3.prototype = Object.assign(Object.create(Interpolant1.prototype), {
    constructor: QuaternionLinearInterpolant3,
    interpolate_: function(i12, t0, t2, t11) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t2 - t0) / (t11 - t0);
        let offset = i12 * stride;
        for(let end = offset + stride; offset !== end; offset += 4)Quaternion1.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
        return result;
    }
});
const QuaternionLinearInterpolant1 = QuaternionLinearInterpolant3;
function QuaternionKeyframeTrack3(name, times, values, interpolation) {
    KeyframeTrack1.call(this, name, times, values, interpolation);
}
QuaternionKeyframeTrack3.prototype = Object.assign(Object.create(KeyframeTrack1.prototype), {
    constructor: QuaternionKeyframeTrack3,
    ValueTypeName: 'quaternion',
    DefaultInterpolation: InterpolateLinear,
    InterpolantFactoryMethodLinear: function(result) {
        return new QuaternionLinearInterpolant1(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodSmooth: undefined
});
const QuaternionKeyframeTrack1 = QuaternionKeyframeTrack3;
function StringKeyframeTrack3(name, times, values, interpolation) {
    KeyframeTrack1.call(this, name, times, values, interpolation);
}
StringKeyframeTrack3.prototype = Object.assign(Object.create(KeyframeTrack1.prototype), {
    constructor: StringKeyframeTrack3,
    ValueTypeName: 'string',
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: undefined,
    InterpolantFactoryMethodSmooth: undefined
});
const StringKeyframeTrack1 = StringKeyframeTrack3;
function VectorKeyframeTrack3(name, times, values, interpolation) {
    KeyframeTrack1.call(this, name, times, values, interpolation);
}
VectorKeyframeTrack3.prototype = Object.assign(Object.create(KeyframeTrack1.prototype), {
    constructor: VectorKeyframeTrack3,
    ValueTypeName: 'vector'
});
const VectorKeyframeTrack1 = VectorKeyframeTrack3;
function AnimationClip2(name, duration, tracks1, blendMode1) {
    this.name = name;
    this.tracks = tracks1;
    this.duration = duration !== undefined ? duration : -1;
    this.blendMode = blendMode1 !== undefined ? blendMode1 : NormalAnimationBlendMode;
    this.uuid = MathUtils1.generateUUID();
    if (this.duration < 0) this.resetDuration();
}
function getTrackTypeForValueTypeName(typeName) {
    switch(typeName.toLowerCase()){
        case 'scalar':
        case 'double':
        case 'float':
        case 'number':
        case 'integer':
            return NumberKeyframeTrack1;
        case 'vector':
        case 'vector2':
        case 'vector3':
        case 'vector4':
            return VectorKeyframeTrack1;
        case 'color':
            return ColorKeyframeTrack1;
        case 'quaternion':
            return QuaternionKeyframeTrack1;
        case 'bool':
        case 'boolean':
            return BooleanKeyframeTrack1;
        case 'string':
            return StringKeyframeTrack1;
    }
    throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
}
function parseKeyframeTrack(json) {
    if (json.type === undefined) throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
    const trackType = getTrackTypeForValueTypeName(json.type);
    if (json.times === undefined) {
        const times = [], values = [];
        AnimationUtils1.flattenJSON(json.keys, times, values, 'value');
        json.times = times;
        json.values = values;
    }
    if (trackType.parse !== undefined) return trackType.parse(json);
    else return new trackType(json.name, json.times, json.values, json.interpolation);
}
Object.assign(AnimationClip2, {
    parse: function(json) {
        const tracks1 = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
        for(let i8 = 0, n = jsonTracks.length; i8 !== n; ++i8)tracks1.push(parseKeyframeTrack(jsonTracks[i8]).scale(frameTime));
        return new AnimationClip2(json.name, json.duration, tracks1, json.blendMode);
    },
    toJSON: function(clip1) {
        const tracks1 = [], clipTracks = clip1.tracks;
        const json = {
            'name': clip1.name,
            'duration': clip1.duration,
            'tracks': tracks1,
            'uuid': clip1.uuid,
            'blendMode': clip1.blendMode
        };
        for(let i8 = 0, n = clipTracks.length; i8 !== n; ++i8)tracks1.push(KeyframeTrack1.toJSON(clipTracks[i8]));
        return json;
    },
    CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {
        const numMorphTargets = morphTargetSequence.length;
        const tracks1 = [];
        for(let i8 = 0; i8 < numMorphTargets; i8++){
            let times = [];
            let values = [];
            times.push((i8 + numMorphTargets - 1) % numMorphTargets, i8, (i8 + 1) % numMorphTargets);
            values.push(0, 1, 0);
            const order1 = AnimationUtils1.getKeyframeOrder(times);
            times = AnimationUtils1.sortedArray(times, 1, order1);
            values = AnimationUtils1.sortedArray(values, 1, order1);
            if (!noLoop && times[0] === 0) {
                times.push(numMorphTargets);
                values.push(values[0]);
            }
            tracks1.push(new NumberKeyframeTrack1('.morphTargetInfluences[' + morphTargetSequence[i8].name + ']', times, values).scale(1 / fps));
        }
        return new AnimationClip2(name, -1, tracks1);
    },
    findByName: function(objectOrClipArray, name) {
        let clipArray = objectOrClipArray;
        if (!Array.isArray(objectOrClipArray)) {
            const o = objectOrClipArray;
            clipArray = o.geometry && o.geometry.animations || o.animations;
        }
        for(let i8 = 0; i8 < clipArray.length; i8++)if (clipArray[i8].name === name) return clipArray[i8];
        return null;
    },
    CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {
        const animationToMorphTargets = {
        };
        const pattern = /^([\w-]*?)([\d]+)$/;
        for(let i8 = 0, il = morphTargets.length; i8 < il; i8++){
            const morphTarget = morphTargets[i8];
            const parts = morphTarget.name.match(pattern);
            if (parts && parts.length > 1) {
                const name = parts[1];
                let animationMorphTargets = animationToMorphTargets[name];
                if (!animationMorphTargets) animationToMorphTargets[name] = animationMorphTargets = [];
                animationMorphTargets.push(morphTarget);
            }
        }
        const clips = [];
        for(const name in animationToMorphTargets)clips.push(AnimationClip2.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
        return clips;
    },
    parseAnimation: function(animation, bones) {
        if (!animation) {
            console.error('THREE.AnimationClip: No animation in JSONLoader data.');
            return null;
        }
        const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
            if (animationKeys.length !== 0) {
                const times = [];
                const values = [];
                AnimationUtils1.flattenJSON(animationKeys, times, values, propertyName);
                if (times.length !== 0) destTracks.push(new trackType(trackName, times, values));
            }
        };
        const tracks1 = [];
        const clipName = animation.name || 'default';
        const fps = animation.fps || 30;
        const blendMode1 = animation.blendMode;
        let duration = animation.length || -1;
        const hierarchyTracks = animation.hierarchy || [];
        for(let h = 0; h < hierarchyTracks.length; h++){
            const animationKeys = hierarchyTracks[h].keys;
            if (!animationKeys || animationKeys.length === 0) continue;
            if (animationKeys[0].morphTargets) {
                const morphTargetNames = {
                };
                let k;
                for(k = 0; k < animationKeys.length; k++)if (animationKeys[k].morphTargets) for(let m = 0; m < animationKeys[k].morphTargets.length; m++)morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                for(const morphTargetName in morphTargetNames){
                    const times = [];
                    const values = [];
                    for(let m1 = 0; m1 !== animationKeys[k].morphTargets.length; ++m1){
                        const animationKey = animationKeys[k];
                        times.push(animationKey.time);
                        values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
                    }
                    tracks1.push(new NumberKeyframeTrack1('.morphTargetInfluence[' + morphTargetName + ']', times, values));
                }
                duration = morphTargetNames.length * (fps || 1);
            } else {
                const boneName = '.bones[' + bones[h].name + ']';
                addNonemptyTrack(VectorKeyframeTrack1, boneName + '.position', animationKeys, 'pos', tracks1);
                addNonemptyTrack(QuaternionKeyframeTrack1, boneName + '.quaternion', animationKeys, 'rot', tracks1);
                addNonemptyTrack(VectorKeyframeTrack1, boneName + '.scale', animationKeys, 'scl', tracks1);
            }
        }
        if (tracks1.length === 0) return null;
        const clip1 = new AnimationClip2(clipName, duration, tracks1, blendMode1);
        return clip1;
    }
});
Object.assign(AnimationClip2.prototype, {
    resetDuration: function() {
        const tracks1 = this.tracks;
        let duration = 0;
        for(let i8 = 0, n = tracks1.length; i8 !== n; ++i8){
            const track = this.tracks[i8];
            duration = Math.max(duration, track.times[track.times.length - 1]);
        }
        this.duration = duration;
        return this;
    },
    trim: function() {
        for(let i8 = 0; i8 < this.tracks.length; i8++)this.tracks[i8].trim(0, this.duration);
        return this;
    },
    validate: function() {
        let valid = true;
        for(let i8 = 0; i8 < this.tracks.length; i8++)valid = valid && this.tracks[i8].validate();
        return valid;
    },
    optimize: function() {
        for(let i8 = 0; i8 < this.tracks.length; i8++)this.tracks[i8].optimize();
        return this;
    },
    clone: function() {
        const tracks1 = [];
        for(let i8 = 0; i8 < this.tracks.length; i8++)tracks1.push(this.tracks[i8].clone());
        return new AnimationClip2(this.name, this.duration, tracks1, this.blendMode);
    }
});
const AnimationClip1 = AnimationClip2;
export { AnimationClip1 as AnimationClip };
class Uniform {
    clone() {
        return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
    }
    constructor(value1){
        if (typeof value1 === 'string') {
            console.warn('THREE.Uniform: Type parameter is no longer needed.');
            value1 = arguments[1];
        }
        this.value = value1;
    }
}
const Uniform1 = Uniform;
export { Uniform1 as Uniform };
function InstancedBufferGeometry3() {
    BufferGeometry1.call(this);
    this.type = 'InstancedBufferGeometry';
    this.instanceCount = Infinity;
}
InstancedBufferGeometry3.prototype = Object.assign(Object.create(BufferGeometry1.prototype), {
    constructor: InstancedBufferGeometry3,
    isInstancedBufferGeometry: true,
    copy: function(source) {
        BufferGeometry1.prototype.copy.call(this, source);
        this.instanceCount = source.instanceCount;
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    toJSON: function() {
        const data = BufferGeometry1.prototype.toJSON.call(this);
        data.instanceCount = this.instanceCount;
        data.isInstancedBufferGeometry = true;
        return data;
    }
});
const InstancedBufferGeometry1 = InstancedBufferGeometry3;
export { InstancedBufferGeometry1 as InstancedBufferGeometry };
class DirectGeometry2 {
    computeGroups(geometry) {
        const groups = [];
        let group, i8;
        let materialIndex1 = undefined;
        const faces = geometry.faces;
        for(i8 = 0; i8 < faces.length; i8++){
            const face = faces[i8];
            if (face.materialIndex !== materialIndex1) {
                materialIndex1 = face.materialIndex;
                if (group !== undefined) {
                    group.count = i8 * 3 - group.start;
                    groups.push(group);
                }
                group = {
                    start: i8 * 3,
                    materialIndex: materialIndex1
                };
            }
        }
        if (group !== undefined) {
            group.count = i8 * 3 - group.start;
            groups.push(group);
        }
        this.groups = groups;
    }
    fromGeometry(geometry) {
        const faces = geometry.faces;
        const vertices17 = geometry.vertices;
        const faceVertexUvs = geometry.faceVertexUvs;
        const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
        const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
        const morphTargets = geometry.morphTargets;
        const morphTargetsLength = morphTargets.length;
        let morphTargetsPosition;
        if (morphTargetsLength > 0) {
            morphTargetsPosition = [];
            for(let i8 = 0; i8 < morphTargetsLength; i8++)morphTargetsPosition[i8] = {
                name: morphTargets[i8].name,
                data: []
            };
            this.morphTargets.position = morphTargetsPosition;
        }
        const morphNormals = geometry.morphNormals;
        const morphNormalsLength = morphNormals.length;
        let morphTargetsNormal;
        if (morphNormalsLength > 0) {
            morphTargetsNormal = [];
            for(let i8 = 0; i8 < morphNormalsLength; i8++)morphTargetsNormal[i8] = {
                name: morphNormals[i8].name,
                data: []
            };
            this.morphTargets.normal = morphTargetsNormal;
        }
        const skinIndices = geometry.skinIndices;
        const skinWeights = geometry.skinWeights;
        const hasSkinIndices = skinIndices.length === vertices17.length;
        const hasSkinWeights = skinWeights.length === vertices17.length;
        if (vertices17.length > 0 && faces.length === 0) console.error('THREE.DirectGeometry: Faceless geometries are not supported.');
        for(let i8 = 0; i8 < faces.length; i8++){
            const face = faces[i8];
            this.vertices.push(vertices17[face.a], vertices17[face.b], vertices17[face.c]);
            const vertexNormals = face.vertexNormals;
            if (vertexNormals.length === 3) this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
            else {
                const normal6 = face.normal;
                this.normals.push(normal6, normal6, normal6);
            }
            const vertexColors = face.vertexColors;
            if (vertexColors.length === 3) this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
            else {
                const color1 = face.color;
                this.colors.push(color1, color1, color1);
            }
            if (hasFaceVertexUv === true) {
                const vertexUvs = faceVertexUvs[0][i8];
                if (vertexUvs !== undefined) this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                else {
                    console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i8);
                    this.uvs.push(new Vector21(), new Vector21(), new Vector21());
                }
            }
            if (hasFaceVertexUv2 === true) {
                const vertexUvs = faceVertexUvs[1][i8];
                if (vertexUvs !== undefined) this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
                else {
                    console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i8);
                    this.uvs2.push(new Vector21(), new Vector21(), new Vector21());
                }
            }
            for(let j4 = 0; j4 < morphTargetsLength; j4++){
                const morphTarget = morphTargets[j4].vertices;
                morphTargetsPosition[j4].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
            }
            for(let j4 = 0; j4 < morphNormalsLength; j4++){
                const morphNormal = morphNormals[j4].vertexNormals[i8];
                morphTargetsNormal[j4].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
            }
            if (hasSkinIndices) this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
            if (hasSkinWeights) this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
        }
        this.computeGroups(geometry);
        this.verticesNeedUpdate = geometry.verticesNeedUpdate;
        this.normalsNeedUpdate = geometry.normalsNeedUpdate;
        this.colorsNeedUpdate = geometry.colorsNeedUpdate;
        this.uvsNeedUpdate = geometry.uvsNeedUpdate;
        this.groupsNeedUpdate = geometry.groupsNeedUpdate;
        if (geometry.boundingSphere !== null) this.boundingSphere = geometry.boundingSphere.clone();
        if (geometry.boundingBox !== null) this.boundingBox = geometry.boundingBox.clone();
        return this;
    }
    constructor(){
        this.vertices = [];
        this.normals = [];
        this.colors = [];
        this.uvs = [];
        this.uvs2 = [];
        this.groups = [];
        this.morphTargets = {
        };
        this.skinWeights = [];
        this.skinIndices = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.verticesNeedUpdate = false;
        this.normalsNeedUpdate = false;
        this.colorsNeedUpdate = false;
        this.uvsNeedUpdate = false;
        this.groupsNeedUpdate = false;
    }
}
const DirectGeometry1 = DirectGeometry2;
function arrayMax2(array) {
    if (array.length === 0) return -Infinity;
    let max = array[0];
    for(let i8 = 1, l1 = array.length; i8 < l1; ++i8)if (array[i8] > max) max = array[i8];
    return max;
}
const arrayMax1 = arrayMax2;
let _bufferGeometryId = 1;
const _m12 = new Matrix41();
const _obj = new Object3D1();
const _offset = new Vector31();
const _box2 = new Box31();
const _boxMorphTargets = new Box31();
const _vector6 = new Vector31();
function BufferGeometry2() {
    Object.defineProperty(this, 'id', {
        value: _bufferGeometryId += 2
    });
    this.uuid = MathUtils1.generateUUID();
    this.name = '';
    this.type = 'BufferGeometry';
    this.index = null;
    this.attributes = {
    };
    this.morphAttributes = {
    };
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = {
        start: 0,
        count: Infinity
    };
    this.userData = {
    };
}
BufferGeometry2.prototype = Object.assign(Object.create(EventDispatcher1.prototype), {
    constructor: BufferGeometry2,
    isBufferGeometry: true,
    getIndex: function() {
        return this.index;
    },
    setIndex: function(index2) {
        if (Array.isArray(index2)) this.index = new (arrayMax1(index2) > 65535 ? Uint32BufferAttribute1 : Uint16BufferAttribute1)(index2, 1);
        else this.index = index2;
    },
    getAttribute: function(name) {
        return this.attributes[name];
    },
    setAttribute: function(name, attribute) {
        this.attributes[name] = attribute;
        return this;
    },
    deleteAttribute: function(name) {
        delete this.attributes[name];
        return this;
    },
    addGroup: function(start, count, materialIndex1) {
        this.groups.push({
            start: start,
            count: count,
            materialIndex: materialIndex1 !== undefined ? materialIndex1 : 0
        });
    },
    clearGroups: function() {
        this.groups = [];
    },
    setDrawRange: function(start, count) {
        this.drawRange.start = start;
        this.drawRange.count = count;
    },
    applyMatrix4: function(matrix) {
        const position = this.attributes.position;
        if (position !== undefined) {
            position.applyMatrix4(matrix);
            position.needsUpdate = true;
        }
        const normal6 = this.attributes.normal;
        if (normal6 !== undefined) {
            const normalMatrix = new Matrix31().getNormalMatrix(matrix);
            normal6.applyNormalMatrix(normalMatrix);
            normal6.needsUpdate = true;
        }
        const tangent = this.attributes.tangent;
        if (tangent !== undefined) {
            tangent.transformDirection(matrix);
            tangent.needsUpdate = true;
        }
        if (this.boundingBox !== null) this.computeBoundingBox();
        if (this.boundingSphere !== null) this.computeBoundingSphere();
        return this;
    },
    rotateX: function(angle) {
        _m12.makeRotationX(angle);
        this.applyMatrix4(_m12);
        return this;
    },
    rotateY: function(angle) {
        _m12.makeRotationY(angle);
        this.applyMatrix4(_m12);
        return this;
    },
    rotateZ: function(angle) {
        _m12.makeRotationZ(angle);
        this.applyMatrix4(_m12);
        return this;
    },
    translate: function(x6, y6, z5) {
        _m12.makeTranslation(x6, y6, z5);
        this.applyMatrix4(_m12);
        return this;
    },
    scale: function(x6, y6, z5) {
        _m12.makeScale(x6, y6, z5);
        this.applyMatrix4(_m12);
        return this;
    },
    lookAt: function(vector) {
        _obj.lookAt(vector);
        _obj.updateMatrix();
        this.applyMatrix4(_obj.matrix);
        return this;
    },
    center: function() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(_offset).negate();
        this.translate(_offset.x, _offset.y, _offset.z);
        return this;
    },
    setFromObject: function(object) {
        const geometry = object.geometry;
        if (object.isPoints || object.isLine) {
            const positions = new Float32BufferAttribute1(geometry.vertices.length * 3, 3);
            const colors = new Float32BufferAttribute1(geometry.colors.length * 3, 3);
            this.setAttribute('position', positions.copyVector3sArray(geometry.vertices));
            this.setAttribute('color', colors.copyColorsArray(geometry.colors));
            if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
                const lineDistances = new Float32BufferAttribute1(geometry.lineDistances.length, 1);
                this.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));
            }
            if (geometry.boundingSphere !== null) this.boundingSphere = geometry.boundingSphere.clone();
            if (geometry.boundingBox !== null) this.boundingBox = geometry.boundingBox.clone();
        } else if (object.isMesh) {
            if (geometry && geometry.isGeometry) this.fromGeometry(geometry);
        }
        return this;
    },
    setFromPoints: function(points1) {
        const position = [];
        for(let i8 = 0, l1 = points1.length; i8 < l1; i8++){
            const point = points1[i8];
            position.push(point.x, point.y, point.z || 0);
        }
        this.setAttribute('position', new Float32BufferAttribute1(position, 3));
        return this;
    },
    updateFromObject: function(object) {
        let geometry = object.geometry;
        if (object.isMesh) {
            let direct = geometry.__directGeometry;
            if (geometry.elementsNeedUpdate === true) {
                direct = undefined;
                geometry.elementsNeedUpdate = false;
            }
            if (direct === undefined) return this.fromGeometry(geometry);
            direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
            direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
            direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
            direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
            direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
            geometry.verticesNeedUpdate = false;
            geometry.normalsNeedUpdate = false;
            geometry.colorsNeedUpdate = false;
            geometry.uvsNeedUpdate = false;
            geometry.groupsNeedUpdate = false;
            geometry = direct;
        }
        if (geometry.verticesNeedUpdate === true) {
            const attribute = this.attributes.position;
            if (attribute !== undefined) {
                attribute.copyVector3sArray(geometry.vertices);
                attribute.needsUpdate = true;
            }
            geometry.verticesNeedUpdate = false;
        }
        if (geometry.normalsNeedUpdate === true) {
            const attribute = this.attributes.normal;
            if (attribute !== undefined) {
                attribute.copyVector3sArray(geometry.normals);
                attribute.needsUpdate = true;
            }
            geometry.normalsNeedUpdate = false;
        }
        if (geometry.colorsNeedUpdate === true) {
            const attribute = this.attributes.color;
            if (attribute !== undefined) {
                attribute.copyColorsArray(geometry.colors);
                attribute.needsUpdate = true;
            }
            geometry.colorsNeedUpdate = false;
        }
        if (geometry.uvsNeedUpdate) {
            const attribute = this.attributes.uv;
            if (attribute !== undefined) {
                attribute.copyVector2sArray(geometry.uvs);
                attribute.needsUpdate = true;
            }
            geometry.uvsNeedUpdate = false;
        }
        if (geometry.lineDistancesNeedUpdate) {
            const attribute = this.attributes.lineDistance;
            if (attribute !== undefined) {
                attribute.copyArray(geometry.lineDistances);
                attribute.needsUpdate = true;
            }
            geometry.lineDistancesNeedUpdate = false;
        }
        if (geometry.groupsNeedUpdate) {
            geometry.computeGroups(object.geometry);
            this.groups = geometry.groups;
            geometry.groupsNeedUpdate = false;
        }
        return this;
    },
    fromGeometry: function(geometry) {
        geometry.__directGeometry = new DirectGeometry1().fromGeometry(geometry);
        return this.fromDirectGeometry(geometry.__directGeometry);
    },
    fromDirectGeometry: function(geometry) {
        const positions = new Float32Array(geometry.vertices.length * 3);
        this.setAttribute('position', new BufferAttribute1(positions, 3).copyVector3sArray(geometry.vertices));
        if (geometry.normals.length > 0) {
            const normals10 = new Float32Array(geometry.normals.length * 3);
            this.setAttribute('normal', new BufferAttribute1(normals10, 3).copyVector3sArray(geometry.normals));
        }
        if (geometry.colors.length > 0) {
            const colors = new Float32Array(geometry.colors.length * 3);
            this.setAttribute('color', new BufferAttribute1(colors, 3).copyColorsArray(geometry.colors));
        }
        if (geometry.uvs.length > 0) {
            const uvs12 = new Float32Array(geometry.uvs.length * 2);
            this.setAttribute('uv', new BufferAttribute1(uvs12, 2).copyVector2sArray(geometry.uvs));
        }
        if (geometry.uvs2.length > 0) {
            const uvs21 = new Float32Array(geometry.uvs2.length * 2);
            this.setAttribute('uv2', new BufferAttribute1(uvs21, 2).copyVector2sArray(geometry.uvs2));
        }
        this.groups = geometry.groups;
        for(const name in geometry.morphTargets){
            const array = [];
            const morphTargets = geometry.morphTargets[name];
            for(let i8 = 0, l1 = morphTargets.length; i8 < l1; i8++){
                const morphTarget = morphTargets[i8];
                const attribute = new Float32BufferAttribute1(morphTarget.data.length * 3, 3);
                attribute.name = morphTarget.name;
                array.push(attribute.copyVector3sArray(morphTarget.data));
            }
            this.morphAttributes[name] = array;
        }
        if (geometry.skinIndices.length > 0) {
            const skinIndices = new Float32BufferAttribute1(geometry.skinIndices.length * 4, 4);
            this.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));
        }
        if (geometry.skinWeights.length > 0) {
            const skinWeights = new Float32BufferAttribute1(geometry.skinWeights.length * 4, 4);
            this.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));
        }
        if (geometry.boundingSphere !== null) this.boundingSphere = geometry.boundingSphere.clone();
        if (geometry.boundingBox !== null) this.boundingBox = geometry.boundingBox.clone();
        return this;
    },
    computeBoundingBox: function() {
        if (this.boundingBox === null) this.boundingBox = new Box31();
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position !== undefined) {
            this.boundingBox.setFromBufferAttribute(position);
            if (morphAttributesPosition) for(let i8 = 0, il = morphAttributesPosition.length; i8 < il; i8++){
                const morphAttribute = morphAttributesPosition[i8];
                _box2.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                    _vector6.addVectors(this.boundingBox.min, _box2.min);
                    this.boundingBox.expandByPoint(_vector6);
                    _vector6.addVectors(this.boundingBox.max, _box2.max);
                    this.boundingBox.expandByPoint(_vector6);
                } else {
                    this.boundingBox.expandByPoint(_box2.min);
                    this.boundingBox.expandByPoint(_box2.max);
                }
            }
        } else this.boundingBox.makeEmpty();
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    },
    computeBoundingSphere: function() {
        if (this.boundingSphere === null) this.boundingSphere = new Sphere1();
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position) {
            const center1 = this.boundingSphere.center;
            _box2.setFromBufferAttribute(position);
            if (morphAttributesPosition) for(let i8 = 0, il = morphAttributesPosition.length; i8 < il; i8++){
                const morphAttribute = morphAttributesPosition[i8];
                _boxMorphTargets.setFromBufferAttribute(morphAttribute);
                if (this.morphTargetsRelative) {
                    _vector6.addVectors(_box2.min, _boxMorphTargets.min);
                    _box2.expandByPoint(_vector6);
                    _vector6.addVectors(_box2.max, _boxMorphTargets.max);
                    _box2.expandByPoint(_vector6);
                } else {
                    _box2.expandByPoint(_boxMorphTargets.min);
                    _box2.expandByPoint(_boxMorphTargets.max);
                }
            }
            _box2.getCenter(center1);
            let maxRadiusSq = 0;
            for(let i8 = 0, il = position.count; i8 < il; i8++){
                _vector6.fromBufferAttribute(position, i8);
                maxRadiusSq = Math.max(maxRadiusSq, center1.distanceToSquared(_vector6));
            }
            if (morphAttributesPosition) for(let i8 = 0, il = morphAttributesPosition.length; i8 < il; i8++){
                const morphAttribute = morphAttributesPosition[i8];
                const morphTargetsRelative = this.morphTargetsRelative;
                for(let j4 = 0, jl = morphAttribute.count; j4 < jl; j4++){
                    _vector6.fromBufferAttribute(morphAttribute, j4);
                    if (morphTargetsRelative) {
                        _offset.fromBufferAttribute(position, j4);
                        _vector6.add(_offset);
                    }
                    maxRadiusSq = Math.max(maxRadiusSq, center1.distanceToSquared(_vector6));
                }
            }
            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
            if (isNaN(this.boundingSphere.radius)) console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
    },
    computeFaceNormals: function() {
    },
    computeVertexNormals: function() {
        const index2 = this.index;
        const positionAttribute = this.getAttribute('position');
        if (positionAttribute !== undefined) {
            let normalAttribute = this.getAttribute('normal');
            if (normalAttribute === undefined) {
                normalAttribute = new BufferAttribute1(new Float32Array(positionAttribute.count * 3), 3);
                this.setAttribute('normal', normalAttribute);
            } else for(let i8 = 0, il = normalAttribute.count; i8 < il; i8++)normalAttribute.setXYZ(i8, 0, 0, 0);
            const pA = new Vector31(), pB = new Vector31(), pC = new Vector31();
            const nA = new Vector31(), nB = new Vector31(), nC = new Vector31();
            const cb = new Vector31(), ab = new Vector31();
            if (index2) for(let i8 = 0, il = index2.count; i8 < il; i8 += 3){
                const vA = index2.getX(i8 + 0);
                const vB = index2.getX(i8 + 1);
                const vC = index2.getX(i8 + 2);
                pA.fromBufferAttribute(positionAttribute, vA);
                pB.fromBufferAttribute(positionAttribute, vB);
                pC.fromBufferAttribute(positionAttribute, vC);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                nA.fromBufferAttribute(normalAttribute, vA);
                nB.fromBufferAttribute(normalAttribute, vB);
                nC.fromBufferAttribute(normalAttribute, vC);
                nA.add(cb);
                nB.add(cb);
                nC.add(cb);
                normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
                normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
                normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
            }
            else for(let i8 = 0, il = positionAttribute.count; i8 < il; i8 += 3){
                pA.fromBufferAttribute(positionAttribute, i8 + 0);
                pB.fromBufferAttribute(positionAttribute, i8 + 1);
                pC.fromBufferAttribute(positionAttribute, i8 + 2);
                cb.subVectors(pC, pB);
                ab.subVectors(pA, pB);
                cb.cross(ab);
                normalAttribute.setXYZ(i8 + 0, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i8 + 1, cb.x, cb.y, cb.z);
                normalAttribute.setXYZ(i8 + 2, cb.x, cb.y, cb.z);
            }
            this.normalizeNormals();
            normalAttribute.needsUpdate = true;
        }
    },
    merge: function(geometry, offset) {
        if (!(geometry && geometry.isBufferGeometry)) {
            console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
            return;
        }
        if (offset === undefined) {
            offset = 0;
            console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
        }
        const attributes = this.attributes;
        for(const key in attributes){
            if (geometry.attributes[key] === undefined) continue;
            const attribute1 = attributes[key];
            const attributeArray1 = attribute1.array;
            const attribute2 = geometry.attributes[key];
            const attributeArray2 = attribute2.array;
            const attributeOffset = attribute2.itemSize * offset;
            const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
            for(let i8 = 0, j4 = attributeOffset; i8 < length; (i8++, j4++))attributeArray1[j4] = attributeArray2[i8];
        }
        return this;
    },
    normalizeNormals: function() {
        const normals10 = this.attributes.normal;
        for(let i8 = 0, il = normals10.count; i8 < il; i8++){
            _vector6.fromBufferAttribute(normals10, i8);
            _vector6.normalize();
            normals10.setXYZ(i8, _vector6.x, _vector6.y, _vector6.z);
        }
    },
    toNonIndexed: function() {
        function convertBufferAttribute(attribute, indices17) {
            const array = attribute.array;
            const itemSize = attribute.itemSize;
            const normalized = attribute.normalized;
            const array2 = new array.constructor(indices17.length * itemSize);
            let index2 = 0, index2 = 0;
            for(let i8 = 0, l1 = indices17.length; i8 < l1; i8++){
                index2 = indices17[i8] * itemSize;
                for(let j4 = 0; j4 < itemSize; j4++)array2[index2++] = array[index2++];
            }
            return new BufferAttribute1(array2, itemSize, normalized);
        }
        if (this.index === null) {
            console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');
            return this;
        }
        const geometry2 = new BufferGeometry2();
        const indices17 = this.index.array;
        const attributes = this.attributes;
        for(const name in attributes){
            const attribute = attributes[name];
            const newAttribute = convertBufferAttribute(attribute, indices17);
            geometry2.setAttribute(name, newAttribute);
        }
        const morphAttributes = this.morphAttributes;
        for(const name in morphAttributes){
            const morphArray = [];
            const morphAttribute = morphAttributes[name];
            for(let i8 = 0, il = morphAttribute.length; i8 < il; i8++){
                const attribute = morphAttribute[i8];
                const newAttribute = convertBufferAttribute(attribute, indices17);
                morphArray.push(newAttribute);
            }
            geometry2.morphAttributes[name] = morphArray;
        }
        geometry2.morphTargetsRelative = this.morphTargetsRelative;
        const groups = this.groups;
        for(let i8 = 0, l1 = groups.length; i8 < l1; i8++){
            const group = groups[i8];
            geometry2.addGroup(group.start, group.count, group.materialIndex);
        }
        return geometry2;
    },
    toJSON: function() {
        const data = {
            metadata: {
                version: 4.5,
                type: 'BufferGeometry',
                generator: 'BufferGeometry.toJSON'
            }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '') data.name = this.name;
        if (Object.keys(this.userData).length > 0) data.userData = this.userData;
        if (this.parameters !== undefined) {
            const parameters1 = this.parameters;
            for(const key in parameters1)if (parameters1[key] !== undefined) data[key] = parameters1[key];
            return data;
        }
        data.data = {
            attributes: {
            }
        };
        const index2 = this.index;
        if (index2 !== null) data.data.index = {
            type: index2.array.constructor.name,
            array: Array.prototype.slice.call(index2.array)
        };
        const attributes = this.attributes;
        for(const key in attributes){
            const attribute = attributes[key];
            const attributeData = attribute.toJSON(data.data);
            if (attribute.name !== '') attributeData.name = attribute.name;
            data.data.attributes[key] = attributeData;
        }
        const morphAttributes = {
        };
        let hasMorphAttributes = false;
        for(const key in this.morphAttributes){
            const attributeArray = this.morphAttributes[key];
            const array = [];
            for(let i8 = 0, il = attributeArray.length; i8 < il; i8++){
                const attribute = attributeArray[i8];
                const attributeData = attribute.toJSON(data.data);
                if (attribute.name !== '') attributeData.name = attribute.name;
                array.push(attributeData);
            }
            if (array.length > 0) {
                morphAttributes[key] = array;
                hasMorphAttributes = true;
            }
        }
        if (hasMorphAttributes) {
            data.data.morphAttributes = morphAttributes;
            data.data.morphTargetsRelative = this.morphTargetsRelative;
        }
        const groups = this.groups;
        if (groups.length > 0) data.data.groups = JSON.parse(JSON.stringify(groups));
        const boundingSphere = this.boundingSphere;
        if (boundingSphere !== null) data.data.boundingSphere = {
            center: boundingSphere.center.toArray(),
            radius: boundingSphere.radius
        };
        return data;
    },
    clone: function() {
        return new BufferGeometry2().copy(this);
    },
    copy: function(source) {
        this.index = null;
        this.attributes = {
        };
        this.morphAttributes = {
        };
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        const data = {
        };
        this.name = source.name;
        const index2 = source.index;
        if (index2 !== null) this.setIndex(index2.clone(data));
        const attributes = source.attributes;
        for(const name in attributes){
            const attribute = attributes[name];
            this.setAttribute(name, attribute.clone(data));
        }
        const morphAttributes = source.morphAttributes;
        for(const name in morphAttributes){
            const array = [];
            const morphAttribute = morphAttributes[name];
            for(let i8 = 0, l1 = morphAttribute.length; i8 < l1; i8++)array.push(morphAttribute[i8].clone(data));
            this.morphAttributes[name] = array;
        }
        this.morphTargetsRelative = source.morphTargetsRelative;
        const groups = source.groups;
        for(let i8 = 0, l1 = groups.length; i8 < l1; i8++){
            const group = groups[i8];
            this.addGroup(group.start, group.count, group.materialIndex);
        }
        const boundingBox = source.boundingBox;
        if (boundingBox !== null) this.boundingBox = boundingBox.clone();
        const boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) this.boundingSphere = boundingSphere.clone();
        this.drawRange.start = source.drawRange.start;
        this.drawRange.count = source.drawRange.count;
        this.userData = source.userData;
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
});
const BufferGeometry1 = BufferGeometry2;
export { BufferGeometry1 as BufferGeometry };
let _geometryId = 0;
const _m13 = new Matrix41();
const _obj1 = new Object3D1();
const _offset1 = new Vector31();
function Geometry2() {
    Object.defineProperty(this, 'id', {
        value: _geometryId += 2
    });
    this.uuid = MathUtils1.generateUUID();
    this.name = '';
    this.type = 'Geometry';
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [
        []
    ];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.elementsNeedUpdate = false;
    this.verticesNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.lineDistancesNeedUpdate = false;
    this.groupsNeedUpdate = false;
}
Geometry2.prototype = Object.assign(Object.create(EventDispatcher1.prototype), {
    constructor: Geometry2,
    isGeometry: true,
    applyMatrix4: function(matrix) {
        const normalMatrix = new Matrix31().getNormalMatrix(matrix);
        for(let i8 = 0, il = this.vertices.length; i8 < il; i8++){
            const vertex7 = this.vertices[i8];
            vertex7.applyMatrix4(matrix);
        }
        for(let i8 = 0, il = this.faces.length; i8 < il; i8++){
            const face = this.faces[i8];
            face.normal.applyMatrix3(normalMatrix).normalize();
            for(let j4 = 0, jl = face.vertexNormals.length; j4 < jl; j4++)face.vertexNormals[j4].applyMatrix3(normalMatrix).normalize();
        }
        if (this.boundingBox !== null) this.computeBoundingBox();
        if (this.boundingSphere !== null) this.computeBoundingSphere();
        this.verticesNeedUpdate = true;
        this.normalsNeedUpdate = true;
        return this;
    },
    rotateX: function(angle) {
        _m13.makeRotationX(angle);
        this.applyMatrix4(_m13);
        return this;
    },
    rotateY: function(angle) {
        _m13.makeRotationY(angle);
        this.applyMatrix4(_m13);
        return this;
    },
    rotateZ: function(angle) {
        _m13.makeRotationZ(angle);
        this.applyMatrix4(_m13);
        return this;
    },
    translate: function(x6, y6, z5) {
        _m13.makeTranslation(x6, y6, z5);
        this.applyMatrix4(_m13);
        return this;
    },
    scale: function(x6, y6, z5) {
        _m13.makeScale(x6, y6, z5);
        this.applyMatrix4(_m13);
        return this;
    },
    lookAt: function(vector) {
        _obj1.lookAt(vector);
        _obj1.updateMatrix();
        this.applyMatrix4(_obj1.matrix);
        return this;
    },
    fromBufferGeometry: function(geometry) {
        const scope3 = this;
        const index2 = geometry.index !== null ? geometry.index : undefined;
        const attributes = geometry.attributes;
        if (attributes.position === undefined) {
            console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');
            return this;
        }
        const position = attributes.position;
        const normal6 = attributes.normal;
        const color1 = attributes.color;
        const uv4 = attributes.uv;
        const uv21 = attributes.uv2;
        if (uv21 !== undefined) this.faceVertexUvs[1] = [];
        for(let i8 = 0; i8 < position.count; i8++){
            scope3.vertices.push(new Vector31().fromBufferAttribute(position, i8));
            if (color1 !== undefined) scope3.colors.push(new Color1().fromBufferAttribute(color1, i8));
        }
        function addFace(a2, b2, c2, materialIndex1) {
            const vertexColors = color1 === undefined ? [] : [
                scope3.colors[a2].clone(),
                scope3.colors[b2].clone(),
                scope3.colors[c2].clone()
            ];
            const vertexNormals = normal6 === undefined ? [] : [
                new Vector31().fromBufferAttribute(normal6, a2),
                new Vector31().fromBufferAttribute(normal6, b2),
                new Vector31().fromBufferAttribute(normal6, c2)
            ];
            const face = new Face31(a2, b2, c2, vertexNormals, vertexColors, materialIndex1);
            scope3.faces.push(face);
            if (uv4 !== undefined) scope3.faceVertexUvs[0].push([
                new Vector21().fromBufferAttribute(uv4, a2),
                new Vector21().fromBufferAttribute(uv4, b2),
                new Vector21().fromBufferAttribute(uv4, c2)
            ]);
            if (uv21 !== undefined) scope3.faceVertexUvs[1].push([
                new Vector21().fromBufferAttribute(uv21, a2),
                new Vector21().fromBufferAttribute(uv21, b2),
                new Vector21().fromBufferAttribute(uv21, c2)
            ]);
        }
        const groups = geometry.groups;
        if (groups.length > 0) for(let i8 = 0; i8 < groups.length; i8++){
            const group = groups[i8];
            const start = group.start;
            const count = group.count;
            for(let j4 = start, jl = start + count; j4 < jl; j4 += 3)if (index2 !== undefined) addFace(index2.getX(j4), index2.getX(j4 + 1), index2.getX(j4 + 2), group.materialIndex);
            else addFace(j4, j4 + 1, j4 + 2, group.materialIndex);
        }
        else if (index2 !== undefined) for(let i8 = 0; i8 < index2.count; i8 += 3)addFace(index2.getX(i8), index2.getX(i8 + 1), index2.getX(i8 + 2));
        else for(let i8 = 0; i8 < position.count; i8 += 3)addFace(i8, i8 + 1, i8 + 2);
        this.computeFaceNormals();
        if (geometry.boundingBox !== null) this.boundingBox = geometry.boundingBox.clone();
        if (geometry.boundingSphere !== null) this.boundingSphere = geometry.boundingSphere.clone();
        return this;
    },
    center: function() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(_offset1).negate();
        this.translate(_offset1.x, _offset1.y, _offset1.z);
        return this;
    },
    normalize: function() {
        this.computeBoundingSphere();
        const center1 = this.boundingSphere.center;
        const radius11 = this.boundingSphere.radius;
        const s1 = radius11 === 0 ? 1 : 1 / radius11;
        const matrix = new Matrix41();
        matrix.set(s1, 0, 0, -s1 * center1.x, 0, s1, 0, -s1 * center1.y, 0, 0, s1, -s1 * center1.z, 0, 0, 0, 1);
        this.applyMatrix4(matrix);
        return this;
    },
    computeFaceNormals: function() {
        const cb = new Vector31(), ab = new Vector31();
        for(let f = 0, fl = this.faces.length; f < fl; f++){
            const face = this.faces[f];
            const vA = this.vertices[face.a];
            const vB = this.vertices[face.b];
            const vC = this.vertices[face.c];
            cb.subVectors(vC, vB);
            ab.subVectors(vA, vB);
            cb.cross(ab);
            cb.normalize();
            face.normal.copy(cb);
        }
    },
    computeVertexNormals: function(areaWeighted) {
        if (areaWeighted === undefined) areaWeighted = true;
        const vertices17 = new Array(this.vertices.length);
        for(let v = 0, vl = this.vertices.length; v < vl; v++)vertices17[v] = new Vector31();
        if (areaWeighted) {
            const cb = new Vector31(), ab = new Vector31();
            for(let f = 0, fl = this.faces.length; f < fl; f++){
                const face = this.faces[f];
                const vA = this.vertices[face.a];
                const vB = this.vertices[face.b];
                const vC = this.vertices[face.c];
                cb.subVectors(vC, vB);
                ab.subVectors(vA, vB);
                cb.cross(ab);
                vertices17[face.a].add(cb);
                vertices17[face.b].add(cb);
                vertices17[face.c].add(cb);
            }
        } else {
            this.computeFaceNormals();
            for(let f = 0, fl = this.faces.length; f < fl; f++){
                const face = this.faces[f];
                vertices17[face.a].add(face.normal);
                vertices17[face.b].add(face.normal);
                vertices17[face.c].add(face.normal);
            }
        }
        for(let v = 0, vl = this.vertices.length; v < vl; v++)vertices17[v].normalize();
        for(let f = 0, fl = this.faces.length; f < fl; f++){
            const face = this.faces[f];
            const vertexNormals = face.vertexNormals;
            if (vertexNormals.length === 3) {
                vertexNormals[0].copy(vertices17[face.a]);
                vertexNormals[1].copy(vertices17[face.b]);
                vertexNormals[2].copy(vertices17[face.c]);
            } else {
                vertexNormals[0] = vertices17[face.a].clone();
                vertexNormals[1] = vertices17[face.b].clone();
                vertexNormals[2] = vertices17[face.c].clone();
            }
        }
        if (this.faces.length > 0) this.normalsNeedUpdate = true;
    },
    computeFlatVertexNormals: function() {
        this.computeFaceNormals();
        for(let f = 0, fl = this.faces.length; f < fl; f++){
            const face = this.faces[f];
            const vertexNormals = face.vertexNormals;
            if (vertexNormals.length === 3) {
                vertexNormals[0].copy(face.normal);
                vertexNormals[1].copy(face.normal);
                vertexNormals[2].copy(face.normal);
            } else {
                vertexNormals[0] = face.normal.clone();
                vertexNormals[1] = face.normal.clone();
                vertexNormals[2] = face.normal.clone();
            }
        }
        if (this.faces.length > 0) this.normalsNeedUpdate = true;
    },
    computeMorphNormals: function() {
        for(let f = 0, fl = this.faces.length; f < fl; f++){
            const face = this.faces[f];
            if (!face.__originalFaceNormal) face.__originalFaceNormal = face.normal.clone();
            else face.__originalFaceNormal.copy(face.normal);
            if (!face.__originalVertexNormals) face.__originalVertexNormals = [];
            for(let i8 = 0, il = face.vertexNormals.length; i8 < il; i8++)if (!face.__originalVertexNormals[i8]) face.__originalVertexNormals[i8] = face.vertexNormals[i8].clone();
            else face.__originalVertexNormals[i8].copy(face.vertexNormals[i8]);
        }
        const tmpGeo = new Geometry2();
        tmpGeo.faces = this.faces;
        for(let i8 = 0, il = this.morphTargets.length; i8 < il; i8++){
            if (!this.morphNormals[i8]) {
                this.morphNormals[i8] = {
                };
                this.morphNormals[i8].faceNormals = [];
                this.morphNormals[i8].vertexNormals = [];
                const dstNormalsFace = this.morphNormals[i8].faceNormals;
                const dstNormalsVertex = this.morphNormals[i8].vertexNormals;
                for(let f1 = 0, fl1 = this.faces.length; f1 < fl1; f1++){
                    const faceNormal = new Vector31();
                    const vertexNormals = {
                        a: new Vector31(),
                        b: new Vector31(),
                        c: new Vector31()
                    };
                    dstNormalsFace.push(faceNormal);
                    dstNormalsVertex.push(vertexNormals);
                }
            }
            const morphNormals = this.morphNormals[i8];
            tmpGeo.vertices = this.morphTargets[i8].vertices;
            tmpGeo.computeFaceNormals();
            tmpGeo.computeVertexNormals();
            for(let f1 = 0, fl1 = this.faces.length; f1 < fl1; f1++){
                const face = this.faces[f1];
                const faceNormal = morphNormals.faceNormals[f1];
                const vertexNormals = morphNormals.vertexNormals[f1];
                faceNormal.copy(face.normal);
                vertexNormals.a.copy(face.vertexNormals[0]);
                vertexNormals.b.copy(face.vertexNormals[1]);
                vertexNormals.c.copy(face.vertexNormals[2]);
            }
        }
        for(let f = 0, fl = this.faces.length; f < fl; f++){
            const face = this.faces[f];
            face.normal = face.__originalFaceNormal;
            face.vertexNormals = face.__originalVertexNormals;
        }
    },
    computeBoundingBox: function() {
        if (this.boundingBox === null) this.boundingBox = new Box31();
        this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function() {
        if (this.boundingSphere === null) this.boundingSphere = new Sphere1();
        this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function(geometry, matrix, materialIndexOffset) {
        if (!(geometry && geometry.isGeometry)) {
            console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);
            return;
        }
        let normalMatrix;
        const vertexOffset = this.vertices.length, vertices17 = this.vertices, vertices22 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, colors1 = this.colors, colors2 = geometry.colors;
        if (materialIndexOffset === undefined) materialIndexOffset = 0;
        if (matrix !== undefined) normalMatrix = new Matrix31().getNormalMatrix(matrix);
        for(let i8 = 0, il = vertices22.length; i8 < il; i8++){
            const vertex7 = vertices22[i8];
            const vertexCopy = vertex7.clone();
            if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);
            vertices17.push(vertexCopy);
        }
        for(let i8 = 0, il = colors2.length; i8 < il; i8++)colors1.push(colors2[i8].clone());
        for(let i8 = 0, il = faces2.length; i8 < il; i8++){
            const face = faces2[i8];
            let normal6, color1;
            const faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
            const faceCopy = new Face31(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
            faceCopy.normal.copy(face.normal);
            if (normalMatrix !== undefined) faceCopy.normal.applyMatrix3(normalMatrix).normalize();
            for(let j4 = 0, jl = faceVertexNormals.length; j4 < jl; j4++){
                normal6 = faceVertexNormals[j4].clone();
                if (normalMatrix !== undefined) normal6.applyMatrix3(normalMatrix).normalize();
                faceCopy.vertexNormals.push(normal6);
            }
            faceCopy.color.copy(face.color);
            for(let j4 = 0, jl = faceVertexColors.length; j4 < jl; j4++){
                color1 = faceVertexColors[j4];
                faceCopy.vertexColors.push(color1.clone());
            }
            faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
            faces1.push(faceCopy);
        }
        for(let i8 = 0, il = geometry.faceVertexUvs.length; i8 < il; i8++){
            const faceVertexUvs2 = geometry.faceVertexUvs[i8];
            if (this.faceVertexUvs[i8] === undefined) this.faceVertexUvs[i8] = [];
            for(let j4 = 0, jl = faceVertexUvs2.length; j4 < jl; j4++){
                const uvs21 = faceVertexUvs2[j4], uvsCopy = [];
                for(let k = 0, kl = uvs21.length; k < kl; k++)uvsCopy.push(uvs21[k].clone());
                this.faceVertexUvs[i8].push(uvsCopy);
            }
        }
    },
    mergeMesh: function(mesh) {
        if (!(mesh && mesh.isMesh)) {
            console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);
            return;
        }
        if (mesh.matrixAutoUpdate) mesh.updateMatrix();
        this.merge(mesh.geometry, mesh.matrix);
    },
    mergeVertices: function() {
        const verticesMap = {
        };
        const unique = [], changes = [];
        const precisionPoints = 4;
        const precision = Math.pow(10, precisionPoints);
        for(let i8 = 0, il = this.vertices.length; i8 < il; i8++){
            const v = this.vertices[i8];
            const key = Math.round(v.x * precision) + '_' + Math.round(v.y * precision) + '_' + Math.round(v.z * precision);
            if (verticesMap[key] === undefined) {
                verticesMap[key] = i8;
                unique.push(this.vertices[i8]);
                changes[i8] = unique.length - 1;
            } else changes[i8] = changes[verticesMap[key]];
        }
        const faceIndicesToRemove = [];
        for(let i8 = 0, il = this.faces.length; i8 < il; i8++){
            const face = this.faces[i8];
            face.a = changes[face.a];
            face.b = changes[face.b];
            face.c = changes[face.c];
            const indices17 = [
                face.a,
                face.b,
                face.c
            ];
            for(let n = 0; n < 3; n++)if (indices17[n] === indices17[(n + 1) % 3]) {
                faceIndicesToRemove.push(i8);
                break;
            }
        }
        for(let i8 = faceIndicesToRemove.length - 1; i8 >= 0; i8--){
            const idx = faceIndicesToRemove[i8];
            this.faces.splice(idx, 1);
            for(let j4 = 0, jl = this.faceVertexUvs.length; j4 < jl; j4++)this.faceVertexUvs[j4].splice(idx, 1);
        }
        const diff = this.vertices.length - unique.length;
        this.vertices = unique;
        return diff;
    },
    setFromPoints: function(points1) {
        this.vertices = [];
        for(let i8 = 0, l1 = points1.length; i8 < l1; i8++){
            const point = points1[i8];
            this.vertices.push(new Vector31(point.x, point.y, point.z || 0));
        }
        return this;
    },
    sortFacesByMaterialIndex: function() {
        const faces = this.faces;
        const length = faces.length;
        for(let i8 = 0; i8 < length; i8++)faces[i8]._id = i8;
        function materialIndexSort(a2, b2) {
            return a2.materialIndex - b2.materialIndex;
        }
        faces.sort(materialIndexSort);
        const uvs12 = this.faceVertexUvs[0];
        const uvs21 = this.faceVertexUvs[1];
        let newUvs1, newUvs2;
        if (uvs12 && uvs12.length === length) newUvs1 = [];
        if (uvs21 && uvs21.length === length) newUvs2 = [];
        for(let i8 = 0; i8 < length; i8++){
            const id = faces[i8]._id;
            if (newUvs1) newUvs1.push(uvs12[id]);
            if (newUvs2) newUvs2.push(uvs21[id]);
        }
        if (newUvs1) this.faceVertexUvs[0] = newUvs1;
        if (newUvs2) this.faceVertexUvs[1] = newUvs2;
    },
    toJSON: function() {
        const data = {
            metadata: {
                version: 4.5,
                type: 'Geometry',
                generator: 'Geometry.toJSON'
            }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '') data.name = this.name;
        if (this.parameters !== undefined) {
            const parameters1 = this.parameters;
            for(const key in parameters1)if (parameters1[key] !== undefined) data[key] = parameters1[key];
            return data;
        }
        const vertices17 = [];
        for(let i8 = 0; i8 < this.vertices.length; i8++){
            const vertex7 = this.vertices[i8];
            vertices17.push(vertex7.x, vertex7.y, vertex7.z);
        }
        const faces = [];
        const normals10 = [];
        const normalsHash = {
        };
        const colors = [];
        const colorsHash = {
        };
        const uvs12 = [];
        const uvsHash = {
        };
        for(let i8 = 0; i8 < this.faces.length; i8++){
            const face = this.faces[i8];
            const hasMaterial = true;
            const hasFaceUv = false;
            const hasFaceVertexUv = this.faceVertexUvs[0][i8] !== undefined;
            const hasFaceNormal = face.normal.length() > 0;
            const hasFaceVertexNormal = face.vertexNormals.length > 0;
            const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
            const hasFaceVertexColor = face.vertexColors.length > 0;
            let faceType = 0;
            faceType = setBit(faceType, 0, 0);
            faceType = setBit(faceType, 1, hasMaterial);
            faceType = setBit(faceType, 2, hasFaceUv);
            faceType = setBit(faceType, 3, hasFaceVertexUv);
            faceType = setBit(faceType, 4, hasFaceNormal);
            faceType = setBit(faceType, 5, hasFaceVertexNormal);
            faceType = setBit(faceType, 6, hasFaceColor);
            faceType = setBit(faceType, 7, hasFaceVertexColor);
            faces.push(faceType);
            faces.push(face.a, face.b, face.c);
            faces.push(face.materialIndex);
            if (hasFaceVertexUv) {
                const faceVertexUvs = this.faceVertexUvs[0][i8];
                faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
            }
            if (hasFaceNormal) faces.push(getNormalIndex(face.normal));
            if (hasFaceVertexNormal) {
                const vertexNormals = face.vertexNormals;
                faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
            }
            if (hasFaceColor) faces.push(getColorIndex(face.color));
            if (hasFaceVertexColor) {
                const vertexColors = face.vertexColors;
                faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
            }
        }
        function setBit(value1, position, enabled) {
            return enabled ? value1 | 1 << position : value1 & ~(1 << position);
        }
        function getNormalIndex(normal6) {
            const hash = normal6.x.toString() + normal6.y.toString() + normal6.z.toString();
            if (normalsHash[hash] !== undefined) return normalsHash[hash];
            normalsHash[hash] = normals10.length / 3;
            normals10.push(normal6.x, normal6.y, normal6.z);
            return normalsHash[hash];
        }
        function getColorIndex(color1) {
            const hash = color1.r.toString() + color1.g.toString() + color1.b.toString();
            if (colorsHash[hash] !== undefined) return colorsHash[hash];
            colorsHash[hash] = colors.length;
            colors.push(color1.getHex());
            return colorsHash[hash];
        }
        function getUvIndex(uv4) {
            const hash = uv4.x.toString() + uv4.y.toString();
            if (uvsHash[hash] !== undefined) return uvsHash[hash];
            uvsHash[hash] = uvs12.length / 2;
            uvs12.push(uv4.x, uv4.y);
            return uvsHash[hash];
        }
        data.data = {
        };
        data.data.vertices = vertices17;
        data.data.normals = normals10;
        if (colors.length > 0) data.data.colors = colors;
        if (uvs12.length > 0) data.data.uvs = [
            uvs12
        ];
        data.data.faces = faces;
        return data;
    },
    clone: function() {
        return new Geometry2().copy(this);
    },
    copy: function(source) {
        this.vertices = [];
        this.colors = [];
        this.faces = [];
        this.faceVertexUvs = [
            []
        ];
        this.morphTargets = [];
        this.morphNormals = [];
        this.skinWeights = [];
        this.skinIndices = [];
        this.lineDistances = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.name = source.name;
        const vertices17 = source.vertices;
        for(let i8 = 0, il = vertices17.length; i8 < il; i8++)this.vertices.push(vertices17[i8].clone());
        const colors = source.colors;
        for(let i8 = 0, il = colors.length; i8 < il; i8++)this.colors.push(colors[i8].clone());
        const faces = source.faces;
        for(let i8 = 0, il = faces.length; i8 < il; i8++)this.faces.push(faces[i8].clone());
        for(let i8 = 0, il = source.faceVertexUvs.length; i8 < il; i8++){
            const faceVertexUvs = source.faceVertexUvs[i8];
            if (this.faceVertexUvs[i8] === undefined) this.faceVertexUvs[i8] = [];
            for(let j4 = 0, jl = faceVertexUvs.length; j4 < jl; j4++){
                const uvs12 = faceVertexUvs[j4], uvsCopy = [];
                for(let k = 0, kl = uvs12.length; k < kl; k++){
                    const uv4 = uvs12[k];
                    uvsCopy.push(uv4.clone());
                }
                this.faceVertexUvs[i8].push(uvsCopy);
            }
        }
        const morphTargets = source.morphTargets;
        for(let i8 = 0, il = morphTargets.length; i8 < il; i8++){
            const morphTarget = {
            };
            morphTarget.name = morphTargets[i8].name;
            if (morphTargets[i8].vertices !== undefined) {
                morphTarget.vertices = [];
                for(let j4 = 0, jl = morphTargets[i8].vertices.length; j4 < jl; j4++)morphTarget.vertices.push(morphTargets[i8].vertices[j4].clone());
            }
            if (morphTargets[i8].normals !== undefined) {
                morphTarget.normals = [];
                for(let j4 = 0, jl = morphTargets[i8].normals.length; j4 < jl; j4++)morphTarget.normals.push(morphTargets[i8].normals[j4].clone());
            }
            this.morphTargets.push(morphTarget);
        }
        const morphNormals = source.morphNormals;
        for(let i8 = 0, il = morphNormals.length; i8 < il; i8++){
            const morphNormal = {
            };
            if (morphNormals[i8].vertexNormals !== undefined) {
                morphNormal.vertexNormals = [];
                for(let j4 = 0, jl = morphNormals[i8].vertexNormals.length; j4 < jl; j4++){
                    const srcVertexNormal = morphNormals[i8].vertexNormals[j4];
                    const destVertexNormal = {
                    };
                    destVertexNormal.a = srcVertexNormal.a.clone();
                    destVertexNormal.b = srcVertexNormal.b.clone();
                    destVertexNormal.c = srcVertexNormal.c.clone();
                    morphNormal.vertexNormals.push(destVertexNormal);
                }
            }
            if (morphNormals[i8].faceNormals !== undefined) {
                morphNormal.faceNormals = [];
                for(let j4 = 0, jl = morphNormals[i8].faceNormals.length; j4 < jl; j4++)morphNormal.faceNormals.push(morphNormals[i8].faceNormals[j4].clone());
            }
            this.morphNormals.push(morphNormal);
        }
        const skinWeights = source.skinWeights;
        for(let i8 = 0, il = skinWeights.length; i8 < il; i8++)this.skinWeights.push(skinWeights[i8].clone());
        const skinIndices = source.skinIndices;
        for(let i8 = 0, il = skinIndices.length; i8 < il; i8++)this.skinIndices.push(skinIndices[i8].clone());
        const lineDistances = source.lineDistances;
        for(let i8 = 0, il = lineDistances.length; i8 < il; i8++)this.lineDistances.push(lineDistances[i8]);
        const boundingBox = source.boundingBox;
        if (boundingBox !== null) this.boundingBox = boundingBox.clone();
        const boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) this.boundingSphere = boundingSphere.clone();
        this.elementsNeedUpdate = source.elementsNeedUpdate;
        this.verticesNeedUpdate = source.verticesNeedUpdate;
        this.uvsNeedUpdate = source.uvsNeedUpdate;
        this.normalsNeedUpdate = source.normalsNeedUpdate;
        this.colorsNeedUpdate = source.colorsNeedUpdate;
        this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
        this.groupsNeedUpdate = source.groupsNeedUpdate;
        return this;
    },
    dispose: function() {
        this.dispatchEvent({
            type: 'dispose'
        });
    }
});
const Geometry1 = Geometry2;
export { Geometry1 as Geometry };
const _vector7 = new Vector31();
function InterleavedBufferAttribute2(interleavedBuffer, itemSize, offset, normalized) {
    this.name = '';
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized === true;
}
Object.defineProperties(InterleavedBufferAttribute2.prototype, {
    count: {
        get: function() {
            return this.data.count;
        }
    },
    array: {
        get: function() {
            return this.data.array;
        }
    },
    needsUpdate: {
        set: function(value1) {
            this.data.needsUpdate = value1;
        }
    }
});
Object.assign(InterleavedBufferAttribute2.prototype, {
    isInterleavedBufferAttribute: true,
    applyMatrix4: function(m) {
        for(let i8 = 0, l1 = this.data.count; i8 < l1; i8++){
            _vector7.x = this.getX(i8);
            _vector7.y = this.getY(i8);
            _vector7.z = this.getZ(i8);
            _vector7.applyMatrix4(m);
            this.setXYZ(i8, _vector7.x, _vector7.y, _vector7.z);
        }
        return this;
    },
    setX: function(index2, x6) {
        this.data.array[index2 * this.data.stride + this.offset] = x6;
        return this;
    },
    setY: function(index2, y6) {
        this.data.array[index2 * this.data.stride + this.offset + 1] = y6;
        return this;
    },
    setZ: function(index2, z5) {
        this.data.array[index2 * this.data.stride + this.offset + 2] = z5;
        return this;
    },
    setW: function(index2, w3) {
        this.data.array[index2 * this.data.stride + this.offset + 3] = w3;
        return this;
    },
    getX: function(index2) {
        return this.data.array[index2 * this.data.stride + this.offset];
    },
    getY: function(index2) {
        return this.data.array[index2 * this.data.stride + this.offset + 1];
    },
    getZ: function(index2) {
        return this.data.array[index2 * this.data.stride + this.offset + 2];
    },
    getW: function(index2) {
        return this.data.array[index2 * this.data.stride + this.offset + 3];
    },
    setXY: function(index2, x6, y6) {
        index2 = index2 * this.data.stride + this.offset;
        this.data.array[index2 + 0] = x6;
        this.data.array[index2 + 1] = y6;
        return this;
    },
    setXYZ: function(index2, x6, y6, z5) {
        index2 = index2 * this.data.stride + this.offset;
        this.data.array[index2 + 0] = x6;
        this.data.array[index2 + 1] = y6;
        this.data.array[index2 + 2] = z5;
        return this;
    },
    setXYZW: function(index2, x6, y6, z5, w3) {
        index2 = index2 * this.data.stride + this.offset;
        this.data.array[index2 + 0] = x6;
        this.data.array[index2 + 1] = y6;
        this.data.array[index2 + 2] = z5;
        this.data.array[index2 + 3] = w3;
        return this;
    },
    clone: function(data) {
        if (data === undefined) {
            console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');
            const array = [];
            for(let i8 = 0; i8 < this.count; i8++){
                const index2 = i8 * this.data.stride + this.offset;
                for(let j4 = 0; j4 < this.itemSize; j4++)array.push(this.data.array[index2 + j4]);
            }
            return new BufferAttribute1(new this.array.constructor(array), this.itemSize, this.normalized);
        } else {
            if (data.interleavedBuffers === undefined) data.interleavedBuffers = {
            };
            if (data.interleavedBuffers[this.data.uuid] === undefined) data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
            return new InterleavedBufferAttribute2(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
    },
    toJSON: function(data) {
        if (data === undefined) {
            console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');
            const array = [];
            for(let i8 = 0; i8 < this.count; i8++){
                const index2 = i8 * this.data.stride + this.offset;
                for(let j4 = 0; j4 < this.itemSize; j4++)array.push(this.data.array[index2 + j4]);
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: array,
                normalized: this.normalized
            };
        } else {
            if (data.interleavedBuffers === undefined) data.interleavedBuffers = {
            };
            if (data.interleavedBuffers[this.data.uuid] === undefined) data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
            return {
                isInterleavedBufferAttribute: true,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            };
        }
    }
});
const InterleavedBufferAttribute1 = InterleavedBufferAttribute2;
export { InterleavedBufferAttribute1 as InterleavedBufferAttribute };
function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
    InterleavedBuffer1.call(this, array, stride);
    this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer1.prototype), {
    constructor: InstancedInterleavedBuffer,
    isInstancedInterleavedBuffer: true,
    copy: function(source) {
        InterleavedBuffer1.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    },
    clone: function(data) {
        const ib = InterleavedBuffer1.prototype.clone.call(this, data);
        ib.meshPerAttribute = this.meshPerAttribute;
        return ib;
    },
    toJSON: function(data) {
        const json = InterleavedBuffer1.prototype.toJSON.call(this, data);
        json.isInstancedInterleavedBuffer = true;
        json.meshPerAttribute = this.meshPerAttribute;
        return json;
    }
});
const InstancedInterleavedBuffer1 = InstancedInterleavedBuffer;
export { InstancedInterleavedBuffer1 as InstancedInterleavedBuffer };
function InterleavedBuffer2(array, stride) {
    this.array = array;
    this.stride = stride;
    this.count = array !== undefined ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRange = {
        offset: 0,
        count: -1
    };
    this.version = 0;
    this.uuid = MathUtils1.generateUUID();
}
Object.defineProperty(InterleavedBuffer2.prototype, 'needsUpdate', {
    set: function(value1) {
        if (value1 === true) this.version++;
    }
});
Object.assign(InterleavedBuffer2.prototype, {
    isInterleavedBuffer: true,
    onUploadCallback: function() {
    },
    setUsage: function(value1) {
        this.usage = value1;
        return this;
    },
    copy: function(source) {
        this.array = new source.array.constructor(source.array);
        this.count = source.count;
        this.stride = source.stride;
        this.usage = source.usage;
        return this;
    },
    copyAt: function(index12, attribute, index2) {
        index12 *= this.stride;
        index2 *= attribute.stride;
        for(let i8 = 0, l1 = this.stride; i8 < l1; i8++)this.array[index12 + i8] = attribute.array[index2 + i8];
        return this;
    },
    set: function(value1, offset) {
        if (offset === undefined) offset = 0;
        this.array.set(value1, offset);
        return this;
    },
    clone: function(data) {
        if (data.arrayBuffers === undefined) data.arrayBuffers = {
        };
        if (this.array.buffer._uuid === undefined) this.array.buffer._uuid = MathUtils1.generateUUID();
        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
        const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
        const ib = new InterleavedBuffer2(array, this.stride);
        ib.setUsage(this.usage);
        return ib;
    },
    onUpload: function(callback) {
        this.onUploadCallback = callback;
        return this;
    },
    toJSON: function(data) {
        if (data.arrayBuffers === undefined) data.arrayBuffers = {
        };
        if (this.array.buffer._uuid === undefined) this.array.buffer._uuid = MathUtils1.generateUUID();
        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
        return {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        };
    }
});
const InterleavedBuffer1 = InterleavedBuffer2;
export { InterleavedBuffer1 as InterleavedBuffer };
function InstancedBufferAttribute3(array, itemSize, normalized, meshPerAttribute) {
    if (typeof normalized === 'number') {
        meshPerAttribute = normalized;
        normalized = false;
        console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
    }
    BufferAttribute1.call(this, array, itemSize, normalized);
    this.meshPerAttribute = meshPerAttribute || 1;
}
InstancedBufferAttribute3.prototype = Object.assign(Object.create(BufferAttribute1.prototype), {
    constructor: InstancedBufferAttribute3,
    isInstancedBufferAttribute: true,
    copy: function(source) {
        BufferAttribute1.prototype.copy.call(this, source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
    },
    toJSON: function() {
        const data = BufferAttribute1.prototype.toJSON.call(this);
        data.meshPerAttribute = this.meshPerAttribute;
        data.isInstancedBufferAttribute = true;
        return data;
    }
});
const InstancedBufferAttribute1 = InstancedBufferAttribute3;
export { InstancedBufferAttribute1 as InstancedBufferAttribute };
const _vector4 = new Vector31();
const _vector22 = new Vector21();
function BufferAttribute2(array, itemSize, normalized) {
    if (Array.isArray(array)) throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    this.name = '';
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== undefined ? array.length / itemSize : 0;
    this.normalized = normalized === true;
    this.usage = StaticDrawUsage;
    this.updateRange = {
        offset: 0,
        count: -1
    };
    this.version = 0;
}
Object.defineProperty(BufferAttribute2.prototype, 'needsUpdate', {
    set: function(value1) {
        if (value1 === true) this.version++;
    }
});
Object.assign(BufferAttribute2.prototype, {
    isBufferAttribute: true,
    onUploadCallback: function() {
    },
    setUsage: function(value1) {
        this.usage = value1;
        return this;
    },
    copy: function(source) {
        this.name = source.name;
        this.array = new source.array.constructor(source.array);
        this.itemSize = source.itemSize;
        this.count = source.count;
        this.normalized = source.normalized;
        this.usage = source.usage;
        return this;
    },
    copyAt: function(index12, attribute, index2) {
        index12 *= this.itemSize;
        index2 *= attribute.itemSize;
        for(let i8 = 0, l1 = this.itemSize; i8 < l1; i8++)this.array[index12 + i8] = attribute.array[index2 + i8];
        return this;
    },
    copyArray: function(array) {
        this.array.set(array);
        return this;
    },
    copyColorsArray: function(colors) {
        const array = this.array;
        let offset = 0;
        for(let i8 = 0, l1 = colors.length; i8 < l1; i8++){
            let color1 = colors[i8];
            if (color1 === undefined) {
                console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i8);
                color1 = new Color1();
            }
            array[offset++] = color1.r;
            array[offset++] = color1.g;
            array[offset++] = color1.b;
        }
        return this;
    },
    copyVector2sArray: function(vectors) {
        const array = this.array;
        let offset = 0;
        for(let i8 = 0, l1 = vectors.length; i8 < l1; i8++){
            let vector = vectors[i8];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i8);
                vector = new Vector21();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
        }
        return this;
    },
    copyVector3sArray: function(vectors) {
        const array = this.array;
        let offset = 0;
        for(let i8 = 0, l1 = vectors.length; i8 < l1; i8++){
            let vector = vectors[i8];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i8);
                vector = new Vector31();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
        }
        return this;
    },
    copyVector4sArray: function(vectors) {
        const array = this.array;
        let offset = 0;
        for(let i8 = 0, l1 = vectors.length; i8 < l1; i8++){
            let vector = vectors[i8];
            if (vector === undefined) {
                console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i8);
                vector = new Vector41();
            }
            array[offset++] = vector.x;
            array[offset++] = vector.y;
            array[offset++] = vector.z;
            array[offset++] = vector.w;
        }
        return this;
    },
    applyMatrix3: function(m) {
        if (this.itemSize === 2) for(let i8 = 0, l1 = this.count; i8 < l1; i8++){
            _vector22.fromBufferAttribute(this, i8);
            _vector22.applyMatrix3(m);
            this.setXY(i8, _vector22.x, _vector22.y);
        }
        else if (this.itemSize === 3) for(let i8 = 0, l1 = this.count; i8 < l1; i8++){
            _vector4.fromBufferAttribute(this, i8);
            _vector4.applyMatrix3(m);
            this.setXYZ(i8, _vector4.x, _vector4.y, _vector4.z);
        }
        return this;
    },
    applyMatrix4: function(m) {
        for(let i8 = 0, l1 = this.count; i8 < l1; i8++){
            _vector4.x = this.getX(i8);
            _vector4.y = this.getY(i8);
            _vector4.z = this.getZ(i8);
            _vector4.applyMatrix4(m);
            this.setXYZ(i8, _vector4.x, _vector4.y, _vector4.z);
        }
        return this;
    },
    applyNormalMatrix: function(m) {
        for(let i8 = 0, l1 = this.count; i8 < l1; i8++){
            _vector4.x = this.getX(i8);
            _vector4.y = this.getY(i8);
            _vector4.z = this.getZ(i8);
            _vector4.applyNormalMatrix(m);
            this.setXYZ(i8, _vector4.x, _vector4.y, _vector4.z);
        }
        return this;
    },
    transformDirection: function(m) {
        for(let i8 = 0, l1 = this.count; i8 < l1; i8++){
            _vector4.x = this.getX(i8);
            _vector4.y = this.getY(i8);
            _vector4.z = this.getZ(i8);
            _vector4.transformDirection(m);
            this.setXYZ(i8, _vector4.x, _vector4.y, _vector4.z);
        }
        return this;
    },
    set: function(value1, offset) {
        if (offset === undefined) offset = 0;
        this.array.set(value1, offset);
        return this;
    },
    getX: function(index2) {
        return this.array[index2 * this.itemSize];
    },
    setX: function(index2, x6) {
        this.array[index2 * this.itemSize] = x6;
        return this;
    },
    getY: function(index2) {
        return this.array[index2 * this.itemSize + 1];
    },
    setY: function(index2, y6) {
        this.array[index2 * this.itemSize + 1] = y6;
        return this;
    },
    getZ: function(index2) {
        return this.array[index2 * this.itemSize + 2];
    },
    setZ: function(index2, z5) {
        this.array[index2 * this.itemSize + 2] = z5;
        return this;
    },
    getW: function(index2) {
        return this.array[index2 * this.itemSize + 3];
    },
    setW: function(index2, w3) {
        this.array[index2 * this.itemSize + 3] = w3;
        return this;
    },
    setXY: function(index2, x6, y6) {
        index2 *= this.itemSize;
        this.array[index2 + 0] = x6;
        this.array[index2 + 1] = y6;
        return this;
    },
    setXYZ: function(index2, x6, y6, z5) {
        index2 *= this.itemSize;
        this.array[index2 + 0] = x6;
        this.array[index2 + 1] = y6;
        this.array[index2 + 2] = z5;
        return this;
    },
    setXYZW: function(index2, x6, y6, z5, w3) {
        index2 *= this.itemSize;
        this.array[index2 + 0] = x6;
        this.array[index2 + 1] = y6;
        this.array[index2 + 2] = z5;
        this.array[index2 + 3] = w3;
        return this;
    },
    onUpload: function(callback) {
        this.onUploadCallback = callback;
        return this;
    },
    clone: function() {
        return new this.constructor(this.array, this.itemSize).copy(this);
    },
    toJSON: function() {
        return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.prototype.slice.call(this.array),
            normalized: this.normalized
        };
    }
});
function Int8BufferAttribute1(array, itemSize, normalized) {
    BufferAttribute2.call(this, new Int8Array(array), itemSize, normalized);
}
Int8BufferAttribute1.prototype = Object.create(BufferAttribute2.prototype);
Int8BufferAttribute1.prototype.constructor = Int8BufferAttribute1;
function Uint8BufferAttribute1(array, itemSize, normalized) {
    BufferAttribute2.call(this, new Uint8Array(array), itemSize, normalized);
}
Uint8BufferAttribute1.prototype = Object.create(BufferAttribute2.prototype);
Uint8BufferAttribute1.prototype.constructor = Uint8BufferAttribute1;
function Uint8ClampedBufferAttribute1(array, itemSize, normalized) {
    BufferAttribute2.call(this, new Uint8ClampedArray(array), itemSize, normalized);
}
Uint8ClampedBufferAttribute1.prototype = Object.create(BufferAttribute2.prototype);
Uint8ClampedBufferAttribute1.prototype.constructor = Uint8ClampedBufferAttribute1;
function Int16BufferAttribute1(array, itemSize, normalized) {
    BufferAttribute2.call(this, new Int16Array(array), itemSize, normalized);
}
Int16BufferAttribute1.prototype = Object.create(BufferAttribute2.prototype);
Int16BufferAttribute1.prototype.constructor = Int16BufferAttribute1;
function Uint16BufferAttribute2(array, itemSize, normalized) {
    BufferAttribute2.call(this, new Uint16Array(array), itemSize, normalized);
}
Uint16BufferAttribute2.prototype = Object.create(BufferAttribute2.prototype);
Uint16BufferAttribute2.prototype.constructor = Uint16BufferAttribute2;
function Int32BufferAttribute1(array, itemSize, normalized) {
    BufferAttribute2.call(this, new Int32Array(array), itemSize, normalized);
}
Int32BufferAttribute1.prototype = Object.create(BufferAttribute2.prototype);
Int32BufferAttribute1.prototype.constructor = Int32BufferAttribute1;
function Uint32BufferAttribute2(array, itemSize, normalized) {
    BufferAttribute2.call(this, new Uint32Array(array), itemSize, normalized);
}
Uint32BufferAttribute2.prototype = Object.create(BufferAttribute2.prototype);
Uint32BufferAttribute2.prototype.constructor = Uint32BufferAttribute2;
function Float32BufferAttribute2(array, itemSize, normalized) {
    BufferAttribute2.call(this, new Float32Array(array), itemSize, normalized);
}
Float32BufferAttribute2.prototype = Object.create(BufferAttribute2.prototype);
Float32BufferAttribute2.prototype.constructor = Float32BufferAttribute2;
function Float64BufferAttribute1(array, itemSize, normalized) {
    BufferAttribute2.call(this, new Float64Array(array), itemSize, normalized);
}
Float64BufferAttribute1.prototype = Object.create(BufferAttribute2.prototype);
Float64BufferAttribute1.prototype.constructor = Float64BufferAttribute1;
const Float32BufferAttribute1 = Float32BufferAttribute2, Uint32BufferAttribute1 = Uint32BufferAttribute2, Uint16BufferAttribute1 = Uint16BufferAttribute2, BufferAttribute1 = BufferAttribute2;
class Face32 {
    clone() {
        return new this.constructor().copy(this);
    }
    copy(source) {
        this.a = source.a;
        this.b = source.b;
        this.c = source.c;
        this.normal.copy(source.normal);
        this.color.copy(source.color);
        this.materialIndex = source.materialIndex;
        for(let i8 = 0, il = source.vertexNormals.length; i8 < il; i8++)this.vertexNormals[i8] = source.vertexNormals[i8].clone();
        for(let i8 = 0, il = source.vertexColors.length; i8 < il; i8++)this.vertexColors[i8] = source.vertexColors[i8].clone();
        return this;
    }
    constructor(a1, b1, c1, normal1, color9, materialIndex){
        this.a = a1;
        this.b = b1;
        this.c = c1;
        this.normal = normal1 && normal1.isVector3 ? normal1 : new Vector31();
        this.vertexNormals = Array.isArray(normal1) ? normal1 : [];
        this.color = color9 && color9.isColor ? color9 : new Color1();
        this.vertexColors = Array.isArray(color9) ? color9 : [];
        this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
    }
}
const Face31 = Face32;
export { Face31 as Face3 };
class Euler2 {
    get x() {
        return this._x;
    }
    set x(value) {
        this._x = value;
        this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(value) {
        this._y = value;
        this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(value) {
        this._z = value;
        this._onChangeCallback();
    }
    get order() {
        return this._order;
    }
    set order(value) {
        this._order = value;
        this._onChangeCallback();
    }
    set(x, y, z, order) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;
        this._onChangeCallback();
        return this;
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this._onChangeCallback();
        return this;
    }
    setFromRotationMatrix(m, order, update) {
        const clamp = MathUtils1.clamp;
        const te = m.elements;
        const m11 = te[0], m12 = te[4], m13 = te[8];
        const m21 = te[1], m22 = te[5], m23 = te[9];
        const m31 = te[2], m32 = te[6], m33 = te[10];
        order = order || this._order;
        switch(order){
            case 'XYZ':
                this._y = Math.asin(clamp(m13, -1, 1));
                if (Math.abs(m13) < 0.9999999) {
                    this._x = Math.atan2(-m23, m33);
                    this._z = Math.atan2(-m12, m11);
                } else {
                    this._x = Math.atan2(m32, m22);
                    this._z = 0;
                }
                break;
            case 'YXZ':
                this._x = Math.asin(-clamp(m23, -1, 1));
                if (Math.abs(m23) < 0.9999999) {
                    this._y = Math.atan2(m13, m33);
                    this._z = Math.atan2(m21, m22);
                } else {
                    this._y = Math.atan2(-m31, m11);
                    this._z = 0;
                }
                break;
            case 'ZXY':
                this._x = Math.asin(clamp(m32, -1, 1));
                if (Math.abs(m32) < 0.9999999) {
                    this._y = Math.atan2(-m31, m33);
                    this._z = Math.atan2(-m12, m22);
                } else {
                    this._y = 0;
                    this._z = Math.atan2(m21, m11);
                }
                break;
            case 'ZYX':
                this._y = Math.asin(-clamp(m31, -1, 1));
                if (Math.abs(m31) < 0.9999999) {
                    this._x = Math.atan2(m32, m33);
                    this._z = Math.atan2(m21, m11);
                } else {
                    this._x = 0;
                    this._z = Math.atan2(-m12, m22);
                }
                break;
            case 'YZX':
                this._z = Math.asin(clamp(m21, -1, 1));
                if (Math.abs(m21) < 0.9999999) {
                    this._x = Math.atan2(-m23, m22);
                    this._y = Math.atan2(-m31, m11);
                } else {
                    this._x = 0;
                    this._y = Math.atan2(m13, m33);
                }
                break;
            case 'XZY':
                this._z = Math.asin(-clamp(m12, -1, 1));
                if (Math.abs(m12) < 0.9999999) {
                    this._x = Math.atan2(m32, m22);
                    this._y = Math.atan2(m13, m11);
                } else {
                    this._x = Math.atan2(-m23, m33);
                    this._y = 0;
                }
                break;
            default:
                console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
        }
        this._order = order;
        if (update !== false) this._onChangeCallback();
        return this;
    }
    setFromQuaternion(q, order, update) {
        _matrix.makeRotationFromQuaternion(q);
        return this.setFromRotationMatrix(_matrix, order, update);
    }
    setFromVector3(v, order) {
        return this.set(v.x, v.y, v.z, order || this._order);
    }
    reorder(newOrder) {
        _quaternion2.setFromEuler(this);
        return this.setFromQuaternion(_quaternion2, newOrder);
    }
    equals(euler) {
        return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    }
    fromArray(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== undefined) this._order = array[3];
        this._onChangeCallback();
        return this;
    }
    toArray(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
    }
    toVector3(optionalResult) {
        if (optionalResult) return optionalResult.set(this._x, this._y, this._z);
        else return new Vector31(this._x, this._y, this._z);
    }
    _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
    }
    _onChangeCallback() {
    }
    constructor(x3 = 0, y3 = 0, z3 = 0, order1 = Euler2.DefaultOrder){
        this._x = x3;
        this._y = y3;
        this._z = z3;
        this._order = order1;
    }
}
Euler2.DefaultOrder = 'XYZ';
Euler2.RotationOrders = [
    'XYZ',
    'YZX',
    'ZXY',
    'XZY',
    'YXZ',
    'ZYX'
];
Euler2.prototype.isEuler = true;
const _matrix = new Matrix41();
const _quaternion2 = new Quaternion1();
const Euler1 = Euler2;
let _object3DId = 0;
const _v13 = new Vector31();
const _q1 = new Quaternion1();
const _m11 = new Matrix41();
const _target = new Vector31();
const _position = new Vector31();
const _scale = new Vector31();
const _quaternion1 = new Quaternion1();
const _xAxis = new Vector31(1, 0, 0);
const _yAxis = new Vector31(0, 1, 0);
const _zAxis = new Vector31(0, 0, 1);
const _addedEvent = {
    type: 'added'
};
const _removedEvent = {
    type: 'removed'
};
function Object3D2() {
    Object.defineProperty(this, 'id', {
        value: _object3DId++
    });
    this.uuid = MathUtils1.generateUUID();
    this.name = '';
    this.type = 'Object3D';
    this.parent = null;
    this.children = [];
    this.up = Object3D2.DefaultUp.clone();
    const position = new Vector31();
    const rotation = new Euler1();
    const quaternion = new Quaternion1();
    const scale = new Vector31(1, 1, 1);
    function onRotationChange() {
        quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
        rotation.setFromQuaternion(quaternion, undefined, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
        position: {
            configurable: true,
            enumerable: true,
            value: position
        },
        rotation: {
            configurable: true,
            enumerable: true,
            value: rotation
        },
        quaternion: {
            configurable: true,
            enumerable: true,
            value: quaternion
        },
        scale: {
            configurable: true,
            enumerable: true,
            value: scale
        },
        modelViewMatrix: {
            value: new Matrix41()
        },
        normalMatrix: {
            value: new Matrix31()
        }
    });
    this.matrix = new Matrix41();
    this.matrixWorld = new Matrix41();
    this.matrixAutoUpdate = Object3D2.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers1();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.userData = {
    };
}
Object3D2.DefaultUp = new Vector31(0, 1, 0);
Object3D2.DefaultMatrixAutoUpdate = true;
Object3D2.prototype = Object.assign(Object.create(EventDispatcher1.prototype), {
    constructor: Object3D2,
    isObject3D: true,
    onBeforeRender: function() {
    },
    onAfterRender: function() {
    },
    applyMatrix4: function(matrix) {
        if (this.matrixAutoUpdate) this.updateMatrix();
        this.matrix.premultiply(matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    applyQuaternion: function(q2) {
        this.quaternion.premultiply(q2);
        return this;
    },
    setRotationFromAxisAngle: function(axis, angle) {
        this.quaternion.setFromAxisAngle(axis, angle);
    },
    setRotationFromEuler: function(euler) {
        this.quaternion.setFromEuler(euler, true);
    },
    setRotationFromMatrix: function(m) {
        this.quaternion.setFromRotationMatrix(m);
    },
    setRotationFromQuaternion: function(q2) {
        this.quaternion.copy(q2);
    },
    rotateOnAxis: function(axis, angle) {
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(_q1);
        return this;
    },
    rotateOnWorldAxis: function(axis, angle) {
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.premultiply(_q1);
        return this;
    },
    rotateX: function(angle) {
        return this.rotateOnAxis(_xAxis, angle);
    },
    rotateY: function(angle) {
        return this.rotateOnAxis(_yAxis, angle);
    },
    rotateZ: function(angle) {
        return this.rotateOnAxis(_zAxis, angle);
    },
    translateOnAxis: function(axis, distance) {
        _v13.copy(axis).applyQuaternion(this.quaternion);
        this.position.add(_v13.multiplyScalar(distance));
        return this;
    },
    translateX: function(distance) {
        return this.translateOnAxis(_xAxis, distance);
    },
    translateY: function(distance) {
        return this.translateOnAxis(_yAxis, distance);
    },
    translateZ: function(distance) {
        return this.translateOnAxis(_zAxis, distance);
    },
    localToWorld: function(vector) {
        return vector.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function(vector) {
        return vector.applyMatrix4(_m11.getInverse(this.matrixWorld));
    },
    lookAt: function(x6, y6, z5) {
        if (x6.isVector3) _target.copy(x6);
        else _target.set(x6, y6, z5);
        const parent = this.parent;
        this.updateWorldMatrix(true, false);
        _position.setFromMatrixPosition(this.matrixWorld);
        if (this.isCamera || this.isLight) _m11.lookAt(_position, _target, this.up);
        else _m11.lookAt(_target, _position, this.up);
        this.quaternion.setFromRotationMatrix(_m11);
        if (parent) {
            _m11.extractRotation(parent.matrixWorld);
            _q1.setFromRotationMatrix(_m11);
            this.quaternion.premultiply(_q1.inverse());
        }
    },
    add: function(object) {
        if (arguments.length > 1) {
            for(let i8 = 0; i8 < arguments.length; i8++)this.add(arguments[i8]);
            return this;
        }
        if (object === this) {
            console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
            return this;
        }
        if (object && object.isObject3D) {
            if (object.parent !== null) object.parent.remove(object);
            object.parent = this;
            this.children.push(object);
            object.dispatchEvent(_addedEvent);
        } else console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
        return this;
    },
    remove: function(object) {
        if (arguments.length > 1) {
            for(let i8 = 0; i8 < arguments.length; i8++)this.remove(arguments[i8]);
            return this;
        }
        const index2 = this.children.indexOf(object);
        if (index2 !== -1) {
            object.parent = null;
            this.children.splice(index2, 1);
            object.dispatchEvent(_removedEvent);
        }
        return this;
    },
    attach: function(object) {
        this.updateWorldMatrix(true, false);
        _m11.getInverse(this.matrixWorld);
        if (object.parent !== null) {
            object.parent.updateWorldMatrix(true, false);
            _m11.multiply(object.parent.matrixWorld);
        }
        object.applyMatrix4(_m11);
        object.updateWorldMatrix(false, false);
        this.add(object);
        return this;
    },
    getObjectById: function(id) {
        return this.getObjectByProperty('id', id);
    },
    getObjectByName: function(name) {
        return this.getObjectByProperty('name', name);
    },
    getObjectByProperty: function(name, value2) {
        if (this[name] === value2) return this;
        for(let i8 = 0, l1 = this.children.length; i8 < l1; i8++){
            const child = this.children[i8];
            const object = child.getObjectByProperty(name, value2);
            if (object !== undefined) return object;
        }
        return undefined;
    },
    getWorldPosition: function(target) {
        if (target === undefined) {
            console.warn('THREE.Object3D: .getWorldPosition() target is now required');
            target = new Vector31();
        }
        this.updateMatrixWorld(true);
        return target.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function(target) {
        if (target === undefined) {
            console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');
            target = new Quaternion1();
        }
        this.updateMatrixWorld(true);
        this.matrixWorld.decompose(_position, target, _scale);
        return target;
    },
    getWorldScale: function(target) {
        if (target === undefined) {
            console.warn('THREE.Object3D: .getWorldScale() target is now required');
            target = new Vector31();
        }
        this.updateMatrixWorld(true);
        this.matrixWorld.decompose(_position, _quaternion1, target);
        return target;
    },
    getWorldDirection: function(target) {
        if (target === undefined) {
            console.warn('THREE.Object3D: .getWorldDirection() target is now required');
            target = new Vector31();
        }
        this.updateMatrixWorld(true);
        const e = this.matrixWorld.elements;
        return target.set(e[8], e[9], e[10]).normalize();
    },
    raycast: function() {
    },
    traverse: function(callback) {
        callback(this);
        const children = this.children;
        for(let i8 = 0, l1 = children.length; i8 < l1; i8++)children[i8].traverse(callback);
    },
    traverseVisible: function(callback) {
        if (this.visible === false) return;
        callback(this);
        const children = this.children;
        for(let i8 = 0, l1 = children.length; i8 < l1; i8++)children[i8].traverseVisible(callback);
    },
    traverseAncestors: function(callback) {
        const parent = this.parent;
        if (parent !== null) {
            callback(parent);
            parent.traverseAncestors(callback);
        }
    },
    updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
    },
    updateMatrixWorld: function(force) {
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || force) {
            if (this.parent === null) this.matrixWorld.copy(this.matrix);
            else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            this.matrixWorldNeedsUpdate = false;
            force = true;
        }
        const children = this.children;
        for(let i8 = 0, l1 = children.length; i8 < l1; i8++)children[i8].updateMatrixWorld(force);
    },
    updateWorldMatrix: function(updateParents, updateChildren) {
        const parent = this.parent;
        if (updateParents === true && parent !== null) parent.updateWorldMatrix(true, false);
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.parent === null) this.matrixWorld.copy(this.matrix);
        else this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        if (updateChildren === true) {
            const children = this.children;
            for(let i8 = 0, l1 = children.length; i8 < l1; i8++)children[i8].updateWorldMatrix(false, true);
        }
    },
    toJSON: function(meta) {
        const isRootObject = meta === undefined || typeof meta === 'string';
        const output = {
        };
        if (isRootObject) {
            meta = {
                geometries: {
                },
                materials: {
                },
                textures: {
                },
                images: {
                },
                shapes: {
                }
            };
            output.metadata = {
                version: 4.5,
                type: 'Object',
                generator: 'Object3D.toJSON'
            };
        }
        const object = {
        };
        object.uuid = this.uuid;
        object.type = this.type;
        if (this.name !== '') object.name = this.name;
        if (this.castShadow === true) object.castShadow = true;
        if (this.receiveShadow === true) object.receiveShadow = true;
        if (this.visible === false) object.visible = false;
        if (this.frustumCulled === false) object.frustumCulled = false;
        if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
        if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
        object.layers = this.layers.mask;
        object.matrix = this.matrix.toArray();
        if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
        if (this.isInstancedMesh) {
            object.type = 'InstancedMesh';
            object.count = this.count;
            object.instanceMatrix = this.instanceMatrix.toJSON();
        }
        function serialize(library, element) {
            if (library[element.uuid] === undefined) library[element.uuid] = element.toJSON(meta);
            return element.uuid;
        }
        if (this.isMesh || this.isLine || this.isPoints) {
            object.geometry = serialize(meta.geometries, this.geometry);
            const parameters1 = this.geometry.parameters;
            if (parameters1 !== undefined && parameters1.shapes !== undefined) {
                const shapes3 = parameters1.shapes;
                if (Array.isArray(shapes3)) for(let i8 = 0, l1 = shapes3.length; i8 < l1; i8++){
                    const shape = shapes3[i8];
                    serialize(meta.shapes, shape);
                }
                else serialize(meta.shapes, shapes3);
            }
        }
        if (this.material !== undefined) {
            if (Array.isArray(this.material)) {
                const uuids = [];
                for(let i8 = 0, l1 = this.material.length; i8 < l1; i8++)uuids.push(serialize(meta.materials, this.material[i8]));
                object.material = uuids;
            } else object.material = serialize(meta.materials, this.material);
        }
        if (this.children.length > 0) {
            object.children = [];
            for(let i8 = 0; i8 < this.children.length; i8++)object.children.push(this.children[i8].toJSON(meta).object);
        }
        if (isRootObject) {
            const geometries = extractFromCache(meta.geometries);
            const materials = extractFromCache(meta.materials);
            const textures = extractFromCache(meta.textures);
            const images = extractFromCache(meta.images);
            const shapes3 = extractFromCache(meta.shapes);
            if (geometries.length > 0) output.geometries = geometries;
            if (materials.length > 0) output.materials = materials;
            if (textures.length > 0) output.textures = textures;
            if (images.length > 0) output.images = images;
            if (shapes3.length > 0) output.shapes = shapes3;
        }
        output.object = object;
        var cache;
        return output;
    },
    clone: function(recursive) {
        return new this.constructor().copy(this, recursive);
    },
    copy: function(source, recursive) {
        if (recursive === undefined) recursive = true;
        this.name = source.name;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.rotation.order = source.rotation.order;
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.layers.mask = source.layers.mask;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) for(let i8 = 0; i8 < source.children.length; i8++){
            const child = source.children[i8];
            this.add(child.clone());
        }
        return this;
    }
});
const Object3D1 = Object3D2;
export { Object3D1 as Object3D };
function Raycaster(origin1, direction1, near, far) {
    this.ray = new Ray1(origin1, direction1);
    // direction is assumed to be normalized (for accurate distance calculations)
    this.near = near || 0;
    this.far = far || Infinity;
    this.camera = null;
    this.layers = new Layers1();
    this.params = {
        Mesh: {
        },
        Line: {
            threshold: 1
        },
        LOD: {
        },
        Points: {
            threshold: 1
        },
        Sprite: {
        }
    };
    Object.defineProperties(this.params, {
        PointCloud: {
            get: function() {
                console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');
                return this.Points;
            }
        }
    });
}
function ascSort(a2, b2) {
    return a2.distance - b2.distance;
}
function intersectObject(object, raycaster, intersects1, recursive) {
    if (object.layers.test(raycaster.layers)) object.raycast(raycaster, intersects1);
    if (recursive === true) {
        const children = object.children;
        for(let i8 = 0, l1 = children.length; i8 < l1; i8++)intersectObject(children[i8], raycaster, intersects1, true);
    }
}
Object.assign(Raycaster.prototype, {
    set: function(origin1, direction1) {
        // direction is assumed to be normalized (for accurate distance calculations)
        this.ray.set(origin1, direction1);
    },
    setFromCamera: function(coords, camera) {
        if (camera && camera.isPerspectiveCamera) {
            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
            this.camera = camera;
        } else if (camera && camera.isOrthographicCamera) {
            this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
            this.camera = camera;
        } else console.error('THREE.Raycaster: Unsupported camera type.');
    },
    intersectObject: function(object, recursive, optionalTarget) {
        const intersects1 = optionalTarget || [];
        intersectObject(object, this, intersects1, recursive);
        intersects1.sort(ascSort);
        return intersects1;
    },
    intersectObjects: function(objects, recursive, optionalTarget) {
        const intersects1 = optionalTarget || [];
        if (Array.isArray(objects) === false) {
            console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');
            return intersects1;
        }
        for(let i8 = 0, l1 = objects.length; i8 < l1; i8++)intersectObject(objects[i8], this, intersects1, recursive);
        intersects1.sort(ascSort);
        return intersects1;
    }
});
const Raycaster1 = Raycaster;
export { Raycaster1 as Raycaster };
class Layers2 {
    set(channel) {
        this.mask = 1 << channel | 0;
    }
    enable(channel) {
        this.mask |= 1 << channel | 0;
    }
    enableAll() {
        this.mask = -1;
    }
    toggle(channel) {
        this.mask ^= 1 << channel | 0;
    }
    disable(channel) {
        this.mask &= ~(1 << channel | 0);
    }
    disableAll() {
        this.mask = 0;
    }
    test(layers) {
        return (this.mask & layers.mask) !== 0;
    }
    constructor(){
        this.mask = 1;
    }
}
const Layers1 = Layers2;
export { Layers1 as Layers };
function EventDispatcher2() {
}
Object.assign(EventDispatcher2.prototype, {
    addEventListener: function(type, listener2) {
        if (this._listeners === undefined) this._listeners = {
        };
        const listeners = this._listeners;
        if (listeners[type] === undefined) listeners[type] = [];
        if (listeners[type].indexOf(listener2) === -1) listeners[type].push(listener2);
    },
    hasEventListener: function(type, listener2) {
        if (this._listeners === undefined) return false;
        const listeners = this._listeners;
        return listeners[type] !== undefined && listeners[type].indexOf(listener2) !== -1;
    },
    removeEventListener: function(type, listener2) {
        if (this._listeners === undefined) return;
        const listeners = this._listeners;
        const listenerArray = listeners[type];
        if (listenerArray !== undefined) {
            const index2 = listenerArray.indexOf(listener2);
            if (index2 !== -1) listenerArray.splice(index2, 1);
        }
    },
    dispatchEvent: function(event) {
        if (this._listeners === undefined) return;
        const listeners = this._listeners;
        const listenerArray = listeners[event.type];
        if (listenerArray !== undefined) {
            event.target = this;
            const array = listenerArray.slice(0);
            for(let i8 = 0, l1 = array.length; i8 < l1; i8++)array[i8].call(this, event);
        }
    }
});
const EventDispatcher1 = EventDispatcher2;
export { EventDispatcher1 as EventDispatcher };
class Clock2 {
    start() {
        this.startTime = (typeof performance === 'undefined' ? Date : performance).now();
        this.oldTime = this.startTime;
        this.elapsedTime = 0;
        this.running = true;
    }
    stop() {
        this.getElapsedTime();
        this.running = false;
        this.autoStart = false;
    }
    getElapsedTime() {
        this.getDelta();
        return this.elapsedTime;
    }
    getDelta() {
        let diff = 0;
        if (this.autoStart && !this.running) {
            this.start();
            return 0;
        }
        if (this.running) {
            const newTime = (typeof performance === 'undefined' ? Date : performance).now();
            diff = (newTime - this.oldTime) / 1000;
            this.oldTime = newTime;
            this.elapsedTime += diff;
        }
        return diff;
    }
    constructor(autoStart){
        this.autoStart = autoStart !== undefined ? autoStart : true;
        this.startTime = 0;
        this.oldTime = 0;
        this.elapsedTime = 0;
        this.running = false;
    }
}
const Clock1 = Clock2;
export { Clock1 as Clock };
function QuaternionLinearInterpolant4(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant1.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
QuaternionLinearInterpolant4.prototype = Object.assign(Object.create(Interpolant1.prototype), {
    constructor: QuaternionLinearInterpolant4,
    interpolate_: function(i12, t0, t2, t11) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t2 - t0) / (t11 - t0);
        let offset = i12 * stride;
        for(let end = offset + stride; offset !== end; offset += 4)Quaternion1.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
        return result;
    }
});
const QuaternionLinearInterpolant1 = QuaternionLinearInterpolant4;
export { QuaternionLinearInterpolant1 as QuaternionLinearInterpolant };
function LinearInterpolant2(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant1.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
LinearInterpolant2.prototype = Object.assign(Object.create(Interpolant1.prototype), {
    constructor: LinearInterpolant2,
    interpolate_: function(i12, t0, t2, t11) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i12 * stride, offset0 = offset1 - stride, weight1 = (t2 - t0) / (t11 - t0), weight0 = 1 - weight1;
        for(let i8 = 0; i8 !== stride; ++i8)result[i8] = values[offset0 + i8] * weight0 + values[offset1 + i8] * weight1;
        return result;
    }
});
const LinearInterpolant1 = LinearInterpolant2;
export { LinearInterpolant1 as LinearInterpolant };
function DiscreteInterpolant3(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant1.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}
DiscreteInterpolant3.prototype = Object.assign(Object.create(Interpolant1.prototype), {
    constructor: DiscreteInterpolant3,
    interpolate_: function(i12) {
        return this.copySampleValue_(i12 - 1);
    }
});
const DiscreteInterpolant1 = DiscreteInterpolant3;
export { DiscreteInterpolant1 as DiscreteInterpolant };
function CubicInterpolant3(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant1.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0.0;
    this._offsetPrev = -0.0;
    this._weightNext = -0.0;
    this._offsetNext = -0.0;
}
CubicInterpolant3.prototype = Object.assign(Object.create(Interpolant1.prototype), {
    constructor: CubicInterpolant3,
    DefaultSettings_: {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
    },
    intervalChanged_: function(i12, t0, t11) {
        const pp = this.parameterPositions;
        let iPrev = i12 - 2, iNext = i12 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
        if (tPrev === undefined) switch(this.getSettings_().endingStart){
            case ZeroSlopeEnding:
                iPrev = i12;
                tPrev = 2 * t0 - t11;
                break;
            case WrapAroundEnding:
                iPrev = pp.length - 2;
                tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                break;
            default:
                iPrev = i12;
                tPrev = t11;
        }
        if (tNext === undefined) switch(this.getSettings_().endingEnd){
            case ZeroSlopeEnding:
                iNext = i12;
                tNext = 2 * t11 - t0;
                break;
            case WrapAroundEnding:
                iNext = 1;
                tNext = t11 + pp[1] - pp[0];
                break;
            default:
                iNext = i12 - 1;
                tNext = t0;
        }
        const halfDt = (t11 - t0) * 0.5, stride = this.valueSize;
        this._weightPrev = halfDt / (t0 - tPrev);
        this._weightNext = halfDt / (tNext - t11);
        this._offsetPrev = iPrev * stride;
        this._offsetNext = iNext * stride;
    },
    interpolate_: function(i12, t0, t2, t11) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i12 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p1 = (t2 - t0) / (t11 - t0), pp = p1 * p1, ppp = pp * p1;
        const sP = -wP * ppp + 2 * wP * pp - wP * p1;
        const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p1 + 1;
        const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p1;
        const sN = wN * ppp - wN * pp;
        for(let i8 = 0; i8 !== stride; ++i8)result[i8] = sP * values[oP + i8] + s0 * values[o0 + i8] + s1 * values[o1 + i8] + sN * values[oN + i8];
        return result;
    }
});
const CubicInterpolant1 = CubicInterpolant3;
export { CubicInterpolant1 as CubicInterpolant };
function Interpolant2(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
}
Object.assign(Interpolant2.prototype, {
    evaluate: function(t2) {
        const pp = this.parameterPositions;
        let i12 = this._cachedIndex, t11 = pp[i12], t0 = pp[i12 - 1];
        validate_interval: {
            seek: {
                let right;
                linear_scan: {
                    forward_scan: if (!(t2 < t11)) {
                        for(let giveUpAt = i12 + 2;;){
                            if (t11 === undefined) {
                                if (t2 < t0) break forward_scan;
                                i12 = pp.length;
                                this._cachedIndex = i12;
                                return this.afterEnd_(i12 - 1, t2, t0);
                            }
                            if (i12 === giveUpAt) break;
                            t0 = t11;
                            t11 = pp[++i12];
                            if (t2 < t11) break seek;
                        }
                        right = pp.length;
                        break linear_scan;
                    }
                    if (!(t2 >= t0)) {
                        const t1global = pp[1];
                        if (t2 < t1global) {
                            i12 = 2;
                            t0 = t1global;
                        }
                        for(let giveUpAt = i12 - 2;;){
                            if (t0 === undefined) {
                                this._cachedIndex = 0;
                                return this.beforeStart_(0, t2, t11);
                            }
                            if (i12 === giveUpAt) break;
                            t11 = t0;
                            t0 = pp[(--i12) - 1];
                            if (t2 >= t0) break seek;
                        }
                        right = i12;
                        i12 = 0;
                        break linear_scan;
                    }
                    break validate_interval;
                }
                while(i12 < right){
                    const mid = i12 + right >>> 1;
                    if (t2 < pp[mid]) right = mid;
                    else i12 = mid + 1;
                }
                t11 = pp[i12];
                t0 = pp[i12 - 1];
                if (t0 === undefined) {
                    this._cachedIndex = 0;
                    return this.beforeStart_(0, t2, t11);
                }
                if (t11 === undefined) {
                    i12 = pp.length;
                    this._cachedIndex = i12;
                    return this.afterEnd_(i12 - 1, t0, t2);
                }
            }
            this._cachedIndex = i12;
            this.intervalChanged_(i12, t0, t11);
        }
        return this.interpolate_(i12, t0, t2, t11);
    },
    settings: null,
    DefaultSettings_: {
    },
    getSettings_: function() {
        return this.settings || this.DefaultSettings_;
    },
    copySampleValue_: function(index2) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index2 * stride;
        for(let i8 = 0; i8 !== stride; ++i8)result[i8] = values[offset + i8];
        return result;
    },
    interpolate_: function() {
        throw new Error('call to abstract method');
    },
    intervalChanged_: function() {
    }
});
Object.assign(Interpolant2.prototype, {
    beforeStart_: Interpolant2.prototype.copySampleValue_,
    afterEnd_: Interpolant2.prototype.copySampleValue_
});
const Interpolant1 = Interpolant2;
export { Interpolant1 as Interpolant };
const _v0 = new Vector31();
const _v11 = new Vector31();
const _v2 = new Vector31();
const _v3 = new Vector31();
const _vab = new Vector31();
const _vac = new Vector31();
const _vbc = new Vector31();
const _vap = new Vector31();
const _vbp = new Vector31();
const _vcp = new Vector31();
function Triangle2(a2, b2, c2) {
    this.a = a2 !== undefined ? a2 : new Vector31();
    this.b = b2 !== undefined ? b2 : new Vector31();
    this.c = c2 !== undefined ? c2 : new Vector31();
}
Object.assign(Triangle2, {
    getNormal: function(a2, b2, c2, target) {
        if (target === undefined) {
            console.warn('THREE.Triangle: .getNormal() target is now required');
            target = new Vector31();
        }
        target.subVectors(c2, b2);
        _v0.subVectors(a2, b2);
        target.cross(_v0);
        const targetLengthSq = target.lengthSq();
        if (targetLengthSq > 0) return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
        return target.set(0, 0, 0);
    },
    getBarycoord: function(point, a2, b2, c2, target) {
        _v0.subVectors(c2, a2);
        _v11.subVectors(b2, a2);
        _v2.subVectors(point, a2);
        const dot00 = _v0.dot(_v0);
        const dot01 = _v0.dot(_v11);
        const dot02 = _v0.dot(_v2);
        const dot11 = _v11.dot(_v11);
        const dot12 = _v11.dot(_v2);
        const denom = dot00 * dot11 - dot01 * dot01;
        if (target === undefined) {
            console.warn('THREE.Triangle: .getBarycoord() target is now required');
            target = new Vector31();
        }
        if (denom === 0) return target.set(-2, -1, -1);
        const invDenom = 1 / denom;
        const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return target.set(1 - u - v, v, u);
    },
    containsPoint: function(point, a2, b2, c2) {
        Triangle2.getBarycoord(point, a2, b2, c2, _v3);
        return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
    },
    getUV: function(point, p1, p2, p3, uv11, uv21, uv31, target) {
        this.getBarycoord(point, p1, p2, p3, _v3);
        target.set(0, 0);
        target.addScaledVector(uv11, _v3.x);
        target.addScaledVector(uv21, _v3.y);
        target.addScaledVector(uv31, _v3.z);
        return target;
    },
    isFrontFacing: function(a2, b2, c2, direction1) {
        _v0.subVectors(c2, b2);
        _v11.subVectors(a2, b2);
        return _v0.cross(_v11).dot(direction1) < 0 ? true : false;
    }
});
Object.assign(Triangle2.prototype, {
    set: function(a2, b2, c2) {
        this.a.copy(a2);
        this.b.copy(b2);
        this.c.copy(c2);
        return this;
    },
    setFromPointsAndIndices: function(points1, i0, i12, i22) {
        this.a.copy(points1[i0]);
        this.b.copy(points1[i12]);
        this.c.copy(points1[i22]);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
    },
    getArea: function() {
        _v0.subVectors(this.c, this.b);
        _v11.subVectors(this.a, this.b);
        return _v0.cross(_v11).length() * 0.5;
    },
    getMidpoint: function(target) {
        if (target === undefined) {
            console.warn('THREE.Triangle: .getMidpoint() target is now required');
            target = new Vector31();
        }
        return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    },
    getNormal: function(target) {
        return Triangle2.getNormal(this.a, this.b, this.c, target);
    },
    getPlane: function(target) {
        if (target === undefined) {
            console.warn('THREE.Triangle: .getPlane() target is now required');
            target = new Plane1();
        }
        return target.setFromCoplanarPoints(this.a, this.b, this.c);
    },
    getBarycoord: function(point, target) {
        return Triangle2.getBarycoord(point, this.a, this.b, this.c, target);
    },
    getUV: function(point, uv11, uv21, uv31, target) {
        return Triangle2.getUV(point, this.a, this.b, this.c, uv11, uv21, uv31, target);
    },
    containsPoint: function(point) {
        return Triangle2.containsPoint(point, this.a, this.b, this.c);
    },
    isFrontFacing: function(direction1) {
        return Triangle2.isFrontFacing(this.a, this.b, this.c, direction1);
    },
    intersectsBox: function(box) {
        return box.intersectsTriangle(this);
    },
    closestPointToPoint: function(p1, target) {
        if (target === undefined) {
            console.warn('THREE.Triangle: .closestPointToPoint() target is now required');
            target = new Vector31();
        }
        const a2 = this.a, b2 = this.b, c2 = this.c;
        let v, w3;
        _vab.subVectors(b2, a2);
        _vac.subVectors(c2, a2);
        _vap.subVectors(p1, a2);
        const d1 = _vab.dot(_vap);
        const d2 = _vac.dot(_vap);
        if (d1 <= 0 && d2 <= 0) return target.copy(a2);
        _vbp.subVectors(p1, b2);
        const d3 = _vab.dot(_vbp);
        const d4 = _vac.dot(_vbp);
        if (d3 >= 0 && d4 <= d3) return target.copy(b2);
        const vc = d1 * d4 - d3 * d2;
        if (vc <= 0 && d1 >= 0 && d3 <= 0) {
            v = d1 / (d1 - d3);
            return target.copy(a2).addScaledVector(_vab, v);
        }
        _vcp.subVectors(p1, c2);
        const d5 = _vab.dot(_vcp);
        const d6 = _vac.dot(_vcp);
        if (d6 >= 0 && d5 <= d6) return target.copy(c2);
        const vb = d5 * d2 - d1 * d6;
        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
            w3 = d2 / (d2 - d6);
            return target.copy(a2).addScaledVector(_vac, w3);
        }
        const va = d3 * d6 - d5 * d4;
        if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
            _vbc.subVectors(c2, b2);
            w3 = (d4 - d3) / (d4 - d3 + (d5 - d6));
            return target.copy(b2).addScaledVector(_vbc, w3);
        }
        const denom = 1 / (va + vb + vc);
        v = vb * denom;
        w3 = vc * denom;
        return target.copy(a2).addScaledVector(_vab, v).addScaledVector(_vac, w3);
    },
    equals: function(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
});
const Triangle1 = Triangle2;
export { Triangle1 as Triangle };
const _lut = [];
for(let i = 0; i < 256; i++)_lut[i] = (i < 16 ? '0' : '') + i.toString(16);
let _seed = 1234567;
const MathUtils2 = {
    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,
    generateUUID: function() {
        const d0 = Math.random() * 4294967295 | 0;
        const d1 = Math.random() * 4294967295 | 0;
        const d2 = Math.random() * 4294967295 | 0;
        const d3 = Math.random() * 4294967295 | 0;
        const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + '-' + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + '-' + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + '-' + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + '-' + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
        return uuid.toUpperCase();
    },
    clamp: function(value2, min, max) {
        return Math.max(min, Math.min(max, value2));
    },
    euclideanModulo: function(n, m) {
        return (n % m + m) % m;
    },
    mapLinear: function(x6, a12, a2, b12, b2) {
        return b12 + (x6 - a12) * (b2 - b12) / (a2 - a12);
    },
    lerp: function(x6, y6, t2) {
        return (1 - t2) * x6 + t2 * y6;
    },
    smoothstep: function(x6, min, max) {
        if (x6 <= min) return 0;
        if (x6 >= max) return 1;
        x6 = (x6 - min) / (max - min);
        return x6 * x6 * (3 - 2 * x6);
    },
    smootherstep: function(x6, min, max) {
        if (x6 <= min) return 0;
        if (x6 >= max) return 1;
        x6 = (x6 - min) / (max - min);
        return x6 * x6 * x6 * (x6 * (x6 * 6 - 15) + 10);
    },
    randInt: function(low, high) {
        return low + Math.floor(Math.random() * (high - low + 1));
    },
    randFloat: function(low, high) {
        return low + Math.random() * (high - low);
    },
    randFloatSpread: function(range) {
        return range * (0.5 - Math.random());
    },
    seededRandom: function(s1) {
        if (s1 !== undefined) _seed = s1 % 2147483647;
        _seed = _seed * 16807 % 2147483647;
        return (_seed - 1) / 2147483646;
    },
    degToRad: function(degrees) {
        return degrees * MathUtils2.DEG2RAD;
    },
    radToDeg: function(radians) {
        return radians * MathUtils2.RAD2DEG;
    },
    isPowerOfTwo: function(value2) {
        return (value2 & value2 - 1) === 0 && value2 !== 0;
    },
    ceilPowerOfTwo: function(value2) {
        return Math.pow(2, Math.ceil(Math.log(value2) / Math.LN2));
    },
    floorPowerOfTwo: function(value2) {
        return Math.pow(2, Math.floor(Math.log(value2) / Math.LN2));
    },
    setQuaternionFromProperEuler: function(q2, a2, b2, c2, order2) {
        const cos = Math.cos;
        const sin = Math.sin;
        const c2 = cos(b2 / 2);
        const s2 = sin(b2 / 2);
        const c13 = cos((a2 + c2) / 2);
        const s13 = sin((a2 + c2) / 2);
        const c1_3 = cos((a2 - c2) / 2);
        const s1_3 = sin((a2 - c2) / 2);
        const c3_1 = cos((c2 - a2) / 2);
        const s3_1 = sin((c2 - a2) / 2);
        switch(order2){
            case 'XYX':
                q2.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
                break;
            case 'YZY':
                q2.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
                break;
            case 'ZXZ':
                q2.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
                break;
            case 'XZX':
                q2.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
                break;
            case 'YXY':
                q2.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
                break;
            case 'ZYZ':
                q2.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
                break;
            default:
                console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order2);
        }
    }
};
const MathUtils1 = MathUtils2;
export { MathUtils1 as MathUtils };
class Spherical {
    set(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(other) {
        this.radius = other.radius;
        this.phi = other.phi;
        this.theta = other.theta;
        return this;
    }
    // restrict phi to be betwee EPS and PI-EPS
    makeSafe() {
        const EPS = 0.000001;
        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
        return this;
    }
    setFromVector3(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
    }
    setFromCartesianCoords(x, y, z) {
        this.radius = Math.sqrt(x * x + y * y + z * z);
        if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
        } else {
            this.theta = Math.atan2(x, z);
            this.phi = Math.acos(MathUtils1.clamp(y / this.radius, -1, 1));
        }
        return this;
    }
    constructor(radius12 = 1, phi1 = 0, theta1 = 0){
        this.radius = radius12;
        this.phi = phi1; // polar angle
        this.theta = theta1; // azimuthal angle
        return this;
    }
}
const Spherical1 = Spherical;
export { Spherical1 as Spherical };
/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */
function Cylindrical(radius13, theta1, y6) {
    this.radius = radius13 !== undefined ? radius13 : 1; // distance from the origin to a point in the x-z plane
    this.theta = theta1 !== undefined ? theta1 : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
    this.y = y6 !== undefined ? y6 : 0; // height above the x-z plane
    return this;
}
Object.assign(Cylindrical.prototype, {
    set: function(radius13, theta1, y6) {
        this.radius = radius13;
        this.theta = theta1;
        this.y = y6;
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(other) {
        this.radius = other.radius;
        this.theta = other.theta;
        this.y = other.y;
        return this;
    },
    setFromVector3: function(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
    },
    setFromCartesianCoords: function(x6, y6, z5) {
        this.radius = Math.sqrt(x6 * x6 + z5 * z5);
        this.theta = Math.atan2(x6, z5);
        this.y = y6;
        return this;
    }
});
const Cylindrical1 = Cylindrical;
export { Cylindrical1 as Cylindrical };
const _vector11 = new Vector31();
const _vector21 = new Vector31();
const _normalMatrix = new Matrix31();
function Plane2(normal6, constant) {
    this.normal = normal6 !== undefined ? normal6 : new Vector31(1, 0, 0);
    this.constant = constant !== undefined ? constant : 0;
}
Object.assign(Plane2.prototype, {
    isPlane: true,
    set: function(normal6, constant) {
        this.normal.copy(normal6);
        this.constant = constant;
        return this;
    },
    setComponents: function(x6, y6, z5, w3) {
        this.normal.set(x6, y6, z5);
        this.constant = w3;
        return this;
    },
    setFromNormalAndCoplanarPoint: function(normal6, point) {
        this.normal.copy(normal6);
        this.constant = -point.dot(this.normal);
        return this;
    },
    setFromCoplanarPoints: function(a2, b2, c2) {
        const normal6 = _vector11.subVectors(c2, b2).cross(_vector21.subVectors(a2, b2)).normalize();
        this.setFromNormalAndCoplanarPoint(normal6, a2);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
    },
    normalize: function() {
        const inverseNormalLength = 1 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
    },
    negate: function() {
        this.constant *= -1;
        this.normal.negate();
        return this;
    },
    distanceToPoint: function(point) {
        return this.normal.dot(point) + this.constant;
    },
    distanceToSphere: function(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
    },
    projectPoint: function(point, target) {
        if (target === undefined) {
            console.warn('THREE.Plane: .projectPoint() target is now required');
            target = new Vector31();
        }
        return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
    },
    intersectLine: function(line, target) {
        if (target === undefined) {
            console.warn('THREE.Plane: .intersectLine() target is now required');
            target = new Vector31();
        }
        const direction1 = line.delta(_vector11);
        const denominator = this.normal.dot(direction1);
        if (denominator === 0) {
            if (this.distanceToPoint(line.start) === 0) return target.copy(line.start);
            return undefined;
        }
        const t2 = -(line.start.dot(this.normal) + this.constant) / denominator;
        if (t2 < 0 || t2 > 1) return undefined;
        return target.copy(direction1).multiplyScalar(t2).add(line.start);
    },
    intersectsLine: function(line) {
        const startSign = this.distanceToPoint(line.start);
        const endSign = this.distanceToPoint(line.end);
        return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    },
    intersectsBox: function(box) {
        return box.intersectsPlane(this);
    },
    intersectsSphere: function(sphere) {
        return sphere.intersectsPlane(this);
    },
    coplanarPoint: function(target) {
        if (target === undefined) {
            console.warn('THREE.Plane: .coplanarPoint() target is now required');
            target = new Vector31();
        }
        return target.copy(this.normal).multiplyScalar(-this.constant);
    },
    applyMatrix4: function(matrix, optionalNormalMatrix) {
        const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
        const referencePoint = this.coplanarPoint(_vector11).applyMatrix4(matrix);
        const normal6 = this.normal.applyMatrix3(normalMatrix).normalize();
        this.constant = -referencePoint.dot(normal6);
        return this;
    },
    translate: function(offset) {
        this.constant -= offset.dot(this.normal);
        return this;
    },
    equals: function(plane) {
        return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
});
const Plane1 = Plane2;
export { Plane1 as Plane };
const _sphere1 = new Sphere1();
const _vector3 = new Vector31();
function Frustum2(p0, p1, p2, p3, p4, p5) {
    this.planes = [
        p0 !== undefined ? p0 : new Plane1(),
        p1 !== undefined ? p1 : new Plane1(),
        p2 !== undefined ? p2 : new Plane1(),
        p3 !== undefined ? p3 : new Plane1(),
        p4 !== undefined ? p4 : new Plane1(),
        p5 !== undefined ? p5 : new Plane1()
    ];
}
Object.assign(Frustum2.prototype, {
    set: function(p0, p1, p2, p3, p4, p5) {
        const planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(frustum) {
        const planes = this.planes;
        for(let i8 = 0; i8 < 6; i8++)planes[i8].copy(frustum.planes[i8]);
        return this;
    },
    setFromProjectionMatrix: function(m) {
        const planes = this.planes;
        const me = m.elements;
        const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
        const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
        const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
        const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
    },
    intersectsObject: function(object) {
        const geometry = object.geometry;
        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
        return this.intersectsSphere(_sphere1);
    },
    intersectsSprite: function(sprite) {
        _sphere1.center.set(0, 0, 0);
        _sphere1.radius = 0.7071067811865476;
        _sphere1.applyMatrix4(sprite.matrixWorld);
        return this.intersectsSphere(_sphere1);
    },
    intersectsSphere: function(sphere) {
        const planes = this.planes;
        const center1 = sphere.center;
        const negRadius = -sphere.radius;
        for(let i8 = 0; i8 < 6; i8++){
            const distance = planes[i8].distanceToPoint(center1);
            if (distance < negRadius) return false;
        }
        return true;
    },
    intersectsBox: function(box) {
        const planes = this.planes;
        for(let i8 = 0; i8 < 6; i8++){
            const plane = planes[i8];
            _vector3.x = plane.normal.x > 0 ? box.max.x : box.min.x;
            _vector3.y = plane.normal.y > 0 ? box.max.y : box.min.y;
            _vector3.z = plane.normal.z > 0 ? box.max.z : box.min.z;
            if (plane.distanceToPoint(_vector3) < 0) return false;
        }
        return true;
    },
    containsPoint: function(point) {
        const planes = this.planes;
        for(let i8 = 0; i8 < 6; i8++)if (planes[i8].distanceToPoint(point) < 0) return false;
        return true;
    }
});
const Frustum1 = Frustum2;
export { Frustum1 as Frustum };
const _box = new Box31();
function Sphere2(center1, radius13) {
    this.center = center1 !== undefined ? center1 : new Vector31();
    this.radius = radius13 !== undefined ? radius13 : -1;
}
Object.assign(Sphere2.prototype, {
    set: function(center1, radius13) {
        this.center.copy(center1);
        this.radius = radius13;
        return this;
    },
    setFromPoints: function(points1, optionalCenter) {
        const center1 = this.center;
        if (optionalCenter !== undefined) center1.copy(optionalCenter);
        else _box.setFromPoints(points1).getCenter(center1);
        let maxRadiusSq = 0;
        for(let i8 = 0, il = points1.length; i8 < il; i8++)maxRadiusSq = Math.max(maxRadiusSq, center1.distanceToSquared(points1[i8]));
        this.radius = Math.sqrt(maxRadiusSq);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
    },
    isEmpty: function() {
        return this.radius < 0;
    },
    makeEmpty: function() {
        this.center.set(0, 0, 0);
        this.radius = -1;
        return this;
    },
    containsPoint: function(point) {
        return point.distanceToSquared(this.center) <= this.radius * this.radius;
    },
    distanceToPoint: function(point) {
        return point.distanceTo(this.center) - this.radius;
    },
    intersectsSphere: function(sphere) {
        const radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    },
    intersectsBox: function(box) {
        return box.intersectsSphere(this);
    },
    intersectsPlane: function(plane) {
        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    },
    clampPoint: function(point, target) {
        const deltaLengthSq = this.center.distanceToSquared(point);
        if (target === undefined) {
            console.warn('THREE.Sphere: .clampPoint() target is now required');
            target = new Vector31();
        }
        target.copy(point);
        if (deltaLengthSq > this.radius * this.radius) {
            target.sub(this.center).normalize();
            target.multiplyScalar(this.radius).add(this.center);
        }
        return target;
    },
    getBoundingBox: function(target) {
        if (target === undefined) {
            console.warn('THREE.Sphere: .getBoundingBox() target is now required');
            target = new Box31();
        }
        if (this.isEmpty()) {
            target.makeEmpty();
            return target;
        }
        target.set(this.center, this.center);
        target.expandByScalar(this.radius);
        return target;
    },
    applyMatrix4: function(matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
    },
    translate: function(offset) {
        this.center.add(offset);
        return this;
    },
    equals: function(sphere) {
        return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
});
const Sphere1 = Sphere2;
export { Sphere1 as Sphere };
const _vector1 = new Vector31();
const _segCenter = new Vector31();
const _segDir = new Vector31();
const _diff = new Vector31();
const _edge1 = new Vector31();
const _edge2 = new Vector31();
const _normal = new Vector31();
class Ray2 {
    set(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
    }
    clone() {
        return new this.constructor().copy(this);
    }
    copy(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
    }
    at(t, target) {
        if (target === undefined) {
            console.warn('THREE.Ray: .at() target is now required');
            target = new Vector31();
        }
        return target.copy(this.direction).multiplyScalar(t).add(this.origin);
    }
    lookAt(v) {
        this.direction.copy(v).sub(this.origin).normalize();
        return this;
    }
    recast(t) {
        this.origin.copy(this.at(t, _vector1));
        return this;
    }
    closestPointToPoint(point, target) {
        if (target === undefined) {
            console.warn('THREE.Ray: .closestPointToPoint() target is now required');
            target = new Vector31();
        }
        target.subVectors(point, this.origin);
        const directionDistance = target.dot(this.direction);
        if (directionDistance < 0) return target.copy(this.origin);
        return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    }
    distanceToPoint(point) {
        return Math.sqrt(this.distanceSqToPoint(point));
    }
    distanceSqToPoint(point) {
        const directionDistance = _vector1.subVectors(point, this.origin).dot(this.direction);
        if (directionDistance < 0) return this.origin.distanceToSquared(point);
        _vector1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        return _vector1.distanceToSquared(point);
    }
    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
        _segDir.copy(v1).sub(v0).normalize();
        _diff.copy(this.origin).sub(_segCenter);
        const segExtent = v0.distanceTo(v1) * 0.5;
        const a01 = -this.direction.dot(_segDir);
        const b0 = _diff.dot(this.direction);
        const b12 = -_diff.dot(_segDir);
        const c2 = _diff.lengthSq();
        const det = Math.abs(1 - a01 * a01);
        let s0, s1, sqrDist, extDet;
        if (det > 0) {
            s0 = a01 * b12 - b0;
            s1 = a01 * b0 - b12;
            extDet = segExtent * det;
            if (s0 >= 0) {
                if (s1 >= -extDet) {
                    if (s1 <= extDet) {
                        const invDet = 1 / det;
                        s0 *= invDet;
                        s1 *= invDet;
                        sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b12) + c2;
                    } else {
                        s1 = segExtent;
                        s0 = Math.max(0, -(a01 * s1 + b0));
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b12) + c2;
                    }
                } else {
                    s1 = -segExtent;
                    s0 = Math.max(0, -(a01 * s1 + b0));
                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b12) + c2;
                }
            } else if (s1 <= -extDet) {
                s0 = Math.max(0, -(-a01 * segExtent + b0));
                s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b12), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b12) + c2;
            } else if (s1 <= extDet) {
                s0 = 0;
                s1 = Math.min(Math.max(-segExtent, -b12), segExtent);
                sqrDist = s1 * (s1 + 2 * b12) + c2;
            } else {
                s0 = Math.max(0, -(a01 * segExtent + b0));
                s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b12), segExtent);
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b12) + c2;
            }
        } else {
            s1 = a01 > 0 ? -segExtent : segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b12) + c2;
        }
        if (optionalPointOnRay) optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
        if (optionalPointOnSegment) optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
        return sqrDist;
    }
    intersectSphere(sphere, target) {
        _vector1.subVectors(sphere.center, this.origin);
        const tca = _vector1.dot(this.direction);
        const d2 = _vector1.dot(_vector1) - tca * tca;
        const radius21 = sphere.radius * sphere.radius;
        if (d2 > radius21) return null;
        const thc = Math.sqrt(radius21 - d2);
        const t0 = tca - thc;
        const t11 = tca + thc;
        if (t0 < 0 && t11 < 0) return null;
        if (t0 < 0) return this.at(t11, target);
        return this.at(t0, target);
    }
    intersectsSphere(sphere) {
        return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    }
    distanceToPlane(plane) {
        const denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {
            if (plane.distanceToPoint(this.origin) === 0) return 0;
            return null;
        }
        const t3 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        return t3 >= 0 ? t3 : null;
    }
    intersectPlane(plane, target) {
        const t3 = this.distanceToPlane(plane);
        if (t3 === null) return null;
        return this.at(t3, target);
    }
    intersectsPlane(plane) {
        const distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) return true;
        const denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) return true;
        return false;
    }
    intersectBox(box, target) {
        let tmin, tmax, tymin, tymax, tzmin, tzmax;
        const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
        const origin2 = this.origin;
        if (invdirx >= 0) {
            tmin = (box.min.x - origin2.x) * invdirx;
            tmax = (box.max.x - origin2.x) * invdirx;
        } else {
            tmin = (box.max.x - origin2.x) * invdirx;
            tmax = (box.min.x - origin2.x) * invdirx;
        }
        if (invdiry >= 0) {
            tymin = (box.min.y - origin2.y) * invdiry;
            tymax = (box.max.y - origin2.y) * invdiry;
        } else {
            tymin = (box.max.y - origin2.y) * invdiry;
            tymax = (box.min.y - origin2.y) * invdiry;
        }
        if (tmin > tymax || tymin > tmax) return null;
        if (tymin > tmin || tmin !== tmin) tmin = tymin;
        if (tymax < tmax || tmax !== tmax) tmax = tymax;
        if (invdirz >= 0) {
            tzmin = (box.min.z - origin2.z) * invdirz;
            tzmax = (box.max.z - origin2.z) * invdirz;
        } else {
            tzmin = (box.max.z - origin2.z) * invdirz;
            tzmax = (box.min.z - origin2.z) * invdirz;
        }
        if (tmin > tzmax || tzmin > tmax) return null;
        if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
        if (tmax < 0) return null;
        return this.at(tmin >= 0 ? tmin : tmax, target);
    }
    intersectsBox(box) {
        return this.intersectBox(box, _vector1) !== null;
    }
    intersectTriangle(a, b, c, backfaceCulling, target) {
        _edge1.subVectors(b, a);
        _edge2.subVectors(c, a);
        _normal.crossVectors(_edge1, _edge2);
        let DdN = this.direction.dot(_normal);
        let sign1;
        if (DdN > 0) {
            if (backfaceCulling) return null;
            sign1 = 1;
        } else if (DdN < 0) {
            sign1 = -1;
            DdN = -DdN;
        } else return null;
        _diff.subVectors(this.origin, a);
        const DdQxE2 = sign1 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
        if (DdQxE2 < 0) return null;
        const DdE1xQ = sign1 * this.direction.dot(_edge1.cross(_diff));
        if (DdE1xQ < 0) return null;
        if (DdQxE2 + DdE1xQ > DdN) return null;
        const QdN = -sign1 * _diff.dot(_normal);
        if (QdN < 0) return null;
        return this.at(QdN / DdN, target);
    }
    applyMatrix4(matrix4) {
        this.origin.applyMatrix4(matrix4);
        this.direction.transformDirection(matrix4);
        return this;
    }
    equals(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
    constructor(origin1, direction1){
        this.origin = origin1 !== undefined ? origin1 : new Vector31();
        this.direction = direction1 !== undefined ? direction1 : new Vector31(0, 0, -1);
    }
}
const Ray1 = Ray2;
export { Ray1 as Ray };
class Matrix42 {
    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        const te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
    }
    identity() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    }
    clone() {
        return new Matrix42().fromArray(this.elements);
    }
    copy(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        te[9] = me[9];
        te[10] = me[10];
        te[11] = me[11];
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        te[15] = me[15];
        return this;
    }
    copyPosition(m) {
        const te = this.elements, me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
    }
    makeBasis(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
    }
    extractRotation(m) {
        const te = this.elements;
        const me = m.elements;
        const scaleX = 1 / _v12.setFromMatrixColumn(m, 0).length();
        const scaleY = 1 / _v12.setFromMatrixColumn(m, 1).length();
        const scaleZ = 1 / _v12.setFromMatrixColumn(m, 2).length();
        te[0] = me[0] * scaleX;
        te[1] = me[1] * scaleX;
        te[2] = me[2] * scaleX;
        te[3] = 0;
        te[4] = me[4] * scaleY;
        te[5] = me[5] * scaleY;
        te[6] = me[6] * scaleY;
        te[7] = 0;
        te[8] = me[8] * scaleZ;
        te[9] = me[9] * scaleZ;
        te[10] = me[10] * scaleZ;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    }
    makeRotationFromEuler(euler) {
        if (!(euler && euler.isEuler)) console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
        const te = this.elements;
        const x6 = euler.x, y6 = euler.y, z5 = euler.z;
        const a2 = Math.cos(x6), b2 = Math.sin(x6);
        const c2 = Math.cos(y6), d = Math.sin(y6);
        const e = Math.cos(z5), f = Math.sin(z5);
        if (euler.order === 'XYZ') {
            const ae = a2 * e, af = a2 * f, be = b2 * e, bf = b2 * f;
            te[0] = c2 * e;
            te[4] = -c2 * f;
            te[8] = d;
            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b2 * c2;
            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a2 * c2;
        } else if (euler.order === 'YXZ') {
            const ce = c2 * e, cf = c2 * f, de = d * e, df = d * f;
            te[0] = ce + df * b2;
            te[4] = de * b2 - cf;
            te[8] = a2 * d;
            te[1] = a2 * f;
            te[5] = a2 * e;
            te[9] = -b2;
            te[2] = cf * b2 - de;
            te[6] = df + ce * b2;
            te[10] = a2 * c2;
        } else if (euler.order === 'ZXY') {
            const ce = c2 * e, cf = c2 * f, de = d * e, df = d * f;
            te[0] = ce - df * b2;
            te[4] = -a2 * f;
            te[8] = de + cf * b2;
            te[1] = cf + de * b2;
            te[5] = a2 * e;
            te[9] = df - ce * b2;
            te[2] = -a2 * d;
            te[6] = b2;
            te[10] = a2 * c2;
        } else if (euler.order === 'ZYX') {
            const ae = a2 * e, af = a2 * f, be = b2 * e, bf = b2 * f;
            te[0] = c2 * e;
            te[4] = be * d - af;
            te[8] = ae * d + bf;
            te[1] = c2 * f;
            te[5] = bf * d + ae;
            te[9] = af * d - be;
            te[2] = -d;
            te[6] = b2 * c2;
            te[10] = a2 * c2;
        } else if (euler.order === 'YZX') {
            const ac = a2 * c2, ad = a2 * d, bc = b2 * c2, bd = b2 * d;
            te[0] = c2 * e;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;
            te[1] = f;
            te[5] = a2 * e;
            te[9] = -b2 * e;
            te[2] = -d * e;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
        } else if (euler.order === 'XZY') {
            const ac = a2 * c2, ad = a2 * d, bc = b2 * c2, bd = b2 * d;
            te[0] = c2 * e;
            te[4] = -f;
            te[8] = d * e;
            te[1] = ac * f + bd;
            te[5] = a2 * e;
            te[9] = ad * f - bc;
            te[2] = bc * f - ad;
            te[6] = b2 * e;
            te[10] = bd * f + ac;
        }
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
    }
    makeRotationFromQuaternion(q) {
        return this.compose(_zero, q, _one);
    }
    lookAt(eye, target, up) {
        const te = this.elements;
        _z.subVectors(eye, target);
        if (_z.lengthSq() === 0) _z.z = 1;
        _z.normalize();
        _x.crossVectors(up, _z);
        if (_x.lengthSq() === 0) {
            if (Math.abs(up.z) === 1) _z.x += 0.0001;
            else _z.z += 0.0001;
            _z.normalize();
            _x.crossVectors(up, _z);
        }
        _x.normalize();
        _y.crossVectors(_z, _x);
        te[0] = _x.x;
        te[4] = _y.x;
        te[8] = _z.x;
        te[1] = _x.y;
        te[5] = _y.y;
        te[9] = _z.y;
        te[2] = _x.z;
        te[6] = _y.z;
        te[10] = _z.z;
        return this;
    }
    multiply(m, n) {
        if (n !== undefined) {
            console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
            return this.multiplyMatrices(m, n);
        }
        return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
        return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a111 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
        const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
        const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
        const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
        const b111 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
        const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
        const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
        const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
        te[0] = a111 * b111 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a111 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a111 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a111 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b111 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b111 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b111 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
    }
    multiplyScalar(s) {
        const te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
    }
    determinant() {
        const te = this.elements;
        const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
        const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
        const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
        const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
        return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    }
    transpose() {
        const te = this.elements;
        let tmp1;
        tmp1 = te[1];
        te[1] = te[4];
        te[4] = tmp1;
        tmp1 = te[2];
        te[2] = te[8];
        te[8] = tmp1;
        tmp1 = te[6];
        te[6] = te[9];
        te[9] = tmp1;
        tmp1 = te[3];
        te[3] = te[12];
        te[12] = tmp1;
        tmp1 = te[7];
        te[7] = te[13];
        te[13] = tmp1;
        tmp1 = te[11];
        te[11] = te[14];
        te[14] = tmp1;
        return this;
    }
    setPosition(x, y, z) {
        const te = this.elements;
        if (x.isVector3) {
            te[12] = x.x;
            te[13] = x.y;
            te[14] = x.z;
        } else {
            te[12] = x;
            te[13] = y;
            te[14] = z;
        }
        return this;
    }
    getInverse(m, throwOnDegenerate) {
        if (throwOnDegenerate !== undefined) console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");
        const te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
        te[4] = t12 * detInv;
        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
        te[8] = t13 * detInv;
        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
        te[12] = t14 * detInv;
        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
        return this;
    }
    scale(v) {
        const te = this.elements;
        const x6 = v.x, y6 = v.y, z5 = v.z;
        te[0] *= x6;
        te[4] *= y6;
        te[8] *= z5;
        te[1] *= x6;
        te[5] *= y6;
        te[9] *= z5;
        te[2] *= x6;
        te[6] *= y6;
        te[10] *= z5;
        te[3] *= x6;
        te[7] *= y6;
        te[11] *= z5;
        return this;
    }
    getMaxScaleOnAxis() {
        const te = this.elements;
        const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    }
    makeTranslation(x, y, z) {
        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
    }
    makeRotationX(theta) {
        const c2 = Math.cos(theta), s2 = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c2, -s2, 0, 0, s2, c2, 0, 0, 0, 0, 1);
        return this;
    }
    makeRotationY(theta) {
        const c2 = Math.cos(theta), s2 = Math.sin(theta);
        this.set(c2, 0, s2, 0, 0, 1, 0, 0, -s2, 0, c2, 0, 0, 0, 0, 1);
        return this;
    }
    makeRotationZ(theta) {
        const c2 = Math.cos(theta), s2 = Math.sin(theta);
        this.set(c2, -s2, 0, 0, s2, c2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
    }
    makeRotationAxis(axis, angle) {
        const c2 = Math.cos(angle);
        const s2 = Math.sin(angle);
        const t3 = 1 - c2;
        const x6 = axis.x, y6 = axis.y, z5 = axis.z;
        const tx = t3 * x6, ty = t3 * y6;
        this.set(tx * x6 + c2, tx * y6 - s2 * z5, tx * z5 + s2 * y6, 0, tx * y6 + s2 * z5, ty * y6 + c2, ty * z5 - s2 * x6, 0, tx * z5 - s2 * y6, ty * z5 + s2 * x6, t3 * z5 * z5 + c2, 0, 0, 0, 0, 1);
        return this;
    }
    makeScale(x, y, z) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
    }
    makeShear(x, y, z) {
        this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
        return this;
    }
    compose(position, quaternion, scale) {
        const te = this.elements;
        const x6 = quaternion._x, y6 = quaternion._y, z5 = quaternion._z, w3 = quaternion._w;
        const x21 = x6 + x6, y21 = y6 + y6, z21 = z5 + z5;
        const xx = x6 * x21, xy = x6 * y21, xz = x6 * z21;
        const yy = y6 * y21, yz = y6 * z21, zz = z5 * z21;
        const wx = w3 * x21, wy = w3 * y21, wz = w3 * z21;
        const sx = scale.x, sy = scale.y, sz = scale.z;
        te[0] = (1 - (yy + zz)) * sx;
        te[1] = (xy + wz) * sx;
        te[2] = (xz - wy) * sx;
        te[3] = 0;
        te[4] = (xy - wz) * sy;
        te[5] = (1 - (xx + zz)) * sy;
        te[6] = (yz + wx) * sy;
        te[7] = 0;
        te[8] = (xz + wy) * sz;
        te[9] = (yz - wx) * sz;
        te[10] = (1 - (xx + yy)) * sz;
        te[11] = 0;
        te[12] = position.x;
        te[13] = position.y;
        te[14] = position.z;
        te[15] = 1;
        return this;
    }
    decompose(position, quaternion, scale) {
        const te = this.elements;
        let sx = _v12.set(te[0], te[1], te[2]).length();
        const sy = _v12.set(te[4], te[5], te[6]).length();
        const sz = _v12.set(te[8], te[9], te[10]).length();
        const det = this.determinant();
        if (det < 0) sx = -sx;
        position.x = te[12];
        position.y = te[13];
        position.z = te[14];
        _m1.copy(this);
        const invSX = 1 / sx;
        const invSY = 1 / sy;
        const invSZ = 1 / sz;
        _m1.elements[0] *= invSX;
        _m1.elements[1] *= invSX;
        _m1.elements[2] *= invSX;
        _m1.elements[4] *= invSY;
        _m1.elements[5] *= invSY;
        _m1.elements[6] *= invSY;
        _m1.elements[8] *= invSZ;
        _m1.elements[9] *= invSZ;
        _m1.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix(_m1);
        scale.x = sx;
        scale.y = sy;
        scale.z = sz;
        return this;
    }
    makePerspective(left, right, top, bottom, near, far) {
        if (far === undefined) console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
        const te = this.elements;
        const x6 = 2 * near / (right - left);
        const y6 = 2 * near / (top - bottom);
        const a2 = (right + left) / (right - left);
        const b2 = (top + bottom) / (top - bottom);
        const c2 = -(far + near) / (far - near);
        const d = -2 * far * near / (far - near);
        te[0] = x6;
        te[4] = 0;
        te[8] = a2;
        te[12] = 0;
        te[1] = 0;
        te[5] = y6;
        te[9] = b2;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c2;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
    }
    makeOrthographic(left, right, top, bottom, near, far) {
        const te = this.elements;
        const w3 = 1 / (right - left);
        const h = 1 / (top - bottom);
        const p1 = 1 / (far - near);
        const x6 = (right + left) * w3;
        const y6 = (top + bottom) * h;
        const z5 = (far + near) * p1;
        te[0] = 2 * w3;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x6;
        te[1] = 0;
        te[5] = 2 * h;
        te[9] = 0;
        te[13] = -y6;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 * p1;
        te[14] = -z5;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
    }
    equals(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for(let i8 = 0; i8 < 16; i8++)if (te[i8] !== me[i8]) return false;
        return true;
    }
    fromArray(array, offset) {
        if (offset === undefined) offset = 0;
        for(let i8 = 0; i8 < 16; i8++)this.elements[i8] = array[i8 + offset];
        return this;
    }
    toArray(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
    }
    constructor(){
        this.elements = [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ];
        if (arguments.length > 0) console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
    }
}
Matrix42.prototype.isMatrix4 = true;
const _v12 = new Vector31();
const _m1 = new Matrix42();
const _zero = new Vector31(0, 0, 0);
const _one = new Vector31(1, 1, 1);
const _x = new Vector31();
const _y = new Vector31();
const _z = new Vector31();
const Matrix41 = Matrix42;
export { Matrix41 as Matrix4 };
class Matrix32 {
    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        const te = this.elements;
        te[0] = n11;
        te[1] = n21;
        te[2] = n31;
        te[3] = n12;
        te[4] = n22;
        te[5] = n32;
        te[6] = n13;
        te[7] = n23;
        te[8] = n33;
        return this;
    }
    identity() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
    }
    clone() {
        return new this.constructor().fromArray(this.elements);
    }
    copy(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrix3Column(this, 0);
        yAxis.setFromMatrix3Column(this, 1);
        zAxis.setFromMatrix3Column(this, 2);
        return this;
    }
    setFromMatrix4(m) {
        const me = m.elements;
        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
        return this;
    }
    multiply(m) {
        return this.multiplyMatrices(this, m);
    }
    premultiply(m) {
        return this.multiplyMatrices(m, this);
    }
    multiplyMatrices(a, b) {
        const ae = a.elements;
        const be = b.elements;
        const te = this.elements;
        const a111 = ae[0], a12 = ae[3], a13 = ae[6];
        const a21 = ae[1], a22 = ae[4], a23 = ae[7];
        const a31 = ae[2], a32 = ae[5], a33 = ae[8];
        const b111 = be[0], b12 = be[3], b13 = be[6];
        const b21 = be[1], b22 = be[4], b23 = be[7];
        const b31 = be[2], b32 = be[5], b33 = be[8];
        te[0] = a111 * b111 + a12 * b21 + a13 * b31;
        te[3] = a111 * b12 + a12 * b22 + a13 * b32;
        te[6] = a111 * b13 + a12 * b23 + a13 * b33;
        te[1] = a21 * b111 + a22 * b21 + a23 * b31;
        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
        te[2] = a31 * b111 + a32 * b21 + a33 * b31;
        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
    }
    multiplyScalar(s) {
        const te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
    }
    determinant() {
        const te = this.elements;
        const a2 = te[0], b2 = te[1], c2 = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i8 = te[8];
        return a2 * e * i8 - a2 * f * h - b2 * d * i8 + b2 * f * g + c2 * d * h - c2 * e * g;
    }
    getInverse(matrix, throwOnDegenerate) {
        if (throwOnDegenerate !== undefined) console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");
        const me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
    }
    transpose() {
        let tmp1;
        const m = this.elements;
        tmp1 = m[1];
        m[1] = m[3];
        m[3] = tmp1;
        tmp1 = m[2];
        m[2] = m[6];
        m[6] = tmp1;
        tmp1 = m[5];
        m[5] = m[7];
        m[7] = tmp1;
        return this;
    }
    getNormalMatrix(matrix4) {
        return this.setFromMatrix4(matrix4).getInverse(this).transpose();
    }
    transposeIntoArray(r) {
        const m = this.elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
    }
    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
        const c2 = Math.cos(rotation);
        const s2 = Math.sin(rotation);
        this.set(sx * c2, sx * s2, -sx * (c2 * cx + s2 * cy) + cx + tx, -sy * s2, sy * c2, -sy * (-s2 * cx + c2 * cy) + cy + ty, 0, 0, 1);
    }
    scale(sx, sy) {
        const te = this.elements;
        te[0] *= sx;
        te[3] *= sx;
        te[6] *= sx;
        te[1] *= sy;
        te[4] *= sy;
        te[7] *= sy;
        return this;
    }
    rotate(theta) {
        const c2 = Math.cos(theta);
        const s2 = Math.sin(theta);
        const te = this.elements;
        const a111 = te[0], a12 = te[3], a13 = te[6];
        const a21 = te[1], a22 = te[4], a23 = te[7];
        te[0] = c2 * a111 + s2 * a21;
        te[3] = c2 * a12 + s2 * a22;
        te[6] = c2 * a13 + s2 * a23;
        te[1] = -s2 * a111 + c2 * a21;
        te[4] = -s2 * a12 + c2 * a22;
        te[7] = -s2 * a13 + c2 * a23;
        return this;
    }
    translate(tx, ty) {
        const te = this.elements;
        te[0] += tx * te[2];
        te[3] += tx * te[5];
        te[6] += tx * te[8];
        te[1] += ty * te[2];
        te[4] += ty * te[5];
        te[7] += ty * te[8];
        return this;
    }
    equals(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for(let i8 = 0; i8 < 9; i8++)if (te[i8] !== me[i8]) return false;
        return true;
    }
    fromArray(array, offset) {
        if (offset === undefined) offset = 0;
        for(let i8 = 0; i8 < 9; i8++)this.elements[i8] = array[i8 + offset];
        return this;
    }
    toArray(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
    }
    constructor(){
        this.elements = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ];
        if (arguments.length > 0) console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
    }
}
Matrix32.prototype.isMatrix3 = true;
const Matrix31 = Matrix32;
export { Matrix31 as Matrix3 };
const _points = [
    new Vector31(),
    new Vector31(),
    new Vector31(),
    new Vector31(),
    new Vector31(),
    new Vector31(),
    new Vector31(),
    new Vector31()
];
const _vector5 = new Vector31();
const _box1 = new Box33();
const _v01 = new Vector31();
const _v14 = new Vector31();
const _v21 = new Vector31();
const _f0 = new Vector31();
const _f1 = new Vector31();
const _f2 = new Vector31();
const _center = new Vector31();
const _extents = new Vector31();
const _triangleNormal = new Vector31();
const _testAxis = new Vector31();
function Box33(min, max) {
    this.min = min !== undefined ? min : new Vector31(Infinity, Infinity, Infinity);
    this.max = max !== undefined ? max : new Vector31(-Infinity, -Infinity, -Infinity);
}
Object.assign(Box33.prototype, {
    isBox3: true,
    set: function(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    },
    setFromArray: function(array) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for(let i8 = 0, l1 = array.length; i8 < l1; i8 += 3){
            const x6 = array[i8];
            const y6 = array[i8 + 1];
            const z5 = array[i8 + 2];
            if (x6 < minX) minX = x6;
            if (y6 < minY) minY = y6;
            if (z5 < minZ) minZ = z5;
            if (x6 > maxX) maxX = x6;
            if (y6 > maxY) maxY = y6;
            if (z5 > maxZ) maxZ = z5;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
    },
    setFromBufferAttribute: function(attribute) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for(let i8 = 0, l1 = attribute.count; i8 < l1; i8++){
            const x6 = attribute.getX(i8);
            const y6 = attribute.getY(i8);
            const z5 = attribute.getZ(i8);
            if (x6 < minX) minX = x6;
            if (y6 < minY) minY = y6;
            if (z5 < minZ) minZ = z5;
            if (x6 > maxX) maxX = x6;
            if (y6 > maxY) maxY = y6;
            if (z5 > maxZ) maxZ = z5;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
    },
    setFromPoints: function(points1) {
        this.makeEmpty();
        for(let i8 = 0, il = points1.length; i8 < il; i8++)this.expandByPoint(points1[i8]);
        return this;
    },
    setFromCenterAndSize: function(center1, size) {
        const halfSize = _vector5.copy(size).multiplyScalar(0.5);
        this.min.copy(center1).sub(halfSize);
        this.max.copy(center1).add(halfSize);
        return this;
    },
    setFromObject: function(object) {
        this.makeEmpty();
        return this.expandByObject(object);
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    },
    makeEmpty: function() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
    },
    isEmpty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    },
    getCenter: function(target) {
        if (target === undefined) {
            console.warn('THREE.Box3: .getCenter() target is now required');
            target = new Vector31();
        }
        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    getSize: function(target) {
        if (target === undefined) {
            console.warn('THREE.Box3: .getSize() target is now required');
            target = new Vector31();
        }
        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    },
    expandByPoint: function(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    },
    expandByVector: function(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    },
    expandByScalar: function(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    },
    expandByObject: function(object) {
        object.updateWorldMatrix(false, false);
        const geometry = object.geometry;
        if (geometry !== undefined) {
            if (geometry.boundingBox === null) geometry.computeBoundingBox();
            _box1.copy(geometry.boundingBox);
            _box1.applyMatrix4(object.matrixWorld);
            this.union(_box1);
        }
        const children = object.children;
        for(let i8 = 0, l1 = children.length; i8 < l1; i8++)this.expandByObject(children[i8]);
        return this;
    },
    containsPoint: function(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
    },
    containsBox: function(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    },
    getParameter: function(point, target) {
        if (target === undefined) {
            console.warn('THREE.Box3: .getParameter() target is now required');
            target = new Vector31();
        }
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    },
    intersectsBox: function(box) {
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
    },
    intersectsSphere: function(sphere) {
        this.clampPoint(sphere.center, _vector5);
        return _vector5.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    },
    intersectsPlane: function(plane) {
        let min, max;
        if (plane.normal.x > 0) {
            min = plane.normal.x * this.min.x;
            max = plane.normal.x * this.max.x;
        } else {
            min = plane.normal.x * this.max.x;
            max = plane.normal.x * this.min.x;
        }
        if (plane.normal.y > 0) {
            min += plane.normal.y * this.min.y;
            max += plane.normal.y * this.max.y;
        } else {
            min += plane.normal.y * this.max.y;
            max += plane.normal.y * this.min.y;
        }
        if (plane.normal.z > 0) {
            min += plane.normal.z * this.min.z;
            max += plane.normal.z * this.max.z;
        } else {
            min += plane.normal.z * this.max.z;
            max += plane.normal.z * this.min.z;
        }
        return min <= -plane.constant && max >= -plane.constant;
    },
    intersectsTriangle: function(triangle) {
        if (this.isEmpty()) return false;
        this.getCenter(_center);
        _extents.subVectors(this.max, _center);
        _v01.subVectors(triangle.a, _center);
        _v14.subVectors(triangle.b, _center);
        _v21.subVectors(triangle.c, _center);
        _f0.subVectors(_v14, _v01);
        _f1.subVectors(_v21, _v14);
        _f2.subVectors(_v01, _v21);
        let axes = [
            0,
            -_f0.z,
            _f0.y,
            0,
            -_f1.z,
            _f1.y,
            0,
            -_f2.z,
            _f2.y,
            _f0.z,
            0,
            -_f0.x,
            _f1.z,
            0,
            -_f1.x,
            _f2.z,
            0,
            -_f2.x,
            -_f0.y,
            _f0.x,
            0,
            -_f1.y,
            _f1.x,
            0,
            -_f2.y,
            _f2.x,
            0
        ];
        if (!satForAxes(axes, _v01, _v14, _v21, _extents)) return false;
        axes = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ];
        if (!satForAxes(axes, _v01, _v14, _v21, _extents)) return false;
        _triangleNormal.crossVectors(_f0, _f1);
        axes = [
            _triangleNormal.x,
            _triangleNormal.y,
            _triangleNormal.z
        ];
        return satForAxes(axes, _v01, _v14, _v21, _extents);
    },
    clampPoint: function(point, target) {
        if (target === undefined) {
            console.warn('THREE.Box3: .clampPoint() target is now required');
            target = new Vector31();
        }
        return target.copy(point).clamp(this.min, this.max);
    },
    distanceToPoint: function(point) {
        const clampedPoint = _vector5.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
    },
    getBoundingSphere: function(target) {
        if (target === undefined) console.error('THREE.Box3: .getBoundingSphere() target is now required');
        this.getCenter(target.center);
        target.radius = this.getSize(_vector5).length() * 0.5;
        return target;
    },
    intersect: function(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        if (this.isEmpty()) this.makeEmpty();
        return this;
    },
    union: function(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    },
    applyMatrix4: function(matrix) {
        if (this.isEmpty()) return this;
        _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
        this.setFromPoints(_points);
        return this;
    },
    translate: function(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    },
    equals: function(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    }
});
function satForAxes(axes, v0, v1, v2, extents) {
    for(let i8 = 0, j4 = axes.length - 3; i8 <= j4; i8 += 3){
        _testAxis.fromArray(axes, i8);
        const r2 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
        const p0 = v0.dot(_testAxis);
        const p1 = v1.dot(_testAxis);
        const p2 = v2.dot(_testAxis);
        if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r2) return false;
    }
    return true;
}
const Box31 = Box33;
export { Box31 as Box3 };
const _vector8 = new Vector21();
function Box2(min, max) {
    this.min = min !== undefined ? min : new Vector21(Infinity, Infinity);
    this.max = max !== undefined ? max : new Vector21(-Infinity, -Infinity);
}
Object.assign(Box2.prototype, {
    set: function(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
    },
    setFromPoints: function(points1) {
        this.makeEmpty();
        for(let i8 = 0, il = points1.length; i8 < il; i8++)this.expandByPoint(points1[i8]);
        return this;
    },
    setFromCenterAndSize: function(center1, size) {
        const halfSize = _vector8.copy(size).multiplyScalar(0.5);
        this.min.copy(center1).sub(halfSize);
        this.max.copy(center1).add(halfSize);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
    },
    makeEmpty: function() {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
    },
    isEmpty: function() {
        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
        return this.max.x < this.min.x || this.max.y < this.min.y;
    },
    getCenter: function(target) {
        if (target === undefined) {
            console.warn('THREE.Box2: .getCenter() target is now required');
            target = new Vector21();
        }
        return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    getSize: function(target) {
        if (target === undefined) {
            console.warn('THREE.Box2: .getSize() target is now required');
            target = new Vector21();
        }
        return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
    },
    expandByPoint: function(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
    },
    expandByVector: function(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
    },
    expandByScalar: function(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
    },
    containsPoint: function(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
    },
    containsBox: function(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
    },
    getParameter: function(point, target) {
        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.
        if (target === undefined) {
            console.warn('THREE.Box2: .getParameter() target is now required');
            target = new Vector21();
        }
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
    },
    intersectsBox: function(box) {
        // using 4 splitting planes to rule out intersections
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
    },
    clampPoint: function(point, target) {
        if (target === undefined) {
            console.warn('THREE.Box2: .clampPoint() target is now required');
            target = new Vector21();
        }
        return target.copy(point).clamp(this.min, this.max);
    },
    distanceToPoint: function(point) {
        const clampedPoint = _vector8.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
    },
    intersect: function(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
    },
    union: function(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
    },
    translate: function(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
    },
    equals: function(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
    }
});
const Box21 = Box2;
export { Box21 as Box2 };
const _startP = new Vector31();
const _startEnd = new Vector31();
function Line3(start, end) {
    this.start = start !== undefined ? start : new Vector31();
    this.end = end !== undefined ? end : new Vector31();
}
Object.assign(Line3.prototype, {
    set: function(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
    },
    getCenter: function(target) {
        if (target === undefined) {
            console.warn('THREE.Line3: .getCenter() target is now required');
            target = new Vector31();
        }
        return target.addVectors(this.start, this.end).multiplyScalar(0.5);
    },
    delta: function(target) {
        if (target === undefined) {
            console.warn('THREE.Line3: .delta() target is now required');
            target = new Vector31();
        }
        return target.subVectors(this.end, this.start);
    },
    distanceSq: function() {
        return this.start.distanceToSquared(this.end);
    },
    distance: function() {
        return this.start.distanceTo(this.end);
    },
    at: function(t3, target) {
        if (target === undefined) {
            console.warn('THREE.Line3: .at() target is now required');
            target = new Vector31();
        }
        return this.delta(target).multiplyScalar(t3).add(this.start);
    },
    closestPointToPointParameter: function(point, clampToLine) {
        _startP.subVectors(point, this.start);
        _startEnd.subVectors(this.end, this.start);
        const startEnd2 = _startEnd.dot(_startEnd);
        const startEnd_startP = _startEnd.dot(_startP);
        let t3 = startEnd_startP / startEnd2;
        if (clampToLine) t3 = MathUtils1.clamp(t3, 0, 1);
        return t3;
    },
    closestPointToPoint: function(point, clampToLine, target) {
        const t3 = this.closestPointToPointParameter(point, clampToLine);
        if (target === undefined) {
            console.warn('THREE.Line3: .closestPointToPoint() target is now required');
            target = new Vector31();
        }
        return this.delta(target).multiplyScalar(t3).add(this.start);
    },
    applyMatrix4: function(matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
    },
    equals: function(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
    }
});
const Line31 = Line3;
export { Line31 as Line3 };
class Euler3 {
    get x() {
        return this._x;
    }
    set x(value) {
        this._x = value;
        this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(value) {
        this._y = value;
        this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(value) {
        this._z = value;
        this._onChangeCallback();
    }
    get order() {
        return this._order;
    }
    set order(value) {
        this._order = value;
        this._onChangeCallback();
    }
    set(x, y, z, order) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order || this._order;
        this._onChangeCallback();
        return this;
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this._onChangeCallback();
        return this;
    }
    setFromRotationMatrix(m, order, update) {
        const clamp = MathUtils1.clamp;
        const te = m.elements;
        const m11 = te[0], m12 = te[4], m13 = te[8];
        const m21 = te[1], m22 = te[5], m23 = te[9];
        const m31 = te[2], m32 = te[6], m33 = te[10];
        order = order || this._order;
        switch(order){
            case 'XYZ':
                this._y = Math.asin(clamp(m13, -1, 1));
                if (Math.abs(m13) < 0.9999999) {
                    this._x = Math.atan2(-m23, m33);
                    this._z = Math.atan2(-m12, m11);
                } else {
                    this._x = Math.atan2(m32, m22);
                    this._z = 0;
                }
                break;
            case 'YXZ':
                this._x = Math.asin(-clamp(m23, -1, 1));
                if (Math.abs(m23) < 0.9999999) {
                    this._y = Math.atan2(m13, m33);
                    this._z = Math.atan2(m21, m22);
                } else {
                    this._y = Math.atan2(-m31, m11);
                    this._z = 0;
                }
                break;
            case 'ZXY':
                this._x = Math.asin(clamp(m32, -1, 1));
                if (Math.abs(m32) < 0.9999999) {
                    this._y = Math.atan2(-m31, m33);
                    this._z = Math.atan2(-m12, m22);
                } else {
                    this._y = 0;
                    this._z = Math.atan2(m21, m11);
                }
                break;
            case 'ZYX':
                this._y = Math.asin(-clamp(m31, -1, 1));
                if (Math.abs(m31) < 0.9999999) {
                    this._x = Math.atan2(m32, m33);
                    this._z = Math.atan2(m21, m11);
                } else {
                    this._x = 0;
                    this._z = Math.atan2(-m12, m22);
                }
                break;
            case 'YZX':
                this._z = Math.asin(clamp(m21, -1, 1));
                if (Math.abs(m21) < 0.9999999) {
                    this._x = Math.atan2(-m23, m22);
                    this._y = Math.atan2(-m31, m11);
                } else {
                    this._x = 0;
                    this._y = Math.atan2(m13, m33);
                }
                break;
            case 'XZY':
                this._z = Math.asin(-clamp(m12, -1, 1));
                if (Math.abs(m12) < 0.9999999) {
                    this._x = Math.atan2(m32, m22);
                    this._y = Math.atan2(m13, m11);
                } else {
                    this._x = Math.atan2(-m23, m33);
                    this._y = 0;
                }
                break;
            default:
                console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
        }
        this._order = order;
        if (update !== false) this._onChangeCallback();
        return this;
    }
    setFromQuaternion(q, order, update) {
        _matrix.makeRotationFromQuaternion(q);
        return this.setFromRotationMatrix(_matrix, order, update);
    }
    setFromVector3(v, order) {
        return this.set(v.x, v.y, v.z, order || this._order);
    }
    reorder(newOrder) {
        _quaternion2.setFromEuler(this);
        return this.setFromQuaternion(_quaternion2, newOrder);
    }
    equals(euler) {
        return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    }
    fromArray(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== undefined) this._order = array[3];
        this._onChangeCallback();
        return this;
    }
    toArray(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
    }
    toVector3(optionalResult) {
        if (optionalResult) return optionalResult.set(this._x, this._y, this._z);
        else return new Vector31(this._x, this._y, this._z);
    }
    _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
    }
    _onChangeCallback() {
    }
    constructor(x3 = 0, y3 = 0, z3 = 0, order1 = Euler3.DefaultOrder){
        this._x = x3;
        this._y = y3;
        this._z = z3;
        this._order = order1;
    }
}
Euler3.DefaultOrder = 'XYZ';
Euler3.RotationOrders = [
    'XYZ',
    'YZX',
    'ZXY',
    'XZY',
    'YXZ',
    'ZYX'
];
Euler3.prototype.isEuler = true;
const _matrix = new Matrix41();
const _quaternion2 = new Quaternion1();
const Euler1 = Euler3;
export { Euler1 as Euler };
class Vector42 {
    get width() {
        return this.z;
    }
    set width(value) {
        this.z = value;
    }
    get height() {
        return this.w;
    }
    set height(value) {
        this.w = value;
    }
    set(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        this.w = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setZ(z) {
        this.z = z;
        return this;
    }
    setW(w) {
        this.w = w;
        return this;
    }
    setComponent(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            case 3:
                this.w = value;
                break;
            default:
                throw new Error('index is out of range: ' + index);
        }
        return this;
    }
    getComponent(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error('index is out of range: ' + index);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w !== undefined ? v.w : 1;
        return this;
    }
    add(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;
        return this;
    }
    sub(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
    }
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
    }
    applyMatrix4(m) {
        const x6 = this.x, y6 = this.y, z5 = this.z, w3 = this.w;
        const e = m.elements;
        this.x = e[0] * x6 + e[4] * y6 + e[8] * z5 + e[12] * w3;
        this.y = e[1] * x6 + e[5] * y6 + e[9] * z5 + e[13] * w3;
        this.z = e[2] * x6 + e[6] * y6 + e[10] * z5 + e[14] * w3;
        this.w = e[3] * x6 + e[7] * y6 + e[11] * z5 + e[15] * w3;
        return this;
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
    }
    setAxisAngleFromQuaternion(q) {
        this.w = 2 * Math.acos(q.w);
        const s2 = Math.sqrt(1 - q.w * q.w);
        if (s2 < 0.0001) {
            this.x = 1;
            this.y = 0;
            this.z = 0;
        } else {
            this.x = q.x / s2;
            this.y = q.y / s2;
            this.z = q.z / s2;
        }
        return this;
    }
    setAxisAngleFromRotationMatrix(m) {
        let angle, x6, y6, z5;
        const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
            if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
                this.set(1, 0, 0, 0);
                return this;
            }
            angle = Math.PI;
            const xx = (m11 + 1) / 2;
            const yy = (m22 + 1) / 2;
            const zz = (m33 + 1) / 2;
            const xy = (m12 + m21) / 4;
            const xz = (m13 + m31) / 4;
            const yz = (m23 + m32) / 4;
            if (xx > yy && xx > zz) {
                if (xx < epsilon) {
                    x6 = 0;
                    y6 = 0.707106781;
                    z5 = 0.707106781;
                } else {
                    x6 = Math.sqrt(xx);
                    y6 = xy / x6;
                    z5 = xz / x6;
                }
            } else if (yy > zz) {
                if (yy < epsilon) {
                    x6 = 0.707106781;
                    y6 = 0;
                    z5 = 0.707106781;
                } else {
                    y6 = Math.sqrt(yy);
                    x6 = xy / y6;
                    z5 = yz / y6;
                }
            } else if (zz < epsilon) {
                x6 = 0.707106781;
                y6 = 0.707106781;
                z5 = 0;
            } else {
                z5 = Math.sqrt(zz);
                x6 = xz / z5;
                y6 = yz / z5;
            }
            this.set(x6, y6, z5, angle);
            return this;
        }
        let s2 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
        if (Math.abs(s2) < 0.001) s2 = 1;
        this.x = (m32 - m23) / s2;
        this.y = (m13 - m31) / s2;
        this.z = (m21 - m12) / s2;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        this.w = Math.min(this.w, v.w);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        this.w = Math.max(this.w, v.w);
        return this;
    }
    clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        this.w = Math.max(min.w, Math.min(max.w, this.w));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        this.w = Math.max(minVal, Math.min(maxVal, this.w));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
    }
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        this.w = v1.w + (v2.w - v1.w) * alpha;
        return this;
    }
    equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    }
    fromArray(array, offset) {
        if (offset === undefined) offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
    }
    toArray(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        this.w = attribute.getW(index);
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        this.w = Math.random();
        return this;
    }
    constructor(x1 = 0, y1 = 0, z1 = 0, w1 = 1){
        this.x = x1;
        this.y = y1;
        this.z = z1;
        this.w = w1;
    }
}
Vector42.prototype.isVector4 = true;
const Vector41 = Vector42;
export { Vector41 as Vector4 };
class Vector32 {
    set(x, y, z) {
        if (z === undefined) z = this.z;
        this.x = x;
        this.y = y;
        this.z = z;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setZ(z) {
        this.z = z;
        return this;
    }
    setComponent(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            case 2:
                this.z = value;
                break;
            default:
                throw new Error('index is out of range: ' + index);
        }
        return this;
    }
    getComponent(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error('index is out of range: ' + index);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
    }
    add(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        return this;
    }
    sub(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
    }
    multiply(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
            return this.multiplyVectors(v, w);
        }
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
    }
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
    }
    multiplyVectors(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
    }
    applyEuler(euler) {
        if (!(euler && euler.isEuler)) console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
        return this.applyQuaternion(_quaternion3.setFromEuler(euler));
    }
    applyAxisAngle(axis, angle) {
        return this.applyQuaternion(_quaternion3.setFromAxisAngle(axis, angle));
    }
    applyMatrix3(m) {
        const x6 = this.x, y6 = this.y, z5 = this.z;
        const e = m.elements;
        this.x = e[0] * x6 + e[3] * y6 + e[6] * z5;
        this.y = e[1] * x6 + e[4] * y6 + e[7] * z5;
        this.z = e[2] * x6 + e[5] * y6 + e[8] * z5;
        return this;
    }
    applyNormalMatrix(m) {
        return this.applyMatrix3(m).normalize();
    }
    applyMatrix4(m) {
        const x6 = this.x, y6 = this.y, z5 = this.z;
        const e = m.elements;
        const w3 = 1 / (e[3] * x6 + e[7] * y6 + e[11] * z5 + e[15]);
        this.x = (e[0] * x6 + e[4] * y6 + e[8] * z5 + e[12]) * w3;
        this.y = (e[1] * x6 + e[5] * y6 + e[9] * z5 + e[13]) * w3;
        this.z = (e[2] * x6 + e[6] * y6 + e[10] * z5 + e[14]) * w3;
        return this;
    }
    applyQuaternion(q) {
        const x6 = this.x, y6 = this.y, z5 = this.z;
        const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
        const ix2 = qw * x6 + qy * z5 - qz * y6;
        const iy2 = qw * y6 + qz * x6 - qx * z5;
        const iz = qw * z5 + qx * y6 - qy * x6;
        const iw = -qx * x6 - qy * y6 - qz * z5;
        this.x = ix2 * qw + iw * -qx + iy2 * -qz - iz * -qy;
        this.y = iy2 * qw + iw * -qy + iz * -qx - ix2 * -qz;
        this.z = iz * qw + iw * -qz + ix2 * -qy - iy2 * -qx;
        return this;
    }
    project(camera) {
        return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
    }
    unproject(camera) {
        return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
    }
    transformDirection(m) {
        const x6 = this.x, y6 = this.y, z5 = this.z;
        const e = m.elements;
        this.x = e[0] * x6 + e[4] * y6 + e[8] * z5;
        this.y = e[1] * x6 + e[5] * y6 + e[9] * z5;
        this.z = e[2] * x6 + e[6] * y6 + e[10] * z5;
        return this.normalize();
    }
    divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        return this;
    }
    clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
    }
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        return this;
    }
    cross(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
            return this.crossVectors(v, w);
        }
        return this.crossVectors(this, v);
    }
    crossVectors(a, b) {
        const ax = a.x, ay = a.y, az = a.z;
        const bx = b.x, by = b.y, bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
    }
    projectOnVector(v) {
        const denominator = v.lengthSq();
        if (denominator === 0) return this.set(0, 0, 0);
        const scalar = v.dot(this) / denominator;
        return this.copy(v).multiplyScalar(scalar);
    }
    projectOnPlane(planeNormal) {
        _vector2.copy(this).projectOnVector(planeNormal);
        return this.sub(_vector2);
    }
    reflect(normal) {
        return this.sub(_vector2.copy(normal).multiplyScalar(2 * this.dot(normal)));
    }
    angleTo(v) {
        const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
        if (denominator === 0) return Math.PI / 2;
        const theta2 = this.dot(v) / denominator;
        return Math.acos(MathUtils1.clamp(theta2, -1, 1));
    }
    distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
        const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
    }
    manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    }
    setFromSpherical(s) {
        return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
    }
    setFromSphericalCoords(radius, phi, theta) {
        const sinPhiRadius = Math.sin(phi) * radius;
        this.x = sinPhiRadius * Math.sin(theta);
        this.y = Math.cos(phi) * radius;
        this.z = sinPhiRadius * Math.cos(theta);
        return this;
    }
    setFromCylindrical(c) {
        return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    }
    setFromCylindricalCoords(radius, theta, y) {
        this.x = radius * Math.sin(theta);
        this.y = y;
        this.z = radius * Math.cos(theta);
        return this;
    }
    setFromMatrixPosition(m) {
        const e = m.elements;
        this.x = e[12];
        this.y = e[13];
        this.z = e[14];
        return this;
    }
    setFromMatrixScale(m) {
        const sx = this.setFromMatrixColumn(m, 0).length();
        const sy = this.setFromMatrixColumn(m, 1).length();
        const sz = this.setFromMatrixColumn(m, 2).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
    }
    setFromMatrixColumn(m, index) {
        return this.fromArray(m.elements, index * 4);
    }
    setFromMatrix3Column(m, index) {
        return this.fromArray(m.elements, index * 3);
    }
    equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z;
    }
    fromArray(array, offset) {
        if (offset === undefined) offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
    }
    toArray(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        return this;
    }
    constructor(x4 = 0, y4 = 0, z4 = 0){
        this.x = x4;
        this.y = y4;
        this.z = z4;
    }
}
Vector32.prototype.isVector3 = true;
const _vector2 = new Vector32();
const _quaternion3 = new Quaternion1();
const Vector31 = Vector32;
export { Vector31 as Vector3 };
class Vector22 {
    get width() {
        return this.x;
    }
    set width(value) {
        this.x = value;
    }
    get height() {
        return this.y;
    }
    set height(value) {
        this.y = value;
    }
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    setComponent(index, value) {
        switch(index){
            case 0:
                this.x = value;
                break;
            case 1:
                this.y = value;
                break;
            default:
                throw new Error('index is out of range: ' + index);
        }
        return this;
    }
    getComponent(index) {
        switch(index){
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error('index is out of range: ' + index);
        }
    }
    clone() {
        return new this.constructor(this.x, this.y);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    }
    add(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
            return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
    }
    sub(v, w) {
        if (w !== undefined) {
            console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
            return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
    }
    multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
    }
    multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
    }
    divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
    }
    divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
    }
    applyMatrix3(m) {
        const x6 = this.x, y6 = this.y;
        const e = m.elements;
        this.x = e[0] * x6 + e[3] * y6 + e[6];
        this.y = e[1] * x6 + e[4] * y6 + e[7];
        return this;
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
    }
    clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
    }
    negate() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y;
    }
    cross(v) {
        return this.x * v.y - this.y * v.x;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    angle() {
        const angle = Math.atan2(-this.y, -this.x) + Math.PI;
        return angle;
    }
    distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
        const dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
    }
    manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        return this;
    }
    equals(v) {
        return v.x === this.x && v.y === this.y;
    }
    fromArray(array, offset) {
        if (offset === undefined) offset = 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
    }
    toArray(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        return this;
    }
    rotateAround(center, angle) {
        const c2 = Math.cos(angle), s2 = Math.sin(angle);
        const x6 = this.x - center.x;
        const y6 = this.y - center.y;
        this.x = x6 * c2 - y6 * s2 + center.x;
        this.y = x6 * s2 + y6 * c2 + center.y;
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        return this;
    }
    constructor(x5 = 0, y5 = 0){
        this.x = x5;
        this.y = y5;
    }
}
Vector22.prototype.isVector2 = true;
const Vector21 = Vector22;
export { Vector21 as Vector2 };
class Quaternion2 {
    static slerp(qa, qb, qm, t) {
        return qm.copy(qa).slerp(qb, t);
    }
    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
        let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
        const x12 = src1[srcOffset1 + 0], y12 = src1[srcOffset1 + 1], z12 = src1[srcOffset1 + 2], w12 = src1[srcOffset1 + 3];
        if (w0 !== w12 || x0 !== x12 || y0 !== y12 || z0 !== z12) {
            let s2 = 1 - t;
            const cos = x0 * x12 + y0 * y12 + z0 * z12 + w0 * w12, dir = cos >= 0 ? 1 : -1;
            const tDir = t * dir;
            x0 = x0 * s2 + x12 * tDir;
            y0 = y0 * s2 + y12 * tDir;
            z0 = z0 * s2 + z12 * tDir;
            w0 = w0 * s2 + w12 * tDir;
            // Normalize in case we just did a lerp:
            if (s2 === 1 - t) {
                const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                x0 *= f;
                y0 *= f;
                z0 *= f;
                w0 *= f;
            }
        }
        dst[dstOffset] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
    }
    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
        const x0 = src0[srcOffset0];
        const y0 = src0[srcOffset0 + 1];
        const z0 = src0[srcOffset0 + 2];
        const w0 = src0[srcOffset0 + 3];
        const x12 = src1[srcOffset1];
        const y12 = src1[srcOffset1 + 1];
        const z12 = src1[srcOffset1 + 2];
        const w12 = src1[srcOffset1 + 3];
        dst[dstOffset] = x0 * w12 + w0 * x12 + y0 * z12 - z0 * y12;
        dst[dstOffset + 1] = y0 * w12 + w0 * y12 + z0 * x12 - x0 * z12;
        dst[dstOffset + 2] = z0 * w12 + w0 * z12 + x0 * y12 - y0 * x12;
        dst[dstOffset + 3] = w0 * w12 - x0 * x12 - y0 * y12 - z0 * z12;
        return dst;
    }
    get x() {
        return this._x;
    }
    set x(value) {
        this._x = value;
        this._onChangeCallback();
    }
    get y() {
        return this._y;
    }
    set y(value) {
        this._y = value;
        this._onChangeCallback();
    }
    get z() {
        return this._z;
    }
    set z(value) {
        this._z = value;
        this._onChangeCallback();
    }
    get w() {
        return this._w;
    }
    set w(value) {
        this._w = value;
        this._onChangeCallback();
    }
    set(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this._onChangeCallback();
        return this;
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this._onChangeCallback();
        return this;
    }
    setFromEuler(euler, update) {
        if (!(euler && euler.isEuler)) throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
        const x6 = euler._x, y6 = euler._y, z5 = euler._z, order2 = euler._order;
        const cos = Math.cos;
        const sin = Math.sin;
        const c12 = cos(x6 / 2);
        const c2 = cos(y6 / 2);
        const c3 = cos(z5 / 2);
        const s11 = sin(x6 / 2);
        const s2 = sin(y6 / 2);
        const s3 = sin(z5 / 2);
        switch(order2){
            case 'XYZ':
                this._x = s11 * c2 * c3 + c12 * s2 * s3;
                this._y = c12 * s2 * c3 - s11 * c2 * s3;
                this._z = c12 * c2 * s3 + s11 * s2 * c3;
                this._w = c12 * c2 * c3 - s11 * s2 * s3;
                break;
            case 'YXZ':
                this._x = s11 * c2 * c3 + c12 * s2 * s3;
                this._y = c12 * s2 * c3 - s11 * c2 * s3;
                this._z = c12 * c2 * s3 - s11 * s2 * c3;
                this._w = c12 * c2 * c3 + s11 * s2 * s3;
                break;
            case 'ZXY':
                this._x = s11 * c2 * c3 - c12 * s2 * s3;
                this._y = c12 * s2 * c3 + s11 * c2 * s3;
                this._z = c12 * c2 * s3 + s11 * s2 * c3;
                this._w = c12 * c2 * c3 - s11 * s2 * s3;
                break;
            case 'ZYX':
                this._x = s11 * c2 * c3 - c12 * s2 * s3;
                this._y = c12 * s2 * c3 + s11 * c2 * s3;
                this._z = c12 * c2 * s3 - s11 * s2 * c3;
                this._w = c12 * c2 * c3 + s11 * s2 * s3;
                break;
            case 'YZX':
                this._x = s11 * c2 * c3 + c12 * s2 * s3;
                this._y = c12 * s2 * c3 + s11 * c2 * s3;
                this._z = c12 * c2 * s3 - s11 * s2 * c3;
                this._w = c12 * c2 * c3 - s11 * s2 * s3;
                break;
            case 'XZY':
                this._x = s11 * c2 * c3 - c12 * s2 * s3;
                this._y = c12 * s2 * c3 - s11 * c2 * s3;
                this._z = c12 * c2 * s3 + s11 * s2 * c3;
                this._w = c12 * c2 * c3 + s11 * s2 * s3;
                break;
            default:
                console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order2);
        }
        if (update !== false) this._onChangeCallback();
        return this;
    }
    setFromAxisAngle(axis, angle) {
        const halfAngle = angle / 2, s2 = Math.sin(halfAngle);
        this._x = axis.x * s2;
        this._y = axis.y * s2;
        this._z = axis.z * s2;
        this._w = Math.cos(halfAngle);
        this._onChangeCallback();
        return this;
    }
    setFromRotationMatrix(m) {
        const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
        if (trace > 0) {
            const s2 = 0.5 / Math.sqrt(trace + 1);
            this._w = 0.25 / s2;
            this._x = (m32 - m23) * s2;
            this._y = (m13 - m31) * s2;
            this._z = (m21 - m12) * s2;
        } else if (m11 > m22 && m11 > m33) {
            const s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
            this._w = (m32 - m23) / s2;
            this._x = 0.25 * s2;
            this._y = (m12 + m21) / s2;
            this._z = (m13 + m31) / s2;
        } else if (m22 > m33) {
            const s2 = 2 * Math.sqrt(1 + m22 - m11 - m33);
            this._w = (m13 - m31) / s2;
            this._x = (m12 + m21) / s2;
            this._y = 0.25 * s2;
            this._z = (m23 + m32) / s2;
        } else {
            const s2 = 2 * Math.sqrt(1 + m33 - m11 - m22);
            this._w = (m21 - m12) / s2;
            this._x = (m13 + m31) / s2;
            this._y = (m23 + m32) / s2;
            this._z = 0.25 * s2;
        }
        this._onChangeCallback();
        return this;
    }
    setFromUnitVectors(vFrom, vTo) {
        const EPS = 0.000001;
        let r2 = vFrom.dot(vTo) + 1;
        if (r2 < EPS) {
            r2 = 0;
            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                this._x = -vFrom.y;
                this._y = vFrom.x;
                this._z = 0;
                this._w = r2;
            } else {
                this._x = 0;
                this._y = -vFrom.z;
                this._z = vFrom.y;
                this._w = r2;
            }
        } else {
            this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
            this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
            this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
            this._w = r2;
        }
        return this.normalize();
    }
    angleTo(q) {
        return 2 * Math.acos(Math.abs(MathUtils1.clamp(this.dot(q), -1, 1)));
    }
    rotateTowards(q, step) {
        const angle = this.angleTo(q);
        if (angle === 0) return this;
        const t3 = Math.min(1, step / angle);
        this.slerp(q, t3);
        return this;
    }
    identity() {
        return this.set(0, 0, 0, 1);
    }
    inverse() {
        return this.conjugate();
    }
    conjugate() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._onChangeCallback();
        return this;
    }
    dot(v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
        let l1 = this.length();
        if (l1 === 0) {
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;
        } else {
            l1 = 1 / l1;
            this._x = this._x * l1;
            this._y = this._y * l1;
            this._z = this._z * l1;
            this._w = this._w * l1;
        }
        this._onChangeCallback();
        return this;
    }
    multiply(q, p) {
        if (p !== undefined) {
            console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
            return this.multiplyQuaternions(q, p);
        }
        return this.multiplyQuaternions(this, q);
    }
    premultiply(q) {
        return this.multiplyQuaternions(q, this);
    }
    multiplyQuaternions(a, b) {
        const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
        const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this._onChangeCallback();
        return this;
    }
    slerp(qb, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(qb);
        const x6 = this._x, y6 = this._y, z5 = this._z, w3 = this._w;
        let cosHalfTheta = w3 * qb._w + x6 * qb._x + y6 * qb._y + z5 * qb._z;
        if (cosHalfTheta < 0) {
            this._w = -qb._w;
            this._x = -qb._x;
            this._y = -qb._y;
            this._z = -qb._z;
            cosHalfTheta = -cosHalfTheta;
        } else this.copy(qb);
        if (cosHalfTheta >= 1) {
            this._w = w3;
            this._x = x6;
            this._y = y6;
            this._z = z5;
            return this;
        }
        const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
        if (sqrSinHalfTheta <= Number.EPSILON) {
            const s2 = 1 - t;
            this._w = s2 * w3 + t * this._w;
            this._x = s2 * x6 + t * this._x;
            this._y = s2 * y6 + t * this._y;
            this._z = s2 * z5 + t * this._z;
            this.normalize();
            this._onChangeCallback();
            return this;
        }
        const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
        const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this._w = w3 * ratioA + this._w * ratioB;
        this._x = x6 * ratioA + this._x * ratioB;
        this._y = y6 * ratioA + this._y * ratioB;
        this._z = z5 * ratioA + this._z * ratioB;
        this._onChangeCallback();
        return this;
    }
    equals(quaternion) {
        return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    }
    fromArray(array, offset) {
        if (offset === undefined) offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onChangeCallback();
        return this;
    }
    toArray(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
    }
    fromBufferAttribute(attribute, index) {
        this._x = attribute.getX(index);
        this._y = attribute.getY(index);
        this._z = attribute.getZ(index);
        this._w = attribute.getW(index);
        return this;
    }
    _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
    }
    _onChangeCallback() {
    }
    constructor(x2 = 0, y2 = 0, z2 = 0, w2 = 1){
        this._x = x2;
        this._y = y2;
        this._z = z2;
        this._w = w2;
    }
}
Quaternion2.prototype.isQuaternion = true;
const Quaternion1 = Quaternion2;
export { Quaternion1 as Quaternion };
const _colorKeywords = {
    'aliceblue': 15792383,
    'antiquewhite': 16444375,
    'aqua': 65535,
    'aquamarine': 8388564,
    'azure': 15794175,
    'beige': 16119260,
    'bisque': 16770244,
    'black': 0,
    'blanchedalmond': 16772045,
    'blue': 255,
    'blueviolet': 9055202,
    'brown': 10824234,
    'burlywood': 14596231,
    'cadetblue': 6266528,
    'chartreuse': 8388352,
    'chocolate': 13789470,
    'coral': 16744272,
    'cornflowerblue': 6591981,
    'cornsilk': 16775388,
    'crimson': 14423100,
    'cyan': 65535,
    'darkblue': 139,
    'darkcyan': 35723,
    'darkgoldenrod': 12092939,
    'darkgray': 11119017,
    'darkgreen': 25600,
    'darkgrey': 11119017,
    'darkkhaki': 12433259,
    'darkmagenta': 9109643,
    'darkolivegreen': 5597999,
    'darkorange': 16747520,
    'darkorchid': 10040012,
    'darkred': 9109504,
    'darksalmon': 15308410,
    'darkseagreen': 9419919,
    'darkslateblue': 4734347,
    'darkslategray': 3100495,
    'darkslategrey': 3100495,
    'darkturquoise': 52945,
    'darkviolet': 9699539,
    'deeppink': 16716947,
    'deepskyblue': 49151,
    'dimgray': 6908265,
    'dimgrey': 6908265,
    'dodgerblue': 2003199,
    'firebrick': 11674146,
    'floralwhite': 16775920,
    'forestgreen': 2263842,
    'fuchsia': 16711935,
    'gainsboro': 14474460,
    'ghostwhite': 16316671,
    'gold': 16766720,
    'goldenrod': 14329120,
    'gray': 8421504,
    'green': 32768,
    'greenyellow': 11403055,
    'grey': 8421504,
    'honeydew': 15794160,
    'hotpink': 16738740,
    'indianred': 13458524,
    'indigo': 4915330,
    'ivory': 16777200,
    'khaki': 15787660,
    'lavender': 15132410,
    'lavenderblush': 16773365,
    'lawngreen': 8190976,
    'lemonchiffon': 16775885,
    'lightblue': 11393254,
    'lightcoral': 15761536,
    'lightcyan': 14745599,
    'lightgoldenrodyellow': 16448210,
    'lightgray': 13882323,
    'lightgreen': 9498256,
    'lightgrey': 13882323,
    'lightpink': 16758465,
    'lightsalmon': 16752762,
    'lightseagreen': 2142890,
    'lightskyblue': 8900346,
    'lightslategray': 7833753,
    'lightslategrey': 7833753,
    'lightsteelblue': 11584734,
    'lightyellow': 16777184,
    'lime': 65280,
    'limegreen': 3329330,
    'linen': 16445670,
    'magenta': 16711935,
    'maroon': 8388608,
    'mediumaquamarine': 6737322,
    'mediumblue': 205,
    'mediumorchid': 12211667,
    'mediumpurple': 9662683,
    'mediumseagreen': 3978097,
    'mediumslateblue': 8087790,
    'mediumspringgreen': 64154,
    'mediumturquoise': 4772300,
    'mediumvioletred': 13047173,
    'midnightblue': 1644912,
    'mintcream': 16121850,
    'mistyrose': 16770273,
    'moccasin': 16770229,
    'navajowhite': 16768685,
    'navy': 128,
    'oldlace': 16643558,
    'olive': 8421376,
    'olivedrab': 7048739,
    'orange': 16753920,
    'orangered': 16729344,
    'orchid': 14315734,
    'palegoldenrod': 15657130,
    'palegreen': 10025880,
    'paleturquoise': 11529966,
    'palevioletred': 14381203,
    'papayawhip': 16773077,
    'peachpuff': 16767673,
    'peru': 13468991,
    'pink': 16761035,
    'plum': 14524637,
    'powderblue': 11591910,
    'purple': 8388736,
    'rebeccapurple': 6697881,
    'red': 16711680,
    'rosybrown': 12357519,
    'royalblue': 4286945,
    'saddlebrown': 9127187,
    'salmon': 16416882,
    'sandybrown': 16032864,
    'seagreen': 3050327,
    'seashell': 16774638,
    'sienna': 10506797,
    'silver': 12632256,
    'skyblue': 8900331,
    'slateblue': 6970061,
    'slategray': 7372944,
    'slategrey': 7372944,
    'snow': 16775930,
    'springgreen': 65407,
    'steelblue': 4620980,
    'tan': 13808780,
    'teal': 32896,
    'thistle': 14204888,
    'tomato': 16737095,
    'turquoise': 4251856,
    'violet': 15631086,
    'wheat': 16113331,
    'white': 16777215,
    'whitesmoke': 16119285,
    'yellow': 16776960,
    'yellowgreen': 10145074
};
const _hslA = {
    h: 0,
    s: 0,
    l: 0
};
const _hslB = {
    h: 0,
    s: 0,
    l: 0
};
function Color2(r2, g, b2) {
    if (g === undefined && b2 === undefined) return this.set(r2);
    return this.setRGB(r2, g, b2);
}
function hue2rgb(p2, q2, t3) {
    if (t3 < 0) t3 += 1;
    if (t3 > 1) t3 -= 1;
    if (t3 < 1 / 6) return p2 + (q2 - p2) * 6 * t3;
    if (t3 < 0.5) return q2;
    if (t3 < 2 / 3) return p2 + (q2 - p2) * 6 * (2 / 3 - t3);
    return p2;
}
function SRGBToLinear(c2) {
    return c2 < 0.04045 ? c2 * 0.0773993808 : Math.pow(c2 * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c2) {
    return c2 < 0.0031308 ? c2 * 12.92 : 1.055 * Math.pow(c2, 0.41666) - 0.055;
}
Object.assign(Color2.prototype, {
    isColor: true,
    r: 1,
    g: 1,
    b: 1,
    set: function(value2) {
        if (value2 && value2.isColor) this.copy(value2);
        else if (typeof value2 === 'number') this.setHex(value2);
        else if (typeof value2 === 'string') this.setStyle(value2);
        return this;
    },
    setScalar: function(scalar) {
        this.r = scalar;
        this.g = scalar;
        this.b = scalar;
        return this;
    },
    setHex: function(hex) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        return this;
    },
    setRGB: function(r2, g, b2) {
        this.r = r2;
        this.g = g;
        this.b = b2;
        return this;
    },
    setHSL: function(h, s2, l1) {
        h = MathUtils1.euclideanModulo(h, 1);
        s2 = MathUtils1.clamp(s2, 0, 1);
        l1 = MathUtils1.clamp(l1, 0, 1);
        if (s2 === 0) this.r = this.g = this.b = l1;
        else {
            const p2 = l1 <= 0.5 ? l1 * (1 + s2) : l1 + s2 - l1 * s2;
            const q2 = 2 * l1 - p2;
            this.r = hue2rgb(q2, p2, h + 1 / 3);
            this.g = hue2rgb(q2, p2, h);
            this.b = hue2rgb(q2, p2, h - 1 / 3);
        }
        return this;
    },
    setStyle: function(style) {
        function handleAlpha(string) {
            if (string === undefined) return;
            if (parseFloat(string) < 1) console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
        }
        let m;
        if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
            let color1;
            const name = m[1];
            const components = m[2];
            switch(name){
                case 'rgb':
                case 'rgba':
                    if (color1 = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        this.r = Math.min(255, parseInt(color1[1], 10)) / 255;
                        this.g = Math.min(255, parseInt(color1[2], 10)) / 255;
                        this.b = Math.min(255, parseInt(color1[3], 10)) / 255;
                        handleAlpha(color1[5]);
                        return this;
                    }
                    if (color1 = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        this.r = Math.min(100, parseInt(color1[1], 10)) / 100;
                        this.g = Math.min(100, parseInt(color1[2], 10)) / 100;
                        this.b = Math.min(100, parseInt(color1[3], 10)) / 100;
                        handleAlpha(color1[5]);
                        return this;
                    }
                    break;
                case 'hsl':
                case 'hsla':
                    if (color1 = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
                        const h = parseFloat(color1[1]) / 360;
                        const s2 = parseInt(color1[2], 10) / 100;
                        const l1 = parseInt(color1[3], 10) / 100;
                        handleAlpha(color1[5]);
                        return this.setHSL(h, s2, l1);
                    }
                    break;
            }
        } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
            const hex = m[1];
            const size = hex.length;
            if (size === 3) {
                this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                return this;
            } else if (size === 6) {
                this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                return this;
            }
        }
        if (style && style.length > 0) return this.setColorName(style);
        return this;
    },
    setColorName: function(style) {
        const hex = _colorKeywords[style];
        if (hex !== undefined) this.setHex(hex);
        else console.warn('THREE.Color: Unknown color ' + style);
        return this;
    },
    clone: function() {
        return new this.constructor(this.r, this.g, this.b);
    },
    copy: function(color1) {
        this.r = color1.r;
        this.g = color1.g;
        this.b = color1.b;
        return this;
    },
    copyGammaToLinear: function(color1, gammaFactor) {
        if (gammaFactor === undefined) gammaFactor = 2;
        this.r = Math.pow(color1.r, gammaFactor);
        this.g = Math.pow(color1.g, gammaFactor);
        this.b = Math.pow(color1.b, gammaFactor);
        return this;
    },
    copyLinearToGamma: function(color1, gammaFactor) {
        if (gammaFactor === undefined) gammaFactor = 2;
        const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
        this.r = Math.pow(color1.r, safeInverse);
        this.g = Math.pow(color1.g, safeInverse);
        this.b = Math.pow(color1.b, safeInverse);
        return this;
    },
    convertGammaToLinear: function(gammaFactor) {
        this.copyGammaToLinear(this, gammaFactor);
        return this;
    },
    convertLinearToGamma: function(gammaFactor) {
        this.copyLinearToGamma(this, gammaFactor);
        return this;
    },
    copySRGBToLinear: function(color1) {
        this.r = SRGBToLinear(color1.r);
        this.g = SRGBToLinear(color1.g);
        this.b = SRGBToLinear(color1.b);
        return this;
    },
    copyLinearToSRGB: function(color1) {
        this.r = LinearToSRGB(color1.r);
        this.g = LinearToSRGB(color1.g);
        this.b = LinearToSRGB(color1.b);
        return this;
    },
    convertSRGBToLinear: function() {
        this.copySRGBToLinear(this);
        return this;
    },
    convertLinearToSRGB: function() {
        this.copyLinearToSRGB(this);
        return this;
    },
    getHex: function() {
        return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
    },
    getHexString: function() {
        return ('000000' + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function(target) {
        if (target === undefined) {
            console.warn('THREE.Color: .getHSL() target is now required');
            target = {
                h: 0,
                s: 0,
                l: 0
            };
        }
        const r2 = this.r, g = this.g, b2 = this.b;
        const max = Math.max(r2, g, b2);
        const min = Math.min(r2, g, b2);
        let hue, saturation;
        const lightness = (min + max) / 2;
        if (min === max) {
            hue = 0;
            saturation = 0;
        } else {
            const delta = max - min;
            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
            switch(max){
                case r2:
                    hue = (g - b2) / delta + (g < b2 ? 6 : 0);
                    break;
                case g:
                    hue = (b2 - r2) / delta + 2;
                    break;
                case b2:
                    hue = (r2 - g) / delta + 4;
                    break;
            }
            hue /= 6;
        }
        target.h = hue;
        target.s = saturation;
        target.l = lightness;
        return target;
    },
    getStyle: function() {
        return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
    },
    offsetHSL: function(h, s2, l1) {
        this.getHSL(_hslA);
        _hslA.h += h;
        _hslA.s += s2;
        _hslA.l += l1;
        this.setHSL(_hslA.h, _hslA.s, _hslA.l);
        return this;
    },
    add: function(color1) {
        this.r += color1.r;
        this.g += color1.g;
        this.b += color1.b;
        return this;
    },
    addColors: function(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
    },
    addScalar: function(s2) {
        this.r += s2;
        this.g += s2;
        this.b += s2;
        return this;
    },
    sub: function(color1) {
        this.r = Math.max(0, this.r - color1.r);
        this.g = Math.max(0, this.g - color1.g);
        this.b = Math.max(0, this.b - color1.b);
        return this;
    },
    multiply: function(color1) {
        this.r *= color1.r;
        this.g *= color1.g;
        this.b *= color1.b;
        return this;
    },
    multiplyScalar: function(s2) {
        this.r *= s2;
        this.g *= s2;
        this.b *= s2;
        return this;
    },
    lerp: function(color1, alpha) {
        this.r += (color1.r - this.r) * alpha;
        this.g += (color1.g - this.g) * alpha;
        this.b += (color1.b - this.b) * alpha;
        return this;
    },
    lerpHSL: function(color1, alpha) {
        this.getHSL(_hslA);
        color1.getHSL(_hslB);
        const h = MathUtils1.lerp(_hslA.h, _hslB.h, alpha);
        const s2 = MathUtils1.lerp(_hslA.s, _hslB.s, alpha);
        const l1 = MathUtils1.lerp(_hslA.l, _hslB.l, alpha);
        this.setHSL(h, s2, l1);
        return this;
    },
    equals: function(c2) {
        return c2.r === this.r && c2.g === this.g && c2.b === this.b;
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        this.r = array[offset];
        this.g = array[offset + 1];
        this.b = array[offset + 2];
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
    },
    fromBufferAttribute: function(attribute, index3) {
        this.r = attribute.getX(index3);
        this.g = attribute.getY(index3);
        this.b = attribute.getZ(index3);
        if (attribute.normalized === true) {
            this.r /= 255;
            this.g /= 255;
            this.b /= 255;
        }
        return this;
    },
    toJSON: function() {
        return this.getHex();
    }
});
Color2.NAMES = _colorKeywords;
const Color1 = Color2;
export { Color1 as Color };
function SphericalHarmonics33() {
    this.coefficients = [];
    for(let i8 = 0; i8 < 9; i8++)this.coefficients.push(new Vector31());
}
Object.assign(SphericalHarmonics33.prototype, {
    isSphericalHarmonics3: true,
    set: function(coefficients) {
        for(let i8 = 0; i8 < 9; i8++)this.coefficients[i8].copy(coefficients[i8]);
        return this;
    },
    zero: function() {
        for(let i8 = 0; i8 < 9; i8++)this.coefficients[i8].set(0, 0, 0);
        return this;
    },
    getAt: function(normal6, target) {
        const x6 = normal6.x, y6 = normal6.y, z5 = normal6.z;
        const coeff = this.coefficients;
        target.copy(coeff[0]).multiplyScalar(0.282095);
        target.addScaledVector(coeff[1], 0.488603 * y6);
        target.addScaledVector(coeff[2], 0.488603 * z5);
        target.addScaledVector(coeff[3], 0.488603 * x6);
        target.addScaledVector(coeff[4], 1.092548 * (x6 * y6));
        target.addScaledVector(coeff[5], 1.092548 * (y6 * z5));
        target.addScaledVector(coeff[6], 0.315392 * (3 * z5 * z5 - 1));
        target.addScaledVector(coeff[7], 1.092548 * (x6 * z5));
        target.addScaledVector(coeff[8], 0.546274 * (x6 * x6 - y6 * y6));
        return target;
    },
    getIrradianceAt: function(normal6, target) {
        const x6 = normal6.x, y6 = normal6.y, z5 = normal6.z;
        const coeff = this.coefficients;
        target.copy(coeff[0]).multiplyScalar(0.886227);
        target.addScaledVector(coeff[1], 1.023328 * y6);
        target.addScaledVector(coeff[2], 1.023328 * z5);
        target.addScaledVector(coeff[3], 1.023328 * x6);
        target.addScaledVector(coeff[4], 0.858086 * x6 * y6);
        target.addScaledVector(coeff[5], 0.858086 * y6 * z5);
        target.addScaledVector(coeff[6], 0.743125 * z5 * z5 - 0.247708);
        target.addScaledVector(coeff[7], 0.858086 * x6 * z5);
        target.addScaledVector(coeff[8], 0.429043 * (x6 * x6 - y6 * y6));
        return target;
    },
    add: function(sh) {
        for(let i8 = 0; i8 < 9; i8++)this.coefficients[i8].add(sh.coefficients[i8]);
        return this;
    },
    addScaledSH: function(sh, s2) {
        for(let i8 = 0; i8 < 9; i8++)this.coefficients[i8].addScaledVector(sh.coefficients[i8], s2);
        return this;
    },
    scale: function(s2) {
        for(let i8 = 0; i8 < 9; i8++)this.coefficients[i8].multiplyScalar(s2);
        return this;
    },
    lerp: function(sh, alpha) {
        for(let i8 = 0; i8 < 9; i8++)this.coefficients[i8].lerp(sh.coefficients[i8], alpha);
        return this;
    },
    equals: function(sh) {
        for(let i8 = 0; i8 < 9; i8++)if (!this.coefficients[i8].equals(sh.coefficients[i8])) return false;
        return true;
    },
    copy: function(sh) {
        return this.set(sh.coefficients);
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    fromArray: function(array, offset) {
        if (offset === undefined) offset = 0;
        const coefficients = this.coefficients;
        for(let i8 = 0; i8 < 9; i8++)coefficients[i8].fromArray(array, offset + i8 * 3);
        return this;
    },
    toArray: function(array, offset) {
        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;
        const coefficients = this.coefficients;
        for(let i8 = 0; i8 < 9; i8++)coefficients[i8].toArray(array, offset + i8 * 3);
        return array;
    }
});
Object.assign(SphericalHarmonics33, {
    getBasisAt: function(normal6, shBasis) {
        const x6 = normal6.x, y6 = normal6.y, z5 = normal6.z;
        shBasis[0] = 0.282095;
        shBasis[1] = 0.488603 * y6;
        shBasis[2] = 0.488603 * z5;
        shBasis[3] = 0.488603 * x6;
        shBasis[4] = 1.092548 * x6 * y6;
        shBasis[5] = 1.092548 * y6 * z5;
        shBasis[6] = 0.315392 * (3 * z5 * z5 - 1);
        shBasis[7] = 1.092548 * x6 * z5;
        shBasis[8] = 0.546274 * (x6 * x6 - y6 * y6);
    }
});
const SphericalHarmonics31 = SphericalHarmonics33;
export { SphericalHarmonics31 as SphericalHarmonics3 };
function ImmediateRenderObject(material) {
    Object3D1.call(this);
    this.material = material;
    this.render = function() {
    };
    this.hasPositions = false;
    this.hasNormals = false;
    this.hasColors = false;
    this.hasUvs = false;
    this.positionArray = null;
    this.normalArray = null;
    this.colorArray = null;
    this.uvArray = null;
    this.count = 0;
}
ImmediateRenderObject.prototype = Object.create(Object3D1.prototype);
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
ImmediateRenderObject.prototype.isImmediateRenderObject = true;
const ImmediateRenderObject1 = ImmediateRenderObject;
export { ImmediateRenderObject1 as ImmediateRenderObject };
const _vector9 = new Vector31();
class SpotLightHelper extends Object3D1 {
    dispose() {
        this.cone.geometry.dispose();
        this.cone.material.dispose();
    }
    update() {
        this.light.updateMatrixWorld();
        const coneLength = this.light.distance ? this.light.distance : 1000;
        const coneWidth = coneLength * Math.tan(this.light.angle);
        this.cone.scale.set(coneWidth, coneWidth, coneLength);
        _vector9.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt(_vector9);
        if (this.color !== undefined) this.cone.material.color.set(this.color);
        else this.cone.material.color.copy(this.light.color);
    }
    constructor(light, color1){
        super();
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color1;
        const geometry = new BufferGeometry1();
        const positions = [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            -1,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            -1,
            1
        ];
        for(let i8 = 0, j4 = 1, l1 = 32; i8 < l1; i8++, j4++){
            const p11 = i8 / l1 * Math.PI * 2;
            const p2 = j4 / l1 * Math.PI * 2;
            positions.push(Math.cos(p11), Math.sin(p11), 1, Math.cos(p2), Math.sin(p2), 1);
        }
        geometry.setAttribute('position', new Float32BufferAttribute1(positions, 3));
        const material8 = new LineBasicMaterial1({
            fog: false,
            toneMapped: false
        });
        this.cone = new LineSegments1(geometry, material8);
        this.add(this.cone);
        this.update();
    }
}
const SpotLightHelper1 = SpotLightHelper;
export { SpotLightHelper1 as SpotLightHelper };
const _vector10 = new Vector31();
const _boneMatrix = new Matrix41();
const _matrixWorldInv = new Matrix41();
class SkeletonHelper extends LineSegments1 {
    updateMatrixWorld(force) {
        const bones = this.bones;
        const geometry1 = this.geometry;
        const position = geometry1.getAttribute('position');
        _matrixWorldInv.getInverse(this.root.matrixWorld);
        for(let i9 = 0, j5 = 0; i9 < bones.length; i9++){
            const bone = bones[i9];
            if (bone.parent && bone.parent.isBone) {
                _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
                _vector10.setFromMatrixPosition(_boneMatrix);
                position.setXYZ(j5, _vector10.x, _vector10.y, _vector10.z);
                _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
                _vector10.setFromMatrixPosition(_boneMatrix);
                position.setXYZ(j5 + 1, _vector10.x, _vector10.y, _vector10.z);
                j5 += 2;
            }
        }
        geometry1.getAttribute('position').needsUpdate = true;
        super.updateMatrixWorld(force);
    }
    constructor(object1){
        const bones = getBoneList(object1);
        const geometry1 = new BufferGeometry1();
        const vertices17 = [];
        const colors = [];
        const color11 = new Color1(0, 0, 1);
        const color2 = new Color1(0, 1, 0);
        for(let i9 = 0; i9 < bones.length; i9++){
            const bone = bones[i9];
            if (bone.parent && bone.parent.isBone) {
                vertices17.push(0, 0, 0);
                vertices17.push(0, 0, 0);
                colors.push(color11.r, color11.g, color11.b);
                colors.push(color2.r, color2.g, color2.b);
            }
        }
        geometry1.setAttribute('position', new Float32BufferAttribute1(vertices17, 3));
        geometry1.setAttribute('color', new Float32BufferAttribute1(colors, 3));
        const material1 = new LineBasicMaterial1({
            vertexColors: true,
            depthTest: false,
            depthWrite: false,
            toneMapped: false,
            transparent: true
        });
        super(geometry1, material1);
        this.type = 'SkeletonHelper';
        this.isSkeletonHelper = true;
        this.root = object1;
        this.bones = bones;
        this.matrix = object1.matrixWorld;
        this.matrixAutoUpdate = false;
    }
}
function getBoneList(object1) {
    const boneList = [];
    if (object1 && object1.isBone) boneList.push(object1);
    for(let i12 = 0; i12 < object1.children.length; i12++)boneList.push.apply(boneList, getBoneList(object1.children[i12]));
    return boneList;
}
const SkeletonHelper1 = SkeletonHelper;
export { SkeletonHelper1 as SkeletonHelper };
// SphereBufferGeometry
class SphereBufferGeometry1 extends BufferGeometry1 {
    constructor(radius8, widthSegments2, heightSegments2, phiStart, phiLength, thetaStart, thetaLength){
        super();
        this.type = 'SphereBufferGeometry';
        this.parameters = {
            radius: radius8,
            widthSegments: widthSegments2,
            heightSegments: heightSegments2,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
        radius8 = radius8 || 1;
        widthSegments2 = Math.max(3, Math.floor(widthSegments2) || 8);
        heightSegments2 = Math.max(2, Math.floor(heightSegments2) || 6);
        phiStart = phiStart !== undefined ? phiStart : 0;
        phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
        const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
        let index2 = 0;
        const grid = [];
        const vertex3 = new Vector31();
        const normal5 = new Vector31();
        // buffers
        const indices10 = [];
        const vertices10 = [];
        const normals5 = [];
        const uvs5 = [];
        // generate vertices, normals and uvs
        for(let iy1 = 0; iy1 <= heightSegments2; iy1++){
            const verticesRow = [];
            const v = iy1 / heightSegments2;
            // special case for the poles
            let uOffset = 0;
            if (iy1 == 0 && thetaStart == 0) uOffset = 0.5 / widthSegments2;
            else if (iy1 == heightSegments2 && thetaEnd == Math.PI) uOffset = -0.5 / widthSegments2;
            for(let ix2 = 0; ix2 <= widthSegments2; ix2++){
                const u = ix2 / widthSegments2;
                // vertex
                vertex3.x = -radius8 * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                vertex3.y = radius8 * Math.cos(thetaStart + v * thetaLength);
                vertex3.z = radius8 * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                vertices10.push(vertex3.x, vertex3.y, vertex3.z);
                // normal
                normal5.copy(vertex3).normalize();
                normals5.push(normal5.x, normal5.y, normal5.z);
                // uv
                uvs5.push(u + uOffset, 1 - v);
                verticesRow.push(index2++);
            }
            grid.push(verticesRow);
        }
        // indices
        for(let iy1 = 0; iy1 < heightSegments2; iy1++)for(let ix1 = 0; ix1 < widthSegments2; ix1++){
            const a2 = grid[iy1][ix1 + 1];
            const b2 = grid[iy1][ix1];
            const c2 = grid[iy1 + 1][ix1];
            const d = grid[iy1 + 1][ix1 + 1];
            if (iy1 !== 0 || thetaStart > 0) indices10.push(a2, b2, d);
            if (iy1 !== heightSegments2 - 1 || thetaEnd < Math.PI) indices10.push(b2, c2, d);
        }
        // build geometry
        this.setIndex(indices10);
        this.setAttribute('position', new Float32BufferAttribute1(vertices10, 3));
        this.setAttribute('normal', new Float32BufferAttribute1(normals5, 3));
        this.setAttribute('uv', new Float32BufferAttribute1(uvs5, 2));
    }
}
const SphereBufferGeometry2 = SphereBufferGeometry1;
class PointLightHelper extends Mesh1 {
    dispose() {
        this.geometry.dispose();
        this.material.dispose();
    }
    update() {
        if (this.color !== undefined) this.material.color.set(this.color);
        else this.material.color.copy(this.light.color);
    }
    constructor(light1, sphereSize, color3){
        const geometry2 = new SphereBufferGeometry2(sphereSize, 4, 2);
        const material2 = new MeshBasicMaterial1({
            wireframe: true,
            fog: false,
            toneMapped: false
        });
        super(geometry2, material2);
        this.light = light1;
        this.light.updateMatrixWorld();
        this.color = color3;
        this.type = 'PointLightHelper';
        this.matrix = this.light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.update();
    }
}
const PointLightHelper1 = PointLightHelper;
export { PointLightHelper1 as PointLightHelper };
// OctahedronBufferGeometry
class OctahedronBufferGeometry1 extends PolyhedronBufferGeometry1 {
    constructor(radius2, detail2){
        const vertices4 = [
            1,
            0,
            0,
            -1,
            0,
            0,
            0,
            1,
            0,
            0,
            -1,
            0,
            0,
            0,
            1,
            0,
            0,
            -1
        ];
        const indices4 = [
            0,
            2,
            4,
            0,
            4,
            3,
            0,
            3,
            5,
            0,
            5,
            2,
            1,
            2,
            5,
            1,
            5,
            3,
            1,
            3,
            4,
            1,
            4,
            2
        ];
        super(vertices4, indices4, radius2, detail2);
        this.type = 'OctahedronBufferGeometry';
        this.parameters = {
            radius: radius2,
            detail: detail2
        };
    }
}
const OctahedronBufferGeometry2 = OctahedronBufferGeometry1;
const _vector13 = new Vector31();
const _color1 = new Color1();
const _color2 = new Color1();
class HemisphereLightHelper extends Object3D1 {
    dispose() {
        this.children[0].geometry.dispose();
        this.children[0].material.dispose();
    }
    update() {
        const mesh = this.children[0];
        if (this.color !== undefined) this.material.color.set(this.color);
        else {
            const colors1 = mesh.geometry.getAttribute('color');
            _color1.copy(this.light.color);
            _color2.copy(this.light.groundColor);
            for(let i10 = 0, l2 = colors1.count; i10 < l2; i10++){
                const color4 = i10 < l2 / 2 ? _color1 : _color2;
                colors1.setXYZ(i10, color4.r, color4.g, color4.b);
            }
            colors1.needsUpdate = true;
        }
        mesh.lookAt(_vector13.setFromMatrixPosition(this.light.matrixWorld).negate());
    }
    constructor(light2, size, color4){
        super();
        this.light = light2;
        this.light.updateMatrixWorld();
        this.matrix = light2.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color4;
        const geometry3 = new OctahedronBufferGeometry2(size);
        geometry3.rotateY(Math.PI * 0.5);
        this.material = new MeshBasicMaterial1({
            wireframe: true,
            fog: false,
            toneMapped: false
        });
        if (this.color === undefined) this.material.vertexColors = true;
        const position = geometry3.getAttribute('position');
        const colors1 = new Float32Array(position.count * 3);
        geometry3.setAttribute('color', new BufferAttribute1(colors1, 3));
        this.add(new Mesh1(geometry3, this.material));
        this.update();
    }
}
const HemisphereLightHelper1 = HemisphereLightHelper;
export { HemisphereLightHelper1 as HemisphereLightHelper };
class GridHelper extends LineSegments1 {
    constructor(size1, divisions, color12, color21){
        size1 = size1 || 10;
        divisions = divisions || 10;
        color12 = new Color1(color12 !== undefined ? color12 : 4473924);
        color21 = new Color1(color21 !== undefined ? color21 : 8947848);
        const center2 = divisions / 2;
        const step = size1 / divisions;
        const halfSize = size1 / 2;
        const vertices18 = [], colors2 = [];
        for(let i10 = 0, j5 = 0, k = -halfSize; i10 <= divisions; i10++, k += step){
            vertices18.push(-halfSize, 0, k, halfSize, 0, k);
            vertices18.push(k, 0, -halfSize, k, 0, halfSize);
            const color5 = i10 === center2 ? color12 : color21;
            color5.toArray(colors2, j5);
            j5 += 3;
            color5.toArray(colors2, j5);
            j5 += 3;
            color5.toArray(colors2, j5);
            j5 += 3;
            color5.toArray(colors2, j5);
            j5 += 3;
        }
        const geometry4 = new BufferGeometry1();
        geometry4.setAttribute('position', new Float32BufferAttribute1(vertices18, 3));
        geometry4.setAttribute('color', new Float32BufferAttribute1(colors2, 3));
        const material3 = new LineBasicMaterial1({
            vertexColors: true,
            toneMapped: false
        });
        super(geometry4, material3);
        this.type = 'GridHelper';
    }
}
const GridHelper1 = GridHelper;
export { GridHelper1 as GridHelper };
class PolarGridHelper extends LineSegments1 {
    constructor(radius13, radials, circles, divisions1, color13, color22){
        radius13 = radius13 || 10;
        radials = radials || 16;
        circles = circles || 8;
        divisions1 = divisions1 || 64;
        color13 = new Color1(color13 !== undefined ? color13 : 4473924);
        color22 = new Color1(color22 !== undefined ? color22 : 8947848);
        const vertices19 = [];
        const colors3 = [];
        // create the radials
        for(let i12 = 0; i12 <= radials; i12++){
            const v = i12 / radials * (Math.PI * 2);
            const x6 = Math.sin(v) * radius13;
            const z5 = Math.cos(v) * radius13;
            vertices19.push(0, 0, 0);
            vertices19.push(x6, 0, z5);
            const color5 = i12 & 1 ? color13 : color22;
            colors3.push(color5.r, color5.g, color5.b);
            colors3.push(color5.r, color5.g, color5.b);
        }
        // create the circles
        for(let i12 = 0; i12 <= circles; i12++){
            const color5 = i12 & 1 ? color13 : color22;
            const r2 = radius13 - radius13 / circles * i12;
            for(let j6 = 0; j6 < divisions1; j6++){
                // first vertex
                let v = j6 / divisions1 * (Math.PI * 2);
                let x6 = Math.sin(v) * r2;
                let z5 = Math.cos(v) * r2;
                vertices19.push(x6, 0, z5);
                colors3.push(color5.r, color5.g, color5.b);
                // second vertex
                v = (j6 + 1) / divisions1 * (Math.PI * 2);
                x6 = Math.sin(v) * r2;
                z5 = Math.cos(v) * r2;
                vertices19.push(x6, 0, z5);
                colors3.push(color5.r, color5.g, color5.b);
            }
        }
        const geometry5 = new BufferGeometry1();
        geometry5.setAttribute('position', new Float32BufferAttribute1(vertices19, 3));
        geometry5.setAttribute('color', new Float32BufferAttribute1(colors3, 3));
        const material4 = new LineBasicMaterial1({
            vertexColors: true,
            toneMapped: false
        });
        super(geometry5, material4);
        this.type = 'PolarGridHelper';
    }
}
const PolarGridHelper1 = PolarGridHelper;
export { PolarGridHelper1 as PolarGridHelper };
const _v16 = new Vector31();
const _v23 = new Vector31();
const _v31 = new Vector31();
class DirectionalLightHelper extends Object3D1 {
    dispose() {
        this.lightPlane.geometry.dispose();
        this.lightPlane.material.dispose();
        this.targetLine.geometry.dispose();
        this.targetLine.material.dispose();
    }
    update() {
        _v16.setFromMatrixPosition(this.light.matrixWorld);
        _v23.setFromMatrixPosition(this.light.target.matrixWorld);
        _v31.subVectors(_v23, _v16);
        this.lightPlane.lookAt(_v23);
        if (this.color !== undefined) {
            this.lightPlane.material.color.set(this.color);
            this.targetLine.material.color.set(this.color);
        } else {
            this.lightPlane.material.color.copy(this.light.color);
            this.targetLine.material.color.copy(this.light.color);
        }
        this.targetLine.lookAt(_v23);
        this.targetLine.scale.z = _v31.length();
    }
    constructor(light3, size2, color5){
        super();
        this.light = light3;
        this.light.updateMatrixWorld();
        this.matrix = light3.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color5;
        if (size2 === undefined) size2 = 1;
        let geometry6 = new BufferGeometry1();
        geometry6.setAttribute('position', new Float32BufferAttribute1([
            -size2,
            size2,
            0,
            size2,
            size2,
            0,
            size2,
            -size2,
            0,
            -size2,
            -size2,
            0,
            -size2,
            size2,
            0
        ], 3));
        const material5 = new LineBasicMaterial1({
            fog: false,
            toneMapped: false
        });
        this.lightPlane = new Line1(geometry6, material5);
        this.add(this.lightPlane);
        geometry6 = new BufferGeometry1();
        geometry6.setAttribute('position', new Float32BufferAttribute1([
            0,
            0,
            0,
            0,
            0,
            1
        ], 3));
        this.targetLine = new Line1(geometry6, material5);
        this.add(this.targetLine);
        this.update();
    }
}
const DirectionalLightHelper1 = DirectionalLightHelper;
export { DirectionalLightHelper1 as DirectionalLightHelper };
const _vector14 = new Vector31();
const _camera = new Camera1();
/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */
class CameraHelper extends LineSegments1 {
    update() {
        const geometry7 = this.geometry;
        const pointMap = this.pointMap;
        const w3 = 1, h = 1;
        // we need just camera projection matrix inverse
        // world matrix must be identity
        _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
        // center / target
        setPoint('c', pointMap, geometry7, _camera, 0, 0, -1);
        setPoint('t', pointMap, geometry7, _camera, 0, 0, 1);
        // near
        setPoint('n1', pointMap, geometry7, _camera, -w3, -h, -1);
        setPoint('n2', pointMap, geometry7, _camera, w3, -h, -1);
        setPoint('n3', pointMap, geometry7, _camera, -w3, h, -1);
        setPoint('n4', pointMap, geometry7, _camera, w3, h, -1);
        // far
        setPoint('f1', pointMap, geometry7, _camera, -w3, -h, 1);
        setPoint('f2', pointMap, geometry7, _camera, w3, -h, 1);
        setPoint('f3', pointMap, geometry7, _camera, -w3, h, 1);
        setPoint('f4', pointMap, geometry7, _camera, w3, h, 1);
        // up
        setPoint('u1', pointMap, geometry7, _camera, w3 * 0.7, h * 1.1, -1);
        setPoint('u2', pointMap, geometry7, _camera, -w3 * 0.7, h * 1.1, -1);
        setPoint('u3', pointMap, geometry7, _camera, 0, h * 2, -1);
        // cross
        setPoint('cf1', pointMap, geometry7, _camera, -w3, 0, 1);
        setPoint('cf2', pointMap, geometry7, _camera, w3, 0, 1);
        setPoint('cf3', pointMap, geometry7, _camera, 0, -h, 1);
        setPoint('cf4', pointMap, geometry7, _camera, 0, h, 1);
        setPoint('cn1', pointMap, geometry7, _camera, -w3, 0, -1);
        setPoint('cn2', pointMap, geometry7, _camera, w3, 0, -1);
        setPoint('cn3', pointMap, geometry7, _camera, 0, -h, -1);
        setPoint('cn4', pointMap, geometry7, _camera, 0, h, -1);
        geometry7.getAttribute('position').needsUpdate = true;
    }
    constructor(camera){
        const geometry7 = new BufferGeometry1();
        const material6 = new LineBasicMaterial1({
            color: 16777215,
            vertexColors: true,
            toneMapped: false
        });
        const vertices20 = [];
        const colors4 = [];
        const pointMap = {
        };
        // colors
        const colorFrustum = new Color1(16755200);
        const colorCone = new Color1(16711680);
        const colorUp = new Color1(43775);
        const colorTarget = new Color1(16777215);
        const colorCross = new Color1(3355443);
        // near
        addLine('n1', 'n2', colorFrustum);
        addLine('n2', 'n4', colorFrustum);
        addLine('n4', 'n3', colorFrustum);
        addLine('n3', 'n1', colorFrustum);
        // far
        addLine('f1', 'f2', colorFrustum);
        addLine('f2', 'f4', colorFrustum);
        addLine('f4', 'f3', colorFrustum);
        addLine('f3', 'f1', colorFrustum);
        // sides
        addLine('n1', 'f1', colorFrustum);
        addLine('n2', 'f2', colorFrustum);
        addLine('n3', 'f3', colorFrustum);
        addLine('n4', 'f4', colorFrustum);
        // cone
        addLine('p', 'n1', colorCone);
        addLine('p', 'n2', colorCone);
        addLine('p', 'n3', colorCone);
        addLine('p', 'n4', colorCone);
        // up
        addLine('u1', 'u2', colorUp);
        addLine('u2', 'u3', colorUp);
        addLine('u3', 'u1', colorUp);
        // target
        addLine('c', 't', colorTarget);
        addLine('p', 'c', colorCross);
        // cross
        addLine('cn1', 'cn2', colorCross);
        addLine('cn3', 'cn4', colorCross);
        addLine('cf1', 'cf2', colorCross);
        addLine('cf3', 'cf4', colorCross);
        function addLine(a2, b2, color6) {
            addPoint(a2, color6);
            addPoint(b2, color6);
        }
        function addPoint(id, color6) {
            vertices20.push(0, 0, 0);
            colors4.push(color6.r, color6.g, color6.b);
            if (pointMap[id] === undefined) pointMap[id] = [];
            pointMap[id].push(vertices20.length / 3 - 1);
        }
        geometry7.setAttribute('position', new Float32BufferAttribute1(vertices20, 3));
        geometry7.setAttribute('color', new Float32BufferAttribute1(colors4, 3));
        super(geometry7, material6);
        this.type = 'CameraHelper';
        this.camera = camera;
        if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
        this.matrix = camera.matrixWorld;
        this.matrixAutoUpdate = false;
        this.pointMap = pointMap;
        this.update();
    }
}
function setPoint(point, pointMap1, geometry11, camera1, x6, y6, z5) {
    _vector14.set(x6, y6, z5).unproject(camera1);
    const points1 = pointMap1[point];
    if (points1 !== undefined) {
        const position1 = geometry11.getAttribute('position');
        for(let i13 = 0, l2 = points1.length; i13 < l2; i13++)position1.setXYZ(points1[i13], _vector14.x, _vector14.y, _vector14.z);
    }
}
const CameraHelper1 = CameraHelper;
export { CameraHelper1 as CameraHelper };
const _box3 = new Box31();
class BoxHelper extends LineSegments1 {
    update(object) {
        if (object !== undefined) console.warn('THREE.BoxHelper: .update() has no longer arguments.');
        if (this.object !== undefined) _box3.setFromObject(this.object);
        if (_box3.isEmpty()) return;
        const min = _box3.min;
        const max = _box3.max;
        /*
			5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/
        const position1 = this.geometry.attributes.position;
        const array = position1.array;
        array[0] = max.x;
        array[1] = max.y;
        array[2] = max.z;
        array[3] = min.x;
        array[4] = max.y;
        array[5] = max.z;
        array[6] = min.x;
        array[7] = min.y;
        array[8] = max.z;
        array[9] = max.x;
        array[10] = min.y;
        array[11] = max.z;
        array[12] = max.x;
        array[13] = max.y;
        array[14] = min.z;
        array[15] = min.x;
        array[16] = max.y;
        array[17] = min.z;
        array[18] = min.x;
        array[19] = min.y;
        array[20] = min.z;
        array[21] = max.x;
        array[22] = min.y;
        array[23] = min.z;
        position1.needsUpdate = true;
        this.geometry.computeBoundingSphere();
    }
    setFromObject(object) {
        this.object = object;
        this.update();
        return this;
    }
    copy(source) {
        LineSegments1.prototype.copy.call(this, source);
        this.object = source.object;
        return this;
    }
    constructor(object2, color6){
        if (color6 === undefined) color6 = 16776960;
        const indices17 = new Uint16Array([
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            0,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            4,
            0,
            4,
            1,
            5,
            2,
            6,
            3,
            7
        ]);
        const positions1 = new Float32Array(24);
        const geometry8 = new BufferGeometry1();
        geometry8.setIndex(new BufferAttribute1(indices17, 1));
        geometry8.setAttribute('position', new BufferAttribute1(positions1, 3));
        super(geometry8, new LineBasicMaterial1({
            color: color6,
            toneMapped: false
        }));
        this.object = object2;
        this.type = 'BoxHelper';
        this.matrixAutoUpdate = false;
        this.update();
    }
}
const BoxHelper1 = BoxHelper;
export { BoxHelper1 as BoxHelper };
class Box3Helper extends LineSegments1 {
    updateMatrixWorld(force) {
        const box = this.box;
        if (box.isEmpty()) return;
        box.getCenter(this.position);
        box.getSize(this.scale);
        this.scale.multiplyScalar(0.5);
        super.updateMatrixWorld(force);
    }
    constructor(box, color7){
        if (color7 === undefined) color7 = 16776960;
        const indices18 = new Uint16Array([
            0,
            1,
            1,
            2,
            2,
            3,
            3,
            0,
            4,
            5,
            5,
            6,
            6,
            7,
            7,
            4,
            0,
            4,
            1,
            5,
            2,
            6,
            3,
            7
        ]);
        const positions2 = [
            1,
            1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            -1
        ];
        const geometry9 = new BufferGeometry1();
        geometry9.setIndex(new BufferAttribute1(indices18, 1));
        geometry9.setAttribute('position', new Float32BufferAttribute1(positions2, 3));
        super(geometry9, new LineBasicMaterial1({
            color: color7,
            toneMapped: false
        }));
        this.box = box;
        this.type = 'Box3Helper';
        this.geometry.computeBoundingSphere();
    }
}
const Box3Helper1 = Box3Helper;
export { Box3Helper1 as Box3Helper };
class PlaneHelper extends Line1 {
    updateMatrixWorld(force) {
        let scale = -this.plane.constant;
        if (Math.abs(scale) < 0.00000001) scale = 0.00000001; // sign does not matter
        this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
        this.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here
        this.lookAt(this.plane.normal);
        super.updateMatrixWorld(force);
    }
    constructor(plane, size3, hex){
        const color8 = hex !== undefined ? hex : 16776960;
        const positions3 = [
            1,
            -1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            -1,
            1,
            1,
            1,
            1,
            0,
            0,
            1,
            0,
            0,
            0
        ];
        const geometry10 = new BufferGeometry1();
        geometry10.setAttribute('position', new Float32BufferAttribute1(positions3, 3));
        geometry10.computeBoundingSphere();
        super(geometry10, new LineBasicMaterial1({
            color: color8,
            toneMapped: false
        }));
        this.type = 'PlaneHelper';
        this.plane = plane;
        this.size = size3 === undefined ? 1 : size3;
        const positions21 = [
            1,
            1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            -1,
            1
        ];
        const geometry21 = new BufferGeometry1();
        geometry21.setAttribute('position', new Float32BufferAttribute1(positions21, 3));
        geometry21.computeBoundingSphere();
        this.add(new Mesh1(geometry21, new MeshBasicMaterial1({
            color: color8,
            opacity: 0.2,
            transparent: true,
            depthWrite: false,
            toneMapped: false
        })));
    }
}
const PlaneHelper1 = PlaneHelper;
export { PlaneHelper1 as PlaneHelper };
const _axis = new Vector31();
let _lineGeometry, _coneGeometry;
class ArrowHelper extends Object3D1 {
    setDirection(dir) {
        // dir is assumed to be normalized
        if (dir.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
        else if (dir.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
        else {
            _axis.set(dir.z, 0, -dir.x).normalize();
            const radians = Math.acos(dir.y);
            this.quaternion.setFromAxisAngle(_axis, radians);
        }
    }
    setLength(length, headLength, headWidth) {
        if (headLength === undefined) headLength = 0.2 * length;
        if (headWidth === undefined) headWidth = 0.2 * headLength;
        this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458
        this.line.updateMatrix();
        this.cone.scale.set(headWidth, headLength, headWidth);
        this.cone.position.y = length;
        this.cone.updateMatrix();
    }
    setColor(color) {
        this.line.material.color.set(color);
        this.cone.material.color.set(color);
    }
    copy(source) {
        super.copy(source, false);
        this.line.copy(source.line);
        this.cone.copy(source.cone);
        return this;
    }
    constructor(dir, origin2, length, color10, headLength, headWidth){
        super();
        // dir is assumed to be normalized
        this.type = 'ArrowHelper';
        if (dir === undefined) dir = new Vector31(0, 0, 1);
        if (origin2 === undefined) origin2 = new Vector31(0, 0, 0);
        if (length === undefined) length = 1;
        if (color10 === undefined) color10 = 16776960;
        if (headLength === undefined) headLength = 0.2 * length;
        if (headWidth === undefined) headWidth = 0.2 * headLength;
        if (_lineGeometry === undefined) {
            _lineGeometry = new BufferGeometry1();
            _lineGeometry.setAttribute('position', new Float32BufferAttribute1([
                0,
                0,
                0,
                0,
                1,
                0
            ], 3));
            _coneGeometry = new CylinderBufferGeometry1(0, 0.5, 1, 5, 1);
            _coneGeometry.translate(0, -0.5, 0);
        }
        this.position.copy(origin2);
        this.line = new Line1(_lineGeometry, new LineBasicMaterial1({
            color: color10,
            toneMapped: false
        }));
        this.line.matrixAutoUpdate = false;
        this.add(this.line);
        this.cone = new Mesh1(_coneGeometry, new MeshBasicMaterial1({
            color: color10,
            toneMapped: false
        }));
        this.cone.matrixAutoUpdate = false;
        this.add(this.cone);
        this.setDirection(dir);
        this.setLength(length, headLength, headWidth);
    }
}
const ArrowHelper1 = ArrowHelper;
export { ArrowHelper1 as ArrowHelper };
class AxesHelper extends LineSegments1 {
    constructor(size4){
        size4 = size4 || 1;
        const vertices22 = [
            0,
            0,
            0,
            size4,
            0,
            0,
            0,
            0,
            0,
            0,
            size4,
            0,
            0,
            0,
            0,
            0,
            0,
            size4
        ];
        const colors5 = [
            1,
            0,
            0,
            1,
            0.6,
            0,
            0,
            1,
            0,
            0.6,
            1,
            0,
            0,
            0,
            1,
            0,
            0.6,
            1
        ];
        const geometry11 = new BufferGeometry1();
        geometry11.setAttribute('position', new Float32BufferAttribute1(vertices22, 3));
        geometry11.setAttribute('color', new Float32BufferAttribute1(colors5, 3));
        const material7 = new LineBasicMaterial1({
            vertexColors: true,
            toneMapped: false
        });
        super(geometry11, material7);
        this.type = 'AxesHelper';
    }
}
const AxesHelper1 = AxesHelper;
export { AxesHelper1 as AxesHelper };
function ArcCurve1(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    EllipseCurve6.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.type = 'ArcCurve';
}
ArcCurve1.prototype = Object.create(EllipseCurve6.prototype);
ArcCurve1.prototype.constructor = ArcCurve1;
ArcCurve1.prototype.isArcCurve = true;
/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/
function Curve() {
    this.type = 'Curve';
    this.arcLengthDivisions = 200;
}
Object.assign(Curve.prototype, {
    // Virtual base class method to overwrite and implement in subclasses
    //	- t [0 .. 1]
    getPoint: function() {
        console.warn('THREE.Curve: .getPoint() not implemented.');
        return null;
    },
    // Get point at relative position in curve according to arc length
    // - u [0 .. 1]
    getPointAt: function(u, optionalTarget) {
        const t3 = this.getUtoTmapping(u);
        return this.getPoint(t3, optionalTarget);
    },
    // Get sequence of points using getPoint( t )
    getPoints: function(divisions2) {
        if (divisions2 === undefined) divisions2 = 5;
        const points1 = [];
        for(let d = 0; d <= divisions2; d++)points1.push(this.getPoint(d / divisions2));
        return points1;
    },
    // Get sequence of points using getPointAt( u )
    getSpacedPoints: function(divisions2) {
        if (divisions2 === undefined) divisions2 = 5;
        const points1 = [];
        for(let d = 0; d <= divisions2; d++)points1.push(this.getPointAt(d / divisions2));
        return points1;
    },
    // Get total curve arc length
    getLength: function() {
        const lengths = this.getLengths();
        return lengths[lengths.length - 1];
    },
    // Get list of cumulative segment lengths
    getLengths: function(divisions2) {
        if (divisions2 === undefined) divisions2 = this.arcLengthDivisions;
        if (this.cacheArcLengths && this.cacheArcLengths.length === divisions2 + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = false;
        const cache = [];
        let current, last = this.getPoint(0);
        let sum = 0;
        cache.push(0);
        for(let p2 = 1; p2 <= divisions2; p2++){
            current = this.getPoint(p2 / divisions2);
            sum += current.distanceTo(last);
            cache.push(sum);
            last = current;
        }
        this.cacheArcLengths = cache;
        return cache; // { sums: cache, sum: sum }; Sum is in the last element.
    },
    updateArcLengths: function() {
        this.needsUpdate = true;
        this.getLengths();
    },
    // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
    getUtoTmapping: function(u, distance) {
        const arcLengths = this.getLengths();
        let i13 = 0;
        const il = arcLengths.length;
        let targetArcLength; // The targeted u distance value to get
        if (distance) targetArcLength = distance;
        else targetArcLength = u * arcLengths[il - 1];
        // binary search for the index with largest value smaller than target u distance
        let low = 0, high = il - 1, comparison;
        while(low <= high){
            i13 = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
            comparison = arcLengths[i13] - targetArcLength;
            if (comparison < 0) low = i13 + 1;
            else if (comparison > 0) high = i13 - 1;
            else {
                high = i13;
                break;
            }
        }
        i13 = high;
        if (arcLengths[i13] === targetArcLength) return i13 / (il - 1);
        // we could get finer grain at lengths, or use simple interpolation between two points
        const lengthBefore = arcLengths[i13];
        const lengthAfter = arcLengths[i13 + 1];
        const segmentLength = lengthAfter - lengthBefore;
        // determine where we are between the 'before' and 'after' points
        const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
        // add that fractional amount to t
        const t3 = (i13 + segmentFraction) / (il - 1);
        return t3;
    },
    // Returns a unit vector tangent at t
    // In case any sub curve does not implement its tangent derivation,
    // 2 points a small delta apart will be used to find its gradient
    // which seems to give a reasonable approximation
    getTangent: function(t3, optionalTarget) {
        const delta = 0.0001;
        let t11 = t3 - delta;
        let t21 = t3 + delta;
        // Capping in case of danger
        if (t11 < 0) t11 = 0;
        if (t21 > 1) t21 = 1;
        const pt1 = this.getPoint(t11);
        const pt2 = this.getPoint(t21);
        const tangent = optionalTarget || (pt1.isVector2 ? new Vector21() : new Vector31());
        tangent.copy(pt2).sub(pt1).normalize();
        return tangent;
    },
    getTangentAt: function(u, optionalTarget) {
        const t3 = this.getUtoTmapping(u);
        return this.getTangent(t3, optionalTarget);
    },
    computeFrenetFrames: function(segments2, closed1) {
        // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
        const normal6 = new Vector31();
        const tangents = [];
        const normals10 = [];
        const binormals = [];
        const vec = new Vector31();
        const mat = new Matrix41();
        // compute the tangent vectors for each segment on the curve
        for(let i13 = 0; i13 <= segments2; i13++){
            const u = i13 / segments2;
            tangents[i13] = this.getTangentAt(u, new Vector31());
            tangents[i13].normalize();
        }
        // select an initial normal vector perpendicular to the first tangent vector,
        // and in the direction of the minimum tangent xyz component
        normals10[0] = new Vector31();
        binormals[0] = new Vector31();
        let min = Number.MAX_VALUE;
        const tx = Math.abs(tangents[0].x);
        const ty = Math.abs(tangents[0].y);
        const tz = Math.abs(tangents[0].z);
        if (tx <= min) {
            min = tx;
            normal6.set(1, 0, 0);
        }
        if (ty <= min) {
            min = ty;
            normal6.set(0, 1, 0);
        }
        if (tz <= min) normal6.set(0, 0, 1);
        vec.crossVectors(tangents[0], normal6).normalize();
        normals10[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals10[0]);
        // compute the slowly-varying normal and binormal vectors for each segment on the curve
        for(let i13 = 1; i13 <= segments2; i13++){
            normals10[i13] = normals10[i13 - 1].clone();
            binormals[i13] = binormals[i13 - 1].clone();
            vec.crossVectors(tangents[i13 - 1], tangents[i13]);
            if (vec.length() > Number.EPSILON) {
                vec.normalize();
                const theta2 = Math.acos(MathUtils1.clamp(tangents[i13 - 1].dot(tangents[i13]), -1, 1)); // clamp for floating pt errors
                normals10[i13].applyMatrix4(mat.makeRotationAxis(vec, theta2));
            }
            binormals[i13].crossVectors(tangents[i13], normals10[i13]);
        }
        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
        if (closed1 === true) {
            let theta2 = Math.acos(MathUtils1.clamp(normals10[0].dot(normals10[segments2]), -1, 1));
            theta2 /= segments2;
            if (tangents[0].dot(vec.crossVectors(normals10[0], normals10[segments2])) > 0) theta2 = -theta2;
            for(let i14 = 1; i14 <= segments2; i14++){
                // twist a little...
                normals10[i14].applyMatrix4(mat.makeRotationAxis(tangents[i14], theta2 * i14));
                binormals[i14].crossVectors(tangents[i14], normals10[i14]);
            }
        }
        return {
            tangents: tangents,
            normals: normals10,
            binormals: binormals
        };
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.arcLengthDivisions = source.arcLengthDivisions;
        return this;
    },
    toJSON: function() {
        const data = {
            metadata: {
                version: 4.5,
                type: 'Curve',
                generator: 'Curve.toJSON'
            }
        };
        data.arcLengthDivisions = this.arcLengthDivisions;
        data.type = this.type;
        return data;
    },
    fromJSON: function(json) {
        this.arcLengthDivisions = json.arcLengthDivisions;
        return this;
    }
});
const Curve1 = Curve;
function CubicPoly() {
    let c0 = 0, c12 = 0, c2 = 0, c3 = 0;
    function init(x0, x12, t0, t11) {
        c0 = x0;
        c12 = t0;
        c2 = -3 * x0 + 3 * x12 - 2 * t0 - t11;
        c3 = 2 * x0 - 2 * x12 + t0 + t11;
    }
    return {
        initCatmullRom: function(x0, x12, x22, x32, tension) {
            init(x12, x22, tension * (x22 - x0), tension * (x32 - x12));
        },
        initNonuniformCatmullRom: function(x0, x12, x22, x32, dt0, dt1, dt2) {
            let t11 = (x12 - x0) / dt0 - (x22 - x0) / (dt0 + dt1) + (x22 - x12) / dt1;
            let t21 = (x22 - x12) / dt1 - (x32 - x12) / (dt1 + dt2) + (x32 - x22) / dt2;
            t11 *= dt1;
            t21 *= dt1;
            init(x12, x22, t11, t21);
        },
        calc: function(t3) {
            const t21 = t3 * t3;
            const t3 = t21 * t3;
            return c0 + c12 * t3 + c2 * t21 + c3 * t3;
        }
    };
}
const tmp = new Vector31();
const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
function CatmullRomCurve31(points1, closed1, curveType, tension) {
    Curve1.call(this);
    this.type = 'CatmullRomCurve3';
    this.points = points1 || [];
    this.closed = closed1 || false;
    this.curveType = curveType || 'centripetal';
    this.tension = tension !== undefined ? tension : 0.5;
}
CatmullRomCurve31.prototype = Object.create(Curve1.prototype);
CatmullRomCurve31.prototype.constructor = CatmullRomCurve31;
CatmullRomCurve31.prototype.isCatmullRomCurve3 = true;
CatmullRomCurve31.prototype.getPoint = function(t3, optionalTarget) {
    const point = optionalTarget || new Vector31();
    const points1 = this.points;
    const l2 = points1.length;
    const p2 = (l2 - (this.closed ? 0 : 1)) * t3;
    let intPoint = Math.floor(p2);
    let weight = p2 - intPoint;
    if (this.closed) intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l2) + 1) * l2;
    else if (weight === 0 && intPoint === l2 - 1) {
        intPoint = l2 - 2;
        weight = 1;
    }
    let p0, p3;
    if (this.closed || intPoint > 0) p0 = points1[(intPoint - 1) % l2];
    else {
        tmp.subVectors(points1[0], points1[1]).add(points1[0]);
        p0 = tmp;
    }
    const p11 = points1[intPoint % l2];
    const p2 = points1[(intPoint + 1) % l2];
    if (this.closed || intPoint + 2 < l2) p3 = points1[(intPoint + 2) % l2];
    else {
        tmp.subVectors(points1[l2 - 1], points1[l2 - 2]).add(points1[l2 - 1]);
        p3 = tmp;
    }
    if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
        const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
        let dt0 = Math.pow(p0.distanceToSquared(p11), pow);
        let dt1 = Math.pow(p11.distanceToSquared(p2), pow);
        let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
        if (dt1 < 0.0001) dt1 = 1;
        if (dt0 < 0.0001) dt0 = dt1;
        if (dt2 < 0.0001) dt2 = dt1;
        px.initNonuniformCatmullRom(p0.x, p11.x, p2.x, p3.x, dt0, dt1, dt2);
        py.initNonuniformCatmullRom(p0.y, p11.y, p2.y, p3.y, dt0, dt1, dt2);
        pz.initNonuniformCatmullRom(p0.z, p11.z, p2.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === 'catmullrom') {
        px.initCatmullRom(p0.x, p11.x, p2.x, p3.x, this.tension);
        py.initCatmullRom(p0.y, p11.y, p2.y, p3.y, this.tension);
        pz.initCatmullRom(p0.z, p11.z, p2.z, p3.z, this.tension);
    }
    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point;
};
CatmullRomCurve31.prototype.copy = function(source) {
    Curve1.prototype.copy.call(this, source);
    this.points = [];
    for(let i13 = 0, l2 = source.points.length; i13 < l2; i13++){
        const point = source.points[i13];
        this.points.push(point.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
};
CatmullRomCurve31.prototype.toJSON = function() {
    const data = Curve1.prototype.toJSON.call(this);
    data.points = [];
    for(let i13 = 0, l2 = this.points.length; i13 < l2; i13++){
        const point = this.points[i13];
        data.points.push(point.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
};
CatmullRomCurve31.prototype.fromJSON = function(json) {
    Curve1.prototype.fromJSON.call(this, json);
    this.points = [];
    for(let i13 = 0, l2 = json.points.length; i13 < l2; i13++){
        const point = json.points[i13];
        this.points.push(new Vector31().fromArray(point));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
};
/**
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bzier_curve
 */
function CatmullRom(t3, p0, p11, p2, p3) {
    const v0 = (p2 - p0) * 0.5;
    const v1 = (p3 - p11) * 0.5;
    const t21 = t3 * t3;
    const t3 = t3 * t21;
    return (2 * p11 - 2 * p2 + v0 + v1) * t3 + (-3 * p11 + 3 * p2 - 2 * v0 - v1) * t21 + v0 * t3 + p11;
}
//
function QuadraticBezierP0(t3, p2) {
    const k1 = 1 - t3;
    return k1 * k1 * p2;
}
function QuadraticBezierP1(t3, p2) {
    return 2 * (1 - t3) * t3 * p2;
}
function QuadraticBezierP2(t3, p2) {
    return t3 * t3 * p2;
}
function QuadraticBezier(t3, p0, p11, p2) {
    return QuadraticBezierP0(t3, p0) + QuadraticBezierP1(t3, p11) + QuadraticBezierP2(t3, p2);
}
//
function CubicBezierP0(t3, p2) {
    const k1 = 1 - t3;
    return k1 * k1 * k1 * p2;
}
function CubicBezierP1(t3, p2) {
    const k1 = 1 - t3;
    return 3 * k1 * k1 * t3 * p2;
}
function CubicBezierP2(t3, p2) {
    return 3 * (1 - t3) * t3 * t3 * p2;
}
function CubicBezierP3(t3, p2) {
    return t3 * t3 * t3 * p2;
}
function CubicBezier(t3, p0, p11, p2, p3) {
    return CubicBezierP0(t3, p0) + CubicBezierP1(t3, p11) + CubicBezierP2(t3, p2) + CubicBezierP3(t3, p3);
}
const CatmullRom1 = CatmullRom, QuadraticBezier1 = QuadraticBezier, CubicBezier1 = CubicBezier;
function CubicBezierCurve2(v0, v1, v2, v3) {
    Curve1.call(this);
    this.type = 'CubicBezierCurve';
    this.v0 = v0 || new Vector21();
    this.v1 = v1 || new Vector21();
    this.v2 = v2 || new Vector21();
    this.v3 = v3 || new Vector21();
}
CubicBezierCurve2.prototype = Object.create(Curve1.prototype);
CubicBezierCurve2.prototype.constructor = CubicBezierCurve2;
CubicBezierCurve2.prototype.isCubicBezierCurve = true;
CubicBezierCurve2.prototype.getPoint = function(t3, optionalTarget) {
    const point = optionalTarget || new Vector21();
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier1(t3, v0.x, v1.x, v2.x, v3.x), CubicBezier1(t3, v0.y, v1.y, v2.y, v3.y));
    return point;
};
CubicBezierCurve2.prototype.copy = function(source) {
    Curve1.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
};
CubicBezierCurve2.prototype.toJSON = function() {
    const data = Curve1.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
};
CubicBezierCurve2.prototype.fromJSON = function(json) {
    Curve1.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
};
function CubicBezierCurve31(v0, v1, v2, v3) {
    Curve1.call(this);
    this.type = 'CubicBezierCurve3';
    this.v0 = v0 || new Vector31();
    this.v1 = v1 || new Vector31();
    this.v2 = v2 || new Vector31();
    this.v3 = v3 || new Vector31();
}
CubicBezierCurve31.prototype = Object.create(Curve1.prototype);
CubicBezierCurve31.prototype.constructor = CubicBezierCurve31;
CubicBezierCurve31.prototype.isCubicBezierCurve3 = true;
CubicBezierCurve31.prototype.getPoint = function(t3, optionalTarget) {
    const point = optionalTarget || new Vector31();
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(CubicBezier1(t3, v0.x, v1.x, v2.x, v3.x), CubicBezier1(t3, v0.y, v1.y, v2.y, v3.y), CubicBezier1(t3, v0.z, v1.z, v2.z, v3.z));
    return point;
};
CubicBezierCurve31.prototype.copy = function(source) {
    Curve1.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
};
CubicBezierCurve31.prototype.toJSON = function() {
    const data = Curve1.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
};
CubicBezierCurve31.prototype.fromJSON = function(json) {
    Curve1.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
};
function EllipseCurve5(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    Curve1.call(this);
    this.type = 'EllipseCurve';
    this.aX = aX || 0;
    this.aY = aY || 0;
    this.xRadius = xRadius || 1;
    this.yRadius = yRadius || 1;
    this.aStartAngle = aStartAngle || 0;
    this.aEndAngle = aEndAngle || 2 * Math.PI;
    this.aClockwise = aClockwise || false;
    this.aRotation = aRotation || 0;
}
EllipseCurve5.prototype = Object.create(Curve1.prototype);
EllipseCurve5.prototype.constructor = EllipseCurve5;
EllipseCurve5.prototype.isEllipseCurve = true;
EllipseCurve5.prototype.getPoint = function(t3, optionalTarget) {
    const point = optionalTarget || new Vector21();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while(deltaAngle < 0)deltaAngle += twoPi;
    while(deltaAngle > twoPi)deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
        if (samePoints) deltaAngle = 0;
        else deltaAngle = twoPi;
    }
    if (this.aClockwise === true && !samePoints) {
        if (deltaAngle === twoPi) deltaAngle = -twoPi;
        else deltaAngle = deltaAngle - twoPi;
    }
    const angle = this.aStartAngle + t3 * deltaAngle;
    let x6 = this.aX + this.xRadius * Math.cos(angle);
    let y6 = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
        const cos = Math.cos(this.aRotation);
        const sin = Math.sin(this.aRotation);
        const tx = x6 - this.aX;
        const ty = y6 - this.aY;
        x6 = tx * cos - ty * sin + this.aX;
        y6 = tx * sin + ty * cos + this.aY;
    }
    return point.set(x6, y6);
};
EllipseCurve5.prototype.copy = function(source) {
    Curve1.prototype.copy.call(this, source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
};
EllipseCurve5.prototype.toJSON = function() {
    const data = Curve1.prototype.toJSON.call(this);
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
};
EllipseCurve5.prototype.fromJSON = function(json) {
    Curve1.prototype.fromJSON.call(this, json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
};
const EllipseCurve6 = EllipseCurve5;
function LineCurve2(v1, v2) {
    Curve1.call(this);
    this.type = 'LineCurve';
    this.v1 = v1 || new Vector21();
    this.v2 = v2 || new Vector21();
}
LineCurve2.prototype = Object.create(Curve1.prototype);
LineCurve2.prototype.constructor = LineCurve2;
LineCurve2.prototype.isLineCurve = true;
LineCurve2.prototype.getPoint = function(t3, optionalTarget) {
    const point = optionalTarget || new Vector21();
    if (t3 === 1) point.copy(this.v2);
    else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t3).add(this.v1);
    }
    return point;
};
LineCurve2.prototype.getPointAt = function(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
};
LineCurve2.prototype.getTangent = function(t3, optionalTarget) {
    const tangent = optionalTarget || new Vector21();
    tangent.copy(this.v2).sub(this.v1).normalize();
    return tangent;
};
LineCurve2.prototype.copy = function(source) {
    Curve1.prototype.copy.call(this, source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
LineCurve2.prototype.toJSON = function() {
    const data = Curve1.prototype.toJSON.call(this);
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
LineCurve2.prototype.fromJSON = function(json) {
    Curve1.prototype.fromJSON.call(this, json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function LineCurve31(v1, v2) {
    Curve1.call(this);
    this.type = 'LineCurve3';
    this.v1 = v1 || new Vector31();
    this.v2 = v2 || new Vector31();
}
LineCurve31.prototype = Object.create(Curve1.prototype);
LineCurve31.prototype.constructor = LineCurve31;
LineCurve31.prototype.isLineCurve3 = true;
LineCurve31.prototype.getPoint = function(t3, optionalTarget) {
    const point = optionalTarget || new Vector31();
    if (t3 === 1) point.copy(this.v2);
    else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t3).add(this.v1);
    }
    return point;
};
LineCurve31.prototype.getPointAt = function(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
};
LineCurve31.prototype.copy = function(source) {
    Curve1.prototype.copy.call(this, source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
LineCurve31.prototype.toJSON = function() {
    const data = Curve1.prototype.toJSON.call(this);
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
LineCurve31.prototype.fromJSON = function(json) {
    Curve1.prototype.fromJSON.call(this, json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function QuadraticBezierCurve2(v0, v1, v2) {
    Curve1.call(this);
    this.type = 'QuadraticBezierCurve';
    this.v0 = v0 || new Vector21();
    this.v1 = v1 || new Vector21();
    this.v2 = v2 || new Vector21();
}
QuadraticBezierCurve2.prototype = Object.create(Curve1.prototype);
QuadraticBezierCurve2.prototype.constructor = QuadraticBezierCurve2;
QuadraticBezierCurve2.prototype.isQuadraticBezierCurve = true;
QuadraticBezierCurve2.prototype.getPoint = function(t3, optionalTarget) {
    const point = optionalTarget || new Vector21();
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier1(t3, v0.x, v1.x, v2.x), QuadraticBezier1(t3, v0.y, v1.y, v2.y));
    return point;
};
QuadraticBezierCurve2.prototype.copy = function(source) {
    Curve1.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
QuadraticBezierCurve2.prototype.toJSON = function() {
    const data = Curve1.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
QuadraticBezierCurve2.prototype.fromJSON = function(json) {
    Curve1.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function QuadraticBezierCurve31(v0, v1, v2) {
    Curve1.call(this);
    this.type = 'QuadraticBezierCurve3';
    this.v0 = v0 || new Vector31();
    this.v1 = v1 || new Vector31();
    this.v2 = v2 || new Vector31();
}
QuadraticBezierCurve31.prototype = Object.create(Curve1.prototype);
QuadraticBezierCurve31.prototype.constructor = QuadraticBezierCurve31;
QuadraticBezierCurve31.prototype.isQuadraticBezierCurve3 = true;
QuadraticBezierCurve31.prototype.getPoint = function(t3, optionalTarget) {
    const point = optionalTarget || new Vector31();
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier1(t3, v0.x, v1.x, v2.x), QuadraticBezier1(t3, v0.y, v1.y, v2.y), QuadraticBezier1(t3, v0.z, v1.z, v2.z));
    return point;
};
QuadraticBezierCurve31.prototype.copy = function(source) {
    Curve1.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
};
QuadraticBezierCurve31.prototype.toJSON = function() {
    const data = Curve1.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
};
QuadraticBezierCurve31.prototype.fromJSON = function(json) {
    Curve1.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
};
function SplineCurve2(points1) {
    Curve1.call(this);
    this.type = 'SplineCurve';
    this.points = points1 || [];
}
SplineCurve2.prototype = Object.create(Curve1.prototype);
SplineCurve2.prototype.constructor = SplineCurve2;
SplineCurve2.prototype.isSplineCurve = true;
SplineCurve2.prototype.getPoint = function(t3, optionalTarget) {
    const point = optionalTarget || new Vector21();
    const points1 = this.points;
    const p2 = (points1.length - 1) * t3;
    const intPoint = Math.floor(p2);
    const weight = p2 - intPoint;
    const p0 = points1[intPoint === 0 ? intPoint : intPoint - 1];
    const p11 = points1[intPoint];
    const p2 = points1[intPoint > points1.length - 2 ? points1.length - 1 : intPoint + 1];
    const p3 = points1[intPoint > points1.length - 3 ? points1.length - 1 : intPoint + 2];
    point.set(CatmullRom1(weight, p0.x, p11.x, p2.x, p3.x), CatmullRom1(weight, p0.y, p11.y, p2.y, p3.y));
    return point;
};
SplineCurve2.prototype.copy = function(source) {
    Curve1.prototype.copy.call(this, source);
    this.points = [];
    for(let i13 = 0, l2 = source.points.length; i13 < l2; i13++){
        const point = source.points[i13];
        this.points.push(point.clone());
    }
    return this;
};
SplineCurve2.prototype.toJSON = function() {
    const data = Curve1.prototype.toJSON.call(this);
    data.points = [];
    for(let i13 = 0, l2 = this.points.length; i13 < l2; i13++){
        const point = this.points[i13];
        data.points.push(point.toArray());
    }
    return data;
};
SplineCurve2.prototype.fromJSON = function(json) {
    Curve1.prototype.fromJSON.call(this, json);
    this.points = [];
    for(let i13 = 0, l2 = json.points.length; i13 < l2; i13++){
        const point = json.points[i13];
        this.points.push(new Vector21().fromArray(point));
    }
    return this;
};
function Shape2(points1) {
    Path1.call(this, points1);
    this.uuid = MathUtils1.generateUUID();
    this.type = 'Shape';
    this.holes = [];
}
Shape2.prototype = Object.assign(Object.create(Path1.prototype), {
    constructor: Shape2,
    getPointsHoles: function(divisions2) {
        const holesPts = [];
        for(let i13 = 0, l2 = this.holes.length; i13 < l2; i13++)holesPts[i13] = this.holes[i13].getPoints(divisions2);
        return holesPts;
    },
    extractPoints: function(divisions2) {
        return {
            shape: this.getPoints(divisions2),
            holes: this.getPointsHoles(divisions2)
        };
    },
    copy: function(source) {
        Path1.prototype.copy.call(this, source);
        this.holes = [];
        for(let i13 = 0, l2 = source.holes.length; i13 < l2; i13++){
            const hole = source.holes[i13];
            this.holes.push(hole.clone());
        }
        return this;
    },
    toJSON: function() {
        const data = Path1.prototype.toJSON.call(this);
        data.uuid = this.uuid;
        data.holes = [];
        for(let i13 = 0, l2 = this.holes.length; i13 < l2; i13++){
            const hole = this.holes[i13];
            data.holes.push(hole.toJSON());
        }
        return data;
    },
    fromJSON: function(json) {
        Path1.prototype.fromJSON.call(this, json);
        this.uuid = json.uuid;
        this.holes = [];
        for(let i13 = 0, l2 = json.holes.length; i13 < l2; i13++){
            const hole = json.holes[i13];
            this.holes.push(new Path1().fromJSON(hole));
        }
        return this;
    }
});
const Shape1 = Shape2;
export { Shape1 as Shape };
function CurvePath2() {
    Curve1.call(this);
    this.type = 'CurvePath';
    this.curves = [];
    this.autoClose = false;
}
CurvePath2.prototype = Object.assign(Object.create(Curve1.prototype), {
    constructor: CurvePath2,
    add: function(curve) {
        this.curves.push(curve);
    },
    closePath: function() {
        const startPoint = this.curves[0].getPoint(0);
        const endPoint = this.curves[this.curves.length - 1].getPoint(1);
        if (!startPoint.equals(endPoint)) this.curves.push(new Curves['LineCurve'](endPoint, startPoint));
    },
    getPoint: function(t3) {
        const d = t3 * this.getLength();
        const curveLengths = this.getCurveLengths();
        let i13 = 0;
        while(i13 < curveLengths.length){
            if (curveLengths[i13] >= d) {
                const diff = curveLengths[i13] - d;
                const curve = this.curves[i13];
                const segmentLength = curve.getLength();
                const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                return curve.getPointAt(u);
            }
            i13++;
        }
        return null;
    },
    getLength: function() {
        const lens = this.getCurveLengths();
        return lens[lens.length - 1];
    },
    updateArcLengths: function() {
        this.needsUpdate = true;
        this.cacheLengths = null;
        this.getCurveLengths();
    },
    getCurveLengths: function() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        const lengths = [];
        let sums = 0;
        for(let i13 = 0, l2 = this.curves.length; i13 < l2; i13++){
            sums += this.curves[i13].getLength();
            lengths.push(sums);
        }
        this.cacheLengths = lengths;
        return lengths;
    },
    getSpacedPoints: function(divisions2) {
        if (divisions2 === undefined) divisions2 = 40;
        const points1 = [];
        for(let i13 = 0; i13 <= divisions2; i13++)points1.push(this.getPoint(i13 / divisions2));
        if (this.autoClose) points1.push(points1[0]);
        return points1;
    },
    getPoints: function(divisions2) {
        divisions2 = divisions2 || 12;
        const points1 = [];
        let last;
        for(let i13 = 0, curves = this.curves; i13 < curves.length; i13++){
            const curve = curves[i13];
            const resolution = curve && curve.isEllipseCurve ? divisions2 * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions2 * curve.points.length : divisions2;
            const pts = curve.getPoints(resolution);
            for(let j6 = 0; j6 < pts.length; j6++){
                const point = pts[j6];
                if (last && last.equals(point)) continue;
                points1.push(point);
                last = point;
            }
        }
        if (this.autoClose && points1.length > 1 && !points1[points1.length - 1].equals(points1[0])) points1.push(points1[0]);
        return points1;
    },
    copy: function(source) {
        Curve1.prototype.copy.call(this, source);
        this.curves = [];
        for(let i13 = 0, l2 = source.curves.length; i13 < l2; i13++){
            const curve = source.curves[i13];
            this.curves.push(curve.clone());
        }
        this.autoClose = source.autoClose;
        return this;
    },
    toJSON: function() {
        const data = Curve1.prototype.toJSON.call(this);
        data.autoClose = this.autoClose;
        data.curves = [];
        for(let i13 = 0, l2 = this.curves.length; i13 < l2; i13++){
            const curve = this.curves[i13];
            data.curves.push(curve.toJSON());
        }
        return data;
    },
    fromJSON: function(json) {
        Curve1.prototype.fromJSON.call(this, json);
        this.autoClose = json.autoClose;
        this.curves = [];
        for(let i13 = 0, l2 = json.curves.length; i13 < l2; i13++){
            const curve = json.curves[i13];
            this.curves.push(new Curves[curve.type]().fromJSON(curve));
        }
        return this;
    }
});
const CurvePath1 = CurvePath2;
function EllipseCurve7(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    Curve1.call(this);
    this.type = 'EllipseCurve';
    this.aX = aX || 0;
    this.aY = aY || 0;
    this.xRadius = xRadius || 1;
    this.yRadius = yRadius || 1;
    this.aStartAngle = aStartAngle || 0;
    this.aEndAngle = aEndAngle || 2 * Math.PI;
    this.aClockwise = aClockwise || false;
    this.aRotation = aRotation || 0;
}
EllipseCurve7.prototype = Object.create(Curve1.prototype);
EllipseCurve7.prototype.constructor = EllipseCurve7;
EllipseCurve7.prototype.isEllipseCurve = true;
EllipseCurve7.prototype.getPoint = function(t3, optionalTarget) {
    const point = optionalTarget || new Vector21();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while(deltaAngle < 0)deltaAngle += twoPi;
    while(deltaAngle > twoPi)deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
        if (samePoints) deltaAngle = 0;
        else deltaAngle = twoPi;
    }
    if (this.aClockwise === true && !samePoints) {
        if (deltaAngle === twoPi) deltaAngle = -twoPi;
        else deltaAngle = deltaAngle - twoPi;
    }
    const angle = this.aStartAngle + t3 * deltaAngle;
    let x6 = this.aX + this.xRadius * Math.cos(angle);
    let y6 = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
        const cos = Math.cos(this.aRotation);
        const sin = Math.sin(this.aRotation);
        const tx = x6 - this.aX;
        const ty = y6 - this.aY;
        x6 = tx * cos - ty * sin + this.aX;
        y6 = tx * sin + ty * cos + this.aY;
    }
    return point.set(x6, y6);
};
EllipseCurve7.prototype.copy = function(source) {
    Curve1.prototype.copy.call(this, source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
};
EllipseCurve7.prototype.toJSON = function() {
    const data = Curve1.prototype.toJSON.call(this);
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
};
EllipseCurve7.prototype.fromJSON = function(json) {
    Curve1.prototype.fromJSON.call(this, json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
};
const EllipseCurve3 = EllipseCurve7;
function Path2(points1) {
    CurvePath1.call(this);
    this.type = 'Path';
    this.currentPoint = new Vector21();
    if (points1) this.setFromPoints(points1);
}
Path2.prototype = Object.assign(Object.create(CurvePath1.prototype), {
    constructor: Path2,
    setFromPoints: function(points1) {
        this.moveTo(points1[0].x, points1[0].y);
        for(let i13 = 1, l2 = points1.length; i13 < l2; i13++)this.lineTo(points1[i13].x, points1[i13].y);
        return this;
    },
    moveTo: function(x6, y6) {
        this.currentPoint.set(x6, y6);
        return this;
    },
    lineTo: function(x6, y6) {
        const curve = new LineCurve(this.currentPoint.clone(), new Vector21(x6, y6));
        this.curves.push(curve);
        this.currentPoint.set(x6, y6);
        return this;
    },
    quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
        const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector21(aCPx, aCPy), new Vector21(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
    },
    bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector21(aCP1x, aCP1y), new Vector21(aCP2x, aCP2y), new Vector21(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
    },
    splineThru: function(pts) {
        const npts = [
            this.currentPoint.clone()
        ].concat(pts);
        const curve = new SplineCurve(npts);
        this.curves.push(curve);
        this.currentPoint.copy(pts[pts.length - 1]);
        return this;
    },
    arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
    },
    absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
    },
    ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        return this;
    },
    absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const curve = new EllipseCurve3(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        if (this.curves.length > 0) {
            const firstPoint = curve.getPoint(0);
            if (!firstPoint.equals(this.currentPoint)) this.lineTo(firstPoint.x, firstPoint.y);
        }
        this.curves.push(curve);
        const lastPoint = curve.getPoint(1);
        this.currentPoint.copy(lastPoint);
        return this;
    },
    copy: function(source) {
        CurvePath1.prototype.copy.call(this, source);
        this.currentPoint.copy(source.currentPoint);
        return this;
    },
    toJSON: function() {
        const data = CurvePath1.prototype.toJSON.call(this);
        data.currentPoint = this.currentPoint.toArray();
        return data;
    },
    fromJSON: function(json) {
        CurvePath1.prototype.fromJSON.call(this, json);
        this.currentPoint.fromArray(json.currentPoint);
        return this;
    }
});
const Path1 = Path2;
export { Path1 as Path };
function ShapePath2() {
    this.type = 'ShapePath';
    this.color = new Color1();
    this.subPaths = [];
    this.currentPath = null;
}
Object.assign(ShapePath2.prototype, {
    moveTo: function(x6, y6) {
        this.currentPath = new Path1();
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo(x6, y6);
        return this;
    },
    lineTo: function(x6, y6) {
        this.currentPath.lineTo(x6, y6);
        return this;
    },
    quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        return this;
    },
    bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        return this;
    },
    splineThru: function(pts) {
        this.currentPath.splineThru(pts);
        return this;
    },
    toShapes: function(isCCW, noHoles) {
        function toShapesNoHoles(inSubpaths) {
            const shapes3 = [];
            for(let i13 = 0, l2 = inSubpaths.length; i13 < l2; i13++){
                const tmpPath = inSubpaths[i13];
                const tmpShape = new Shape1();
                tmpShape.curves = tmpPath.curves;
                shapes3.push(tmpShape);
            }
            return shapes3;
        }
        function isPointInsidePolygon(inPt, inPolygon) {
            const polyLen = inPolygon.length;
            let inside = false;
            for(let p2 = polyLen - 1, q2 = 0; q2 < polyLen; p2 = q2++){
                let edgeLowPt = inPolygon[p2];
                let edgeHighPt = inPolygon[q2];
                let edgeDx = edgeHighPt.x - edgeLowPt.x;
                let edgeDy = edgeHighPt.y - edgeLowPt.y;
                if (Math.abs(edgeDy) > Number.EPSILON) {
                    if (edgeDy < 0) {
                        edgeLowPt = inPolygon[q2];
                        edgeDx = -edgeDx;
                        edgeHighPt = inPolygon[p2];
                        edgeDy = -edgeDy;
                    }
                    if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
                    if (inPt.y === edgeLowPt.y) {
                        if (inPt.x === edgeLowPt.x) return true;
                    } else {
                        const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                        if (perpEdge === 0) return true;
                        if (perpEdge < 0) continue;
                        inside = !inside;
                    }
                } else {
                    if (inPt.y !== edgeLowPt.y) continue;
                    if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true;
                }
            }
            return inside;
        }
        const isClockWise = ShapeUtils1.isClockWise;
        const subPaths = this.subPaths;
        if (subPaths.length === 0) return [];
        if (noHoles === true) return toShapesNoHoles(subPaths);
        let solid, tmpPath, tmpShape;
        const shapes3 = [];
        if (subPaths.length === 1) {
            tmpPath = subPaths[0];
            tmpShape = new Shape1();
            tmpShape.curves = tmpPath.curves;
            shapes3.push(tmpShape);
            return shapes3;
        }
        let holesFirst = !isClockWise(subPaths[0].getPoints());
        holesFirst = isCCW ? !holesFirst : holesFirst;
        const betterShapeHoles = [];
        const newShapes = [];
        let newShapeHoles = [];
        let mainIdx = 0;
        let tmpPoints;
        newShapes[mainIdx] = undefined;
        newShapeHoles[mainIdx] = [];
        for(let i13 = 0, l2 = subPaths.length; i13 < l2; i13++){
            tmpPath = subPaths[i13];
            tmpPoints = tmpPath.getPoints();
            solid = isClockWise(tmpPoints);
            solid = isCCW ? !solid : solid;
            if (solid) {
                if (!holesFirst && newShapes[mainIdx]) mainIdx++;
                newShapes[mainIdx] = {
                    s: new Shape1(),
                    p: tmpPoints
                };
                newShapes[mainIdx].s.curves = tmpPath.curves;
                if (holesFirst) mainIdx++;
                newShapeHoles[mainIdx] = [];
            } else newShapeHoles[mainIdx].push({
                h: tmpPath,
                p: tmpPoints[0]
            });
        }
        if (!newShapes[0]) return toShapesNoHoles(subPaths);
        if (newShapes.length > 1) {
            let ambiguous = false;
            const toChange = [];
            for(let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++)betterShapeHoles[sIdx] = [];
            for(let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++){
                const sho = newShapeHoles[sIdx];
                for(let hIdx = 0; hIdx < sho.length; hIdx++){
                    const ho = sho[hIdx];
                    let hole_unassigned = true;
                    for(let s2Idx = 0; s2Idx < newShapes.length; s2Idx++)if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                        if (sIdx !== s2Idx) toChange.push({
                            froms: sIdx,
                            tos: s2Idx,
                            hole: hIdx
                        });
                        if (hole_unassigned) {
                            hole_unassigned = false;
                            betterShapeHoles[s2Idx].push(ho);
                        } else ambiguous = true;
                    }
                    if (hole_unassigned) betterShapeHoles[sIdx].push(ho);
                }
            }
            if (toChange.length > 0) {
                if (!ambiguous) newShapeHoles = betterShapeHoles;
            }
        }
        let tmpHoles;
        for(let i13 = 0, il = newShapes.length; i13 < il; i13++){
            tmpShape = newShapes[i13].s;
            shapes3.push(tmpShape);
            tmpHoles = newShapeHoles[i13];
            for(let j6 = 0, jl = tmpHoles.length; j6 < jl; j6++)tmpShape.holes.push(tmpHoles[j6].h);
        }
        return shapes3;
    }
});
const ShapePath1 = ShapePath2;
export { ShapePath1 as ShapePath };
function ShapePath3() {
    this.type = 'ShapePath';
    this.color = new Color1();
    this.subPaths = [];
    this.currentPath = null;
}
Object.assign(ShapePath3.prototype, {
    moveTo: function(x6, y6) {
        this.currentPath = new Path1();
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo(x6, y6);
        return this;
    },
    lineTo: function(x6, y6) {
        this.currentPath.lineTo(x6, y6);
        return this;
    },
    quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        return this;
    },
    bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        return this;
    },
    splineThru: function(pts) {
        this.currentPath.splineThru(pts);
        return this;
    },
    toShapes: function(isCCW, noHoles) {
        function toShapesNoHoles(inSubpaths) {
            const shapes3 = [];
            for(let i13 = 0, l2 = inSubpaths.length; i13 < l2; i13++){
                const tmpPath = inSubpaths[i13];
                const tmpShape = new Shape1();
                tmpShape.curves = tmpPath.curves;
                shapes3.push(tmpShape);
            }
            return shapes3;
        }
        function isPointInsidePolygon(inPt, inPolygon) {
            const polyLen = inPolygon.length;
            let inside = false;
            for(let p2 = polyLen - 1, q2 = 0; q2 < polyLen; p2 = q2++){
                let edgeLowPt = inPolygon[p2];
                let edgeHighPt = inPolygon[q2];
                let edgeDx = edgeHighPt.x - edgeLowPt.x;
                let edgeDy = edgeHighPt.y - edgeLowPt.y;
                if (Math.abs(edgeDy) > Number.EPSILON) {
                    if (edgeDy < 0) {
                        edgeLowPt = inPolygon[q2];
                        edgeDx = -edgeDx;
                        edgeHighPt = inPolygon[p2];
                        edgeDy = -edgeDy;
                    }
                    if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
                    if (inPt.y === edgeLowPt.y) {
                        if (inPt.x === edgeLowPt.x) return true;
                    } else {
                        const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                        if (perpEdge === 0) return true;
                        if (perpEdge < 0) continue;
                        inside = !inside;
                    }
                } else {
                    if (inPt.y !== edgeLowPt.y) continue;
                    if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true;
                }
            }
            return inside;
        }
        const isClockWise = ShapeUtils1.isClockWise;
        const subPaths = this.subPaths;
        if (subPaths.length === 0) return [];
        if (noHoles === true) return toShapesNoHoles(subPaths);
        let solid, tmpPath, tmpShape;
        const shapes3 = [];
        if (subPaths.length === 1) {
            tmpPath = subPaths[0];
            tmpShape = new Shape1();
            tmpShape.curves = tmpPath.curves;
            shapes3.push(tmpShape);
            return shapes3;
        }
        let holesFirst = !isClockWise(subPaths[0].getPoints());
        holesFirst = isCCW ? !holesFirst : holesFirst;
        const betterShapeHoles = [];
        const newShapes = [];
        let newShapeHoles = [];
        let mainIdx = 0;
        let tmpPoints;
        newShapes[mainIdx] = undefined;
        newShapeHoles[mainIdx] = [];
        for(let i13 = 0, l2 = subPaths.length; i13 < l2; i13++){
            tmpPath = subPaths[i13];
            tmpPoints = tmpPath.getPoints();
            solid = isClockWise(tmpPoints);
            solid = isCCW ? !solid : solid;
            if (solid) {
                if (!holesFirst && newShapes[mainIdx]) mainIdx++;
                newShapes[mainIdx] = {
                    s: new Shape1(),
                    p: tmpPoints
                };
                newShapes[mainIdx].s.curves = tmpPath.curves;
                if (holesFirst) mainIdx++;
                newShapeHoles[mainIdx] = [];
            } else newShapeHoles[mainIdx].push({
                h: tmpPath,
                p: tmpPoints[0]
            });
        }
        if (!newShapes[0]) return toShapesNoHoles(subPaths);
        if (newShapes.length > 1) {
            let ambiguous = false;
            const toChange = [];
            for(let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++)betterShapeHoles[sIdx] = [];
            for(let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++){
                const sho = newShapeHoles[sIdx];
                for(let hIdx = 0; hIdx < sho.length; hIdx++){
                    const ho = sho[hIdx];
                    let hole_unassigned = true;
                    for(let s2Idx = 0; s2Idx < newShapes.length; s2Idx++)if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                        if (sIdx !== s2Idx) toChange.push({
                            froms: sIdx,
                            tos: s2Idx,
                            hole: hIdx
                        });
                        if (hole_unassigned) {
                            hole_unassigned = false;
                            betterShapeHoles[s2Idx].push(ho);
                        } else ambiguous = true;
                    }
                    if (hole_unassigned) betterShapeHoles[sIdx].push(ho);
                }
            }
            if (toChange.length > 0) {
                if (!ambiguous) newShapeHoles = betterShapeHoles;
            }
        }
        let tmpHoles;
        for(let i13 = 0, il = newShapes.length; i13 < il; i13++){
            tmpShape = newShapes[i13].s;
            shapes3.push(tmpShape);
            tmpHoles = newShapeHoles[i13];
            for(let j6 = 0, jl = tmpHoles.length; j6 < jl; j6++)tmpShape.holes.push(tmpHoles[j6].h);
        }
        return shapes3;
    }
});
const ShapePath1 = ShapePath3;
function Font2(data) {
    this.type = 'Font';
    this.data = data;
}
Object.assign(Font2.prototype, {
    isFont: true,
    generateShapes: function(text1, size5) {
        if (size5 === undefined) size5 = 100;
        const shapes3 = [];
        const paths = createPaths(text1, size5, this.data);
        for(let p2 = 0, pl = paths.length; p2 < pl; p2++)Array.prototype.push.apply(shapes3, paths[p2].toShapes());
        return shapes3;
    }
});
function createPaths(text1, size5, data) {
    const chars = Array.from ? Array.from(text1) : String(text1).split('');
    const scale = size5 / data.resolution;
    const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
    const paths = [];
    let offsetX = 0, offsetY = 0;
    for(let i13 = 0; i13 < chars.length; i13++){
        const char = chars[i13];
        if (char === '\n') {
            offsetX = 0;
            offsetY -= line_height;
        } else {
            const ret = createPath(char, scale, offsetX, offsetY, data);
            offsetX += ret.offsetX;
            paths.push(ret.path);
        }
    }
    return paths;
}
function createPath(char, scale, offsetX, offsetY, data) {
    const glyph = data.glyphs[char] || data.glyphs['?'];
    if (!glyph) {
        console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
        return;
    }
    const path1 = new ShapePath1();
    let x6, y6, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
    if (glyph.o) {
        const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
        for(let i13 = 0, l2 = outline.length; i13 < l2;){
            const action = outline[i13++];
            switch(action){
                case 'm':
                    x6 = outline[i13++] * scale + offsetX;
                    y6 = outline[i13++] * scale + offsetY;
                    path1.moveTo(x6, y6);
                    break;
                case 'l':
                    x6 = outline[i13++] * scale + offsetX;
                    y6 = outline[i13++] * scale + offsetY;
                    path1.lineTo(x6, y6);
                    break;
                case 'q':
                    cpx = outline[i13++] * scale + offsetX;
                    cpy = outline[i13++] * scale + offsetY;
                    cpx1 = outline[i13++] * scale + offsetX;
                    cpy1 = outline[i13++] * scale + offsetY;
                    path1.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                    break;
                case 'b':
                    cpx = outline[i13++] * scale + offsetX;
                    cpy = outline[i13++] * scale + offsetY;
                    cpx1 = outline[i13++] * scale + offsetX;
                    cpy1 = outline[i13++] * scale + offsetY;
                    cpx2 = outline[i13++] * scale + offsetX;
                    cpy2 = outline[i13++] * scale + offsetY;
                    path1.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                    break;
            }
        }
    }
    return {
        offsetX: glyph.ha * scale,
        path: path1
    };
}
const Font1 = Font2;
export { Font1 as Font };
function CurvePath3() {
    Curve1.call(this);
    this.type = 'CurvePath';
    this.curves = [];
    this.autoClose = false;
}
CurvePath3.prototype = Object.assign(Object.create(Curve1.prototype), {
    constructor: CurvePath3,
    add: function(curve) {
        this.curves.push(curve);
    },
    closePath: function() {
        const startPoint = this.curves[0].getPoint(0);
        const endPoint = this.curves[this.curves.length - 1].getPoint(1);
        if (!startPoint.equals(endPoint)) this.curves.push(new Curves['LineCurve'](endPoint, startPoint));
    },
    getPoint: function(t3) {
        const d = t3 * this.getLength();
        const curveLengths = this.getCurveLengths();
        let i13 = 0;
        while(i13 < curveLengths.length){
            if (curveLengths[i13] >= d) {
                const diff = curveLengths[i13] - d;
                const curve = this.curves[i13];
                const segmentLength = curve.getLength();
                const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                return curve.getPointAt(u);
            }
            i13++;
        }
        return null;
    },
    getLength: function() {
        const lens = this.getCurveLengths();
        return lens[lens.length - 1];
    },
    updateArcLengths: function() {
        this.needsUpdate = true;
        this.cacheLengths = null;
        this.getCurveLengths();
    },
    getCurveLengths: function() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        const lengths = [];
        let sums = 0;
        for(let i13 = 0, l2 = this.curves.length; i13 < l2; i13++){
            sums += this.curves[i13].getLength();
            lengths.push(sums);
        }
        this.cacheLengths = lengths;
        return lengths;
    },
    getSpacedPoints: function(divisions2) {
        if (divisions2 === undefined) divisions2 = 40;
        const points1 = [];
        for(let i13 = 0; i13 <= divisions2; i13++)points1.push(this.getPoint(i13 / divisions2));
        if (this.autoClose) points1.push(points1[0]);
        return points1;
    },
    getPoints: function(divisions2) {
        divisions2 = divisions2 || 12;
        const points1 = [];
        let last;
        for(let i13 = 0, curves = this.curves; i13 < curves.length; i13++){
            const curve = curves[i13];
            const resolution = curve && curve.isEllipseCurve ? divisions2 * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions2 * curve.points.length : divisions2;
            const pts = curve.getPoints(resolution);
            for(let j6 = 0; j6 < pts.length; j6++){
                const point = pts[j6];
                if (last && last.equals(point)) continue;
                points1.push(point);
                last = point;
            }
        }
        if (this.autoClose && points1.length > 1 && !points1[points1.length - 1].equals(points1[0])) points1.push(points1[0]);
        return points1;
    },
    copy: function(source) {
        Curve1.prototype.copy.call(this, source);
        this.curves = [];
        for(let i13 = 0, l2 = source.curves.length; i13 < l2; i13++){
            const curve = source.curves[i13];
            this.curves.push(curve.clone());
        }
        this.autoClose = source.autoClose;
        return this;
    },
    toJSON: function() {
        const data = Curve1.prototype.toJSON.call(this);
        data.autoClose = this.autoClose;
        data.curves = [];
        for(let i13 = 0, l2 = this.curves.length; i13 < l2; i13++){
            const curve = this.curves[i13];
            data.curves.push(curve.toJSON());
        }
        return data;
    },
    fromJSON: function(json) {
        Curve1.prototype.fromJSON.call(this, json);
        this.autoClose = json.autoClose;
        this.curves = [];
        for(let i13 = 0, l2 = json.curves.length; i13 < l2; i13++){
            const curve = json.curves[i13];
            this.curves.push(new Curves[curve.type]().fromJSON(curve));
        }
        return this;
    }
});
const CurvePath1 = CurvePath3;
export { CurvePath1 as CurvePath };
function Curve2() {
    this.type = 'Curve';
    this.arcLengthDivisions = 200;
}
Object.assign(Curve2.prototype, {
    getPoint: function() {
        console.warn('THREE.Curve: .getPoint() not implemented.');
        return null;
    },
    getPointAt: function(u, optionalTarget) {
        const t3 = this.getUtoTmapping(u);
        return this.getPoint(t3, optionalTarget);
    },
    getPoints: function(divisions2) {
        if (divisions2 === undefined) divisions2 = 5;
        const points1 = [];
        for(let d = 0; d <= divisions2; d++)points1.push(this.getPoint(d / divisions2));
        return points1;
    },
    getSpacedPoints: function(divisions2) {
        if (divisions2 === undefined) divisions2 = 5;
        const points1 = [];
        for(let d = 0; d <= divisions2; d++)points1.push(this.getPointAt(d / divisions2));
        return points1;
    },
    getLength: function() {
        const lengths = this.getLengths();
        return lengths[lengths.length - 1];
    },
    getLengths: function(divisions2) {
        if (divisions2 === undefined) divisions2 = this.arcLengthDivisions;
        if (this.cacheArcLengths && this.cacheArcLengths.length === divisions2 + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = false;
        const cache = [];
        let current, last = this.getPoint(0);
        let sum = 0;
        cache.push(0);
        for(let p2 = 1; p2 <= divisions2; p2++){
            current = this.getPoint(p2 / divisions2);
            sum += current.distanceTo(last);
            cache.push(sum);
            last = current;
        }
        this.cacheArcLengths = cache;
        return cache;
    },
    updateArcLengths: function() {
        this.needsUpdate = true;
        this.getLengths();
    },
    getUtoTmapping: function(u, distance) {
        const arcLengths = this.getLengths();
        let i13 = 0;
        const il = arcLengths.length;
        let targetArcLength;
        if (distance) targetArcLength = distance;
        else targetArcLength = u * arcLengths[il - 1];
        let low = 0, high = il - 1, comparison;
        while(low <= high){
            i13 = Math.floor(low + (high - low) / 2);
            comparison = arcLengths[i13] - targetArcLength;
            if (comparison < 0) low = i13 + 1;
            else if (comparison > 0) high = i13 - 1;
            else {
                high = i13;
                break;
            }
        }
        i13 = high;
        if (arcLengths[i13] === targetArcLength) return i13 / (il - 1);
        const lengthBefore = arcLengths[i13];
        const lengthAfter = arcLengths[i13 + 1];
        const segmentLength = lengthAfter - lengthBefore;
        const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
        const t3 = (i13 + segmentFraction) / (il - 1);
        return t3;
    },
    getTangent: function(t3, optionalTarget) {
        const delta = 0.0001;
        let t11 = t3 - delta;
        let t21 = t3 + delta;
        if (t11 < 0) t11 = 0;
        if (t21 > 1) t21 = 1;
        const pt1 = this.getPoint(t11);
        const pt2 = this.getPoint(t21);
        const tangent = optionalTarget || (pt1.isVector2 ? new Vector21() : new Vector31());
        tangent.copy(pt2).sub(pt1).normalize();
        return tangent;
    },
    getTangentAt: function(u, optionalTarget) {
        const t3 = this.getUtoTmapping(u);
        return this.getTangent(t3, optionalTarget);
    },
    computeFrenetFrames: function(segments2, closed1) {
        const normal6 = new Vector31();
        const tangents = [];
        const normals10 = [];
        const binormals = [];
        const vec = new Vector31();
        const mat = new Matrix41();
        for(let i13 = 0; i13 <= segments2; i13++){
            const u = i13 / segments2;
            tangents[i13] = this.getTangentAt(u, new Vector31());
            tangents[i13].normalize();
        }
        normals10[0] = new Vector31();
        binormals[0] = new Vector31();
        let min = Number.MAX_VALUE;
        const tx = Math.abs(tangents[0].x);
        const ty = Math.abs(tangents[0].y);
        const tz = Math.abs(tangents[0].z);
        if (tx <= min) {
            min = tx;
            normal6.set(1, 0, 0);
        }
        if (ty <= min) {
            min = ty;
            normal6.set(0, 1, 0);
        }
        if (tz <= min) normal6.set(0, 0, 1);
        vec.crossVectors(tangents[0], normal6).normalize();
        normals10[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals10[0]);
        for(let i13 = 1; i13 <= segments2; i13++){
            normals10[i13] = normals10[i13 - 1].clone();
            binormals[i13] = binormals[i13 - 1].clone();
            vec.crossVectors(tangents[i13 - 1], tangents[i13]);
            if (vec.length() > Number.EPSILON) {
                vec.normalize();
                const theta2 = Math.acos(MathUtils1.clamp(tangents[i13 - 1].dot(tangents[i13]), -1, 1));
                normals10[i13].applyMatrix4(mat.makeRotationAxis(vec, theta2));
            }
            binormals[i13].crossVectors(tangents[i13], normals10[i13]);
        }
        if (closed1 === true) {
            let theta2 = Math.acos(MathUtils1.clamp(normals10[0].dot(normals10[segments2]), -1, 1));
            theta2 /= segments2;
            if (tangents[0].dot(vec.crossVectors(normals10[0], normals10[segments2])) > 0) theta2 = -theta2;
            for(let i14 = 1; i14 <= segments2; i14++){
                normals10[i14].applyMatrix4(mat.makeRotationAxis(tangents[i14], theta2 * i14));
                binormals[i14].crossVectors(tangents[i14], normals10[i14]);
            }
        }
        return {
            tangents: tangents,
            normals: normals10,
            binormals: binormals
        };
    },
    clone: function() {
        return new this.constructor().copy(this);
    },
    copy: function(source) {
        this.arcLengthDivisions = source.arcLengthDivisions;
        return this;
    },
    toJSON: function() {
        const data = {
            metadata: {
                version: 4.5,
                type: 'Curve',
                generator: 'Curve.toJSON'
            }
        };
        data.arcLengthDivisions = this.arcLengthDivisions;
        data.type = this.type;
        return data;
    },
    fromJSON: function(json) {
        this.arcLengthDivisions = json.arcLengthDivisions;
        return this;
    }
});
const Curve1 = Curve2;
export { Curve1 as Curve };
let _canvas;
const ImageUtils3 = {
    getDataURL: function(image) {
        if (/^data:/i.test(image.src)) return image.src;
        if (typeof HTMLCanvasElement == 'undefined') return image.src;
        let canvas;
        if (image instanceof HTMLCanvasElement) canvas = image;
        else {
            if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
            _canvas.width = image.width;
            _canvas.height = image.height;
            const context = _canvas.getContext('2d');
            if (image instanceof ImageData) context.putImageData(image, 0, 0);
            else context.drawImage(image, 0, 0, image.width, image.height);
            canvas = _canvas;
        }
        if (canvas.width > 2048 || canvas.height > 2048) return canvas.toDataURL('image/jpeg', 0.6);
        else return canvas.toDataURL('image/png');
    }
};
const ImageUtils1 = ImageUtils3;
export { ImageUtils1 as ImageUtils };
const Earcut2 = {
    triangulate: function(data, holeIndices, dim) {
        dim = dim || 2;
        const hasHoles = holeIndices && holeIndices.length;
        const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        let outerNode = linkedList(data, 0, outerLen, dim, true);
        const triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev) return triangles;
        let minX, minY, maxX, maxY, x6, y6, invSize;
        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for(let i13 = dim; i13 < outerLen; i13 += dim){
                x6 = data[i13];
                y6 = data[i13 + 1];
                if (x6 < minX) minX = x6;
                if (y6 < minY) minY = y6;
                if (x6 > maxX) maxX = x6;
                if (y6 > maxY) maxY = y6;
            }
            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
    }
};
function linkedList(data, start, end, dim, clockwise) {
    let i13, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) for(i13 = start; i13 < end; i13 += dim)last = insertNode(i13, data[i13], data[i13 + 1], last);
    else for(i13 = end - dim; i13 >= start; i13 -= dim)last = insertNode(i13, data[i13], data[i13 + 1], last);
    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }
    return last;
}
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    let p2 = start, again;
    do {
        again = false;
        if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
            removeNode(p2);
            p2 = end = p2.prev;
            if (p2 === p2.next) break;
            again = true;
        } else p2 = p2.next;
    }while (again || p2 !== end)
    return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    let stop = ear, prev, next;
    while(ear.prev !== ear.next){
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
        }
        ear = next;
        if (ear === stop) {
            if (!pass) earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            else if (pass === 1) {
                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) splitEarcut(ear, triangles, dim, minX, minY, invSize);
            break;
        }
    }
}
function isEar(ear) {
    const a2 = ear.prev, b2 = ear, c2 = ear.next;
    if (area(a2, b2, c2) >= 0) return false;
    let p2 = ear.next.next;
    while(p2 !== ear.prev){
        if (pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
        p2 = p2.next;
    }
    return true;
}
function isEarHashed(ear, minX, minY, invSize) {
    const a2 = ear.prev, b2 = ear, c2 = ear.next;
    if (area(a2, b2, c2) >= 0) return false;
    const minTX = a2.x < b2.x ? a2.x < c2.x ? a2.x : c2.x : b2.x < c2.x ? b2.x : c2.x, minTY = a2.y < b2.y ? a2.y < c2.y ? a2.y : c2.y : b2.y < c2.y ? b2.y : c2.y, maxTX = a2.x > b2.x ? a2.x > c2.x ? a2.x : c2.x : b2.x > c2.x ? b2.x : c2.x, maxTY = a2.y > b2.y ? a2.y > c2.y ? a2.y : c2.y : b2.y > c2.y ? b2.y : c2.y;
    const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    let p2 = ear.prevZ, n = ear.nextZ;
    while(p2 && p2.z >= minZ && n && n.z <= maxZ){
        if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
        p2 = p2.prevZ;
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    while(p2 && p2.z >= minZ){
        if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
        p2 = p2.prevZ;
    }
    while(n && n.z <= maxZ){
        if (n !== ear.prev && n !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }
    return true;
}
function cureLocalIntersections(start, triangles, dim) {
    let p2 = start;
    do {
        const a2 = p2.prev, b2 = p2.next.next;
        if (!equals(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
            triangles.push(a2.i / dim);
            triangles.push(p2.i / dim);
            triangles.push(b2.i / dim);
            removeNode(p2);
            removeNode(p2.next);
            p2 = start = b2;
        }
        p2 = p2.next;
    }while (p2 !== start)
    return filterPoints(p2);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    let a2 = start;
    do {
        let b2 = a2.next.next;
        while(b2 !== a2.prev){
            if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
                let c2 = splitPolygon(a2, b2);
                a2 = filterPoints(a2, a2.next);
                c2 = filterPoints(c2, c2.next);
                earcutLinked(a2, triangles, dim, minX, minY, invSize);
                earcutLinked(c2, triangles, dim, minX, minY, invSize);
                return;
            }
            b2 = b2.next;
        }
        a2 = a2.next;
    }while (a2 !== start)
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
    const queue = [];
    let i13, len, start, end, list;
    for(i13 = 0, len = holeIndices.length; i13 < len; i13++){
        start = holeIndices[i13] * dim;
        end = i13 < len - 1 ? holeIndices[i13 + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for(i13 = 0; i13 < queue.length; i13++){
        eliminateHole(queue[i13], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
}
function compareX(a2, b2) {
    return a2.x - b2.x;
}
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        const b2 = splitPolygon(outerNode, hole);
        filterPoints(outerNode, outerNode.next);
        filterPoints(b2, b2.next);
    }
}
function findHoleBridge(hole, outerNode) {
    let p2 = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity, m;
    do {
        if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
            const x6 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
            if (x6 <= hx && x6 > qx) {
                qx = x6;
                if (x6 === hx) {
                    if (hy === p2.y) return p2;
                    if (hy === p2.next.y) return p2.next;
                }
                m = p2.x < p2.next.x ? p2 : p2.next;
            }
        }
        p2 = p2.next;
    }while (p2 !== outerNode)
    if (!m) return null;
    if (hx === qx) return m;
    const stop = m, mx = m.x, my = m.y;
    let tanMin = Infinity, tan;
    p2 = m;
    do {
        if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
            tan = Math.abs(hy - p2.y) / (hx - p2.x);
            if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m.x || p2.x === m.x && sectorContainsSector(m, p2)))) {
                m = p2;
                tanMin = tan;
            }
        }
        p2 = p2.next;
    }while (p2 !== stop)
    return m;
}
function sectorContainsSector(m, p2) {
    return area(m.prev, m, p2.prev) < 0 && area(p2.next, m, m.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
    let p2 = start;
    do {
        if (p2.z === null) p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
        p2.prevZ = p2.prev;
        p2.nextZ = p2.next;
        p2 = p2.next;
    }while (p2 !== start)
    p2.prevZ.nextZ = null;
    p2.prevZ = null;
    sortLinked(p2);
}
function sortLinked(list) {
    let i13, p2, q2, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
        p2 = list;
        list = null;
        tail = null;
        numMerges = 0;
        while(p2){
            numMerges++;
            q2 = p2;
            pSize = 0;
            for(i13 = 0; i13 < inSize; i13++){
                pSize++;
                q2 = q2.nextZ;
                if (!q2) break;
            }
            qSize = inSize;
            while(pSize > 0 || qSize > 0 && q2){
                if (pSize !== 0 && (qSize === 0 || !q2 || p2.z <= q2.z)) {
                    e = p2;
                    p2 = p2.nextZ;
                    pSize--;
                } else {
                    e = q2;
                    q2 = q2.nextZ;
                    qSize--;
                }
                if (tail) tail.nextZ = e;
                else list = e;
                e.prevZ = tail;
                tail = e;
            }
            p2 = q2;
        }
        tail.nextZ = null;
        inSize *= 2;
    }while (numMerges > 1)
    return list;
}
function zOrder(x6, y6, minX, minY, invSize) {
    x6 = 32767 * (x6 - minX) * invSize;
    y6 = 32767 * (y6 - minY) * invSize;
    x6 = (x6 | x6 << 8) & 16711935;
    x6 = (x6 | x6 << 4) & 252645135;
    x6 = (x6 | x6 << 2) & 858993459;
    x6 = (x6 | x6 << 1) & 1431655765;
    y6 = (y6 | y6 << 8) & 16711935;
    y6 = (y6 | y6 << 4) & 252645135;
    y6 = (y6 | y6 << 2) & 858993459;
    y6 = (y6 | y6 << 1) & 1431655765;
    return x6 | y6 << 1;
}
function getLeftmost(start) {
    let p2 = start, leftmost = start;
    do {
        if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y) leftmost = p2;
        p2 = p2.next;
    }while (p2 !== start)
    return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px1, py1) {
    return (cx - px1) * (ay - py1) - (ax - px1) * (cy - py1) >= 0 && (ax - px1) * (by - py1) - (bx - px1) * (ay - py1) >= 0 && (bx - px1) * (cy - py1) - (cx - px1) * (by - py1) >= 0;
}
function isValidDiagonal(a2, b2) {
    return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
}
function area(p2, q2, r2) {
    return (q2.y - p2.y) * (r2.x - q2.x) - (q2.x - p2.x) * (r2.y - q2.y);
}
function equals(p11, p2) {
    return p11.x === p2.x && p11.y === p2.y;
}
function intersects(p11, q11, p2, q2) {
    const o1 = sign(area(p11, q11, p2));
    const o2 = sign(area(p11, q11, q2));
    const o3 = sign(area(p2, q2, p11));
    const o4 = sign(area(p2, q2, q11));
    if (o1 !== o2 && o3 !== o4) return true;
    if (o1 === 0 && onSegment(p11, p2, q11)) return true;
    if (o2 === 0 && onSegment(p11, q2, q11)) return true;
    if (o3 === 0 && onSegment(p2, p11, q2)) return true;
    if (o4 === 0 && onSegment(p2, q11, q2)) return true;
    return false;
}
function onSegment(p2, q2, r2) {
    return q2.x <= Math.max(p2.x, r2.x) && q2.x >= Math.min(p2.x, r2.x) && q2.y <= Math.max(p2.y, r2.y) && q2.y >= Math.min(p2.y, r2.y);
}
function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a2, b2) {
    let p2 = a2;
    do {
        if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2)) return true;
        p2 = p2.next;
    }while (p2 !== a2)
    return false;
}
function locallyInside(a2, b2) {
    return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
}
function middleInside(a2, b2) {
    let p2 = a2, inside = false;
    const px1 = (a2.x + b2.x) / 2, py1 = (a2.y + b2.y) / 2;
    do {
        if (p2.y > py1 !== p2.next.y > py1 && p2.next.y !== p2.y && px1 < (p2.next.x - p2.x) * (py1 - p2.y) / (p2.next.y - p2.y) + p2.x) inside = !inside;
        p2 = p2.next;
    }while (p2 !== a2)
    return inside;
}
function splitPolygon(a2, b2) {
    const a2 = new Node1(a2.i, a2.x, a2.y), b2 = new Node1(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
    a2.next = b2;
    b2.prev = a2;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
}
function insertNode(i13, x6, y6, last) {
    const p2 = new Node1(i13, x6, y6);
    if (!last) {
        p2.prev = p2;
        p2.next = p2;
    } else {
        p2.next = last.next;
        p2.prev = last;
        last.next.prev = p2;
        last.next = p2;
    }
    return p2;
}
function removeNode(p2) {
    p2.next.prev = p2.prev;
    p2.prev.next = p2.next;
    if (p2.prevZ) p2.prevZ.nextZ = p2.nextZ;
    if (p2.nextZ) p2.nextZ.prevZ = p2.prevZ;
}
function Node1(i13, x6, y6) {
    this.i = i13;
    this.x = x6;
    this.y = y6;
    this.prev = null;
    this.next = null;
    this.z = null;
    this.prevZ = null;
    this.nextZ = null;
    this.steiner = false;
}
function signedArea(data, start, end, dim) {
    let sum = 0;
    for(let i13 = start, j6 = end - dim; i13 < end; i13 += dim){
        sum += (data[j6] - data[i13]) * (data[i13 + 1] + data[j6 + 1]);
        j6 = i13;
    }
    return sum;
}
const Earcut1 = Earcut2;
const ShapeUtils2 = {
    area: function(contour) {
        const n = contour.length;
        let a2 = 0;
        for(let p2 = n - 1, q2 = 0; q2 < n; p2 = q2++)a2 += contour[p2].x * contour[q2].y - contour[q2].x * contour[p2].y;
        return a2 * 0.5;
    },
    isClockWise: function(pts) {
        return ShapeUtils2.area(pts) < 0;
    },
    triangulateShape: function(contour, holes) {
        const vertices23 = [];
        const holeIndices = [];
        const faces = [];
        removeDupEndPts(contour);
        addContour(vertices23, contour);
        let holeIndex = contour.length;
        holes.forEach(removeDupEndPts);
        for(let i13 = 0; i13 < holes.length; i13++){
            holeIndices.push(holeIndex);
            holeIndex += holes[i13].length;
            addContour(vertices23, holes[i13]);
        }
        const triangles = Earcut1.triangulate(vertices23, holeIndices);
        for(let i13 = 0; i13 < triangles.length; i13 += 3)faces.push(triangles.slice(i13, i13 + 3));
        return faces;
    }
};
function removeDupEndPts(points1) {
    const l2 = points1.length;
    if (l2 > 2 && points1[l2 - 1].equals(points1[0])) points1.pop();
}
function addContour(vertices23, contour) {
    for(let i13 = 0; i13 < contour.length; i13++){
        vertices23.push(contour[i13].x);
        vertices23.push(contour[i13].y);
    }
}
const ShapeUtils1 = ShapeUtils2;
export { ShapeUtils1 as ShapeUtils };
function RawShaderMaterial1(parameters1) {
    ShaderMaterial1.call(this, parameters1);
    this.type = 'RawShaderMaterial';
}
RawShaderMaterial1.prototype = Object.create(ShaderMaterial1.prototype);
RawShaderMaterial1.prototype.constructor = RawShaderMaterial1;
RawShaderMaterial1.prototype.isRawShaderMaterial = true;
const RawShaderMaterial2 = RawShaderMaterial1;
const LOD_MIN = 4;
const LOD_MAX = 8;
const SIZE_MAX = Math.pow(2, LOD_MAX);
// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [
    0.125,
    0.215,
    0.35,
    0.446,
    0.526,
    0.582
];
const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;
const ENCODINGS = {
    [LinearEncoding]: 0,
    [sRGBEncoding]: 1,
    [RGBEEncoding]: 2,
    [RGBM7Encoding]: 3,
    [RGBM16Encoding]: 4,
    [RGBDEncoding]: 5,
    [GammaEncoding]: 6
};
const _flatCamera = new OrthographicCamera1();
const { _lodPlanes , _sizeLods , _sigmas  } = _createPlanes();
let _oldTarget = null;
// Golden Ratio
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;
// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const _axisDirections = [
    new Vector31(1, 1, 1),
    new Vector31(-1, 1, 1),
    new Vector31(1, 1, -1),
    new Vector31(-1, 1, -1),
    new Vector31(0, PHI, INV_PHI),
    new Vector31(0, PHI, -INV_PHI),
    new Vector31(INV_PHI, 0, PHI),
    new Vector31(-INV_PHI, 0, PHI),
    new Vector31(PHI, INV_PHI, 0),
    new Vector31(-PHI, INV_PHI, 0)
];
/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 */
class PMREMGenerator {
    /**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */
    fromScene(scene, sigma = 0, near = 0.1, far = 100) {
        _oldTarget = this._renderer.getRenderTarget();
        const cubeUVRenderTarget = this._allocateTargets();
        this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
        if (sigma > 0) this._blur(cubeUVRenderTarget, 0, 0, sigma);
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
    }
    /**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */
    fromEquirectangular(equirectangular) {
        return this._fromTexture(equirectangular);
    }
    /**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */
    fromCubemap(cubemap) {
        return this._fromTexture(cubemap);
    }
    /**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
    compileCubemapShader() {
        if (this._cubemapShader === null) {
            this._cubemapShader = _getCubemapShader();
            this._compileMaterial(this._cubemapShader);
        }
    }
    /**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
    compileEquirectangularShader() {
        if (this._equirectShader === null) {
            this._equirectShader = _getEquirectShader();
            this._compileMaterial(this._equirectShader);
        }
    }
    /**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */
    dispose() {
        this._blurMaterial.dispose();
        if (this._cubemapShader !== null) this._cubemapShader.dispose();
        if (this._equirectShader !== null) this._equirectShader.dispose();
        for(let i13 = 0; i13 < _lodPlanes.length; i13++)_lodPlanes[i13].dispose();
    }
    // private interface
    _cleanup(outputTarget) {
        this._pingPongRenderTarget.dispose();
        this._renderer.setRenderTarget(_oldTarget);
        outputTarget.scissorTest = false;
        _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
    }
    _fromTexture(texture) {
        _oldTarget = this._renderer.getRenderTarget();
        const cubeUVRenderTarget = this._allocateTargets(texture);
        this._textureToCubeUV(texture, cubeUVRenderTarget);
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
    }
    _allocateTargets(texture) {
        const params = {
            magFilter: NearestFilter,
            minFilter: NearestFilter,
            generateMipmaps: false,
            type: UnsignedByteType,
            format: RGBEFormat,
            encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
            depthBuffer: false,
            stencilBuffer: false
        };
        const cubeUVRenderTarget = _createRenderTarget(params);
        cubeUVRenderTarget.depthBuffer = texture ? false : true;
        this._pingPongRenderTarget = _createRenderTarget(params);
        return cubeUVRenderTarget;
    }
    _compileMaterial(material) {
        const tmpMesh = new Mesh1(_lodPlanes[0], material);
        this._renderer.compile(tmpMesh, _flatCamera);
    }
    _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
        const fov1 = 90;
        const aspect1 = 1;
        const cubeCamera = new PerspectiveCamera1(fov1, aspect1, near, far);
        const upSign = [
            1,
            -1,
            1,
            1,
            1,
            1
        ];
        const forwardSign = [
            1,
            1,
            1,
            -1,
            -1,
            -1
        ];
        const renderer = this._renderer;
        const outputEncoding = renderer.outputEncoding;
        const toneMapping = renderer.toneMapping;
        const clearColor = renderer.getClearColor();
        const clearAlpha = renderer.getClearAlpha();
        renderer.toneMapping = NoToneMapping;
        renderer.outputEncoding = LinearEncoding;
        let background = scene.background;
        if (background && background.isColor) {
            background.convertSRGBToLinear();
            // Convert linear to RGBE
            const maxComponent = Math.max(background.r, background.g, background.b);
            const fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128), 127);
            background = background.multiplyScalar(Math.pow(2, -fExp));
            const alpha = (fExp + 128) / 255;
            renderer.setClearColor(background, alpha);
            scene.background = null;
        }
        for(let i13 = 0; i13 < 6; i13++){
            const col = i13 % 3;
            if (col == 0) {
                cubeCamera.up.set(0, upSign[i13], 0);
                cubeCamera.lookAt(forwardSign[i13], 0, 0);
            } else if (col == 1) {
                cubeCamera.up.set(0, 0, upSign[i13]);
                cubeCamera.lookAt(0, forwardSign[i13], 0);
            } else {
                cubeCamera.up.set(0, upSign[i13], 0);
                cubeCamera.lookAt(0, 0, forwardSign[i13]);
            }
            _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i13 > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);
            renderer.setRenderTarget(cubeUVRenderTarget);
            renderer.render(scene, cubeCamera);
        }
        renderer.toneMapping = toneMapping;
        renderer.outputEncoding = outputEncoding;
        renderer.setClearColor(clearColor, clearAlpha);
    }
    _textureToCubeUV(texture, cubeUVRenderTarget) {
        const renderer = this._renderer;
        if (texture.isCubeTexture) {
            if (this._cubemapShader == null) this._cubemapShader = _getCubemapShader();
        } else if (this._equirectShader == null) this._equirectShader = _getEquirectShader();
        const material9 = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
        const mesh = new Mesh1(_lodPlanes[0], material9);
        const uniforms = material9.uniforms;
        uniforms['envMap'].value = texture;
        if (!texture.isCubeTexture) uniforms['texelSize'].value.set(1 / texture.image.width, 1 / texture.image.height);
        uniforms['inputEncoding'].value = ENCODINGS[texture.encoding];
        uniforms['outputEncoding'].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];
        _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);
        renderer.setRenderTarget(cubeUVRenderTarget);
        renderer.render(mesh, _flatCamera);
    }
    _applyPMREM(cubeUVRenderTarget) {
        const renderer = this._renderer;
        const autoClear = renderer.autoClear;
        renderer.autoClear = false;
        for(let i13 = 1; i13 < TOTAL_LODS; i13++){
            const sigma = Math.sqrt(_sigmas[i13] * _sigmas[i13] - _sigmas[i13 - 1] * _sigmas[i13 - 1]);
            const poleAxis = _axisDirections[(i13 - 1) % _axisDirections.length];
            this._blur(cubeUVRenderTarget, i13 - 1, i13, sigma, poleAxis);
        }
        renderer.autoClear = autoClear;
    }
    /**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */
    _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
        const pingPongRenderTarget = this._pingPongRenderTarget;
        this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);
        this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
    }
    _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
        const renderer = this._renderer;
        const blurMaterial = this._blurMaterial;
        if (direction !== 'latitudinal' && direction !== 'longitudinal') console.error('blur direction must be either latitudinal or longitudinal!');
        // Number of standard deviations at which to cut off the discrete approximation.
        const STANDARD_DEVIATIONS = 3;
        const blurMesh = new Mesh1(_lodPlanes[lodOut], blurMaterial);
        const blurUniforms = blurMaterial.uniforms;
        const pixels = _sizeLods[lodIn] - 1;
        const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
        const sigmaPixels = sigmaRadians / radiansPerPixel;
        const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
        if (samples > MAX_SAMPLES) console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
        const weights = [];
        let sum = 0;
        for(let i13 = 0; i13 < MAX_SAMPLES; ++i13){
            const x6 = i13 / sigmaPixels;
            const weight = Math.exp(-x6 * x6 / 2);
            weights.push(weight);
            if (i13 == 0) sum += weight;
            else if (i13 < samples) sum += 2 * weight;
        }
        for(let i13 = 0; i13 < weights.length; i13++)weights[i13] = weights[i13] / sum;
        blurUniforms['envMap'].value = targetIn.texture;
        blurUniforms['samples'].value = samples;
        blurUniforms['weights'].value = weights;
        blurUniforms['latitudinal'].value = direction === 'latitudinal';
        if (poleAxis) blurUniforms['poleAxis'].value = poleAxis;
        blurUniforms['dTheta'].value = radiansPerPixel;
        blurUniforms['mipInt'].value = LOD_MAX - lodIn;
        blurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
        blurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
        const outputSize = _sizeLods[lodOut];
        const x6 = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
        const y6 = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);
        _setViewport(targetOut, x6, y6, 3 * outputSize, 2 * outputSize);
        renderer.setRenderTarget(targetOut);
        renderer.render(blurMesh, _flatCamera);
    }
    constructor(renderer){
        this._renderer = renderer;
        this._pingPongRenderTarget = null;
        this._blurMaterial = _getBlurShader(MAX_SAMPLES);
        this._equirectShader = null;
        this._cubemapShader = null;
        this._compileMaterial(this._blurMaterial);
    }
}
function _isLDR(texture) {
    if (texture === undefined || texture.type !== UnsignedByteType) return false;
    return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
}
function _createPlanes() {
    const _lodPlanes1 = [];
    const _sizeLods1 = [];
    const _sigmas1 = [];
    let lod = LOD_MAX;
    for(let i13 = 0; i13 < TOTAL_LODS; i13++){
        const sizeLod = Math.pow(2, lod);
        _sizeLods1.push(sizeLod);
        let sigma = 1 / sizeLod;
        if (i13 > LOD_MAX - LOD_MIN) sigma = EXTRA_LOD_SIGMA[i13 - LOD_MAX + LOD_MIN - 1];
        else if (i13 == 0) sigma = 0;
        _sigmas1.push(sigma);
        const texelSize = 1 / (sizeLod - 1);
        const min = -texelSize / 2;
        const max = 1 + texelSize / 2;
        const uv11 = [
            min,
            min,
            max,
            min,
            max,
            max,
            min,
            min,
            max,
            max,
            min,
            max
        ];
        const cubeFaces = 6;
        const vertices23 = 6;
        const positionSize = 3;
        const uvSize = 2;
        const faceIndexSize = 1;
        const position1 = new Float32Array(positionSize * vertices23 * cubeFaces);
        const uv4 = new Float32Array(uvSize * vertices23 * cubeFaces);
        const faceIndex = new Float32Array(faceIndexSize * vertices23 * cubeFaces);
        for(let face = 0; face < cubeFaces; face++){
            const x6 = face % 3 * 2 / 3 - 1;
            const y6 = face > 2 ? 0 : -1;
            const coordinates = [
                x6,
                y6,
                0,
                x6 + 2 / 3,
                y6,
                0,
                x6 + 2 / 3,
                y6 + 1,
                0,
                x6,
                y6,
                0,
                x6 + 2 / 3,
                y6 + 1,
                0,
                x6,
                y6 + 1,
                0
            ];
            position1.set(coordinates, positionSize * vertices23 * face);
            uv4.set(uv11, uvSize * vertices23 * face);
            const fill = [
                face,
                face,
                face,
                face,
                face,
                face
            ];
            faceIndex.set(fill, faceIndexSize * vertices23 * face);
        }
        const planes = new BufferGeometry1();
        planes.setAttribute('position', new BufferAttribute1(position1, positionSize));
        planes.setAttribute('uv', new BufferAttribute1(uv4, uvSize));
        planes.setAttribute('faceIndex', new BufferAttribute1(faceIndex, faceIndexSize));
        _lodPlanes1.push(planes);
        if (lod > LOD_MIN) lod--;
    }
    return {
        _lodPlanes: _lodPlanes1,
        _sizeLods: _sizeLods1,
        _sigmas: _sigmas1
    };
}
function _createRenderTarget(params) {
    const cubeUVRenderTarget = new WebGLRenderTarget1(3 * SIZE_MAX, 3 * SIZE_MAX, params);
    cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
    cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
    cubeUVRenderTarget.scissorTest = true;
    return cubeUVRenderTarget;
}
function _setViewport(target, x6, y6, width2, height3) {
    target.viewport.set(x6, y6, width2, height3);
    target.scissor.set(x6, y6, width2, height3);
}
function _getBlurShader(maxSamples) {
    const weights = new Float32Array(maxSamples);
    const poleAxis = new Vector31(0, 1, 0);
    const shaderMaterial = new RawShaderMaterial2({
        name: 'SphericalGaussianBlur',
        defines: {
            'n': maxSamples
        },
        uniforms: {
            'envMap': {
                value: null
            },
            'samples': {
                value: 1
            },
            'weights': {
                value: weights
            },
            'latitudinal': {
                value: false
            },
            'dTheta': {
                value: 0
            },
            'mipInt': {
                value: 0
            },
            'poleAxis': {
                value: poleAxis
            },
            'inputEncoding': {
                value: ENCODINGS[LinearEncoding]
            },
            'outputEncoding': {
                value: ENCODINGS[LinearEncoding]
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: /* glsl */
        `\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n			uniform int samples;\n			uniform float weights[ n ];\n			uniform bool latitudinal;\n			uniform float dTheta;\n			uniform float mipInt;\n			uniform vec3 poleAxis;\n\n			${_getEncodings()}\n\n			#define ENVMAP_TYPE_CUBE_UV\n			#include <cube_uv_reflection_fragment>\n\n			vec3 getSample( float theta, vec3 axis ) {\n\n				float cosTheta = cos( theta );\n				// Rodrigues' axis-angle rotation\n				vec3 sampleDirection = vOutputDirection * cosTheta\n					+ cross( axis, vOutputDirection ) * sin( theta )\n					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n				return bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n			}\n\n			void main() {\n\n				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n				}\n\n				axis = normalize( axis );\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n				for ( int i = 1; i < n; i++ ) {\n\n					if ( i >= samples ) {\n\n						break;\n\n					}\n\n					float theta = dTheta * float( i );\n					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n				}\n\n				gl_FragColor = linearToOutputTexel( gl_FragColor );\n\n			}\n		`,
        blending: NoBlending,
        depthTest: false,
        depthWrite: false
    });
    return shaderMaterial;
}
function _getEquirectShader() {
    const texelSize = new Vector21(1, 1);
    const shaderMaterial = new RawShaderMaterial2({
        name: 'EquirectangularToCubeUV',
        uniforms: {
            'envMap': {
                value: null
            },
            'texelSize': {
                value: texelSize
            },
            'inputEncoding': {
                value: ENCODINGS[LinearEncoding]
            },
            'outputEncoding': {
                value: ENCODINGS[LinearEncoding]
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: /* glsl */
        `\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n			uniform vec2 texelSize;\n\n			${_getEncodings()}\n\n			#include <common>\n\n			void main() {\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n				vec3 outputDirection = normalize( vOutputDirection );\n				vec2 uv = equirectUv( outputDirection );\n\n				vec2 f = fract( uv / texelSize - 0.5 );\n				uv -= f * texelSize;\n				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n				uv.x += texelSize.x;\n				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n				uv.y += texelSize.y;\n				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n				uv.x -= texelSize.x;\n				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n				vec3 tm = mix( tl, tr, f.x );\n				vec3 bm = mix( bl, br, f.x );\n				gl_FragColor.rgb = mix( tm, bm, f.y );\n\n				gl_FragColor = linearToOutputTexel( gl_FragColor );\n\n			}\n		`,
        blending: NoBlending,
        depthTest: false,
        depthWrite: false
    });
    return shaderMaterial;
}
function _getCubemapShader() {
    const shaderMaterial = new RawShaderMaterial2({
        name: 'CubemapToCubeUV',
        uniforms: {
            'envMap': {
                value: null
            },
            'inputEncoding': {
                value: ENCODINGS[LinearEncoding]
            },
            'outputEncoding': {
                value: ENCODINGS[LinearEncoding]
            }
        },
        vertexShader: _getCommonVertexShader(),
        fragmentShader: /* glsl */
        `\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform samplerCube envMap;\n\n			${_getEncodings()}\n\n			void main() {\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n				gl_FragColor = linearToOutputTexel( gl_FragColor );\n\n			}\n		`,
        blending: NoBlending,
        depthTest: false,
        depthWrite: false
    });
    return shaderMaterial;
}
function _getCommonVertexShader() {
    return( /* glsl */
    `\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute vec3 position;\n		attribute vec2 uv;\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	`);
}
function _getEncodings() {
    return( /* glsl */
    `\n\n		uniform int inputEncoding;\n		uniform int outputEncoding;\n\n		#include <encodings_pars_fragment>\n\n		vec4 inputTexelToLinear( vec4 value ) {\n\n			if ( inputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( inputEncoding == 1 ) {\n\n				return sRGBToLinear( value );\n\n			} else if ( inputEncoding == 2 ) {\n\n				return RGBEToLinear( value );\n\n			} else if ( inputEncoding == 3 ) {\n\n				return RGBMToLinear( value, 7.0 );\n\n			} else if ( inputEncoding == 4 ) {\n\n				return RGBMToLinear( value, 16.0 );\n\n			} else if ( inputEncoding == 5 ) {\n\n				return RGBDToLinear( value, 256.0 );\n\n			} else {\n\n				return GammaToLinear( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 linearToOutputTexel( vec4 value ) {\n\n			if ( outputEncoding == 0 ) {\n\n				return value;\n\n			} else if ( outputEncoding == 1 ) {\n\n				return LinearTosRGB( value );\n\n			} else if ( outputEncoding == 2 ) {\n\n				return LinearToRGBE( value );\n\n			} else if ( outputEncoding == 3 ) {\n\n				return LinearToRGBM( value, 7.0 );\n\n			} else if ( outputEncoding == 4 ) {\n\n				return LinearToRGBM( value, 16.0 );\n\n			} else if ( outputEncoding == 5 ) {\n\n				return LinearToRGBD( value, 256.0 );\n\n			} else {\n\n				return LinearToGamma( value, 2.2 );\n\n			}\n\n		}\n\n		vec4 envMapTexelToLinear( vec4 color ) {\n\n			return inputTexelToLinear( color );\n\n		}\n	`);
}
const PMREMGenerator1 = PMREMGenerator;
export { PMREMGenerator1 as PMREMGenerator };
function WebGLUtils3(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function convert(p2) {
        let extension;
        if (p2 === UnsignedByteType) return gl.UNSIGNED_BYTE;
        if (p2 === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
        if (p2 === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
        if (p2 === UnsignedShort565Type) return gl.UNSIGNED_SHORT_5_6_5;
        if (p2 === ByteType) return gl.BYTE;
        if (p2 === ShortType) return gl.SHORT;
        if (p2 === UnsignedShortType) return gl.UNSIGNED_SHORT;
        if (p2 === IntType) return gl.INT;
        if (p2 === UnsignedIntType) return gl.UNSIGNED_INT;
        if (p2 === FloatType) return gl.FLOAT;
        if (p2 === HalfFloatType) {
            if (isWebGL2) return gl.HALF_FLOAT;
            extension = extensions.get('OES_texture_half_float');
            if (extension !== null) return extension.HALF_FLOAT_OES;
            else return null;
        }
        if (p2 === AlphaFormat) return gl.ALPHA;
        if (p2 === RGBFormat) return gl.RGB;
        if (p2 === RGBAFormat) return gl.RGBA;
        if (p2 === LuminanceFormat) return gl.LUMINANCE;
        if (p2 === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
        if (p2 === DepthFormat) return gl.DEPTH_COMPONENT;
        if (p2 === DepthStencilFormat) return gl.DEPTH_STENCIL;
        if (p2 === RedFormat) return gl.RED;
        if (p2 === RedIntegerFormat) return gl.RED_INTEGER;
        if (p2 === RGFormat) return gl.RG;
        if (p2 === RGIntegerFormat) return gl.RG_INTEGER;
        if (p2 === RGBIntegerFormat) return gl.RGB_INTEGER;
        if (p2 === RGBAIntegerFormat) return gl.RGBA_INTEGER;
        if (p2 === RGB_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT3_Format || p2 === RGBA_S3TC_DXT5_Format) {
            extension = extensions.get('WEBGL_compressed_texture_s3tc');
            if (extension !== null) {
                if (p2 === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (p2 === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (p2 === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (p2 === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else return null;
        }
        if (p2 === RGB_PVRTC_4BPPV1_Format || p2 === RGB_PVRTC_2BPPV1_Format || p2 === RGBA_PVRTC_4BPPV1_Format || p2 === RGBA_PVRTC_2BPPV1_Format) {
            extension = extensions.get('WEBGL_compressed_texture_pvrtc');
            if (extension !== null) {
                if (p2 === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (p2 === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (p2 === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (p2 === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            } else return null;
        }
        if (p2 === RGB_ETC1_Format) {
            extension = extensions.get('WEBGL_compressed_texture_etc1');
            if (extension !== null) return extension.COMPRESSED_RGB_ETC1_WEBGL;
            else return null;
        }
        if (p2 === RGB_ETC2_Format || p2 === RGBA_ETC2_EAC_Format) {
            extension = extensions.get('WEBGL_compressed_texture_etc');
            if (extension !== null) {
                if (p2 === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;
                if (p2 === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;
            }
        }
        if (p2 === RGBA_ASTC_4x4_Format || p2 === RGBA_ASTC_5x4_Format || p2 === RGBA_ASTC_5x5_Format || p2 === RGBA_ASTC_6x5_Format || p2 === RGBA_ASTC_6x6_Format || p2 === RGBA_ASTC_8x5_Format || p2 === RGBA_ASTC_8x6_Format || p2 === RGBA_ASTC_8x8_Format || p2 === RGBA_ASTC_10x5_Format || p2 === RGBA_ASTC_10x6_Format || p2 === RGBA_ASTC_10x8_Format || p2 === RGBA_ASTC_10x10_Format || p2 === RGBA_ASTC_12x10_Format || p2 === RGBA_ASTC_12x12_Format || p2 === SRGB8_ALPHA8_ASTC_4x4_Format || p2 === SRGB8_ALPHA8_ASTC_5x4_Format || p2 === SRGB8_ALPHA8_ASTC_5x5_Format || p2 === SRGB8_ALPHA8_ASTC_6x5_Format || p2 === SRGB8_ALPHA8_ASTC_6x6_Format || p2 === SRGB8_ALPHA8_ASTC_8x5_Format || p2 === SRGB8_ALPHA8_ASTC_8x6_Format || p2 === SRGB8_ALPHA8_ASTC_8x8_Format || p2 === SRGB8_ALPHA8_ASTC_10x5_Format || p2 === SRGB8_ALPHA8_ASTC_10x6_Format || p2 === SRGB8_ALPHA8_ASTC_10x8_Format || p2 === SRGB8_ALPHA8_ASTC_10x10_Format || p2 === SRGB8_ALPHA8_ASTC_12x10_Format || p2 === SRGB8_ALPHA8_ASTC_12x12_Format) {
            extension = extensions.get('WEBGL_compressed_texture_astc');
            if (extension !== null) return p2;
            else return null;
        }
        if (p2 === RGBA_BPTC_Format) {
            extension = extensions.get('EXT_texture_compression_bptc');
            if (extension !== null) return p2;
            else return null;
        }
        if (p2 === UnsignedInt248Type) {
            if (isWebGL2) return gl.UNSIGNED_INT_24_8;
            extension = extensions.get('WEBGL_depth_texture');
            if (extension !== null) return extension.UNSIGNED_INT_24_8_WEBGL;
            else return null;
        }
    }
    return {
        convert: convert
    };
}
const WebGLUtils1 = WebGLUtils3;
export { WebGLUtils1 as WebGLUtils };
